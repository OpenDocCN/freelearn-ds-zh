["```py\neasy_install <package name>\n```", "```py\npip install <package name>\n```", "```py\n>>> import sys\n>>> sys.path[-1]\n'C:\\\\Python34\\\\lib\\\\site-packages'\n```", "```py\n>> sys.path\n['', 'C:\\\\WINDOWS\\\\system32\\\\python34.zip', 'C:\\\\Python34\\\\DLLs',\n'C:\\\\Python34\\\\lib', 'C:\\\\Python34\\\\lib\\\\plat-win\n', 'C:\\\\Python34\\\\lib\\\\lib-tk', 'C:\\\\Python34',\n'C:\\\\Python34\\\\lib\\\\site-packages']\n```", "```py\npip install virtualenv\n```", "```py\nmkdir geospatial_projects\n```", "```py\nvirtualenv geospatial_projects/project1\n```", "```py\nsource geospatial_projects/project1/bin/activate\n```", "```py\ndeactivate\n```", "```py\nPython 3.4.2 (v3.4.2:ab2c023a9432, Oct 6 2014, 22:15:05) [MSC v.1600\n32 bit (Intel)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more\ninformation.\n```", "```py\npip install GDAL-1.11.3-cp34-none-win32.whl\n```", "```py\nPython 3.4.2 (v3.4.2:ab2c023a9432, Oct 6 2014, 22:15:05) [MSC v.1600 32 bit (Intel)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> from osgeo import gdal\n>>> gdal.__version__\n1.11.3\n```", "```py\nsudo apt-get install gdal-bin\n```", "```py\nsudo apt-get install python3-gdal\n```", "```py\n>>> from osgeo import gdal\n>>> from osgeo import ogr\n```", "```py\n>>> import urllib.request\n>>> import urllib.parse\n>>> import urllib.error\n>>> url = \"https://github.com/GeospatialPython/\nLearn/raw/master/hancock.zip\"\n>>> fileName = \"hancock.zip\"\n>>> urllib.request.urlretrieve(url, fileName)\n('hancock.zip', <httplib.HTTPMessage instance at 0x00CAD378>)\n```", "```py\n>>> url = \"http://earthquake.usgs.gov/earthquakes/feed/v1.0/\nsummary/all_hour.csv\"\n>>> earthquakes = urllib.request.urlopen(url)\n>>> earthquakes.readline()\n'time,latitude,longitude,depth,mag,magType,nst,gap,dmin,rms,net,\nid,updated,place\n\\n'\n>>> earthquakes.readline()\n'2013-06-14T14:37:57.000Z,64.8405,-147.6478,13.1,0.6,Ml,\n6,180,0.09701805,0.2,ak,\nak10739050,2013-06-14T14:39:09.442Z,\"3km E of Fairbanks,\nAlaska\"\\n'\n```", "```py\n>>> for record in earthquakes: print(record)\n2013-06-14T14:30:40.000Z,62.0828,-145.2995,22.5,1.6,\nMl,8,108,0.08174669,0.86,ak,\nak10739046,2013-06-14T14:37:02.318Z,\"13km ESE of Glennallen,\nAlaska\"\n...\n2013-06-14T13:42:46.300Z,38.8162,-122.8148,3.5,0.6,\nMd,,126,0.00898315,0.07,nc,nc\n72008115,2013-06-14T13:53:11.592Z,\"6km NW of The Geysers,\nCalifornia\"\n```", "```py\npip install requests\n```", "```py\nimport requests\n```", "```py\nurl = \"https://github.com/GeospatialPython/Learning/raw/master/hancock.zip\"\nfileName = \"hancock.zip\"\n```", "```py\nr = requests.get(url)\n```", "```py\nwith open(fileName, 'wb') as f:\n f.write(r.content)\n```", "```py\nimport ftplib\n\nserver = \"ftp.ngdc.noaa.gov\"\ndir = \"hazards/DART/20070815_peru\"\nfileName = \"21415_from_20070727_08_55_15_tides.txt\"\nftp = ftplib.FTP(server)\nftp.login()\nftp.cwd(dir)\n\nwith open(fileName, \"wb\") as out:\n    ftp.retrbinary(\"RETR \" + fileName, out.write)\n\nwith open(fileName) as dart:\n for line in dart:\n     if \"LAT, \" in line:\n     print(line)\n     break\n```", "```py\n LAT,   LON      50.1663    171.8360\n```", "```py\nftp://username:password@server/directory/file\n```", "```py\n>>> dart = urllib.request.urlopen(\"ftp://\" + server + \"/\" + dir +\n\"/\" + fileName)\n>>> for line in dart:\n... line = str(line, encoding=\"utf8\")\n... if \"LAT,\" in line:\n... print(line)\n... break\n...\nLAT, LON 50.1663 171.8360\n```", "```py\n>>> import zipfile\n>>> zip = open(\"hancock.zip\", \"rb\")\n>>> zipShape = zipfile.ZipFile(zip)\n>>> shpName, shxName, dbfName = zipShape.namelist()\n>>> shpFile = open(shpName, \"wb\")\n>>> shxFile = open(shxName, \"wb\")\n>>> dbfFile = open(dbfName, \"wb\")\n>>> shpFile.write(zipShape.read(shpName))\n>>> shxFile.write(zipShape.read(shxName))\n>>> dbfFile.write(zipShape.read(dbfName))\n>>> shpFile.close()\n>>> shxFile.close()\n>>> dbfFile.close()\n```", "```py\n>>> import zipfile\n>>> zip = open(\"hancock.zip\", \"rb\")\n>>> zipShape = zipfile.ZipFile(zip)\n>>> for fileName in zipShape.namelist():\n... out = open(fileName, \"wb\")\n... out.write(zipShape.read(fileName))\n... out.close()\n>>>\n```", "```py\n>>> import tarfile\n>>> tar = tarfile.open(\"hancock.tar.gz\", \"w:gz\")\n>>> tar.add(\"hancock.shp\")\n>>> tar.add(\"hancock.shx\")\n>>> tar.add(\"hancock.dbf\")\n>>> tar.close()\n```", "```py\n>>> tar = tarfile.open(\"hancock.tar.gz\", \"r:gz\")\n>>> tar.extractall()\n>>> tar.close()\n```", "```py\n>>> import urllib.request\n>>> import urllib.parse\n>>> import urllib.error\n>>> import zipfile\n>>> import io\n>>> import struct\n>>> url =\n\"https://github.com/GeospatialPython/Learn/raw/master/hancock.zip\"\n>>> cloudshape = urllib.request.urlopen(url)\n>>> memoryshape = io.BytesIO(cloudshape.read())\n>>> zipshape = zipfile.ZipFile(memoryshape)\n>>> cloudshp = zipshape.read(\"hancock.shp\")\n# Access Python string as an array\n>>> struct.unpack(\"<dddd\", cloudshp[36:68])\n(-89.6904544701547, 30.173943486533133, -89.32227546981174,\n30.6483914869749)\n```", "```py\n>>> from xml.dom import minidom\n>>> kml = minidom.parse(\"time-stamp-point.kml\")\n>>> Placemarks = kml.getElementsByTagName(\"Placemark\")\n>>> len(Placemarks)\n361\n```", "```py\n>>> Placemarks[0]\n<DOM Element: Placemark at 0x2045a30>\n```", "```py\n>>> Placemarks[0].toxml()\nu'<Placemark>\\n <TimeStamp>\\n \\<when>2007-01-14T21:05:02Z</when>\\n\n</TimeStamp>\\n <styleUrl>#paddle-a</styleUrl>\\n <Point>\\n\n<coordinates>-122.536226,37.86047,0</coordinates>\\n\n</Point>\\n </Placemark>'\n```", "```py\n>>> coordinates =\nPlacemarks[0].getElementsByTagName(\"coordinates\")\n>>> point = coordinates[0].firstChild.data\n>>> point\nu'-122.536226,37.86047,0'\n```", "```py\n>>> x,y,z = point.split(\",\")\n>>> x\nu'-122.536226'\n>>> y\nu'37.86047'\n>>> z\nu'0'\n>>> x = float(x)\n>>> y = float(y)\n>>> z = float(z)\n>>> x,y,z\n(-122.536226, 37.86047, 0.0)\n```", "```py\n>>> x,y,z = [float(c) for c in point.split(\",\")]\n>>> x,y,z\n(-122.536226, 37.86047, 0.0)\n```", "```py\ntry:\n    import xml.etree.cElementTree as ET\nexcept ImportError:\n    import xml.etree.ElementTree as ET\n```", "```py\n>>> tree = ET.ElementTree(file=\"time-stamp-point.kml\")\n>>> ns = \"{http://www.opengis.net/kml/2.2}\"\n>>> placemark = tree.find(\".//%sPlacemark\" % ns)\n>>> coordinates =\nplacemark.find(\"./{}Point/{}coordinates\".format(ns, ns))\n>>> coordinates.text\n'-122.536226,37.86047,0'\n```", "```py\nxml = \"<?xml version=\"1.0\" encoding=\"utf-8\"?>\"\nxml += \"<kml >\"\nxml += \" <Placemark>\"\nxml += \" <name>Office</name>\"\nxml += \" <description>Office Building</description>\"\nxml += \" <Point>\"\nxml += \" <coordinates>\"\nxml += \" -122.087461,37.422069\"\nxml += \" </coordinates>\"\nxml += \" </Point>\"\nxml += \" </Placemark>\"\nxml += \"</kml>\"\n```", "```py\n>>> root = ET.Element(\"kml\")\n>>> root.attrib[\"xmlns\"] = \"http://www.opengis.net/kml/2.2\"\n>>> placemark = ET.SubElement(root, \"Placemark\")\n>>> office = ET.SubElement(placemark, \"name\")\n>>> office.text = \"Office\"\n>>> point = ET.SubElement(placemark, \"Point\")\n>>> coordinates = ET.SubElement(point, \"coordinates\")\n>>> coordinates.text = \"-122.087461,37.422069, 37.422069\"\n>>> tree = ET.ElementTree(root)\n>>> tree.write(\"placemark.kml\",\nxml_declaration=True,encoding='utf-8',method=\"xml\")\n```", "```py\neasy_install beautifulsoup4\n```", "```py\npip install beautifulsoup4\n```", "```py\n>>> from bs4 import BeautifulSoup\n```", "```py\n>>> gpx = minidom.parse(\"broken_data.gpx\")\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nFile \"C:\\Python34\\lib\\xml\\dom\\minidom.py\", line 1914, in parse\nreturn expatbuilder.parse(file)\nFile \"C:\\Python34\\lib\\xml\\dom\\expatbuilder.py\", line 924, in\nparse\nresult = builder.parseFile(fp)\nFile \"C:\\Python34\\lib\\xml\\dom\\expatbuilder.py\", line 207, in\nparseFile\nparser.Parse(buffer, 0)\nxml.parsers.expat.ExpatError: mismatched tag: line 2346, column 2\n```", "```py\n>>> ET.ElementTree(file=\"broken_data.gpx\")\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nFile \"C:\\Python34\\lib\\xml\\etree\\ElementTree.py\", line 611, in\n__init__\nself.parse(file)\nFile \"C:\\Python34\\lib\\xml\\etree\\ElementTree.py\", line 653, in\nparse\nparser.feed(data)\nFile \"C:\\Python34\\lib\\xml\\etree\\ElementTree.py\", line 1624, in\nfeed\nself._raiseerror(v)\nFile \"C:\\Python34\\lib\\xml\\etree\\ElementTree.py\", line 1488, in\n_raiseerror\nraise err\nxml.etree.ElementTree.ParseError: mismatched tag: line 2346,\ncolumn 2\n```", "```py\n>>> from bs4 import BeautifulSoup\n>>> gpx = open(\"broken_data.gpx\")\n>>> soup = BeautifulSoup(gpx.read(), features=\"xml\")\n>>>\n```", "```py\n>>> soup.trkpt\n<trkpt lat=\"30.307267000\" lon=\"-89.332444000\">\n<ele>10.7</ele><time>2013-05-16T04:39:46Z</time></trkpt>\n```", "```py\n>>> tracks = soup.findAll(\"trkpt\")\n>>> len(tracks)\n2321\n```", "```py\n>>> fixed = open(\"fixed_data.gpx\", \"w\")\n>>> fixed.write(soup.prettify())\n>>> fixed.close()\n```", "```py\nPOLYGON((0 0,4 0,4 4,0 4,0 0),(1 1, 2 1, 2 2, 1 2,1 1))\n```", "```py\n>>> import shapely.wkt\n>>> wktPoly = \"POLYGON((0 0,4 0,4 4,0 4,0 0),(1 1, 2 1, 2 2, 1 2,\n1 1))\"\n>>> poly = shapely.wkt.loads(wktPoly)\n>>> poly.area\n15.0\n```", "```py\n>>> poly.wkt\n'POLYGON ((0.0 0.0, 4.0 0.0, 4.0 4.0, 0.0 4.0, 0.0 0.0), (1.0 1.0,\n2.0 1.0, 2.0 2.0, 1.0 2.0, 1.0 1.0))'\n```", "```py\n>>> from osgeo import ogr\n>>> shape = ogr.Open(\"polygon.shp\")\n>>> layer = shape.GetLayer()\n>>> feature = layer.GetNextFeature()\n>>> geom = feature.GetGeometryRef()\n>>> wkt = geom.ExportToWkt()\n>>> wkt\n' POLYGON ((-99.904679362176353 51.698147686745074,\n-75.010398603076666 46.56036851832075,-75.010398603076666\n46.56036851832075,-75.010398603076666 46.56036851832075,\n-76.975736557742451 23.246272688996914,-76.975736557742451\n23.246272688996914,-76.975736557742451 23.246272688996914,\n-114.31715769639194 26.220870210283724,-114.31715769639194\n26.220870210283724,-99.904679362176353 51.698147686745074))'\n```", "```py\n>>> poly = ogr.CreateGeometryFromWkt(wkt)\n>>> poly.GetEnvelope()\n(-114.31715769639194, -75.01039860307667, 23.246272688996914,\n51.698147686745074)\n```", "```py\n{\n    \"type\": \"Feature\",\n    \"id\": \"OpenLayers.Feature.Vector_314\",\n    \"properties\": {},\n    \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [\n            97.03125,\n            39.7265625\n        ]\n    },\n    \"crs\": {\n        \"type\": \"name\",\n        \"properties\": {\n            \"name\": \"urn:ogc:def:crs:OGC:1.3:CRS84\"\n        }\n    }\n}\n```", "```py\n>>> jsdata = \"\"\"{\n    \"type\": \"Feature\",\n   \"id\": \"OpenLayers.Feature.Vector_314\",\n  \"properties\": {},\n    \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [\n           97.03125,\n           39.7265625\n       ]\n    },\n    \"crs\": {\n        \"type\": \"name\",\n        \"properties\": {\n            \"name\": \"urn:ogc:def:crs:OGC:1.3:CRS84\"\n        }\n    }\n}\"\"\"\n```", "```py\n>>> point = eval(jsdata)\n>>> point[\"geometry\"]\n{'type': 'Point', 'coordinates': [97.03125, 39.7265625]}\n```", "```py\n>>> import json\n>>> json.loads(jsdata)\n{u'geometry': {u'type': u'Point', u'coordinates': [97.03125,\n39.7265625]}, u'crs': {u'type': u'name', u'properties': {u'name':\nu'urn:ogc:def:crs:OGC:1.3:CRS84'}}, u'type': u'Feature', u'id': u'OpenLayers.Feature.Vector_314',\nu'properties':\n{}}\n```", "```py\n>>> pydata = json.loads(jsdata)\n>>> json.dumps(pydata)\n'{\"geometry\": {\"type\": \"Point\", \"coordinates\": [97.03125,\n39.7265625]}, \"crs\": {\"type\": \"name\", \"properties\": {\"name\":\n\"urn:ogc:def:crs:OGC:1.3:CRS84\"}}, \"type\" : \"Feature\", \"id\": \"OpenLayers.Feature.Vector_314\", \"properties\":\n{}}'\n```", "```py\nprint(json.dumps(pydata, indent=4))\n\n{\n    \"type\": \"Feature\",\n    \"id\":\n    \"OpenLayers.Feature.Vector_314\",\n    \"properties\": {},\n    \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [\n            97.03125,\n            39.7265625\n        ]\n    },\n    \"crs\": {\n        \"type\": \"name\",\n        \"properties\": {           \n                 \"name\": \"urn:ogc:def:crs:OGC:1.3:CRS84\"\n        }\n   }\n}\n```", "```py\n>>> import geojson\n>>> p = geojson.Point([-92, 37])\n```", "```py\n>>> geojs = geojson.dumps(p, indent=4)\n>>> geojs\n```", "```py\n{\n    \"type\": \"Point\",\n    \"coordinates\": [\n        -92,\n        37\n    ]\n}\nPOINT (-92 37)\n```", "```py\n>>> from shapely.geometry import asShape\n>>> point = asShape(p)\n>>> point.wkt\n'POINT (-92.0000000000000000 37.0000000000000000)'\n\n```", "```py\n>>> import ogr\n>>> shp = ogr.Open(\"point.shp\")\n>>> layer = shp.GetLayer()\n>>> for feature in layer:\n... geometry = feature.GetGeometryRef()\n... print(geometry.GetX(), geometry.GetY(),\nfeature.GetField(\"FIRST_FLD\"))\n...\n1.0 1.0 First\n3.0 1.0 Second\n4.0 3.0 Third\n2.0 2.0 Fourth\n0.0 0.0 Appended\n```", "```py\n>>> import shapefile\n>>> shp = shapefile.Reader(\"point.shp\")\n>>> for feature in shp.shapeRecords():\n... point = feature.shape.points[0]\n... rec = feature.record[0]\n... print(point[0], point[1], rec)\n...\n1.0 1.0 First\n3.0 1.0 Second\n4.0 3.0 Third\n2.0 2.0 Fourth\n0.0 0.0 Appended //\n```", "```py\neasy_install -f\n https://github.com/GeospatialPython/dbfpy3/archive/master.zip\n```", "```py\npip install\n https://github.com/GeospatialPython/dbfpy3/archive/master.zip\n```", "```py\n>>> from dbfpy3 import dbf\n>>> db = dbf.Dbf(\"GIS_CensusTract_poly.dbf\")\n>>> db[0]\nGEODB_OID: 4029 (<type 'int'>)\nOBJECTID: 4029 (<type 'int'>)\nPERMANE0: 61be9239-8f3b-4876-8c4c-0908078bc597 (<type 'str'>)\nSOURCE_1: NA (<type 'str'>)\nSOURCE_2: 20006 (<type 'str'>)\nSOURCE_3: Census Tracts (<type 'str'>)\nSOURCE_4: Census Bureau (<type 'str'>)\nDATA_SE5: 5 (<type 'str'>)\nDISTRIB6: E4 (<type 'str'>)\nLOADDATE: 2007-03-13 (<type 'datetime.date'>)\nQUALITY: 2 (<type 'str'>)\nSCALE: 1 (<type 'str'>)\nFCODE: 1734 (<type 'str'>)\nSTCO_FI7: 22071 (<type 'str'>)\nSTATE_NAME: 22 (<type 'str'>)\nCOUNTY_8: 71 (<type 'str'>)\nCENSUST9: 22071001734 (<type 'str'>)\nPOPULAT10: 1760 (<type 'int'>)\nAREASQKM: 264.52661934 (<type 'float'>)\nGNIS_ID: NA (<type 'str'>)\nPOPULAT11: 1665 (<type 'int'>)\nDB2GSE_12: 264526619.341 (<type 'float'>)\nDB2GSE_13: 87406.406192 (<type 'float'>)\n```", "```py\n>>> rec = db[0]\n>>> field = rec[\"POPULAT10\"]\n>>> rec[\"POPULAT10\"] = field + 1\n>>> rec.store()\n>>> del rec\n>>> db[0][\"POPULAT10\"]\n1761\n```", "```py\n>>> from shapely import wkt, geometry\n>>> wktPoly = \"POLYGON((0 0,4 0,4 4,0 4,0 0))\"\n>>> poly = wkt.loads(wktPoly)\n>>> poly.area\n16.0\n>>> buf = poly.buffer(5.0)\n>>> buf.area\n174.41371226364848\n```", "```py\n>>> buf.difference(poly).area\n158.413712264\n```", "```py\n>>> import fiona\n>>> from pprint import pprint\n>>> f = fiona.open(\"GIS_CensusTract_poly.shp\")\n>>> f.driver\n```", "```py\n>>> f.crs\n{'init': 'epsg:4269'}\n>>> f.bounds\n(-89.8744162216216, 30.161122135135138, -89.1383837783784,\n30.661213864864862)\n```", "```py\n>>> pprint(f.schema)\n{'geometry': 'Polygon',\n'properties': {'GEODB_OID': 'float:11',\n'OBJECTID': 'float:11',\n'PERMANE0': 'str:40',\n'SOURCE_1': 'str:40',\n'SOURCE_2': 'str:40',\n'SOURCE_3': 'str:100',\n'SOURCE_4': 'str:130',\n'DATA_SE5': 'str:46',\n'DISTRIB6': 'str:188',\n'LOADDATE': 'date',\n'QUALITY': 'str:35',\n'SCALE': 'str:52',\n'FCODE': 'str:38',\n'STCO_FI7': 'str:5',\n'STATE_NAME': 'str:140',\n'COUNTY_8': 'str:60',\n'CENSUST9': 'str:20',\n'POPULAT10': 'float:11',\n'AREASQKM': 'float:31.15',\n'GNIS_ID': 'str:10',\n'POPULAT11': 'float:11',\n'DB2GSE_12': 'float:31.15',\n'DB2GSE_13': 'float:31.15'}}\n```", "```py\n>>> len(f)\n45\n```", "```py\npprint(f[1])\n{'geometry': {'coordinates': [[[(-89.86412366375093,\n30.661213864864862), (-89.86418691770497, 30.660764012731285),\n(-89.86443391770518, 30.659652012730202),\n...\n'type': 'MultiPolygon'},\n'id': '1',\n'properties': {'GEODB_OID': 4360.0,\n'OBJECTID': 4360.0,\n'PERMANE0': '9a914eef-9249-44cf-a05f-af4b48876c59',\n'SOURCE_1': 'NA',\n'SOURCE_2': '20006',\n...\n'DB2GSE_12': 351242560.967882,\n'DB2GSE_13': 101775.283967268},\n'type': 'Feature'}\n```", "```py\n>>> from osgeo import gdal\n>>> raster = gdal.Open(\"SatImage.tif\")\n>>> raster.RasterCount\n3\n>>> raster.RasterXSize\n2592\n>>> raster.RasterYSize\n2693\n```", "```py\n>>> from osgeo import gdal_array\n>>> srcArray = gdal_array.LoadFile(\"SatImage.tif\")\n>>> band1 = srcArray[0]\n>>> gdal_array.SaveArray(band1, \"band1.jpg\", format=\"JPEG\")\n```", "```py\n>>> try:\n>>> import Image\n>>> import ImageDraw\n>>> except:\n>>> from PIL import Image\n>>> from PIL import ImageDraw\n>>> import shapefile\n>>> r = shapefile.Reader(\"hancock.shp\")\n>>> xdist = r.bbox[2] - r.bbox[0]\n>>> ydist = r.bbox[3] - r.bbox[1]\n>>> iwidth = 400\n>>> iheight = 600\n>>> xratio = iwidth/xdist\n>>> yratio = iheight/ydist\n>>> pixels = []\n>>> for x,y in r.shapes()[0].points:\n... px = int(iwidth - ((r.bbox[2] - x) * xratio))\n... py = int((r.bbox[3] - y) * yratio)\n... pixels.append((px,py))\n...\n>>> img = Image.new(\"RGB\", (iwidth, iheight), \"white\")\n>>> draw = ImageDraw.Draw(img)\n>>> draw.polygon(pixels, outline=\"rgb(203, 196, 190)\",\nfill=\"rgb(198, 204, 189)\")\n>>> img.save(\"hancock.png\")\n```", "```py\n>>> import shapefile\n>>> import pngcanvas\n>>> r = shapefile.Reader(\"hancock.shp\")\n>>> xdist = r.bbox[2] - r.bbox[0]\n>>> ydist = r.bbox[3] - r.bbox[1]\n>>> iwidth = 400\n>>> iheight = 600\n>>> xratio = iwidth/xdist\n>>> yratio = iheight/ydist\n>>> pixels = []\n>>> for x,y in r.shapes()[0].points:\n... px = int(iwidth - ((r.bbox[2] - x) * xratio))\n... py = int((r.bbox[3] - y) * yratio)\n... pixels.append([px,py])\n...\n>>> c = pngcanvas.PNGCanvas(iwidth,iheight)\n>>> c.polyline(pixels)\n>>> f = open(\"hancock_pngcvs.png\", \"wb\")\n>>> f.write(c.dump())\n>>> f.close()\n```", "```py\n>>> import geopandas\n>>> import matplotlib.pyplot as plt\n>>> gdf = geopandas.GeoDataFrame\n>>> census = gdf.from_file(\"GIS_CensusTract_poly.shp\")\n>>> census.plot()\n>>> plt.show()\n```", "```py\n# Import the python mysql library\nimport pymysql\n# Establish a database connection on our local\n# machine as the root database user.\nconn = pymysql.connect(host='localhost', port=3306,\nuser='root', passwd='', db='mysql')\n```", "```py\n# Get the database cursor needed to change\n# the database\ncur = conn.cursor()\n```", "```py\n# If the database already exists, delete\n# it and recreate it either way.\ncur.execute(\"DROP DATABASE IF EXISTS spatial_db\")\ncur.execute(\"CREATE DATABASE spatial_db\")\n# Close the cursor and the connection\ncur.close()\nconn.close()\n```", "```py\n# Set up a new connection and cursor\nconn = pymysql.connect(host='localhost', port=3306,\nuser='root', passwd='', db='spatial_db')\ncur = conn.cursor()\n```", "```py\n# Create our geospatial table\ncur.execute(\"CREATE TABLE PLACES (id int NOT NULL\n# Add name and location fields. The location\n# field is spatially enabled to hold GIS data\nAUTO_INCREMENT PRIMARY KEY, Name varchar(50) NOT NULL, location\nGeometry NOT NULL)\")\n```", "```py\n# Insert a name and location for the city of\n# New Orleans\ncur.execute(\"INSERT INTO PLACES (name, location) VALUES ('NEW\nORLEANS', GeomFromText('POINT(30.03 90.03)'))\")\n# Insert a name and location for the city of\n# Memphis.\ncur.execute(\"INSERT INTO PLACES (name, location) VALUES\n('MEMPHIS', GeomFromText('POINT(35.05 90.00)'))\")\n```", "```py\n# Commit the changes to the database\nconn.commit()\n```", "```py\n# Now let's read the data. Select all of\n# the point locations from the database.\ncur.execute(\"SELECT AsText(location) FROM PLACES\")\n```", "```py\n# We know there's only two points, so we'll\n# just parse them.\np1, p2 = [p[0] for p in cur.fetchall()]\n```", "```py\n# Now we'll convert the data\n# to geometries to measure the distance\n# between the two cities\ncur.execute(\"SET @p1 = ST_GeomFromText('{}')\".format(p1))\ncur.execute(\"SET @p2 = ST_GeomFromText('{}')\".format(p2))\n```", "```py\n# Now we do the measurement function which\n# is also a database query.\ncur.execute(\"SELECT ST_Distance(@p1, @p2)\")\nd = float(cur.fetchone()[0])\n# Print the distance as a formatted\n# string object.\nprint(\"{:.2f} miles from New Orleans to Memphis\".format(d *\n70))\ncur.close()\nconn.close()\n```", "```py\n351.41 miles from New Orleans to Memphis\n```", "```py\n>>> import fpdf\n>>> # PDF constructor:\n>>> # Portrait, millimeter units, A4 page size\n>>> pdf=fpdf.FPDF(\"P\", \"mm\", \"A4\")\n>>> # create a new page\n>>> pdf.add_page()\n>>> # Set font: arial, bold, size 20\n>>> pdf.set_font('Arial','B',20)\n>>> # Layout cell: 160 x 25mm, title, no border, centered\n>>> pdf.cell(160,25,'Hancock County Boundary', \\\n>>> border=0, align=\"C\")\n>>> # Write the image specifying the size\n>>> pdf.image(\"hancock.png\",25,50,110,160)\n>>> # Save the file: filename, F = to file System\n>>> pdf.output('map.pdf','F')\n```", "```py\npip install https://github.com/GeospatialPython/geopdf-py3/archive/master.zip\n```", "```py\n# Import the geopdf library\nfrom geopdf import GeoCanvas\n# Import the necessary Reportlab modules\nfrom reportlab.pdfbase.pdfdoc import PDFString, PDFArray\n# Create a canvas with a name for our pdf.\ncanvas = GeoCanvas('SimpleGIS.pdf')\n# Draw a rectangle to represent the State boundary\ncanvas.rect(100, 400, 400, 250, stroke=1)\n# DATA MODEL\n# All layers will have a name, 1+ points, and population count\nNAME = 0\nPOINTS = 1\nPOP = 2\n# Create the state layer\nstate = [\"COLORADO\", [[-109, 37], [-109, 41], [-102, 41], [-102, 37]], 5187582]\n# Cities layer list\n# city = [name, [point], population]\ncities = []\n# Add Denver\ncities.append([\"DENVER\", [-104.98, 39.74], 634265])\n# Add Boulder\ncities.append([\"BOULDER\", [-105.27, 40.02], 98889])\n# Add Durango\ncities.append([\"DURANGO\", [-107.88, 37.28], 17069])\n# MAP GRAPHICS RENDERING\nmap_width = 400\nmap_height = 250\n# State Bounding Box\n# Use Python min/max function to get state bounding box\nminx = 180\nmaxx = -180\nminy = 90\nmaxy = -90\nfor x, y in state[POINTS]:\n    if x < minx:\n        minx = x\n    elif x > maxx:\n        maxx = x\n    if y < miny:\n        miny = y\n    elif y > maxy:\n        maxy = y\n# Get earth distance on each axis\ndist_x = maxx - minx\ndist_y = maxy - miny\n# Scaling ratio each axis\n# to map points from world to screen\nx_ratio = map_width / dist_x\ny_ratio = map_height / dist_y\ndef convert(point):\n    \"\"\"Convert lat/lon to screen coordinates\"\"\"\n    lon = point[0]\n    lat = point[1]\n    x = map_width - ((maxx - lon) * x_ratio)\n    y = map_height - ((maxy - lat) * y_ratio)\n    # Python turtle graphics start in the middle of   \n    # the screen so we must offset the points so they     \n    # are centered\n    x = x + 100\n    y = y + 400\n    return [x, y]\n\n# Set up our map labels\ncanvas.setFont(\"Helvetica\", 20)\ncanvas.drawString(250, 500, \"COLORADO\")\n\n# Use smaller text for cities\ncanvas.setFont(\"Helvetica\", 8)\n\n# Draw points and label the cities\nfor city in cities:\npixel = convert(city[POINTS])\nprint(pixel)\n\n# Place a point for the city\ncanvas.circle(pixel[0], pixel[1], 5, stroke=1, fill=1)  \n\n# Label the city\ncanvas.drawString(pixel[0] + 10, pixel[1], city[NAME] + \", Population: \" + str(city[POP]))\n\n# A series of registration point pairs (pixel x, \n# pixel y, x, y) to spatially enable the PDF. We only \n# need to do the state boundary.\n# The cities will be contained with in it.\nregistration = PDFArray([\nPDFArray(map(PDFString, ['100', '400', '{}'.format(minx), '{}'.format(maxy)])),\nPDFArray(map(PDFString, ['500', '400', '{}'.format(maxx), '{}'.format(maxy)])),\nPDFArray(map(PDFString, ['100', '150', '{}'.format(minx), '{}'.format(miny)])),\nPDFArray(map(PDFString, ['500', '150', '{}'.format(maxx), '{}'.format(miny)]))\n])\n# Add the map registration\ncanvas.addGeo(Registration=registration)\n# Save our geopdf\ncanvas.save()\n```", "```py\n>>> import rasterio\n>>> ds = rasterio.open(\"SatImage.tif\")\n>>> ds.name\n'SatImage.tif'\n>>> ds.count\n3\n>>> ds.width\n2592\n>>> ds.height\n2693\n```", "```py\npip install osmnx\n```", "```py\n>>> import osmnx as ox\n>>> G = ox.graph_from_place('Bay Saint Louis, MS , USA', network_type='drive')\n>>> stats = ox.basic_stats(G)\n>>> stats[\"street_length_avg\"]\n172.1468804611654\n```"]