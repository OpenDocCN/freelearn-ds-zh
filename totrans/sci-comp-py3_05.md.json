["```py\nM = array([[1.,2.],[3.,4.]])\nv = M[0,:] # first row of M\n```", "```py\nv[-1] = 0.\nv # array([[1.,0.]])\nM # array([[1.,0.],[3.,4.]]) # M is modified as well\n```", "```py\nv.base # array([[1.,0.],[3.,4.]])\nv.base is M # True\n```", "```py\nM.base # None\n```", "```py\na = arange(4) # array([0.,1.,2.,3.])\nb = a[[2,3]] # the index is a list [2,3]\nb # array([2.,3.])\nb.base is None # True, the data was copied\nc = a[1:3]\nc.base is None # False, this is just a view\n```", "```py\nN = M[:] # this is a view of the whole array M\n```", "```py\nM = random.random_sample((3,3))\nN = M.T\nN.base is M # True\n```", "```py\nv = arange(10)\nC = v.reshape(-1,1) # column matrix\nC.base is v # True\n```", "```py\nM = array([[1.,2.],[3.,4.]])\nN = array(M.T) # copy of M.T\n```", "```py\nN.base is None # True\n```", "```py\nA = array([0.,0.])\nB = array([0.,0.])\nif abs(B-A) < 1e-10: # an exception is raised here\n    print(\"The two arrays are close enough\")\n```", "```py\nValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()\n```", "```py\nA = array([True,False]) # Boolean array\nA.dtype # dtype('bool')\n```", "```py\nM = array([[2, 3],\n           [1, 4]])\nM > 2 # array([[False, True],\n             # [False, True]])\nM == 0 # array([[False, False],\n             # [False, False]])\nN = array([[2, 3],\n           [0, 0]])\nM == N # array([[True, True],\n              # [False, False]])\n...\n```", "```py\nA = array([[1,2],[3,4]])\nB = array([[1,2],[3,3]])\nA == B # creates array([[True, True], [True, False]]) \n(A == B).all() # False\n(A != B).any() # True\nif (abs(B-A) < 1e-10).all():\n    print(\"The two arrays are close enough\")\n```", "```py\ndata = random.rand(2)*1e-3\nsmall_error = random.rand(2)*1e-16\ndata == data + small_error # False\nallclose(data, data + small_error, rtol=1.e-5, atol=1.e-8)   # True\n```", "```py\ndata = 1e-3\nerror = 1e-16\ndata == data + error # False\nallclose(data, data + error, rtol=1.e-5, atol=1.e-8)  #True\n```", "```py\nA = array([True, True, False, False])\nB = array([True, False, True, False])\nA and B # error!\nA & B # array([True, False, False, False])\nA | B # array([True, True, True, False])\n~A # array([False, False, True, True])\n```", "```py\ndata = linspace(1,100,100) # data\ndeviation = random.normal(size=100) # the deviations \n           #don't forget the parentheses in next statement!\nexceptional = data[(deviation<-0.5)|(deviation>0.5)] \nexceptional = data[abs(deviation)>0.5] # same result \nsmall = data[(abs(deviation)<0.1)&(data<5.)] # small deviation and data\n```", "```py\nB = array([[True, False],\n           [False, True]])\nM = array([[2, 3],\n           [1, 4]])\nM[B] # array([2,4]), a vector\n```", "```py\nM[B] = 0\nM # [[0, 3], [1, 0]]\n```", "```py\nM[B] = 10, 20\nM # [[10, 3], [1, 20]]\n```", "```py\nM[M>2] = 0    # all the elements > 2 are replaced by 0\n```", "```py\nwhere(condition, a, b)\n```", "```py\ndef H(x):\n    return where(x < 0, 0, 1)\nx = linspace(-1,1,11)  # [-1\\. -0.8 -0.6 -0.4 -0.2 0\\. 0.2 0.4 0.6 0.8 1\\. ]\nprint(H(x))            # [0 0 0 0 0 1 1 1 1 1 1]\n```", "```py\nx = linspace(-4,4,5)\n# [-4\\. -2.  0.  2.  4.]\n\nprint(where(x > 0, sqrt(x), 0))\n# [ 0.+0.j 0.+0.j 0.+0.j 1.41421356+0.j  2.+0.j ]\nprint(where(x > 0, 1, -1)) # [-1 -1 -1  1  1]\n```", "```py\na = arange(9)\nb = a.reshape((3,3))\n\nprint(where(a > 5))   # (array([6, 7, 8]),)\n\nprint(where(b > 5))   # (array([2, 2, 2]), array([0, 1, 2]))\n```", "```py\ndef my_prod(a,b):\n    val = 0\n    for aa,bb in zip(a,b):\n        val += aa*bb\n    return val\n```", "```py\nfor i in range(len(v)):\n    w[i] = v[i] + 5\n```", "```py\nw = v + 5\n```", "```py\ndef my_avg(A):\n    m,n = A.shape\n    B = A.copy()\n    for i in range(1,m-1):\n        for j in range(1,n-1):\n            B[i,j] = (A[i-1,j] + A[i+1,j] + A[i,j-1] + A[i,j+1])/4\n    return B\n\ndef slicing_avg(A):\n    A[1:-1,1:-1] = (A[:-2,1:-1] + A[2:,1:-1] +\n    A[1:-1,:-2] + A[1:-1,2:])/4\n    return A\n```", "```py\ndef my_func(x):\n    y = x**3 - 2*x + 5\n    if y>0.5:\n        return y-0.5\n    else:\n        return 0\n```", "```py\nfor i in range(len(v)):\n    v[i] = my_func(v[i])\n```", "```py\nmy_vecfunc = vectorize(my_func)\n```", "```py\nv = my_vecfunc(v)\n```", "```py\nvector = arange(4) # array([0.,1.,2.,3.])\nvector + 1\\.        # array([1.,2.,3.,4.])\n```", "```py\nC = arange(2).reshape(-1,1) # column\nR = arange(2).reshape(1,-1) # row\nC + R                       # valid addition: array([[0.,1.],[1.,2.]])\n```", "```py\nM = array([[11, 12, 13, 14],\n           [21, 22, 23, 24],\n           [31, 32, 33, 34]])\n```", "```py\nv = array([100, 200, 300, 400])\n```", "```py\nM + v # works directly\n```", "```py\nM + v.reshape(-1,1)\n```", "```py\nM = array([[11, 12, 13, 14],\n           [21, 22, 23, 24],\n           [31, 32, 33, 34]])\n```", "```py\nv = array([100, 200, 300])\n```", "```py\nM + v # shape mismatch error\n```", "```py\nM + v.reshape(-1,1)\n```", "```py\nrescaled = M*coeff.reshape(-1,1)\n```", "```py\nrescaled = M*coeff\n```", "```py\nrescaled = M*coeff.reshape(1,-1)\n```", "```py\nW=u.reshape(-1,1) + v\n```", "```py\nw = cos(x).reshape(-1,1) + sin(2*y)\n```", "```py\nx,y = ogrid[0:1:3j,0:1:3j] \n# x,y are vectors with the contents of linspace(0,1,3)\nw = cos(x) + sin(2*y)\n```", "```py\nx,y = ogrid[0:1:3j, 0:1:3j]\nx,y = ogrid.__getitem__((slice(0, 1, 3j),slice(0, 1, 3j)))\n```", "```py\nx,y = ogrid[0:1:3j, 0:1:3j]\n```", "```py\narray([[ 0\\. ],\n       [ 0.5],\n       [ 1\\. ]])\narray([[ 0\\. ,  0.5,  1\\. ]])\n```", "```py\nx,y = ogrid[0:1.5:.5, 0:1.5:.5]\n```", "```py\ndata = (1\\. 2\\. 3\\. 4.)\nindptr = (0 2 2 3 5)\nindices = (0 2 0 0 3)\n```", "```py\nimport scipy.sparse as sp\nA = array([[1,0,2,0],[0,0,0,0],[3.,0.,0.,0.],[1.,0.,0.,4.]])\nAS = sp.csr_matrix(A)\n```", "```py\nAS.data      # returns array([ 1., 2., 3., 1., 4.]) \nAS.indptr    # returns array([0, 2, 2, 3, 5])\nAS.indices   # returns array([0, 2, 0, 0, 3])\nAS.nnz       # returns 5\n```", "```py\nimport scipy.sparse as sp\nA = array([[1,0,2,0],[0,0,0,0],[3.,0.,0.,0.],[1.,0.,0.,4.]])\nAS = sp.csc_matrix(A)\nAS.data         # returns array([ 1., 3., 1., 2., 4.]) \nAS.indptr       # returns array([0, 3, 3, 4, 5])\nAS.indices      # returns array([0, 2, 3, 0, 3])\nAS.nnz          # returns 5\n```", "```py\nimport scipy.sparse as sp\nA = array([[1,0,2,0],[0,0,0,0], [3.,0.,0.,0.], [1.,0.,0.,4.]]) \nAS = sp.lil_matrix(A)\nAS.data     # returns array([[1.0, 2.0], [], [3.0], [1.0, 4.0]], dtype=object)\nAS.rows     # returns array([[0, 2], [], [0], [0, 3]], dtype=object)\nAS.nnz      # returns 5\n```", "```py\nBS = AS[1:3,0:2]\nBS.data     # returns array([[], [3.0]], dtype=object)\nBS.rows     # returns array([[], [0]], dtype=object)\n```", "```py\nAS[0,1] = 17 \nAS.data # returns array([[1.0, 17.0, 2.0], [], [3.0], [1.0, 4.0]])\nAS.rows              # returns array([[0, 1, 2], [], [0], [0, 3]])\nAS.nnz               # returns 6\n```", "```py\nimport scipy.sparse as sp\nsp.eye(20,20,format = 'lil') \nsp.spdiags(ones((20,)),0,20,20, format = 'csr') \nsp.identity(20,format ='csc')\n```", "```py\nimport scipy.sparse as sp \nAS=sp.rand(20,200,density=0.1,format=’csr’)\nAS.nnz # returns 400\n```", "```py\nimport scipy.sparse as sp\nZ=sp.csr_matrix((20,200))\nZ.nnz    # returns 0\n```", "```py\nAS.toarray # converts sparse formats to a numpy array \nAS.tocsr\nAS.tocsc\nAS.tolil\n```", "```py\nimport scipy.sparse as sp\ndef sparse_sin(A):\n    if not (sp.isspmatrix_csr(A) or sp.isspmatrix_csc(A)):\n        A = A.tocsr()\nA.data = sin(A.data)\nreturn A\n```", "```py\nimport scipy.sparse as sp\nA = array([[1,0,2,0],[0,0,0,0],[3.,0.,0.,0.],[1.,0.,0.,4.]])\nAS = sp.csr_matrix(A)\nb = array([1,2,3,4])\nc = AS.dot(b)      # returns array([ 7., 0., 3., 17.]) \nC = AS.dot(AS)     # returns  csr_matrix\nd = dot(AS,b)      # does not return the expected result! \n\n```"]