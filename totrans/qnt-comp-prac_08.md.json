["```py\n    from qiskit import IBMQ\n    print(\"Getting providers...\")\n    if not IBMQ.active_account():\n        IBMQ.load_account()\n    provider = IBMQ.get_provider()\n    ```", "```py\n    def select_backend():\n        # Get all available and operational backends.\n        print(\"Getting backends...\")\n        available_backends = provider.backends(filters=lambda         b: not b.configuration().simulator and         b.configuration().n_qubits > 0 and         b.status().operational)\n        # Fish out criteria to compare\n        print(\"{0:20} {1:<10}\".format(\"Name\",\"#Qubits\"))\n        print(\"{0:20} {1:<10}\".format(\"----\",\"-------\"))        \n        for n in range(0, len(available_backends)):\n            backend = provider.get_backend(str(            available_backends[n]))\n            print(\"{0:20} {1:<10}\".format(        backend.name(),backend.configuration().n_qubits))\n        select_backend=input(\"Select a backend ('exit' to         end): \")\n        if select_backend!=\"exit\":\n            backend = provider.get_backend(select_backend)\n        else:\n            backend=select_backend\n        return(backend)F\n    ```", "```py\n    def display_information(backend):\n        basis_gates=backend.configuration().basis_gates\n        n_qubits=backend.configuration().n_qubits\n        if n_qubits>1:\n            coupling_map=backend.configuration().coupling_map\n        else:\n            coupling_map=[]\n        micro=10**6\n    ```", "```py\n        for qubit in range(n_qubits):\n            print(\"\\nQubit:\",qubit)\n            print(\"T1:\",int(backend.properties().            t1(qubit)*micro),\"\\u03BCs\")\n            print(\"T2:\",int(backend.properties().            t2(qubit)*micro),\"\\u03BCs\")\n            print(\"Readout error:\",round(backend.            properties().readout_error(qubit)*100,2),\"%\")\n            for bg in basis_gates:\n                if bg!=\"cx\":\n                    if backend.properties().                   gate_length(bg,[qubit])!=0:\n                        print(bg,round(                        backend.properties().gate_                        length(bg,[0])*micro,2),\"\\                        u03BCs\", \"Err:\",round(backend.                        properties().gate_error(bg,                        [qubit])*100,2),\"%\") \n                    else:    \n                        print(bg,round(                       backend.properties().gate_                       length(bg,[0])*micro,2),\"\\                       u03BCs\", \"Err:\",round(backend.                       properties().gate_                       error(bg,[qubit])*100,2),\"%\")\n            if n_qubits>0:\n                for cm in coupling_map:\n                    if qubit in cm:\n                        print(\"cx\",cm,round(                       backend.properties().gate_                       length(\"cx\",cm)*micro,2),\"\\                       u03BCs\", \"Err:\",round(backend.                       properties().gate_                       error(\"cx\",cm)*100,2),\"%\")\n    ```", "```py\n    def main():\n        backend=select_backend()\n        display_information(backend)\n    if __name__ == '__main__':\n        main()\n    ```", "```py\n    from qiskit import IBMQ, Aer, QuantumCircuit, ClassicalRegister, QuantumRegister, execute\n    from qiskit.tools.monitor import job_monitor\n    from qiskit.visualization import plot_histogram, plot_error_map\n    from IPython.core.display import display\n    print(\"Getting provider...\")\n    if not IBMQ.active_account():\n        IBMQ.load_account()\n    provider = IBMQ.get_provider()\n    ```", "```py\n    def select_backend():\n        # Get all available and operational backends.\n        available_backends = provider.backends(filters=lambda         b: not b.configuration().simulator and         b.configuration().n_qubits > 1 and         b.status().operational)\n        # Fish out criteria to compare\n        print(\"{0:20} {1:<10} {2:<10}\".        format(\"Name\",\"#Qubits\",\"Pending jobs\"))\n        print(\"{0:20} {1:<10} {2:<10}\".format(\"----\",        \"-------\",\"------------\"))        \n        for n in range(0, len(available_backends)):\n            backend = provider.get_backend(str(            available_backends[n]))\n            print(\"{0:20} {1:<10}\".format(backend.            name(),backend.configuration().            n_qubits),backend.status().pending_jobs)\n        select_backend=input(\"Select a backend ('LB' for         least busy): \")\n        if select_backend not in [\"LB\",\"lb\"]:\n            backend = provider.get_backend(str(            select_backend))\n        else:\n            from qiskit.providers.ibmq import least_busy\n            backend = least_busy(provider.backends(            filters=lambda b: not b.configuration().            simulator and b.configuration().n_qubits > 1             and b.status().operational))\n        print(\"Selected backend:\",backend.status().       backend_name)\n        return(backend)\n    ```", "```py\n    def get_gate_info(backend):\n        # Pull out the gates information.\n        gates=backend.properties().gates\n        #Cycle through the CX gate couplings to find the best     # and worst \n        cx_best_worst = [[[0,0],1],[[0,0],0]]\n        for n in range (0, len(gates)):\n            if gates[n].gate ==  \"cx\":\n                print(gates[n].name, \":\", gates[n].                parameters[0].name,\"=\",                 gates[n].parameters[0].value)\n                if cx_best_worst[0][1]>gates[n].                parameters[0].value:\n                    cx_best_worst[0][1]=gates[n].                    parameters[0].value\n                    cx_best_worst[0][0]=gates[n].qubits\n                if cx_best_worst[1][1]<gates[n].                parameters[0].value:\n                    cx_best_worst[1][1]=gates[n].                    parameters[0].value\n                    cx_best_worst[1][0]=gates[n].qubits\n        print(\"Best cx gate:\", cx_best_worst[0][0], \",\",         round(cx_best_worst[0][1]*100,3),\"%\")\n        print(\"Worst cx gate:\", cx_best_worst[1][0], \",\",         round(cx_best_worst[1][1]*100,3),\"%\")\n        return(cx_best_worst)\n    ```", "```py\n    def create_circuits(backend, cx_best_worst):\n        print(\"Building circuits...\")\n        q1 = QuantumRegister(backend.configuration().        n_qubits)\n        c1 = ClassicalRegister(backend.configuration().        n_qubits)\n        qc_best = QuantumCircuit(q1, c1)\n        qc_worst = QuantumCircuit(q1, c1)\n\n        #Best circuit\n        qc_best.h(q1[cx_best_worst[0][0][0]])\n        qc_best.cx(q1[cx_best_worst[0][0][0]], q1[cx_best_        worst[0][0][1]])\n        qc_best.measure(q1[cx_best_worst[0][0][0]], c1[0])\n        qc_best.measure(q1[cx_best_worst[0][0][1]], c1[1])\n        print(\"Best CX:\")\n        display(qc_best.draw('mpl'))\n\n        #Worst circuit\n        qc_worst.h(q1[cx_best_worst[1][0][0]])\n        qc_worst.cx(q1[cx_best_worst[1][0][0]], q1[cx_best_        worst[1][0][1]])\n        qc_worst.measure(q1[cx_best_worst[1][0][0]], c1[0])\n        qc_worst.measure(q1[cx_best_worst[1][0][1]], c1[1])\n\n        print(\"Worst CX:\")\n        display(qc_worst.draw('mpl'))\n\n        return(qc_best,qc_worst)\n    ```", "```py\n    def compare_cx(backend,qc_best,qc_worst):\n        print(\"Comparing CX pairs...\")\n        print(\"Best CX 2:\")\n        display(qc_best.draw('mpl'))\n        job_best = execute(qc_best, backend, shots=8192)\n        job_monitor(job_best)\n        print(\"Worst CX 2:\")\n        display(qc_worst.draw('mpl'))\n        job_worst = execute(qc_worst, backend, shots=8192)\n        job_monitor(job_worst)\n    ```", "```py\n        q = QuantumRegister(backend.configuration().n_qubits)\n        c = ClassicalRegister(backend.configuration().        n_qubits)\n        qc = QuantumCircuit(q, c)\n        qc.h(q[0])\n        qc.cx(q[0], q[1])\n        qc.measure(q[0], c[0])\n        qc.measure(q[1], c[1])\n        backend_sim = Aer.get_backend('qasm_simulator')\n        job_sim = execute(qc, backend_sim)\n    ```", "```py\n        best_result = job_best.result()\n        counts_best  = best_result.get_counts(qc_best)\n        print(\"Best qubit pair:\")\n        print(counts_best)\n        worst_result = job_worst.result()\n        counts_worst  = worst_result.get_counts(qc_worst)\n        print(\"Worst qubit pair:\")\n        print(counts_worst)\n        sim_result = job_sim.result()\n        counts_sim  = sim_result.get_counts(qc)\n        print(\"Simulated baseline:\")\n        print(counts_sim)\n        display(plot_histogram([counts_best, counts_worst,                            counts_sim],                            title = \"Best and worst qubit                            pair for: \" + backend.name(),                            legend = [\"Best qubit                            pair\",\"Worst qubit                            pair\",\"Simulated baseline\"],\n                               sort = 'desc',\n                               figsize = (15,12),\n                               color = ['green',                            'red','blue'],\n                               bar_labels = True))\n    ```", "```py\n    def main():\n        backend=select_backend()\n        cx_best_worst=get_gate_info(backend)\n        qc_best, qc_worst=create_circuits(backend,         cx_best_worst)\n        compare_cx(backend,qc_best,qc_worst)\n\n    if __name__ == '__main__':\n        main()\n    ```", "```py\n    ...\n    trans_qc_best = transpile(qc_best, backend)\n    print(\"Transpiled qc_best circuit:\")\n    display(trans_qc_best.draw())\n    ...\n    ```", "```py\n    from qiskit import Aer, IBMQ, QuantumCircuit, execute\n    from qiskit.providers.aer.noise import NoiseModel\n    from qiskit.tools.visualization import plot_histogram\n    from qiskit.tools.monitor import job_monitor\n    from IPython.core.display import display\n    print(\"Getting providers...\")\n    if not IBMQ.active_account():\n        IBMQ.load_account()\n    provider = IBMQ.get_provider()\n    ```", "```py\n    def select_backend():\n        # Get all available and operational backends.\n        print(\"Getting backends...\")\n        available_backends = provider.backends(filters=lambda         b: not b.configuration().simulator and         b.configuration().n_qubits > 0 and         b.status().operational)\n        # Fish out criteria to compare\n        print(\"{0:20} {1:<10} {2:<10}\".        format(\"Name\",\"#Qubits\",\"Pending jobs\"))\n        print(\"{0:20} {1:<10} {2:<10}\".format(\"----\",       \"-------\",\"------------\"))\n        for n in range(0, len(available_backends)):\n            backend = provider.get_backend(str(            available_backends[n]))\n            print(\"{0:20} {1:<10}\".format(backend.            name(),backend.configuration().            n_qubits),backend.status().pending_jobs)\n        select_backend=input(\"Select a backend:\\n\")\n        backend = provider.get_backend(select_backend)\n        return(backend)\n    ```", "```py\n    def display_information(backend,n_id,ttype):\n        micro=10**6\n        qubit=0\n        T1=int(backend.properties().t1(qubit)*micro)\n        T2=int(backend.properties().t2(qubit)*micro)\n        id_len=backend.properties().        gate_length(\"id\",[0])*micro\n        if ttype==\"T1\":\n            T=T1\n        else:\n            T=T2\n        print(\"\\nBackend data:\")\n        print(\"\\nBackend online since:\",backend.        configuration().online_date.strftime('%Y-%m-%d'))\n        print(\"Qubit:\",qubit)\n        print(\"T1:\",T1,\"\\u03BCs\")\n        print(\"T2:\",T2,\"\\u03BCs\")\n        print(\"Readout error:\",round(backend.properties().        readout_error(qubit)*100,2),\"%\")\n        print(\"Qubit\",qubit,\"Id length:\",round(id_len,3),        \"\\u03BCs\") \n        print(ttype,\"-id =\", round(T-n_id*id_len,2),        \"\\u03BCs\",int((100*n_id*id_len)/T),\"%\")\n        return(T)\n    ```", "```py\n    def build_circuit(ttype,n_id):\n        qc = QuantumCircuit(1,1)\n        qc.x(0)\n        if ttype in [\"T2\",\"t2\"]:\n            qc.h(0)\n        for n in range(int(n_id)):\n            qc.id(0)\n            qc.barrier(0)\n        if ttype in [\"T2\",\"t2\"]:\n            qc.h(0)\n        qc.measure(0,0)\n        return(qc)\n    ```", "```py\n    def build_noise_model(backend):\n        print(\"Building noise model...\")\n        # Construct the noise model from backend\n        noise_model = NoiseModel.from_backend(backend)\n        return(noise_model)\n    ```", "```py\n    def execute_circuit(backend, circuit,noise_model, n_id):\n        # Basis gates for the noise model\n        basis_gates = noise_model.basis_gates\n        # Coupling map\n        coupling_map = backend.configuration().coupling_map \n        # Execute noisy simulation on QASM simulator and get     # counts\n        noisy_counts = execute(circuit,         Aer.get_backend('qasm_simulator'),         noise_model=noise_model, coupling_map=coupling_        map, basis_gates=basis_gates).result().get_        counts(circuit)\n        return(noisy_counts)\n    ```", "```py\n    def main():\n        # Set the time type\n        ttype=\"T1\"\n        # Select the backend to simulate or run on\n        backend=select_backend()\n        back_sim=input(\"Enter Q to run on the selected         backend, S to run on the simulated backend:\\n\")\n        if back_sim in [\"Q\",\"q\"]:\n            sim=False\n        else:\n            sim=True\n            noise_model=build_noise_model(backend)\n        n_id=int(input(\"Number of id gates:\\n\"))\n        t=display_information(backend,n_id,ttype)\n        qc=build_circuit(ttype,n_id)  \n        # Print sample circuit\n        print(\"\\nSample 5-Id gate\",ttype,\"circuit:\")\n        display(build_circuit(ttype,5).draw('mpl'))\n    ```", "```py\n        job = execute(qc, backend=Aer.get_backend(       'qasm_simulator'), shots=8192)\n        results = job.result()\n        sim_counts = results.get_counts()\n        print(\"\\nRunning:\")\n        print(\"Results for simulator:\",sim_counts)\n        # Run the circuit\n        entry={'sim':sim_counts}\n        legend=['sim']\n        length=n_id\n        while length!=0:\n            qc=build_circuit(ttype,length)\n            if sim:\n                noisy_counts=execute_circuit(backend,qc,                noise_model,length)\n            else:\n                job = execute(qc, backend=backend,                shots=8192)\n                job_monitor(job)\n                results = job.result()\n                noisy_counts = results.get_counts()\n            print(\"Results for\",length,\"Id gates:\",            noisy_counts)\n            entry.update({str(length):noisy_counts})\n            legend.append(str(length))\n            length=int(length/4)\n    ```", "```py\n        results_array=[]\n        for i in legend:\n            results_array.append(entry[i])\n        # Display the final results\n        title=\"ID-circuits on \"+str(backend)+\" with         \"+ttype+\"= \"+str(t)+\" \\u03BCs\"\n        if sim:\n            title+=\" (Simulated)\"\n        title+=\" \\nOnline since: \"+str(backend.        configuration().online_date.strftime('%Y-%m-%d'))\n        display(plot_histogram(results_array, legend=legend,         title=title))\n    ```", "```py\n# Main \ndef main():\n    # Set the time type\n    ttype=\"T2\"\n```", "```py\n    from qiskit import Aer, IBMQ, QuantumRegister, execute\n    from qiskit import QuantumCircuit\n    from qiskit.tools.visualization import plot_histogram\n    from qiskit.tools.monitor import job_monitor\n    from IPython.core.display import display\n    print(\"Getting providers...\")\n    if not IBMQ.active_account():\n        IBMQ.load_account()\n    provider = IBMQ.get_provider()\n    ```", "```py\n    def select_backend():\n        # Get all available and operational backends.\n        available_backends = provider.backends(filters=lambda         b: not b.configuration().simulator and         b.configuration().n_qubits > 1 and         b.status().operational)\n        # Fish out criteria to compare\n        print(\"{0:20} {1:<10} {2:<10}\".        format(\"Name\",\"#Qubits\",\"Pending jobs\"))\n        print(\"{0:20} {1:<10} {2:<10}\".format(\"----\",        \"-------\",\"------------\"))        \n        for n in range(0, len(available_backends)):\n            backend = provider.get_backend(str(            available_backends[n]))\n            print(\"{0:20} {1:<10}\".format(backend.            name(),backend.configuration().            n_qubits),backend.status().pending_jobs)\n        select_backend=input(\"Select a backend ('exit' to         end): \")\n        if select_backend!=\"exit\":\n            backend = provider.get_backend(select_backend)\n        else:\n            backend=select_backend\n        return(backend)\n    ```", "```py\n    def create_circuit():\n         #Create the circuit\n        circuit = QuantumCircuit(3)\n        circuit.h(0)\n        circuit.cx(0,1)\n        circuit.cx(0,2) \n        circuit.measure_all()\n        print(\"Our circuit:\")\n        display(circuit.draw('mpl'))\n        return(circuit)\n    ```", "```py\n    def simulator_results(circuit):\n        # Run the circuit on the local simulator\n        job = execute(circuit, backend=Aer.get_backend(        'qasm_simulator'), shots=8192)\n        job_monitor(job)\n        results = job.result()\n        sim_counts = results.get_counts()\n        print(\"Simulator results:\\n\",sim_counts)\n        return(sim_counts)\n    ```", "```py\n    def noisy_results(circuit,backend):\n        # Select backend and run the circuit\n        job = execute(circuit, backend=backend, shots=8192)\n        job_monitor(job)\n        results = job.result()\n        noisy_counts = results.get_counts()\n        print(backend,\"results:\\n\",noisy_counts)\n        return(noisy_counts,results)\n    ```", "```py\n    def mitigated_results(circuit,backend,results):\n        # Import the required methods\n        from qiskit.providers.aer.noise import NoiseModel\n        from qiskit.ignis.mitigation.measurement import         (complete_meas_cal,CompleteMeasFitter)\n        # Get noise model for backend\n        noise_model = NoiseModel.from_backend(backend)\n        # Create the measurement fitter\n        qr = QuantumRegister(circuit.num_qubits)\n        meas_calibs, state_labels = complete_meas_cal(qr=qr,         circlabel='mcal')\n        job = execute(meas_calibs, backend=Aer.get_        backend('qasm_simulator'), shots=8192,         noise_model=noise_model)\n        cal_results = job.result()\n        meas_fitter = CompleteMeasFitter(cal_results,         state_labels, circlabel='mcal')\n        # Plot the calibration matrix\n        print(\"Calibration matrix\")\n        meas_fitter.plot_calibration()\n        # Get the filter object\n        meas_filter = meas_fitter.filter\n        # Results with mitigation\n        mitigated_results = meas_filter.apply(results)\n        mitigated_counts = mitigated_results.get_counts(0)\n        print(\"Mitigated\",backend,\"results:\\n\",        mitigated_counts)\n        return(mitigated_counts)\n    ```", "```py\n    def main():\n       backend=select_backend()\n       circ=create_circuit()\n       sim_counts=simulator_results(circ)\n       noisy_counts,results=noisy_results(circ,backend)\n       # Analyze and error correct the measurements\n       mitigated_counts=mitigated_results(circ,backend,        results)\n       # Show all results as a comparison\n       print(\"Final results:\")\n       display(plot_histogram([sim_counts, noisy_counts,         mitigated_counts], legend=['sim','noisy',         'mitigated']))\n    ```", "```py\n    from qiskit import QuantumCircuit, execute, Aer\n    from qiskit.visualization import plot_bloch_multivector, plot_state_qsphere\n    # Supporting methods\n    from math import pi\n    from random import random\n    from IPython.core.display import display\n    # Set the Aer simulator backend\n    backend = Aer.get_backend('qasm_simulator')\n    ```", "```py\n    def get_psi(qc):\n        global psi\n        backend = Aer.get_backend('statevector_simulator') \n        result = execute(qc, backend).result()\n        psi = result.get_statevector(qc)\n        return(psi)\n    ```", "```py\n    def add_error(error, circuit,ry_error, rz_error):\n        circuit.barrier([x for x in range(circuit.num_        qubits)])\n        if error==\"1\": #Bit flip error\n            circuit.x(0)\n        elif error==\"2\": #Bit flip plus phase flip error\n            circuit.x(0)\n            circuit.z(0)\n        else: #Theta plus phi shift and Random\n            circuit.ry(ry_error,0)\n            circuit.rz(rz_error,0)\n        circuit.barrier([x for x in range(circuit.num_        qubits)])\n        return(circuit)\n    ```", "```py\n    def not_corrected(error, ry_error, rz_error):\n        # Non-corrected code\n        qco = QuantumCircuit(1,1)\n        print(\"\\nOriginal qubit, in state \")\n        display(plot_bloch_multivector(get_psi(qco)))\n        display(plot_state_qsphere(get_psi(qco)))\n        # Add error\n        add_error(error,qco, ry_error, rz_error)\n        print(\"\\nQubit with error...\")\n        display(plot_bloch_multivector(get_psi(qco)))\n        display(plot_state_qsphere(get_psi(qco)))\n        qco.measure(0,0)\n        display(qco.draw('mpl'))\n        job = execute(qco, backend, shots=1000)        \n        counts = job.result().get_counts()\n        print(\"\\nResult of qubit error:\")\n        print(\"-----------------------\")\n        print(counts)\n    ```", "```py\n        add_error(error,qc, ry_error, rz_error)\n        print(\"Qubit with error... LSB can be in  and in         , with various phase.\")\n        display(plot_state_qsphere(get_psi(qc)))\n        display(qc.draw('mpl'))\n    ```", "```py\n        qc.cx(0,1)\n        qc.cx(3,4)\n        qc.cx(6,7)\n        qc.cx(0,2)\n        qc.cx(3,5)\n        qc.cx(6,8)\n        qc.ccx(1,2,0)\n        qc.ccx(4,5,3)\n        qc.ccx(8,7,6)\n    ```", "```py\n        qc.h(0)\n        qc.h(3)\n        qc.h(6)\n        qc.cx(0,3)\n        qc.cx(0,6)\n        qc.ccx(6,3,0)\n    ```", "```py\n        qc.barrier([x for x in range(qc.num_qubits)])\n        qc.measure(0,0)\n        print(\"Error corrected qubit... LSB in         with phase 0.\")\n        display(plot_state_qsphere(get_psi(qc)))\n        display(qc.draw('mpl'))\n        job = execute(qc, backend, shots=1000)        \n        counts = job.result().get_counts()\n        print(\"\\nResult of qubit error after         Shor code correction:\")\n        print(\"----------------------------------------------        ----\")\n        print(counts)\n    ```", "```py\n     def main():\n        error=\"1\"\n        ry_error=0\n        rz_error=0\n        while error!=\"0\":\n            error=input(\"Select an error:\\n1\\. Bit flip\\n2\\.             Bit flip plus phase flip\\n3\\. Theta plus phi             shift\\n4\\. Random\\n\")\n            if error==\"3\":\n                ry_error=float(input(\"Enter theta:\\n\"))\n                rz_error=float(input(\"Enter phi:\\n\"))\n            if error==\"4\":\n                ry_error=pi*random()\n                rz_error=2*pi*random()\n            not_corrected(error, ry_error, rz_error)\n            input(\"Press enter for error correction...\")\n            shor_corrected(error, ry_error, rz_error)\n    ```"]