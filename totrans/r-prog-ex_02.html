<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Understanding Votes with Descriptive Statistics</h1>
                
            
            <article>
                
<p class="calibre2">This chapter shows how to perform a descriptive statistics analysis to get a general idea about the data we're dealing with, which is usually the first step in data analysis projects and is a basic ability for data analysts in general. We will learn how to clean and transform data, summarize data in a useful way, find specific observations, create various kinds of plots that provide intuition for the data, use correlations to understand relations among numerical variables, use principal components to find optimal variable combinations, and put everything together into code that is reusable, understandable, and easily modifiable.</p>
<p class="calibre2">Since this is a book about programming with R and not about doing statistics with R, our focus will be on the programming side of things, not the statistical side. Keep that in mind while reading it.</p>
<p class="calibre2">Some of the important topics covered in this chapter are as follows:</p>
<ul class="calibre11">
<li class="calibre12">Cleaning, transforming, and operating on data</li>
<li class="calibre12">Creating various kinds of graphs programmatically</li>
<li class="calibre12">Performing qualitative analysis with various tools in R</li>
<li class="calibre12">Building new variables with Principal Components Analysis</li>
<li class="calibre12">Developing modular and flexible code that is easy to work with</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">This chapter's required packages</h1>
                
            
            <article>
                
<p class="calibre2">During this chapter we will make use of the following R packages. If you don't already have them installed, you can look into <a href="part0296.html#8Q96G0-f494c932c729429fb734ce52cafce730" class="calibre4">Appendix</a><em class="calibre19">, Required Packages </em>for instructions on how do so.</p>
<table class="calibre5">
<tbody class="calibre6">
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><strong class="calibre1">Package</strong></p>
</td>
<td class="calibre8">
<p class="calibre2"><strong class="calibre1">Used for</strong></p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">ggplot2</kbd></p>
</td>
<td class="calibre8">
<p class="calibre2">High-quality graphs</p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">viridis</kbd></p>
</td>
<td class="calibre8">
<p class="calibre2">Color palette for graphs</p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">corrplot</kbd></p>
</td>
<td class="calibre8">
<p class="calibre2">Correlation plots</p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9"><span>ggbiplot</span></kbd></p>
</td>
<td class="calibre8">
<p class="calibre2">Principal components plots</p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9"><span>progress</span></kbd></p>
</td>
<td class="calibre8">
<p class="calibre2">Show progress for iterations</p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The Brexit votes example</h1>
                
            
            <article>
                
<p class="calibre2">In June 2016, a referendum was held in the <strong class="calibre1">United Kingdom</strong> (<strong class="calibre1">UK</strong>) to decide whether or not to remain part of the <strong class="calibre1">European Union</strong> (<strong class="calibre1">EU</strong>). 72% of registered voters took part, and of those, 51.2% voted to leave the EU. In February 2017, Martin Rosenbaum, freedom of information specialist at BBC News, published the article, <em class="calibre19">Local Voting Figures Shed New Light on EU Referendum</em> (<a href="http://www.bbc.com/news/uk-politics-38762034" class="calibre4">http://www.bbc.co.uk/news/uk-politics-38762034</a>). He obtained data from 1,070 electoral wards (the smallest administrative division for electoral purposes in the UK), with numbers for <strong class="calibre1">Leave</strong> and <strong class="calibre1">Remain</strong> votes in each ward.</p>
<p class="calibre2">Martin Rosenbaum calculated some statistical associations between the proportion of <strong class="calibre1">Leave</strong> votes in a ward and some of its social, economic, and demographic characteristics by making use of the most recent UK census, which was conducted in 2011. He used his data for a university class, and that's the data we will use in this example, with some variables removed. The data is provided in a CSV file (<kbd class="calibre9">data_brexit_referendum.csv</kbd>) which can be found in the accompanying code repository for this book (<a href="https://github.com/PacktPublishing/R-Programming-By-Example" class="calibre4">https://github.com/PacktPublishing/R-Programming-By-Example</a>). The table shows the variables included in the data:</p>
<div class="cdpaligncenter"><img src="../images/00009.jpeg" class="calibre28"/></div>
<div class="mce-root2">Data variable descriptions</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Cleaning and setting up the data</h1>
                
            
            <article>
                
<p class="calibre2">Setting up the data for this example is straightforward. We will load the data, correctly label missing values, and create some new variables for our analysis. Before we start, make sure the <kbd class="calibre9">data.csv</kbd> file is in the same directory as the code you're working with, and that your <em class="calibre19">working directory</em> is properly setup. If you don't know how to do so, setting up your working directory is quite easy, you simply call the <kbd class="calibre9">setwd()</kbd> function passing the directory you want to use as such. For example, <kbd class="calibre9">setwd(/home/user/examples/)</kbd> would use the <kbd class="calibre9">/home/user/examples</kbd> directory to look for files, and save files to.</p>
<p class="calibre2">If you don’t know how to do so, setting up your working directory is quite easy, you simply call the <kbd class="calibre9">setwd()</kbd> function passing the directory you want to use as such. For example, <kbd class="calibre9">setwd(/home/user/examples/)</kbd> would use the /home/user/examples directory to look for files, and save files to.</p>
<p class="calibre2">We can load the contents of the <kbd class="calibre9">data.csv</kbd> file into a data frame (the most intuitive structure to use with data in CSV format) by using the <kbd class="calibre9">read.csv()</kbd> function. Note that the data has some missing values in the <kbd class="calibre9">Leave</kbd> variable. These values have a value of <kbd class="calibre9">-1</kbd> to identify them. However, the proper way to identify missing values in R is with <kbd class="calibre9">NA</kbd>, which is what we use to replace the <kbd class="calibre9">-1</kbd> values.</p>
<pre class="mce-root">data &lt;- read.csv("./data_brexit_referendum.csv") <br class="title-page-name"/>data[data$Leave == -1, "Leave"] &lt;- NA </pre>
<p class="calibre2">To count the number of missing values in our data, we can use the <kbd class="calibre9">is.na()</kbd> function to get a logical (Boolean) vector that contains <kbd class="calibre9">TRUE</kbd> values to identify missing values and <kbd class="calibre9">FALSE</kbd> values to identify non-missing values. The length of such a vector will be equal to the length of the vector used as input, which is the <kbd class="calibre9">Leave</kbd> variable in our case. Then, we can use this logical vector as input for <kbd class="calibre9">sum()</kbd> while leverage the way R treats such <kbd class="calibre9">TRUE/FALSE</kbd> values to get the number of missing values. <kbd class="calibre9">TRUE</kbd> is treated as <kbd class="calibre9">1</kbd>, while <kbd class="calibre9">FALSE</kbd> is treated as <kbd class="calibre9">0</kbd>. We find that the number of missing values in the <kbd class="calibre9">Leave</kbd> variable is 267.</p>
<pre class="mce-root">sum(is.na(data$Leave))<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 267</strong></pre>
<p class="calibre2">If we want to, we can use a mechanism to fill the missing values. A common and straightforward mechanism is to impute the variable's mean. In our case, in <a href="part0076.html#28FAO0-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 3</a>, <em class="calibre19">Predicting Votes with Linear Models</em>, we will use linear regression to estimate these missing values. However, we will keep things simple for now and just leave them as missing values.</p>
<p class="calibre2">We now proceed to defining a new variable, <kbd class="calibre9">Proportion</kbd>, which will contain the percentage of votes in favor of leaving the EU. To do so we divide the <kbd class="calibre9">Leave</kbd> variable (number of votes in favor of leaving) by the <kbd class="calibre9">NVotes</kbd> variable (number of votes in total), for each ward. Given the vectorized nature of R, this is straightforward:</p>
<pre class="mce-root">data$Proportion &lt;- data$Leave / data$NVotes</pre>
<div class="packt_infobox">We are creating a new variable in the data frame by simply assigning to it. There's no difference between creating a new variable and modifying an existing one, which means that we need to be careful when doing so to make sure we're not overwriting an old variable by accident.</div>
<p class="calibre2">Now, create a new variable that contains a classification of whether most of the wards voted in favor of leaving or remaining in the EU. If more than 50 percent of each ward's votes were in favor of leaving, then we will mark the ward as having voted for leaving, and vice versa for remaining. Again, R makes this very simple with the use of the <kbd class="calibre9">ifelse()</kbd> function. If the mentioned condition (first parameter) holds true, then the value assigned will be <kbd class="calibre9">"Leave"</kbd> (second parameter); otherwise it will be <kbd class="calibre9">"Remain"</kbd> (third parameter). This is a vectorized operation, so it will be done for each observation in the data frame:</p>
<pre class="mce-root">data$Vote &lt;- ifelse(data$Proportion &gt; 0.5, "Leave", "Remain")</pre>
<p class="calibre2">Sometimes, people like to use a different syntax for these types of operations; they will use a <em class="calibre19">subset-assign approach,</em> which is slightly different from what we used. We won't go into the details of the differences among these approaches, but keep in mind that the latter approach may give you an error in our case:</p>
<pre class="mce-root">data[data$Proportion &gt;  0.5, "Vote"] &lt;- "Leave"
data[data$Proportion &lt;= 0.5, "Vote"] &lt;- "Remain"<span><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">#&gt; Error in `[&lt;-.data.frame`(`*tmp*`, data$Proportion 0.5, "Vote", value = "Leave"): </strong><br class="title-page-name"/><strong class="calibre1">#&gt;   missing values are not allowed in subscripted assignments of data frames</strong></span></pre>
<p class="calibre2">This happens because the <kbd class="calibre9">Proportion</kbd> variable contains some missing values that were consequences of the <kbd class="calibre9">Leave</kbd> variable having some <kbd class="calibre9">NA</kbd> values in the first place. Since we can't compute a <kbd class="calibre9">Proportion</kbd> value for observations with <kbd class="calibre9">NA</kbd> values in <kbd class="calibre9">Leave</kbd>, when we create it, the corresponding values also get an <kbd class="calibre9">NA</kbd> value assigned.</p>
<p class="calibre2">If we insist on using the <em class="calibre19">subset-assign approach,</em> we can make it work by using the <kbd class="calibre9">which()</kbd> function. It will ignore (returning as <kbd class="calibre9">FALSE</kbd>) those values that contain <kbd class="calibre9">NA</kbd> in the comparison. This way it won't give us an error, and we will get the same result as using the <kbd class="calibre9">ifelse()</kbd> function. We should use the <kbd class="calibre9">ifelse()</kbd> function when possible because it's simpler, easier to read, and more efficient (more about this in <a href="part0229.html#6QCGQ0-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 9</a>, <em class="calibre19">Implementing an Efficient Simple Moving Average</em>).</p>
<pre class="mce-root">data[which(data$Proportion &gt;  0.5), "Vote"] &lt;- "Leave"
data[which(data$Proportion &lt;= 0.5), "Vote"] &lt;- "Remain"</pre>
<p class="calibre2">Down the road we will want to create plots that include the <kbd class="calibre9">RegionName</kbd> information and having long names will most likely make them hard to read. To fix that we can shorten those names while we are in the process of cleaning the data.</p>
<pre class="mce-root">data$RegionName &lt;- as.character(data$RegionName)<br class="title-page-name"/>data[data$RegionName == "London", "RegionName"]                   &lt;- "L"<br class="title-page-name"/>data[data$RegionName == "North West", "RegionName"]               &lt;- "NW"<br class="title-page-name"/>data[data$RegionName == "North East", "RegionName"]               &lt;- "NE"<br class="title-page-name"/>data[data$RegionName == "South West", "RegionName"]               &lt;- "SW"<br class="title-page-name"/>data[data$RegionName == "South East", "RegionName"]               &lt;- "SE"<br class="title-page-name"/>data[data$RegionName == "East Midlands", "RegionName"]            &lt;- "EM"<br class="title-page-name"/>data[data$RegionName == "West Midlands", "RegionName"]            &lt;- "WM"<br class="title-page-name"/>data[data$RegionName == "East of England", "RegionName"]          &lt;- "EE"<br class="title-page-name"/>data[data$RegionName == "Yorkshire and The Humber", "RegionName"] &lt;- "Y"</pre>
<p class="calibre2">Note that the first line in the previous code block is assigning a transformation of the <kbd class="calibre9">RegionName</kbd> into character type. Before we do this, the type of the variable is factor (which comes from the default way of reading data with <kbd class="calibre9">read.csv()</kbd>), and it prevents us from assigning a different value from the ones already contained in the variable. In such a case, we will get an error, <kbd class="calibre9">Invalid factor level, NA generated</kbd>. To avoid this problem, we need to perform the type transformation.</p>
<p class="calibre2">We now have clean data ready for analysis. We have created a new variable of interest for us (<kbd class="calibre9">Proportion</kbd>), which will be the focus of the rest of this chapter and the next one, since in this example, we're interested in finding out the relations among other variables and how people voted in the referendum.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summarizing the data into a data frame</h1>
                
            
            <article>
                
<p class="calibre2">To get a summary of the data, we may execute <kbd class="calibre9">summary(data)</kbd> and see the relevant summaries for each type of variable. The summary is tailored for each column's data type. As you can see, numerical variables such as <kbd class="calibre9">ID</kbd> and <kbd class="calibre9">NVotes</kbd> get a quantile summary, while factor (categorical) variables get a count for each different category, such as <kbd class="calibre9">AreaType</kbd> and <kbd class="calibre9">RegionName</kbd>. If there are many categories, the summary will show the categories that appear the most and group the rest into a (<kbd class="calibre9">Other</kbd>) group, as we can see at the bottom of <kbd class="calibre9">RegionName</kbd>.</p>
<pre class="mce-root">summary(data)<br class="title-page-name"/><strong class="calibre1">#&gt;       ID        RegionName              NVotes          Leave</strong><br class="title-page-name"/><strong class="calibre1">#&gt; Min.   :  1    Length: 1070        Min.   : 1039    Min.   : 287</strong><br class="title-page-name"/><strong class="calibre1">#&gt; 1st Qu.: 268   Class : character   1st Qu.: 4252    1st Qu.: 1698</strong><br class="title-page-name"/><strong class="calibre1">#&gt; Median : 536   Mode  : character   Median : 5746    Median : 2874</strong><br class="title-page-name"/><strong class="calibre1">#&gt; Mean   : 536                       Mean   : 5703    Mean   : 2971</strong><br class="title-page-name"/><strong class="calibre1">#&gt; 3rd Qu.: 803                       3rd Qu.: 7020    3rd Qu.: 3936</strong><br class="title-page-name"/><strong class="calibre1">#&gt; Max.   : 1070                      Max.   : 15148   Max.   : 8316</strong><br class="title-page-name"/><strong class="calibre1">(Truncated output)</strong></pre>
<p class="calibre2">From here, we can see that London is the region to which more wards belong, followed by the North West and West Midlands. We can also see that the ward with the least votes in all of the data had only 1,039 votes, the one with the most votes had 15,148, and the mean number of votes per ward was 5,703. We will take a deeper look into these kinds of analyses later in the chapter. For now we'll focus on making this summary data useful for further analysis. As you may have noticed, we can't use the <kbd class="calibre9">summary()</kbd> results to make computations. We can try to save the summary into a variable, find out the variable type, and traverse it in an appropriate way. However, if we do that we will find that it's text data, which means that we can't use it for computations as it is:</p>
<pre class="mce-root">summary &lt;- summary(data) <br class="title-page-name"/>class(summary) <br class="title-page-name"/><strong class="calibre1">#&gt; [1] "table"</strong><br class="title-page-name"/>summary[1]<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "Min.   : 1  "</strong><br class="title-page-name"/>class(summary[1])<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "character"</strong></pre>
<p class="calibre2">Surely, there must be a way to get the <kbd class="calibre9">summary</kbd> data into a data frame for further analysis. This is R, so you can bet there is! The first thing we should note is that we can't directly translate the output of the <kbd class="calibre9">summary()</kbd> function into a data frame because of the non-numerical variables. These non-numerical variables contain a different summary structure which is not composed of the minimum, first quartile, median, mean, third quartile, and maximum values. This means that we first need to subset the data to get only the numerical variables. After all, a data frame is a rectangular structure with well defined rows and columns. If we tried to mix types (by including numerical and non-numerical summaries) into the data frame, we would have a hard time doing so.</p>
<p class="calibre2">To find if a column is numeric or not, we can use the <kbd class="calibre9">is.numeric()</kbd> function. For example, we can see that the <kbd class="calibre9">Proportion</kbd> column is numeric and the <kbd class="calibre9">RegionName</kbd> is not:</p>
<pre class="mce-root">is.numeric(data$Proportion) <br class="title-page-name"/><strong class="calibre1">#&gt; [1] TRUE</strong>
is.numeric(data$RegionName)<br class="title-page-name"/>#&gt; [1] FALSE</pre>
<p class="calibre2">We can then apply <kbd class="calibre9">is.numeric()</kbd> to each column by using the <kbd class="calibre9">sapply()</kbd> function. This will give us a logical (Boolean) vector with a <kbd class="calibre9">TRUE</kbd> or <kbd class="calibre9">FALSE</kbd> value for each column, indicating whether or not it's numeric. Then we can use this logical vector to subset our data and get only the numerical columns with <kbd class="calibre9">data[, numerical_variables]</kbd>. As you can see, there are no non-numerical columns in the <kbd class="calibre9">data_numerical</kbd> object:</p>
<pre class="mce-root">numerical_variables &lt;- sapply(data, is.numeric) <br class="title-page-name"/>numerical_variables <br class="title-page-name"/><strong class="calibre1">#&gt;            ID   RegionName         NVotes       Leave   Residents</strong><br class="title-page-name"/><strong class="calibre1">#&gt;          TRUE        FALSE           TRUE        TRUE        TRUE</strong><br class="title-page-name"/><strong class="calibre1">#&gt;    Households      MeanAge   AdultMeanAge   Aget_0to4   Age_5to7</strong><br class="title-page-name"/><strong class="calibre1">#&gt;          TRUE         TRUE           TRUE        TRUE        TRUE</strong><br class="title-page-name"/>(Truncated output)<br class="title-page-name"/><br class="title-page-name"/>data_numerical &lt;- data[, numerical_variables] <br class="title-page-name"/>colnames(data_numerical)<br class="title-page-name"/><strong class="calibre1">#&gt;  [1] "ID"           "Nvotes"       "Leave"          "Residents"</strong><br class="title-page-name"/><strong class="calibre1">#&gt;  [5] "Households"   "MeanAge"      "AdultMeanAge"   "Age_0to4"</strong><br class="title-page-name"/><strong class="calibre1">#&gt;  [9] "Age_5to7"     "Age_8to9"     "Age_10to14"     "Age_15"</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [13] "Age_16to17    "Age_18to19"   "Age_20to24"     "Age_25to29"</strong><br class="title-page-name"/><strong class="calibre1">(Truncated output)</strong></pre>
<p class="calibre2">Since it doesn't make much sense to get the <kbd class="calibre9">summary</kbd> values for the <kbd class="calibre9">ID</kbd> variable, we can remove it from the logical vector, effectively treating it as a non-numerical variable. If we do, we must remember to recreate the <kbd class="calibre9">data_numeric</kbd> object to make sure it doesn't include the <kbd class="calibre9">ID</kbd> variable also:</p>
<pre class="mce-root">numerical_variables[["ID"]] &lt;- FALSE <br class="title-page-name"/>data_numerical &lt;- data[, numerical_variables]</pre>
<p class="calibre2">To create our numerical variables summary, we first will apply the <kbd class="calibre9">summary()</kbd> function we used before to each numerical column using the <kbd class="calibre9">lapply()</kbd> function. The <kbd class="calibre9">lapply()</kbd> function returns a named list, where each list member has the corresponding column name:</p>
<pre class="mce-root">lapply(data[, numerical_variables], summary)<br class="title-page-name"/><strong class="calibre1">#&gt; $NVotes</strong><br class="title-page-name"/><strong class="calibre1">#&gt;    Min. 1st Qu. Median  Mean 3rd Qu.  Max.</strong><br class="title-page-name"/><strong class="calibre1">#&gt;    1039    4252   5746  5703   7020  15148</strong><br class="title-page-name"/><strong class="calibre1">#&gt;</strong><br class="title-page-name"/><strong class="calibre1">#&gt; $Leave</strong><br class="title-page-name"/><strong class="calibre1">#&gt;    Min. 1st Qu. Median  Mean 3rd Qu.  Max.</strong><br class="title-page-name"/><strong class="calibre1">#&gt;     287    1698   2874  2971    3936  8316</strong><br class="title-page-name"/><strong class="calibre1">#&gt;</strong><br class="title-page-name"/><strong class="calibre1">#&gt; $Residents</strong><br class="title-page-name"/><strong class="calibre1">#&gt;    Min. 1st Qu. Median   Mean 3rd Qu.   Max.</strong><br class="title-page-name"/><strong class="calibre1">#&gt;    1932    8288  11876  11646   14144  34098</strong><br class="title-page-name"/><strong class="calibre1">#&gt;</strong><br class="title-page-name"/><strong class="calibre1">(Truncated output)</strong></pre>
<p class="calibre2">Now we need to put each member of this list together into a data frame. To do so, we will use the <kbd class="calibre9">cbind()</kbd> and <kbd class="calibre9">do.call()</kbd> functions. <kbd class="calibre9">do.call()</kbd> will consecutively apply <kbd class="calibre9">cbind()</kbd> to each member of the list generated by <kbd class="calibre9">lapply()</kbd> and return them all together. To get a reminder on how these vectorized operations work, take a look at <a href="part0022.html#KVCC0-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 1</a>, <em class="calibre19">Introduction to R:</em></p>
<pre class="mce-root">numerical_summary &lt;- do.call(cbind, lapply(data_numerical, summary))<br class="title-page-name"/><strong class="calibre1">#&gt; Warning in (function (..., deparse.level = 1) : number of rows of result is</strong><br class="title-page-name"/><strong class="calibre1">#&gt; not a multiple of vector length (arg 1)</strong><br class="title-page-name"/><br class="title-page-name"/>numerical_summary<br class="title-page-name"/><strong class="calibre1">#&gt;          NVotes Leave Residents Households MeanAge AdultMeanAge Age_0to4</strong><br class="title-page-name"/><strong class="calibre1">#&gt; Min.       1039   287      1932       779    27.80        29.20    2.200</strong><br class="title-page-name"/><strong class="calibre1">#&gt; 1st Qu.    4252  1698      8288      3466    35.60        44.10    5.400</strong><br class="title-page-name"/><strong class="calibre1">#&gt; Median     5746  2874     11876      4938    38.70        47.40    6.300</strong><br class="title-page-name"/><strong class="calibre1">#&gt; Mean       5703  2971     11646      4767    38.45        46.85    6.481</strong><br class="title-page-name"/><strong class="calibre1">#&gt; 3rd Qu.    7020  3936     14144      5832    41.40        49.90  7.50058</strong><br class="title-page-name"/><strong class="calibre1">#&gt; Max.      15148  8316     34098     15726    51.60        58.10   12.300</strong><br class="title-page-name"/><strong class="calibre1">#&gt; NA's       1039   267      1932       779    27.80        29.20    2.200</strong></pre>
<p class="calibre2">We got our results, but not so fast! We got a warning, and it looks suspicious. What does this <kbd class="calibre9">number of rows of result is not a multiple of vector length</kbd> message mean? Aha! If we take a more detailed look at the list we previously got from our <kbd class="calibre9">lapply()</kbd> function, we can see that in the case of <kbd class="calibre9">Leave</kbd> (and <kbd class="calibre9">Proportion</kbd>) we get an extra column for <kbd class="calibre9">NAs</kbd> that we don't get for any other column. That means that when we try to use <kbd class="calibre9">cbind()</kbd> on these columns, the extra <kbd class="calibre9">NAs</kbd> column will create an extra space that needs to be filled. This is a problem we looked at in <a href="part0022.html#KVCC0-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 1</a>, <em class="calibre19">Intro</em><em class="calibre19">duction to R</em>.</p>
<p class="calibre2">As we saw, then, R deals with it by repeating the vectors in order until all spaces are filled. In our case this means that the first element, the one corresponding to the minimum value, will be repeated for the <kbd class="calibre9">NAs</kbd> space for each column that doesn't have an <kbd class="calibre9">NAs</kbd> space. You can verify this by comparing the numbers of the <kbd class="calibre9">Min</kbd> and <kbd class="calibre9">NAs</kbd> columns for variables other than <kbd class="calibre9">Leave</kbd> or <kbd class="calibre9">Proportion</kbd> (for these two, the values should actually be different).</p>
<p class="calibre2">To fix it we can just remove the extra <kbd class="calibre9">NA</kbd> value's row from the resulting data frame, but this would not deal with the warning's source, only the symptom. To deal with the source, we need to have the  same number of columns for each variable before we apply <kbd class="calibre9">cbind()</kbd>. Since we already know that we have 267 missing values for the <kbd class="calibre9">Leave</kbd> variable, which then affects the <kbd class="calibre9">Proportion</kbd> variable, we can easily fix this by just ignoring that information. To do so, we simply use the <em class="calibre19">complete cases</em>, meaning that we keep observations that don't have any <kbd class="calibre9">NA</kbd> values in any of their variables; or, put another way, we drop every observation that contains at least one <kbd class="calibre9">NA</kbd>. Once we do that, we get our results back and we don't get any warnings:</p>
<pre class="mce-root">data &lt;- data[complete.cases(data), ] <br class="title-page-name"/>data_numerical &lt;- data[, numerical_variables] <br class="title-page-name"/>numerical_summary &lt;- do.call(cbind, lapply(data_numerical, summary))<br class="title-page-name"/>numerical_summary<br class="title-page-name"/><strong class="calibre1">#&gt;         NVotes Leave Residents Households MeanAge AdultMeanAge Age_0to4</strong><br class="title-page-name"/><strong class="calibre1">#&gt; Min.      1039   287      1932        779   28.40        30.50    2.200</strong><br class="title-page-name"/><strong class="calibre1">#&gt; 1st Qu.   4242  1698      8405       3486   35.70        44.10    5.400</strong><br class="title-page-name"/><strong class="calibre1">#&gt; Median    5739  2874     11911       4935   38.60        47.40    6.300</strong><br class="title-page-name"/><strong class="calibre1">#&gt; Mean      5725  2971     11739       4793   38.43        46.83    6.479</strong><br class="title-page-name"/><strong class="calibre1">#&gt; 3rd Qu.   7030  3936     14200       5850   41.40        49.90    7.500</strong><br class="title-page-name"/><strong class="calibre1">#&gt; Max.     15148 8316      34098      15726   47.30        56.10   12.300</strong><br class="title-page-name"/><strong class="calibre1">(Truncated output)</strong></pre>
<p class="calibre2">If we want to get the summary values as columns and the variables as rows, we can use the <kbd class="calibre9">rbind()</kbd> function instead of <kbd class="calibre9">cbind()</kbd>. The structure we actually end up using will depend on what we want to do with it. However, we can easily change between them later if we need to:</p>
<pre class="mce-root">do.call(rbind, lapply(data_numerical, summary))<br class="title-page-name"/><strong class="calibre1">#&gt;                  Min.    1st Qu.    Median       Mean     3rd Qu.      Max.</strong><br class="title-page-name"/><strong class="calibre1">#&gt; NVotes     1039.0000  4241.5000  5.739e+03  5.725e+03  7.030e+03  1.515e+04</strong><br class="title-page-name"/><strong class="calibre1">#&gt; Leave       287.0000  1697.5000  2.874e+03  2.971e+03  3.936e+03  8.316e+03</strong><br class="title-page-name"/><strong class="calibre1">#&gt; Residents  1932.0000  8405.0000  1.191e+04  1.174e+04  1.420e+04  3.410e+04</strong><br class="title-page-name"/><strong class="calibre1">#&gt; Households  779.0000  3486.0000  4.935e+03  4.793e+03  5.850e+03  1.573e+04</strong><br class="title-page-name"/><strong class="calibre1">#&gt; MeanAge      28.4000    35.7000  3.860e+01  3.843e+01  4.140e+01  4.730e+01</strong></pre>
<p class="calibre2">Now that we have this <kbd class="calibre9">numerical_summary</kbd> object, we can use it to perform computations, such as finding the range between the wards with the least and most proportions of votes in favor of leaving (0.6681), which may be useful to interpret the big difference among the <em class="calibre19">types</em> of wards we may find in the UK. If we want to know which wards are being used to get to this result, we can search for the wards with the least and most proportion of votes:</p>
<pre class="mce-root">numerical_summary["Max.", "Proportion"] - numerical_summary["Min.", "Proportion"] <br class="title-page-name"/>desired_variables &lt;- c( <br class="title-page-name"/>    "ID", <br class="title-page-name"/>    "NoQuals", <br class="title-page-name"/>    "Proportion", <br class="title-page-name"/>    "AdultMeanAge", <br class="title-page-name"/>    "L4Quals_plus", <br class="title-page-name"/>    "RegionName" <br class="title-page-name"/>) <br class="title-page-name"/><br class="title-page-name"/>&gt;data[which.max(data$Proportion), desired_variables]<br class="title-page-name"/><strong class="calibre1">#&gt;        ID NoQuals Proportion AdultMeanAge L4Quals_plus RegionName</strong><br class="title-page-name"/><strong class="calibre1">#&gt; 754   754    35.8     0.7897         48.7         13.7          L</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">data[which.min(data$Proportion), desired_variables]</strong><br class="title-page-name"/><strong class="calibre1">#&gt;      ID NoQuals Proportion AdultMeanAge L4Quals_plus RegionName</strong><br class="title-page-name"/><strong class="calibre1">#&gt; 732 732     2.8     0.1216         31.2         44.3         EE</strong></pre>
<p class="calibre2">As you can see, this analysis already shows some interesting results. The UK ward that voted to leave the EU the most is characterized by older people (<kbd class="calibre9">MeanAge</kbd>) with low education levels (<kbd class="calibre9">NoQuals</kbd>, <kbd class="calibre9">L4Quals_plus</kbd>). On the other hand, the UK ward that voted to remain in the EU the most is characterized by younger people with much higher education levels. Of course, this is not the full picture, but it's a hint about the direction in which we need to look to further understand what's going on. For now, we have found that education and age seem to be relevant variables for the analysis.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Getting intuition with graphs and correlations</h1>
                
            
            <article>
                
<p class="calibre2">Now that we have some clean data to work with, we will create lots of plots to build intuition about the data. In this chapter, we will work with plots that are easy to create and are used for exploratory purposes. In <a href="part0091.html#2MP360-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 4</a>, <em class="calibre19">Simulating Sales Data and Working with Databases,</em> we will look into publication ready plots that are a little more verbose to create.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Visualizing variable distributions</h1>
                
            
            <article>
                
<p class="calibre2">Our first plot is a simple one and shows the proportion of votes by each <kbd class="calibre9">RegionName</kbd>. As you can see in the plot shown below, the London, North West, and West Midlands regions account for around 55 percent of the observations in the data.</p>
<div class="cdpaligncenter"><img src="../images/00010.jpeg" class="calibre29"/></div>
<div class="mce-root2">Vote Proportion by Region</div>
<p class="calibre2">To create the plot, we need to create a table for the frequencies of each region in <kbd class="calibre9">RegionName</kbd> with the <kbd class="calibre9">table()</kbd> function, then we feed that to the <kbd class="calibre9">prop.table()</kbd> function, which computes the corresponding proportions, which in turn are used as heights for each bar.</p>
<p class="calibre2">We use the <kbd class="calibre9">barplot()</kbd> function to produce the plot, and we can specify some options, such as the title (<kbd class="calibre9">main</kbd>), the <em class="calibre19">y</em> axis label (<kbd class="calibre9">ylab</kbd>), and the color for the bars (<kbd class="calibre9">col</kbd>). As always, you can find out more about in the function's parameters with <kbd class="calibre9">? barplot</kbd>:</p>
<pre class="mce-root">table(data$RegionName) <br class="title-page-name"/><strong class="calibre1">#&gt; EE EM   L NE  NW SE SW  WM  Y</strong><br class="title-page-name"/><strong class="calibre1">#&gt; 94 20 210 32 134 79 23 133 78</strong><br class="title-page-name"/><br class="title-page-name"/>prop.table(table(data$RegionName))<br class="title-page-name"/><strong class="calibre1">#&gt;      EE      EM       L      NE      NW      SE      SW      WM       Y</strong><br class="title-page-name"/><strong class="calibre1">#&gt; 0.11706 0.02491 0.26152 0.03985 0.16687 0.09838 0.02864 0.16563 0.09714</strong><br class="title-page-name"/><br class="title-page-name"/>barplot( <br class="title-page-name"/>    height = prop.table(table(data$RegionName)), <br class="title-page-name"/>    main = "Vote Proportion by Region", <br class="title-page-name"/>    ylab = "Frequency", <br class="title-page-name"/>    col = "white"<br class="title-page-name"/>)</pre>
<p class="calibre2">Our next plot, shown below, is a little more eye-catching. Each point represents a ward observation, and it shows the <kbd class="calibre9">Proportion</kbd> of <kbd class="calibre9">Leave</kbd> votes for each ward, arranged in vertical lines corresponding to <kbd class="calibre9">RegionName</kbd> and colored by the proportion of white population for each ward. As you can see, we have another interesting finding; it seems that the more diversified a ward's population is (seen in the darker points), the more likely it is for the ward to vote in favor of remaining in the EU (a lower <kbd class="calibre9">Proportion</kbd> value).</p>
<div class="cdpaligncenter"><img src="../images/00011.jpeg" class="calibre30"/></div>
<div class="mce-root2">Proportion by RegionName and White Population Percentage</div>
<p class="calibre2">To create the plot, we need to load the <kbd class="calibre9">ggplot2</kbd> and <kbd class="calibre9">viridis</kbd> packages; the first one will be used to create the actual plot, while the second one will be used to color the points with a scientifically interesting color palette called <strong class="calibre1">Viridis</strong> (it comes from color perception research done by Nathaniel Smith and Stéfan van der Walt, <a href="http://bids.github.io/colormap/" class="calibre4">http://bids.github.io/colormap/</a>). The details of the <kbd class="calibre9">ggplot2</kbd> syntax will be explained in <a href="part0091.html#2MP360-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 4</a>, <em class="calibre19">Simulating Sales Data and Working with Databases</em>, but for now, all you need to know is that the function receives as a first parameter the data frame with the data that will be used for the plot, and as a second parameter an aesthetics object (<kbd class="calibre9">aes</kbd>), created with the <kbd class="calibre9">aes()</kbd> function, which in turn can receive parameters for the variable that should be used in the <em class="calibre19">x</em> axis, <em class="calibre19">y</em> axis, and color. After that, we add a <em class="calibre19">points layer</em> with the <kbd class="calibre9">geom_points()</kbd> function, and the Viridis color palette with the <kbd class="calibre9">scale_color_viridis()</kbd> function. Notice how we are adding plot objects while we work with <kbd class="calibre9">ggplot2</kbd>. This is a very convenient feature that provides a lot of power and flexibility. Finally, we show the plot with the <kbd class="calibre9">print()</kbd> function (in R, some functions used for plotting immediately show the plot (for example, <kbd class="calibre9">barplot</kbd>), while others return a plot object (for example, <kbd class="calibre9">ggplot2</kbd>) and need to be printed explicitly):</p>
<pre class="mce-root">library(ggplot2)
library(viridis)

plot &lt;- ggplot(data, aes(x = RegionName, y = Proportion, color = White))
plot &lt;- plot + geom_point() + scale_color_viridis()
print(plot)</pre>
<p class="calibre2">The next set of plots, shown below, display histograms for the <kbd class="calibre9">NoQuals</kbd>, <kbd class="calibre9">L4Quals_plus</kbd>, and <kbd class="calibre9">AdultMeanAge</kbd> variables. As you can see, the <kbd class="calibre9">NoQuals</kbd> variable appears to be normally distributed, but the <kbd class="calibre9">L4Quals_plus</kbd> and <kbd class="calibre9">AdultMeanAge</kbd> variables seemed to be skewed towards the left and right, correspondingly. These tell us that most people in the sample don't have high education levels and are past 45 years of age.</p>
<div class="cdpaligncenter">
<div class="cdpaligncenter"><img src="../images/00012.jpeg" class="calibre31"/></div>
<div class="mce-root2">Histogram for NoQuals, L4Quals_plus, and AdultMeanAge</div>
</div>
<p class="calibre2">Creating these plots is simple enough; you just need to pass the variable that will be used for the histogram into the <kbd class="calibre9">hist()</kbd> function, and optionally specify a title and <em class="calibre19">x</em> axis label for the plots (which we leave empty, as the information is already in the plot's title).</p>
<div class="packt_infobox">For the book, we arranged plots in such a way that their spacing and understanding is efficient, but when you create the plots using the code shown, you'll see them one by one. There are ways to group various plots together, but we'll look at them in <a href="part0091.html#2MP360-f494c932c729429fb734ce52cafce730" class="calibre26">Chapter 4</a>, <em class="calibre27">Simulating Sales Data and Working with Databases</em>).</div>
<p class="calibre2">Let's have a look at the following code:</p>
<pre class="mce-root">hist(data$NoQuals, main = "Histogram for NoQuals", xlab = "")
hist(data$L4Quals_plus, main = "Histogram for L4Quals_plus", xlab = "")
hist(data$AdultMeanAge, main = "Histogram for AdultMeanAge", xlab ="")</pre>
<p class="calibre2">Now that we understand a bit more about the distribution of the <kbd class="calibre9">NoQuals</kbd>, <kbd class="calibre9">L4Quals_plus</kbd>, and <kbd class="calibre9">AdultMeanAge</kbd> variables, we will see their joint-distribution in the scatter plots shown below. We can see how these scatter plots resemble the histograms by comparing the <em class="calibre19">x</em> axis and <em class="calibre19">y</em> axis <span>in the scatter plots to the corresponding </span><em class="calibre19">x</em><span> axis in the histograms, and comparing the frequency (height) in the histograms with the point density in the scatter plots.</span></p>
<div class="cdpaligncenter"><img src="../images/00013.jpeg" class="calibre32"/></div>
<div class="mce-root2">Scatter plots for NoQuals, L4Quals_plus vs AdultMeanAge</div>
<p class="calibre2">We find a slight relation that shows that the older the people, the lower the levels of education they have. This can be interpreted in a number of ways, but we'll leave that as an exercise, to keep focus on the programming, not the statistics. Creating these scatter plots is also very simple. Just send the <kbd class="calibre9">x</kbd> and <kbd class="calibre9">y</kbd> variables to the <kbd class="calibre9">plot()</kbd> function, and optionally specify labels for the axes.</p>
<pre class="mce-root">plot(x = data$NoQuals, y = data$AdultMeanAge, ylab = "AdultMeanAge", xlab = "NoQuals")
plot(x = data$L4Quals_plus, y = data$AdultMeanAge, ylab = "AdultMeanAge", xlab = "L4Quals_plus")</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using matrix scatter plots for a quick overview</h1>
                
            
            <article>
                
<p class="calibre2">What happens if we want to visualize a lot of scatter plots in a single graph to quickly get a sense for the data? In that case, we need <em class="calibre19">matrix scatter plots</em>. We have various package options to create such matrix scatter plots (such as the <kbd class="calibre9">car</kbd> package). However, to keep things simple, we will use a built-in function instead of an external package.</p>
<p class="calibre2">By looking at the graph shown below, we can get a big-picture view of the interactions among variables. The purpose of this type of visualization is not to provide details, but to provide a general overview. To read this plot we need to look at any interesting scatter plot in the matrix, and move both horizontally and vertically until we find the name associated with its axis.</p>
<p class="calibre2">For example, if you look at the plot immediately to the right of <kbd class="calibre9">NoQuals</kbd> and simultaneously immediately on top of <kbd class="calibre9">L4Quals_plus</kbd>, what you're looking at is at the relation between those two variables (<kbd class="calibre9">NoQuals</kbd> in the <em class="calibre19">y</em> axis, <kbd class="calibre9">L4Quals_plus</kbd> in the <em class="calibre19">x</em> axis), and we find that it's an inverse relation; the higher the percentage of people in a ward with high levels of education, the lower the percentage of people with low levels of education. Another obvious relation is that the higher the education level (<kbd class="calibre9">L4Quals_plus</kbd>), the higher the occupation (<kbd class="calibre9">HigherOccup</kbd>).</p>
<div class="cdpaligncenter"><img src="../images/00014.jpeg" class="calibre33"/></div>
<div class="mce-root2">Matrix scatter plot</div>
<p class="calibre2">Due to space restrictions, we were not able to show all variable relations, since the scatter plots would be too small to make sense of. However, we encourage the reader to add more variables to the matrix. There are some non-obvious relations. Finding them is left as an exercise for the reader:</p>
<pre class="mce-root">desired_variables &lt;- c(
    "AdultMeanAge",
    "White",
    "Owned",
    "NoQuals",
    "L4Quals_plus",
    "Unemp",
    "HigherOccup",
    "Deprived",
    "Proportion"
)
pairs(data[, desired_variables])</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Getting a better look with detailed scatter plots</h1>
                
            
            <article>
                
<p class="calibre2">Now that we know how to get a big-picture view of the scatter plots to get a general sense of the relations among variables, how can we get a more detailed look into each scatter plot? Well, I'm glad you asked! To achieve this, we'll do it in two steps. First, we are going to work on producing a single, detailed scatter plot that we're happy with. Second, we're going to develop a simple algorithm that will traverse all variable combinations and create the corresponding plot for each of them:</p>
<div class="cdpaligncenter"><img src="../images/00015.jpeg" class="calibre34"/></div>
<div class="mce-root2">Scatter plot for NoQuals vs AdultMeanAge vs Proportion with Regression Line</div>
<p class="calibre2">The graph shown above shows our prototype scatter plot. It has a combination of variables in the <kbd class="calibre9">x</kbd> and <kbd class="calibre9">y</kbd> axes, <kbd class="calibre9">NoQuals</kbd> and <kbd class="calibre9">AdultMeanAge</kbd> in our case, assigns a color according to the corresponding <kbd class="calibre9">Proportion</kbd>, and places a line corresponding to a linear regression on top to get a general sense of the relation among the variables in the axes. Compare this plot to the left scatter plot of previous pair of scatter plots. They are the same plot, but this one is more detailed and conveys more information. This plot seems good enough for now.</p>
<pre class="mce-root">plot &lt;- ggplot(data, aes(x = NoQuals, y = AdultMeanAge, color = Proportion))
plot &lt;- plot + stat_smooth(method = "lm", col = "darkgrey", se = FALSE)
plot &lt;- plot + scale_color_viridis()
plot &lt;- plot + geom_point()
print(plot)</pre>
<p class="calibre2">Now we need to develop the algorithm that will take all variable combinations and create the corresponding plots. We present the full algorithm and explain part by part. As you can see, we start defining the <kbd class="calibre9">create_graphs_iteratively</kbd> function, which receives two parameters: the <kbd class="calibre9">data</kbd> and the <kbd class="calibre9">plot_function</kbd>. The algorithm will get the variable names for the data and store them in the <kbd class="calibre9">vars</kbd> variables. It will then remove <kbd class="calibre9">Proportion</kbd> from such variables, because they will be used to create the combinations for the axis, and <kbd class="calibre9">Proportion</kbd> will never be used in the axis; it will be used exclusively for the colors.</p>
<p class="calibre2">Now, if we imagine all the variable combinations in a matrix like the one for the matrix scatter plot shown previously, then we need to traverse the upper triangle or the lower triangle to get all possible combinations (in fact, the upper and lower triangles from matrix of scatter plots are symmetrical because they convey the same information). To traverse these triangles, we can use a <em class="calibre19">known pattern,</em> which uses two for-loops, each for one axis, and where the inner loop need only start at the position of the outer loop (this is what forms a triangle). The <kbd class="calibre9">-1</kbd> and <kbd class="calibre9">+1</kbd> are there to make sure we start and finish in appropriate places in each loop without getting an error for array boundaries.</p>
<p class="calibre2">Inside the inner loop is where we will create the name for the plot as a combination of the variable names and concatenate them using the <kbd class="calibre9">paste()</kbd> function, as well as create the plot with the <kbd class="calibre9">plot_function</kbd> we will send as a parameter (more on this ahead). The <kbd class="calibre9">png()</kbd> and <kbd class="calibre9">dev.off()</kbd> functions are there to save the plots to the computer's hard drive. Think of the <kbd class="calibre9">png()</kbd> function as the place where R starts looking for a graph, and <kbd class="calibre9">dev.off()</kbd> as the place where it stops the saving process. Feel free to look into their documentation or read more about <em class="calibre19">devices</em> in R.</p>
<pre class="mce-root">create_plots_iteratively &lt;- function(data, plot_function) {
    vars &lt;- colnames(data)
    vars &lt;- vars(!which(vars == "Proportion"))
    for (i in 1:(length(vars) - 1)) {
        for (j in (i + 1):length(vars)) {
            save_to &lt;- paste(vars[i], "_", vars[j], ".png", sep = "")
            plot_function(data, vars[i], vars[j], save_to)
        }
    }
}</pre>
<p class="calibre2">We're almost done; we just need to wrap the code we used to turn our plot prototype into a function and we will be all set. As you can see, we extracted the <kbd class="calibre9">x</kbd>, <kbd class="calibre9">y</kbd>, and <kbd class="calibre9">color</kbd> parameters for the <kbd class="calibre9">aes()</kbd> function as variables that are sent as parameters to the function (this is called <strong class="calibre1">parametrizing arguments</strong>), and we switched the <kbd class="calibre9">aes()</kbd> function with the <kbd class="calibre9">aes_string()</kbd> function, which is able to receive variables with strings for the parameters. We also added the option to send the <kbd class="calibre9">var_color</kbd> as <kbd class="calibre9">FALSE</kbd> to avoid using a color-version of the plot. Everything else is kept the same:</p>
<pre class="mce-root">prototype_scatter_plot &lt;- function(data, var_x, var_y, var_color = "Proportion", save_to = "") {
    if (is.na(as.logical(var_color))) {
        plot &lt;- ggplot(data, aes_string(x = var_x, y = var_y, color = var_color))
    } else {
        plot &lt;- ggplot(data, aes_string(x = var_x, y = var_y))
    }
    plot &lt;- plot + stat_smooth(method = "lm", col = "darkgrey", se = FALSE)
    plot &lt;- plot + scale_color_viridis()
    plot &lt;- plot + geom_point()
    if (not_empty(save_to)) png(save_to)
    print(plot)
    if (not_empty(save_to)) dev.off()
}</pre>
<p class="calibre2">Since we will be checking in various places whether the <kbd class="calibre9">save_to</kbd> string is empty, we name the check and wrap it in the <kbd class="calibre9">not_empty()</kbd> function. Now it's a bit easier to read our code.</p>
<pre class="mce-root">not_empty &lt;- function(file) {<br class="title-page-name"/>    return(file != "")<br class="title-page-name"/>}</pre>
<p class="calibre2">With this <kbd class="calibre9">prototype_scatter_plot()</kbd> function, we can re-create the right scatter plots shown previously, as well as any other variable combination, quite easily. This seems pretty powerful, doesn't it?</p>
<div class="cdpaligncenter"><img src="../images/00016.jpeg" class="calibre35"/></div>
<div class="mce-root2">Scatter plot for L4Quals_plus vs AdultMeanAge vs Proportion with Regression Line</div>
<p class="calibre2">Let's have a look at the following code:</p>
<pre class="mce-root">prototype_scatter_plot(data, "L4Quals_plus", "AdultMeanAge")</pre>
<p class="calibre2">Now that we have done the hard work, we can create all possible combinations quite easily. We just need to call the <kbd class="calibre9">create_plots_iteratively()</kbd> function with our data and the <kbd class="calibre9">prototype_scatter_plot()</kbd> function. Using functions as parameters for other functions is known as the <strong class="calibre1">strategy pattern</strong>. The name comes from the fact that we can easily change our strategy for plotting for any other one we want that receives the same parameters (<kbd class="calibre9">data</kbd>, <kbd class="calibre9">var_x</kbd>, and <kbd class="calibre9">var_y</kbd>) to create plots, without having to change our algorithm to traverse the variable combinations. This kind of flexibility is very powerful:</p>
<pre class="mce-root">create_plots_iteratively(data, prototype_scatter_plot)</pre>
<p class="calibre2">This will create all the plots for us and save them to our hard drive. Pretty cool, huh? Now we can look at each of them independently and do whatever we need with them, as we already have them as PNG files.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Understanding interactions with correlations</h1>
                
            
            <article>
                
<p class="calibre2">The correlation is a measure of the linear relation among two variables. Its value ranges from <kbd class="calibre9">-1</kbd>, representing a perfect inverse relation, to <kbd class="calibre9">1</kbd>, representing a perfect direct relation. Just as we created a matrix of scatter plots, we will now create a matrix of correlations, and resulting graph is shown below. Large circles mean high absolute correlation. Blue circles mean positive correlation, while red circles mean negative correlation.</p>
<p class="calibre2">To create this plot we will use the <kbd class="calibre9">corrplot()</kbd> function from the <kbd class="calibre9">corrplot</kbd> package, and pass it the correlations data computed by the <kbd class="calibre9">cor()</kbd> function in R, and optionally some parameters for the text labels (<kbd class="calibre9">tl</kbd>), such as color (<kbd class="calibre9">color</kbd>) and size (<kbd class="calibre9">cex</kbd>).</p>
<div class="cdpaligncenter"><img src="../images/00017.jpeg" class="calibre36"/></div>
<div class="mce-root2">Variable Correlations</div>
<p class="calibre2">Now, let's look at the following code:</p>
<pre class="mce-root">library(corrplot)
corrplot(corr = cor(data_numerical), tl.col = "black", tl.cex = 0.6)</pre>
<p class="calibre2">If we look at the relation among the <kbd class="calibre9">Proportion</kbd> variable and the other variables, variables in large blue circles are positively correlated with it, meaning that the more that variable increases, the more likely it is for the <kbd class="calibre9">Proportion</kbd> variable to also increase. For examples of this type, look at the relations among <kbd class="calibre9">AdultMeanAge</kbd> and <kbd class="calibre9">NoQuals</kbd> with <kbd class="calibre9">Proportion</kbd>. If we find large red circles among <kbd class="calibre9">Proportion</kbd> and other variables, it means that the more that variable increases, the more <kbd class="calibre9">Proportion</kbd> is likely to decrease. For examples of this type, look at the relations among <kbd class="calibre9">Age_25to29</kbd>, <kbd class="calibre9">Age_30to44</kbd>, and <kbd class="calibre9">L4Quals_plus</kbd> with <kbd class="calibre9">Proportion</kbd>:</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating a new dataset with what we've learned</h1>
                
            
            <article>
                
<p class="calibre2">What we have learned so far in this chapter is that age, education, and ethnicity are important factors in understanding the way people voted in the Brexit Referendum. Younger people with higher education levels are related with votes in favor of remaining in the EU. Older white people are related with votes in favor of leaving the EU. We can now use this knowledge to make a more succinct data set that incorporates this knowledge. First we add relevant variables, and then we remove non-relevant variables.</p>
<p class="calibre2">Our new relevant variables are two groups of age (adults below and above 45), two groups of ethnicity (whites and non-whites), and two groups of education (high and low education levels):</p>
<pre class="mce-root">data$Age_18to44 &lt;- (
    data$Age_18to19 +
    data$Age_20to24 +
    data$Age_25to29 +
    data$Age_30to44
)
data$Age_45plus &lt;- (
    data$Age_45to59 +
    data$Age_60to64 +
    data$Age_65to74 +
    data$Age_75to84 +
    data$Age_85to89 +
    data$Age_90plus
)
data$NonWhite &lt;- (
    data$Black +
    data$Asian +
    data$Indian +
    data$Pakistani
)
data$HighEducationLevel &lt;- data$L4Quals_plus
data$LowEducationLevel  &lt;- data$NoQuals</pre>
<p class="calibre2">Now we remove the old variables that were used to create our newly added variables. To do so without having to manually specify a full list by leveraging the fact that all of them contain the word <kbd class="calibre9">"Age"</kbd>, we create the <kbd class="calibre9">age_variables</kbd> logical vector, which contains a <kbd class="calibre9">TRUE</kbd> value for those variables that contain the word <kbd class="calibre9">"Age"</kbd> inside (<kbd class="calibre9">FALSE</kbd> otherwise), and make sure we keep our newly created <kbd class="calibre9">Age_18to44</kbd> and <kbd class="calibre9">Age_45plus</kbd> variables. We remove the other ethnicity and education levels manually:</p>
<pre class="mce-root">column_names &lt;- colnames(data)
new_variables &lt;- !logical(length(column_names))
new_variables &lt;- setNames(new_variables, column_names)
age_variables &lt;- sapply(column_names, function(x) grepl("Age", x))
new_variables[age_variables]     &lt;- FALSE
new_variables[["AdultMeanAge"]]  &lt;- TRUE
new_variables[["Age_18to44"]]    &lt;- TRUE
new_variables[["Age_45plus"]]    &lt;- TRUE
new_variables[["Black"]]         &lt;- FALSE
new_variables[["Asian"]]         &lt;- FALSE
new_variables[["Indian"]]        &lt;- FALSE
new_variables[["Pakistani"]]     &lt;- FALSE
new_variables[["NoQuals"]]       &lt;- FALSE
new_variables[["L4Quals_plus"]]  &lt;- FALSE
new_variables[["OwnedOutright"]] &lt;- FALSE
new_variables[["MultiDeprived"]] &lt;- FALSE</pre>
<p class="calibre2">We save our created <kbd class="calibre9">data_adjusted</kbd> object by selecting the new columns, create our new numerical variables for the new data structure, and save it as a CSV file:</p>
<pre class="mce-root">data_adjusted &lt;- data[, new_variables]
numerical_variables_adjusted &lt;- sapply(data_adjusted, is.numeric)
write.csv(data_adjusted, file = "data_brexit_referendum_adjusted.csv")</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Building new variables with principal components</h1>
                
            
            <article>
                
<p class="calibre2"><strong class="calibre1">Principal Component Analysis</strong> (<strong class="calibre1">PCA</strong>) is a dimensionality reduction technique that is widely used in data analysis when there are many numerical variables, some of which may be correlated, and we would like to reduce the number of dimensions required to understand the data.</p>
<p class="calibre2">It can be useful to help us understand the data, since thinking in more than three dimensions can be problematic, and to accelerate algorithms that are computationally intensive, especially with large numbers of variables. With PCA, we can extract most of the information into only one or two variables constructed in a very specific way, such that they capture the most variance while having the added benefit of being uncorrelated among them by construction.</p>
<p class="calibre2">The first principal component is a linear combination of the original variables which captures the maximum variance (information) in the dataset. No other component can have higher variability than the first principal component. Then, second principal component is orthogonal to the first one and is computed in such a way that it captures the maximum variance left in the data. And so on. The fact that all variables are linear combinations that are orthogonal among themselves is the key for them being uncorrelated among each other. Enough statistics talk; let's get on with the programming!</p>
<p class="calibre2">When performing PCA in R, we have a variety of functions which can do the task. To mention some of them, we have <kbd class="calibre9">prcomp()</kbd> and <kbd class="calibre9">princomp()</kbd> from the <kbd class="calibre9">stats</kbd> package (built-in), <kbd class="calibre9">PCA()</kbd> from the <kbd class="calibre9">FactoMineR</kbd> package, <kbd class="calibre9">dudi.pca()</kbd> from the <kbd class="calibre9">ade4</kbd> package, and <kbd class="calibre9">acp()</kbd> from the <kbd class="calibre9">amap</kbd> package. In our case, we'll use the <kbd class="calibre9">prcomp()</kbd> function that is built into R.</p>
<p class="calibre2">To perform our PCA, we will use the adjusted data from the previous section. First, we remove numerical variables which are correlated with <kbd class="calibre9">Proportion</kbd>. Then we perform the PCA by sending the numerical data to the <kbd class="calibre9">prcomp()</kbd> function, as well as some normalization parameters. <kbd class="calibre9">center = TRUE</kbd> will subtract each variable's mean from itself, and <kbd class="calibre9">scale. = TRUE</kbd> will make each variable's variance unitary, effectively normalizing the data. Normalizing the data is very important when performing PCA, as it's a method sensitive to scales:</p>
<pre class="mce-root">numerical_variables_adjusted[["NVotes"]] &lt;- FALSE
numerical_variables_adjusted[["Leave"]]  &lt;- FALSE
data_numerical_adjusted &lt;- data_adjusted[, numerical_variables_adjusted]
pca &lt;- prcomp(data_numerical_adjusted, center = TRUE, scale. = TRUE)
pca<br class="title-page-name"/><strong class="calibre1">#&gt; Standard deviations (1, .., p=21):</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 2.93919 2.42551 1.25860 1.13300 1.00800 0.94112 0.71392 0.57613</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [9] 0.54047 0.44767 0.37701 0.30166 0.21211 0.17316 0.13759 0.11474</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [17] 0.10843 0.09797 0.08275 0.07258 0.02717</strong><br class="title-page-name"/><strong class="calibre1">#&gt;</strong><br class="title-page-name"/><strong class="calibre1">#&gt; Rotation (n x k) = (21 x 21):</strong><br class="title-page-name"/><strong class="calibre1">#&gt;                     PC1       PC2      PC3       PC4      PC5</strong><br class="title-page-name"/><strong class="calibre1">#&gt; ID             0.008492 -0.007276  0.14499  0.174484 -0.82840</strong><br class="title-page-name"/><strong class="calibre1">#&gt; Residents      0.205721  0.004321  0.54743  0.303663  0.06659</strong><br class="title-page-name"/><strong class="calibre1">#&gt; Households     0.181071  0.008752  0.49902  0.470793  0.13119</strong><br class="title-page-name"/><strong class="calibre1">#&gt; AdultMeanAge  -0.275210  0.192311  0.14601 -0.011834  0.12951</strong><br class="title-page-name"/><strong class="calibre1">#&gt; White         -0.239842  0.112711 -0.25766  0.471189 -0.02500</strong><br class="title-page-name"/><strong class="calibre1">#&gt; Owned         -0.289544  0.085502  0.26954 -0.179515 -0.11673</strong><br class="title-page-name"/><strong class="calibre1">(Truncated output)</strong></pre>
<p class="calibre2">When we print the <kbd class="calibre9">pca</kbd> object, we can see the standard deviations for each variable, but more importantly, we can see the weights used for each variable to create each principal component. As we can see, when we look at the full output in our computer, among the most important weights (the largest absolute values) we have the age and ethnicity variables, as well as others, such as home ownership.</p>
<p class="calibre2">If you want to get the axis value for each observation in the new coordinate system composed of the principal components, you simply need to multiply each observation in your data (each row) with the corresponding weights from the rotation matrix from the <kbd class="calibre9">pca</kbd> object (<kbd class="calibre9">pca$rotation</kbd>). For example, to know where the first observation in the data should be placed in regards to the second principal component, you can use the following:</p>
<pre class="mce-root">as.matrix(data_numerical_adjusted[1, ]) %*% pca$rotation[, 1]</pre>
<p class="calibre2">In general, you can apply matrix operations to get coordinates for all the observations in your data in regards to all the principal components in your <kbd class="calibre9">pca</kbd> object by using the following line, which will perform a matrix multiplication. Note that you don't need to do this yourself since R will do it automatically for you when analyzing the results.</p>
<pre class="mce-root">as.matrix(data_numerical_adjusted) %*% pca$rotation</pre>
<p class="calibre2">When we look at the summary of <kbd class="calibre9">pca</kbd>, we can see the standard deviations for each principal component, as well as its proportion of the variance captured and its accumulation. This information is useful when deciding how many principal components we should keep for the rest of the analysis. In our case, we find that with just the first two principal components, we have captured approximately 70 percent of the information in the data, which for our case may be good enough.</p>
<p class="calibre2">The 70% number can be arrived at by adding the <kbd class="calibre9">Proportion of variance</kbd> value for the principal components we want to consider (in order and starting at <kbd class="calibre9">PC1</kbd>). In this case, if we add the <kbd class="calibre9">Proportion of variance</kbd> for <kbd class="calibre9">PC1</kbd> and <kbd class="calibre9">PC2</kbd>, we get $0.411 + 0.280 = 0.691$, which is almost 70 percent. Note that you can simply look at the <kbd class="calibre9">Cumulative proportion</kbd> to find this number without having to perform the sum yourself, as it accumulates the <kbd class="calibre9">Proportion of variance</kbd> incrementally, starting at <kbd class="calibre9">PC1</kbd>.</p>
<div class="cdpaligncenter"><img src="../images/00018.jpeg" class="calibre37"/></div>
<div class="mce-root2">Principal Component's Variances</div>
<p class="calibre2">Take one moment to think about how powerful this technique is: with just two variables, we are able to capture 70 percent of the information contained in the original 40 variables:</p>
<pre class="mce-root">summary(pca)<br class="title-page-name"/><strong class="calibre1">#&gt; Importance of components:</strong><br class="title-page-name"/><strong class="calibre1">#&gt;                          PC1   PC2    PC3    PC4    PC5    PC6    PC7</strong><br class="title-page-name"/><strong class="calibre1">#&gt; Standard deviation     2.939 2.426 1.2586 1.1330 1.0080 0.9411 0.7139</strong><br class="title-page-name"/><strong class="calibre1">#&gt; Proportion of Variance 0.411 0.280 0.0754 0.0611 0.0484 0.0422 0.0243</strong><br class="title-page-name"/><strong class="calibre1">#&gt; Cumulative Proportion  0.411 0.692 0.7670 0.8281 0.8765 0.9186 0.9429</strong><br class="title-page-name"/><strong class="calibre1">#&gt;                           PC8    PC9    PC10    PC11    PC12    PC13</strong><br class="title-page-name"/><strong class="calibre1">#&gt; Standard deviation     0.5761 0.5405 0.44767 0.37701 0.30166 0.21211</strong><br class="title-page-name"/><strong class="calibre1">#&gt; Proportion of Variance 0.0158 0.0139 0.00954 0.00677 0.00433 0.00214</strong><br class="title-page-name"/><strong class="calibre1">#&gt; Cumulative Proportion  0.9587 0.9726 0.98217 0.98894 0.99327 0.99541</strong><br class="title-page-name"/><strong class="calibre1">#&gt;                           PC14   PC15    PC16    PC17    PC18    PC19</strong><br class="title-page-name"/><strong class="calibre1">#&gt; Standard deviation     0.17316 0.1376 0.11474 0.10843 0.09797 0.08275</strong><br class="title-page-name"/><strong class="calibre1">#&gt; Proportion of Variance 0.00143 0.0009 0.00063 0.00056 0.00046 0.00033</strong><br class="title-page-name"/><strong class="calibre1">#&gt; Cumulative Proportion  0.99684 0.9977 0.99837 0.99893 0.99939 0.99971</strong><br class="title-page-name"/><strong class="calibre1">(Truncated output)</strong></pre>
<p class="calibre2">In the graph shown above, we can see the variances (in the form of squared standard deviations) from the <kbd class="calibre9">summary(pca)</kbd> results. We can see how each subsequent principal component captures a lower amount of the total variance:</p>
<pre class="mce-root">plot(pca, type = "l", main = "Principal Components' Variances" )</pre>
<p class="calibre2">Finally, following graph shows a scatter plot of the ward observations (points) over a plane created by the two principal components from our analysis; it is called a <strong class="calibre1">biplot</strong>. Since these two principal components are formed as linear combinations of the original variables, we need some guidance when interpreting them. <span>To make it easy, the arrows point towards the direction of that variable's association to the principal component axis. The further the arrow is from the center, the stronger the effect on the principal components.</span></p>
<div class="cdpaligncenter"><img src="../images/00019.jpeg" class="calibre38"/></div>
<div class="mce-root2">PCA Biplot</div>
<p class="calibre2">With this biplot, we can see that <kbd class="calibre9">Proportion</kbd> is strongly related to the wards that voted to leave the EU, which is obvious since that's by construction. However, we can also see some other interesting relations. For example, other than the effects we have found so far (age, education, and ethnicity), people owning their own homes is also slightly associated with a higher tendency towards voting to leave the EU. On the other side, a previously unknown relation is the fact that the more dense a ward's population is (think about highly populated cities), the more likely it is that they will vote to remain in the EU:</p>
<pre class="mce-root">library(ggbiplot)
biplot &lt;- ggbiplot(pca, groups = data$Vote)
biplot &lt;- biplot + scale_color_discrete(name = "")
biplot &lt;- biplot + theme(legend.position = "top", legend.direction = "horizontal")
print(biplot)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Putting it all together into high-quality code</h1>
                
            
            <article>
                
<p class="calibre2">Now that we have the fundamentals about analyzing data with descriptive statistics, we're going to improve our code's structure and flexibility by breaking it up into functions. Even though this is common knowledge among efficient programmers, it's not a common practice among data analysts. Many data analysts would simply paste the code we have developed all together, as-is, into a single file, and run it every time they wanted to perform the analysis. We won't be adding new features to the analysis. All we'll do is reorder code into functions to encapsulate their inner-workings and communicate intention with function names (this substantially reduces the need for comments).</p>
<p class="calibre2">We'll focus on producing <em class="calibre19">high-quality</em> code that is easy to read, reuse, modify, and fix (in case of bugs). The way we actually do it is a matter of style, and different ways of arranging code are fit for different contexts. The method we'll work with here is one that has served me well for a variety of situations, but it may not be the best for yours. If it doesn't suit your needs, feel free to change it. Whichever style you prefer, making an investment in creating a habit of constantly producing high-quality code will make you a more efficient programmer in the long run, and a point will come where you will not want to program inefficiently any more.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Planning before programming</h1>
                
            
            <article>
                
<p class="calibre2">Often, people start programming before having a general idea of what they want to accomplish. If you're an experienced programmer, this may be a good way to get a feel for the problem, since you have already developed intuition, and you'll probably end up throwing away the first couple of attempts anyway. However, if you're a novice programmer, I recommend you make your objectives clear and explicit before writing any code (putting them into writing can help). It will help you make better decisions by asking yourself how a certain way of doing things will affect your objectives. So, before we set up anything, we need to understand and make our general objectives explicit:</p>
<ol class="calibre14">
<li value="1" class="calibre12">Understand the big picture of the analysis quickly.</li>
<li value="2" class="calibre12">Reproduce our analysis automatically by executing a single file.</li>
<li value="3" class="calibre12">Save all the resulting objects, text, and images for the analysis.</li>
<li value="4" class="calibre12">Measure the amount of time it takes to perform the full analysis.</li>
<li value="5" class="calibre12">When working on iterative processes, know the completed percentage.</li>
<li value="6" class="calibre12">Be able to find and change each part of the analysis easily.</li>
</ol>
<p class="calibre2">To fulfill these general objectives, we need to develop modular code with well-managed dependencies that are flexible (easy to change) and friendly to side-effects (saving objects, texts, and images). Even if your explicit objectives don't require it, you should make a habit of programming this way, even when just doing data analysis.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Understanding the fundamentals of high-quality code</h1>
                
            
            <article>
                
<p class="calibre2">Code that is modular, flexible, and whose dependencies are well-managed, is said to be <strong class="calibre1">highly-cohesive</strong> and <strong class="calibre1">loosely-coupled</strong>. These terms are mostly used in object-oriented environments (more about these in <a href="part0178.html#59O440-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 8</a>, <em class="calibre19">Object-Oriented System to Track Cryptocurrencies</em>), but apply generally to any system. <strong class="calibre1">Highly-cohesive</strong> means that things that are supposed to be together, are. <strong class="calibre1">Loosely-coupled</strong> means that things that are not supposed to be together, are not. The following image shows these characteristics, where each of the circles can be a function or an object in general. These are the basics of dependency management. Many books focused on these topics have been, and continue to be, published. For the interested reader, Steve McConnell's <em class="calibre19">Code Complete</em> (Microsoft Press, 2004) and Robert Martin's <em class="calibre19">Clean Code</em> (Prentice Hall, 2009) are excellent references. In this book, you'll see some of these techniques applied.</p>
<div class="cdpaligncenter"><img class="aligncenter" src="../images/00020.jpeg"/></div>
<div class="mce-root2">High cohesion and low coupling (left) vs Low cohesion and high coupling (right)</div>
<p class="calibre2">The most important principles for high-quality code are:</p>
<ol class="calibre14">
<li value="1" class="calibre12">Make things small and focused on a single responsibility.</li>
<li value="2" class="calibre12">Make the concrete depend on the abstract (not vice versa).</li>
<li value="3" class="calibre12">Make things that are highly-cohesive and loosely-coupled.</li>
</ol>
<div class="packt_infobox">By <em class="calibre27">things,</em> I mean functions, methods, classes, and objects in general. We'll touch more on what these are in <a href="part0178.html#59O440-f494c932c729429fb734ce52cafce730" class="calibre26">Chapter 8</a>, O<span class="calibre39"><em class="calibre27">bject-Oriented System to Track Cryptocurrencies</em></span>.</div>
<p class="calibre2">We start by creating two files: <kbd class="calibre9">functions.R</kbd> and <kbd class="calibre9">main.R</kbd>. The <kbd class="calibre9">functions.R</kbd> file contains high-level functions (mainly called from the <kbd class="calibre9">main.R</kbd> file) as well as low-level functions (used within other functions). By reading the <kbd class="calibre9">main.R</kbd> file, we should have a clear idea of what the analysis does (this is the purpose of the high-level functions), and executing it should re-create our analysis for any data that fits our base assumptions (for this example, these are mainly data structures).</p>
<p class="calibre2">We should always keep related code at the same level of abstraction. This means that we don't want to program things at the big-picture level and implement it with mixed details, and separating our code into the <kbd class="calibre9">main.R</kbd> and <kbd class="calibre9">functions.R</kbd> is a first step in this direction. Furthermore, none of the code in the <kbd class="calibre9">main.R</kbd> file should depend on details of the implementation. This makes it modular in the sense that if we want to change the way something is implemented, we can do so without having to change the high-level code. However, the way we implement things depends on what we want the analysis to ultimately do, which means that concrete implementations should depend on the abstract implementations that in turn depend on our analysis' purpose (stated as code in the <kbd class="calibre9">main.R</kbd> file).</p>
<p class="calibre2">When we bring knowledge from one set of code to another, we're generating a dependency, because the code that knows about other code depends on it to function properly. We want to avoid these dependencies as much as possible, and most importantly, we want to manage their direction. As stated before, the abstract should not depend on the concrete, or put another way, the concrete should depend on the abstract. Since the analysis (<kbd class="calibre9">main.R</kbd>) is on the abstract side, it should not depend on the implementation details of the concrete functions. But, how can our analysis be performed without knowledge of the functions that implement it? Well, it can't. That's why we need an intermediary, the abstract functions. These functions are there to provide stable knowledge to <kbd class="calibre9">main.R</kbd> and guarantee that the analysis its looking for will be performed, and they remove the dependency of <kbd class="calibre9">main.R</kbd> on the implementation details by managing that knowledge themselves. This may seem a convoluted way of working and a tricky concept to grasp, but when you do, you'll find out that it's very simple, and you'll be able to create code that is pluggable, which is a big efficiency boost. You may want to take a look at the books referenced previously to get a deeper sense of these concepts.</p>
<div class="cdpaligncenter"><img src="../images/00021.jpeg" class="calibre40"/></div>
<div class="mce-root2">General code structure</div>
<p class="calibre2">The previous graph shows that our analysis depends on the abstract functions (interfaces), as well as the concrete code that implements those interfaces. These abstract functions let us invert the dependency between the concrete functions and the analysis. We'll go deeper into these concepts in <a href="part0178.html#59O440-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 8</a>, <em class="calibre19">Object-Oriented System to Track Cryptocurrencies</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Programming by visualizing the big picture</h1>
                
            
            <article>
                
<p class="calibre2">Now, we will work with a top-down approach, meaning that we'll start with abstract code first and gradually move into the implementation details. Generally I find this approach to be more efficient when you have a clear idea of what you want to do. In our case, we'll start by working with the <kbd class="calibre9">main.R</kbd> file.</p>
<p class="calibre2">The first thing to note is that we will use the <kbd class="calibre9">proc.time()</kbd> function twice, once at the beginning and once at the end, and we will use the difference among these two values to measure how much time it took for the whole code to execute.<br class="title-page-name"/>
<br class="title-page-name"/>
The second thing to note is that the <kbd class="calibre9">empty_directories()</kbd> function makes sure each of the specified directories exist, and deletes any files contained in them. We use it to clean up our directories at the beginning of each execution, to make sure we have the latest files, and only the files created in the last run. The actual code is shown below, and it simply iterates through each of the directories passed, removes any files inside recursively with the <kbd class="calibre9">unlink()</kbd> function, and makes sure the directory exists with the <kbd class="calibre9">dir.create()</kbd> function. It avoids showing any warnings due to the directory already existing, which is not a problem in our case, by using the <kbd class="calibre9">showWarnings = FALSE</kbd> parameter.</p>
<pre class="mce-root">empty_directories &lt;- function(directories) {<br class="title-page-name"/>    for (directory in directories) {<br class="title-page-name"/>        unlink(directory, recursive = TRUE)<br class="title-page-name"/>        dir.create(directory, showWarnings = FALSE)<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">From <a href="part0022.html#KVCC0-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 1</a>, <em class="calibre19">Introduction to R</em>, we use of the <kbd class="calibre9">print_section()</kbd> and <kbd class="calibre9">empty_directories()</kbd> functions to print headers and delete directory contents (to re-create the results every time we run the function with empty directories), respectively, and we'll use the mechanism shown with <kbd class="calibre9">proc.time()</kbd> to measure execution time.</p>
<p class="calibre2">Now that the previous two points are out of the way, we proceed to show the full contents of the <kbd class="calibre9">main.R</kbd> file.</p>
<pre class="mce-root">start_time &lt;- proc.time()

source("./functions.R")

empty_directories(c(
    "./results/original/",
    "./results/adjusted/",
    "./results/original/scatter_plots/"
))

data &lt;- prepare_data("./data_brexit_referendum.csv", complete_cases = TRUE)

data_adjusted           &lt;- adjust_data(data)
numerical_variables     &lt;- get_numerical_variable_names(data)
numerical_variables_adj &lt;- get_numerical_variable_names(data_adjusted)

print("Working on summaries...")

full_summary(data, save_to = "./results/original/summary_text.txt")
numerical_summary(
    data,
    numerical_variables = numerical_variables,
    save_to = "./results/original/summary_numerical.csv"
)

print("Working on histograms...")

plot_percentage(
    data,
    variable = "RegionName",
    save_to = "./results/original/vote_percentage_by_region.png"
)

print("Working on matrix scatter plots...")

matrix_scatter_plots(
    data_adjusted,
    numerical_variables = numerical_variables_adj,
    save_to = "./results/adjusted/matrix_scatter_plots.png"
)

print("Working on scatter plots...")

plot_scatter_plot(
    data,
    var_x = "RegionName",
    var_y = "Proportion",
    var_color = "White",
    regression = TRUE,
    save_to = "./results/original/regionname_vs_proportion_vs_white.png"
)
all_scatter_plots(
    data,
    numerical_variables = numerical_variables,
    save_to = "./results/original/scatter_plots/"
)

print("Working on correlations...")

correlations_plot(
    data,
    numerical_variables = numerical_variables,
    save_to = "./results/original/correlations.png"
)

print("Working on principal components...")

principal_components(
    data_adjusted,
    numerical_variables = numerical_variables_adj,
    save_to = "./results/adjusted/principal_components"
)

end_time &lt;- proc.time()
time_taken &lt;- end_time - start_time
print(paste("Time taken:", taken[1]))

print("Done.")</pre>
<p class="calibre2">As you can see, with just this file, you get the big picture of the analysis, and are able to reproduce your analysis by running a single file, save the results to disk (note the <kbd class="calibre9">save_to</kbd> arguments), and measure the amount of time it takes to perform the full analysis. From our general objectives list, objectives one through four are fulfilled by this code. Fulfilling objectives five and six will be accomplished by working on the <kbd class="calibre9">functions.R</kbd> file, which contains lots of small functions. Having this <kbd class="calibre9">main.R</kbd> file gives us a map of what needs to be programmed, and even though right now it would not work because the functions it uses do not yet exist, by the time we finish programming them, this file will not require any changes and will produce the desired results.</p>
<p class="calibre2">Due to space restrictions, we won't look at the implementation of all the functions in the <kbd class="calibre9">main.R</kbd> file, just the representative ones: <kbd class="calibre9">prepare_data()</kbd>, <kbd class="calibre9">plot_scatter_plot()</kbd>, and <kbd class="calibre9">all_scatter_plots()</kbd>. The other functions use similar techniques to encapsulate the corresponding code. You can always go to this book's code repository (<a href="https://github.com/PacktPublishing/R-Programming-By-Example" class="calibre4">https://github.com/PacktPublishing/R-Programming-By-Example</a>) to see the rest of the implementation details. After reading this book, you should be able to figure out exactly what's going on in every file in that repository.</p>
<p class="calibre2">We start with <kbd class="calibre9">prepare_data()</kbd>. This function is abstract and uses four different concrete functions to do its job, <kbd class="calibre9">read.csv()</kbd>, <kbd class="calibre9">clean_data()</kbd>, <kbd class="calibre9">transform_data()</kbd>, and, if required, <kbd class="calibre9">complete.cases()</kbd>. The first function, namely <kbd class="calibre9">read.csv()</kbd>, receives the path to a CSV file to read data from and loads into a data frame object named <kbd class="calibre9">data</kbd> in this case. The fourth function you have seen before in <a href="part0022.html#KVCC0-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 1</a>, <em class="calibre19">Introduction to R</em>, so we won't explain it here. Functions two and three are created by us, and we'll explain them. Note that <kbd class="calibre9">main.R</kbd> doesn't know about how data is prepared, it only asks for data to be prepared, and delegates the job to the abstract function <kbd class="calibre9">prepare_data()</kbd>.</p>
<pre class="mce-root">prepare_data &lt;- function(path, complete_cases = TRUE) {
    data &lt;- read.csv(path)
    data &lt;- clean_data(data)
    data &lt;- transform_data(data)
    if (complete_cases) {
        data &lt;- data[complete.cases(data), ]
    }
    return(data)
}</pre>
<p class="calibre2">The <kbd class="calibre9">clean_data()</kbd> function simply encapsulates the re-coding of -1 for <kbd class="calibre9">NA</kbd> for now. If our cleaning procedure suddenly got more complex (for example, new data sources requiring more cleaning or realizing we missed something and we need to add it to the cleaning procedure), we would add those changes to this function and we would not have to modify anything else in the rest of our code. These are some of the advantages of encapsulating code into functions that communicate intention and isolate what needs to be done into small steps:</p>
<pre class="mce-root">clean_data &lt;- function(data) {
    data[data$Leave == -1, "Leave"] &lt;- NA
    return(data)
}</pre>
<p class="calibre2">To transform our data by adding the extra <kbd class="calibre9">Proportion</kbd> and <kbd class="calibre9">Vote</kbd> variables, and re-label the region names, we use the following function:</p>
<pre class="mce-root">transform_data &lt;- function(data) {
    data$Proportion &lt;- data$Leave / data$NVotes
    data$Vote &lt;- ifelse(data$Proportion &gt; 0.5, "Leave", "Remain")
    data$RegionName &lt;- as.character(data$RegionName)
    data[data$RegionName == "London", "RegionName"]                   &lt;- "L"
    data[data$RegionName == "North West", "RegionName"]               &lt;- "NW"
    data[data$RegionName == "North East", "RegionName"]               &lt;- "NE"
    data[data$RegionName == "South West", "RegionName"]               &lt;- "SW"
    data[data$RegionName == "South East", "RegionName"]               &lt;- "SE"
    data[data$RegionName == "East Midlands", "RegionName"]            &lt;- "EM"
    data[data$RegionName == "West Midlands", "RegionName"]            &lt;- "WM"
    data[data$RegionName == "East of England", "RegionName"]          &lt;- "EE"
    data[data$RegionName == "Yorkshire and The Humber", "RegionName"] &lt;- "Y"
    return(data)
}</pre>
<p class="calibre2">All of these lines of code you have seen before. All we are doing is encapsulating them into functions that communicate intention and allow us to find where certain procedures are taking place so that we can find them and change them easily if we need to do so later on.</p>
<p class="calibre2">Now we look into <kbd class="calibre9">plot_scatter_plot()</kbd>. This function is between being an abstract and a concrete function. We will use it directly in our <kbd class="calibre9">main.R</kbd> file, but we will also use it within other functions in the <kbd class="calibre9">functions.R</kbd> file. We know that most of the time we'll use <kbd class="calibre9">Proportion</kbd> as the color variable, so we add that as a default value, but we allow for the user to remove the color completely by checking if the argument was sent as <kbd class="calibre9">FALSE</kbd>, and since we will use this same function to create graphs that resemble all the scatter plots we have created up to this point, we will make the regression line optional.</p>
<p class="calibre2">Note that in the case of the former graphs, the <em class="calibre19">x</em> axis is a continuous variable, but in the case of the latter graph, it's a categorical (<em class="calibre19">factor</em>) variable. This kind of flexibility is very powerful and is available to us due to <kbd class="calibre9">ggplot2</kbd>'s capability to adapt to these changes. Formally, this is called <strong class="calibre1">polymorphism</strong>, and it's something we'll explain in <a href="part0178.html#59O440-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 8</a>, <em class="calibre19">Object-Oriented System to Track Cryptocurrencies</em>.</p>
<p class="calibre2">Finally, instead of assuming the user will always want to save the resulting graph to disk, we make the <kbd class="calibre9">save_to</kbd> argument optional by providing an empty string for it. When appropriate, we check to see if this string is empty with <kbd class="calibre9">not_empty()</kbd>, and if it's not empty, we set up the PNG saving mechanism.</p>
<pre class="mce-root">plot_scatter_plot &lt;- function(data,
                             var_x,
                             var_y,
                             var_color = "Proportion",
                             regression = FALSE,
                             save_to = "") {
    if (var_color) {
        plot &lt;- ggplot(data, aes_string(x = var_x, y = var_y, color = var_color))
    } else {
        plot &lt;- ggplot(data, aes_string(x = var_x, y = var_y))
    }
    plot &lt;- plot + scale_color_viridis()
    plot &lt;- plot + geom_point()
    if (regression) {
        plot &lt;- plot + stat_smooth(method = "lm", col = "grey", se = FALSE)
    }
    if (not_empty(save_to)) png(save_to)
    print(plot)
    if (not_empty(save_to)) dev.off()
}</pre>
<p class="calibre2">Now we look into <kbd class="calibre9">all_scatter_plots()</kbd>. This function is an abstract function that hides from the user's knowledge the name of the function that will create graphs iteratively, conveniently named <kbd class="calibre9">create_graphs_iteratively()</kbd>, and the graphing function, the <kbd class="calibre9">plot_scatter_plot()</kbd> function we saw before. In case we want to improve the iterative mechanism or the graphing function, we can do so without requiring changes from people that use our code, because that knowledge is encapsulated here.</p>
<div class="packt_tip">Encapsulate what changes frequently or is expected to change.</div>
<p class="calibre2">The <kbd class="calibre9">create_graphs_iteratively()</kbd> function is the same we have seen before, except for the progress bar code. The <kbd class="calibre9">progress</kbd> package provides the <kbd class="calibre9">progress_bar$new()</kbd> function that creates a progress bar in the terminal while an iterative process is being executed so that we see what percentage of the process has been completed and know how much time is remaining (see <a href="part0296.html#8Q96G0-f494c932c729429fb734ce52cafce730" class="calibre4">Appendix</a>, <em class="calibre19">Required Packages</em> for more information).</p>
<p class="calibre2">Note the change in the <kbd class="calibre9">save_to</kbd> argument from the functions <kbd class="calibre9">plot_scatter_plot()</kbd> and <kbd class="calibre9">all_scatter_plots()</kbd>. In the former, it's a filename; in the latter, a directory name. The difference is small, but important. The incautious reader might not notice it and it may be a cause for confusion. The <kbd class="calibre9">plot_scatter_plot()</kbd> function produces a single plot, and thus receives a file name. However, the <kbd class="calibre9">all_scatter_plots()</kbd> will produce, by making use of <kbd class="calibre9">plot_scatter_plot()</kbd>, a lot of graphs, so it must know where all of them need to be saved, create the final image names dynamically, and send them one-by-one to <kbd class="calibre9">plot_scatter_plot()</kbd>. Finally, since we want the regression to be included in these graphs, we just send the <kbd class="calibre9">regression = TRUE</kbd> parameter:</p>
<pre class="mce-root">all_scatter_plots &lt;- function(data, numerical_variables, save_to = "") {
    create_graphs_iteratively(data, numerical_variables, plot_scatter_plot, save_to)
}

create_graphs_iteratively &lt;- function(data,
                                      numerical_variables,
                                      plot_function,
                                      save_to = "") {
<br class="title-page-name"/>    numerical_variables[["Proportion"]] &lt;- FALSE
    variables &lt;- names(numerical_variables[numerical_variables == TRUE])

    n_variables &lt;- (length(variables) - 1)
    progress_bar &lt;- progress_bar$new(
        format = "Progress [:bar] :percent ETA: :eta",
        total = n_variables
    )
    for (i in 1:n_variables) {
        progress_bar$tick()
        for (j in (i + 1):length(variables)) {
            image_name &lt;- paste(
                save_to,
                variables[i], "_",
                variables[j], ".png",
                sep = ""
            )
            plot_function(
                data,
                var_x = variables[i],
                var_y = variables[j],
                save_to = image_name,
                regression = TRUE
            )
        }
    }
}</pre>
<p class="calibre2">The other functions that we have not looked at in detail follow similar techniques as the ones we showed, and the full implementation is available at this book's code repository (<a href="https://github.com/PacktPublishing/R-Programming-By-Example" class="calibre4">https://github.com/PacktPublishing/R-Programming-By-Example</a>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">This chapter showed how to perform a qualitative analysis that is useful as a first step when doing data analysis. We showed some descriptive statistics techniques and how to implement them programmatically. With these skills, we are able to perform simple yet powerful analyses and save the results for later use. Specifically, we showed how to do basic data cleaning, how to create graphs programmatically, how to create matrix scatter plots and matrix correlations, how to perform Principal Component Analysis, and how to combine these tools to understand the data at hand. Finally, we touched on the basics of high-quality code and showed how to transform your initial data analysis code into programs that are modular, flexible, and easy to work with.</p>
<p class="calibre2">In <a href="part0076.html#28FAO0-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 3</a>, <em class="calibre19">Predicting Votes with Linear Models,</em> we'll show how to extend the current analysis with qualitative tools. Specifically, we'll show how to use linear models to understand the quantitative effects of variables on the proportion of votes in favor of the UK leaving and remaining in the EU, how to make predictions for wards whose vote data we don't have, and how to measure the accuracy of those predictions with the data we do have. These are essential skills for any data analyst and, just as we did in this chapter, we'll see how to implement them programmatically.</p>


            </article>

            
        </section>
    </body></html>