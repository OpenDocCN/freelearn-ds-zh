<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;Object-Oriented Programming"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Object-Oriented Programming</h1></div></div></div><p>In the previous chapter, you learned how functional programming and metaprogramming make it possible to customize the behavior of functions. We can create a function within a certain context, which is called a closure. We can also use higher order functions by passing functions around just like other objects.</p><p>In this chapter, you will learn how to customize the behavior of objects by walking into the world of object-oriented programming. R provides several different object-oriented systems to work with. At first glance, they look quite different from the object-oriented systems in other programming languages. However, the idea is mostly the same. I will briefly explain the concept of class and method of objects, and show you how they can be useful in unifying the way we work with data and models.</p><p>We will cover the following topics at the beginner level in the subsequent sections:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The idea of object-oriented programming</li><li class="listitem" style="list-style-type: disc">S3 system</li><li class="listitem" style="list-style-type: disc">S4 system</li><li class="listitem" style="list-style-type: disc">Reference class</li><li class="listitem" style="list-style-type: disc">R6 package</li></ul></div><p>Finally, we will compare these systems in several aspects.</p><div class="section" title="Introducing object-oriented programming"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec52"/>Introducing object-oriented programming</h1></div></div></div><p>If you are a developer from programming languages such as Java, Python, C++, C#, you should feel familiar with the object-oriented style of coding. However, if you are not familiar with any other object-oriented programming languages, you will probably be puzzled by this term, as it sounds a bit abstract. However, don't worry; this is much easier to understand than it looks if we think about the core of programming.</p><p>When we talk about programming, we are actually talking about using programming tools to solve problems. Before solving the problem, we need to model the problem first. Traditionally, we usually figured out an algorithm that takes several steps to solve a numeric computing problem. Then, we wrote some procedural code to implement the algorithm. For example, most statistical algorithms are implemented in a procedural style, that is, by transforming the input into the output according to the theory, step by step.</p><p>However, many problems are so closely bounded to the real world that it can be very intuitive to model the problem by defining some classes of objects as well as the interaction between them. In other words, by programming in an object-oriented style, we simply try to mimic the important features of the objects in concern at an appropriate level of abstraction.</p><p>There are many concepts involved in object-oriented programming. Here, we will only focus on the most important ones.</p><div class="section" title="Understanding classes and methods"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec120"/>Understanding classes and methods</h2></div></div></div><p>The most important concepts in this chapter are classes and methods. A class describes what the object is, and a method defines what it can do. There are countless real-world examples for these concepts. For example, <code class="literal">animal</code> can be a class. In this class, we can define methods such as make sound and move. The <code class="literal">vehicle</code> can be a class, too. In this class, we can define methods such as start, move, and stop. The <code class="literal">person</code> can be a class that has methods such as wake up, talk to another person, and go somewhere.</p><p>For a particular problem, we can define classes according to our need to model the objects we are dealing with and define methods for them to model the interaction between the objects. The objects need not be physical or tangible. One practical example is a bank account. It only exists in the data storage of banks, but it can be useful to model bank accounts with some data fields such as balance and owner, and some methods such as deposit, withdraw, and transfer between two accounts.</p></div><div class="section" title="Understanding inheritance"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec121"/>Understanding inheritance</h2></div></div></div><p>Another important concept of object-oriented programming is inheritance, that is, we can define a class that inherits the behavior of a base (or super) class and has some new behavior. Usually, the base class is more abstract and general in concept, and the inheriting class is more concrete and specific. This is simply true for the concepts in our everyday life.</p><p>For example, <code class="literal">dog</code> and <code class="literal">cat</code> are two classes that inherit from the <code class="literal">animal</code> class. The <code class="literal">animal</code> class defines methods such as make sound and move. The <code class="literal">dog</code> and <code class="literal">cat</code> classes inherit these methods but implement them in different ways so that they make different sounds and move in different manners.</p><p>Also, <code class="literal">car</code>, <code class="literal">bus</code>, and <code class="literal">airplane</code> are classes that inherit from the <code class="literal">vehicle</code> class. The <code class="literal">vehicle</code> class defines methods such as <code class="literal">start</code>, <code class="literal">move</code>, and <code class="literal">stop</code>. The <code class="literal">car</code>, <code class="literal">bus</code>, and <code class="literal">airplane</code> classes inherit these functionalities but work in different ways. The <code class="literal">car</code> and <code class="literal">bus</code> can move in two dimensions on the surface, while airplane can move in three dimensions in the air.</p><p>There are some other concepts in the system of object-oriented programming, but we are not going to focus on them in this chapter. Let's keep in mind the concepts we mentioned and see how these concepts work in R programming.</p></div></div></div>
<div class="section" title="Working with the S3 object system"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec53"/>Working with the S3 object system</h1></div></div></div><p>The S3 object system in R is a simple, loose, object-oriented system. Every basic object type has an S3 class name. For example, <code class="literal">integer</code>, <code class="literal">numeric</code>, <code class="literal">character</code>, <code class="literal">logical</code>, <code class="literal">list</code>,
 <code class="literal">data.frame</code>, and so on are all S3 classes.</p><p>For example, the type of <code class="literal">vec1</code> class is <code class="literal">double</code>, which means the internal type or storage mode of <code class="literal">vec1</code> is double floating numbers. However, its S3 class is <code class="literal">numeric</code>:</p><pre class="programlisting">vec1 &lt;- c(1, 2, 3) &#13;
typeof(vec1) &#13;
## [1] "double" &#13;
class(vec1) &#13;
## [1] "numeric" &#13;
</pre><p>The type of <code class="literal">data1</code> class is <code class="literal">list</code>, which means the internal type or storage mode of <code class="literal">data1</code> is a list, but its S3 class is <code class="literal">data.frame</code>:</p><pre class="programlisting">data1 &lt;- data.frame(x = 1:3, y = rnorm(3)) &#13;
typeof(data1) &#13;
## [1] "list" &#13;
class(data1) &#13;
## [1] "data.frame" &#13;
</pre><p>In the following sections, we'll explain the difference between the internal type of an object and its S3 class.</p><div class="section" title="Understanding generic functions and method dispatch"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec122"/>Understanding generic functions and method dispatch</h2></div></div></div><p>As we mentioned earlier in this chapter, a class can possess a number of methods that define its behavior, mostly with other objects. In the S3 system, we can create generic functions and implement them for different classes as methods. This is how the S3 method dispatch works to make the class of an object important.</p><p>There are many simple examples of the S3 generic function in R. Each of them is defined for a general purpose and allows different classes of objects to have their own implementation for that purpose. Let's first take a look at the <code class="literal">head()</code> and <code class="literal">tail()</code> functions. Their functionality is simple: <code class="literal">head()</code> gets the first <code class="literal">n</code> records of a data object, while <code class="literal">tail()</code> gets the last <code class="literal">n</code> records of a data object. It is different from<code class="literal">x[1:n]</code> because it has different definitions of record for different classes of objects. For an atomic vector (numeric, character, and so on), the first <code class="literal">n</code> records just means the first <code class="literal">n</code> elements. However, for a data frame, the first <code class="literal">n</code> record means the first <code class="literal">n</code> rows rather than columns. Since a data frame is essentially a list, directly taking out the first <code class="literal">n</code> elements from a data frame is actually taking out the first <code class="literal">n</code> columns, which is not what <code class="literal">head()</code> is intended for.</p><p>First, let's type <code class="literal">head</code> and see what's inside the function:</p><pre class="programlisting">head &#13;
## function (x, ...)  &#13;
## UseMethod("head") &#13;
## &lt;bytecode: 0x000000000f052e10&gt; &#13;
## &lt;environment: namespace:utils&gt; &#13;
</pre><p>We find that there are no actual implementation details in this function. Instead, it calls <code class="literal">UseMethod("head")</code> to make <code class="literal">head</code> a so-called <span class="strong"><strong>generic function</strong></span> to perform method dispatch, that is, it may behave in different ways for different classes.</p><p>Now, let's create two data objects of <code class="literal">numeric</code> class and <code class="literal">data.frame</code> class, respectively, and see how method dispatch works when we pass each object to the generic function <code class="literal">head</code>:</p><pre class="programlisting">num_vec &lt;- c(1, 2, 3, 4, 5) &#13;
data_frame &lt;- data.frame(x = 1:5, y = rnorm(5)) &#13;
</pre><p>For a numeric vector, <code class="literal">head</code> simply takes its first several elements.</p><pre class="programlisting">head(num_vec, 3) &#13;
## [1] 1 2 3 &#13;
</pre><p>However, for a data frame, <code class="literal">head</code> takes its first several rows rather than columns:</p><pre class="programlisting">head(data_frame, 3) &#13;
##   x         y &#13;
## 1 1 0.8867848 &#13;
## 2 2 0.1169713 &#13;
## 3 3 0.3186301 &#13;
</pre><p>Here, we can use a function to mimic the behavior of <code class="literal">head</code>. The following code is a simple implementation that takes the first <code class="literal">n</code> elements of any given object <code class="literal">x</code>:</p><pre class="programlisting">simple_head &lt;- function(x, n) { &#13;
  x[1:n] &#13;
} &#13;
</pre><p>For a numeric vector, it works in exactly the same way as <code class="literal">head</code>:</p><pre class="programlisting">simple_head(num_vec, 3) &#13;
## [1] 1 2 3 &#13;
</pre><p>However, for a data frame, it actually tries to take out the first <code class="literal">n</code> columns. Recall that the data frame is a list, and each column of the data frame is an element of the list. It may cause an error if <code class="literal">n</code> exceeds the number of columns of the data frame or, equivalently, the number of elements of the list:</p><pre class="programlisting">simple_head(data_frame, 3) &#13;
## Error in `[.data.frame`(x, 1:n): undefined columns selected &#13;
</pre><p>To improve the implementation, we can check whether the input object <code class="literal">x</code> is a data frame before taking any measures:</p><pre class="programlisting">simple_head2 &lt;- function(x, n) { &#13;
  if (is.data.frame(x)) { &#13;
    x[1:n,] &#13;
  } else { &#13;
    x[1:n] &#13;
  } &#13;
} &#13;
</pre><p>Now, the behavior of <code class="literal">simple_head2</code> is almost the same with <code class="literal">head</code> for atomic vectors and data frames:</p><pre class="programlisting">simple_head2(num_vec, 3) &#13;
## [1] 1 2 3 &#13;
simple_head2(data_frame, 3) &#13;
##   x         y &#13;
## 1 1 0.8867848 &#13;
## 2 2 0.1169713 &#13;
## 3 3 0.3186301 &#13;
</pre><p>However, <code class="literal">head</code> offers more than this. To see the methods implemented for <code class="literal">head</code>, we can call <code class="literal">methods()</code>, which returns a character vector:</p><pre class="programlisting">methods("head") &#13;
## [1] head.data.frame* head.default*    head.ftable*     &#13;
## [4] head.function*   head.matrix      head.table*      &#13;
## see '?methods' for accessing help and source code &#13;
</pre><p>It shows that there is already a bunch of built-in methods of <code class="literal">head</code> for a number of classes other than vectors and data frames. Note that the methods are all in the form of <code class="literal">method.class</code>. If we input a <code class="literal">data.frame</code> object, <code class="literal">head</code> will call <code class="literal">head.data.frame</code> internally. Similarly, if we input a <code class="literal">table</code> object, it will call <code class="literal">head.table</code> internally. What if we input a numeric vector? When no method is found that matches the class of the input object, it will turn to <code class="literal">method.default</code>, if defined. In this case, all atomic vectors are matched by <code class="literal">head.default</code>. The process through which a generic function finds the appropriate method for a certain input object is called <span class="strong"><strong>method dispatch</strong></span>.</p><p>It looks like we can always check the class of the input object in a function to achieve the goal of method dispatch. However, it is easier to implement a method for another class to extend the functionality of a generic function because you don't have to modify the original generic function by adding specific class-checking conditions each time. We'll cover this later in this section.</p></div><div class="section" title="Working with built-in classes and methods"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec123"/>Working with built-in classes and methods</h2></div></div></div><p>S3 generic functions and methods are most useful in unifying the way we work with all kinds of models. For example, we can create a linear model and use generic functions to view the model from different perspectives:</p><pre class="programlisting">lm1 &lt;- lm(mpg ~ cyl + vs, data = mtcars) &#13;
</pre><p>In previous chapters, we mentioned that a linear model is essentially a list of data fields resulted from model fitting. That's why the type of <code class="literal">lm1</code> is <code class="literal">list</code>, but its class is <code class="literal">lm</code> so that generic functions will choose methods for <code class="literal">lm</code>:</p><pre class="programlisting">typeof(lm1) &#13;
## [1] "list" &#13;
class(lm1) &#13;
## [1] "lm" &#13;
</pre><p>The S3 method dispatch even happens without explicit calling of S3 generic functions. If we type <code class="literal">lm1</code> and see what it is, the model object is printed:</p><pre class="programlisting">lm1 &#13;
##  &#13;
## Call: &#13;
## lm(formula = mpg ~ cyl + vs, data = mtcars) &#13;
##  &#13;
## Coefficients: &#13;
## (Intercept)          cyl           vs   &#13;
##     39.6250      -3.0907      -0.9391 &#13;
</pre><p>In fact, <code class="literal">print</code> is implicitly called:</p><pre class="programlisting">print(lm1) &#13;
##  &#13;
## Call: &#13;
## lm(formula = mpg ~ cyl + vs, data = mtcars) &#13;
##  &#13;
## Coefficients: &#13;
## (Intercept)          cyl           vs   &#13;
##     39.6250      -3.0907      -0.9391 &#13;
</pre><p>We know that <code class="literal">lm1</code> is essentially a list. Why does it not look like a list when it is printed? This is because <code class="literal">print</code> is a generic function, and it has a method for <code class="literal">lm</code> that prints the most important information of the linear model. We can get the actual method we call by <code class="literal">getS3method("print", "lm")</code>. In fact, <code class="literal">print(lm1)</code> goes to <code class="literal">stats:::print.lm</code>, which can be verified by checking whether they are identical:</p><pre class="programlisting">identical(getS3method("print", "lm"), stats:::print.lm) &#13;
## [1] TRUE &#13;
</pre><p>Note that <code class="literal">print.lm</code> is defined in the <code class="literal">stats</code> package, but is not exported for public use, so we have to use <code class="literal">:::</code> to access it. Generally, it is a bad idea to access internal objects in a package, because they may change in different releases and have no changes visible to the user. In most cases, we simply don't need to because generic functions such as <code class="literal">print</code> automatically choose the right method to call.</p><p>In R, <code class="literal">print</code> has methods implemented for many classes. The following code shows how many methods are implemented for different classes:</p><pre class="programlisting">length(methods("print")) &#13;
## [1] 198 &#13;
</pre><p>You can call <code class="literal">methods("print")</code> to view the whole list. In fact, if more packages are loaded, there will be more methods defined for classes in these packages.</p><p>While <code class="literal">print</code> shows a brief version of the model, <code class="literal">summary</code> shows detailed information. This function is also a generic function that has many methods for all kinds of model classes:</p><pre class="programlisting">summary(lm1) &#13;
##  &#13;
## Call: &#13;
## lm(formula = mpg ~ cyl + vs, data = mtcars) &#13;
##  &#13;
## Residuals: &#13;
##    Min     1Q Median     3Q    Max  &#13;
## -4.923 -1.953 -0.081  1.319  7.577  &#13;
##  &#13;
## Coefficients: &#13;
##             Estimate Std. Error t value Pr(&gt;|t|)     &#13;
## (Intercept)  39.6250     4.2246   9.380 2.77e-10 *** &#13;
## cyl          -3.0907     0.5581  -5.538 5.70e-06 *** &#13;
## vs           -0.9391     1.9775  -0.475    0.638     &#13;
## --- &#13;
## Signif. codes:   &#13;
## 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 &#13;
##  &#13;
## Residual standard error: 3.248 on 29 degrees of freedom &#13;
## Multiple R-squared:  0.7283, Adjusted R-squared:  0.7096  &#13;
## F-statistic: 38.87 on 2 and 29 DF,  p-value: 6.23e-09 &#13;
</pre><p>The summary of a linear model provides not only what <code class="literal">print</code> shows but also some important statistics for the coefficients and the overall model. In fact, the output of <code class="literal">summary</code> is another object that can be accessed for the data it contains. In this case, it is a list of the <code class="literal">summary.lm</code> class, and it has its own method of <code class="literal">print</code>:</p><pre class="programlisting">lm1summary &lt;- summary(lm1) &#13;
typeof(lm1summary) &#13;
## [1] "list" &#13;
class(lm1summary) &#13;
## [1] "summary.lm" &#13;
</pre><p>To list what elements <code class="literal">lm1summary</code> contains, we can view the names on the list:</p><pre class="programlisting">names(lm1summary) &#13;
## [1] "call"          "terms"         "residuals"     &#13;
## [4] "coefficients"  "aliased"       "sigma"         &#13;
## [7] "df"            "r.squared"     "adj.r.squared" &#13;
##[10] "fstatistic"    "cov.unscaled" &#13;
</pre><p>We can access each element in exactly the same way as we extract an element from a typical list. For example, to access the estimated coefficients of the linear model, we can use <code class="literal">lm1$coefficients</code>. Alternatively, we will use the following code to access the estimated coefficients:</p><pre class="programlisting">coef(lm1) &#13;
## (Intercept)         cyl          vs  &#13;
##  39.6250234  -3.0906748  -0.9390815 &#13;
</pre><p>Here, <code class="literal">coef</code> is also a generic function that extracts the vector of coefficients from a model object. To access the detailed coefficient table in the model summary, we can use <code class="literal">lm1summary$coefficients</code> or, again, <code class="literal">coef</code>:</p><pre class="programlisting">coef(lm1summary) &#13;
##               Estimate Std. Error    t value     Pr(&gt;|t|) &#13;
## (Intercept) 39.6250234  4.2246061  9.3795782 2.765008e-10 &#13;
## cyl         -3.0906748  0.5580883 -5.5379676 5.695238e-06 &#13;
## vs          -0.9390815  1.9775199 -0.4748784 6.384306e-01 &#13;
</pre><p>There are other useful model-related generic functions such as <code class="literal">plot</code>, <code class="literal">predict</code>, and so on. All these generic functions we mentioned are standard ways in R for users to interact with an estimated model. Different built-in models and those provided by third-party packages all try to implement these generic functions so that we don't need to remember different sets of functions to work with each model.</p><p>For example, we can use the <code class="literal">plot</code> function to the linear model with 2-by-2 partitions:</p><pre class="programlisting">oldpar &lt;- par(mfrow = c(2, 2)) &#13;
plot(lm1) &#13;
par(oldpar) &#13;
</pre><p>This produces the following image with four parts:</p><div class="mediaobject"><img src="graphics/image_10_001.jpg" alt="Working with built-in classes and methods"/></div><p>We can see that we used <code class="literal">plot</code> function to a linear model, which will result in four diagnostic plots that show the features of the residuals, which can be helpful in getting an impression on whether the model fit is good or bad. Note that if we directly call the <code class="literal">plot</code> function to a <code class="literal">lm</code> in a console, the four plots are interactively done in turn. To avoid this, we call <code class="literal">par()</code> to divide the plot area into 2-by-2 subareas.</p><p>Most statistical models are useful because they can be used to predict with new data. To do this, we use <code class="literal">predict</code>. In this case, we can supply the linear model and the new data to <code class="literal">predict</code>, and it will find the right method to make predictions with new data:</p><pre class="programlisting">predict(lm1, data.frame(cyl = c(6, 8), vs = c(1, 1))) &#13;
##        1        2  &#13;
## 20.14189 13.96054 &#13;
</pre><p>This function can be used both in sample and out of sample. If we supply new data to the model, it is out-of-sample prediction. If the data we supply is already in the sample, it is in-sample prediction. Here, we can create a scatter plot between actual values <code class="literal">(mtcars$mpg)</code> and fitted values to see how well the fitted linear model predicts:</p><pre class="programlisting">plot(mtcars$mpg, fitted(lm1)) &#13;
</pre><p>The plot generated is shown as follows:</p><div class="mediaobject"><img src="graphics/image_10_002.jpg" alt="Working with built-in classes and methods"/></div><p>Here, <code class="literal">fitted</code> is also a generic function, which, in this case, is equivalent to <code class="literal">lm1$fitted.values</code>, fitted values are also equal to the predicted values with the original dataset using <code class="literal">predict(lm1, mtcars)</code>.</p><p>The difference between the actual values and fitted values of the response variable is called residuals. We can use another generic function <code class="literal">residuals</code> to access the numeric vector, or equivalently, use <code class="literal">lm1$residuals</code>. Here, we will make a density plot of the residuals:</p><pre class="programlisting">plot(density(residuals(lm1)),  &#13;
  main = "Density of lm1 residuals") &#13;
</pre><p>The plot generated is shown as follows:</p><div class="mediaobject"><img src="graphics/image_10_003.jpg" alt="Working with built-in classes and methods"/></div><p>In the preceding function call, all involved functions are generic functions. The <code class="literal">residuals</code> function extracts the residuals from <code class="literal">lm1</code> and returns a numeric vector. The <code class="literal">density</code> function creates a list of class <code class="literal">density</code> to store the estimated data of density function of the residuals. Finally, <code class="literal">plot</code> turns to <code class="literal">plot.density</code> to create a density plot.</p><p>These generic functions work not only with <code class="literal">lm</code>, <code class="literal">glm</code>, and other built-in models, but also with models provided by other packages. For example, we use the <code class="literal">rpart</code> package to fit a regression tree model using the same data and the same formula in the previous example.</p><p>If you don't have the package installed, you need run the following code:</p><pre class="programlisting">install.packages("rpart") &#13;
</pre><p>Now, the package is ready to attach. We call <code class="literal">rpart</code> in exactly the same way as <code class="literal">lm</code>:</p><pre class="programlisting">library(rpart) &#13;
tree_model &lt;- rpart(mpg ~ cyl + vs, data = mtcars) &#13;
</pre><p>We can do so because the package authors want the function call to be consistent with how we call built-in functions in R. The resulted object is a list of class <code class="literal">rpart</code>, which works in the same way with <code class="literal">lm</code> is a list of class <code class="literal">rpart</code>:</p><pre class="programlisting">typeof(tree_model) &#13;
## [1] "list" &#13;
class(tree_model) &#13;
## [1] "rpart" &#13;
</pre><p>Like <code class="literal">lm</code> object, <code class="literal">rpart</code> also has a number of generic methods implemented. For example, we use the <code class="literal">print</code> function to print the model in its own way:</p><pre class="programlisting">print(tree_model) &#13;
## n = 32  &#13;
##  &#13;
## node), split, n, deviance, yval &#13;
##       * denotes terminal node &#13;
##  &#13;
## 1) root 32 1126.04700 20.09062   &#13;
##   2) cyl &gt;= 5 21  198.47240 16.64762   &#13;
##     4) cyl &gt;= 7 14   85.20000 15.10000 * &#13;
##     5) cyl &lt; 7 7   12.67714 19.74286 * &#13;
##   3) cyl &lt; 5 11  203.38550 26.66364 * &#13;
</pre><p>The output indicates that <code class="literal">print</code> has a method for <code class="literal">rpart</code>, which briefly shows what the regression tree looks like. In addition to <code class="literal">print</code>, <code class="literal">summary</code> gives more detailed information about the model fitting:</p><pre class="programlisting">summary(tree_model) &#13;
## Call: &#13;
## rpart(formula = mpg ~ cyl + vs, data = mtcars) &#13;
##   n = 32  &#13;
##  &#13;
##           CP nsplit rel error    xerror       xstd &#13;
## 1 0.64312523      0 1.0000000 1.0844542 0.25608044 &#13;
## 2 0.08933483      1 0.3568748 0.3858990 0.07230642 &#13;
## 3 0.01000000      2 0.2675399 0.3875795 0.07204598 &#13;
##  &#13;
## Variable importance &#13;
## cyl  vs  &#13;
##  65  35  &#13;
##  &#13;
## Node number 1: 32 observations,    complexity param=0.6431252 &#13;
##   mean=20.09062, MSE=35.18897  &#13;
##   left son=2 (21 obs) right son=3 (11 obs) &#13;
##   Primary splits: &#13;
##       cyl &lt; 5   to the right, improve=0.6431252, (0 missing) &#13;
##       vs  &lt; 0.5 to the left,  improve=0.4409477, (0 missing) &#13;
##   Surrogate splits: &#13;
##       vs &lt; 0.5 to the left,  agree=0.844, adj=0.545, (0 split) &#13;
##  &#13;
## Node number 2: 21 observations,    complexity param=0.08933483 &#13;
##   mean=16.64762, MSE=9.451066  &#13;
##   left son=4 (14 obs) right son=5 (7 obs) &#13;
##   Primary splits: &#13;
##       cyl &lt; 7   to the right, improve=0.5068475, (0 missing) &#13;
##   Surrogate splits: &#13;
##       vs &lt; 0.5 to the left,  agree=0.857, adj=0.571, (0 split) &#13;
##  &#13;
## Node number 3: 11 observations &#13;
##   mean=26.66364, MSE=18.48959  &#13;
##  &#13;
## Node number 4: 14 observations &#13;
##   mean=15.1, MSE=6.085714  &#13;
##  &#13;
## Node number 5: 7 observations &#13;
##   mean=19.74286, MSE=1.81102 &#13;
</pre><p>Likewise, <code class="literal">plot</code> and <code class="literal">text</code> also have methods for <code class="literal">rpart</code> to visualize it:</p><pre class="programlisting">oldpar &lt;- par(xpd = NA) &#13;
plot(tree_model) &#13;
text(tree_model, use.n = TRUE) &#13;
par(oldpar) &#13;
</pre><p>Then, we have the following tree graph:</p><div class="mediaobject"><img src="graphics/image_10_004.jpg" alt="Working with built-in classes and methods"/></div><p>We can use <code class="literal">predict</code> to make predictions with new data, just like what we did with the linear model in the previous examples:</p><pre class="programlisting">predict(tree_model, data.frame(cyl = c(6, 8), vs = c(1, 1))) &#13;
##        1        2  &#13;
## 19.74286 15.10000 &#13;
</pre><p>Note that not all models implement methods for all the generic functions. For example, since the regression tree is not a simple parametric model, it does not implement a method for <code class="literal">coef</code>:</p><pre class="programlisting">coef(tree_model) &#13;
## NULL &#13;
</pre></div><div class="section" title="Defining generic functions for existing classes"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec124"/>Defining generic functions for existing classes</h2></div></div></div><p>In the previous section, you learned how to use existing classes and methods to work with model objects. The S3 system, however, also allows us to create our own classes and generic functions.</p><p>Recall the example where we used conditional expressions to mimic the method dispatch of <code class="literal">head</code>. We mentioned that it works, but is often not the best practice. S3 generic functions are more flexible and easier to extend. To define a generic function, we usually create a function in which
 <code class="literal">UseMethod</code> is called to trigger method dispatch. Then, we create method functions in the form of <code class="literal">method.class</code> for the classes we want the generic function to work with and usually a default method in the form of <code class="literal">method.default</code> to capture all other cases. Here is a simple rewriting of this example using generic function and methods. Here, we will create a new generic function, <code class="literal">generic_head</code>, with two arguments: the input object <code class="literal">x</code> and the number of records to take, <code class="literal">n</code>. The generic function only calls <code class="literal">UseMethod("generic_head")</code> to ask R for method dispatch according to the class of <code class="literal">x</code>:</p><pre class="programlisting">generic_head &lt;- function(x, n)  &#13;
  UseMethod("generic_head") &#13;
</pre><p>For atomic vectors (numeric, character, logical, and so on), the first <code class="literal">n</code> elements should be taken. We can define <code class="literal">generic_head.numeric</code>, <code class="literal">generic_head.character</code>, and so on respectively, but in this case, it looks better to define a default method to capture all cases that are not matched by other <code class="literal">generic_head.class</code> methods:</p><pre class="programlisting">generic_head.default &lt;- function(x, n) { &#13;
  x[1:n] &#13;
} &#13;
</pre><p>Now, <code class="literal">generic_head</code> has only one method, which is equivalent to not using generic function at all:</p><pre class="programlisting">generic_head(num_vec, 3) &#13;
## [1] 1 2 3 &#13;
</pre><p>Since we haven't defined the method for class <code class="literal">data.frame</code>, supplying a data frame will fall back to <code class="literal">generic_head.default</code>, which causes an error due to the invalid access of an out-of-bound column index:</p><pre class="programlisting">generic_head(data_frame, 3) &#13;
## Error in `[.data.frame`(x, 1:n): undefined columns selected &#13;
</pre><p>However, let's assume we define a method for <code class="literal">data.frame</code>:</p><pre class="programlisting">generic_head.data.frame &lt;- function(x, n) { &#13;
  x[1:n,] &#13;
} &#13;
</pre><p>The generic function works as it is supposed to:</p><pre class="programlisting">generic_head(data_frame, 3) &#13;
##   x         y &#13;
## 1 1 0.8867848 &#13;
## 2 2 0.1169713 &#13;
## 3 3 0.3186301 &#13;
</pre><p>You may notice that the methods we implemented earlier are not robust because we don't have the argument checked. For example, if <code class="literal">n</code> is greater than the number of elements of the input object, the function will behave differently and usually in an undesirable way. I'll leave it as an exercise for you to make the methods more robust and behave appropriately for corner cases.</p></div><div class="section" title="Creating objects of new classes"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec125"/>Creating objects of new classes</h2></div></div></div><p>Now, it is time to have some examples of defining new classes. Note that <code class="literal">class(x)</code> gets the class of <code class="literal">x</code>, while <code class="literal">class(x) &lt;- "some_class"</code> sets the class of <code class="literal">x</code> to <code class="literal">some_class</code>.</p><div class="section" title="Using list as the underlying data structure"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec61"/>Using list as the underlying data structure</h3></div></div></div><p>Just like <code class="literal">lm</code> and <code class="literal">rpart</code>, list is probably the most widely used underlying data structure to create a new class. This is because a class represents a type of object that can store different kinds of data with different lengths and has some methods to interact with other objects.</p><p>In the following example, we will define a function called <code class="literal">product</code> that creates a list of the class <code class="literal">product</code> with a name, price, and inventory. We'll define its own <code class="literal">print</code> method and add more behaviors as we go ahead:</p><pre class="programlisting">product &lt;- function(name, price, inventory) { &#13;
  obj &lt;- list(name = name,  &#13;
    price = price,  &#13;
    inventory = inventory) &#13;
  class(obj) &lt;- "product" &#13;
  obj &#13;
} &#13;
</pre><p>Note that we created a list first, replaced its class with <code class="literal">product</code>, and finally returned the object. In fact, the class of an object is a character vector. An alternative way is to use <code class="literal">structure()</code>:</p><pre class="programlisting">product &lt;- function(name, price, inventory) { &#13;
  structure(list(name = name,  &#13;
    price = price,  &#13;
    inventory = inventory), &#13;
    class = "product") &#13;
} &#13;
</pre><p>Now, we have a function that produced objects of the class <code class="literal">product</code>. In the following code, we will call <code class="literal">product()</code> and create an instance of this class:</p><pre class="programlisting">laptop &lt;- product("Laptop", 499, 300) &#13;
</pre><p>Like all previous objects, we can see its internal data structure and its S3 class for method dispatch:</p><pre class="programlisting">typeof(laptop) &#13;
## [1] "list" &#13;
class(laptop) &#13;
## [1] "product" &#13;
</pre><p>Obviously, <code class="literal">laptop</code> is a list of class <code class="literal">product</code> as we created it. Since we haven't defined any methods for this class, its behavior is no different from an ordinary list object. If we type it, it will be printed as a list with its customized class attribute:</p><pre class="programlisting">laptop &#13;
## $name &#13;
## [1] "Laptop" &#13;
##  &#13;
## $price &#13;
## [1] 499 &#13;
##  &#13;
## $inventory &#13;
## [1] 300 &#13;
##  &#13;
## attr(,"class") &#13;
## [1] "product" &#13;
</pre><p>First, we can implement the <code class="literal">print</code> method for this class. Here, we want the class and the data fields in it to be printed in a compact style:</p><pre class="programlisting">print.product &lt;- function(x, ...) { &#13;
  cat("&lt;product&gt;\n") &#13;
  cat("name:", x$name, "\n") &#13;
  cat("price:", x$price, "\n") &#13;
  cat("inventory:", x$inventory, "\n") &#13;
  invisible(x) &#13;
} &#13;
</pre><p>It is a convention that the <code class="literal">print</code> method returns the input object itself for further use. If the printing is customized, then we often use <code class="literal">invisible</code> to suppress repeated printing of the same object that the function returns. You may try returning <code class="literal">x</code> directly and see what happens.</p><p>Then, we type the variable again. The <code class="literal">print</code> method will be dispatched to <code class="literal">print.product</code> since it is already defined:</p><pre class="programlisting">laptop &#13;
## &lt;product&gt; &#13;
## name: Laptop  &#13;
## price: 499  &#13;
## inventory: 300 &#13;
</pre><p>We can access the elements in <code class="literal">laptop</code> just like extracting elements from a list:</p><pre class="programlisting">laptop$name &#13;
## [1] "Laptop" &#13;
laptop$price &#13;
## [1] 499 &#13;
laptop$inventory &#13;
## [1] 300 &#13;
</pre><p>If we create another instance and put the two instances into a list, <code class="literal">print.product</code> will still be called when the list is printed:</p><pre class="programlisting">cellphone &lt;- product("Phone", 249, 12000) &#13;
products &lt;- list(laptop, cellphone) &#13;
products &#13;
## [[1]] &#13;
## &lt;product&gt; &#13;
## name: Laptop  &#13;
## price: 499  &#13;
## inventory: 300  &#13;
##  &#13;
## [[2]] &#13;
## &lt;product&gt; &#13;
## name: Phone  &#13;
## price: 249  &#13;
## inventory: 12000 &#13;
</pre><p>This is because when <code class="literal">products</code> is printed as a list, it calls <code class="literal">print</code> on each of the elements, which also causes method dispatch.</p><p>Creating an S3 class is much simpler than most other programming languages that require formal definition of classes. It is important to have sufficient checking on the arguments to ensure that the created object is internally consistent with what the class represents.</p><p>For example, without proper checking, we can create a product with negative and non-integer inventory:</p><pre class="programlisting">product("Basket", 150, -0.5) &#13;
## &lt;product&gt; &#13;
## name: Basket  &#13;
## price: 150  &#13;
## inventory: -0.5 &#13;
</pre><p>To avoid this, we need to add some checking conditions in the object-generating function, <code class="literal">product</code>:</p><pre class="programlisting">product &lt;- function(name, price, inventory) { &#13;
  stopifnot( &#13;
    is.character(name), length(name) == 1, &#13;
    is.numeric(price), length(price) == 1,  &#13;
    is.numeric(inventory), length(inventory) == 1,  &#13;
price &gt; 0, inventory &gt;= 0) &#13;
  structure(list(name = name,  &#13;
    price = as.numeric(price),  &#13;
    inventory = as.integer(inventory)), &#13;
    class = "product") &#13;
} &#13;
</pre><p>The function is enhanced, in that <code class="literal">name</code> must be a single string, <code class="literal">price</code> must be a single positive number, and <code class="literal">inventory</code> must be a single non-negative number. With this function, we cannot create ridiculous products by mistake, and such errors can be found in an early stage:</p><pre class="programlisting">product("Basket", 150, -0.5) &#13;
## Error: inventory &gt;= 0 is not TRUE &#13;
</pre><p>In addition to defining new classes, we can also define new generic functions. In the following code, we will define a new generic function called <code class="literal">value</code> and implement a method for <code class="literal">product</code> by measuring the value of the inventory of the product:</p><pre class="programlisting">value &lt;- function(x, ...)  &#13;
  UseMethod("value") &#13;
 &#13;
value.default &lt;- function(x, ...) { &#13;
  stop("value is undefined") &#13;
} &#13;
 &#13;
value.product &lt;- function(x, ...) { &#13;
  x$price * x$inventory &#13;
} &#13;
</pre><p>For other classes, it calls <code class="literal">value.default</code> and stops. Now, <code class="literal">value</code> can be used with all instances of <code class="literal">product</code> we created:</p><pre class="programlisting">value(laptop) &#13;
## [1] 149700 &#13;
value(cellphone) &#13;
## [1] 2988000 &#13;
</pre><p>The generic function also works with apply family functions by performing method dispatch for each element in the input vector or list:</p><pre class="programlisting">sapply(products, value) &#13;
## [1]  149700 2988000 &#13;
</pre><p>One more question is once we create the object of a certain class, does that mean that we can no longer change it? No, we still can change it. In this case, we can modify an existing element of <code class="literal">laptop</code>:</p><pre class="programlisting">laptop$price &lt;- laptop$price * 0.85 &#13;
</pre><p>We can also create a new element in <code class="literal">laptop</code>:</p><pre class="programlisting">laptop$value &lt;- laptop$price * laptop$inventory &#13;
</pre><p>Now, we can take a look at it, and the changes are effective:</p><pre class="programlisting">laptop &#13;
## &lt;product&gt; &#13;
## name: Laptop  &#13;
## price: 424.15  &#13;
## inventory: 300 &#13;
</pre><p>What's worse is that we can even remove an element by setting it to <code class="literal">NULL</code>. This is why the S3 system is considered to be loose. You can't make sure that the object of a certain type has a fixed set of data fields and methods.</p></div><div class="section" title="Using an atomic vector as the underlying data structure"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec62"/>Using an atomic vector as the underlying data structure</h3></div></div></div><p>In the previous section, we demonstrated an example of creating a new class from a list object. In fact, it is sometimes useful to create a new class of object from an atomic vector. In this section, I will show you a series of steps to create vectors with a percentage representation.</p><p>We first define a function, <code class="literal">percent</code>. This function simply checks whether the input is a numeric vector and alters its class to <code class="literal">percent</code>, which inherits from <code class="literal">numeric</code>:</p><pre class="programlisting">percent &lt;- function(x) { &#13;
  stopifnot(is.numeric(x)) &#13;
  class(x) &lt;- c("percent", "numeric") &#13;
  x &#13;
} &#13;
</pre><p>The inheritance here means that method dispatch first looks for methods of <code class="literal">percent</code>. If none is found, then it looks for methods of <code class="literal">numeric</code>. Therefore, the order of the class names matters. S3 inheritance will be covered in detail in the following section.</p><p>Now, we can create a percent vector from a numeric vector:</p><pre class="programlisting">pct &lt;- percent(c(0.1, 0.05, 0.25, 0.23)) &#13;
pct &#13;
## [1] 0.10 0.05 0.25 0.23 &#13;
## attr(,"class") &#13;
## [1] "percent" "numeric" &#13;
</pre><p>At the moment, there is no method implemented for <code class="literal">percent</code>. So, <code class="literal">pct</code> looks like an ordinary numeric vector with a customized class attribute. The purpose of this class is to show its values in percentage form, such as 25 percent instead of its original decimal representation.</p><p>To achieve this goal, we first implement <code class="literal">as.character</code> for the <code class="literal">percent</code> class by producing the correct string representation of the percentage form:</p><pre class="programlisting">as.character.percent &lt;- function(x, ...) { &#13;
  paste0(as.numeric(x) * 100, "%") &#13;
} &#13;
</pre><p>Now, we can get the desired string representation of a given percent vector:</p><pre class="programlisting">as.character(pct) &#13;
## [1] "10%" "5%"  "25%" "23%" &#13;
</pre><p>Likewise, we need to implement <code class="literal">format</code> for <code class="literal">percent</code> by directly calling <code class="literal">as.character</code>:</p><pre class="programlisting">format.percent &lt;- function(x, ...) { &#13;
  as.character(x, ...) &#13;
} &#13;
</pre><p>Now, <code class="literal">format</code> has the same effect:</p><pre class="programlisting">format(pct) &#13;
## [1] "10%" "5%"  "25%" "23%" &#13;
</pre><p>Now, we can implement <code class="literal">print</code> for <code class="literal">percent</code> by calling <code class="literal">format.percent</code> directly:</p><pre class="programlisting">print.percent &lt;- function(x, ...) { &#13;
  print(format.percent(x), quote = FALSE) &#13;
} &#13;
</pre><p>Note that we specify <code class="literal">quote = FALSE</code> when we print the formatted strings to make it look like numbers rather than strings. This is exactly the desired effect:</p><pre class="programlisting">pct &#13;
## [1] 10% 5%  25% 23% &#13;
</pre><p>Note that arithmetic operators such as <code class="literal">+</code> and <code class="literal">*</code> automatically preserve the class of the output vector. As a result, the output vector is still printed in percentage form:</p><pre class="programlisting">pct + 0.2 &#13;
## [1] 30% 25% 45% 43% &#13;
pct * 0.5 &#13;
## [1] 5%    2.5%  12.5% 11.5% &#13;
</pre><p>Unfortunately, other functions may not preserve the class of their input. For example, <code class="literal">sum</code>, <code class="literal">mean</code>, <code class="literal">max</code>, and <code class="literal">min</code> will drop the customized class and return a plain numeric vector instead:</p><pre class="programlisting">sum(pct) &#13;
## [1] 0.63 &#13;
mean(pct) &#13;
## [1] 0.1575 &#13;
max(pct) &#13;
## [1] 0.25 &#13;
min(pct) &#13;
## [1] 0.05 &#13;
</pre><p>To make sure the percentage form is preserved when we perform these calculations, we need to implement these methods for the <code class="literal">percent</code> class:</p><pre class="programlisting">sum.percent &lt;- function(...) { &#13;
  percent(NextMethod("sum")) &#13;
} &#13;
mean.percent &lt;- function(x, ...) { &#13;
  percent(NextMethod("mean")) &#13;
} &#13;
max.percent &lt;- function(...) { &#13;
  percent(NextMethod("max")) &#13;
} &#13;
min.percent &lt;- function(...) { &#13;
  percent(NextMethod("max")) &#13;
} &#13;
</pre><p>In the first method, <code class="literal">NextMethod("sum")</code> calls <code class="literal">sum</code> for numeric class, and the output numeric vector is wrapped with <code class="literal">percent</code> again. The same logic also applies to the implementation of the other three methods:</p><pre class="programlisting">sum(pct) &#13;
## [1] 63% &#13;
mean(pct) &#13;
## [1] 15.75% &#13;
max(pct) &#13;
## [1] 25% &#13;
min(pct) &#13;
## [1] 5% &#13;
</pre><p>Now, these functions return values in percentage form, too. However, if we combine a percent vector with other numeric values, the percent class will be gone:</p><pre class="programlisting">c(pct, 0.12) &#13;
## [1] 0.10 0.05 0.25 0.23 0.12 &#13;
</pre><p>We can do the same thing to <code class="literal">c</code>:</p><pre class="programlisting">c.percent &lt;- function(x, ...) { &#13;
  percent(NextMethod("c")) &#13;
} &#13;
</pre><p>Now, combining percent vectors with numeric values result in percent vectors too:</p><pre class="programlisting">c(pct, 0.12, -0.145) &#13;
## [1] 10%    5%     25%    23%    12%    -14.5% &#13;
</pre><p>However, from the other side, when we subset the percent vector or extract a value from it, the percent class will be dropped:</p><pre class="programlisting">pct[1:3] &#13;
## [1] 0.10 0.05 0.25 &#13;
pct[[2]] &#13;
## [1] 0.05 &#13;
</pre><p>To fix this, we need to implement <code class="literal">[</code> and <code class="literal">[[</code> for <code class="literal">percent</code> in exactly the same way. You might be surprised to see a method called <code class="literal">[.percent</code>, but it will indeed match the <code class="literal">percent</code> class when we use these operators on a percent vector:</p><pre class="programlisting">`[.percent` &lt;- function(x, i) { &#13;
  percent(NextMethod("[")) &#13;
} &#13;
`[[.percent` &lt;- function(x, i) { &#13;
  percent(NextMethod("[[")) &#13;
} &#13;
</pre><p>Now, both subsetting and extracting preserve the percent class:</p><pre class="programlisting">pct[1:3] &#13;
## [1] 10% 5%  25% &#13;
pct[[2]] &#13;
## [1] 5% &#13;
</pre><p>With all these methods implemented, we can place a percent vector as a column of a data frame:</p><pre class="programlisting">data.frame(id = 1:4, pct) &#13;
##   id pct &#13;
## 1  1 10% &#13;
## 2  2  5% &#13;
## 3  3 25% &#13;
## 4  4 23% &#13;
</pre><p>The percentage form is correctly preserved as a column in the data frame.</p></div><div class="section" title="Understanding S3 inheritance"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec63"/>Understanding S3 inheritance</h3></div></div></div><p>The S3 system is loose. You only need to create a function in the form of <code class="literal">method.class</code> to implement a method for a generic function. You only need to supply a character vector with multiple elements to indicate the inheritance relationship along the vector.</p><p>As we mentioned in the previous section, the class vector determines the order of matching classes in method dispatch. To demonstrate it, we will use a simple example in which we construct a number of classes with inheritance relationships.</p><p>Suppose we want to model some vehicles such as a car, bus, and airplane. These vehicles have something in common. They all have name, speed, and position, and they can move. To model them, we can define a base class called <code class="literal">vehicle</code>, which stores the common parts. We also define <code class="literal">car</code>, <code class="literal">bus</code>, and <code class="literal">airplane</code> that inherit from <code class="literal">vehicle</code> but have customized behaviors.</p><p>First, we will define a function to create the <code class="literal">vehicle</code> object, which is essentially an environment. We choose an environment over a list because we need its reference semantics, that is, we pass around the object, and modifying it will not cause a copy of the object. So, the object always refers to the same vehicle, no matter where it is passed around:</p><pre class="programlisting">Vehicle &lt;- function(class, name, speed) { &#13;
  obj &lt;- new.env(parent = emptyenv()) &#13;
  obj$name &lt;- name &#13;
  obj$speed &lt;- speed &#13;
  obj$position &lt;- c(0, 0, 0) &#13;
  class(obj) &lt;- c(class, "vehicle") &#13;
  obj &#13;
} &#13;
</pre><p>Note that <code class="literal">class(obj) &lt;- c(class, "vehicle")</code> may look ambiguous because <code class="literal">class</code> is both a function argument and a basic function. In fact, <code class="literal">class(obj) &lt;-</code> will look for the <code class="literal">class&lt;-</code> function so that the usage does not cause ambiguity. The <code class="literal">Vehicle</code> function is a general creator of vehicle class objects with common data fields. The following function is specialized functions to create <code class="literal">car</code>, <code class="literal">bus</code> and <code class="literal">airplane</code> that inherit vehicle:</p><pre class="programlisting">Car &lt;- function(...) { &#13;
  Vehicle(class = "car", ...) &#13;
} &#13;
Bus &lt;- function(...) { &#13;
  Vehicle(class = "bus", ...) &#13;
} &#13;
Airplane &lt;- function(...) { &#13;
  Vehicle(class = "airplane", ...) &#13;
} &#13;
</pre><p>With the three preceding functions, we can create <code class="literal">car</code>, <code class="literal">bus</code>, and <code class="literal">airplane</code> objects. All inherit from the <code class="literal">vehicle</code> class. Now, we create an instance for each class:</p><pre class="programlisting">car &lt;- Car("Model-A", 80) &#13;
bus &lt;- Bus("Medium-Bus", 45) &#13;
airplane &lt;- Airplane("Big-Plane", 800) &#13;
</pre><p>Now, we will implement a common <code class="literal">print</code> method for <code class="literal">vehicle</code>:</p><pre class="programlisting">print.vehicle &lt;- function(x, ...) { &#13;
  cat(sprintf("&lt;vehicle: %s&gt;\n", class(x)[[1]])) &#13;
  cat("name:", x$name, "\n") &#13;
  cat("speed:", x$speed, "km/h\n") &#13;
  cat("position:", paste(x$position, collapse = ", ")) &#13;
} &#13;
</pre><p>Since no <code class="literal">print.car</code>, <code class="literal">print.bus</code> or <code class="literal">print.airplane</code> is defined, typing those variables will print them with <code class="literal">print.vehicle</code>:</p><pre class="programlisting">car &#13;
## &lt;vehicle: car&gt; &#13;
## name: Model-A  &#13;
## speed: 80 km/h &#13;
## position: 0, 0, 0 &#13;
bus &#13;
## &lt;vehicle: bus&gt; &#13;
## name: Medium-Bus  &#13;
## speed: 45 km/h &#13;
## position: 0, 0, 0 &#13;
airplane &#13;
## &lt;vehicle: airplane&gt; &#13;
## name: Big-Plane  &#13;
## speed: 800 km/h &#13;
## position: 0, 0, 0 &#13;
</pre><p>A vehicle is a carrier designed to be driven and to move. Naturally, we define a generic function called <code class="literal">move</code>, which modifies the position of a vehicle to reflect a user-supplied movement in a three-dimensional space. Since different vehicles move in different ways with distinct limitations, we can further implement several <code class="literal">move</code> methods for the various classes of vehicle we just defined:</p><pre class="programlisting">move &lt;- function(vehicle, x, y, z) { &#13;
  UseMethod("move") &#13;
} &#13;
move.vehicle &lt;- function(vehicle, movement) { &#13;
  if (length(movement) != 3) { &#13;
    stop("All three dimensions must be specified to move a vehicle") &#13;
  } &#13;
  vehicle$position &lt;- vehicle$position + movement &#13;
  vehicle &#13;
} &#13;
</pre><p>Here, we will limit the movement that can happen to a car and a bus to two dimensions. Therefore, we will implement <code class="literal">move.bus</code> and <code class="literal">move.car</code> by checking the length of the <code class="literal">movement</code> vector, which is only allowed to be <code class="literal">2</code>. If the movement is valid, then, we would force the third dimension of <code class="literal">movement</code> to be <code class="literal">0</code> and then call <code class="literal">NextMethod("move")</code> to call <code class="literal">move.vehicle</code> with <code class="literal">vehicle</code> and the latest value of <code class="literal">movement</code>:</p><pre class="programlisting">move.bus &lt;- move.car &lt;- function(vehicle, movement) { &#13;
  if (length(movement) != 2) { &#13;
    stop("This vehicle only supports 2d movement") &#13;
  } &#13;
  movement &lt;- c(movement, 0) &#13;
  NextMethod("move") &#13;
} &#13;
</pre><p>An airplane can move in either two or three dimensions. Therefore, <code class="literal">move.airplane</code> can be flexible to accept both. If the <code class="literal">movement</code> vector is two dimensional, then the movement on the third dimension is regarded as zero:</p><pre class="programlisting">move.airplane &lt;- function(vehicle, movement) { &#13;
  if (length(movement) == 2) { &#13;
    movement &lt;- c(movement, 0) &#13;
  } &#13;
  NextMethod("move") &#13;
} &#13;
</pre><p>With <code class="literal">move</code> implemented for all three vehicles, we can test them with the three instances. First, let's see if the following expression goes into an error if we want the car to move with a three-dimensional vector:</p><pre class="programlisting">move(car, c(1, 2, 3)) &#13;
## Error in move.car(car, c(1, 2, 3)): This vehicle only supports 2d movement &#13;
</pre><p>The method dispatch of the preceding function call finds <code class="literal">move.car</code> and stops for the invalid movement. The following code is a two-dimensional movement, which is valid:</p><pre class="programlisting">move(car, c(1, 2)) &#13;
## &lt;vehicle: car&gt; &#13;
## name: Model-A  &#13;
## speed: 80 km/h &#13;
## position: 1, 2, 0 &#13;
</pre><p>Similarly, we can move the airplane in two dimensions:</p><pre class="programlisting">move(airplane, c(1, 2)) &#13;
## &lt;vehicle: airplane&gt; &#13;
## name: Big-Plane  &#13;
## speed: 800 km/h &#13;
## position: 1, 2, 0 &#13;
</pre><p>We can also move it in three dimensions:</p><pre class="programlisting">move(airplane, c(20, 50, 80)) &#13;
## &lt;vehicle: airplane&gt; &#13;
## name: Big-Plane  &#13;
## speed: 800 km/h &#13;
## position: 21, 52, 80 &#13;
</pre><p>Note that the position of <code class="literal">airplane</code> is accumulated because it is essentially an environment, so modifying <code class="literal">position</code> in <code class="literal">move.vehicle</code> does not cause a copy of it. Therefore, no matter where you pass it, there is only one instance of it. If you are not familiar with the reference semantics of environments, go through <a class="link" href="ch08.html" title="Chapter 8. Inside R">Chapter 8</a>, <span class="emphasis"><em>Inside R</em></span>.</p></div></div></div>
<div class="section" title="Working with S4"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec54"/>Working with S4</h1></div></div></div><p>In the previous section, we introduced the S3 system. Unlike the object-oriented systems in most other programming languages, the S3 system is much less strict than a system in which classes are defined with a fixed structure and certain method dispatch as the program compiles. When we define an S3 class, almost nothing can be sure. We can not only add or remove methods of the class at any time but also insert or delete data elements from the object as we wish. In addition, S3 only supports single dispatch, that is, methods are chosen according to the class of only one argument, mostly the first argument.</p><p>Then, R introduces a more formal and stricter object-oriented system, S4. This system allows us to define formal classes with pre-specified definition and inheritance structure. It also supports multiple dispatch, that is, methods are chosen according to the classes of multiple arguments.</p><p>In this section, you will learn how to define S4 classes and methods.</p><div class="section" title="Defining S4 classes"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec126"/>Defining S4 classes</h2></div></div></div><p>Unlike S3 classes, which are simply represented by character vectors, S4 classes require formal definition of classes and methods. To define an S4 class, we need to call <code class="literal">setClass</code> and supply a representation of the class members, which are called <span class="strong"><strong>slots</strong></span>. The representation is specified by the name and class of each slot. In this section, we'll redefine the product objects using an S4 class:</p><pre class="programlisting">setClass("Product",  &#13;
  representation(name = "character",  &#13;
    price = "numeric",  &#13;
    inventory = "integer")) &#13;
</pre><p>Once the class is defined, we can get the slots from its class definition by <code class="literal">getSlots()</code>:</p><pre class="programlisting">getSlots("Product") &#13;
##        name       price   inventory  &#13;
## "character"   "numeric"   "integer" &#13;
</pre><p>S4 is stricter than S3, not only because S4 requires class definition, but also because R will ensure that the classes of the members that create a new instance are consistent with the class representation. Now, we will use <code class="literal">new()</code> to create a new instance of an S4 class and specify the values of the slots:</p><pre class="programlisting">laptop &lt;- new("Product", name = "Laptop-A", price = 299, inventory = 100) &#13;
## Error in validObject(.Object): invalid class "Product" object: invalid object for slot "inventory" in class "Product": got class "numeric", should be or extend class "integer" &#13;
</pre><p>It might surprise you that the preceding code produces an error. If you take a closer look at the class representation, you will find that <code class="literal">inventory</code> must be an integer. In other words, <code class="literal">100</code> is a numeric value, which is not of class <code class="literal">integer</code>. It requires <code class="literal">100L</code> instead:</p><pre class="programlisting">laptop &lt;- new("Product", name = "Laptop-A", price = 299, inventory = 100L) &#13;
laptop &#13;
## An object of class "Product" &#13;
## Slot "name": &#13;
## [1] "Laptop-A" &#13;
##  &#13;
## Slot "price": &#13;
## [1] 299 &#13;
##  &#13;
## Slot "inventory": &#13;
## [1] 100 &#13;
</pre><p>Now, a new instance of <code class="literal">Product</code>, <code class="literal">laptop</code>, is created. It is printed as an object of class <code class="literal">Product</code>. The values of all slots are automatically printed.</p><p>For an S4 object, we can still use <code class="literal">typeof()</code> and <code class="literal">class()</code> to get some type information:</p><pre class="programlisting">typeof(laptop) &#13;
## [1] "S4" &#13;
class(laptop) &#13;
## [1] "Product" &#13;
## attr(,"package") &#13;
## [1] ".GlobalEnv" &#13;
</pre><p>This time, the type is <code class="literal">S4</code> instead of <code class="literal">list</code> or other data types, and the class is the name of the S4 class. The S4 object is also a first-class citizen in R because it has a checking function:</p><pre class="programlisting">isS4(laptop) &#13;
## [1] TRUE &#13;
</pre><p>Unlike accessing a list or environment with <code class="literal">$</code>, we need to use <code class="literal">@</code> to access a slot of an S4 object:</p><pre class="programlisting">laptop@price * laptop@inventory &#13;
## [1] 29900 &#13;
</pre><p>Alternatively, we can call <code class="literal">slot()</code> to access a slot with its name as a string. This is equivalent to accessing an element of a list or environment with double brackets (<code class="literal">[[]]</code>):</p><pre class="programlisting">slot(laptop, "price") &#13;
## [1] 299 &#13;
</pre><p>We can also modify an S4 object in the same way we modify a list:</p><pre class="programlisting">laptop@price &lt;- 289 &#13;
</pre><p>However, we cannot supply to a slot something that is not consistent with the class representation:</p><pre class="programlisting">laptop@inventory &lt;- 200 &#13;
## Error in (function (cl, name, valueClass) : assignment of an object of class "numeric" is not valid for @'inventory' in an object of class "Product"; is(value, "integer") is not TRUE &#13;
</pre><p>Neither can we create a new slot just like adding a new element to a list because the structure of an S4 object is fixed to its class representation:</p><pre class="programlisting">laptop@value &lt;- laptop@price * laptop@inventory &#13;
## Error in (function (cl, name, valueClass) : 'value' is not a slot in class "Product" &#13;
</pre><p>Now, we will create another instance with the values of slots partially supplied:</p><pre class="programlisting">toy &lt;- new("Product", name = "Toys", price = 10) &#13;
toy &#13;
## An object of class "Product" &#13;
## Slot "name": &#13;
## [1] "Toys" &#13;
##  &#13;
## Slot "price": &#13;
## [1] 10 &#13;
##  &#13;
## Slot "inventory": &#13;
## integer(0) &#13;
</pre><p>The preceding code does not specify <code class="literal">inventory</code>, so the resulting object, <code class="literal">toy</code>, takes an empty integer vector as <code class="literal">inventory</code>. If you think it is not a good default value, we can specify a prototype of the class so that each instance will be created from it as a template:</p><pre class="programlisting">setClass("Product",  &#13;
  representation(name = "character",  &#13;
    price = "numeric",  &#13;
    inventory = "integer"), &#13;
  prototype(name = "Unnamed", price = NA_real_, inventory = 0L)) &#13;
</pre><p>In the preceding prototype, we set the default value of <code class="literal">price</code> to be the numeric missing value and inventory to be integer zero. Note that <code class="literal">NA</code> is logical and cannot be used here because it is not consistent with the class representation.</p><p>Then, we will recreate <code class="literal">toy</code> with the same code:</p><pre class="programlisting">toy &lt;- new("Product", name = "Toys", price = 5) &#13;
toy &#13;
## An object of class "Product" &#13;
## Slot "name": &#13;
## [1] "Toys" &#13;
##  &#13;
## Slot "price": &#13;
## [1] 5 &#13;
##  &#13;
## Slot "inventory": &#13;
## [1] 0 &#13;
</pre><p>This time, <code class="literal">inventory</code> takes the default value <code class="literal">0L</code> from the prototype. However, what if we need more constraints on the input arguments? Although the classes of the arguments are checked, we can still supply values that are not meaningful as an instance of <code class="literal">Product</code>. For example, we can create a <code class="literal">bottle</code> class with negative inventory:</p><pre class="programlisting">bottle &lt;- new("Product", name = "Bottle", price = 1.5, inventory = -2L) &#13;
bottle &#13;
## An object of class "Product" &#13;
## Slot "name": &#13;
## [1] "Bottle" &#13;
##  &#13;
## Slot "price": &#13;
## [1] 1.5 &#13;
##  &#13;
## Slot "inventory": &#13;
## [1] -2 &#13;
</pre><p>The following code is a validation function that ensures that the slots of a <code class="literal">Product</code> object are meaningful. The validation function is somehow special because when there is no error about the input object, it should return <code class="literal">TRUE</code>. When there are errors, it should return a character vector that describe the errors. Therefore, it is best not to use <code class="literal">stop()</code> or <code class="literal">warning()</code> when a slot is not valid.</p><p>Here, we will validate the object by checking the length of each slot and whether they are missing values. Also, the price must be positive, and the inventory must be non-negative:</p><pre class="programlisting">validate_product &lt;- function(object) { &#13;
  errors &lt;- c( &#13;
    if (length(object@name) != 1)   &#13;
      "Length of name should be 1"  &#13;
    else if (is.na(object@name))  &#13;
      "name should not be missing value", &#13;
     &#13;
    if (length(object@price) != 1)  &#13;
      "Length of price should be 1" &#13;
    else if (is.na(object@price))  &#13;
      "price should not be missing value" &#13;
    else if (object@price &lt;= 0)  &#13;
      "price must be positive", &#13;
     &#13;
    if (length(object@inventory) != 1)  &#13;
      "Length of inventory should be 1" &#13;
    else if (is.na(object@inventory)) &#13;
      "inventory should not be missing value" &#13;
    else if (object@inventory &lt; 0)  &#13;
      "inventory must be non-negative") &#13;
  if (length(errors) == 0) TRUE else errors &#13;
} &#13;
</pre><p>We write a long combination of values to make up the error messages. This works because <code class="literal">if (FALSE) expr</code> returns <code class="literal">NULL</code> and <code class="literal">c(x, NULL)</code> returns <code class="literal">x</code>. At last, if no error message is produced, the function returns <code class="literal">TRUE</code>, otherwise it returns the error messages.</p><p>With this function defined, we can directly use it to validate <code class="literal">bottle</code>:</p><pre class="programlisting">validate_product(bottle) &#13;
## [1] "inventory must be non-negative" &#13;
</pre><p>The validation results in an error message as supposed. Now, we need to make the class perform validation each time an instance is being created. We only need to specify the <code class="literal">validity</code> argument when we use <code class="literal">setClass</code> for <code class="literal">Product</code> class:</p><pre class="programlisting">setClass("Product",  &#13;
  representation(name = "character",  &#13;
    price = "numeric",  &#13;
    inventory = "integer"), &#13;
  prototype(name = "Unnamed",  &#13;
    price = NA_real_, inventory = 0L), &#13;
  validity = validate_product) &#13;
</pre><p>Then, each time we try to create an instance of the <code class="literal">Product</code> class, the supplied values are automatically checked. Even the prototype is checked. Here are two cases that fail the validation:</p><pre class="programlisting">bottle &lt;- new("Product", name = "Bottle") &#13;
## Error in validObject(.Object): invalid class "Product" object: price should not be missing value &#13;
</pre><p>The preceding code fails because the default value of <code class="literal">price</code> is <code class="literal">NA_real_</code> in the prototype. In the validation, however, the price cannot be a missing value:</p><pre class="programlisting">bottle &lt;- new("Product", name = "Bottle", price = 3, inventory = -2L) &#13;
## Error in validObject(.Object): invalid class "Product" object: inventory must be non-negative &#13;
</pre><p>This fails because <code class="literal">inventory</code> must be a non-negative integer.</p><p>Note that the validation only occurs when we create a new instance of an S4 class. Once the object is created, however, the validation does not happen anymore. In other words, we can still set a slot to a bad value unless we explicitly validate it.</p></div><div class="section" title="Understanding S4 inheritance"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec127"/>Understanding S4 inheritance</h2></div></div></div><p>The S3 system is loose and flexible. Each S3 object of the same class may have different members. For S4, however, this cannot happen, that is, we cannot arbitrarily add a slot that is not in the class definition when we create a new instance of the class.</p><p>For example, we cannot put a <code class="literal">volume</code> slot when we create a new instance of <code class="literal">Product</code>:</p><pre class="programlisting">bottle &lt;- new("Product", name = "Bottle",  &#13;
  price = 3, inventory = 100L, volume = 15) &#13;
## Error in initialize(value, ...): invalid name for slot of class "Product": volume &#13;
</pre><p>Instead, we can only do this through proper inheritance. We need to create a new class that contains (or inherits from) the original class. In this case, we can define a <code class="literal">Container</code> class that inherits from <code class="literal">Product</code> and has a new numeric slot named <code class="literal">volume</code>:</p><pre class="programlisting">setClass("Container",  &#13;
  representation(volume = "numeric"),  &#13;
  contains = "Product") &#13;
</pre><p>Since <code class="literal">Container</code> inherits from <code class="literal">Product</code>, any instance of <code class="literal">Container</code> has all the slots of <code class="literal">Product</code>. We can use <code class="literal">getSlots()</code> to view them:</p><pre class="programlisting">getSlots("Container") &#13;
##      volume        name       price   inventory  &#13;
##   "numeric" "character"   "numeric"   "integer" &#13;
</pre><p>Now, we can create an instance of <code class="literal">Container</code> that has a <code class="literal">volume</code> slot:</p><pre class="programlisting">bottle &lt;- new("Container", name = "Bottle", &#13;
  price = 3, inventory = 100L, volume = 15) &#13;
</pre><p>Note that the validation of <code class="literal">Product</code> still functions when we create an instance of <code class="literal">Container</code>:</p><pre class="programlisting">bottle &lt;- new("Container", name = "Bottle", &#13;
  price = 3, inventory = -10L, volume = 15) &#13;
## Error in validObject(.Object): invalid class "Container" object: inventory must be non-negative &#13;
</pre><p>Therefore, the checking ensures it is a valid <code class="literal">Product</code> class, but it still does not check anything about <code class="literal">Container</code>:</p><pre class="programlisting">bottle &lt;- new("Container", name = "Bottle", &#13;
  price = 3, inventory = 100L, volume = -2) &#13;
</pre><p>Just like we defined a validation function for <code class="literal">Product</code>, we can define another for <code class="literal">Container</code>:</p><pre class="programlisting">validate_container &lt;- function(object) { &#13;
  errors &lt;- c( &#13;
    if (length(object@volume) != 1) &#13;
      "Length of volume must be 1", &#13;
    if (object@volume &lt;= 0) &#13;
      "volume must be positive" &#13;
  ) &#13;
  if (length(errors) == 0) TRUE else errors &#13;
} &#13;
</pre><p>Then, we will redefine <code class="literal">Container</code> with this validation function:</p><pre class="programlisting">setClass("Container",  &#13;
  representation(volume = "numeric"),  &#13;
  contains = "Product", &#13;
  validity = validate_container) &#13;
</pre><p>Note that we don't need to call <code class="literal">validate_product</code> in <code class="literal">validate_container</code> because both validation functions will be called in turn to make sure all classes in the inheritance chain are properly checked with their validation functions. You may add some text-printing code to the validating functions to confirm that <code class="literal">validate_product</code> is always called before <code class="literal">validate_container</code> when we create an instance of <code class="literal">Container</code>:</p><pre class="programlisting">bottle &lt;- new("Container", name = "Bottle", &#13;
  price = 3, inventory = 100L, volume = -2) &#13;
## Error in validObject(.Object): invalid class "Container" object: volume must be positive &#13;
bottle &lt;- new("Container", name = "Bottle", &#13;
  price = 3, inventory = -5L, volume = 10) &#13;
## Error in validObject(.Object): invalid class "Container" object: inventory must be non-negative &#13;
</pre></div><div class="section" title="Defining S4 generic functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec128"/>Defining S4 generic functions</h2></div></div></div><p>In the previous examples, we saw that S4 is much more formal than S3 because the S4 class requires a class definition. Likewise, S4 generic functions are more formal too.</p><p>Here is an example where we define a series of S4 classes with a simple hierarchy of inheritance relationships. The example is about shapes. First, <code class="literal">Shape</code> is a root class. Both <code class="literal">Polygon</code> and <code class="literal">Circle</code> inherit from <code class="literal">Shape</code>, while <code class="literal">Triangle</code> and <code class="literal">Rectangle</code> inherit from <code class="literal">Polygon</code>. The inheritance structure of these shapes is illustrated here:</p><div class="mediaobject"><img src="graphics/image_10_005.jpg" alt="Defining S4 generic functions"/></div><p>Each class except <code class="literal">Shape</code> has some necessary slots to describe itself:</p><pre class="programlisting">setClass("Shape") &#13;
setClass("Polygon",  &#13;
  representation(sides = "integer"),  &#13;
  contains = "Shape") &#13;
setClass("Triangle",  &#13;
  representation(a = "numeric", b = "numeric", c = "numeric"),  &#13;
  prototype(a = 1, b = 1, c = 1, sides = 3L), &#13;
  contains = "Polygon") &#13;
setClass("Rectangle", &#13;
  representation(a = "numeric", b = "numeric"), &#13;
  prototype(a = 1, b = 1, sides = 4L), &#13;
  contains = "Polygon") &#13;
setClass("Circle", &#13;
  representation(r = "numeric"), &#13;
  prototype(r = 1, sides = Inf), &#13;
  contains = "Shape") &#13;
</pre><p>With these classes defined, we can set up a generic function to calculate the area of a <code class="literal">Shape</code> object. To do this, we need to call <code class="literal">setGeneric()</code> upon <code class="literal">area</code> and supply a function that calls <code class="literal">standardGeneric("area")</code> to make <code class="literal">area</code> a generic function and ready for S4 method dispatch. The <code class="literal">valueClass</code> is used to ensure that the return value of each method must be of class <code class="literal">numeric</code>:</p><pre class="programlisting">setGeneric("area", function(object) { &#13;
  standardGeneric("area") &#13;
}, valueClass = "numeric") &#13;
## [1] "area" &#13;
</pre><p>Once the generic function is set up, we go on to implement different methods for different kinds of shapes. For <code class="literal">Triangle</code>, we use Heron's formula (<a class="ulink" href="https://en.wikipedia.org/wiki/Heron's_formula">https://en.wikipedia.org/wiki/Heron's_formula</a>) to calculate its area, given the lengths of the three sides:</p><pre class="programlisting">setMethod("area", signature("Triangle"), function(object) { &#13;
  a &lt;- object@a &#13;
  b &lt;- object@b &#13;
  c &lt;- object@c &#13;
  s &lt;- (a + b + c) / 2 &#13;
  sqrt(s * (s - a) * (s - b) * (s - c)) &#13;
}) &#13;
## [1] "area" &#13;
</pre><p>For <code class="literal">Rectangle</code> and <code class="literal">Circle</code>, it is easy to write out the area formula for each of them:</p><pre class="programlisting">setMethod("area", signature("Rectangle"), function(object) { &#13;
  object@a * object@b &#13;
}) &#13;
## [1] "area" &#13;
setMethod("area", signature("Circle"), function(object) { &#13;
  pi * object@r ^ 2 &#13;
}) &#13;
## [1] "area" &#13;
</pre><p>Now, we can create an instance of <code class="literal">Triangle</code> and see whether <code class="literal">area()</code> dispatches to the correct method and returns the correct answer:</p><pre class="programlisting">triangle &lt;- new("Triangle", a = 3, b = 4, c = 5) &#13;
area(triangle) &#13;
## [1] 6 &#13;
</pre><p>We also create an instance of <code class="literal">Circle</code> and see whether method dispatch works:</p><pre class="programlisting">circle &lt;- new("Circle", r = 3) &#13;
area(circle) &#13;
## [1] 28.27433 &#13;
</pre><p>Both answers are correct. The <code class="literal">area()</code> function just works like an S3 generic function that performs method dispatch according to the class of the input object.</p></div><div class="section" title="Understanding multiple dispatch"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec129"/>Understanding multiple dispatch</h2></div></div></div><p>An S4 generic function is more flexible because it also supports multiple dispatch, that is, it can perform method dispatch according to the classes of multiple arguments.</p><p>Here, we will define another family of S4 classes: <code class="literal">Object</code> with a numeric <code class="literal">height</code>. Both <code class="literal">Cylinder</code> and <code class="literal">Cone</code> inherit from <code class="literal">Object</code>. Later, we will use multiple dispatch to calculate the volume of a certain type of geometric object with a certain shape of the bottom surface:</p><pre class="programlisting">setClass("Object", representation(height = "numeric")) &#13;
setClass("Cylinder", contains = "Object") &#13;
setClass("Cone", contains = "Object") &#13;
</pre><p>Now, we will define a new generic function named <code class="literal">volume</code>. As its name suggests, this function is used to calculate the volume of an object that is described by the shape of the bottom surface and the form of the object:</p><pre class="programlisting">setGeneric("volume",  &#13;
  function(shape, object) standardGeneric("volume")) &#13;
## [1] "volume" &#13;
</pre><p>In the following code, we will implement two cases: one is for a rectangle-shaped cylinder and the other is for a rectangle-shaped cone:</p><pre class="programlisting">setMethod("volume", signature("Rectangle", "Cylinder"),  &#13;
  function(shape, object) { &#13;
    shape@a * shape@b * object@height &#13;
  }) &#13;
## [1] "volume" &#13;
setMethod("volume", signature("Rectangle", "Cone"), &#13;
  function(shape, object) { &#13;
    shape@a * shape@b * object@height / 3 &#13;
  }) &#13;
## [1] "volume" &#13;
</pre><p>Note that all existing methods for <code class="literal">volume</code> require two arguments. Therefore, the method dispatch happens with both arguments, that is, it requires the classes of both input objects to match to choose the correct method. Now, we will test <code class="literal">volume</code> with an instance of <code class="literal">Rectagle</code> and an instance of <code class="literal">Cylinder</code>:</p><pre class="programlisting">rectangle &lt;- new("Rectangle", a = 2, b = 3) &#13;
cylinder &lt;- new("Cylinder", height = 3) &#13;
volume(rectangle, cylinder) &#13;
## [1] 18 &#13;
</pre><p>Since a relationship holds for a cylinder and a cone with the same height and the shape of bottom surface, the volume of the cylinder is three times that of the cone. To simplify the implementation of <code class="literal">volume</code> methods, we can directly put <code class="literal">Shape</code> in the method signature and call <code class="literal">area()</code> of the shape and directly use its area in the calculation:</p><pre class="programlisting">setMethod("volume", signature("Shape", "Cylinder"),  &#13;
  function(shape, object) { &#13;
    area(shape) * object@height &#13;
  }) &#13;
## [1] "volume" &#13;
setMethod("volume", signature("Shape", "Cone"), &#13;
  function(shape, object) { &#13;
    area(shape) * object@height / 3 &#13;
  }) &#13;
## [1] "volume" &#13;
</pre><p>Now, <code class="literal">volume</code> is automatically applicable to <code class="literal">Circle</code>:</p><pre class="programlisting">circle &lt;- new("Circle", r = 2) &#13;
cone &lt;- new("Cone", height = 3) &#13;
volume(circle, cone) &#13;
## [1] 12.56637 &#13;
</pre><p>To make <code class="literal">volume</code> easier to use, we can also define a method that takes an instance of <code class="literal">Shape</code> and a numeric value as the height of the cylinder:</p><pre class="programlisting">setMethod("volume", signature("Shape", "numeric"), &#13;
  function(shape, object) { &#13;
    area(shape) * object &#13;
  }) &#13;
## [1] "volume" &#13;
</pre><p>Then, we can directly use numeric values in calculating the volume of the cylinder given its shape and height:</p><pre class="programlisting">volume(rectangle, 3) &#13;
## [1] 18 &#13;
</pre><p>Furthermore, we can simplify the notation by implementing a method of <code class="literal">*</code>:</p><pre class="programlisting">setMethod("*", signature("Shape", "Object"),  &#13;
  function(e1, e2) { &#13;
    volume(e1, e2) &#13;
  }) &#13;
## [1] "*" &#13;
</pre><p>Now, we can calculate the volume by simply multiplying the shape and the object form:</p><pre class="programlisting">rectangle * cone &#13;
## [1] 6 &#13;
</pre><p>Note that an S4 object is not a list or environment, but it has copy-on-modify semantics. In this sense, when the value of a slot of an S4 object is modified by <code class="literal">&lt;-</code> in a function, it behaves more like a list, that is, the S4 object is copied in the function and the original object is not modified.</p><p>For example, in the following code, we will define a function that tries to lengthen <code class="literal">Object</code> by multiplying its height with a numeric factor:</p><pre class="programlisting">lengthen &lt;- function(object, factor) { &#13;
  object@height &lt;- object@height * factor &#13;
  object &#13;
} &#13;
</pre><p>When we apply this function on <code class="literal">cylinder</code>, which we previously created, its height is not changed at all. Instead, it is copied inside the function:</p><pre class="programlisting">cylinder &#13;
## An object of class "Cylinder" &#13;
## Slot "height": &#13;
## [1] 3 &#13;
lengthen(cylinder, 2) &#13;
## An object of class "Cylinder" &#13;
## Slot "height": &#13;
## [1] 6 &#13;
cylinder &#13;
## An object of class "Cylinder" &#13;
## Slot "height": &#13;
## [1] 3 &#13;
</pre></div></div>
<div class="section" title="Working with the reference class"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec55"/>Working with the reference class</h1></div></div></div><p>There is also a class system that has reference semantics. It is more like the class system in other object-oriented programming languages.</p><p>First, to define a reference class (<span class="strong"><strong>RC</strong></span>), we supply a class definition to <code class="literal">setRefClass()</code>. Unlike the S4 class system where we use <code class="literal">new()</code> to create an instance, <code class="literal">setRefClass()</code> returns an instance generator. For example, we define a class named <code class="literal">Vehicle</code>, which has two fields: a numeric position and a numeric distance. We store the instance generator to a variable named <code class="literal">Vehicle</code>:</p><pre class="programlisting">Vehicle &lt;- setRefClass("Vehicle",  &#13;
  fields = list(position = "numeric", distance = "numeric")) &#13;
</pre><p>To create an instance, we use <code class="literal">Vehicle$new</code> to create new instances of the <code class="literal">Vehicle</code> class:</p><pre class="programlisting">car &lt;- Vehicle$new(position = 0, distance = 0) &#13;
</pre><p>Unlike S4, the fields of RC are not slots, so we can use <code class="literal">$</code> to access them:</p><pre class="programlisting">car$position &#13;
## [1] 0 &#13;
</pre><p>Each instance we create with <code class="literal">Vehicle$new</code> is an object of reference semantics. It behaves like a combination of S4 object and environment.</p><p>In the following code, we will create a function that modifies the fields in a <code class="literal">Vehicle</code> object. More specifically, we define <code class="literal">move</code> that modifies <code class="literal">position</code> in relative terms, and all movements are accumulated to <code class="literal">distance</code>:</p><pre class="programlisting">move &lt;- function(vehicle, movement) { &#13;
  vehicle$position &lt;- vehicle$position + movement &#13;
  vehicle$distance &lt;- vehicle$distance + abs(movement) &#13;
} &#13;
</pre><p>Now, we will call <code class="literal">move</code> with <code class="literal">car</code>, and the instance we created is modified rather than copied:</p><pre class="programlisting">move(car, 10) &#13;
car &#13;
## Reference class object of class "Vehicle" &#13;
## Field "position": &#13;
## [1] 10 &#13;
## Field "distance": &#13;
## [1] 10 &#13;
</pre><p>Since RC itself is a class system more like ordinary object-oriented system, a better way to do this is to define its own methods of the class:</p><pre class="programlisting">Vehicle &lt;- setRefClass("Vehicle",  &#13;
  fields = list(position = "numeric", distance = "numeric"), &#13;
  methods = list(move = function(x) { &#13;
    stopifnot(is.numeric(x)) &#13;
    position &lt;&lt;- position + x &#13;
    distance &lt;&lt;- distance + abs(x) &#13;
  })) &#13;
</pre><p>Unlike S3 and S4 systems where methods are stored in the environment, RC directly include its methods. Therefore, we can directly call the method inside an instance. Note that to modify the value of a field in a method, we need to use <code class="literal">&lt;&lt;-</code> instead of <code class="literal">&lt;-</code>. The following code is a simple test to check whether the method works and whether the reference object is modified:</p><pre class="programlisting">bus &lt;- Vehicle(position = 0, distance = 0) &#13;
bus$move(5) &#13;
bus &#13;
## Reference class object of class "Vehicle" &#13;
## Field "position": &#13;
## [1] 5 &#13;
## Field "distance": &#13;
## [1] 5 &#13;
</pre><p>From the preceding examples, we can see that RC looks more like the objects in C++ and Java. For more detailed introduction, read <code class="literal">?ReferenceClasses</code>.</p></div>
<div class="section" title="Working with R6"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec56"/>Working with R6</h1></div></div></div><p>An enhanced version of RC is R6, a package that implements a more efficient reference class that supports public and private fields and methods, and some other powerful features.</p><p>Run the following code to install the package:</p><pre class="programlisting">install.packages("R6") &#13;
</pre><p>The R6 class allows us to define classes that are even more like popular object-oriented programming languages. The following code is an example where we define the <code class="literal">Vehicle</code> class. It has some public fields and methods for users and some private fields and methods for internal use:</p><pre class="programlisting">library(R6) &#13;
Vehicle &lt;- R6Class("Vehicle",  &#13;
  public = list( &#13;
    name = NA, &#13;
    model = NA, &#13;
    initialize = function(name, model) { &#13;
      if (!missing(name)) self$name &lt;- name &#13;
      if (!missing(model)) self$model &lt;- model &#13;
    }, &#13;
    move = function(movement) { &#13;
      private$start() &#13;
      private$position &lt;- private$position + movement &#13;
      private$stop() &#13;
    }, &#13;
    get_position = function() { &#13;
      private$position &#13;
    } &#13;
  ), &#13;
  private = list( &#13;
    position = 0, &#13;
    speed = 0, &#13;
    start = function() { &#13;
      cat(self$name, "is starting\n") &#13;
      private$speed &lt;- 50 &#13;
    }, &#13;
    stop = function() { &#13;
      cat(self$name, "is stopping\n") &#13;
      private$speed &lt;- 0 &#13;
    } &#13;
  )) &#13;
</pre><p>From the user side, we can only access the public fields and methods. Only the class methods have access to the private fields and methods. Although the vehicle has a position, we don't want the user to modify its value. Therefore, we put it in the private part and expose its value through <code class="literal">get_position()</code> so that it is hard for users to modify the position from outside:</p><pre class="programlisting">car &lt;- Vehicle$new(name = "Car", model = "A") &#13;
car &#13;
## &lt;Vehicle&gt; &#13;
##   Public: &#13;
##     clone: function (deep = FALSE)  &#13;
##     get_position: function ()  &#13;
##     initialize: function (name, model)  &#13;
##     model: A &#13;
##     move: function (movement)  &#13;
##     name: Car &#13;
##   Private: &#13;
##     position: 0 &#13;
##     speed: 0 &#13;
##     start: function ()  &#13;
##     stop: function () &#13;
</pre><p>When <code class="literal">car</code> is printed, all public and private fields and methods are displayed. Then, we will call the <code class="literal">move()</code> method, and we can find the position is changed with <code class="literal">get_position()</code>:</p><pre class="programlisting">car$move(10) &#13;
## Car is starting &#13;
## Car is stopping &#13;
car$get_position() &#13;
## [1] 10 &#13;
</pre><p>To demonstrate the inheritance of R6 class, we define a new class named <code class="literal">MeteredVehicle</code> that records the sum of distance it moves in history. To define the class, we need to add a private field <code class="literal">distance</code>, a public override of <code class="literal">move</code> that first calls <code class="literal">super$move()</code> to move the vehicle to get the right position and then accumulates the distance resulted from the movement in absolute terms:</p><pre class="programlisting">MeteredVehicle &lt;- R6Class("MeteredVehicle", &#13;
  inherit = Vehicle, &#13;
  public = list( &#13;
    move = function(movement) { &#13;
      super$move(movement) &#13;
      private$distance &lt;&lt;- private$distance + abs(movement) &#13;
    }, &#13;
    get_distance = function() { &#13;
      private$distance &#13;
    } &#13;
  ), &#13;
  private = list( &#13;
    distance = 0 &#13;
  )) &#13;
</pre><p>Now, we can do some experiments with <code class="literal">MeteredVehicle</code>. In the following code, we will create a <code class="literal">bus</code>:</p><pre class="programlisting">bus &lt;- MeteredVehicle$new(name = "Bus", model = "B") &#13;
bus &#13;
## &lt;MeteredVehicle&gt; &#13;
##   Inherits from: &lt;Vehicle&gt; &#13;
##   Public: &#13;
##     clone: function (deep = FALSE)  &#13;
##     get_distance: function ()  &#13;
##     get_position: function ()  &#13;
##     initialize: function (name, model)  &#13;
##     model: B &#13;
##     move: function (movement)  &#13;
##     name: Bus &#13;
##   Private: &#13;
##     distance: 0 &#13;
##     position: 0 &#13;
##     speed: 0 &#13;
##     start: function ()  &#13;
##     stop: function () &#13;
</pre><p>First, let <code class="literal">bus</code> move <code class="literal">10</code> units forward, and then, the position is changed and the distance is accumulated:</p><pre class="programlisting">bus$move(10) &#13;
## Bus is starting &#13;
## Bus is stopping &#13;
bus$get_position() &#13;
## [1] 10 &#13;
bus$get_distance() &#13;
## [1] 10 &#13;
</pre><p>Then, let <code class="literal">bus</code> move <code class="literal">5</code> units backward. The position is closer to the origin, while the distance that sums up all movements becomes greater:</p><pre class="programlisting">bus$move(-5) &#13;
## Bus is starting &#13;
## Bus is stopping &#13;
bus$get_position() &#13;
## [1] 5 &#13;
bus$get_distance() &#13;
## [1] 15 &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note5"/>Note</h3><p>R6 also supports some other powerful features. For more details, read its vignettes at <a class="ulink" href="https://cran.r-project.org/web/packages/R6/vignettes/Introduction.html">https://cran.r-project.org/web/packages/R6/vignettes/Introduction.html</a>.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec57"/>Summary</h1></div></div></div><p>In this chapter, you learned the basic concepts of object-oriented programming: class and methods and how they are connected by generic functions in R through method dispatch. You learned how to create S3, S4, RC, and R6 classes and methods. These systems share similar ideas but are distinct in implementation and usage. Hadley Wickham gives some nice suggestions in picking a system (<a class="ulink" href="http://adv-r.had.co.nz/OO-essentials.html#picking-a-system">http://adv-r.had.co.nz/OO-essentials.html#picking-a-system</a>).</p><p>After getting familiar with R's most important features, we will discuss more practical topics in the subsequent chapters. In the next chapter, you will learn about the packages and techniques used to access popular databases. You will gain necessary knowledge and techniques to connect R to relational databases such as SQLite and MySQL as well as the upcoming non-relational databases such as MongoDB and Redis.</p></div></body></html>