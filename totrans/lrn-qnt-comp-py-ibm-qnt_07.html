<html><head></head><body><div><div><div><h1 class="chapterNumber">7</h1>
    <h1 id="_idParaDest-118" class="chapterTitle">Programming with Qiskit</h1>
    <p class="normal"><strong class="keyWord">Qiskit</strong> has <a id="_idIndexMarker810"/>various libraries that link between the core hardware of a quantum system and the tools necessary to create quantum circuits, both transcend upward through the code stack. It is, therefore, the foundation used to create quantum circuits, as well as generating and scheduling pulses from the circuits onto the hardware devices. Other features, such as optimizers and transpilers, are used to ensure the circuits are optimal to reduce decoherence and improve performance. In this chapter, we will explore all the key features available in Qiskit to help you create your own circuits, optimizers, and pulse schedules.</p>
    <p class="normal">The following topics will be covered in this chapter:</p>
    <ul>
      <li class="bulletList">Understanding quantum circuits</li>
      <li class="bulletList">Generating pulse schedules on hardware</li>
      <li class="bulletList">Understanding the Job component</li>
    </ul>
    <p class="normal">Qiskit has so many features and enhancements that it would take an entire book to write about them all. To cover as many of them as possible, we will create a quantum circuit and walk you through the various features. After reading this chapter, you will be able to understand how to create quantum circuits from basic to customized circuits with user-defined labels to help contextualize your circuit. You’ll also get an understanding of the Job component, which is used to run your circuit on a quantum system.</p>
    <p class="normal">We’ll even delve into the hardware to schedule a pulse operation on a qubit to better understand how the circuit is translated from digital to analog signals to perform an operation on a qubit(s), followed by reading the information from the qubit and converting the signal back from analog to digital.</p>
    <p class="normal">Sound exciting? Great! Let’s get to it!</p>
    <h1 id="_idParaDest-119" class="heading-1">Technical requirements</h1>
    <p class="normal">In this chapter, it is expected that you are familiar with the basics of quantum circuits described in previous chapters, such as creating and executing quantum circuits, visualizing circuit diagrams, and knowledge of qubit logic gates. </p>
    <p class="normal">Here is the source code used throughout this book: <a href="https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition">https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition</a>.</p>
    <h1 id="_idParaDest-120" class="heading-1">Customizing and optimizing quantum circuits</h1>
    <p class="normal">In previous chapters, you<a id="_idIndexMarker811"/> had some exposure to quantum circuit operations to understand some of the basic quantum components. These basic operations included creating a quantum circuit, applying quantum gates to the circuit, and executing the circuit on a simulator.</p>
    <p class="normal">We will <a id="_idIndexMarker812"/>now take a deeper look into quantum circuits to better understand what properties and functionalities are available to us to not just execute these circuits on a real device but to do so as optimally as possible. In this section, we will learn how to extract circuit properties, such as circuit depth, width, and size, and obtain the number of actual operators. Let’s first start by reviewing the various forms of creating a quantum circuit.</p>
    <h2 id="_idParaDest-121" class="heading-2">Components of a quantum circuit</h2>
    <p class="normal">Qiskit provides<a id="_idIndexMarker813"/> various ways to create a quantum circuit, each depending on how much information you need throughout your circuit. Up to this point, we have been creating circuits using a single constructor that automatically creates the circuit registers needed. In this form, the arguments indicate the number of qubits and bits of both the quantum and classical registers, respectively:</p>
    <pre class="programlisting code"><code class="hljs-code"># Load helper file
%run helper_file_1.0.ipynb
qc = QuantumCircuit(2,2)
</code></pre>
    <p class="normal">In this section, we will describe other ways to create a circuit and discuss the advantage of using one form or the other.</p>
    <p class="normal">Another way to construct a <code class="inlineCode">QuantumCircuit</code> class is to create the quantum and classical registers independently of the quantum circuit constructor. Here, we will first create the quantum and classical registers, each with two qubits and two bits, respectively, and then draw the<a id="_idIndexMarker814"/> circuit. The constructor allows us to customize the label of our registers, which we were not able to do in the previous form:</p>
    <pre class="programlisting code"><code class="hljs-code"># Import registers
from qiskit import QuantumRegister, ClassicalRegister
qr = QuantumRegister(2, 'my_QR')
cr = ClassicalRegister(2, 'my_CR')
qc = QuantumCircuit(qr,cr)
qc.draw(output='mpl')
</code></pre>
    <p class="normal">From the preceding code, note that the second argument: that is, the <code class="inlineCode">name</code> attribute: of the register constructors allows us to add a label to each register, as in the following screenshot:</p>
    <figure class="mediaobject"><img src="img/B18420_07_01.png" alt="Diagram  Description automatically generated with medium confidence" width="192" height="183"/></figure>
    <p class="packt_figref">Figure 7.1: Customized quantum and classical register labels</p>
    <p class="normal">Customizing the labels of our registers simplifies reading our circuits, particularly as the circuits become more complex when having multiple registers performing different processes. You may want to have one register created with a fixed number of qubits and another dynamic register where defining the number of qubits would vary based on some preprocessed step. You’ll see the value of this when we create composites later in this chapter.</p>
    <p class="normal">Of course, you can also combine creating the registers and the circuit constructor all in one line if needed:</p>
    <pre class="programlisting gen"><code class="hljs">qc = QuantumCircuit(QuantumRegister(2, 'my_QR'), ClassicalRegister(2, 'my_CR'))
</code></pre>
    <p class="normal">Let’s assume now that you have two quantum circuits and you want to concatenate them together. The following example will illustrate how to concatenate two circuits into one without <a id="_idIndexMarker815"/>having to explicitly recreate one based on the two existing quantum circuits:</p>
    <ol>
      <li class="numberedList" value="1">In the following code, we will create the first circuit and include labels on both the quantum and classical registers so that we can monitor that they are, in fact, combined:
        <pre class="programlisting code-one"><code class="hljs-code">#Create the quantum and classical registers, each with 
#labels
qr1 = QuantumRegister(2, name='qr1')
cr1 = ClassicalRegister(2, name='cr1')
#Create the quantum circuit using the registers
qc1 = QuantumCircuit(qr1, cr1)
#Draw the circuit
qc1.draw(output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The following screenshot shows what should be displayed after running the previous code:</p>
    <figure class="mediaobject"><img src="img/B18420_07_02.png" alt="Calendar  Description automatically generated with low confidence" width="157" height="151"/></figure>
    <p class="packt_figref">Figure 7.2: The first of the two quantum circuits we will join</p>
    <ol>
      <li class="numberedList" value="2">Next, we will create a second circuit, which is very similar to the first one, only we will update the labels to identify it as the second:
        <pre class="programlisting code-one"><code class="hljs-code">#Create two Quantum and Classical registers
qr2 = QuantumRegister(2, name='qr2')
cr2 = ClassicalRegister(2, name='cr2')
#Create a second circuit using the registers created 
#above
qc2 = QuantumCircuit(qr2, cr2)
#Draw the second quantum circuit
qc2.draw(output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The results of the code should be no surprise: that it is the same as the first one only with the labels updated as expected:</p>
    <figure class="mediaobject"><img src="img/B18420_07_03.png" alt="Figure 8.4 – The second of the two quantum circuits we will join " width="151" height="152"/></figure>
    <p class="packt_figref">Figure 7.3: The second of the two quantum circuits we will join</p>
    <ol>
      <li class="numberedList" value="3">Now, let’s <a id="_idIndexMarker816"/>finish up by combining one circuit with the other, which is to say we will widen the circuit from 2 to 4 qubits. To do this, we will use the <code style="font-weight: bold;" class="codeHighlighted">add_register</code> function, which combines the quantum and classical registers into a single circuit. Here, we will combine circuits <code style="font-weight: bold;" class="codeHighlighted">qc2</code> and <code style="font-weight: bold;" class="codeHighlighted">qc1</code> into a new circuit titled <code style="font-weight: bold;" class="codeHighlighted">qc_combined</code>, and then draw the results:
        <pre class="programlisting code-one"><code class="hljs-code">#Concatenate the two previous circuits to create a new #circuit
#Create an empty quantum circuit
qc_combined = QuantumCircuit()
#Add the two previous quantum and classical 
#registers to the empty quantum circuit
qc_combined.add_register(qr1, qr2, cr1, cr2)
#Draw the concatenated circuit
qc_combined.draw(output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">As you can see in the following screenshot, the results are now a combination of the two previous quantum circuits into a new circuit, by combining the registers:</p>
    <figure class="mediaobject"><img src="img/B18420_07_04.png" alt="Figure 8.5 – Concatenation of two quantum circuits " width="162" height="339"/></figure>
    <p class="packt_figref">Figure 7.4: Concatenation of two quantum circuits</p>
    <p class="normal">We originally <a id="_idIndexMarker817"/>created two individual quantum circuits, each with two quantum registers and two classical registers. We then concatenated them to create a quantum circuit with four quantum and classical circuits. The order of the quantum circuits is based on the order in which they were concatenated. As an extra exercise, repeat the previous concatenation code and switch the order to confirm or create more quantum circuits and add more circuits together.</p>
    <p class="normal">One last circuit creation object I would like to share is the random circuit generator, which, as the name suggests, will generate a random circuit for you. Having the ability to create a random circuit could help you to create test circuits or examples given a set of parameters, such as circuit width and depth. As the following code block indicates, the <code class="inlineCode">random_circuit</code> object requires two parameters. They are the number of qubits you want the random circuit to contain and the depth of the circuit, respectively: where depth indicates the number of standard gates, selected from the Qiskit circuit extensions listed in the API documentation, to add randomly per qubit. You can also indicate whether you want the circuit to include measurement operators:</p>
    <pre class="programlisting code"><code class="hljs-code">#Import the random_circuit class
from qiskit.circuit.random import random_circuit
#Construct the random circuit with the number of qubits = 3
#with a depth = 2, and include the measurement operator for 
#each qubit
qc = random_circuit(3, 2, measure=True)
#Draw the circuit
qc.draw(output='mpl')
</code></pre>
    <p class="normal">The results from<a id="_idIndexMarker818"/> the random circuit will vary, of course, each time you execute it, as it should. What will not vary are the parameter options, particularly the number of qubits and the depth count. In this case, your results should have a circuit that contains three qubits and a depth of two operators. The following random circuit is the result of running the preceding code. Note that the measurement operator is not included in the depth count:</p>
    <figure class="mediaobject"><img src="img/B18420_07_05.png" alt="Figure 8.6 – Random circuit generated with number of qubits = 3 and depth = 2  " width="490" height="263"/></figure>
    <p class="packt_figref">Figure 7.5: Random circuit generated with number of qubits = 3 and depth = 2</p>
    <p class="normal">Now that you are familiar with the various ways to generate quantum circuits, we will continue and see what properties we can extract from the circuits created. These properties could be used to analyze the generated circuit and ensure it is optimized by leveraging some optimization features available to us in Qiskit.</p>
    <h2 id="_idParaDest-122" class="heading-2">Obtaining circuit properties and analysis</h2>
    <p class="normal">Constructing circuits <a id="_idIndexMarker819"/>could get very complex once you start building them out, particularly if you create composites of gates and combine them to form larger gates. You’re going to want to get some information about your circuit along the way should you need to analyze your results.</p>
    <p class="normal">The good thing for us is that Qiskit has taken care of some of this by making a lot of these properties available to us. Let’s start with some basic properties. Let’s say we want to know how many qubits we have in our circuit. As we learned in the previous section, we know that we can concatenate two or more circuits together. As we add more circuits together, it becomes difficult, or tedious, to determine the number of qubits and gates that our concatenated circuit will have. It’s here that the width, depth, and operator count functions come in handy.</p>
    <p class="normal">In the following code, we <a id="_idIndexMarker820"/>will create two two-qubit random circuits, each with different gate counts. We will then append one circuit to another and use our circuit property functions to help us get the total width, depth, and operator count. All circuits that we append will need to have the same number of qubits using this method:</p>
    <pre class="programlisting code"><code class="hljs-code">#Import the random circuit class
from qiskit.circuit.random import random_circuit
#Create two random circuits, each with 2 qubit registers and 
#random gate operator counts.
qc1 = random_circuit(2,2)
qc2 = random_circuit(2,4)
#Concatenate the two random circuits into one
qc = qc1.compose(qc2, [0,1])
#Draw the circuit
qc.draw(output='mpl')
</code></pre>
    <p class="normal">The result should be a two-qubit circuit with a random set of gate operators with a total depth of 6. We know this because we created them and can see the values from the <code class="inlineCode">random_circuit</code> constructor:</p>
    <figure class="mediaobject"><img src="img/B18420_07_06.png" alt="" width="748" height="157"/></figure>
    <p class="packt_figref">Figure 7.6: Randomly generated two-qubit circuits with a depth of 6</p>
    <p class="normal">Now, let’s use our circuit property functions to get the width, depth, size, and operator count of our circuit. To simplify this, we will create a helper function that will print out the circuit properties of the quantum circuit we will pass in as an argument:</p>
    <pre class="programlisting code"><code class="hljs-code">#Define function to print circuit properties:
def print_circuit_props(qc):
    width = qc.width()
    depth = qc.depth()
    num_operators = qc.count_ops()
    circuit_size = qc.size()
    print('Width = ', width)
    print('Depth = ', depth)
    print('Circuit size = ', circuit_size)
    print('Number of operators = ', num_operators)
</code></pre>
    <p class="normal">Now, we<a id="_idIndexMarker821"/> can run our circuit through our helper function, which will print out all the properties we need:</p>
    <pre class="programlisting code"><code class="hljs-code">#Pass our quantum circuit to print out the circuit properties
print_circuit_props(qc)
</code></pre>
    <p class="normal">Our results should have the same value for <code class="inlineCode">Width</code> and <code class="inlineCode">Depth</code>. However, since we are using random circuits, our circuit size and the number of operators will be different as they are based on the randomly chosen gates. However, by observing the circuit, you will see that the result values of <code class="inlineCode">size()</code> and <code class="inlineCode">count_ops()</code> are the same. The difference between the two is that the circuit size returns the total number of gates in the circuit, while the operator count lists the name of each gate type and the total number of each gate type in the circuit:</p>
    <pre class="programlisting code"><code class="hljs-code">Width =  2
Depth =  6
Circuit size =  7
Number of operators =  OrderedDict([('cu3', 2), ('z', 1), ('tdg', 1), ('crz', 1), ('cz', 1), ('ch', 1)])
</code></pre>
    <p class="normal">Now, let’s try adding some classic registers, measurements, and barriers to see what we get back. We can use a shortcut to include measurement operators by using <code class="inlineCode">measure_all()</code>, which will append a barrier, a measurement for each qubit, and the classical registers to match the number of qubits in the quantum register of our circuit:</p>
    <pre class="programlisting code"><code class="hljs-code">#Use measure_all() to automatically add the barrier, 
#measurement, and classical register to our existing circuit.
qc.measure_all()
#Draw the circuit
qc.draw(output='mpl')
</code></pre>
    <p class="normal">The result now includes the classical components needed to measure and read out our qubits. These include the two-bit classical registers labeled as <code class="inlineCode">measure</code>, a barrier separating the <a id="_idIndexMarker822"/>quantum gates from the measurement operators, and the measurement operators, as illustrated in the following screenshot:</p>
    <figure class="mediaobject"><img src="img/B18420_07_07.png" alt="A screenshot of a computer  Description automatically generated with low confidence" width="822" height="198"/></figure>
    <p class="packt_figref">Figure 7.7: Random circuit with classical components added</p>
    <p class="normal">Let’s now print our circuit property functions to see an updated count:</p>
    <pre class="programlisting code"><code class="hljs-code">#Print out the circuit properties
print_circuit_props(qc)
</code></pre>
    <p class="normal">The results show what we generally would expect. The <code class="inlineCode">W</code><code class="inlineCode">idth</code> count increased by 2, due to the addition of the two-bit classical register. The <code class="inlineCode">Depth</code> count increased by 1 due to the addition of the barrier. Note that the measurement operator is not included in the size or operator count, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">Width =  4
Depth =  7
Circuit size =  9
Number of operators =  OrderedDict([('cu3', 2), ('measure', 2), ('z', 1), ('tdg', 1), ('crz', 1), ('cz', 1), ('ch', 1), ('barrier', 1)])
</code></pre>
    <p class="normal">Before moving on to the next section, let’s look at an interesting caveat to our circuit property functions. Most gates are created from basis gates that are specific to the quantum computers used. For most quantum systems, there are a set of basis gates used to create other gates.</p>
    <p class="normal">However, some gates, such as the <strong class="keyWord">Toffoli</strong> and <strong class="keyWord">Swap</strong> gates, not only require more than a single qubit but are also composed of several basis gates. Let’s look at the Toffoli gate as an example:</p>
    <ol>
      <li class="numberedList" value="1">We will create a quantum circuit with 3 qubits and add only a Toffoli gate to it, as shown here:
        <pre class="programlisting code-one"><code class="hljs-code">qc = QuantumCircuit(3)
qc.ccx(0,1,2)
qc.draw(output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">Here, we see the Toffoli gate as expected, with the 0 and 1 source qubits entangled, with qubit 2 as the target:</p>
    <figure class="mediaobject"><img src="img/B18420_07_08.png" alt="Figure 8.9 – The Toffoli gate on a quantum circuit " width="183" height="162"/></figure>
    <p class="packt_figref">Figure 7.8: The Toffoli gate on a quantum circuit</p>
    <ol>
      <li class="numberedList" value="2">We print<a id="_idIndexMarker823"/> out our circuit properties of the quantum circuit with the Toffoli gate:
        <pre class="programlisting code-one"><code class="hljs-code">#Print out the circuit properties
print_circuit_props(qc)
</code></pre>
      </li>
    </ol>
    <p class="normal-one">As we can see, the results are not surprising in that the values are not surprising either: a three-qubit gate with a width of <code class="inlineCode">3</code> and a depth of <code class="inlineCode">1</code>:</p>
    <pre class="programlisting code-one"><code class="hljs-code">Width = 3
Depth = 1
Circuit size = 1
Number of operators = OrderedDict([('ccx', 1)])
</code></pre>
    <ol>
      <li class="numberedList" value="3">Now, let’s print our circuit property, only this time, let’s decompose our quantum circuit to see the results. As you will recall, when we invoke the <code class="inlineCode">decompose()</code> function on our quantum circuit, we are requesting the circuit to be decomposed down to its basis gates used to create the gates in our circuit. In this case, we are referring to the basis gates that are used to create a Toffoli gate:
        <pre class="programlisting code-one"><code class="hljs-code">#Print out the circuit properties
print_circuit_props(qc.decompose())
</code></pre>
      </li>
    </ol>
    <p class="normal-one"><em class="italic">Notice the difference?</em> Quite surprising indeed! By observing the results, we see that the Toffoli gate requires 15 operators, which are made up of various gates, such as T, <img src="img/B18420_07_001.png" alt="" width="23" height="25"/><a id="_idIndexMarker824"/>, H, and CNOT:</p>
    <pre class="programlisting code-one"><code class="hljs-code">Width = 3
Depth = 11
Circuit size = 15
Number of operators = OrderedDict([('cx', 6), ('t', 4), ('tdg', 3), ('h', 2)])
</code></pre>
    <p class="normal-one">The<a id="_idIndexMarker825"/> reason why I wanted to mention this was to make you aware that some of the gates used are not basis gates but are rather composites of basis gates used to generate the functionality of the desired gate. This is good to know when analyzing your circuit with respect to qubit noise or decoherence.</p>
    <p class="normal">Try the same exercise, only this time try creating a two-qubit circuit with a Swap gate and see what results you get back.</p>
    <p class="normal">Now that you are familiar with the various forms of creating quantum circuits, let’s look at how we can reuse these circuits in a modular way that makes it easy to combine and comprehend them.</p>
    <h2 id="_idParaDest-123" class="heading-2">Customizing and parameterizing circuit libraries</h2>
    <p class="normal">There are times<a id="_idIndexMarker826"/> when you are going to want to reuse a circuit on multiple occasions. To simplify this, you can create a composite of <a id="_idIndexMarker827"/>operators and reuse them throughout your circuit. This not only simplifies creating the circuit from modules but also makes it very easy for others to understand what your circuit is doing in those composites. Qiskit creates these compositions based on the instruction sets or quantum circuits.</p>
    <p class="normal">In the following steps, we are going to create a composite gate that is made up of multiple qubits and gates:</p>
    <ol>
      <li class="numberedList" value="1">First, we create a two-qubit quantum circuit, give it a name, and convert it into a generic quantum instruction:
        <pre class="programlisting code-one"><code class="hljs-code">#Create a custom two-qubit composite gate
#Create the quantum register
qr = QuantumRegister(2, name='qr_c')
#Generate quantum circuit which will make up the 
#composite gate
comp_qc = QuantumCircuit(qr, name='My-composite')
#Add any gates you wish to your composite gate
comp_qc.h(0)
comp_qc.cx(0, 1)
#Create the composite instructions by converting
#the QuantumCircuit to a list of Instructions
composite_inst = comp_qc.to_instruction()
#Draw the circuit which will represent the composite gate
comp_qc.draw(output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The <a id="_idIndexMarker828"/>preceding code will<a id="_idIndexMarker829"/> create the following two-qubit circuit, which we will use as our composite gate:</p>
    <figure class="mediaobject"><img src="img/B18420_07_09.png" alt="" width="277" height="141"/></figure>
    <p class="packt_figref">Figure 7.9: The quantum circuit that will represent the composite gate</p>
    <ol>
      <li class="numberedList" value="2">Now, let’s create a quantum circuit that will append the composite gate onto the circuit we created:
        <pre class="programlisting code-one"><code class="hljs-code">#Create your 2-qubit circuit to generate your composite gate
qr2 = QuantumRegister(3, 'qr')
#Create a quantum circuit using the quantum register
qc = QuantumCircuit(qr2)
#Add any arbitrary gates that would represent the function
#of the composite gate
qc.h(0)
qc.cx(0,1)
qc.cx(0,2)
#Draw the composite circuit
qc.draw(output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The preceding code will create the circuit, which we prepopulated with some gates before including our composite gate:</p>
    <figure class="mediaobject"><img src="img/B18420_07_10.png" alt="Figure 8.11 – The quantum circuit that we will append to the composite gate " width="297" height="168"/></figure>
    <p class="packt_figref">Figure 7.10: The quantum circuit that we will append to the composite gate</p>
    <ol>
      <li class="numberedList" value="3">Since <a id="_idIndexMarker830"/>our <a id="_idIndexMarker831"/>composite gate is made up of two qubits, we will need to indicate which of the three qubits to append our two-qubit composite gate to. For this example, we will append it to the first two qubits:
        <pre class="programlisting code-one"><code class="hljs-code">#Append your composite gate to the specified qubits.
qc.append(composite_inst, [qr2[0], qr2[1]])
#Draw the complete circuit
qc.draw(output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">As we can see from the results, our composite gate was successfully appended to the first and second qubits. It also includes the name of the composite gate, which makes it simple for anyone, including yourself, to read the circuit and understand what the composite gate is doing within the circuit:</p>
    <figure class="mediaobject"><img src="img/B18420_07_11.png" alt="A screenshot of a computer  Description automatically generated with low confidence" width="516" height="204"/></figure>
    <p class="packt_figref">Figure 7.11: The quantum circuit with a composite gate representation of a predefined circuit</p>
    <p class="normal-one">This <a id="_idIndexMarker832"/>makes reading your circuit much easier compared to how it would be if you were to just concatenate the two quantum circuits together.</p>
    <p class="normal-one">Of course, this<a id="_idIndexMarker833"/> is ideal if you have a circuit that would run as is. However, there may be times when you wish to perhaps control the amount of rotation of some of the gates in the composite gate you generated. This is where the parameterization of composite gates comes in handy. We will now create another composite gate, only this one will include the ability to add parameters to your composite gate so that it is more dynamic. This is commonly referred <a id="_idIndexMarker834"/>to as a <strong class="keyWord">Parameterized Quantum Circuit</strong> (<strong class="keyWord">PQC</strong>).</p>
    <ol>
      <li class="numberedList" value="4">To parameterize a gate, we will need to create a <code class="inlineCode">Parameter</code> class and set it to a rotation gate; in this example, we will apply the parameter to an R<sub class="subscript">Z</sub> gate:
        <pre class="programlisting code-one"><code class="hljs-code">#Import the Parameter object
from qiskit.circuit import Parameter
#Construct the Parameter set to Theta
param_theta = Parameter('Ө')
#Create a two-qubit quantum circuit and add some gates
qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
#Include a rotation gate which we wish to apply
#the Parameter value
qc.rz(param_theta, 0)
qc.rz(param_theta, 1)
#Draw the circuit
qc.draw(output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">Note <a id="_idIndexMarker835"/>that <a id="_idIndexMarker836"/>the parameter value is defined as <img src="img/B18420_06_162.png" alt="" width="10" height="25"/><a id="_idIndexMarker837"/>, but is not set as an explicit value. It just reserves the <code class="inlineCode">Parameter</code> value to later include a rotation value of <img src="img/B18420_06_162.png" alt="" width="10" height="25"/><a id="_idIndexMarker838"/>:</p>
    <figure class="mediaobject"><img src="img/B18420_07_12.png" alt="Figure 8.13 – Set the parameter of the Rz gate to  " width="341" height="132"/></figure>
    <p class="packt_figref">Figure 7.12: Set the parameter of the R<sub class="subscript">z</sub> gate to θ</p>
    <ol>
      <li class="numberedList" value="5">Let’s bind the <code class="inlineCode">Parameter</code> value of our gates to <img src="img/B18420_07_004.png" alt="" width="23" height="25"/><a id="_idIndexMarker839"/> and draw the circuit:
        <pre class="programlisting code-one"><code class="hljs-code">import numpy as np
#Bind the parameters with a value, in this case 2π
qc = qc.assign_parameters(parameters={param_theta: 2*np.pi})
#Draw the circuit with the set parameter values
qc.draw(output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">Note that our rotation gate has its theta value set to <img src="img/B18420_07_004.png" alt="" width="23" height="25"/><a id="_idIndexMarker840"/> as expected:</p>
    <figure class="mediaobject"><img src="img/B18420_07_13.png" alt="A screenshot of a computer  Description automatically generated with low confidence" width="305" height="142"/></figure>
    <p class="packt_figref">Figure 7.13: Rotation gates R<sub class="subscript">z</sub> now have the Parameter value θ set to 2π</p>
    <p class="normal">Our circuit is now ready to run with the bound parameter values. By having this feature, we can iterate it over a loop and bind multiple values if need be, so that we can iterate over all of them without having to manually update the bound values. This greatly optimizes our ability to run and analyze the results of our circuit for each iteration.</p>
    <p class="normal">In this section, we <a id="_idIndexMarker841"/>learned about various forms and <a id="_idIndexMarker842"/>ways to create quantum circuits using the classes and functions provided in Qiskit to help us analyze our circuit properties and construction. We also learned how to reuse the created circuits.</p>
    <p class="normal">In the next section, we will dig even deeper into manipulating qubits, only this time not from basis gates, but to directly manipulate the qubits using the hardware itself!</p>
    <h1 id="_idParaDest-124" class="heading-1">Generating pulse schedules on hardware</h1>
    <p class="normal">So far, you<a id="_idIndexMarker843"/> have learned how to create quantum circuits, add gates that manipulate the qubits of the circuit, and execute the circuits. In this section, we’ll go a little deeper to see how a quantum circuit is converted from digital instructions to pulse instructions that physically manipulate the qubits using microwave pulses as instructed by the quantum circuit. Microwave pulses are <a id="_idIndexMarker844"/>what manipulate the qubits on quantum devices. A signal is generated and tuned to a specific frequency of each qubit so that the signal only affects the qubit that the pulse is tuned to. </p>
    <p class="normal">Much of this section will assume that you have some knowledge of signal processing, particularly that of transmon-like superconducting qubits and microwave pulses. For reference, this is a fantastic paper that goes into the details, <a href="https://arxiv.org/pdf/1904.06560.pdf">https://arxiv.org/pdf/1904.06560.pdf</a>, where sections <em class="italic">4.C</em> and <em class="italic">4.D</em> cover a basic overview of how microwave signals are used to manipulate qubits. </p>
    <p class="normal">One thing you might be wondering by now is why you should have pulse access to manipulate the qubits. First, it is good to understand that superconducting qubits are manipulated by microwave pulses. These pulses send signals down to each qubit using the qubit’s carrier frequency to ensure that the pulse operation will affect only the qubit that is tuned to that specific frequency. This way, if you are a kernel developer, for example, the ability to configure the pulses provides you with the ability to fine-tune the gate operations yourself rather than the default pulse shapes that are set up. These fine-tunings could be applied to not only single-gate operations but also two-qubit operations such as a CNOT gate.</p>
    <p class="normal">We’ll begin by <a id="_idIndexMarker845"/>illustrating how the hardware components are connected to the various pulse channels. IBM Quantum provides you with access to the machines in a way that is unique from most other quantum systems available on the cloud. Qiskit includes a <code class="inlineCode">Pulse</code> library that allows you to control the pulses sent to the hardware that controls the device. Based on the <code class="inlineCode">OpenPulse</code> documentation (<a href="https://arxiv.org/abs/1809.03452">https://arxiv.org/abs/1809.03452</a>), it is tailored to provide the functionality to generate pulse signals used to control the qubits.</p>
    <p class="normal">To understand how the pulse functionality works, we’ll start by describing the four main components you will be using:</p>
    <ul>
      <li class="bulletList">Instructions</li>
      <li class="bulletList">Pulse libraries</li>
      <li class="bulletList">Channels</li>
      <li class="bulletList">Schedules</li>
    </ul>
    <p class="normal">In the following sections, we will learn about the preceding components.</p>
    <p class="normal">Before we proceed to the next section, we will use the following code, which will import everything we need to create, schedule, and trigger a pulse on a quantum device directly:</p>
    <pre class="programlisting code"><code class="hljs-code">#Import pulse classes
from qiskit.pulse import Waveform, DriveChannel, Play, Schedule
</code></pre>
    <p class="normal">Now that we have imported the files needed, we will move on to the next section, about instructions.</p>
    <h2 id="_idParaDest-125" class="heading-2">Learning about instructions</h2>
    <p class="normal"><strong class="keyWord">Pulse programs</strong>, or, as d<a id="_idIndexMarker846"/>escribed in the Qiskit API documentation, <strong class="keyWord">Schedules</strong>, are<a id="_idIndexMarker847"/> a set of instructions used to describe the control of the<a id="_idIndexMarker848"/> electronic components of the quantum system. There are various instruction objects included within the <code class="inlineCode">qiskit.pulse</code> library that have capabilities such as modulation of the frequency and phase of the pulse signal. </p>
    <div><p class="normal"><code class="inlineCode">pulse</code>, in essence, provides you with the ability to specify the dynamics of each operation in a quantum circuit, so you can fine-tune each in a way to minimize as much noise as possible. <code class="inlineCode">pulse</code> has various functionalities to give you access to the channels that send and receive information to and from each qubit, and includes libraries of pulses that you can use as a base and you can then modify each one accordingly. </p>
    </div>
    <p class="normal">You can also delay an instruction from triggering, similar to a <code class="inlineCode">sleep()</code> function in most programming languages. Finally, it gives you the ability to trigger an operation and enable the acquire channel by playing and capturing the microwave pulse signals, respectively.</p>
    <p class="normal">Understanding each of the following is dependent on understanding <em class="italic">why</em> you would want to use these functions. For example, setting the frequency is important as each qubit is tuned to a specific frequency, so any pulse operation should be sent at the carrier frequency of the specified qubit; otherwise, the operation will not work, or, worse, it might operate on a qubit that you do not want to update. Now, let’s describe each instruction<a id="_idIndexMarker849"/> and its parameters:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">SetFrequency(frequency, channel, name)</code>, where <code class="inlineCode">frequency</code> is in Hz, <code class="inlineCode">channel</code> indicates which channel the frequency will be applied to, and <code class="inlineCode">name</code> is the name you can set for the instruction. The default <em class="italic">duration</em> of the <code class="inlineCode">SetFrequency</code> instruction is <code class="inlineCode">0</code>. This very simply sets the frequency of the channel so that the pulses applied to the channel are tuned accordingly. If you do not specify a frequency when creating a pulse for a specific qubit, the default frequency for the qubit on the drive channel will be used.</li>
      <li class="bulletList"><code class="inlineCode">ShiftPhase(phase, channel, name)</code>, where <code class="inlineCode">phase</code> is the rotation angle in radians, <code class="inlineCode">channel</code> indicates the channel that the frequency will be applied to, and the <code class="inlineCode">name</code> parameter is the name you can set for the instruction. This instruction shifts the phase of the pulse by increasing its rotation angle by the provided amount in radians.</li>
      <li class="bulletList"><code class="inlineCode">Delay(duration, channel, name)</code>, where <code class="inlineCode">duration</code> is the length of time in the delay (in the documentation, this is also referred to as <em class="italic">time step</em>, or <code class="inlineCode">dt</code>), <code class="inlineCode">channel</code> indicates which channel the delay will be applied to, and <code class="inlineCode">name</code> indicates the name that you can set for the instruction. The <code class="inlineCode">Delay</code> instruction is generally used to align pulses with respect to other pulse instructions. For example, if you wish to send two pulses and include a time gap between the pulses, you can specify the time gap by adding a <code class="inlineCode">Delay</code> instruction with the desired time gap amount.</li>
      <li class="bulletList"><code class="inlineCode">Play(pulse, channel, name)</code>, where <code class="inlineCode">pulse</code> is the pulse waveform you wish to apply, <code class="inlineCode">channel</code> indicates which channel the pulse will be applied to, and <code class="inlineCode">name</code> is the name you can set for the instruction. The <code class="inlineCode">Play</code> instruction will apply the pulse <a id="_idIndexMarker850"/>output to the channel specified, where the pulse output was previously modulated using both the <code class="inlineCode">SetFrequency</code> and <code class="inlineCode">SetPhase</code> instructions.</li>
      <li class="bulletList"><code class="inlineCode">Acquire(duration, channel, mem_slot, reg_slot, kernel, discriminator, name)</code>, where <code class="inlineCode">duration</code> is the number of time steps (dt) to acquire the data information, <code class="inlineCode">channel</code> indicates which channel to acquire the data from, <code class="inlineCode">mem_slot</code> is the classical memory slot in which to store each of the returned results, and <code class="inlineCode">reg_slot</code> is the register slot used to store the classified and readout results. The <code class="inlineCode">kernel</code> parameter is used to integrate the raw data for each slot, <code class="inlineCode">discriminator</code> is used to classify kernelled IQ data into a <code class="inlineCode">0</code> or <code class="inlineCode">1</code> result, and <code class="inlineCode">name</code> indicates the name you can set for the instruction.</li>
    </ul>
    <p class="normal">Each instruction includes an operator that will be applied to the specified channels stated. The operators include pulse modulators, delays, and readouts from channels. Before we get into discussing channels, let’s create some pulses using the Qiskit Pulse library.</p>
    <h2 id="_idParaDest-126" class="heading-2">Understanding pulses and Pulse libraries</h2>
    <p class="normal">Each <a id="_idIndexMarker851"/>microwave pulse is created<a id="_idIndexMarker852"/> by an <strong class="keyWord">arbitrary waveform generator</strong> (<strong class="keyWord">AWG</strong>), which specifies the frequency and phase of the <a id="_idIndexMarker853"/>pulse signal output. The frequency and phase are set by the <code class="inlineCode">SetFrequency</code> and <code class="inlineCode">ShiftPhase</code> instructions we learned about earlier, respectively.</p>
    <div><p class="normal"><strong class="keyWord">Important Note</strong></p>
      <p class="normal">Qiskit Pulse provides a nice library of waveforms, which can simplify creating the pulses we need to operate on a qubit. The following are the types of available waveforms at the time of writing this chapter: <code class="inlineCode">Constant</code>, <code class="inlineCode">Drag</code>, <code class="inlineCode">Discrete</code>, <code class="inlineCode">Gaussian</code>, <code class="inlineCode">GaussianSquare</code>, and <code class="inlineCode">Waveform</code>. Each of these waveforms has a specific feature, for example, <code class="inlineCode">Drag</code> is used to reduce leakage to the <img src="img/B18420_07_006.png" alt="" width="21" height="25"/><a id="_idIndexMarker854"/> state of the qubit and keeps it confined to the <img src="img/B18420_07_007.png" alt="" width="21" height="25"/><a id="_idIndexMarker855"/> and <img src="img/B18420_07_008.png" alt="" width="21" height="25"/><a id="_idIndexMarker856"/> states.</p>
    </div>
    <p class="normal">Each of the <a id="_idIndexMarker857"/>waveforms provided in the Pulse library has a specific feature. We’ll cover a few of them below, but I would encourage you to read more in the <a id="_idIndexMarker858"/>Qiskit documentation, <a href="https://docs.quantum.ibm.com/api/qiskit/pulse">https://docs.quantum.ibm.com/api/qiskit/pulse</a>, which includes a detailed description of each.</p>
    <p class="normal"><code class="inlineCode">Waveform</code> allows<a id="_idIndexMarker859"/> you to define your own pulse by providing an array of complex value samples as an argument. These samples each have a predefined time step, <code class="inlineCode">dt</code>, which is the time period played for each and varies based on the specified backend. The following code is an example of a sample pulse for a simple sine waveform of 128 samples:</p>
    <pre class="programlisting code"><code class="hljs-code">#Import numpy and generate the sine sample values
import numpy as np
x = np.linspace(0,2*np.pi,64)
data = np.sin(x)
#Generate our Waveform
waveform = Waveform(data, name="sine_64_pulse")
#Draw the generated waveform
waveform.draw()
</code></pre>
    <p class="normal">The following screenshot is the result of creating our sample pulse of a sine waveform:</p>
    <figure class="mediaobject"><img src="img/B18420_07_14.png" alt="Chart  Description automatically generated" width="817" height="262"/></figure>
    <p class="packt_figref">Figure 7.14: Sample pulse of a sine waveform</p>
    <p class="normal">Let’s now try generating one of the waveforms from the Pulse library.</p>
    <p class="normal">The Pulse library has an array of different waveforms, such as <code class="inlineCode">Gaussian</code>, <code class="inlineCode">GaussianSquare</code>, <code class="inlineCode">Constant</code>, and <code class="inlineCode">Drag</code> (just to name a few). Each has its own distinct shape that we can leverage to fine-tune any pulse we wish.</p>
    <p class="normal">Let’s <a id="_idIndexMarker860"/>create a<a id="_idIndexMarker861"/> <code class="inlineCode">GaussianSquare</code> pulse, which is simply a square pulse with Gaussian edges on both ends, rather than squared-off edges:</p>
    <pre class="programlisting code"><code class="hljs-code">#Import the Gaussian Square pulse from Pulse Library
from qiskit.pulse.library import GaussianSquare
#Create a Gaussian Square pulse
#Args: duration, amp, sigma, width, name
gaussian_square_pulse = GaussianSquare(128, 1, 2, 112, name="gaussian square")
gaussian_square_pulse.draw()
</code></pre>
    <p class="normal">The <a id="_idIndexMarker862"/>preceding code will result in the following pulse, where the duration (<code class="inlineCode">dt</code>) is <code class="inlineCode">128</code>, the amplification max is at <code class="inlineCode">1</code>, sigma is set to <code class="inlineCode">2</code>, and the width of the pulse peak is <code class="inlineCode">112</code> (<code class="inlineCode">dt</code>):</p>
    <figure class="mediaobject"><img src="img/B18420_07_15.png" alt="Graphical user interface, application, table  Description automatically generated" width="825" height="179"/></figure>
    <p class="packt_figref">Figure 7.15: Gaussian square pulse</p>
    <p class="normal">As you can see, the parameters available to us allow adjustments to the waveform in multiple ways. In the <code class="inlineCode">Gaussian Square</code> waveform sample, we were able to adjust the amplitude, width, and its sigma, which therefore provides us with more control over the creation of the pulse, which could potentially reduce noise or any other affects that could come from a standard pulse that is created based on the quantum circuit instructions.</p>
    <p class="normal">Now that we can create pulses, let’s learn about the channels that we will transmit these pulses through.</p>
    <h2 id="_idParaDest-127" class="heading-2">Leveraging channels to transmit and receive instructions</h2>
    <p class="normal">There are two types of channels in Qiskit Pulse:</p>
    <ul>
      <li class="bulletList">The first type is <a id="_idIndexMarker863"/>the <strong class="keyWord">Pulse channel</strong>, which <a id="_idIndexMarker864"/>transmits the generated pulses to the quantum device. These <a id="_idIndexMarker865"/>include<a id="_idIndexMarker866"/> the <strong class="keyWord">Drive channel</strong>, <strong class="keyWord">Control channel</strong>, and<a id="_idIndexMarker867"/> the <strong class="keyWord">Measure channel</strong>.</li>
      <li class="bulletList">The other type of<a id="_idIndexMarker868"/> channel is the <strong class="keyWord">Acquisition channel</strong>. Currently, this<a id="_idIndexMarker869"/> type only includes <a id="_idIndexMarker870"/>the <strong class="keyWord">Acquire channel</strong>, which is the channel that receives pulses from the quantum device.</li>
    </ul>
    <p class="normal">All channels only have one parameter, the index, which is used to assign the channel. The following list describes all the channels:</p>
    <ul>
      <li class="bulletList">The Drive channel is the channel used to transmit the pulse signal down to the qubit to execute the gate operation. When displayed, it has the prefix <strong class="screenText">D</strong>.</li>
      <li class="bulletList">The Control channel is commonly used on multi-qubit gate operations such as <code class="inlineCode">Control-Not</code>, <code class="inlineCode">Control-Phase</code>, and more. They generally provide auxiliary control over the qubit via the drive channel. When displayed, it has the prefix <strong class="screenText">U</strong>.</li>
      <li class="bulletList">The Measure channel transmits a measurement stimulus pulse to the qubit for a readout from the qubit. When displayed, it has the prefix <strong class="screenText">M</strong>.</li>
      <li class="bulletList">The Acquire channel is the only channel that is used to receive information from the device. It is used to collect data from the quantum device. When displayed, it has the prefix <strong class="screenText">A</strong>.</li>
    </ul>
    <p class="normal">So far, we have learned that pulse programs are instructions that are made up of waveform pulses that are constructed to perform gate operations on quantum devices. We also covered the different channels available to transmit and receive information to and from quantum devices. With this information, we can now look at how to schedule these instructions to be executed on a real device.</p>
    <h2 id="_idParaDest-128" class="heading-2">Generating and executing schedules</h2>
    <p class="normal">Pulse schedules <a id="_idIndexMarker871"/>are a set of instructions sent through specified channels to be executed on a quantum device. The <code class="inlineCode">Schedule</code> class can be made up of instructions or a combination of other schedules. That means you can create a schedule with one of the instructions we learned about earlier, or you can combine or append schedules to existing schedules. We will do all this in this section.</p>
    <p class="normal">We will use what we<a id="_idIndexMarker872"/> have learned so far in this chapter to build a schedule. First, we will construct a schedule and insert a pulse from the Pulse library into it that will be triggered at <code class="inlineCode">time = 0</code>. Then, we will create another schedule and insert a different pulse from the Pulse library into it. The second one will be appended to the first schedule and then shifted, so it is triggered at some time after the first pulse has completed. We’ll then execute the schedule on a quantum device and get back its result:</p>
    <ol>
      <li class="numberedList" value="1">Let’s continue using the notebook we have been using so far to create our first schedule, and name it <code class="inlineCode">schedule_1</code>. We’ll also use the <code class="inlineCode">Play</code> instruction to insert the Gaussian square pulse we generated earlier and assign the schedule to drive channel <code class="inlineCode">0</code>:
        <pre class="programlisting code-one"><code class="hljs-code">#Create the first schedule with our Gaussian Square pulse
schedule_1 = Schedule(name='Schedule 1')
schedule_1 = schedule_1.insert(0, 
        Play(gaussian_square_pulse, DriveChannel(0)))
#Draw the schedule
schedule_1.draw()
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The result we see is that our Gaussian square pulse was added to the schedule starting at <code class="inlineCode">time = 0</code>, as follows:</p>
    <figure class="mediaobject"><img src="img/B18420_07_16.png" alt="Table  Description automatically generated" width="736" height="151"/></figure>
    <p class="packt_figref">Figure 7.16: Schedule 1: Gaussian square pulse</p>
    <ol>
      <li class="numberedList" value="2">Now, let’s continue and create the second schedule, <code class="inlineCode">schedule_2</code>, with the sample pulse we generated earlier:
        <pre class="programlisting code-one"><code class="hljs-code">#Create a second schedule with our sample pulse
schedule_2 = Schedule(name='Schedule 2')
schedule_2 = schedule_2.insert(0, Play(waveform, DriveChannel(0)))
#Draw the schedule
schedule_2.draw()
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This<a id="_idIndexMarker873"/> results in the following schedule: note the <a id="_idIndexMarker874"/>duration of our sample pulse is 64, whereas the Gaussian square pulse has a duration of 128:</p>
    <figure class="mediaobject"><img src="img/B18420_07_17.png" alt="Chart, histogram  Description automatically generated" width="759" height="219"/></figure>
    <p class="packt_figref">Figure 7.17: Schedule 2: sample (sine waveform) pulse</p>
    <ol>
      <li class="numberedList" value="3">Next, we will create a third schedule, <code class="inlineCode">schedule_3</code>, and we will construct it by inserting both <code class="inlineCode">schedule_1</code> and <code class="inlineCode">schedule_2</code> together with a gap of 5 time steps (<code class="inlineCode">dt</code>) in between the two:
        <pre class="programlisting code-one"><code class="hljs-code">#Let's create a third schedule, where we add the first 
#schedule and second schedules and shift the second 
# to the right by a time of 5 after the first
schedule_3 = schedule_1.insert(schedule_1.duration+5, schedule_2)
schedule_3.draw()
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The result is a combination of <code class="inlineCode">schedule_1</code> starting at <code class="inlineCode">time = 0</code> and then we insert <code class="inlineCode">schedule_2</code> starting at 5 time units after the first schedule. Note the use of the <code class="inlineCode">duration</code> variable to ensure that the pulse does not overlap with the first. Schedule 3, therefore, has a total time of the two pulses plus the 5 time units in between the two, totaling 197, as the following figure illustrates:</p>
    <figure class="mediaobject"><img src="img/B18420_07_18.png" alt="Chart  Description automatically generated" width="759" height="219"/></figure>
    <p class="packt_figref">Figure 7.18: Schedule 3, combining schedules 1 and 2 with a 5 time unit difference in between</p>
    <ol>
      <li class="numberedList" value="4">Of course, there <a id="_idIndexMarker875"/>are other ways to combine pulses. If<a id="_idIndexMarker876"/> you want to combine the two schedules without a gap in between, then you can simply use the <code class="inlineCode">append</code> function to combine them:
        <pre class="programlisting code-one"><code class="hljs-code">#We could have also combined the two using the append operator
#The two schedules are appended immediately after one #another
schedule_3_append = schedule_1.append(schedule_2)
schedule_3_append.draw()
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The preceding code results in the following output. Note how the total time units are equal to the total time units of both pulses, without the additional 5 time units in between the two pulses:</p>
    <figure class="mediaobject"><img src="img/B18420_07_19.png" alt="A picture containing chart  Description automatically generated" width="758" height="224"/></figure>
    <p class="packt_figref">Figure 7.19: Schedule 3, appending two schedules without a time gap in between</p>
    <p class="normal">Up to this point, we <a id="_idIndexMarker877"/>were able to generate a pulse, apply it to an instruction, and <a id="_idIndexMarker878"/>schedule it to run on a specified channel to manipulate the qubit. Generating a set of pulses allows you to get an understanding of how we can schedule two separate gate operations to a single qubit sequentially on the specified channel. </p>
    <p class="normal">In the next section, we’ll see how we can find the status of our quantum circuits once they have been submitted.</p>
    <h1 id="_idParaDest-129" class="heading-1">Understanding the Job component</h1>
    <p class="normal">The last <a id="_idIndexMarker879"/>component we will cover is the <code class="inlineCode">Job</code> component. The <code class="inlineCode">Job</code> component is basically an instance of the circuit that has been executed on the backend and contains information from the executed circuit(s), such as results, which backend, duration, etc. What that means is that once you send the circuit to the backend to get executed, the backend will generate the <code class="inlineCode">Job</code> instance and append information about the job: information such as status, result, job identifier, and so on. The following is a list of the available <code class="inlineCode">Job</code> functions:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">backend()</code> provides the backend that the job is running on.</li>
      <li class="bulletList"><code class="inlineCode">status()</code> provides the status of the job.</li>
      <li class="bulletList"><code class="inlineCode">result()</code> provides the job result after execution is completed on the backend.</li>
      <li class="bulletList"><code class="inlineCode">cancel()</code> provides the ability to cancel the job.</li>
      <li class="bulletList"><code class="inlineCode">job_id()</code> provides the alphanumeric job identifier.</li>
    </ul>
    <p class="normal">We’ll reuse the circuit we created earlier, <code class="inlineCode">transpiled_qc</code>, for simplicity so we can review the <code class="inlineCode">Job</code> object and its functions. Let’s start by importing the <code class="inlineCode">job_monitor</code> class and launching the Qiskit job watcher, followed by running the circuit on a backend and running the job monitor to see the status of the job in the output:</p>
    <pre class="programlisting code"><code class="hljs-code">#Run the simple quantum circuit on local Sampler
from qiskit.primitives import Sampler
sampler = Sampler()
#Let's create a simple circuit
qc = QuantumCircuit(1,1)
qc.h(0)
qc.measure([0],[0])
#Let's run a circuit with the Sampler primitive
job = sampler.run(qc, shots=1024)
print(job.status())
</code></pre>
    <p class="normal">The<a id="_idIndexMarker880"/> preceding code will execute a circuit and the following will display the details of the <code class="inlineCode">Job</code> object; for example, it will indicate whether the job is in a queue, running, or completed successfully. In this case, the result of the status is that the job has successfully run:</p>
    <pre class="programlisting gen"><code class="hljs">Job Status: JobStatus.DONE
</code></pre>
    <p class="normal">Other information can also be pulled from the <code class="inlineCode">Job</code> object. The <strong class="keyWord">Job ID</strong> is the unique identifier of the job that is being run. This ID can be very useful for various reasons, such as tracking the results, and should you have an issue with a job running on the backend, you can reference the job ID when speaking to the support team, which will help the team find the job. The status and results can be called explicitly using the functions <code style="font-weight: bold;" class="codeHighlighted">status()</code> and <code style="font-weight: bold;" class="codeHighlighted">result()</code>, respectively. The <code class="inlineCode">result</code> object provides all the information resulting from running the job on the backend. Let’s run these functions to review the results of the job we just ran:</p>
    <pre class="programlisting code"><code class="hljs-code">#From the previous output of executed jobs, obtain its job id 
#and print out information about the Job.
print('Print Job ID: ', job.job_id())
print('Print Job Status: ', job.status())
print('Print Job Result: ', job.result())
</code></pre>
    <p class="normal">The results of each of the functions in the code snippet are as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">Print Job ID:  dc25c6bd-2ce6-41d5-9caf-f1326f70b90d
Print Job Status:  JobStatus.DONE
Print Job Result:  SamplerResult(quasi_dists=[{0: 0.5107421875, 1: 0.4892578125}], metadata=[{'shots': 1024}])
</code></pre>
    <p class="normal">This is where we can pull specific result information that we can use to visualize the status of the Job. For example, the following code will extract the counts from the results and display the counts in a histogram:</p>
    <pre class="programlisting code"><code class="hljs-code">job_result = job.result()
quasi_dists = job_result.quasi_dists
# Get result counts
counts = quasi_dists[0].binary_probabilities()
#Print and plot results
print(counts)
plot_distribution(counts)
</code></pre>
    <p class="normal">The results will produce the following histogram which pertains to the results from each shot as a total of probabilities. (quasi-probabilities) as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">{'0': 547, '1': 477}
</code></pre>
    <p class="normal">The histogram <a id="_idIndexMarker881"/>will then display as follows:</p>
    <figure class="mediaobject"><img src="img/B18420_07_20.png" alt="Chart, bar chart  Description automatically generated" width="711" height="485"/></figure>
    <p class="packt_figref">Figure 7.20: The probability results as a histogram</p>
    <p class="normal">The <code class="inlineCode">job</code> object helps us get details regarding the circuit that we have sent to run on a quantum system. This information can be used to provide the results back to our application and visualize the results accordingly. It also provides the status and other information that we can use to keep track of the job and share details about the results with others, such as support teams, so they can easily identify jobs on the backend. </p>
    <h1 id="_idParaDest-130" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we covered just some of the many features included in the Qiskit library. We reviewed creating quantum circuits, as well as executing them on the simulator and real quantum devices. We also reviewed how to concatenate circuits so as to enable you to combine and create composite circuits, which included binding parameters to enable adjustments to various gates. </p>
    <p class="normal">We covered how the circuits are converted into pulses using Qiskit’s Pulse library and created schedules, which are programs that send pulse information via various channels down to the hardware, and looked at how to obtain the details of the job that was running on the backend.</p>
    <p class="normal">In the next chapter, we will cover techniques to optimize your quantum circuits by reviewing the features available via pass managers and optimizers. We’ll also learn various ways to visualize your quantum circuits and monitor your jobs as they are executed on the quantum backend systems.</p>
    <h1 id="_idParaDest-131" class="heading-1">Questions</h1>
    <ol>
      <li class="numberedList" value="1">Construct a random quantum circuit with a width of 4 and a depth of 9.</li>
      <li class="numberedList">Create another random quantum circuit with the same width as the circuit you created in <em class="italic">Question 1</em> and concatenate it so that it is added before the random quantum circuit you created.</li>
      <li class="numberedList">Print the circuit properties of the concatenated quantum circuit from <em class="italic">Question 3</em> and specify the total number of operators, not including any measurement operators.</li>
      <li class="numberedList">Create a circuit with a parameterized R<sub class="subscript">Y</sub> gate that would rotate by an angle of <img src="img/B18420_07_009.png" alt="" width="31" height="25"/><a id="_idIndexMarker882"/>.</li>
    </ol>
    <h1 id="_idParaDest-132" class="heading-1">Join us on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
    <p class="normal"><a href="Chapter_7.xhtml">https://packt.link/3FyN1</a></p>
    <p class="normal"><img src="img/QR_Code2617625996838265932.png" alt="" width="165" height="165"/></p>
  </div>
</div></div></body></html>