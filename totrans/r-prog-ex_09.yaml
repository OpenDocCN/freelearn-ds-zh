- en: Implementing an Efficient Simple Moving Average
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现高效的简单移动平均
- en: During the last few decades, demand for computing power has steadily increased
    as the data volume has become larger and models have become more complex. It is
    obvious that minimizing the time needed for these calculations has become an important
    task and that there are obvious performance problems that need to be tackled.
    These performance problems arise from a mismatch between data volume and existing
    analytical methods. Eventually, a fundamental shift in data analysis techniques
    will be required, but for now, we must settle with improving the efficiency of
    our implementations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几十年中，随着数据量的增加和模型的复杂化，对计算能力的需求稳步增长。显然，最小化这些计算所需的时间已成为一项重要任务，并且存在明显的性能问题需要解决。这些性能问题源于数据量与现有分析方法之间的不匹配。最终，数据分析技术将需要进行根本性的转变，但就目前而言，我们必须满足于提高我们实现的效率。
- en: R was designed as an interpreted language with a high-level expressiveness,
    and that's one of the reasons why it lacks much of the fine-grained control and
    basic constructs to support highly-performant code. As Arora nails it in the book,
    she edited, *Conquering Big Data with High Performance Computing, by Springer,
    2016:* "*While R is clearly a high productivity language, it has not necessarily
    been a high performance language*.*"*
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: R被设计为一种具有高级表达性的解释型语言，这也是它缺乏许多支持高性能代码的细粒度控制和基本结构的原因之一。正如阿罗拉在2016年Springer出版的《用高性能计算征服大数据》一书中所说：“虽然R显然是一种高生产力语言，但它并不一定是一种高性能语言。”
- en: It is not uncommon for the execution time of an R program to be measured in
    hours, or even in days. As the volume of data to be analyzed increases, the execution
    time can become prohibitively long, and it's often the case that data scientists
    and statisticians get stuck with these bottlenecks. When this happens, and if
    they don't know much about performance optimization, they'll probably just settle
    with reduced amounts of data, which can hinder their analysis. However, fear not;
    R programs can be slow, but well-written R programs are usually fast enough, and
    we will look at various techniques you can use to increase the performance of
    your R code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: R程序的执行时间以小时或甚至以天来衡量并不罕见。随着要分析的数据量的增加，执行时间可能会变得过长，数据科学家和统计学家常常会遇到这些瓶颈。当这种情况发生时，如果他们对性能优化了解不多，他们可能会满足于减少数据量，这可能会阻碍他们的分析。然而，不用担心；R程序可能会慢，但编写良好的R程序通常足够快，我们将探讨你可以使用的各种技术来提高你的R代码性能。
- en: This chapter is not meant to make you a performance optimization expert, but
    rather provide an overview that introduces you to the vast amount of techniques
    that can be used when attempting to increase your code's performance. We will
    look at many different techniques, each of which can have chapters and even books
    dedicated to them, so we will have to look at them from a very high level, but
    if you find yourself being constantly restricted by computing resources, they
    are something you will want to look further into.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的不是让你成为一个性能优化专家，而是提供一个概述，介绍你如何尝试提高代码性能时可以使用的各种技术。我们将探讨许多不同的技术，每个技术都可能有自己的章节甚至书籍，因此我们只能从非常高的层面来看待它们，但如果你发现自己经常受到计算资源的限制，那么这些内容是你需要进一步深入了解的。
- en: 'Some of the important topics covered in this chapter are as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的一些重要主题如下：
- en: Deciding how fast an implementation must be
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定实现必须有多快
- en: The importance of using good algorithms
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用良好算法的重要性
- en: Reasons why R can be slow or inefficient at times
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么R有时会慢或效率低下
- en: The big performance impact small changes can have
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小的改变可能对性能产生的影响
- en: Measuring your code's performance to find bottlenecks
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量代码性能以找到瓶颈
- en: Comparing different implementations among themselves
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较不同实现之间的差异
- en: Getting the most from your computer by parallelizing
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过并行化从计算机中获得最大效益
- en: Improving performance by interfacing with other languages
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过与其他语言接口提高性能
- en: Required packages
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需要的包
- en: We have already worked with some of the packages required for this chapter,
    such as `ggplot2` and `lubridate`. The other three packages are introduced to
    benchmark functions and compare their performance among themselves, and for advanced
    optimization techniques like **delegation** and **parallelization**, which will
    be explained in their respective sections.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了一些本章所需的包，例如 `ggplot2` 和 `lubridate`。其他三个包被介绍用于基准函数，并比较它们之间的性能，以及用于高级优化技术如**委托**和**并行化**，这些将在各自的章节中解释。
- en: To be able to replicate all the examples in this chapter, you also need working
    compilers for Fortran and C++ code. Refer to [Appendix](part0296.html#8Q96G0-f494c932c729429fb734ce52cafce730),
    *Required Packages*, for instructions on how to install them for your operating
    system.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够复制本章中的所有示例，你还需要为 Fortran 和 C++ 代码安装可工作的编译器。有关如何在您的操作系统上安装它们的说明，请参阅[附录](part0296.html#8Q96G0-f494c932c729429fb734ce52cafce730)，*所需包*。
- en: 'Let''s take a look at the following table depicting the uses of the required
    packages:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下表格，描述了所需包的用途：
- en: '| **Packages** | **Reason** |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| **包** | **原因** |'
- en: '| `ggplot2` | High-quality graphs |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `ggplot2` | 高质量图表 |'
- en: '| `lubridate` | Easily transfer dates |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `lubridate` | 容易转换日期 |'
- en: '| `microbenchmark` | Benchmark functions'' performance |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `microbenchmark` | 基准函数的性能 |'
- en: Starting by using good algorithms
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从使用好的算法开始
- en: To be able to communicate the ideas contained in this chapter clearly, first
    I need to provide some simple definitions. When I refer to an *algorithm*, I mean
    an abstract specification for a process. When I refer to an *implementation*,
    I refer to the way an algorithm is actually programmed. Finally, when I refer
    to a *program* or an *application*, I mean a set of such algorithm implementations
    working together. Having said that, it's easy to see how an algorithm can be implemented
    in many different ways (for example, one implementation may be using a list, while
    another may be using an array). Each of these implementations will have different
    performances, and they are related, but not equivalent, to an algorithm's time-complexity.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够清楚地传达本章包含的思想，首先我需要提供一些简单的定义。当我提到一个*算法*时，我指的是一个过程的抽象规范。当我提到一个*实现*时，我指的是算法实际编程的方式。最后，当我提到一个*程序*或*应用*时，我指的是一组这样的算法实现协同工作。有了这些，很容易看出一个算法可以以许多不同的方式实现（例如，一个实现可能使用列表，而另一个可能使用数组）。这些实现中的每一个都会有不同的性能，并且它们与算法的时间复杂度相关，但并不等价。
- en: For those unfamiliar with the last term, each algorithm has the following two
    basic properties
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不熟悉最后一个术语的人来说，每个算法都有以下两个基本属性
- en: '**Time complexity**: This property refers to the number of calculations an
    algorithm needs to execute, in relation to the size of input it receives. There
    are various mathematical tools to measure this complexity, the most common one
    being Big-O notation, which measures the worst-case scenario for an algorithm.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间复杂度**：这个属性指的是算法需要执行的计算次数，与它接收到的输入大小相关。有各种数学工具可以测量这种复杂性，最常见的是大O符号，它衡量算法的最坏情况。'
- en: '**Space complexity**: This property refers to the amount of memory required
    to execute the algorithm, again in relation to the size of the input it receives,
    and it can be also measured with the same mathematical tools.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空间复杂度**：这个属性指的是执行算法所需的内存量，再次与它接收到的输入大小相关，也可以用相同的数学工具来衡量。'
- en: It's a well-known fact that an inefficient algorithm implemented very efficiently
    can be orders of magnitude slower than an efficient algorithm implemented inefficiently.
    This means that most of the time, algorithm selection is much more important than
    implementation optimization.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，一个效率低下的算法即使实现得非常高效，也可能比一个效率高的算法实现得低效慢得多。这意味着，大多数情况下，算法选择比实现优化更重要。
- en: There are many other things to consider when evaluating an algorithm other than
    the complexities mentioned previously, such as efficiency resources usage (for
    example, internet bandwith), as well as other properties such as security or implementation
    difficulty. We won't dig into these topics in this book. However, if you want
    your code to perform well, you must study data structures and algorithms formally.
    Great resources to get started on these topics are the book by Cormen, Leiserson,
    Rivest, and Stein, titled *Introduction to Algorithms, by MIT Press, 2009*, and
    Skiena's, *The Algorithm Design Manual, by Springer, 2008*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估算法时，除了之前提到的复杂度之外，还有许多其他因素需要考虑，例如效率资源使用（例如，互联网带宽），以及其他属性，如安全性或实现难度。在这本书中，我们不会深入探讨这些主题。然而，如果你想让你的代码表现良好，你必须正式地学习数据结构和算法。这些主题的入门资源包括Cormen、Leiserson、Rivest和Stein合著的书籍，书名为《算法导论》，由MIT出版社于2009年出版，以及Skiena的《算法设计手册》，由Springer出版社于2008年出版。
- en: Just how much impact can algorithm selection have?
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算法选择可以产生多大的影响？
- en: Calculating Fibonacci numbers is a traditional example when teaching recursiveness.
    Here, we will use it to compare the performance of two algorithms, one recursive
    and one sequential.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 计算斐波那契数是教授递归性的传统例子。在这里，我们将用它来比较两种算法的性能，一种是递归的，另一种是顺序的。
- en: In case you are not familiar with them, Fibonacci numbers are defined recursively
    in a sequence where the next is the sum of the previous two, and the first two
    numbers are ones (our base cases). The actual sequence is 1, 1, 2, 3, 5, 8, 13,
    21, 34, 55, 89, 144, and so on. This is called a Fibonacci sequence, and it exhibits
    interesting properties, such as being related to the golden ratio, which you should
    definitely look up if don't know what it is.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉它们，斐波那契数是在一个序列中递归定义的，其中下一个数是前两个数的和，前两个数都是1（我们的基本情况）。实际的序列是1, 1, 2, 3,
    5, 8, 13, 21, 34, 55, 89, 144，等等。这被称为斐波那契序列，它表现出有趣的性质，例如与黄金比例相关，如果你不知道它是什么，你绝对应该查找一下。
- en: 'Our `fibonacci_recursive()` function receives the position of the Fibonacci
    number we want to calculate as `n`, restricted to integers greater than or equal
    to one. If `n` is a base case, that is, if it''s below 1, we will simply return
    it (not that if we''re computing the Fibonacci number at the second position,
    our operation `n - 2` would be zero, which is not a valid position, that''s why
    we need to use `<=` instead of `==`). Otherwise, we will return the sum of the
    recursive calls to the previous two with `fibonacci_recursive(n - 1)` and `fibonacci_recursive(n
    - 2)`, as shown in the following code snippet:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`fibonacci_recursive()`函数接收我们想要计算的斐波那契数的位置`n`，限制为大于或等于1的整数。如果`n`是基本情况，即如果它小于1，我们将简单地返回它（不是如果我们正在计算第二个位置的斐波那契数，我们的操作`n
    - 2`将是零，这不是一个有效的位置，这就是为什么我们需要使用`<=`而不是`==`）。否则，我们将返回对前两个递归调用的和，即`fibonacci_recursive(n
    - 1)`和`fibonacci_recursive(n - 2)`，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Why is this happening? The answer is that this algorithm is doing a lot of
    unnecessary work, making it a bad algorithm. To understand why, let''s mentally
    go through the execution of the algorithm for the third and fourth Fibonacci numbers
    and make the corresponding execution trees, as shown in the following diagram:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会发生这种情况？答案是，这个算法做了很多不必要的操作，使其成为一个糟糕的算法。为了理解原因，让我们在脑海中回顾一下计算第三个和第四个斐波那契数的算法执行过程，并制作相应的执行树，如下所示：
- en: '![](img/00061.jpeg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00061.jpeg)'
- en: In the preceding diagram, **f(n)** is short for `fibonacci_recursive(n)`, so
    that we can fit all the objects inside it, and colors are used to show which function
    calls are repeated. As you can see, when you execute `fibonacci_recusive(3)`,
    the `fibonacci_recursive(1)` call is executed twice. When executing `fibonacci_recursive(4)`,
    that same call is executed three times. How many times will it be executed for
    `fibonacci_recursive(5)` and `for fibonacci_recursive(6)`? That's an exercise
    for you, the reader, and as you'll find, the number increases exponentially.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，**f(n**)是`fibonacci_recursive(n)`的简称，这样我们就可以将所有对象都放入其中，颜色用于显示哪些函数调用是重复的。正如你所看到的，当你执行`fibonacci_recusive(3)`时，`fibonacci_recursive(1)`调用执行了两次。当执行`fibonacci_recursive(4)`时，相同的调用执行了三次。`fibonacci_recursive(5)`和`fibonacci_recursive(6)`将执行多少次？这是一个练习，留给读者去完成，你会发现，这个数字呈指数增长。
- en: To be technically precise, the time complexity for the algorithm is O(2^n),
    which is as bad as you can get. Furthermore, most of the calculations are completely
    unnecessary since they are repeated. The algorithm is correct, but its performance
    is one of the worst. As we mentioned earlier, even if you provide the most efficient
    implementation possible for this algorithm, it will be much slower than a very
    inefficient implementation of a more efficient one.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上讲，算法的时间复杂度是O(2^n)，这是最糟糕的情况。此外，大多数计算都是完全不必要的，因为它们是重复的。算法是正确的，但它的性能是最差的。正如我们之前提到的，即使您为这个算法提供了可能的最有效实现，它也将比一个更有效算法的低效实现慢得多。
- en: 'If we design a correct algorithm that avoids doing all the unnecessary calculations,
    we can have a much faster program, and that''s exactly what the following algorithm
    does. Instead of making a tree of recursive calls, we will simply compute the
    Fibonacci numbers in order up to the one we are being asked for. We will simply
    add the previous two numbers and store the result in the array `f`, which will
    have `n` integers. We specify the two base cases and proceed with the calculation,
    as shown in the following code snippet:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们设计一个正确的算法，避免进行所有不必要的计算，我们可以拥有一个运行速度更快的程序，这正是以下算法所做到的。我们不会构建递归调用的树，而是简单地按顺序计算我们要求的斐波那契数。我们将简单地添加前两个数，并将结果存储在数组`f`中，该数组将有`n`个整数。我们指定两个基本情况，并继续计算，如下面的代码片段所示：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, each number is computed only once, which is the most efficient
    algorithm we can design for this problem. This avoids all the overhead from the
    recursive algorithm and leaves us with a linear time complexity of O(n). Even
    if we code this algorithm without much care for performance optimization, it's
    execution time will be many orders of magnitude faster.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，每个数字只计算一次，这是我们为这个问题能设计的最有效算法。这避免了递归算法的所有开销，并使我们保持线性时间复杂度O(n)。即使我们不关心性能优化地编写这个算法，它的执行时间也将快得多。
- en: 'With this algorithm, we can actually compute the 1476^(th) Fibonacci number,
    which is the largest one that R''s internal architecture will allow for. If we
    try to compute the 1477^(th) Fibonacci number, we will get infinity (`Inf`) as
    a response due to the mechanisms R uses to store integers, which is a topic we
    won''t go into. Furthermore, the computation for the 1476^(th) Fibonacci number
    is almost instantaneous, which goes to showcase the importance of choosing a good
    algorithm before worrying about optimizing it:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个算法，我们实际上可以计算出第1476个斐波那契数，这是R语言内部架构允许的最大值。如果我们尝试计算第1477个斐波那契数，由于R语言存储整数所使用的机制，我们将得到无穷大（`Inf`）作为响应，这个机制我们不会深入探讨。此外，计算第1476个斐波那契数几乎是瞬间的，这展示了在选择算法之前优化它的重要性：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Finally, note that we achieved an increase in speed at the expense of using
    more memory. The recursive algorithm discarded every Fibonacci number once it
    computed it, while the sequential algorithm keeps every single one in memory.
    For this particular problem, this seems to be a good trade-off. The trade-off
    among time and space is a common one in performance optimization.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，我们是在牺牲更多内存使用的情况下提高了速度。递归算法在计算完每个斐波那契数后就会丢弃它，而顺序算法则将每个数都保留在内存中。对于这个问题，这似乎是一个很好的权衡。在性能优化中，时间和空间之间的权衡是常见的。
- en: Now that we have seen just how important algorithm selection can be, for the
    rest of the chapter we will work with a single algorithm, and we will focus on
    optimizing its implementation. However, the point remains that choosing an efficient
    algorithm is more important than implementing it efficiently.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经看到了算法选择的重要性，那么在接下来的章节中，我们将使用一个单一的算法，并专注于优化其实现。然而，选择一个高效的算法比高效地实现它更重要。
- en: How fast is fast enough?
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多快才算快？
- en: Let's assume that you have chosen a good algorithm and implemented it without
    too much regard for optimization, as is commonly the case with first attempts.
    Should you invest the time to optimize it? Performance optimization can be a very
    costly activity. You must not try to optimize your code unless you must. Your
    time is valuable, and it's probably better spent doing something else.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已经选择了一个好的算法，并且没有过多考虑优化地实现了它，这在第一次尝试中很常见。您是否应该投入时间去优化它？性能优化可能是一项非常昂贵的活动。除非您必须这样做，否则不要尝试优化您的代码。您的时间很宝贵，可能最好花在其他事情上。
- en: Let's say that for some reason, you must make your implementation faster. The
    first thing you must decide on is how fast is fast enough. Is your algorithm required
    to simply finish within a couple of hours instead of a couple of days, or do you
    need to come down to microsecond levels? Is this an absolute requirement or should
    you simply do the best job you can within a specific time frame? These are important
    questions that you must consider before optimizing your code, and sometimes the
    solution is not even optimization.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 假设由于某种原因，你必须使你的实现更快。你必须首先决定的是多快才算足够快。你的算法是否只需要在几小时内完成，而不是几天，或者你需要降低到微秒级别？这是一个绝对要求，还是你只需要在特定时间内尽你所能做好？在优化代码之前，你必须考虑这些问题，有时解决方案甚至不是优化。
- en: It's not rare for clients to prefer spending more money on using some type of
    cloud resource to tackle the performance problem rather than spending valuable
    time optimizing an algorithm's performance, especially if they can be providing
    more business value doing something else.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 客户更喜欢花费更多金钱使用某种类型的云资源来解决性能问题，而不是花费宝贵的时间优化算法的性能，这种情况并不少见，尤其是如果他们可以通过做其他事情提供更多商业价值的话。
- en: Apart from the machine-time versus human-time trade-off mentioned earlier, there
    are other considerations when deciding whether to optimize an algorithm's implementation
    or not. Do you want your code to be easily readable? Do you want your code to
    be shareable? It's often the case that more performant code is also more difficult
    to understand. Furthermore, if you're developing code that is executed parallelly,
    it will impose a bunch of restrictions on the type of systems that can execute
    it, and you need to keep that in mind.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 除了之前提到的机器时间与人类时间的权衡之外，在决定是否优化算法实现时，还有其他需要考虑的因素。你希望你的代码易于阅读吗？你希望你的代码可以共享吗？通常情况下，性能更好的代码也更难以理解。此外，如果你正在开发并行执行的代码，它将对可以执行它的系统类型施加一系列限制，你需要记住这一点。
- en: 'I suggest that you keep to the minimum number of optimizations; this will make
    you achieve your goal regarding how fast an implementation must run, and don''t
    do more than that. The process will be simple: find the most important bottleneck,
    remove it (or at least decrease its impact), check whether or not your implementation
    is fast enough, and if it''s not, repeat. We will go through this cycle a couple
    of times along this chapter, and even though it seems easy in retrospective, it
    can be quite difficult in reality, especially when dealing with complex algorithms.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你坚持最小化优化的数量；这将帮助你实现关于实现运行速度的目标，并且不要超过这个范围。这个过程将会很简单：找出最重要的瓶颈，移除它（或者至少减少其影响），检查你的实现是否足够快，如果不是，就重复这个过程。我们将在本章中多次经历这个循环，尽管在回顾时它看起来很简单，但在现实中可能会相当困难，尤其是在处理复杂算法时。
- en: Calculating simple moving averages inefficiently
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 低效地计算简单移动平均
- en: The algorithm we will work with for the rest of the chapter is called **simple
    moving average** (**SMA**). It's a very well-known tool for doing technical analysis
    of time-series, specially for financial markets and trading. The idea behind SMA
    is that you will compute an average at each point in time by looking back at a
    predefined number periods. For example, let's say you're looking at a minute-by-minute
    time-series, and you will compute an SMA(30). This means that at each observation
    in your time-series, you will take the observations that correspond to the previous
    30 minutes from starting at a specific observation (30 observations back), and
    will save the average for those 30 observations as the SMA(30) value for that
    point in time.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章剩余部分使用的算法被称为**简单移动平均**（**SMA**）。它是进行时间序列技术分析的一个非常著名的工具，特别是用于金融市场和交易。SMA背后的想法是，你将通过回顾预定义的周期数来计算每个时间点的平均值。例如，假设你正在查看每分钟的时间序列，并且你将计算SMA(30)。这意味着在你的时间序列中的每个观察点，你将取从特定观察点开始对应于之前30分钟的观察值（30个观察值），并将这些30个观察值的平均值保存为该时间点的SMA(30)值。
- en: In the later diagram, you can visualize the idea behind SMAs. The diagram shows
    a monotone time-series that increases by one value-unit for every time-unit, both
    of which start at one (that is, its value is **1** at time **1**, **2** at time
    **2**, and so on), along with some figures surrounding the group of observations
    the SMA calculation will take. As you can see, for SMA(3), we get the last three
    elements at every point in the time-series; similarly, for SMA(4), we get the
    last four elements. When you calculate the average for the subset of elements
    in the figure, you get the numbers in the top-left corners, which correspond to
    the specific SMA time-series calculated. Specifically for such a time-series,
    for the SMA(3) case, the result is NA, NA, **2**, **3**, **4**, **5**, **6**,
    **7**, and **8**, and for the SMA(4) case, the result is NA, NA, NA, **2.5**,
    **3.5**, **4.5**, **5.5**, **6.5**, and **7.5**.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的图中，你可以可视化SMA背后的思想。该图显示了一个单调递增的时间序列，每个时间单位增加一个值单位，两者都从1开始（也就是说，它在时间**1**的值是**1**，在时间**2**的值是**2**，依此类推），以及一些围绕SMA计算将采用的观察值组的图形。正如你所看到的，对于SMA(3)，我们在时间序列的每个点上得到最后三个元素；同样，对于SMA(4)，我们得到最后四个元素。当你计算图中元素子集的平均值时，你得到的是左上角的数字，这些数字对应于特定SMA时间序列的计算。具体来说，对于这样的时间序列，对于SMA(3)的情况，结果是NA，NA，**2**，**3**，**4**，**5**，**6**，**7**，和**8**，而对于SMA(4)的情况，结果是NA，NA，NA，**2.5**，**3.5**，**4.5**，**5.5**，**6.5**，和**7.5**。
- en: 'There are a couple of following properties we should note about SMAs:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 关于SMA，我们应该注意以下两个属性：
- en: First, note that both SMA(3) and SMA(4) are series that contain the same number
    of observations as the original time-series, **9** in this case.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，请注意，SMA(3)和SMA(4)都是包含与原始时间序列相同数量的观察值的序列，**9**个在这个例子中。
- en: Second, note that they both begin with a number of NA equal to the number SMA
    parameter minus one. This is because in the case of SMA(3), at time **2**, we
    don't have three observations back, we only have two. Therefore, an NA is used
    to indicate that SMA(3) could not be computed at that point. The same explanation
    applies to all other NA values.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二点，请注意，它们两者都以一个等于SMA参数减一的NA数量开始。这是因为，在SMA(3)的情况下，在时间**2**时，我们并没有三个观察值，我们只有两个。因此，使用NA来表示在那个点上无法计算SMA(3)。同样的解释适用于所有其他的NA值。
- en: Third and finally, note that every time we move one time-unit, we add one observation
    and remove another observation (the tail) from the current subset.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三点也是最后一点，请注意，每次我们移动一个时间单位，我们就会向当前子集中添加一个观察值，并移除另一个观察值（即尾部）。
- en: 'Take a look at the following figure depicting the preceding properties:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下描述先前属性的图：
- en: '![](img/00062.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00062.jpeg)'
- en: Simulating the time-series
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟时间序列
- en: Of course, you have been collecting data from cryptocurrency markets since you
    implemented your own version of the object-oriented system we developed in the
    last chapter, haven't you? I'm just kidding. If you have, it's probably not enough
    data for what we will do in this chapter, so here's a small piece of code that
    will simulate two time-series for Bitcoin and Litecoin price in US Dollars. The
    data structure is similar to the one used in the previous chapter, making the
    code we develop here useful for that system also.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，自从你实现了我们在上一章开发的面向对象系统的个人版本以来，你一直在收集加密货币市场的数据，对吧？我只是在开玩笑。如果你已经这样做了，那么可能对于我们将在本章中要做的事情来说，数据量可能还不够，所以这里有一小段代码，它将模拟比特币和莱特币的美元价格的两个时间序列。数据结构类似于上一章中使用的结构，这使得我们在这里开发的代码对于那个系统也是有用的。
- en: 'We won''t go too deep into how the function works since it should be clear
    for you at this point, except to point out that we''re using the `time_to_timestamp.TimeStamp()`
    function we developed in the last chapter, and that the `simulate_prices()` function
    uses a quadratic model on top of an ARIMA simulation. If you don''t know what
    an ARIMA model is, don''t worry too much about it (it''s not needed to understand
    this chapter). If you''re interested in learning more about it, take a look at
    Shumway and Stoffer''s book, *Time Series Analysis and Its Applications: With
    R Examples, Springer, 2011*. We are using a quadratic model because Bitcoin''s
    price has been accelerating during the past couple of months (this is being written
    during November 2017). Let''s take a look at the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入探讨函数的工作原理，因为此时你应该已经很清楚，除了指出我们正在使用我们在上一章中开发的`time_to_timestamp.TimeStamp()`函数，以及`simulate_prices()`函数在ARIMA模拟之上使用二次模型。如果你不知道ARIMA模型是什么，不必过于担心（它对本章的理解不是必需的）。如果你对它感兴趣并想了解更多，可以查看Shumway和Stoffer的书籍，《时间序列分析及其应用：带R示例，Springer，2011》。我们使用二次模型是因为比特币的价格在过去几个月中一直在加速（本书在2017年11月撰写）。让我们看一下以下代码：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that the parameters used to call the `simulate_market()` function try to
    resemble what is seen currently in Bitcoin and Litecoin prices, but keep in mind
    that this is a very simple model, so don't expect it to behave as the actual price
    time-series for these assets. Finally, we simulate 525,600 observations for each
    asset, which is approximately equal to the number of minutes in a year (`N <-
    60 * 24 * 365`, which contains seconds per hour, hours per day, and days per year).
    This means we're simulating minute-by-minute data.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，用于调用`simulate_market()`函数的参数试图与目前比特币和莱特币价格中看到的情况相似，但请记住，这是一个非常简单的模型，所以不要期望它像这些资产的实际价格时间序列那样表现。最后，我们对每个资产模拟了525,600个观察值，这大约等于一年中的分钟数（`N
    <- 60 * 24 * 365`，其中包含每小时的秒数、每天的小时数和每年的天数）。这意味着我们正在模拟每分钟的数据。
- en: 'To visualize the Bitcoin prices we simulated, you may use the following code.
    It simply produces one graph that uses a sample of 1,000 elements throughout the
    year (more than that is unnecessary, since you won''t be able to perceive more
    points, and it will slow down the calculations); also, another graph is produced,
    which shows a zoom-in effect into the first hour in the data:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化我们模拟的比特币价格，你可以使用以下代码。它简单地生成一个图表，使用全年的1,000个样本元素（更多的元素是不必要的，因为你无法感知更多的点，而且会减慢计算速度）；此外，还会生成另一个图表，它展示了数据中第一小时的放大效果：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As can be seen, there''s a strong upward trend when looking at the full year
    simulation, but if you zoom-in into a smaller time frame, you''ll see quite a
    bit of price variance, which allows for useful SMA implementations. Let''s take
    a look at the following graph:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，在查看全年的模拟时，存在一个明显的上升趋势，但如果你将时间范围缩小，你会看到相当多的价格波动，这允许进行有用的简单移动平均（SMA）实现。让我们看一下以下图表：
- en: '![](img/00063.jpeg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00063.jpeg)'
- en: Our first (very inefficient) attempt at an SMA
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们对SMA的第一个（非常低效）尝试
- en: 'As was mentioned earlier, we will work with SMA implementations for the rest
    of the chapter. To differentiate among them, we will change the function name
    for each subsequent implementation, starting with `sma_slow_1()`. All SMA implementations
    will receive the following parameters:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将在本章的剩余部分使用SMA实现。为了区分它们，我们将为每个后续实现更改函数名称，从`sma_slow_1()`开始。所有SMA实现都将接收以下参数：
- en: '`period`: To specify how many observations to use for the SMA.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`period`：指定用于SMA的观察值数量。'
- en: '`symbol`: To denote the asset we want to make the calculations for'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`symbol`：表示我们想要进行计算的资产'
- en: For this example, options will be  `BTC` for `Bitcoin` or `LTC` for `Litecoin`.
    However, when you execute the system yourself, you'll be able to expand it with
    any cryptocurrency symbol you so desire.
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个例子中，选项将是`BTC`表示比特币或`LTC`表示莱特币。然而，当你自己执行系统时，你可以根据需要将其扩展到任何加密货币符号。
- en: '`data`: The actual data that contains the price time-series for every asset.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`：包含每个资产价格时间序列的实际数据。'
- en: We will make two assumptions on `data`—the `timestamp` column is in increasing
    order and we don't have gaps in the time-series, meaning that we have price data
    for every minute. This allows us to skip any ordering procedures and check whether
    the SMA should contain NA internally when no data is available. Note that both
    these assumptions are fulfilled by our data simulation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对 `data` 做两个假设——`timestamp` 列是递增的，并且时间序列中没有空缺，这意味着我们每分钟都有价格数据。这允许我们跳过任何排序程序，并检查当没有数据时
    SMA 是否应该内部包含 `NA`。请注意，这两个假设都由我们的数据模拟满足。
- en: 'Now, we''ll explain how `sma_slow_1()` works. Note that this is a very inefficient
    implementation, and you should definitely avoid programming this way. However,
    these are common errors people make, and we will be removing them one by one while
    we measure the impact they actually have on your code''s speed. Let''s see how
    it is done by performing the following steps:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将解释 `sma_slow_1()` 函数是如何工作的。请注意，这是一个非常低效的实现，你绝对应该避免以这种方式编程。然而，这些是人们常犯的错误，在我们测量它们对代码速度的实际影响时，我们将逐一移除它们。让我们通过以下步骤来查看它是如何完成的：
- en: First, we create an empty data frame named `result` that contains a single column
    called `sma`.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为 `result` 的空数据框，它包含一个名为 `sma` 的单列。
- en: Then, we loop over all rows in the data; `end` denotes the end, or right-extreme,
    of the SMA interval under consideration.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们遍历数据中的所有行；`end` 表示正在考虑的简单移动平均（SMA）区间的结束，或右端点。
- en: We create a `position` integer that is the same as the `end` every time we start
    the loop as well as an `sma` object that will contain the actual SMA computation
    for the end position, an `n_accumulated` integer that keeps track of the number
    of observations we have accumulated, and a `period_prices` data frame that contains
    a single column to store the prices for the current SMA calculation.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个 `position` 整数，每次开始循环时它与 `end` 相同，以及一个 `sma` 对象，它将包含实际 SMA 计算的末尾位置，一个
    `n_accumulated` 整数，用于跟踪我们累积的观测值数量，以及一个 `period_prices` 数据框，它包含一个单列来存储当前 SMA 计算的价格。
- en: Next, we check whether the observation at the current `end` corresponds to the
    `symbol` we're interested in. If it's not, we simply ignore that iteration, but
    if it is, we will accumulate `period_prices` starting at the `end` position (remember
    that `position` is equal to `end` and this point) and going backward until the
    number of accumulated prices is equal to the `period` we're interested in or the
    current `position` is lower than 1 (meaning that we're at the beginning of the
    time-series). To do so, we use a while-loop that checks for the condition mentioned
    before, increases `n_accumulated` when an observation with the same `symbol` is
    found and its data is appended to the `period_prices` data frame, and increases
    the `position` regardless of whether the observation was useful so that we don't
    get stuck.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们检查当前 `end` 位置的观测值是否对应于我们感兴趣的 `symbol`。如果不是，我们简单地忽略这次迭代，但如果它是，我们将从 `end`
    位置开始累积 `period_prices`，向后直到累积的价格数量等于我们感兴趣的 `period` 或当前 `position` 低于 1（这意味着我们处于时间序列的开始）。为此，我们使用一个
    while 循环来检查之前提到的条件，当找到具有相同 `symbol` 的观测值并将其数据附加到 `period_prices` 数据框时，增加 `n_accumulated`，并且无论观测值是否有用，都增加
    `position`，这样我们才不会陷入困境。
- en: 'After the while-loop is finished, we know that we have either accumulated a
    number of prices equal to the `period` we are interested in or we encountered
    the beginning of the time-series. In the first case, we compute the mean of such
    prices by iterating over the `period_prices` data frame, and assign that as the
    `sma` value for the current `end` position. In the second case, we simply record
    an `NA` value since we were not able to compute the full SMA. Take a look at the
    following code snippet:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 while 循环完成后，我们知道我们已经累积了等于我们感兴趣的 `period` 的价格数量，或者我们遇到了时间序列的开始。在前一种情况下，我们通过遍历
    `period_prices` 数据框来计算这些价格的均值，并将其作为当前 `end` 位置的 `sma` 值。在第二种情况下，我们简单地记录一个 `NA`
    值，因为我们无法计算完整的 SMA。请看以下代码片段：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If the implementation seems complicated, it's because it is. As we start improving
    our code, it will naturally be simplified, which will make it easier to understand.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实现看起来很复杂，那是因为它确实如此。当我们开始改进我们的代码时，它自然会简化，这将使其更容易理解。
- en: 'Now, we want to actually see that it works. To do so, we bring the `sma-slow.R`
    file into memory (which contains all the slow implementations) as well as the
    data as shown in the following code snippet:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们想要真正看到它是否工作。为此，我们将`sma-slow.R`文件（其中包含所有慢速实现）以及数据载入内存（如下代码片段所示）：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Note that we take only the first 100 observations, which correspond to 50 minutes
    of Bitcoin price action (remember that these 100 observations only contain 50
    for Bitcoin; the other 50 are for Litecoin). We can see that the SMA(5) for Bitcoin
    makes sense, including the first four NA (feel free to check the numbers by hand,
    but remember to use the data and results for your own data simulation):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只取前100个观测值，这对应于50分钟的比特币价格波动（记住这100个观测值中只有50个是比特币的；其他50个是莱特币的）。我们可以看到，比特币的SMA(5)是有意义的，包括前四个NA（你可以手动检查这些数字，但请记住使用你自己的数据模拟的数据和结果）：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Before we understand how to fix this code, we need to understand why R can be
    slow as well as how to measure how much of an impact we're having while we are
    improving it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们了解如何修复这段代码之前，我们需要了解为什么R可能会慢，以及如何衡量我们在改进它时所产生的影响。
- en: Understanding why R can be slow
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解为什么R可能会慢
- en: Understanding why a programming language can be slow is a fundamental skill
    needed to be able to increase the speed of its implementations. Any implementation
    in any programming language is similarly affected by an algorithm's time and memory
    complexities, because they are algorithms, and not implementation properties.
    However, the way languages handle specific implementations can vary quite a bit,
    and that's what we'll focus on now.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 理解为什么一种编程语言可能会慢，是能够提高其实现速度的基本技能。任何编程语言中的任何实现都会受到算法的时间和内存复杂性的影响，因为它们是算法，而不是实现属性。然而，语言处理特定实现的方式可能会有很大差异，这就是我们现在要关注的。
- en: 'In the case of R, people often find the following four main bottlenecks:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在R的情况下，人们经常发现以下四个主要瓶颈：
- en: Object immutability
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象不可变性
- en: Interpreted dynamic typings
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释型动态类型
- en: Memory-bound processes
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存密集型进程
- en: Single-threaded processes
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单线程进程
- en: By no means is this list complete or encountered in every implementation. It's
    just the most common bottlenecks I've seen people encounter, and which, after
    being fixed, produced the largest amount of speed improvements. They are often
    good starting points, but every implementation is different, so it's very difficult
    to suggest general rules for performance optimization, and you should keep this
    in mind.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对不能说这个列表是完整的，或者在每个实现中都会遇到。这仅仅是我看到人们遇到的最常见的瓶颈，而且这些瓶颈在修复后，产生了最大的速度提升。它们通常是很好的起点，但每个实现都是不同的，因此很难提出通用的性能优化规则，你应该记住这一点。
- en: Object immutability
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象不可变性
- en: Improving the speed of R implementations does not necessarily involve advanced
    optimization techniques, such as parallelization. Indeed, there are a number of
    simple tweaks that, while not always obvious, can make R run significantly faster.
    The top bottleneck people encounter with R is a lack of understanding about its
    object immutability property, and the overhead incurred when making copies of
    such objects. Simply taking care of this can produce dramatic performance improvements,
    and it's not too difficult once you understand how to do so. This is a good candidate
    to start looking for optimizations.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 提高R实现的性能并不一定需要高级优化技术，例如并行化。实际上，有一些简单的调整，虽然并不总是显而易见，但可以使R运行得更快。人们在使用R时遇到的最常见的瓶颈是对其对象不可变性属性缺乏理解，以及复制此类对象时产生的开销。仅仅注意这一点就可以产生显著的性能提升，一旦你了解了如何做到这一点，这并不太难。这是一个很好的起点，开始寻找优化。
- en: 'As an example of some of the issues that can arise, suppose you have an array
    of numbers named `a`. Now, suppose you want to update first element of `a` to
    be `10`, as shown in the following code snippet:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 作为可能出现的一些问题的例子，假设你有一个名为`a`的数字数组。现在，假设你想要将`a`的第一个元素更新为`10`，如下代码片段所示：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This assignment is much more complex than it seems. It is actually implemented
    via the `` `"[<-"` `` replacement function through this call and assignment:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务比看起来要复杂得多。实际上，它是通过这个调用和赋值中的`` `"[<-"` ``替换函数来实现的：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: At first, you may find this to be a very weird syntax, but remember that, as
    we saw in [Chapter 1](part0022.html#KVCC0-f494c932c729429fb734ce52cafce730), *Introduction
    to R*, we can have strings that represent objects, including functions, as is
    the case here. The [PRE11]
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，你可能觉得这种语法非常奇怪，但记住，正如我们在[第1章](part0022.html#KVCC0-f494c932c729429fb734ce52cafce730)“R语言简介”中看到的，我们可以有表示对象（包括函数）的字符串，就像这里的情况一样。[PRE11]
- en: Rprof()
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Rprof()
- en: sma_1 <- sma_slow_1(period, symbol, data_original[1:10000, ])
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: sma_1 <- sma_slow_1(period, symbol, data_original[1:10000, ])
- en: Rprof(NULL)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Rprof(NULL)
- en: summaryRprof()
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: summaryRprof()
- en: '#> $by.self'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '#> $by.self'
- en: '#>                         self.time self.pct total.time total.pct'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '#>                         self.time self.pct total.time total.pct'
- en: '#> "rbind"                      1.06    10.84       6.16     62.99'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '#> "rbind"                      1.06    10.84       6.16     62.99'
- en: '#> "structure"                  0.82     8.38       0.94      9.61'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '#> "structure"                  0.82     8.38       0.94      9.61'
- en: '#> "data.frame"                 0.68     6.95       4.32     44.17'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '#> "data.frame"                 0.68     6.95       4.32     44.17'
- en: '#> "[.data.frame"               0.54     5.52       1.76     18.00'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '#> "[.data.frame"               0.54     5.52       1.76     18.00'
- en: '#> "sma_slow_1"                 0.48     4.91       9.78    100.00'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '#> "sma_slow_1"                 0.48     4.91       9.78    100.00'
- en: '#> (Truncated output)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '#> (输出截断)'
- en: '#>'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '#>'
- en: '#> $by.total'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '#> $by.total'
- en: '#>                         total.time total.pct self.time self.pct'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '#>                         total.time total.pct self.time self.pct'
- en: '#> "sma_slow_1"                  9.78    100.00      0.48     4.91'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '#> "sma_slow_1"                  9.78    100.00      0.48     4.91'
- en: '#> "rbind"                       6.16     62.99      1.06    10.84'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '#> "rbind"                       6.16     62.99      1.06    10.84'
- en: '#> "data.frame"                  4.32     44.17      0.68     6.95'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '#> "data.frame"                  4.32     44.17      0.68     6.95'
- en: '#> "["                           1.88     19.22      0.20     2.04'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '#> "["                           1.88     19.22      0.20     2.04'
- en: '#> "as.data.frame"               1.86     19.02      0.10     1.02'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '#> "as.data.frame"               1.86     19.02      0.10     1.02'
- en: '#> (Truncated output)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '#> (输出截断)'
- en: '#>'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '#>'
- en: '#> $sample.interval'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '#> $sample.interval'
- en: '#> [1] 0.02'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '#> [1] 0.02'
- en: '#>'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '#>'
- en: '#> $sampling.time'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '#> $sampling.time'
- en: '#> [1] 9.78'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '#> [1] 9.78'
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: system.time(sma_slow_1(period, symbol, data_original[1:10000, ]))
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: system.time(sma_slow_1(period, symbol, data_original[1:10000, ]))
- en: '#>   user  system elapsed'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '#>   user  system elapsed'
- en: '#>  9.251   0.015   9.277'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '#> 9.251   0.015   9.277'
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: performance <- microbenchmark(
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: performance <- microbenchmark(
- en: sma_1 <- sma_slow_1(period, symbol, data),
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: sma_1 <- sma_slow_1(period, symbol, data),
- en: unit = "us"
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: unit = "us"
- en: )
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: summary(performance)$median
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: summary(performance)$median
- en: '#> [1] 81035.19'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '#> [1] 81035.19'
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: sma_slow_2 <- function(period, symbol, data) {
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: sma_slow_2 <- function(period, symbol, data) {
- en: result <- data.frame(sma=numeric())
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: result <- data.frame(sma=numeric())
- en: for(end in 1:nrow(data)) {
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: for(end in 1:nrow(data)) {
- en: position <- end
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: position <- end
- en: sma <- NA
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: sma <- NA
- en: n_accumulated <- 0
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: n_accumulated <- 0
- en: period_prices <- NULL
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: period_prices <- NULL
- en: if(data[end, "symbol"] == symbol) {
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果(data[end, "symbol"] == symbol) {
- en: while(n_accumulated < period & position >= 1) {
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: while(n_accumulated < period & position >= 1) {
- en: if(data[position, "symbol"] == symbol) {
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: if(data[position, "symbol"] == symbol) {
- en: period_prices <- c(period_prices,
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: period_prices <- c(period_prices,
- en: data[position, "price_usd"])
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: data[position, "price_usd"])
- en: n_accumulated <- n_accumulated + 1
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: n_accumulated <- n_accumulated + 1
- en: '}'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: position <- position - 1
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: position <- position - 1
- en: '}'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: if (n_accumulated == period) {
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (n_accumulated == period) {
- en: sma <- 0
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: sma <- 0
- en: for (price in period_prices) {
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: for (price in period_prices) {
- en: sma <- sma + price
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: sma <- sma + price
- en: '}'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: sma <- sma / period
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: sma <- sma / period
- en: '} else {'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '} else {'
- en: sma <- NA
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: sma <- NA
- en: '}'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: result <- rbind(result, data.frame(sma=sma))
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: result <- rbind(result, data.frame(sma=sma))
- en: '}'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: return(result)
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return(result)
- en: '}'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE15]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: performance <- microbenchmark(
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: performance <- microbenchmark(
- en: sma_2 <- sma_slow_2(period, symbol, data),
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: sma_2 <- sma_slow_2(period, symbol, data),
- en: unit = "us"
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: unit = "us"
- en: )
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: all(sma_1$sma == sma_2$sma, na.rm = TRUE)
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: all(sma_1$sma == sma_2$sma, na.rm = TRUE)
- en: '#> TRUE'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '#> TRUE'
- en: summary(performance)$median
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: summary(performance)$median
- en: '#> [1] 33031.7785'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '#> [1] 33031.7785'
- en: '[PRE16]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: performance <- microbenchmark(
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: performance <- microbenchmark(
- en: sma_3 <- sma_slow_3(period, symbol, data),
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: sma_3 <- sma_slow_3(period, symbol, data),
- en: unit = "us"
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: unit = "us"
- en: )
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: all(sma_1$sma - sma_3 <= 0.001, na.rm = TRUE)
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: all(sma_1$sma - sma_3 <= 0.001, na.rm = TRUE)
- en: '#> TRUE'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '#> TRUE'
- en: summary(performance)$median
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: summary(performance)$median
- en: '#> [1] 19628.243'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '#> [1] 19628.243'
- en: '[PRE17]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: sma_slow_4 <- function(period, symbol, data) {
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: sma_slow_4 <- function(period, symbol, data) {
- en: result <- NULL
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: result <- NULL
- en: for(end in 1:nrow(data)) {
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: for(end in 1:nrow(data)) {
- en: position <- end
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: position <- end
- en: sma <- NA
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: sma <- NA
- en: n_accumulated <- 0
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: n_accumulated <- 0
- en: period_prices <- NULL
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: period_prices <- NULL
- en: if (data[end, "symbol"] == symbol) {
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (data[end, "symbol"] == symbol) {
- en: while(n_accumulated < period & position >= 1) {
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: while(n_accumulated < period & position >= 1) {
- en: if (data[position, "symbol"] == symbol) {
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (data[position, "symbol"] == symbol) {
- en: period_prices <- c(period_prices,
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: period_prices <- c(period_prices,
- en: data[position, "price_usd"])
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: data[position, "price_usd"])
- en: n_accumulated <- n_accumulated + 1
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: n_accumulated <- n_accumulated + 1
- en: '}'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: position <- position - 1
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: position <- position - 1
- en: '}'
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: if (n_accumulated == period) {
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (n_accumulated == period) {
- en: sma <- mean(period_prices)
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: sma <- mean(period_prices)
- en: '} else {'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '} else {'
- en: sma <- NA
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: sma <- NA
- en: '}'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: result <- c(result, sma)
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: result <- c(result, sma)
- en: '}'
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: return(result)
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return(result)
- en: '}'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE18]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: performance <- microbenchmark(
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: performance <- microbenchmark(
- en: sma_4 <- sma_slow_4(period, symbol, data),
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: sma_4 <- sma_slow_4(period, symbol, data),
- en: unit = "us"
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: unit = "us"
- en: )
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: all(sma_1$sma - sma_4 <= 0.001, na.rm = TRUE)
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: all(sma_1$sma - sma_4 <= 0.001, na.rm = TRUE)
- en: '#> TRUE'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '#> TRUE'
- en: summary(performance)$median
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: summary(performance)$median
- en: '#> [1] 20825.8790'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '#> [1] 20825.8790'
- en: '[PRE19]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: x <- sample(100)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: x <- sample(100)
- en: performance <- microbenchmark(
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: performance <- microbenchmark(
- en: mean(x),
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: mean(x),
- en: sum(x) / length(x),
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: sum(x) / length(x),
- en: .Internal(mean(x)),
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: .Internal(mean(x)),
- en: times = 1e+05
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: times = 1e+05
- en: )
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: performance
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: performance
- en: '#> Unit: nanoseconds'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '#> Unit: nanoseconds'
- en: '#>                expr  min   lq      mean median   uq      max neval'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '#>                expr  min   lq      mean median   uq      max neval'
- en: '#>             mean(x) 1518 1797 2238.2607   1987 2230  2335285 1e+05'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '#>             mean(x) 1518 1797 2238.2607   1987 2230  2335285 1e+05'
- en: '#>    sum(x)/length(x)  291  345  750.2324    403  488 27016544 1e+05'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '#>    sum(x)/length(x)  291  345  750.2324    403  488 27016544 1e+05'
- en: '#>  .Internal(mean(x))  138  153  187.0588    160  176    34513 1e+05'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '#>  .Internal(mean(x))  138  153  187.0588    160  176    34513 1e+05'
- en: '[PRE20]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: sma_slow_5 <- function(period, symbol, data) {
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: sma_slow_5 <- function(period, symbol, data) {
- en: result <- NULL
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: result <- NULL
- en: for(end in 1:nrow(data)) {
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: for(end in 1:nrow(data)) {
- en: position <- end
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: position <- end
- en: sma <- 0
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: sma <- 0
- en: n_accumulated <- 0
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: n_accumulated <- 0
- en: if (data[end, "symbol"] == symbol) {
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (data[end, "symbol"] == symbol) {
- en: while(n_accumulated < period & position >= 1) {
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: while(n_accumulated < period & position >= 1) {
- en: if (data[position, "symbol"] == symbol) {
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (data[position, "symbol"] == symbol) {
- en: sma <- sma + data[position, "price_usd"]
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: sma <- sma + data[position, "price_usd"]
- en: n_accumulated <- n_accumulated + 1
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: n_accumulated <- n_accumulated + 1
- en: '}'
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: position <- position - 1
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: position <- position - 1
- en: '}'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: if (n_accumulated == period) {
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (n_accumulated == period) {
- en: sma <- sma / period
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: sma <- sma / period
- en: '} else {'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '} else {'
- en: sma <- NA
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: sma <- NA
- en: '}'
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: result <- c(result, sma)
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: result <- c(result, sma)
- en: '}'
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: return(result)
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return(result)
- en: '}'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE21]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: performance <- microbenchmark(
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: performance <- microbenchmark(
- en: sma_5 <- sma_slow_5(period, symbol, data),
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: sma_5 <- sma_slow_5(period, symbol, data),
- en: unit = "us"
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: unit = "us"
- en: )
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: all(sma_1$sma - sma_5 <= 0.001, na.rm = TRUE)
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: all(sma_1$sma - sma_5 <= 0.001, na.rm = TRUE)
- en: '#> TRUE'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '#> TRUE'
- en: summary(performance)$median
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: summary(performance)$median
- en: '#> [1] 16682.68'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '#> [1] 16682.68'
- en: '[PRE22]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Rprof()
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Rprof()
- en: sma_5 <- sma_slow_5(period, symbol, data_original[1:10000, ])
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: sma_5 <- sma_slow_5(period, symbol, data_original[1:10000, ])
- en: Rprof(NULL)
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Rprof(NULL)
- en: summaryRprof()
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: summaryRprof()
- en: '#> $by.self'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '#> $by.self'
- en: '#>                self.time self.pct total.time total.pct'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '#>                self.time self.pct total.time total.pct'
- en: '#> "[.data.frame"      0.54    26.21       1.24     60.19'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '#> "[.data.frame"      0.54    26.21       1.24     60.19'
- en: '#> "["                 0.22    10.68       1.34     65.05'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '#> "["                 0.22    10.68       1.34     65.05'
- en: '#> "NextMethod"        0.20     9.71       0.20      9.71'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '#> "NextMethod"        0.20     9.71       0.20      9.71'
- en: '#> "sma_slow_5"        0.14     6.80       2.06    100.00'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '#> "sma_slow_5"        0.14     6.80       2.06    100.00'
- en: '#> "Ops.factor"        0.12     5.83       0.52     25.24'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '#> "Ops.factor"        0.12     5.83       0.52     25.24'
- en: '#> (Truncated output)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '#> (Truncated output)'
- en: '#>'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '#>'
- en: '#> $by.total'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '#> $by.total'
- en: '#>                  total.time total.pct self.time self.pct'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '#>                  total.time total.pct self.time self.pct'
- en: '#> "sma_slow_5"           2.06    100.00      0.14     6.80'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '#> "sma_slow_5"           2.06    100.00      0.14     6.80'
- en: '#> "["                    1.34     65.05      0.22    10.68'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '#> "["                    1.34     65.05      0.22    10.68'
- en: '#> "[.data.frame"         1.24     60.19      0.54    26.21'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '#> "[.data.frame"         1.24     60.19      0.54    26.21'
- en: '#> "Ops.factor"           0.52     25.24      0.12     5.83'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '#> "Ops.factor"           0.52     25.24      0.12     5.83'
- en: '#> "NextMethod"           0.20      9.71      0.20     9.71'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '#> "NextMethod"           0.20      9.71      0.20     9.71'
- en: '#> (Truncated output)'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '#> (Truncated output)'
- en: '[PRE23]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: performance <- microbenchmark(
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: performance <- microbenchmark(
- en: sma_6 <- sma_slow_6(period, symbol, data),
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: sma_6 <- sma_slow_6(period, symbol, data),
- en: unit = "us"
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: unit = "us"
- en: )
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: all(sma_1$sma - sma_6 <= 0.001, na.rm = TRUE)
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: all(sma_1$sma - sma_6 <= 0.001, na.rm = TRUE)
- en: '#> TRUE'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '#> TRUE'
- en: summary(performance)$median
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: summary(performance)$median
- en: '#> [1] 2991.5720'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '#> [1] 2991.5720'
- en: '[PRE24]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: sma_slow_7 <- function(period, symbol, data) {
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: sma_slow_7 <- function(period, symbol, data) {
- en: data <- data[data$symbol == symbol, ]
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: data <- data[data$symbol == symbol, ]
- en: result <- NULL
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: result <- NULL
- en: for(end in 1:nrow(data)) {
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: for(end in 1:nrow(data)) {
- en: start <- end - period + 1
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: start <- end - period + 1
- en: if (start >= 1) {
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (start >= 1) {
- en: sma <- mean(data[start:end, "price_usd"])
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: sma <- mean(data[start:end, "price_usd"])
- en: '} else {'
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '} else {'
- en: sma <- NA
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: sma <- NA
- en: '}'
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: result <- c(result, sma)
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: result <- c(result, sma)
- en: '}'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: return(result)
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return(result)
- en: '}'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE25]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: performance <- microbenchmark(
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: performance <- microbenchmark(
- en: sma_7 <- sma_slow_7(period, symbol, data),
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: sma_7 <- sma_slow_7(period, symbol, data),
- en: unit = "us"
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: unit = "us"
- en: )
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: all(sma_1$sma - sma_7 <= 0.001, na.rm = TRUE)
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: all(sma_1$sma - sma_7 <= 0.001, na.rm = TRUE)
- en: '#> TRUE'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '#> TRUE'
- en: summary(performance)$median
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: summary(performance)$median
- en: '#> [1] 910.793'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '#> [1] 910.793'
- en: '[PRE26]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: sma_efficient_1 <- function(period, symbol, data) {
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: sma_efficient_1 <- function(period, symbol, data) {
- en: data <- data[data$symbol == symbol, ]
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return(unlist(lapply(1:nrow(data),
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sma_from_position_1,
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: period, data)))
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: sma_from_position_1 <- function(end, period, data) {
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: start <- end - period + 1
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return(ifelse(start >= 1,
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mean(data[start:end, "price_usd"]), NA))
  id: totrans-341
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: performance <- microbenchmark(
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: sma_8 <- sma_efficient_1(period, symbol, data),
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: unit = "us"
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: all(sma_1$sma - sma_8 <= 0.001, na.rm = TRUE)
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '#> TRUE'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: summary(performance)$median
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '#> [1] 1137.704'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: sma_efficient_2 <- function(period, symbol, data) {
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: data <- data[data$symbol == symbol, "price_usd"]
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return(unlist(lapply(1:length(data),
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sma_from_position_2,
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: period, data)))
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: sma_from_position_2 <- function(end, period, data) {
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: start <- end - period + 1
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return(ifelse(start >= 1, sum(data[start:end]) / period, NA))
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: performance <- microbenchmark(
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: sma_9 <- sma_efficient_2(period, symbol, data),
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: unit = "us"
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: all(sma_1$sma - sma_9 <= 0.001, na.rm = TRUE)
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '#> TRUE'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: summary(performance)$median
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '#> [1] 238.2425'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Rprof()
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: sma_9 <- sma_efficient_2(period, symbol, data_original[1:10000, ])
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: Rprof(NULL)
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: summaryRprof()
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '#> $by.self'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '#>          self.time self.pct total.time total.pct'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '#> "ifelse"      0.02      100       0.02       100'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '#>'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '#> $by.total'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '#>                   total.time total.pct self.time self.pct'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '#> "ifelse"                0.02       100      0.02      100'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '#> "FUN"                   0.02       100      0.00        0'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '#> "lapply"                0.02       100      0.00        0'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '#> "sma_efficient_2"       0.02       100      0.00        0'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '#> "unlist"                0.02       100      0.00        0'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: library(parallel)
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: sma_parallel_inefficient <- function(period, symbol, data) {
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: data <- as.numeric(data[data$symbol == symbol, "price_usd"])
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cluster <- makeCluster(detectCores())
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: result <- unlist(parLapply(
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cluster, 1:length(data), sma_from_position_2, period, data))
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: stopCluster(cluster)
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return(result)
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: performance <- microbenchmark(
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: sma_10 <- sma_parallel_inefficient(period, symbol, data),
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: unit = "us"
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: all(sma_1$sma - sma_10 <= 0.001, na.rm = TRUE)
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '#> TRUE'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: summary(performance)$median
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '#> [1] 1197329.3980'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: sma_parallel <- function(period, symbol, data, cluster) {
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: data <- as.numeric(data[data$symbol == symbol, "price_usd"])
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return(unlist(parLapply(
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cluster, 1:length(data), sma_from_position_2, period, data)))
  id: totrans-411
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: cluster <- makeCluster(detectCores())
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: performance <- microbenchmark(
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: sma_11 <- sma_parallel(period, symbol, data, cluster),
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: unit = "us"
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: all(sma_1$sma - sma_11 <= 0.001, na.rm = TRUE)
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '#> TRUE'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: summary(performance)$median
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '#> [1] 44825.9355'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: subroutine sma_fortran(period, dataa, smas, n)
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: integer pos, n, endd, period
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: real dataa(n), smas(n), sma
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: do 10 endd = 1, n
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: pos = endd
  id: totrans-428
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: sma = 0.0
  id: totrans-429
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: do 20 while ((endd - pos .lt. period) .and. (pos .ge. 1))
  id: totrans-430
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: sma = sma + dataa(pos)
  id: totrans-431
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: pos = pos - 1
  id: totrans-432
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 20      end do
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: if (endd - pos .eq. period) then
  id: totrans-434
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: sma = sma / period
  id: totrans-435
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: else
  id: totrans-436
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: sma = 0
  id: totrans-437
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: end if
  id: totrans-438
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: smas(endd) = sma
  id: totrans-439
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 10  continue
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: end
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: $ gfortran -c sma-delegated-fortran.f -o sma-delegated-fortran.so
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: system("R CMD SHLIB sma-delegated-fortran.f")
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: system("R CMD SHLIB sma-delegated-fortran.f")
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: system("R CMD SHLIB sma-delegated-fortran.f")
- en: dyn.load("sma-delegated-fortran.so")
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: dyn.load("sma-delegated-fortran.so")
- en: sma_delegated_fortran <- function(period, symbol, data) {
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: sma_delegated_fortran <- function(period, symbol, data) {
- en: data <- data[which(data$symbol == symbol), "price_usd"]
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: data <- data[which(data$symbol == symbol), "price_usd"]
- en: n <- length(data)
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: n <- length(data)
- en: results <- .Fortran(
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: results <- .Fortran(
- en: '"sma_fortran",'
  id: totrans-453
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"sma_fortran",'
- en: period = as.integer(period),
  id: totrans-454
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: period = as.integer(period),
- en: dataa = as.single(data),
  id: totrans-455
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: dataa = as.single(data),
- en: smas = single(n),
  id: totrans-456
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: smas = single(n),
- en: n = as.integer(n)
  id: totrans-457
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: n = as.integer(n)
- en: )
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: )
- en: return(as.numeric(results$smas))
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return(as.numeric(results$smas))
- en: '}'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE39]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: performance <- microbenchmark(
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: performance <- microbenchmark(
- en: sma_12 <- sma_delegated_fortran(period, symboo, data),
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: sma_12 <- sma_delegated_fortran(period, symboo, data),
- en: unit = "us"
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: unit = "us"
- en: )
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: all(sma_1$sma - sma_12 <= 0.001, na.rm = TRUE)
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: all(sma_1$sma - sma_12 <= 0.001, na.rm = TRUE)
- en: '#> TRUE'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '#> TRUE'
- en: summary(performance)$median
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: summary(performance)$median
- en: '#> [1] 148.0335'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '#> [1] 148.0335'
- en: '[PRE40]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '#include'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '#include'
- en: using namespace Rcpp;
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: using namespace Rcpp;
- en: // [[Rcpp::export(sma_delegated_cpp)]]
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: // [[Rcpp::export(sma_delegated_cpp)]]
- en: NumericVector smaDelegated(int period, NumericVector data) {
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: NumericVector smaDelegated(int period, NumericVector data) {
- en: int position, n = data.size();
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: int position, n = data.size();
- en: NumericVector result(n);
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: NumericVector result(n);
- en: double sma;
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: double sma;
- en: for (int end = 0; end < n; end++) {
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: for (int end = 0; end < n; end++) {
- en: position = end;
  id: totrans-479
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: position = end;
- en: sma = 0;
  id: totrans-480
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: sma = 0;
- en: while(end - position < period && position >= 0) {
  id: totrans-481
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: while(end - position < period && position >= 0) {
- en: sma = sma + data[position];
  id: totrans-482
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: sma = sma + data[position];
- en: position = position - 1;
  id: totrans-483
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: position = position - 1;
- en: '}'
  id: totrans-484
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: if (end - position == period) {
  id: totrans-485
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (end - position == period) {
- en: sma = sma / period;
  id: totrans-486
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: sma = sma / period;
- en: '} else {'
  id: totrans-487
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '} else {'
- en: sma = NA_REAL;
  id: totrans-488
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: sma = NA_REAL;
- en: '}'
  id: totrans-489
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: result[end] = sma;
  id: totrans-490
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: result[end] = sma;
- en: '}'
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: return result;
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return result;
- en: '}'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE41]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: library(Rcpp)
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: library(Rcpp)
- en: sourceCpp("./sma-delegated-cpp.cpp")
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: sourceCpp("./sma-delegated-cpp.cpp")
- en: sma_delegated_cpp <- function(period, symbol, data) {
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: sma_delegated_cpp <- function(period, symbol, data) {
- en: data <- as.numeric(data[which(data$symbol == symbol), "price_usd"])
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: data <- as.numeric(data[which(data$symbol == symbol), "price_usd"])
- en: return(sma_cpp(period, data))
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return(sma_cpp(period, data))
- en: '}'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE42]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: performance <- microbenchmark(
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: performance <- microbenchmark(
- en: sma_13 <- sma_delegated_cpp(period, symboo, data),
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: sma_13 <- sma_delegated_cpp(period, symboo, data),
- en: unit = "us"
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: unit = "us"
- en: )
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: all(sma_1$sma - sma_13 <= 0.001, na.rm = TRUE)
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: all(sma_1$sma - sma_13 <= 0.001, na.rm = TRUE)
- en: '#> TRUE'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '#> TRUE'
- en: summary(performance)$median
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: summary(performance)$median
- en: '#> [1] 80.6415'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '#> [1] 80.6415'
- en: '[PRE43]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: library(compiler)
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: library(compiler)
- en: sma_efficient_2_compiled <-
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: sma_efficient_2_compiled <-
- en: cmpfun(sma_efficient_2, options = list(optimize = e))
  id: totrans-513
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: cmpfun(sma_efficient_2, options = list(optimize = e))
- en: '[PRE44]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: library(compiler)
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: library(compiler)
- en: enableJIT(level = 3)
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: enableJIT(level = 3)
- en: '```'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '**JIT** compilation can also be enabled by setting the `R_ENABLE_JIT` environment
    in the operating system before starting R. The value of `R_ENABLE_JIT` should
    be set to the value of the level argument.'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '**JIT** 编译可以通过在启动 R 之前在操作系统中设置 `R_ENABLE_JIT` 环境变量来启用。`R_ENABLE_JIT` 的值应设置为
    level 参数的值。'
- en: Using memoization or cache layers
  id: totrans-519
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用记忆化或缓存层
- en: If you have deterministic algorithms, every time you provide equal inputs, you
    should receive equal outputs, and if that's the case and the process to go from
    inputs to outputs is very time-consuming, you may use memoization or cache layers.
    The basic idea is that you store some copies of the inputs and outputs, and whenever
    an input is sent to a function, before computing the output, you check whether
    or not that specific input's output has been computed before. If it has, send
    that instead of doing all the work again. This means you should only be computing
    the output for each input once.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你具有确定性的算法，每次提供相同的输入时，你应该收到相同的输出，如果情况如此，并且从输入到输出的过程非常耗时，你可以使用记忆化或缓存层。基本思想是存储一些输入和输出的副本，每次将输入发送到函数时，在计算输出之前，检查该特定输入的输出是否已经计算过。如果是，发送它而不是再次做所有的工作。这意味着你只需为每个输入计算一次输出。
- en: You should try to implement such a layer in the `fibonacci_recursive()` function
    we created at the beginning of this chapter to see how big of an impact these
    kind of techniques can have, even when using slow algorithms.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该尝试在本书开头创建的 `fibonacci_recursive()` 函数中实现这样的层，以了解这类技术即使在使用慢速算法时也能产生多大的影响。
- en: Sometimes, these types of techniques are also used even when the output for
    a given input changes through time. All you have to do in such cases is to provide
    a mechanism that will invalidate or delete the stored input/output relation after
    a specific amount of time so that it's actually recalculated next time the input
    is used.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，即使给定输入的输出随时间变化，也会使用这类技术。在这种情况下，你只需要提供一个机制，在特定时间后使存储的输入/输出关系失效或删除，以便下次使用输入时实际上重新计算。
- en: Improving our data and memory management
  id: totrans-523
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高我们的数据和内存管理
- en: R, as any programming language, is constrained by CPU, RAM, and I/O, and in
    this chapter, we focused on increasing the speed for the CPU part. However, considerable
    performance gains can be achieved by also making our RAM and I/O usage more efficient.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: R，作为任何编程语言，都受限于CPU、RAM和I/O，在本章中，我们专注于提高CPU部分的效率。然而，通过使我们的RAM和I/O使用更加高效，也可以实现相当大的性能提升。
- en: 'Measuring RAM (memory) usage is best done outside of R using the tools provided
    by your operating system for exactly this purpose. The information that these
    tools report varies depending on the operating system, but here are the key metrics
    you should keep an eye on: CPU usage, free memory, physical memory, swap size,
    and bytes read/written per second.'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 在R之外使用操作系统提供的工具来测量RAM（内存）使用情况是最佳做法，这些工具正是为此目的而设计的。这些工具报告的信息会根据操作系统而有所不同，但以下是一些你应该关注的关键指标：CPU使用率、空闲内存、物理内存、交换空间大小以及每秒读取/写入的字节数。
- en: If you encounter high CPU utilization, the CPU is likely the main bottleneck
    for R's performance. Use the profiling techniques in this chapter to identify
    which parts of the code are taking most of the CPU's time is the way to go.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到高CPU利用率，CPU很可能是R性能的主要瓶颈。使用本章中介绍的性能分析技术来识别代码中占用CPU时间最多的部分是解决问题的方法。
- en: If you encounter enough free system memory with high disk I/O, your code is
    likely performing lots of read/write operations to disk. Remove any unnecessary
    I/O operations and store intermediate data in the memory if there is sufficient
    memory.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到足够的空闲系统内存和高磁盘I/O的情况，你的代码可能正在执行大量的磁盘读取/写入操作。移除任何不必要的I/O操作，并在有足够内存的情况下将中间数据存储在内存中。
- en: If you encounter low CPU utilization and low free system memory with a large
    swap size, the system is likely running out of physical memory and is thus swapping
    memory onto the disk. In this case, see whether you have enough resources to handle
    the loads you're sending to R, and if you do, try to use the `rm()` function to
    remove unused objects that are waiting memory from R's session.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到CPU利用率低、空闲系统内存低以及大交换空间的情况，系统可能正在耗尽物理内存，因此将内存交换到磁盘上。在这种情况下，检查你是否拥有足够的资源来处理发送给R的负载，如果有，尝试使用`rm()`函数从R会话中删除等待内存的未使用对象。
- en: If you encounter a scenario similar to the last one, but you know that you don't
    have enough memory to handle the full data you're working with, even if you did
    so efficiently, you may try to partition your data. Can you work with a subset
    of the data by parts and then bring the results together? If so, you should try
    that. For example, if your full data doesn't fit in memory and you're trying to
    find the maximum value, you may want to split your data into four parts, load
    each them one by one, calculate the maximum for each of them, and remove them
    from memory after you do, while keeping the maximum and then getting the maximum
    of the four maximums you computed separately.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到与上一个情况类似的情况，但你知道你没有足够的内存来处理你正在处理的全数据，即使你这样做得很高效，你可以尝试对数据进行分区。你能通过部分处理数据，然后将结果汇总吗？如果是这样，你应该尝试这样做。例如，如果你的全部数据不适合内存，你正在尝试找到最大值，你可能想将数据分成四部分，一次加载一个，计算每个的最大值，然后在计算完之后从内存中删除它们，同时保留最大值，然后得到四个单独计算出的最大值中的最大值。
- en: Another possibility for a scenario like the previous one is to simply migrate
    your data handling to a database. Databases are specialized tools for dealing
    with data, and can avoid data being a bottleneck in R since only the preprocessed
    subset of the data you need is brought into R. Most of databases nowadays also
    perform very efficient simple operations, like finding the maximum. You can leverage
    the techniques we showed in [Chapter 4](part0091.html#2MP360-f494c932c729429fb734ce52cafce730),
    *Simulating Sales Data and Working with Databases*, to accomplish this.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类似前一种情况的可能性，你可以简单地迁移你的数据处理到数据库。数据库是专门用于处理数据的工具，可以避免数据成为R的瓶颈，因为只有你需要的数据预处理子集被带入R。如今的大多数数据库也执行非常高效的简单操作，如查找最大值。你可以利用我们在[第4章](part0091.html#2MP360-f494c932c729429fb734ce52cafce730)中展示的技术，*模拟销售数据和数据库操作*，来完成这项工作。
- en: Using specialized packages for performance
  id: totrans-531
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用专门的性能包
- en: Another good way to increase the performance of your implementations is to look
    for specialized functions published in CRAN packages or elsewhere. Before you
    go about changing your own code, take a look and see if you can find a very efficient
    implementation somewhere else. There's tremendous variation in CRAN packages'
    quality and speed, but leveraging them can definitely save you a lot of time.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 提高你实现性能的另一种好方法是寻找在 CRAN 软件包或其他地方发布的专用函数。在你开始修改自己的代码之前，先看看是否可以在其他地方找到一个非常高效的实现。CRAN
    软件包的质量和速度差异很大，但利用它们肯定可以为你节省大量时间。
- en: Two very powerful packages to help you develop efficient implementations are
    the `data.table` and `dplyr` packages. They can provide efficient ways of dealing
    with data frames, and in the case of `dplyr` other objects as well. The **Basic
    Linear Algebra Subprogram** (**BLAS**) library can also be very helpful when performing
    linear algebra operations. It's written using Fortran and is highly optimized.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个非常强大的软件包可以帮助你开发高效的实现，分别是 `data.table` 和 `dplyr` 软件包。它们可以提供处理数据框的高效方法，在 `dplyr`
    的情况下还可以处理其他对象。**基本线性代数子程序**（**BLAS**）库在执行线性代数操作时也非常有帮助。它是用 Fortran 编写的，并且高度优化。
- en: Flexibility and power with cloud computing
  id: totrans-534
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云计算带来的灵活性和强大功能
- en: Sometimes, you don't even need more computing power or efficient resources usage.
    Sometimes, you just need to run R on some other computer without tying up your
    own for hours or days. In those cases, using cloud computing resources can be
    very useful.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你甚至不需要更多的计算能力或高效的资源使用。有时候，你只需要在其他计算机上运行 R，而不用占用你自己的计算机数小时或数天。在这些情况下，使用云计算资源可能非常有用。
- en: Cloud computing resources are not only useful when you want to use an extra
    machine, they are a very efficient way to get hold of supercomputers to do some
    work for you. It's very easy to build a machine with 64 CPU cores and 512 GB of
    RAM memory. Using a system like that may be cheaper than you think, and it can
    be leveraged for very costly computations that would take way too much time in
    commodity hardware.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算资源不仅在你想使用额外机器时很有用，而且是一种非常有效的方式来获取超级计算机为你做一些工作。构建一个具有 64 个 CPU 核心和 512 GB
    RAM 的机器非常容易。使用这样的系统可能比你想象的要便宜，并且可以用于非常昂贵的计算，这些计算在通用硬件上会花费太多时间。
- en: Specialized R distributions
  id: totrans-537
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 专业的 R 分布
- en: Finally, if none of the previous options have worked for you, you may also use
    specialized R distributions. These distributions are maintained independently
    of the common R distribution and are focused on optimizing specific aspects within
    R. Some of them are built to provide fine-grained controlled for parallelization,
    and some do it for you automatically. Learning to use those distributions can
    be require a significant time investment, which may or may not be beneficial for
    your particular case.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你之前尝试的选项都没有奏效，你也可以使用专业的 R 分布。这些分布是独立于常见的 R 分布维护的，并且专注于优化 R 中的特定方面。其中一些是为了提供细粒度控制的并行化而构建的，而另一些则是自动为你完成。学习使用这些分布可能需要大量的时间投入，这对你具体情况可能有益也可能无益。
- en: Summary
  id: totrans-539
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we saw the most important reasons behind slow R code: programming
    without understanding object immutability, the nature of interpreted dynamic typings,
    memory-bound processes, and single-threaded processes. We learned that the first
    one can be reduced by properly using R, the second one can be reduced by delegating
    to statistically typed languages such as Fortran or C++, the third one can be
    reduced using more powerful computers (specifically with more RAM), and, finally,
    the fourth one can be reduced using parallelization.'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了导致 R 代码运行缓慢的最重要原因：在不理解对象不可变性的情况下编程、解释动态类型的特点、内存受限的过程以及单线程过程。我们了解到，第一个可以通过正确使用
    R 来减少，第二个可以通过委托给 Fortran 或 C++ 等统计类型语言来减少，第三个可以通过使用更强大的计算机（特别是具有更多 RAM 的计算机）来减少，最后，第四个可以通过并行化来减少。
- en: We also mentioned some variables that we may want to take into account when
    deciding whether or not to optimize our implementations, how small a difference
    in implementation may result in big performance enhancements, and how the performance
    gains from these enhancements can become larger as the size of the inputs increases.
    Finally, we also learned how to profile and benchmark to improve our implementations.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提到了一些变量，这些变量在决定是否优化我们的实现时可能需要考虑，一个很小的实现差异可能带来大的性能提升，以及随着输入规模的增长，这些提升的性能可以变得更大。最后，我们还学习了如何进行性能分析和基准测试以改进我们的实现。
- en: In the next and final chapter, we will learn to use the `Shiny` package to create
    interactive dashboards that will make use of the SMA implementation we developed
    throughout this chapter.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章和最后一章中，我们将学习如何使用`Shiny`包来创建交互式仪表板，这些仪表板将利用本章中我们开发的全局移动平均（SMA）实现。
