<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Working with ArcPy Geometry Objects"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Working with ArcPy Geometry Objects</h1></div></div></div><p>The essence of geospatial analysis is using geometric shapes – points, lines, and polygons – to model the geography of real world objects and their location-based relationships. The simple shapes and their geometric properties of location, length and area are processed using geospatial operations to generate analysis results. It is the combination of modeled geographic data and the associated attribute information that separate geospatial information systems from all other information systems.</p><p>Until ArcPy, processing the feature class geometry using the geospatial operations was depended on the pre-built tools within ArcToolbox. ArcPy has made it possible to directly access the geometric shapes which are stored as mathematical representations in the shape field of feature classes. Once accessed, this geometric data is loaded into ArcPy geometry objects to make the data available for analysis within an ArcPy script. Because of this advance, writing scripts that access geometry fields and use them to perform analysis has transformed ArcGIS geospatial analysis. In this chapter, we'll explore how to generate and use the ArcPy geometry objects to perform geospatial operations, and apply them to the bus stops analysis.</p><p>In this chapter, we will cover: <code class="literal">Point</code> and <code class="literal">Array</code> constructor objects and <code class="literal">PointGeometry</code>, <code class="literal">Polyline</code>, and <code class="literal">Polygon</code> geometry objects</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to use the geometry objects to perform geospatial operations</li><li class="listitem" style="list-style-type: disc">How to integrate the geometry objects into scripts</li><li class="listitem" style="list-style-type: disc">How to perform common geospatial operations using the geometry objects</li><li class="listitem" style="list-style-type: disc">How to replace the use of ArcToolbox tools in the script with geometry object methods</li></ul></div><div class="section" title="ArcPy geometry object classes"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec34"/>ArcPy geometry object classes</h1></div></div></div><p>In designing<a id="id223" class="indexterm"/> geometry objects, the authors of ArcPy made it possible to perform geospatial operations in memory, reducing the need to use tools in the ArcToolbox for these operations. This will result in speed gains as there is no need to write the results of the calculations to disk at each step of the analysis. Instead, the results of the steps can be passed from function to function within the script. The final results of the analysis can be written to the hard drive as a feature class, or they can be written into a spreadsheet or passed to another program.</p><p>The geometry objects are written as Python classes- special blocks of code that contain internal functions. The internal functions are the methods and properties of the geometry objects; when called they allow the object to perform an operation (a method) or to reveal  information about the geometry object (a property). Python classes are written with a main class that contains shared methods and properties, and with sub-classes that reference the main class but also have specific methods and properties that are not shared. Here, the main class is the ArcPy <code class="literal">Geometry</code> object, while the sub-classes are the <code class="literal">PointGeometry</code>, <code class="literal">Multipoint</code>, <code class="literal">Polyline</code> and <code class="literal">Polygon</code> objects.</p><p>The geometry objects are generated in three ways. The first requires using data cursors to read existing feature classes and passing a special keyword as a field name. The shape data returned by the cursor is a geometry object. The second method is to create new data by passing raw coordinates to a constructor object (either a <code class="literal">Point</code> or <code class="literal">Array</code> object), which is then passed to a geometry object. The third method is to read data from a feature class using the Copy Features tool from the ArcToolbox.</p><p>Each geometry object has methods that allow for read access and write access. The read access methods are important for accessing the coordinate points that constitute the points, lines and polygons. The write access methods are important when generating new data objects that can be analyzed or written to disk.</p><p>The <code class="literal">PointGeometry</code>, <code class="literal">Multipoint</code>, <code class="literal">Polyline</code>, and <code class="literal">Polygon</code> geometry objects are used for performing analysis upon their respective geometry types. The generic geometry object can accept any geometry type and an optional spatial reference to perform geospatial operations when there is no need to discern the geometry type.</p><p>Two other ArcPy classes will be used for performing geospatial operations in memory: the <code class="literal">Array</code> object and the <code class="literal">Point</code> object. They are constructor objects, as they are not sub-classed from the geometry class, but are instead used to construct the geometry objects. The <code class="literal">Point</code> object is used to create coordinate points from raw coordinates. The <code class="literal">Array</code> object is a list of coordinate points that can be passed to a <code class="literal">Polyline</code> or <code class="literal">Polygon</code> object, as a regular Python list of ArcPy <code class="literal">Point</code> objects cannot be used to generate those geometry objects.</p><div class="section" title="ArcPy Point objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec49"/>ArcPy Point objects</h2></div></div></div><p>
<code class="literal">Point</code> objects are the building blocks used to generate geometry objects. Also, all of the geometry objects will return component coordinates as <code class="literal">Point</code> objects when using read access methods. <code class="literal">Point</code> objects allow for simple geometry access using its <span class="emphasis"><em>X</em></span>, <span class="emphasis"><em>Y </em></span>and <span class="emphasis"><em>Z</em></span> properties, and a <a id="id224" class="indexterm"/>limited number of geospatial methods, such as <code class="literal">contains</code>, <code class="literal">overlaps</code>, <code class="literal">within</code>, <code class="literal">touches</code>, <code class="literal">crosses, equals</code>, and <code class="literal">disjoint</code>. Let's use IDLE to explore some of these methods with two <code class="literal">Point</code> geometry objects with the same coordinates:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; Point = arcpy.Point(4,5)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; point1  = arcpy.Point(4,5)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; Point.equals(point1)</strong></span>
<span class="strong"><strong>True</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; Point.contains(point1)</strong></span>
<span class="strong"><strong>True</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; Point. crosses(point1)</strong></span>
<span class="strong"><strong>False</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; Point.overlaps(point1)</strong></span>
<span class="strong"><strong>False</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; Point.disjoint(point1)</strong></span>
<span class="strong"><strong>False</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; Point.within(point1)</strong></span>
<span class="strong"><strong>True</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; point.X, Point.Y</strong></span>
<span class="strong"><strong>(4.0, 5.0)</strong></span>
</pre></div><p>In these examples, we see some of the idiosyncrasies of the <code class="literal">Point</code> object. With two points that have the same coordinates, the results of the <code class="literal">equals</code> method and the <code class="literal">disjoint</code> method are as expected. The <code class="literal">disjoint</code> method will return <code class="literal">True</code> when the two objects do not share coordinates, while the opposite is true with the <code class="literal">equals</code> method. The <code class="literal">contains</code> method will work with the two Point objects and return True. The <code class="literal">crosses</code> method and <code class="literal">overlaps</code> method are somewhat surprising results, as the two Point objects do overlap in location and could be considered to cross; however, those methods do not return the expected result as they are not built to compare two points.</p></div><div class="section" title="ArcPy Array objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec50"/>ArcPy Array objects</h2></div></div></div><p>Before we progress up to <code class="literal">Polyline</code> and <code class="literal">Polygon</code> objects, we need to understand the ArcPy <code class="literal">Array</code> object. It is the bridge between the <code class="literal">Point</code> objects and those geometry objects that require multiple coordinate points. <code class="literal">Array</code> objects accept <code class="literal">Point</code> objects as parameters, and the <code class="literal">Array </code>object is in turn passed as a parameter to the geometry object to be created. Let's use Point objects with an Array object to understand better how they work together.</p><p>The <code class="literal">Array</code> object is similar to a Python list, with <code class="literal">extend</code>, <code class="literal">append</code>, and <code class="literal">replace</code> methods, and also has unique methods such as <code class="literal">add</code> and <code class="literal">clone</code>. The <code class="literal">add</code> method will be used to <a id="id225" class="indexterm"/>add <code class="literal">Point</code> objects individually:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; Point = arcpy.Point(4,5)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; point1  = arcpy.Point(7,9)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; Array = arcpy.Array()</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; Array.add(point)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; Array.add(point1)</strong></span>
</pre></div><p>The <code class="literal">extend()</code> method would add a list of Point objects all at once:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; Point = arcpy.Point(4,5)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; point1 = arcpy.Point(7,9)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; pList = [Point,point1]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; Array = arcpy.Array()</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; Array.extend(pList)</strong></span>
</pre></div><p>The <code class="literal">insert</code> method will put a <code class="literal">Point</code> object in the Array at a specific index, while the <code class="literal">replace</code> method is used to replace a <code class="literal">Point</code> object in an Array by passing an index and a new <code class="literal">Point</code> object:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; Point  = arcpy.Point(4,5)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; point1  = arcpy.Point(7,9)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; point2  = arcpy.Point(11,13)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; pList = [Point,point1]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; Array = arcpy.Array()</strong></span>
<span class="strong"><strong>   &gt;&gt;&gt; Array.extend(pList)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; Array.replace(1,point2)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; point3  = arcpy.Point(17,15)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; Array.insert(2,point3)</strong></span>
</pre></div><p>The <code class="literal">Array</code> object, when loaded with <code class="literal">Point</code> objects, can then be used to generate the other geometry objects.</p></div><div class="section" title="ArcPy Polyline objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec51"/>ArcPy Polyline objects</h2></div></div></div><p>The <code class="literal">Polyline</code> object is generated with an <code class="literal">Array</code> object that has at least two <code class="literal">Point </code>objects. As given in the following IDLE example, once an <code class="literal">Array</code> object has been generated and loaded with the <code class="literal">Point</code> objects, it can then be passed as a parameter to a <code class="literal">Polyline</code> object:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; Point  = arcpy.Point(4,5)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; point1  = arcpy.Point(7,9)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; pList = [Point,point1]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; Array = arcpy.Array()</strong></span>
<span class="strong"><strong>   </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; Array.extend(pList)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; pLine = arcpy.Polyline(Array)</strong></span>
</pre></div><p>Now that the Polyline object has been created, its methods can be accessed. This includes methods to reveal the constituent coordinate points within the polyline, and other relevant information:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; pLine.firstPoint</strong></span>
<span class="strong"><strong>&lt;Point (4.0, 5.0, #, #)&gt;</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; pLine.lastPoint</strong></span>
<span class="strong"><strong>&lt;Point (7.0, 9.0, #, #)&gt;</strong></span>
<span class="strong"><strong>pLine.getPart()</strong></span>
<span class="strong"><strong>&lt;Array [&lt;Array [&lt;Point (4.0, 5.0, #, #)&gt;, &lt;Point (7.0, 9.0, #, #)&gt;]&gt;]&gt;</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; pLine.trueCentroid</strong></span>
<span class="strong"><strong>&lt;Point (5.5, 7.0, #, #)&gt;</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; pLine.length</strong></span>
<span class="strong"><strong>5.0</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; pLine.pointCount</strong></span>
<span class="strong"><strong>2</strong></span>
</pre></div><p>This<a id="id226" class="indexterm"/> example <code class="literal">Polyline</code> object has not been assigned a spatial reference system, so the length is unitless. When a geometry object does have a spatial reference system, the linear and areal units will be returned in the linear unit of the system.</p><p>The <code class="literal">Polyline</code> object is also our first geometry object with which we can invoke geometry class methods that perform geospatial operations, such as buffers, distance analyses, and clips:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; bufferOfLine = pLine.buffer(10)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; bufferOfLine.area</strong></span>
<span class="strong"><strong>413.93744395</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; bufferOfLine.contains(pLine)</strong></span>
<span class="strong"><strong>True</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; newPoint = arcpy.Point(25,19)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; pLine.distanceTo(newPoint)</strong></span>
<span class="strong"><strong>20.591260281974</strong></span>
</pre></div><p>Another useful method of <code class="literal">Polyline</code> objects is the <code class="literal">positionAlongLine</code> method. It is used to return a <code class="literal">PointGeometry</code> object, discussed in the following, at a specific position along the line. This position along the line can either be a numeric distance from the first Point or as a percentage (expressed as a float from 0-1), when using the optional second parameter:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; nPoint = pLine.positionAlongLine(3)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; nPoint.firstPoint.X, nPoint.firstPoint.Y</strong></span>
<span class="strong"><strong>(5.8, 7.4)&gt;&gt;&gt; pPoint = pLine.positionAlongLine(.5,True)</strong></span>
<span class="strong"><strong>          &gt;&gt;&gt; pPoint.firstPoint.X,pPoint.firstPoint.Y</strong></span>
<span class="strong"><strong>(5.5, 7.0)</strong></span>
</pre></div><p>There are a number of other methods available to <code class="literal">Polyline</code> objects. More information is available here: <a class="ulink" href="http://resources.arcgis.com/en/help/main/10.2/index.html#//018z00000008000000">http://resources.arcgis.com/en/help/main/10.2/index.html#//018z00000008000000</a>
</p></div><div class="section" title="ArcPy Polygon objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec52"/>ArcPy Polygon objects</h2></div></div></div><p>To <a id="id227" class="indexterm"/>create a <code class="literal">Polygon</code> object, an <code class="literal">Array</code> object <a id="id228" class="indexterm"/>must be loaded with <code class="literal">Point</code> objects and then passed as a parameter to the <code class="literal">Polygon </code>object. Once the <code class="literal">Polygon</code> object has been generated, the methods available to it are very useful for performing geospatial operations. The geometry objects can also be saved to disk using the ArcToolbox <code class="literal">CopyFeatures</code> tool. This IDLE example demonstrates how to generate a <code class="literal">shapefile</code> by passing a <code class="literal">Polygon</code> object and a raw string filename to the tool:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; import arcpy
&gt;&gt;&gt; point1 = arcpy.Point(12,16)
&gt;&gt;&gt; point2 = arcpy.Point(14, 18)
&gt;&gt;&gt; point3 = arcpy.Point(11, 20)
&gt;&gt;&gt; Array = arcpy.Array()
&gt;&gt;&gt; Points = [point1,point2,point3]
&gt;&gt;&gt; Array.extend(points)
&gt;&gt;&gt; Polygon = arcpy.Polygon(array)
&gt;&gt;&gt; arcpy.CopyFeatures_management(polygon, r'C:\Projects\Polygon.shp')
&lt;Result 'C:\\Projects\\Polygon.shp'&gt;</pre></div><div class="section" title="Polygon object buffers"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec22"/>Polygon object buffers</h3></div></div></div><p>
<code class="literal">Polygon</code> objects, like <code class="literal">Polyline</code> objects, have methods that make it easy to perform geospatial operations such as buffers.  By passing a number to the buffer method as a parameter, a buffer will be generated in memory. The unit of the number is determined by the <code class="literal">SpatialReference</code> system. Internal buffers can be generated by supplying negative buffer numbers; the buffer generated being the area within the <code class="literal">Polygon</code> object at the specified distance from the Polygon perimeter. Clips, unions, symmetrical differences, and more operations are available as methods, as are within or contains operations; even projections can be performed using the <code class="literal">Polygon</code> object methods as long as it has a <code class="literal">SpatialReference</code> system object passed as a parameter. Following is a script that will create two shapefiles with two separate <code class="literal">SpatialReference</code> systems, each identified by a numeric code (2227 and 4326) from the EPSG coding system:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>import arcpyPoint  = arcpy.Point(6004548.231,2099946.033)</strong></span>
<span class="strong"><strong>point1  = arcpy.Point(6008673.935,2105522.068)</strong></span>
<span class="strong"><strong>point2  = arcpy.Point(6003351.355,2100424.783)Array = arcpy.Array()</strong></span>
<span class="strong"><strong>Array.add(point1)</strong></span>
<span class="strong"><strong>Array.add(point)</strong></span>
<span class="strong"><strong>array.add(point2)</strong></span>
<span class="strong"><strong>Polygon = arcpy.Polygon(array, 2227)</strong></span>
<span class="strong"><strong>buffPoly = Polygon.buffer(50)</strong></span>
<span class="strong"><strong>features = [Polygon,buffPoly]</strong></span>
<span class="strong"><strong>arcpy.CopyFeatures_management(features,</strong></span>
<span class="strong"><strong>                              r'C:\Projects\Polygons.shp')</strong></span>
<span class="strong"><strong>spatialRef = arcpy.SpatialReference(4326)</strong></span>
<span class="strong"><strong>polygon4326 = Polygon.projectAs(spatialRef)</strong></span>
<span class="strong"><strong>arcpy.CopyFeatures_management(polygon4326,</strong></span>
<span class="strong"><strong>                              r'C:\Projects\polygon4326.shp')</strong></span>
</pre></div><p>Here<a id="id229" class="indexterm"/> is how the second shapefile looks in <a id="id230" class="indexterm"/>the <span class="strong"><strong>ArcCatalog</strong></span> <span class="strong"><strong>Preview </strong></span>window:</p><div class="mediaobject"><img src="graphics/8662OS_06_01.jpg" alt="Polygon object buffers"/></div></div><div class="section" title="Other Polygon object methods"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec23"/>Other Polygon object methods</h3></div></div></div><p>Unlike the clip tool in the ArcToolbox, which can clip a Polygon using another polygon, the clip method requires an extent object (another ArcPy class) and is limited to a rectangular envelope around the area to be clipped. To remove areas from a polygon, the difference method can work like the clip or erase tool in the ArcToolbox:</p><div class="informalexample"><pre class="programlisting">buffPoly = Polygon.buffer(500)
donutHole =buffPoly.difference(Polygon)
features = [Polygon,donutHole]
arcpy.CopyFeatures_management(features,
                              r"C:\Projects\Polygons2.shp")</pre></div><p>Here is<a id="id231" class="indexterm"/> the donut hole-like result of the buffer <a id="id232" class="indexterm"/>and difference operation. The buffer with the donut hole surrounds the original <code class="literal">Polygon</code> object:</p><div class="mediaobject"><img src="graphics/8662OS_06_02.jpg" alt="Other Polygon object methods"/></div></div></div><div class="section" title="ArcPy geometry objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec53"/>ArcPy geometry objects</h2></div></div></div><p>The generic <a id="id233" class="indexterm"/>geometry object is quite<a id="id234" class="indexterm"/> useful for creating in memory a copy of the geometry of a feature class, without first needing to know which type of geometry the feature class contains. Like all of the ArcPy geometry objects, its read methods include the extraction of the data in many formats such as JSON, WKT, and WKB. The area (if it is a polygon), the centroid, the extent, and the constituent points of each geometry are also available, as demonstrated previously.</p><p>Here is an<a id="id235" class="indexterm"/> example of reading the geometry <a id="id236" class="indexterm"/>of a feature class into memory using the <code class="literal">CopyFeatures</code> tool:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>import arcpy</strong></span>
<span class="strong"><strong>cen2010 = r'C:\Projects\ArcPy.gdb\SanFrancisco\CensusBlocks2010'</strong></span>
<span class="strong"><strong>blockPolys = arcpy.CopyFeatures_management(cen2010,</strong></span>
<span class="strong"><strong>                                           arcpy.Geometry())</strong></span>
</pre></div><p>The variable <code class="literal">blockPolys</code> is a Python list containing all of the geometries loaded into it; in this case it is census blocks. The list can then be iterated to be analyzed.</p></div><div class="section" title="ArcPy PointGeometry objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec54"/>ArcPy PointGeometry objects</h2></div></div></div><p>The <code class="literal">PointGeometry</code> object is very useful for performing these same geospatial operations <a id="id237" class="indexterm"/>with points, which are <a id="id238" class="indexterm"/>not available with the <code class="literal">Point </code>objects. When a cursor is used to retrieve shape data from a feature class with a <code class="literal">PointGeometry</code> type, the shape data is returned as a <code class="literal">PointGeometry</code> object. While <code class="literal">Point</code> objects are required to construct all other geometry objects when a cursor is not used to retrieve data from a feature class, it's the <code class="literal">PointGeometry</code> object that is used to perform point geospatial operations.</p><p>Let's explore getting <code class="literal">PointGeometry</code> objects from a data access module <code class="literal">SearchCursor</code> and using the returned data rows to create buffered points. In our bus stop analysis, this will replace the need to use the ArcToolbox Buffer tool to create the 400 foot buffers around each stop. The script in the following uses a dictionary to collect the buffer objects and then searches the census blocks using another Search Cursor. To access the shape field using the <code class="literal">SearchCursor()</code> method, the <code class="literal">SHAPE@</code> token is passed as one of the fields. Then, the script will iterate through the bus stops and find all census blocks with which each stop intersects:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># Generate 400 foot buffers around each bus stop</strong></span>
<span class="strong"><strong>import arcpy,csv</strong></span>
<span class="strong"><strong>busStops = r"C:\Projects\PacktDB.gdb\SanFrancisco\Bus_Stops"</strong></span>
<span class="strong"><strong>censusBlocks2010 = r"C:\Projects\PacktDB.gdb\SanFrancisco\CensusBlocks2010"</strong></span>

<span class="strong"><strong>sql = "NAME = '71 IB' AND BUS_SIGNAG = 'Ferry Plaza'"</strong></span>
<span class="strong"><strong>dataDic = {}</strong></span>
<span class="strong"><strong>with arcpy.da.SearchCursor(busStops, ['NAME','STOPID','SHAPE@'], sql) as cursor:</strong></span>
<span class="strong"><strong>    for row in cursor:</strong></span>
<span class="strong"><strong>        linename = row[0]</strong></span>
<span class="strong"><strong>        stopid = row[1]</strong></span>
<span class="strong"><strong>        shape = row[2]</strong></span>
<span class="strong"><strong>        dataDic[stopid] = shape.buffer(400), linename</strong></span>
</pre></div><p>Now that the data has been retrieved and the buffers have been generated using the buffer method of the <code class="literal">PointGeometry</code> objects, the buffers can be compared against the census block <a id="id239" class="indexterm"/>geometry using iteration and a <a id="id240" class="indexterm"/>Search Cursor. There will be two geospatial methods used in this analysis: <code class="literal">overlap</code> and <code class="literal">intersect</code>. The overlaps method is a boolean operation, returning a value of true or false when one geometry is compared against another. The <code class="literal">intersect</code> method is used to get the actual area of the intersect as well as identifying the population of each block. Using the intersect requires two parameters: a second geometry object, and an integer indicating which type of geometry to return (1 for point, 2 for line, 4 for polygon).  We want the polygonal area of intersect returned to have an area of intersection available along with the population data:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># Intersect census blocks and bus stop buffers</strong></span>
<span class="strong"><strong>processedDataDic = {} = {}</strong></span>
<span class="strong"><strong>for stopid in dataDic.keys():</strong></span>
<span class="strong"><strong>    values = dataDic[stopid]</strong></span>
<span class="strong"><strong>    busStopBuffer = values[0]</strong></span>
<span class="strong"><strong>    linename = values[1]</strong></span>
<span class="strong"><strong>    blocksIntersected = []</strong></span>
<span class="strong"><strong>    with arcpy.da.SearchCursor(censusBlocks2010, ['BLOCKID10','POP10','SHAPE@']) as cursor:</strong></span>
<span class="strong"><strong>for row in cursor:</strong></span>
<span class="strong"><strong>            block = row[2]</strong></span>
<span class="strong"><strong>            population = row[1]</strong></span>
<span class="strong"><strong>            blockid = row[0]            </strong></span>
<span class="strong"><strong>            if busStopBuffer.overlaps(block) ==True:</strong></span>
<span class="strong"><strong>                interPoly = busStopBuffer.intersect(block,4)</strong></span>
<span class="strong"><strong>                data = row[0],row[1],interPoly, block</strong></span>
<span class="strong"><strong>                blocksIntersected.append(data)</strong></span>
<span class="strong"><strong>    processedDataDic[stopid] = values, blocksIntersected</strong></span>
</pre></div><p>This portion of the script iterates through the blocks and intersects against the buffered bus stops. Now that we can identify the blocks that touch the buffer around each stop and the data of interest has been collected into the dictionary, it can be processed and the average population of all of the blocks touched by the buffer can be calculated:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># Create an average population for each bus stop</strong></span>
<span class="strong"><strong>dataList = []</strong></span>
<span class="strong"><strong>for stopid in processedDataDic.keys():</strong></span>
<span class="strong"><strong>    allValues = processedDataDic[stopid]</strong></span>
<span class="strong"><strong>    popValues = []</strong></span>
<span class="strong"><strong>    blocksIntersected = allValues[1]</strong></span>
<span class="strong"><strong>    for blocks in blocksIntersected:</strong></span>
<span class="strong"><strong>        popValues.append(blocks[1])</strong></span>
<span class="strong"><strong>    averagePop = sum(popValues)/len(popValues)</strong></span>
<span class="strong"><strong>    busStopLine = allValues[0][1]</strong></span>
<span class="strong"><strong>    busStopID = stopid</strong></span>
<span class="strong"><strong>    finalData = busStopLine, busStopID, averagePop</strong></span>
<span class="strong"><strong>    dataList.append(finalData)</strong></span>
</pre></div><p>Now <a id="id241" class="indexterm"/>that the data has been created <a id="id242" class="indexterm"/>and added to a list, it can be outputted to a spreadsheet using the <code class="literal">createCSV</code> module we created in <a class="link" href="ch04.html" title="Chapter 4. Complex ArcPy Scripts and Generalizing Functions">Chapter 4</a>, <span class="emphasis"><em>Complex ArcPy Scripts and Generalizing Functions</em></span>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># Generate a spreadsheet with the analysis results</strong></span>
<span class="strong"><strong>def createCSV(data, csvname, mode ='ab'):</strong></span>
<span class="strong"><strong>    with open(csvname, mode) as csvfile:</strong></span>
<span class="strong"><strong>        csvwriter = csv.writer(csvfile, delimiter=',')</strong></span>
<span class="strong"><strong>        csvwriter.writerow(data)</strong></span>

<span class="strong"><strong>csvname = "C:\Projects\Output\StationPopulations.csv"</strong></span>
<span class="strong"><strong>headers = 'Bus Line Name','Bus Stop ID', 'Average Population'</strong></span>
<span class="strong"><strong>createCSV(headers, csvname, 'wb')     </strong></span>
<span class="strong"><strong>for data in dataList:</strong></span>
<span class="strong"><strong>    createCSV(data, csvname)</strong></span>
</pre></div><p>The data has been processed and written to the spreadsheet. There is one more step that we can take with the data and that is to use the area of the intersection to create a proportional population value for each buffer. Let's redo the processing of the data to include the proportional areas:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>dataList = []</strong></span>
<span class="strong"><strong>for stopid in processedDataDic.keys():</strong></span>
<span class="strong"><strong>    allValues = processedDataDic[stopid]</strong></span>
<span class="strong"><strong>    popValues = []</strong></span>
<span class="strong"><strong>    blocksIntersected = allValues[1]</strong></span>
<span class="strong"><strong>    for blocks in blocksIntersected:</strong></span>
<span class="strong"><strong>       pop = blocks[1]</strong></span>
<span class="strong"><strong>        totalArea = blocks[-1].area</strong></span>
<span class="strong"><strong>        interArea = blocks[-2].area</strong></span>
<span class="strong"><strong>        finalPop = pop * (interArea/totalArea)</strong></span>
<span class="strong"><strong>        popValues.append(finalPop)</strong></span>
<span class="strong"><strong>    averagePop = round(sum(popValues)/len(popValues),2)</strong></span>
<span class="strong"><strong>    busStopLine = allValues[0][1]</strong></span>
<span class="strong"><strong>    busStopID = stopid</strong></span>
<span class="strong"><strong>    finalData = busStopLine, busStopID, averagePop</strong></span>
<span class="strong"><strong>    dataList.append(finalData)</strong></span>
</pre></div><p>Now the <a id="id243" class="indexterm"/>script is taking full advantage <a id="id244" class="indexterm"/>of the power of ArcPy geometry objects, and the script is running completely in memory which avoids producing any intermediate datasets.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec35"/>Summary</h1></div></div></div><p>In this chapter, we discussed in detail the use of ArcPy geometry objects. These varied objects have similar methods and are, in fact, sub-classed from the same Python class. They are useful for performing in-memory geospatial analyses, which avoids having to read and write data from the hard drive and also skips creating any intermediate data.</p><p>ArcPy geometry objects will become an important part of automating geospatial workflows. Combining them with Search Cursors makes ArcPy more useful than any earlier implementation of Python scripting tools for ArcGIS. Next, we will convert the raw script into a script tool that can be executed directly from the ArcToolbox or a personal toolbox in a geodatabase.</p></div></body></html>