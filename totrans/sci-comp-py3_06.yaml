- en: Chapter 6. Plotting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Plotting in Python can be done with the `pyplot` part of the matplotlib module.
    With matplotlib you can create high-quality figures and graphics and also plot
    and visualize your results. Matplotlib is open source and freely available software,
    [[21]](apa.html "Appendix . References"). The matplotlib website also contains
    excellent documentation with examples, [[35]](apa.html "Appendix . References").
    In this section, we will show you how to use the most common features. The examples
    in the upcoming sections assume that you have imported the module as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In case you want to use the plotting commands in IPython, it is recommended
    that you run the magic command `%matplotlib` directly after starting the IPython
    shell. This prepares IPython for interactive plotting.
  prefs: []
  type: TYPE_NORMAL
- en: Basic plotting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The standard plotting function is `plot`. Calling `plot(x,y)` creates a figure
    window with a plot of *y* as a function of *x*. The input arguments are arrays
    (or lists) of equal length. It is also possible to use `plot(y)`, in which case
    the values in *y* will be plotted against their index, that is, `plot(y)` is a
    short form of `plot(range(len(y)),y)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that shows how to plot sin(*x*) for *x* ϵ [-2π, 2π]  using
    200 sample points and sets markers at every fourth point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is shown in the following figure (*Figure 6.1*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic plotting](img/plotting_sinexample.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: A plot of the function sin(x) with grid lines shown.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the standard plot is a solid blue curve. Each axis gets automatically
    scaled to fit the values but can also be set manually. Color and plot options
    can be given after the first two input arguments. Here, `r*` indicates red star-shaped
    markers. Formatting is covered in more detail in the next section. The `title`
    command puts a title text string above the plot area.
  prefs: []
  type: TYPE_NORMAL
- en: Calling `plot` multiple times will overlay the plots in the same window. To
    get a new clean figure window, use `figure()`. The `figure` command might contain
    an integer, for example, `figure(2)`, which can be used to switch between figure
    windows. If there is no figure window with that number, a new one is created,
    otherwise, the window is activated for plotting and all subsequent plotting commands
    apply to that window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiple plots can be explained using the `legend` function, along with adding
    labels to each plot call. The following example fits polynomials to a set of points
    using the commands `polyfit` and `polyval`, and plots the result with a legend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here you can also see how to manually set the range of the axis using `axis([xmin,xmax,ymin,ymax])`.
    The `legend` command takes optional arguments on placement and formatting; in
    this case the legend is put in the upper-left corner and typeset with a small
    font size, as shown in the following figure (*Figure 6.2*).
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic plotting](img/plotting_polynomialfit.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Two polynomials fitted to the same points.'
  prefs: []
  type: TYPE_NORMAL
- en: As final examples for basic plotting, we demonstrate how to do scatter plots and
    logarithmic plots in two dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example of 2D point scatter plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![Basic plotting](img/plotting_scatterplot.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3(a): An example of a scatter plot'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example of a logarithmic plot using `loglog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![Basic plotting](img/plotting_loglogplot.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3(b): An example of a plot with logarithmic x and y axis'
  prefs: []
  type: TYPE_NORMAL
- en: The examples shown in the preceding figure (*Figure 6.3(a)* and *Figure 6.3(b)*)
    used some parameters of `plot` and `loglog` which allow special formatting. In
    the next section, we will explain the parameters in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The appearance of figures and plots can be styled and customized to look how
    you want them to look. Some important variables are `linewidth`, which controls
    the thickness of plot lines; `xlabel`, `ylabel`, which set the axis labels, `color`
    for plot colors, and `transparent` for transparency. This section will tell you
    how to use some of them. The following is an example with more keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There are short commands that can be used if you only need basic style changes,
    for example, setting the color and line style. The following table (*Table 6.1*)
    shows some examples of these formatting commands. You may use either the short
    string syntax `plot(...,'ro-')`, or the more explicit syntax `plot(..., marker='o',
    color='r', linestyle='-')`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Formatting](img/table-6.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Table 6.1: Some common plot formatting arguments'
  prefs: []
  type: TYPE_NORMAL
- en: 'To set the color to green with the `''o''` marker we write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To plot histograms instead of regular plots, the `hist` command is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![Formatting](img/plotting_histexample.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 normal distribution with 50 bins and a green curve indicating the
    true distribution
  prefs: []
  type: TYPE_NORMAL
- en: The resulting plot looks similar to the preceding figure (*Figure 6.4*). The
    title, and any other text, can be formatted using LaTeX to show mathematical formulas.
    LaTeX formatting is enclosed within a pair of `$` signs. Also, note the string
    formatting done using the `format` method, refer to section *Strings* in [Chapter
    2](ch02.html "Chapter 2. Variables and Basic Types"), *Variables and Basic Types*.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes the brackets for the string formatting interfere with LaTeX bracket
    environments. If this occurs, replace the LaTeX bracket with a double bracket,
    for example, `x_{1}` should be replaced with `x_{{1}}`. The text might contain
    sequences that overlap with string escape sequences, for example, `\tau` will
    be interpreted as the tab character `\t`. An easy workaround  is to add `r` before
    the string, for example `r'\tau'`; this makes it a raw string.
  prefs: []
  type: TYPE_NORMAL
- en: Placing several plots in one figure window can be done using the `subplot` command.
    Consider the following example, which iteratively averages out the noise on a
    sine curve.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![Formatting](img/plotting_sinsubplot.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: An example of plotting several times in the same figure window.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The function `avg`  uses a `roll` call to shift all values of the array. `subplot`
    takes three arguments: the number of vertical plots, the number of horizontal
    plots, and an index indicating which location to plot in (counted row-wise). Note
    that we used the `subplots_adjust` command to add extra space to adjust the distance
    between both the subplots.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A useful command is `savefig` which lets you save a figure as an image (this
    can also be done from the figure window). Many image and file formats are supported
    by this command, they are specified by the filename''s extension as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can place the image against a non-white background, for example, a webpage.
    For this, the `transparent` parameter can be set to make the figure''s background
    transparent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you intend to embed a figure into a LaTeX document, it is recommended that
    you reduce the surrounding white space by setting the figure''s bounding box tight
    around the drawing, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Meshgrid and contours
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common task is a graphical representation of a scalar function over a rectangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Meshgrid and contours](img/function_meshgrid.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For this, first we have to generate a grid on the rectangle [*a*,*b*] x [*c*,*d*].
    This is done using the `meshgrid` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`X` and `Y` are arrays with `(n,m)` shape such that ![Meshgrid and contours](img/xijYij.jpg)
    contains the coordinates of the grid point ![Meshgrid and contours](img/PIJ.jpg)
    as shown in the next figure *(Figure 6.6)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Meshgrid and contours](img/meshgrid.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.6: A rectangle discretized by meshgrid'
  prefs: []
  type: TYPE_NORMAL
- en: A rectangle discretized by `meshgrid` will be used  to visualize the behavior
    of an iteration. Bur first we will use it to plot level curves of a function.
    This is done by the command `contour`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example we choose Rosenbrock''s banana function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Meshgrid and contours](img/banana.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It is used to challenge optimization methods. The function values descend towards
    a banana-shaped valley, which itself decreases slowly towards the function’s global
    minimum at (1, 1).
  prefs: []
  type: TYPE_NORMAL
- en: First we display the level curves using `contour`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This plots the level curve at the levels given by the fourth parameter and uses
    the colormap `gray`. Furthermore, we used logarithmically spaced steps from 10^(0.5)
    to 10³ using the function `logscale` to define the levels, as shown in the next
    figure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Meshgrid and contours](img/rosenbrock.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.7: A contour plot of Rosenbrock function'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, an anonymous function indicated by the keyword `lambda`
    is used to keep the code compact. Anonymous functions are explained in section *Anonymous
    functions - the lambda keyword* in [Chapter 7](ch07.html "Chapter 7. Functions"),
    *Functions*, *Anonymous functions*. If levels are not given as arguments to `contour`,
    the function chooses appropriate levels by itself .
  prefs: []
  type: TYPE_NORMAL
- en: The `contourf` function performs the same function as `contour` but fills the
    plot with colors according to different levels. Contour plots are ideal for visualizing
    the behavior of a numerical method. We illustrate this here by showing the iterations
    of an optimization method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We continue the preceding example and depict the steps towards the minimum
    of the Rosenbrock function generated by Powell''s method, [[27]](apa.html "Appendix . References"),
    which we will apply to find the minimum of the Rosenbrock function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The iterative method `fmin_powell` applies Powell's method to find a minimum.
    It is started by a given start value of *x[0]* and reports all iterates when the
    option `retall=True` is given. After sixteen iterations, the solution *x=*0*,
    y=*0 was found. The iterations are depicted as bullets in the following contour
    plot (*Figure 6.8*).
  prefs: []
  type: TYPE_NORMAL
- en: '![Meshgrid and contours](img/rosenbrock_opt.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.8: A contour plot of Rosenbrock function with a search path of an
    optimization method'
  prefs: []
  type: TYPE_NORMAL
- en: '`contour` also creates a contour set object that we assigned to the variable
    `cs`. This is then used by `clabel` to annotate the levels of the corresponding
    function values, as shown in the preceding figure (*Figure 6.8*).'
  prefs: []
  type: TYPE_NORMAL
- en: Images and contours
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us take a look at some examples of visualizing arrays as images. The following
    function will create a matrix of color values for the Mandelbrot fractal**.**
    Here we consider a fixed point iteration, that depends on a complex parameter
    *c*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images and contours](img/B05511_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Depending on the choice of this parameter it may or may not create a bounded
    sequence of complex values *z[n]*.
  prefs: []
  type: TYPE_NORMAL
- en: For every value of *c*, we check if *z[n]* exceeds a prescribed bound. If it
    remains below the bound within `maxit` iterations, we assume the sequence to be
    bounded.
  prefs: []
  type: TYPE_NORMAL
- en: Note how, in the following piece of code,`meshgrid` is used to generate a matrix
    of complex parameter values *c:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The command `imshow`  displays the matrix as an image. The selected color map
    shows the regions where the sequence appeared unbounded in white and others in
    black. Here we used `axis('off')` to turn off the axis as this might be not so
    useful for images.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images and contours](img/plotting_mandelbrot_gray.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.9: An example of using imshow to visualize a matrix as an image.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, `imshow` uses interpolation to make the images look nicer. This
    is clearly seen when the matrices are small. The next figure shows the difference
    between using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the second example, pixel values are just replicated.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images and contours](img/plotting_mandelbrot_small.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.10: The difference between using the linear interpolation of imshow
    compared to using nearest neighbor interpolation'
  prefs: []
  type: TYPE_NORMAL
- en: For more details on working and plotting with images using Python refer to [[30]](apa.html
    "Appendix . References").
  prefs: []
  type: TYPE_NORMAL
- en: Matplotlib objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Till now, we have used the `pyplot` module of matplotlib. This module makes
    it easy for us to use the most important plot commands directly. Mostly, we are
    interested in creating a figure and display it immediately. Sometimes, though,
    we want to generate a figure that should be modified later by changing some of
    its attributes. This requires us to work with graphical objects in an object-oriented
    way. In this section, we will present some basic steps to modify figures. For
    a more sophisticated object oriented approach to plotting in Python, you have
    to leave `pyplot` and have to dive directly into `matplotlib` with its extensive
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: The axes object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When creating a plot that should be modified later, we need references to a
    figure and an axes object. For this we have to create a figure first and then
    define some axes and their location in the figure. And we should not forget to
    assign these objects to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'A figure can have several axes objects depending on the use of `subplot`. In
    a second step plots are associated with a given axes object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we used an anonymous function indicated by the `lambda` keyword . We will
    explain this construct later in section *Anonymous functions - the lambda keyword*
    in [Chapter 7](ch07.html "Chapter 7. Functions"), *Functions*. In fact, these
    two plot commands fill the list `ax.lines` with two `Lines2D` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'It is a good practice to use labels so that we can later identify objects in
    an easy way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We set up now things in a way that allows further modifications. The figure
    we got so far is shown in preceding figure (*Figure 6.11, left*).
  prefs: []
  type: TYPE_NORMAL
- en: Modifying line properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just identified a particular line object by its label. It is an element of
    the list `ax.lines` list with the index  `il` . All its properties are collected
    in a dictionary
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'which can be obtained by the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'They can be changed by corresponding setter methods. Let us change the line
    style of the sine - curve:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even modify the data, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is shown in the next figure *(Figure 6.11, right)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Modifying line properties](img/amp_mod_sin01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.11: The amplitude modulated sine-function (left) and a curve with
    the last data point corrupted (right).'
  prefs: []
  type: TYPE_NORMAL
- en: Annotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One useful axes method is `annotate`. It sets an annotation at a given position
    and points, with an arrow, to another position in the drawing. The arrow can be
    given properties in a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the first annotation example above, the arrow points to a point with the
    coordinates (*2.1, 1.0*) and the left bottom coordinate of the text is (*3.2,
    0.5*). If not otherwise specified, the coordinates are given in the convenient
    data-coordinate system, which refers to the data used to generate the plots.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we demonstrated a couple of arrow properties specified by the `arrowprop` 
    dictionary. You can scale the arrow by the `shrink` key. The setting `'shrink':0.05`
    reduces the arrow size by 5% to keep a distance to the curve it points to. You
    can let the arrow follow a spline arc or give it other shapes using the `connectionstyle`
    key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Text properties or even a bounding box around the text can be made by extra
    keyword arguments to the annotate method, refer to the following figure (*Figure
    6.12, left*):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Experimenting with annotations requires sometimes to remove attempts that we
    would like to reject. Therefore we assigned the annotate object to a variable,
    which allows us to remove the annotation by its `remove` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Filling areas between curves
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Filling is an ideal tool to highlight differences between curves, such as noise
    on top of expected data, approximations versus exact functions, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Filling is done by the axis method
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'For the next figure we used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`where` is a very convenient parameter that needs a Boolean array to specify
    the additional filling conditions.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The Boolean array which selects the regions to fill is `amod_sin(x)-sin(x) >
    0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next figure shows the curve with both variants of filling areas:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Filling areas between curves](img/amp_mod_sin23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.12: The amplitude modulated sin-function with annotations and filled
    areas(left) and a modified figure with only partially filled areas by using the
    where parameter (right).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you test these commands yourself, do not forget to remove the complete filling
    before you try out the partial filling, otherwise you will not see any change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Related filling commands are `fill` and `fill_betweenx`.
  prefs: []
  type: TYPE_NORMAL
- en: Ticks and ticklabels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Figures in talks, posters, and publications look much nicer if they are not
    overloaded with unnecessary information. You want to direct the spectator to those
    parts that contain the message. In our example, we clean up the picture by removing
    ticks from the *x*-axis and *y*-axis and by introducing problem related tick labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ticks and ticklabels](img/amp_mod_sin4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.13: The completed example of the amplitude modulated sine - function
    with annotations and filled areas and modified ticks and tick labels.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note that we used LaTeX formatting in the strings to represent Greek letters,
    to set formulas correctly, and to use a LaTeX font. It is also a good practice
    to increase the font size so that the resulting figure can be scaled down into
    a text document without affecting the readability of the axes. The final result
    of this guiding example is shown in the previous figure (*Figure 6.13*).
  prefs: []
  type: TYPE_NORMAL
- en: Making 3D plots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some useful `matplotlib` tool kits and modules that can be used for
    a variety of special purposes. In this section, we describe a method for producing
    3D-plots.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mplot3d` toolkit provides 3D plotting of points, lines, contours, surfaces,
    and all other basic components as well as 3D rotation and scaling. Making a 3D
    plot is done by adding the keyword `projection=''3d''` to the axes object as shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, you need to import the `axes3D` type from `mplot3d`. The resulting
    plot displays the scattered 3D-data which can be seen in the following figure
    (*Figure 6.14*)
  prefs: []
  type: TYPE_NORMAL
- en: '![Making 3D plots](img/scatter3d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.14: Plotting 3D data using mplot3d toolkit'
  prefs: []
  type: TYPE_NORMAL
- en: Plotting surfaces is just as easy. The following example uses the built-in function
    `get_test_data` to create a sample data for plotting a surface. Consider the following
    example of a surface plot with transparency.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The *alpha* value sets the transparency. The surface plot is shown in the following
    figure (*Figure 6.15*).
  prefs: []
  type: TYPE_NORMAL
- en: '![Making 3D plots](img/surface_plot.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.15: Example for plotting a surface mesh with three 2D projections.'
  prefs: []
  type: TYPE_NORMAL
- en: You can also plot contours in any of the coordinate projections as in the next
    example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note the commands for setting the axis limits. The standard `matplotlib` commands
    for setting the axis limits are `axis([-40, 40, -40, 40])`, this works fine for
    2D plots. However, `axis([-40,40,-40,40,-40,40])` does not work. For 3D plots
    you need to use the object oriented version of the commands, `ax.set_xlim3d(-40,40)`
    and likewise. The same goes for labeling the axis; note the commands for setting
    the labels. For 2D plots you can do `xlabel(’X axis’)` and `ylabel(’Y axis’)`
    but there is no `zlabel` command. Instead, in 3D plots you need to use `ax.set_xlabel(’X
    axis’)` and likewise, as shown in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: The resulting figure from this code is the following
  prefs: []
  type: TYPE_NORMAL
- en: '![Making 3D plots](img/wireframe_contours.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are many options for formatting the appearance of the plots, including
    color and transparency of surfaces. The `mplot3d` documentation website, [[23]](apa.html
    "Appendix . References"), has the details.
  prefs: []
  type: TYPE_NORMAL
- en: Making movies from plots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have data that evolves, you might want to save it as a movie besides
    showing it in a figure window, similar to the `savefig` command. One way to do
    this is with the `visvis` module available at visvis (refer to [[37]](apa.html
    "Appendix . References") for more information).
  prefs: []
  type: TYPE_NORMAL
- en: Here is a simple example of evolving a circle using an implicit representation.
    Let the circle be represented by the zero level, ![Making movies from plots](img/math_circle.jpg),
    of a function ![Making movies from plots](img/2d_function-1.jpg). Alternatively,
    consider the disk ![Making movies from plots](img/disk_math.jpg) inside the zero
    set. If the value of *f* decreases at a rate *v* then the circle will move outward
    with rate ![Making movies from plots](img/nabla_math.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be implemented as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is a Flash movie (*.swf file) of a growing black circle, as shown
    in the next figure (*Figure 6.16)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making movies from plots](img/circle_evolution_0-new.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.16: An example of evolving a circle'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, a list of arrays was used to create the movie. The `visvis`
    module can also save an GIF animation and on certain platforms an AVI animation
    (*.gif and *.avi files*)*, and there is also the possibility to capturing movie
    frames directly from the figure window. These options, however, require some more
    packages to be installed on your system (for example, `PyOpenGL` and `PIL`, the
    Python Imaging Library). See the documentation on the `visvis` webpage for more
    details.
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to use `savefig` to create images, one for each frame.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: These images can then be combined using a standard video editing software, for
    example, Mencoder or ImageMagick. This approach has the advantage that you can
    make high-resolution videos by saving high-resolution images.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A graphical representation is the most compact form in which to present mathematical
    results or the behavior of an algorithm. This chapter provided you with the basic
    tools for plotting and introduced you to a more sophisticated way to work with
    graphical objects, such as figures, axes, and lines in an object-oriented way.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make plots, not only classical x/y-plots
    but also 3D-plots and histograms. We gave you an appetizer on making films. You
    also saw how to modify plots considering them to be graphical objects with related
    methods and attributes which can be set, deleted, or modified.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Ex. 1** → Write a function that plots an ellipse given its center coordinates
    (*x,y*), the half axis *a* and *b* rotation angle θ.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 2** → Write a short program that takes a 2D array, e.g., the preceding
    Mandelbrot contour image, and iteratively replace each value by the average of
    its neighbors. Update a contour plot of the array in a figure window to animate
    the evolution of the contours. Explain the behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 3** → Consider an *N × N* matrix or image with integer values. The mapping'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercises](img/I_map_math.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'is an example of a mapping of a toroidal square grid of points onto itself.
    This has the interesting property that it distorts the image by shearing and then
    moving the pieces outside the image back using the modulu function `mod`. Applied
    iteratively, this results in randomizing the image in a way that eventually returns
    the original. Implement the following sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercises](img/I_map_iter_math.jpg)'
  prefs: []
  type: TYPE_IMG
- en: and save out the first N steps to files or plot them in a figure window.
  prefs: []
  type: TYPE_NORMAL
- en: As an example image, you can use the classic 512 *×* 512 Lena test image from
    `scipy.misc`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The result should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![Exercises](img/lena_cat_0.jpg) | ![Exercises](img/lena_cat_1.jpg) | … |
    ![Exercises](img/lena_cat_128.jpg) | … | ![Exercises](img/lena_cat_256.jpg) |
    … | ![Exercises](img/lena_cat_511.jpg) | ![Exercises](img/lena_cat_512.jpg) |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 |  | 128 |  | 256 |  | 511 | 512 |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Compute the *x* and *y* mappings and use array indexing (refer to section *Array
    Indexing* in [Chapter 5](ch05.html "Chapter 5. Advanced Array Concepts"), *Advance
    Array Concepts*) to copy the pixel values.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 4** → Reading and plotting on images. SciPy comes with the `imread` function
    (in the `scipy.misc` module) for reading images, (refer to section *Reading and
    Writing Images* in [Chapter 12](ch12.html "Chapter 12. Input and Output"), *Input
    and output*). Write a short program that reads an image from file and plots the
    image contour at a given gray level value overlaid on the original image.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can get a gray level version of the image by averaging the color channels
    like this: `mean(im,axis=2)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 5** → Image edges. The zero crossings of the 2D Laplacian are a good
    indication of image edges. Modify the program in the previous exercise to use
    the `gaussian_laplace` or `laplace` function from the `scipy.ndimage` module to
    compute the 2D Laplacian and overlay the edges on top of the image.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 6** → Reformulate the Mandelbrod fractal example (see section *Images
    and Contours)* by using `orgid` instead of `meshgrid,` see also the explanation
    `ogrid` in *Function of two variables* in [Chapter 5](ch05.html "Chapter 5. Advanced
    Array Concepts"), *Advanced Array Concepts*. What is the difference between `orgid`,
    `mgrid`, and `meshgrid`?'
  prefs: []
  type: TYPE_NORMAL
