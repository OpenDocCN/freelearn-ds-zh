<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Iterating</h1></div></div></div><p>In this chapter, we will present iteration using loops and iterators. We will show examples of how this can be used with lists and generators. Iteration is one of the fundamental operations a computer is useful for. Traditionally, iteration is achieved by a <code class="literal">for</code> loop. A <code class="literal">for</code> loop is a repetition of a block of instructions a certain number of times. Inside the loop, one has access to a loop variable, in which the iteration number is stored.</p><p>The Python idiom is slightly different. A <code class="literal">for</code> loop in Python is primarily designed to exhaust a list, that is, to enumerate the elements of a list. The effect is similar to the repetition effect just described if one uses a list containing the first <em>n</em> integers.</p><p>A <code class="literal">for</code> loop only needs one element of the list at a time. It is therefore desirable to use a <code class="literal">for</code> loop with objects that are able to create those elements on demand, one at a time. This is what iterators achieve in Python.</p><div><div><div><div><h1 class="title"><a id="ch09lvl1sec75"/>The for statement</h1></div></div></div><p>The primary aim of the <code class="literal">for</code> statement is to traverse a list:</p><pre class="programlisting">for s in ['a', 'b', 'c']:&#13;
    print(s), # a b c</pre><p>In this example, the loop variable <em>s</em> is successively assigned to one element of the list. Notice that the loop variable is available after the loop has terminated. This may sometimes be useful; refer, for instance, the example in section <em>Controlling the flow inside the loop</em>.</p><p>One of the most frequent uses of a <code class="literal">for</code> loop is to repeat a given task a defined number of times, using the function <code class="literal">range</code>  (refer to section <em>Lists</em> of <a class="link" href="ch01.html" title="Chapter 1. Getting Started">Chapter 1</a>, <em>Getting Started</em>).</p><pre class="programlisting">for iteration in range(n): # repeat the following code n times&#13;
    ...</pre><p>If the purpose of a loop is to go through a list, many languages (including Python) offer the following pattern:</p><pre class="programlisting">for k in range(...):&#13;
    ...&#13;
    element = my_list[k]</pre><p>If the purpose of that code were to go through the list <code class="literal">my_list</code>, the preceding code would not make it very clear. For this reason, a better way to express this is as follows:</p><pre class="programlisting">for element in my_list:&#13;
    ...</pre><p>It is now clear at first glance that the preceding piece of code goes through the <code class="literal">my_list</code> list. Note that if you really need the index variable <em>k</em>, you may replace the preceding code by this:</p><pre class="programlisting">for k, element in enumerate(my_list):&#13;
    ...</pre><p>The intent of this piece of code is to go through <code class="literal">my_list</code> while keeping the index variable <em>k</em> available. A similar construction for arrays is the command <code class="literal">ndenumerate</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec76"/>Controlling the flow inside the loop</h1></div></div></div><p>Sometimes it is necessary to jump out of the loop, or to go directly to the next loop iteration. These two operations are performed by the <code class="literal">break</code> and <code class="literal">continue</code> commands.  The <code class="literal">break</code> keyword, as the name indicates, breaks the loop. Two situations can occur where the loop breaks:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The loop is completely executed.</li><li class="listitem" style="list-style-type: disc">The loop is left before it was completely executed (<code class="literal">break</code>).</li></ul></div><p>For the first case, special actions can be defined in an <code class="literal">else</code> block, which is executed if the whole list is traversed. This is useful in general if the purpose of the <code class="literal">for</code> loop is to find something and stop. Examples might be searching for one element satisfying a certain property inside a list. If such an element is not found, the <code class="literal">else</code> block is executed.</p><p>Here is a common usage in scientific computing. Quite often, we use an iterating algorithm that is not guaranteed to succeed. In that case, it is preferable to use a (big) finite loop so that the program does not get caught in an infinite loop. The <code class="literal">for</code>/<code class="literal">else</code> construct allows such an implementation:</p><pre class="programlisting">maxIteration = 10000&#13;
for iteration in range(maxIteration):&#13;
    residual = compute() # some computation&#13;
    if residual &lt; tolerance:&#13;
        break&#13;
else: # only executed if the for loop is not broken&#13;
    raise Exception("The algorithm did not converge")&#13;
print("The algorithm converged in {} steps".format(iteration+1))</pre></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec77"/>Iterators</h1></div></div></div><p>A <code class="literal">for</code> loop is primarily used to traverse a list, but it picks the elements of the list one at a time. In particular, there is no need to store the whole list in memory for the loop to work properly. The mechanism that allows <code class="literal">for</code> loops to work without lists is that of iterators.</p><p>An iterable object produces objects (to be passed to a <code class="literal">for</code> loop). Such an object, <code class="literal">obj</code>, may be used inside a <code class="literal">for</code> loop, as follows:</p><pre class="programlisting">for element in obj:&#13;
    ...</pre><p>The notion of iterator thus generalizes the idea of lists. The simplest example of an iterable object is given by lists. The produced objects are simply the objects stored in the list:</p><pre class="programlisting">L = ['A', 'B', 'C']&#13;
for element in L:&#13;
    print(element)</pre><p>An iterable object need not produce existing objects. The objects may, instead, be produced on the fly.</p><p>A typical iterable is the object returned by the function <code class="literal">range</code>. This function works as if it would generate a list of integers, but instead, the successive integers are produced on the fly when they are needed:</p><pre class="programlisting">for iteration in range(100000000):&#13;
    # Note: the 100000000 integers are not created at once&#13;
    if iteration &gt; 10:&#13;
        break</pre><p>If one really needs a list with all integers between 0 and 100,000,000, then it has to be formed explicitly:</p><pre class="programlisting">l=list(range(100000000))</pre><div><div><div><div><h2 class="title"><a id="ch09lvl2sec95"/>Generators</h2></div></div></div><p>You can create your own iterators using the <code class="literal">yield</code> keyword. For example, a generator for odd numbers smaller than  <em>n</em> can be defined:</p><pre class="programlisting">def odd_numbers(n):&#13;
    "generator for odd numbers less than n"&#13;
    for k in range(n):&#13;
        if k % 2 == 1:&#13;
            yield k</pre><p>Then you can use it as follows:</p><pre class="programlisting">g = odd_numbers(10)&#13;
for k in g:&#13;
    ...    # do something with k</pre><p>Or even like this:</p><pre class="programlisting">for k in odd_numbers(10):&#13;
    ... # do something with k</pre></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec96"/>Iterators are disposable</h2></div></div></div><p>One salient feature of iterators is that they may be used only once. In order to use the iterator again, you will have to create a new iterator object. Note that an iterable object is able to create new iterators as many times as necessary. Let us examine the case of a list:</p><pre class="programlisting">L = ['a', 'b', 'c']&#13;
iterator = iter(L)&#13;
list(iterator) # ['a', 'b', 'c']&#13;
list(iterator) # [] empty list, because the iterator is exhausted&#13;
&#13;
new_iterator = iter(L) # new iterator, ready to be used&#13;
list(new_iterator) # ['a', 'b', 'c']</pre><p>Each time a generator object is called, it creates a new iterator. Hence, when that iterator is exhausted, one has to call the generator again to obtain a new iterator:</p><pre class="programlisting">g = odd_numbers(10)&#13;
for k in g:&#13;
    ... # do something with k&#13;
&#13;
# now the iterator is exhausted:&#13;
for k in g: # nothing will happen!!&#13;
    ...&#13;
&#13;
# to loop through it again, create a new one:&#13;
g = odd_numbers(10)&#13;
for k in g:.&#13;
    ...</pre></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec97"/>Iterator tools</h2></div></div></div><p>Here are a couple of iterator tools that often come in very handy:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">enumerate</code> is used to enumerate another iterator. It produces a new iterator that yields pairs (iteration, element), where <code class="literal">iteration</code> stores the index of the iteration:</li></ul></div><pre class="programlisting">      A = ['a', 'b', 'c']&#13;
      for iteration, x in enumerate(A):&#13;
          print(iteration, x)&#13;
      # result: (0, 'a') (1, 'b') (2, 'c')</pre><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">reversed</code> creates an iterator from a list by going through that list backwards. Notice that this is different from creating a reversed list:</li></ul></div><pre class="programlisting">      A = [0, 1, 2]&#13;
      for elt in reversed(A):,&#13;
          print(elt)&#13;
          # result: 2 1 0</pre><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">itertools.count</code> is a possibly infinite iterator of integers:</li></ul></div><pre class="programlisting">      for iteration in itertools.count():&#13;
          if iteration &gt; 100:&#13;
              break # without this, the loop goes on forever&#13;
          print("integer {}".format(iteration))&#13;
          # prints the 100 first integer</pre><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">intertools.islice</code> truncates an iterator using the familiar <code class="literal">slicing</code> syntax; refer to <a class="link" href="ch03.html" title="Chapter 3. Container Types">Chapter 3</a>, <em>Container Types</em>. One application is creating a finite iterator from an infinite one:</li></ul></div><pre class="programlisting">      from itertools import count, islice&#13;
      for iteration in islice(count(), 10): &#13;
          # same effect as range(10)&#13;
          ...</pre><p>For example, let's find some odd numbers by combining <code class="literal">islice</code> with an infinite generator. First, we modify the generator for odd numbers so that it becomes an infinite generator:</p><pre class="programlisting">def odd_numbers():&#13;
    k=-1&#13;
    while True:&#13;
        k+=1&#13;
        if k%2==1:&#13;
        yield k</pre><p>Then, we use it with <code class="literal">islice</code> to get a list of some odd numbers:</p><pre class="programlisting">list(itertools.islice(odd_numbers(),10,30,8)) # returns [21, 37, 53]</pre></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec98"/>Generators of recursive sequences</h2></div></div></div><p>Assume that a sequence is given by an induction formula. For instance, consider the Fibonacci sequence, defined by the recurrence formula: <em>u<sub>n</sub> = u<sub>n</sub></em><sub>-1</sub> +<em> u</em><sub><em>n</em>-2</sub>.</p><p>This sequence depends on two initial values, namely <em>u</em><sub>0</sub> and <em>u</em><sub>1</sub>, although for the standard Fibonacci sequence those numbers are taken as 0 and 1 respectively. A nifty way of programming the generation of such a sequence is by using generators, as follows:</p><pre class="programlisting">def fibonacci(u0, u1):&#13;
    """&#13;
    Infinite generator of the Fibonacci sequence.&#13;
    """&#13;
    yield u0&#13;
    yield u1&#13;
    while True:&#13;
        u0, u1 = u1, u0+u1&#13;
        yield u1</pre><p>This may then be used, for instance, like this:</p><pre class="programlisting"># sequence of the 100 first Fibonacci numbers:&#13;
list(itertools.islice(fibonacci(0, 1), 100))</pre><div><div><div><div><h3 class="title"><a id="ch09lvl3sec27"/> Arithmetic geometric mean</h3></div></div></div><p>The iteration based on iteratively computing arithmetic and geometric means is called <strong>AGM iteration</strong> (refer to <a class="link" href="apa.html" title="Appendix . References">[1, p. 598]</a> for more information):</p><p>
</p><div><img src="img/B05511_09_01.jpg" alt=" Arithmetic geometric mean"/></div><p>
</p><p>It has the fascinating property that for  <img src="img/B05511_09_02.jpg" alt=" Arithmetic geometric mean"/> :</p><p>
</p><div><img src="img/B05511_09_03.jpg" alt=" Arithmetic geometric mean"/></div><p>
</p><p>The integral on the right-hand side is called a complete elliptic integral of the first kind. We now proceed to compute this elliptic integral. We use a generator to describe the iteration:</p><pre class="programlisting">def arithmetic_geometric_mean(a, b):&#13;
    """&#13;
    Generator for the arithmetic and geometric mean&#13;
    a, b initial values&#13;
    """ &#13;
    while True:    # infinite loop&#13;
         a, b = (a+b)/2, sqrt(a*b)&#13;
         yield a, b</pre><p>As the sequence {<em>a<sub>i</sub></em>} is convergent, the sequence {<em>c</em><sub><em>i</em></sub>}  defined by {<em>c<sub>i</sub></em>} = (<em>a<sub>i</sub>–b<sub>i</sub></em>)/2, converges to zero – a fact that will be used to terminate the iteration in the program to compute the elliptic integral:</p><pre class="programlisting">def elliptic_integral(k, tolerance=1e-5):&#13;
    """&#13;
    Compute an elliptic integral of the first kind.&#13;
    """&#13;
    a_0, b_0 = 1., sqrt(1-k**2)&#13;
    for a, b in arithmetic_geometric_mean(a_0, b_0):&#13;
        if abs(a-b) &lt; tolerance:&#13;
            return pi/(2*a)</pre><p>We have to make sure that the algorithm stops. Note that this code fully relies on the mathematical statement that the arithmetic geometric mean iteration converges (fast). In practical computing, we have to be careful while applying theoretical results, as they might no longer be valid in limited-precision arithmetic. The right way to make the preceding code safe is to use <code class="literal">itertools.islice</code>. The safe code is as follows (see the example under the section <em>Controlling the flow inside the loop</em> for another typical usage of the <code class="literal">for</code>/<code class="literal">else</code> statement):</p><pre class="programlisting">from itertools import islice&#13;
def elliptic_integral(k, tolerance=1e-5, maxiter=100):&#13;
    """&#13;
    Compute an elliptic integral of the first kind.&#13;
    """&#13;
    a_0, b_0 = 1., sqrt(1-k**2)&#13;
    for a, b in islice(arithmetic_geometric_mean(a_0, b_0), &#13;
                                                  maxiter):&#13;
        if abs(a-b) &lt; tolerance:&#13;
            return pi/(2*a)&#13;
    else:&#13;
        raise Exception("Algorithm did not converge")</pre><p>As an application, elliptic integrals may be used to compute the period of a <strong>pendulum</strong> of length <em>L</em> starting at an angle θ (refer to <a class="link" href="apa.html" title="Appendix . References">[18, p.114]</a> for more information) using:</p><p>
</p><div><img src="img/B05511_09_04.jpg" alt=" Arithmetic geometric mean"/></div><p>
</p><p>Using this formula, the period of the pendulum is easily obtained:</p><pre class="programlisting">def pendulum_period(L, theta, g=9.81):&#13;
    return 4*sqrt(L/g)*elliptic_integral(sin(theta/2))</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec78"/>Convergence acceleration</h1></div></div></div><p>We give an example of application of generators for convergence acceleration. This presentation follows closely the example given by <em>Pramode C.E</em> in <em>Python Generator Tricks</em> (refer <a class="link" href="apa.html" title="Appendix . References">[9]</a> for more information).</p><p>Note that a generator may take an other generator as an input parameter. For instance, suppose that we have defined a generator that generates the elements of a converging sequence. It is then possible to improve the convergence by an acceleration technique due to <em>Euler</em> and <em>Aitken</em>, often called Aitken’s Δ<sup>2</sup>-method (Refer <a class="link" href="apa.html" title="Appendix . References"> [33]</a><em>).</em> It transforms a sequence <em>s<sub>i</sub></em> into another by defining </p><p>
</p><div><img src="img/B05511_09_05.jpg" alt="Convergence acceleration"/></div><p>
</p><p>Both sequences have the same limit, but the sequence <img src="img/B05511_09_19.jpg" alt="Convergence acceleration"/>  converges significantly faster. One possible implementation is as follows:</p><pre class="programlisting">def Euler_accelerate(sequence):&#13;
    """&#13;
    Accelerate the iterator in the variable `sequence`.&#13;
    """&#13;
    s0 = next(sequence) # Si&#13;
    s1 = next(sequence) # Si+1&#13;
    s2 = next(sequence) # Si+2&#13;
    while True:&#13;
        yield s0 - ((s1 - s0)**2)/(s2 - 2*s1 + s0)&#13;
<em>      </em>  s0, s1, s2 = s1, s2, next(sequence)</pre><p>As an example, we use the classical series:</p><p>
</p><div><img src="img/B05511_09_06.jpg" alt="Convergence acceleration"/></div><p>
</p><p>It converges towards π/4<em>. </em>We implement this series as a generator in the following code:</p><pre class="programlisting">def pi_series():&#13;
    sum = 0.&#13;
    j = 1&#13;
    for i in itertools.cycle([1, -1]):&#13;
        yield sum&#13;
        sum += i/j&#13;
        j += 2</pre><p>We may now use the accelerated version of that sequence using this:</p><pre class="programlisting">Euler_accelerate(pi_series())</pre><p>Accordingly, the first <em>N</em> elements of that accelerated sequence are obtained with:</p><pre class="programlisting">itertools.islice(Euler_accelerate(pi_series()), N)</pre><p>For instance, the following figure (<em>Figure 9.1</em>) shows the convergence rate of the log of the error for the standard version of the sequence defined by the above formula and its accelerated version:</p><p>
</p><div><img src="img/seqacceleration-e1481709869771.jpg" alt="Convergence acceleration"/></div><p>
</p><p>Figure 9.1: Comparison between the sequence defined and its accelerated version</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec79"/>List filling patterns</h1></div></div></div><p>In this section we will compare different ways to fill lists. They are different in computational  efficiency and also in code readability.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec99"/>List filling with the append method
</h2></div></div></div><p>A ubiquitous programming pattern is to compute elements and store them in a list:</p><pre class="programlisting">L = []&#13;
for k in range(n):&#13;
    # call various functions here&#13;
    # that compute "result"&#13;
    L.append(result)</pre><p>This approach has a number of disadvantages:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The number of iterations is decided in advance. If there is a <code class="literal">break</code> instruction, then the preceding code takes care of both generating values and deciding when to stop. This is not desirable and lacks flexibility.</li><li class="listitem" style="list-style-type: disc">It makes the assumption that the user wants the whole history of the computation, for all the iterations. Suppose we are only interested in the sum of all the computed values. If there are many computed values, it does not make sense to store them, as it is much more efficient to add them one at a time.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec100"/>List from iterators</h2></div></div></div><p>Iterators provide us with an elegant solution to problems discussed previously:</p><pre class="programlisting">def result_iterator():&#13;
    for k in itertools.count(): # infinite iterator&#13;
        # call various functions here&#13;
        # that compute "result"&#13;
        ...&#13;
        yield result</pre><p>With iterators, we separate the task of generating the computed values without bothering about the stopping condition or about the storage. If the user of that code wants to store the <em>n</em> first values, it is easily done using the <code class="literal">list</code> constructor:</p><pre class="programlisting">L = list(itertools.islice(result_iterator(), n)) # no append needed!</pre><p>If the user wants the sum of the first <em>n</em> generated values, this construction is recommended:</p><pre class="programlisting"># make sure that you do not use scipy.sum here&#13;
s = sum(itertools.islice(result_iterator(), n))</pre><p>What we did here was separating the generation of elements on one hand, and storing those elements on the other.</p><p>If the purpose is really to build a list, and when the result at each step does not depend on previously computed elements, one may use the list comprehension syntax (refer to section <em>List</em> of <a class="link" href="ch03.html" title="Chapter 3. Container Types">Chapter 3</a>, <em>Container Types</em>, for more information):</p><pre class="programlisting">L = [some_function(k) for k in range(n)]</pre><p>When iteratively computing values that depend on the previously computed values, list comprehensions cannot help.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec101"/>Storing generated values</h2></div></div></div><p>Using iterators to fill out lists will work nicely most of the time, but there are complications to this pattern when the algorithm computing the new values is liable to throw an exception; if the iterator raises an exception along the way, the list will not be available! The following example illustrates this problem.</p><p>Suppose we generate the sequence defined recursively by <img src="img/B05511_09_07.jpg" alt="Storing generated values"/> . This sequence quickly diverges to infinity if the initial data <em>u</em><sub>0</sub> is greater than one. Let us generate it with a generator:</p><pre class="programlisting">import itertools&#13;
def power_sequence(u0):&#13;
    u = u0&#13;
    while True:&#13;
        yield u&#13;
        u = u**2</pre><p>If you try to obtain the first <em>20</em> elements of the sequence (initialized by <em>u<sub>0</sub> = 2</em>) by executing,</p><pre class="programlisting">list(itertools.islice(power_sequence(2.), 20))</pre><p>an exception will be raised and no list will be available, not even the list of elements before the exception was raised. There is currently no way to obtain a partially filled list from a possibly faulty generator. The only way around is to use the append method wrapped in an exception-catching block (refer to section <em>Exceptions</em> in <a class="link" href="ch10.html" title="Chapter 10. Error Handling">Chapter 10</a>, <em>Error Handling</em>, for more details):</p><pre class="programlisting">generator = power_sequence(2.)&#13;
L = []&#13;
for iteration in range(20):&#13;
    try:&#13;
        L.append(next(generator))&#13;
    except Exception:&#13;
        ...</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec80"/>When iterators behave as lists</h1></div></div></div><p>Some list operations also work on iterators. We will now examine the equivalents of <em>list comprehensions</em> and <em>list zipping</em> (refer to section <em>List</em> of <a class="link" href="ch03.html" title="Chapter 3. Container Types">Chapter 3</a>, <em>Container Types</em>, for more details).</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec102"/>Generator expression</h2></div></div></div><p>There is an equivalent of list comprehension for generators. Such a construction is called a generator expression:</p><pre class="programlisting">g = (n for n in range(1000) if not n % 100)&#13;
# generator for  100, 200, ... , 900</pre><p>This is useful in particular for computing sums or products because those operations are incremental; they only need one element at a time:</p><pre class="programlisting">sum(n for n in range(1000) if not n % 100) # returns 4500 </pre><p>In that code, you notice that the <code class="literal">sum</code> function is given one argument, which is a generator expression. Note that Python syntax allows us to omit the enclosing parentheses of generators when a generator is used as the <em>only</em> argument of a function.</p><p>Let us compute the Riemann zeta function <em>ζ</em>, whose expression is</p><p>
</p><div><img src="img/B05511_09_08.jpg" alt="Generator expression"/></div><p>
</p><p>With a generator expression, we may compute a partial sum of this series in one line:</p><pre class="programlisting">sum(1/n**s for n in itertools.islice(itertools.count(1), N))</pre><p>Note that we could also have defined a generator of the sequence 1 ⁄ <em>n<sup>s</sup></em>as follows:</p><pre class="programlisting">def generate_zeta(s):&#13;
    for n in itertools.count(1):&#13;
        yield 1/n**s</pre><p>Then we simply obtain the sum of the first <em>N</em> terms using:</p><pre class="programlisting">def zeta(N, s):&#13;
    # make sure that you do not use the scipy.sum here&#13;
    return sum(itertools.islice(generate_zeta(s), N))</pre><p>We point out that we used this way of computing the zeta (ζ) function as a demonstration of the use of generators in an elegant way. It is certainly not the most accurate and computationally efficient way to evaluate this function.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec103"/>Zipping iterators</h2></div></div></div><p>We saw in section <em>List</em>, <a class="link" href="ch03.html" title="Chapter 3. Container Types">Chapter 3</a>, <em>Container Types</em>, that it is possible to create a list out of two by zipping them together. The same operation exists for iterators:</p><pre class="programlisting">xg = x_iterator()  # some iterator&#13;
yg = y_iterator()  # another iterator&#13;
&#13;
for x, y in zip(xg, yg):&#13;
    print(x, y)</pre><p>The zipped iterator stops as soon as one of the iterators is exhausted. This is the same behavior as for a zip operation on lists.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec81"/>Iterator objects</h1></div></div></div><p>As we mentioned earlier, a <code class="literal">for</code> loop only needs an iterable object. Lists, in particular, are iterable. This means that a list is able to create an iterator from its contents. In fact, this is true for any object (not only lists): any object may be made iterable.</p><p>This is achieved via the <code class="literal">__iter__</code> method, which should return an iterator. Here we give an example where the <code class="literal">__iter__</code> method is a generator:</p><pre class="programlisting">class OdeStore:&#13;
    """&#13;
    Class to store results of ode computations&#13;
    """&#13;
    def __init__(self, data):&#13;
        "data is a list of the form [[t0, u0], [t1, u1],...]"&#13;
        self.data = data&#13;
    &#13;
    def __iter__(self):&#13;
        "By default, we iterate on the values u0, u1,..."&#13;
        for t, u in self.data:&#13;
            yield u&#13;
&#13;
store = OdeStore([[0, 1], [0.1, 1.1], [0.2, 1.3]])&#13;
for u in store:&#13;
    print(u)&#13;
# result: 1, 1.1, 1.3&#13;
list(store) # [1, 1.1, 1.3]</pre><p>If you try to use the features of an iterator with an object that is not iterable, an exception will be raised:</p><pre class="programlisting">&gt;&gt;&gt; list(3)&#13;
TypeError: 'int' object is not iterable</pre><p>In this example, the list function tries to iterate through the object <em>3</em> by calling the <code class="literal">__iter__</code> method. But this method is not implemented for integers and thus the exception is raised. The same would happen if we tried to cycle through a non-iterable object:</p><pre class="programlisting">&gt;&gt;&gt; for iteration in 3: pass&#13;
TypeError: 'int' object is not iterable</pre></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec82"/>Infinite iterations</h1></div></div></div><p>Infinite iterations are obtained either with an infinite iterator, with a <code class="literal">while</code> loop, or by recursion. Obviously, in practical cases, some condition stops the iteration. The difference with finite iterations is that it is impossible to say by a cursory examination of the code, whether the iteration will stop or not.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec104"/>The while loop</h2></div></div></div><p>The <code class="literal">while</code> loop may be used to repeat a code block until a condition is fulfilled:</p><pre class="programlisting">while condition:&#13;
    &lt;code&gt;</pre><p>A <code class="literal">while</code> loop is equivalent to the following code:</p><pre class="programlisting">for iteration in itertools.count():&#13;
    if not condition:&#13;
        break&#13;
    &lt;code&gt;</pre><p>So a <code class="literal">while</code> loop is equivalent to an infinite iterator, which might be stopped if a condition is fulfilled. The danger of such a construction is obvious: the code may be trapped in an infinite loop if the condition is never fulfilled.</p><p>The problem in scientific computing is that one is not always sure that an algorithm will converge. Newton iteration, for instance, might not converge at all. If that algorithm were implemented inside a <code class="literal">while</code> loop, the corresponding code would be trapped in an infinite loop for some choices of initial conditions.</p><p>We therefore give an advice that finite iterators are often better suited for such a task. The following construction replaces, often advantageously, the use of a <code class="literal">while</code> loop:</p><pre class="programlisting">maxit = 100&#13;
for nb_iterations in range(max_it):&#13;
    ...&#13;
else:&#13;
    raise Exception("No convergence in {} iterations".format(maxit))</pre><p>The first advantage is that the code is guaranteed to execute in a finite time no matter what happens. The second advantage is that the variable <code class="literal">nb_iterations</code> contains the number of iterations that was necessary for the algorithm to converge.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec105"/>Recursion</h2></div></div></div><p>A recursion occurs when a function calls itself (refer to section <em>Recursive Function </em>in <a class="link" href="ch07.html" title="Chapter 7. Functions">Chapter 7</a>, <em>Functions</em>).</p><p>When doing recursions, it is the recursion depth, that is the number of iterations, which brings your computer to its limits. We demonstrate this here by considering a simple recursion, which actually contains no computations at all. It assigns to the iterates only the value zero:</p><pre class="programlisting">def f(N):&#13;
    if N == 0: &#13;
        return 0&#13;
    return f(N-1)</pre><p>Depending on your system, this program may choke for <em>N ≥ 10000</em> (too much memory is used). The result is that the Python interpreter crashes without further exception. Python provides a mechanism to raise an exception when a too high recursion depth is detected. This maximum recursion depth may be changed by executing:</p><pre class="programlisting">import sys &#13;
sys.setrecursionlimit(1000)</pre><p>The actual value of the recursion limit can be obtained by <code class="literal">sys.getrecursionlimit()</code>.</p><p>Be aware though, that choosing too high a number may imperil the stability of your code, since Python might crash before that maximum depth is reached. It is therefore often wise to leave the recursion limit as it is.</p><p>By comparison, the following, non recursive, program runs ten of millions of iterations without any problem:</p><pre class="programlisting">for iteration in range(10000000):&#13;
    pass</pre><p>We advocate that, if possible, recursion should be avoided in Python. This applies obviously only if there is an appropriate alternative iterative algorithm available. The first reason is that a recursion of depth <em>N</em> involves <em>N</em> function calls at the same time, which might result in a significant overhead. The second reason is that it is an infinite iteration, that is, it is difficult to give an upper bound to the number of steps necessary before the recursion is over.</p><p>Note that in some very special cases (tree traversal) recursion is unavoidable. Besides, in some cases (with small recursion depths) recursive programs might be preferred due to readability.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec83"/>Summary</h1></div></div></div><p>In this chapter, we studied iterators,  a programming construct very near to a mathematical description of iterative methods. You saw the <code class="literal">yield</code> keyword and met finite and infinite iterators.</p><p>We showed that an iterator can be exhausted. More special aspects such as iterator comprehension and recursive iterators were introduced and demonstrated with the help of examples.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec84"/>Exercises</h1></div></div></div><p>
<strong>Ex. 1</strong> → Compute the value of the sum:</p><p>
</p><div><img src="img/B05511_09_09.jpg" alt="Exercises"/></div><p>
</p><p>
<strong>Ex. 2</strong> → Create a generator that computes the sequence defined by the relation:</p><p>
</p><div><img src="img/un2nm1.jpg" alt="Exercises"/></div><p>
</p><p>
<strong>Ex. 3</strong> → Generate all the even numbers.</p><p>
<strong>Ex. 4</strong> → Let <img src="img/B05511_09_10.jpg" alt="Exercises"/>. In calculus, it is shown that <img src="img/limsn.jpg" alt="Exercises"/>. Determine experimentally the smallest number <em>n</em> such that <img src="img/tempowminus5.jpg" alt="Exercises"/>. Use a generator for this task.</p><p>
<strong>Ex. 5</strong> → Generate all prime numbers less than a given integer. Use the algorithm called Sieve of Eratosthenes.</p><p>
<strong>Ex. 6</strong> → Solving the differential equation <img src="img/odesin.jpg" alt="Exercises"/> by applying the explicit Euler method results in the recursion:</p><p>
</p><div><img src="img/euler1.jpg" alt="Exercises"/></div><p>
</p><p>Write a generator that computes the solution values <em>u<sub>n</sub></em> for a given initial value <em>u</em><sub>0</sub> and for a given value of the time step <em>h</em>.</p><p>
<strong>Ex. 7</strong> → Compute π using the formula:</p><p>
</p><div><img src="img/B05511_09_11.jpg" alt="Exercises"/></div><p>
</p><p>The integral can be approximated using the composite trapezoidal rule, that is, by this formula:</p><p>
</p><div><img src="img/B05511_09_12.jpg" alt="Exercises"/></div><p>
</p><p>where <img src="img/grid_value.jpg" alt="Exercises"/>.</p><p>Program a <em>generator</em> for the values <em>y<sub>i</sub> = f(x<sub>i</sub>)</em> and evaluate the formula by summing one term after the other. Compare your results with the <code class="literal">quad</code> function of SciPy.</p><p>
<strong>Ex. 8</strong> → Let <em>x </em>= [1, 2, 3] and <em>y </em>= [-1, -2, -3]. What is the effect of the code <code class="literal">zip(*zip(x, y))</code>? Explain how it works.</p><p>
<strong>Ex. 9</strong> → Complete elliptic integrals can be computed by the function <code class="literal">scipy.special.ellipk</code>. Write a function, which counts the number of iterations needed with the  AGM iteration until the result coincides up to a given tolerance (note that the input parameter <em>m</em> in <code class="literal">ellipk</code> corresponds to <em>k<sup>2  </sup></em>in the definition in the section <em>Arithmetic geometric mean) </em>.</p><p>
<strong>Ex. 10</strong> → Consider the sequence defined by:</p><p>
</p><div><img src="img/En.jpg" alt="Exercises"/></div><p>
</p><p>It converges monotonically to zero: <em>E<sub>1</sub> &gt;E<sub>2</sub> &gt; . . . &gt; 0</em>. By integration by parts, one can show that the sequence <em>E<sub>n</sub></em> fulfills the following recursion:</p><p>
</p><div><img src="img/E_recurse.jpg" alt="Exercises"/></div><p>
</p><p>Compute the first 20 terms of the recursion by using an appropriate generator and compare the results with those obtained by numerical integration with <code class="literal">scipy.integrate.quad</code>. Do the same by reversing the recursion:</p><p>
</p><div><img src="img/B05511_09_17.jpg" alt="Exercises"/></div><p>
</p><p>Use the <code class="literal">exp</code> function to evaluate the exponential function. What do you observe? Do you have an explanation? (refer to <a class="link" href="apa.html" title="Appendix . References">[29]</a><em>)</em></p><p>
</p><div><img src="img/Euler-e1481710075110.jpg" alt="Exercises"/></div><p>
</p><p>Figure 9.2: A convergence study of functions approximating to sin(x)</p><p>
<strong>Ex. 11</strong> → The  sine-function  can be expressed due to Euler as</p><p>
</p><div><img src="img/B05511_09_18.jpg" alt="Exercises"/></div><p>
</p><p>Write a generator that generates the function values <em>P<sub>k</sub>(x)</em>. Set <code class="literal">x=linspace(-1,3.5*pi,200) </code>and demonstrate graphically how good <em>P<sub>k</sub>(x)</em> approximates sin for increasing <em>k</em>. In previous figure (<em>Figure 9.2</em>), the possible result is shown (refer to <a class="link" href="apa.html" title="Appendix . References">[11, Th. 5.2, p. 65]</a>).</p></div></body></html>