- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Developing a Native Application with Snowpark
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Snowpark开发原生应用
- en: In today’s data-driven world, the demand for actionable insights is at an all-time
    high. However, traditional data analysis workflows often need help with slow processing
    times, siloed data, and complex development procedures. This is where Snowpark,
    with its unique features for native applications, comes to the rescue. By offering
    a powerful and innovative solution, Snowpark overcomes these challenges and opens
    up new revenue streams for organizations through distribution in the Snowflake
    Marketplace.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天以数据驱动的世界中，对可操作洞察的需求达到了前所未有的高度。然而，传统的数据分析工作流程往往需要解决缓慢的处理时间、孤岛数据和复杂的开发程序等问题。这正是Snowpark凭借其原生应用的独特特性来拯救的地方。通过提供强大而创新的解决方案，Snowpark克服了这些挑战，并通过在Snowflake市场中的分发为组织开辟了新的收入渠道。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Introduction to the Native App Framework
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原生应用框架简介
- en: Developing the native application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发原生应用
- en: Publishing the native application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布原生应用
- en: Managing the native application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理原生应用
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To set up the environment, please refer to the technical requirements in the
    previous chapter. The supporting materials are available at [https://github.com/PacktPublishing/The-Ultimate-Guide-To-Snowpark](https://github.com/PacktPublishing/The-Ultimate-Guide-To-Snowpark).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置环境，请参考上一章中的技术要求。支持材料可在[https://github.com/PacktPublishing/The-Ultimate-Guide-To-Snowpark](https://github.com/PacktPublishing/The-Ultimate-Guide-To-Snowpark)找到。
- en: Introduction to the Native Apps Framework
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原生应用框架简介
- en: Data analysis has evolved beyond static reports. In today’s business landscape,
    real-time insights, interactive visuals, and seamless integration with operational
    tools are in high demand. While traditional methods utilizing SQL or pre-built
    dashboards have their place, they need more agility and flexibility for modern
    data exploration. This is where native applications step in, offering exciting
    potential for immediate and actionable insights and sparking new possibilities
    for your data analysis.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 数据分析已经超越了静态报告。在当今的商业环境中，实时洞察、交互式视觉和与操作工具的无缝集成需求极高。虽然使用SQL或预构建仪表板的传统方法有其位置，但它们需要更多的敏捷性和灵活性来满足现代数据探索的需求。这正是原生应用介入的地方，它们提供了即时和可操作的洞察的巨大潜力，并为你的数据分析开启了新的可能性。
- en: Snowflake native applications offer a unique advantage by allowing you to develop
    applications directly within the Data Cloud. These applications reside alongside
    your data, eliminating the need for data movement or external connectors. This
    removes the data transfer bottleneck between systems and significantly reduces
    network latency. Snowflake’s architecture, optimized for parallel processing and
    distributed storage, enables faster analysis of complex queries and large datasets
    than traditional models. Moreover, the native applications benefit from Snowflake’s
    secure foundation, which offers a multi-layered security architecture with features
    such as encryption, access controls, and audit trails without separate infrastructure.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Snowflake原生应用通过允许你在数据云中直接开发应用程序，提供了一个独特的优势。这些应用程序与你的数据并存，消除了数据移动或外部连接器的需求。这消除了系统之间的数据传输瓶颈，并显著降低了网络延迟。Snowflake的架构，针对并行处理和分布式存储进行了优化，比传统模型能更快地分析复杂查询和大数据集。此外，原生应用还受益于Snowflake的安全基础，它提供了一个多层安全架构，包括加密、访问控制和审计跟踪等特性，无需单独的基础设施。
- en: Snowflake’s native application Landscape
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Snowflake原生应用景观
- en: The Snowflake Native App Framework is a powerful tool for building data applications
    that utilize Snowflake’s core functionality. With this framework, you can extend
    the capabilities of Snowflake features by sharing data and relevant business logic
    with other Snowflake accounts. This can include using Streamlit apps, stored procedures,
    and functions written in the Snowpark API, JavaScript, and SQL. By leveraging
    the power of Snowflake’s capabilities, you can create sophisticated applications
    that are tailored to your unique needs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Snowflake原生应用框架是构建利用Snowflake核心功能的数据应用的有力工具。使用此框架，你可以通过与其他Snowflake账户共享数据和相关的业务逻辑来扩展Snowflake功能。这可以包括使用Streamlit应用、存储过程和用Snowpark
    API、JavaScript和SQL编写的函数。通过利用Snowflake的能力，你可以创建针对你独特需求的高级应用。
- en: In addition to expanding Snowflake’s features, the Snowflake Native App Framework
    also allows you to share your applications with others. You can distribute your
    apps through free or paid listings in the Snowflake Marketplace, or privately
    distribute them to specific consumers. Furthermore, this framework allows you
    to create rich visualizations in your application using Streamlit. With the Snowflake
    Native App Framework, you have all the tools you need to create powerful, scalable,
    and flexible data applications that meet your organization’s needs.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 除了扩展Snowflake的功能外，Snowflake Native App Framework还允许您与他人共享您的应用程序。您可以通过Snowflake市场的免费或付费列表分发您的应用程序，或者私下将它们分发给特定的消费者。此外，此框架还允许您使用Streamlit在应用程序中创建丰富的可视化。借助Snowflake
    Native App Framework，您拥有创建强大、可扩展和灵活的数据应用程序所需的所有工具，以满足您组织的需要。
- en: In summary, the Snowflake Native App Framework provides a comprehensive solution
    for building sophisticated data applications. Whether you need to expand Snowflake’s
    capabilities, share your applications with others, or create rich visualizations,
    this framework has you covered. With its powerful features and scalability, the
    Snowflake Native App Framework is an essential tool for any organization looking
    to build data applications that leverage Snowflake’s full potential.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Snowflake Native App Framework为构建复杂的数据应用程序提供了一个全面的解决方案。无论您需要扩展Snowflake的功能、与他人共享应用程序，还是创建丰富的可视化，此框架都能满足您的需求。凭借其强大的功能和可扩展性，Snowflake
    Native App Framework是任何希望利用Snowflake全部潜能构建数据应用程序的组织不可或缺的工具。
- en: Snowflake native applications consist of business logic that defines the core
    functionality of your application, encompassing tasks such as data transformations,
    calculations, and model predictions. The data model can be developed using Snowpark,
    where native applications leverage Snowflake’s powerful engine to interact with
    your data efficiently. Snowpark enables you to manipulate tables, query datasets,
    and extract meaningful insights. The user interface can be developed using Streamlit,
    and users can interact with the application natively within Snowflake.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Snowflake原生应用程序由定义应用程序核心功能的企业逻辑组成，包括数据转换、计算和模型预测等任务。数据模型可以使用Snowpark开发，原生应用程序利用Snowflake强大的引擎高效地与您的数据交互。Snowpark使您能够操作表、查询数据集并提取有意义的见解。用户界面可以使用Streamlit开发，用户可以在Snowflake中以原生方式与应用程序交互。
- en: Snowpark bridges the gap between traditional data analysis and modern application
    development by offering several key features that make it the ideal engine for
    building native applications. The applications seamlessly scale with your data
    volume, eliminating the need for manual infrastructure provisioning.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Snowpark通过提供几个关键特性来弥合传统数据分析与现代应用程序开发之间的差距，使其成为构建原生应用程序的理想引擎。应用程序可以无缝地与您的数据量一起扩展，消除了手动基础设施配置的需求。
- en: Before diving deep into developing a Snowpark application, let us understand
    the benefits that Native Apps provide.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入开发Snowpark应用程序之前，让我们了解Native Apps提供的优势。
- en: Native App Framework components
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Native App Framework组件
- en: 'The **Snowflake Native App Framework** components consist of the **provider**,
    the developer of the apps and the distributor of them for consumption, and the
    **consumer**, who accesses the data and application that the provider distributes.
    The high-level components of the Native App Framework are shown in the following
    diagram:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**Snowflake Native App Framework**的组件包括**提供者**，应用程序的开发者和分发者，以及**消费者**，他们访问提供者分发的数据和应用程序。Native
    App Framework的高级组件如下图所示：'
- en: '![Figure 7.1 – Native App Framework components](img/B19923_07_1.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – Native App Framework组件](img/B19923_07_1.jpg)'
- en: Figure 7.1 – Native App Framework components
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – Native App Framework组件
- en: The provider account is where the application is developed and packaged for
    distribution. The package includes the application code, Snowpark models, and
    associated data. It also consists of the various licenses and entitlements required
    for the application packages. The application is then packed and can be made available
    for distribution.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 提供者账户是应用程序开发和打包以供分发的地方。该包包括应用程序代码、Snowpark模型和相关数据。它还包括应用程序包所需的各项许可证和权益。然后，应用程序被打包并可供分发。
- en: The provider can distribute the packages as a public marketplace listing that
    other organizations can consume or through a private listing, which can also be
    distributed as internal apps within the same organization. The consumer account
    deploys the application and can consume it with local data and access external
    systems. The app for this can be built using Streamlit in Python.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 提供者可以将包作为公共市场列表分发，供其他组织消费，或者通过私人列表分发，这也可以在同一个组织内部作为内部应用分发。消费者账户部署应用程序，并可以使用本地数据访问外部系统。此类应用可以使用Python中的Streamlit构建。
- en: Streamlit in Snowflake
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Snowflake中的Streamlit
- en: Streamlit is an open source Python library that makes creating and sharing custom
    web apps for machine learning and data science easy. It allows you to build and
    deploy powerful data applications quickly. Streamlit in Snowflake helps you move
    beyond pure data and enter the territory of application logic, making the application
    come alive and transforming insights into actions and reactions. Using Streamlit
    in Snowflake, you can build applications that process and use data in Snowflake
    without moving data or application code to an external system. The Native App
    can embed interactive data visualizations and user interfaces directly into the
    app, enabling dynamic charts and graphs that update as users interact with the
    data, and interactive data exploration tools for users to drill down and uncover
    more profound insights.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Streamlit是一个开源的Python库，它使得创建和分享用于机器学习和数据科学的自定义Web应用变得简单。它允许你快速构建和部署强大的数据应用。Snowflake中的Streamlit帮助你超越纯粹的数据，进入应用逻辑的领域，使应用变得生动，并将见解转化为行动和反应。使用Snowflake中的Streamlit，你可以构建在Snowflake中处理和使用数据的应用，而无需将数据或应用代码移动到外部系统。原生应用可以直接将交互式数据可视化和用户界面嵌入到应用中，实现动态图表和图形，这些图表和图形在用户与数据交互时更新，并为用户提供交互式数据探索工具，以便深入挖掘并发现更深刻的见解。
- en: Let’s discuss the various benefits provided by Native Apps.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论原生应用提供的各种优势。
- en: Benefits of Native Apps
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原生应用的优势
- en: Native applications built within Snowflake offer unparalleled advantages for
    data analysis and decision-making. Native Apps provide multiple benefits; by offering
    streamlined development with Snowpark, they eliminate the steep learning curve
    typically associated with a development framework. Developers can seamlessly transition
    to data manipulation within Snowflake’s robust cloud environment, allowing rapid
    innovation. This empowers developers to focus on building impactful applications
    and extracting valuable insights without syntax roadblocks.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在Snowflake内部构建的原生应用为数据分析与决策提供了无与伦比的优势。原生应用提供了多项好处；通过提供Snowpark的简化开发，它们消除了与开发框架相关联的陡峭学习曲线。开发者可以无缝过渡到Snowflake强大云环境中的数据操作，从而实现快速创新。这使开发者能够专注于构建有影响力的应用和提取有价值的见解，而无需克服语法障碍。
- en: Snowflake’s integration with Streamlit enables developers to unleash the power
    of their existing Python expertise directly within Snowflake. Developers can build
    sophisticated applications for data exploration, machine learning, and interactive
    dashboards. This eliminates context switching and maximizes productivity within
    Snowflake’s secure and scalable environment. Snowflake’s *data residency* principle
    ensures that valuable information remains within the secure perimeter, significantly
    reducing the risk of data breaches.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Snowflake与Streamlit的集成使得开发者能够在Snowflake内部直接释放他们现有的Python专长。开发者可以构建用于数据探索、机器学习和交互式仪表板的高级应用。这消除了环境切换，并在Snowflake安全且可扩展的环境中最大化了生产力。Snowflake的*数据驻留*原则确保有价值的信息保持在安全范围内，显著降低了数据泄露的风险。
- en: Native applications seamlessly interface with existing Snowflake features and
    tools, such as Tasks and Streams, creating an integrated analytics environment.
    Leveraging Snowflake Tasks for automated execution and scheduling, along with
    Snowflake Streams or Snowpipe for real-time data ingestion and delivery, ensures
    continuous updates and enhances performance. Snowflake **user-defined functions**
    (**UDFs**) and stored procedures also improve flexibility and minimize data movement.
    We will explore Streamlit in Snowflake in the next section.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 原生应用能够无缝地与现有的Snowflake功能和工具，如任务和流，进行接口交互，创建一个集成的分析环境。利用Snowflake任务进行自动执行和调度，结合Snowflake流或Snowpipe进行实时数据摄取和交付，确保持续更新并提升性能。Snowflake
    **用户定义函数**（**UDFs**）和存储过程也提高了灵活性并最小化了数据移动。我们将在下一节中探讨Snowflake中的Streamlit。
- en: As we delve deeper into this chapter, we will utilize the familiar Bike Sharing
    dataset and its associated Snowpark model we saw in the previous chapters and
    develop a Streamlit application using Snowsight.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们深入本章内容，我们将利用熟悉的共享单车数据集及其在上一章中看到的关联Snowpark模型，并使用Snowsight开发Streamlit应用程序。
- en: Developing the native application
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发本地应用程序
- en: The initial step involves developing a Streamlit application to illustrate the
    development of the Snowpark model. The application provides a user-friendly interface
    that streamlines the exploration and understanding of Snowpark’s underlying data
    and modeling techniques. Within Snowflake, the Streamlit application can be developed
    through a dedicated Python editor within Snowsight. This editor empowers users
    to write, edit, and execute code for their Streamlit applications effortlessly.
    Notably, it offers invaluable features such as auto-completion and comprehensive
    documentation, facilitating a smooth and intuitive development experience while
    leveraging the full potential of Streamlit and Snowpark functionalities. We will
    be using this editor to develop the Streamlit application.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步涉及开发一个Streamlit应用程序来展示Snowpark模型的开发。该应用程序提供了一个用户友好的界面，简化了对Snowpark底层数据和建模技术的探索和理解。在Snowflake中，可以通过Snowsight中的专用Python编辑器开发Streamlit应用程序。此编辑器使用户能够轻松地编写、编辑和执行Streamlit应用程序的代码。值得注意的是，它提供了自动完成和全面文档等宝贵功能，在利用Streamlit和Snowpark功能的同时，提供了一个顺畅直观的开发体验。我们将使用此编辑器来开发Streamlit应用程序。
- en: 'Let’s delve into the detailed steps of creating a Streamlit application within
    the Snowflake environment:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解在Snowflake环境中创建Streamlit应用程序的详细步骤：
- en: Note
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The **CREATE STREAMLIT** privilege is required for the user at the schema level
    to develop the application and this application will utilize warehouse compute
    to run it, so choose the warehouse size appropriately. X-Small will be sufficient
    for the Streamlit and Native Apps developed in this chapter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 用户在模式级别需要**CREATE STREAMLIT**权限来开发应用程序，并且此应用程序将利用仓库计算来运行，因此请适当选择仓库大小。X-Small将足以用于本章中开发的Streamlit和本地应用程序。
- en: 'Upon successful login, select **Projects** from the left navigation bar within
    Snowsight and select **Streamlit** to initiate the Streamlit application:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录成功后，在Snowsight左侧导航栏中选择**项目**，然后选择**Streamlit**以启动Streamlit应用程序：
- en: '![Figure 7.2 – Streamlit Snowsight](img/B19923_07_2.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – Streamlit Snowsight](img/B19923_07_2.jpg)'
- en: Figure 7.2 – Streamlit Snowsight
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – Streamlit Snowsight
- en: 'Within the Streamlit projects section, click the **+ Streamlit App** button
    to create a new Streamlit application:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Streamlit项目部分，点击**+ Streamlit应用程序**按钮以创建一个新的Streamlit应用程序：
- en: '![Figure 7.3 – Streamlit app creation](img/B19923_07_3_V.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3 – Streamlit应用程序创建](img/B19923_07_3_V.jpg)'
- en: Figure 7.3 – Streamlit app creation
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – Streamlit应用程序创建
- en: 'Once you click the button, the **Create Streamlit App** window will appear.
    Provide a name for your application, as shown here:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击按钮后，将出现**创建Streamlit应用程序**窗口。提供应用程序名称，如此处所示：
- en: '![Figure 7.4 – Configuring the application details](img/B19923_07_4.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4 – 配置应用程序详情](img/B19923_07_4.jpg)'
- en: Figure 7.4 – Configuring the application details
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 配置应用程序详情
- en: 'Select the appropriate warehouse from the drop-down menu where you wish to
    execute your application’s queries. Specify the database and schema where the
    application will be hosted from the respective drop-down menus:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉菜单中选择您希望执行应用程序查询的适当仓库。从相应的下拉菜单中指定应用程序将托管的数据库和模式：
- en: '![Figure 7.5 – Defining the execution environment](img/B19923_07_5_V.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5 – 定义执行环境](img/B19923_07_5_V.jpg)'
- en: Figure 7.5 – Defining the execution environment
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 定义执行环境
- en: 'Finalize the creation process by clicking the **Create** button, which initiates
    the setup of your Streamlit application. Upon successful creation, Streamlit will
    be launched in your Snowflake editor, presenting an example of the Streamlit application
    in the **Viewer** mode. This mode offers a preview of how the application will
    appear to end users, facilitating visualization and assessment of its user interface:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**创建**按钮完成创建过程，这将启动Streamlit应用程序的设置。创建成功后，Streamlit将在您的Snowflake编辑器中启动，以**查看器**模式展示Streamlit应用程序的示例。此模式提供了应用程序将如何呈现给最终用户的预览，有助于可视化评估其用户界面：
- en: '![Figure 7.6 – The Streamlit Snowflake editor](img/B19923_07_6.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6 – Streamlit Snowflake编辑器](img/B19923_07_6.jpg)'
- en: Figure 7.6 – The Streamlit Snowflake editor
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – Streamlit Snowflake 编辑器
- en: In the next section, we will discover and familiarize ourselves with the Streamlit
    editor.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将发现并熟悉 Streamlit 编辑器。
- en: The Streamlit editor
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Streamlit 编辑器
- en: The Streamlit editor in Snowflake helps develop the Streamlit application within
    Snowflake. The editor is built into the Snowsight interface, making it easier
    to create without needing an external environment. The Streamlit in Snowflake
    interface is structured into three primary panes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Snowflake 中的 Streamlit 编辑器有助于在 Snowflake 中开发 Streamlit 应用程序。编辑器集成在 Snowsight
    界面中，使得创建应用程序更加容易，无需外部环境。Snowflake 中的 Streamlit 界面分为三个主要窗格。
- en: The object browser provides visibility into the databases, schemas, and views
    accessible under your permissions, aiding in data exploration and access. The
    Streamlit editor houses a dedicated Python editor tailored to craft your Streamlit
    application code, facilitating seamless development and customization. The Streamlit
    preview displays the running Streamlit application in real time, allowing you
    to observe its behavior and appearance as you make modifications.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对象浏览器可以查看你权限下可访问的数据库、模式和视图，有助于数据探索和访问。Streamlit 编辑器包含一个定制的 Python 编辑器，专门用于编写
    Streamlit 应用程序代码，便于开发和定制。Streamlit 预览实时显示运行中的 Streamlit 应用程序，允许你在修改时观察其行为和外观。
- en: By default, only the Streamlit editor and preview panes are visible. However,
    you can adjust the interface layout according to your preferences. Use the **Show**/**Hide**
    buttons in the lower-left corner of the Streamlit in Snowflake editor to toggle
    the visibility of different panes according to your workflow requirements.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，只有 Streamlit 编辑器和预览窗格可见。然而，你可以根据个人喜好调整界面布局。使用 Snowflake 编辑器左下角的 **显示**/**隐藏**
    按钮根据工作流程需求切换不同窗格的可见性。
- en: Now that we are familiar with the interface, let’s create our first Streamlit
    application in the next section.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了界面，接下来将在下一节创建我们的第一个 Streamlit 应用程序。
- en: Running the Streamlit application
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行 Streamlit 应用程序
- en: In this section, we will build an application using the Streamlit code from
    the `chapter_7` folder of the GitHub repository ([https://github.com/PacktPublishing/The-Ultimate-Guide-To-Snowpark/tree/main/chapter_7](https://github.com/PacktPublishing/The-Ultimate-Guide-To-Snowpark/tree/main/chapter_7)).
    The SnowparkML code has been extensively covered in previous chapters and is available
    in the repository. Copy and paste the code in the `streamlit_bike_share_analysis.py`
    file from the repository into the Streamlit editor. The code requires the `BSD_TRAIN`
    table created from the *Bike Sharing* dataset that we have used before. The `chapter_7_data_load.ipynb`
    file can be run to create the required table.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 GitHub 仓库中 `chapter_7` 文件夹下的 Streamlit 代码构建一个应用程序（[https://github.com/PacktPublishing/The-Ultimate-Guide-To-Snowpark/tree/main/chapter_7](https://github.com/PacktPublishing/The-Ultimate-Guide-To-Snowpark/tree/main/chapter_7)）。SnowparkML
    代码在前几章中已有详细说明，并在仓库中提供。将仓库中的 `streamlit_bike_share_analysis.py` 文件复制粘贴到 Streamlit
    编辑器中。该代码需要使用之前使用的 *Bike Sharing* 数据集创建的 `BSD_TRAIN` 表。可以通过运行 `chapter_7_data_load.ipynb`
    文件来创建所需的表。
- en: 'Now, execute the Streamlit application by selecting the **Run** option to refresh,
    and the result will be updated within the Streamlit preview pane:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过选择 **运行** 选项来刷新应用程序，结果将在 Streamlit 预览窗格中更新：
- en: '![Figure 7.7 – The Streamlit App preview](img/B19923_07_7_V.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.7 – Streamlit 应用预览](img/B19923_07_7_V.jpg)'
- en: Figure 7.7 – The Streamlit App preview
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 – Streamlit 应用预览
- en: 'The code requires several packages to be installed in your Streamlit environment.
    Click on the **Packages** button in the code editor and select the following packages:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码需要在你的 Streamlit 环境中安装几个包。在代码编辑器中点击 **包** 按钮并选择以下包：
- en: Matplotlib
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Matplotlib
- en: Seaborn
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Seaborn
- en: SciPy
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SciPy
- en: Snowflake-ml-python
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Snowflake-ml-python
- en: 'You have successfully run your first Streamlit app inside Snowflake. You can
    select the app to execute it within the Snowsight context:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你已在 Snowflake 中成功运行了第一个 Streamlit 应用程序。你可以在 Snowsight 环境中选择应用程序来执行：
- en: '![Figure 7.8 – The Streamlit app](img/B19923_07_8.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.8 – Streamlit 应用](img/B19923_07_8.jpg)'
- en: Figure 7.8 – The Streamlit app
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8 – Streamlit 应用
- en: Note
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Snowsight offers a convenient platform for crafting single-page Streamlit applications.
    However, deploying multi-page Streamlit apps requires a slightly different approach,
    necessitating the utilization of SQL commands. Once the deployment process is
    complete, you can seamlessly navigate and interact with the multi-page application
    directly within Snowsight’s interface.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Snowsight 为创建单页 Streamlit 应用程序提供了一个方便的平台。然而，部署多页 Streamlit 应用程序需要稍微不同的方法，需要使用
    SQL 命令。一旦部署过程完成，您就可以在 Snowsight 的界面中无缝导航和交互多页应用程序。
- en: In the following section, we will develop and push the Streamlit application
    using the Native App Framework.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用原生应用程序框架开发和推送 Streamlit 应用程序。
- en: Developing with the Native App Framework
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用原生应用程序框架进行开发
- en: Now that our Streamlit application is operational, let’s explore the process
    of transforming it into a Native App within the Snowflake ecosystem. In this section,
    we’ll give a detailed walkthrough on leveraging the Native App Framework to develop
    applications to share data and associated business logic with other Snowflake
    accounts. We will primarily demonstrate this using the Snowsight web interface,
    which can also be created using a client such as VS Code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的 Streamlit 应用程序已经运行，让我们探索将其转换为 Snowflake 生态系统中的原生应用程序的过程。在本节中，我们将详细介绍如何利用原生应用程序框架开发应用程序，以便与其他
    Snowflake 账户共享数据和相关的业务逻辑。我们将主要使用 Snowsight 网络界面来演示这一点，该界面也可以使用 VS Code 等客户端创建。
- en: 'The following sequential steps will convert your existing Streamlit app into
    a native application in Snowflake:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下顺序步骤将把您的现有 Streamlit 应用程序转换为 Snowflake 中的原生应用程序：
- en: Creating the application files
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建应用程序文件
- en: Creating an application package
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建应用程序包
- en: Uploading application files to the named stage
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上传应用程序文件到命名阶段
- en: Installing the application
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装应用程序
- en: Versioning the application
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 版本控制应用程序
- en: Testing the application
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试应用程序
- en: We will start with the first step, creating the application files.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从第一步开始，创建应用程序文件。
- en: Creating the application files
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建应用程序文件
- en: Creating the application files involves creating the setup script and the manifest
    file, which are vital components that the Native App Framework requires.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 创建应用程序文件包括创建设置脚本和清单文件，这些是原生应用程序框架必需的组件。
- en: Creating the setup script
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建设置脚本
- en: 'The setup script is an SQL file that executes automatically when consumers
    install the application in their accounts. It facilitates seamless configuration
    and setup processes and consists of the initialization instructions required to
    configure the application. To initiate the creation of the setup script, follow
    these steps:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 设置脚本是一个 SQL 文件，当消费者在其账户中安装应用程序时自动执行。它简化了配置和设置过程，并包含配置应用程序所需的初始化指令。要启动创建设置脚本，请按照以下步骤操作：
- en: We’ll start by creating a directory structure on your local filesystem. Create
    a folder named **native_apps** to serve as the root directory for your application’s
    external files.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先将在您的本地文件系统中创建一个目录结构。创建一个名为 **native_apps** 的文件夹，作为应用程序外部文件的根目录。
- en: Within this folder, create a subfolder called **scripts** to store the script
    files. This folder will contain all the script files necessary for the application.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件夹中，创建一个名为 **scripts** 的子文件夹来存储脚本文件。此文件夹将包含应用程序所需的所有脚本文件。
- en: 'Inside the **scripts** folder, create a new file called **setup.sql** and add
    the following statement:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **scripts** 文件夹中，创建一个名为 **setup.sql** 的新文件，并添加以下语句：
- en: '[PRE0]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will be seeing the detailed explanation of the previous code as we move through
    this section.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们进入本节，我们将看到之前代码的详细解释。
- en: Creating the Streamlit app file
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建 Streamlit 应用程序文件
- en: 'We will incorporate the application logic and the Streamlit app, leveraging
    its capabilities for data science and machine learning tasks. Utilizing the Streamlit
    app enhances user interaction and facilitates data visualization. We will start
    the process by creating the Streamlit app:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将结合应用程序逻辑和 Streamlit 应用程序，利用其在数据科学和机器学习任务中的功能。利用 Streamlit 应用程序增强了用户交互并促进了数据可视化。我们将通过创建
    Streamlit 应用程序开始这个过程：
- en: Create a subfolder named **streamlit** within the **native_apps** directory.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **native_apps** 目录中创建一个名为 **streamlit** 的子文件夹。
- en: Within the folder, create a file called **streamlit_bike_share_analysis.py**.
    The code for this is available within the repository inside the **chapter_7**
    folder.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件夹中，创建一个名为 **streamlit_bike_share_analysis.py** 的文件。该代码位于 **chapter_7** 文件夹内的存储库中。
- en: 'Copy and paste the following code into this file and save it:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Creating the README file
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The README file serves as a descriptive guide outlining your application’s
    functionality. It is readily accessible when viewing your application within Snowsight.
    To generate the README file for your application, follow these steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the **native_apps** directory and create a file called **readme.md**.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Populate the **readme.md** file with the following content detailing the purpose
    and features of your application:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now we can create the manifest file in the next section.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Creating the manifest file
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The manifest file, which uses YAML syntax, contains essential configuration
    details about the application. It is a foundational document outlining crucial
    specifications for proper functionality, and every application developed within
    the Native App Framework necessitates a corresponding manifest file.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate the manifest file, proceed as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Within the **native_apps** folder, create a new file named **manifest.yml**.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Populate the **manifest.yml** file with the following content:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `setup_script` property specifies the location of the setup script relative
    to the manifest file’s location. Ensure that the path and filename specified correspond
    precisely to the setup script created earlier.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: The manifest file is crucial for your project. It must be named **manifest.yml**
    and placed at the root level. All file paths, including the setup scripts, are
    relative to this file’s location. Fundamental properties such as **manifest_version**,
    **artifacts**, and **setup_script** are mandatory to ensure proper functioning.
    You can optionally include the **readme** property to provide additional documentation.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will create an application package for the native apps.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Creating an application package
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, you will create an application package, a container for the
    application’s resources. The application package extends Snowflake’s database
    to encompass additional application-related information, serving as a consolidated
    container housing shared data content and applications. To create an application
    package, your role needs to have the **Create Application Package** privilege.
    Execute the following command to grant the privilege:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once executed, you should see the following output:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – Role creation](img/B19923_07_9.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: Figure 7.9 – Role creation
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the following command to create the `SNOWFLAKE_NATIVE_APPS_PACKAGE`
    application package:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You will receive the following output that confirms the package has been created:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – Package creation](img/B19923_07_10.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
- en: Figure 7.10 – Package creation
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'The application package will be created, and the current context will be switched
    to `SNOWFLAKE_NATIVE_APPS_PACKAGE`. We can confirm the list of packages by running
    the following command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will display the following output:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – Showing the packages](img/B19923_07_11.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: Figure 7.11 – Showing the packages
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the application packages are created, the next step is to make the
    named stage for uploading the application files. Switch to the context of the
    application package by running the following command:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will display the following output:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12 – Using snowflake_native_apps_package](img/B19923_07_12.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
- en: Figure 7.12 – Using snowflake_native_apps_package
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need a schema to host the stage. Create a schema by running the following
    command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Once the schema is created, you’ll see the following message:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13 – Creating a new schema](img/B19923_07_13.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
- en: Figure 7.13 – Creating a new schema
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create the stage in this schema. Create a stage by running
    the following code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With this step, you’ve established a named stage within the application package,
    providing a designated space to upload the files essential for building your application.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Note on setup.sql
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: The following set of SQL commands are part of **setup.sql** and are packaged
    inside the native apps folder in **chapter_7**. This file will be uploaded to
    the stage area and will be utilized when we create a Native Apps application,
    so the code need not be executed in the Snowflake worksheet.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see what the `set.sql` file encompasses to create a Native Apps application.
    We will also be creating a role that is required for the application. To create
    an application role, run the following command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code initializes an application role named `app_public`. It then creates
    or updates a versioned schema named `code_schema`. Finally, it grants permission
    for the `app_public` application role to use the `code_schema` schema. This setup
    is commonly used for managing access control and schema organization in database
    applications.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following code to incorporate the Streamlit app:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code creates a Streamlit app named `bike_share_streamlit` within the `code_schema`
    schema, pulling its content from the `/streamlit` directory and its main file
    from `/streamlit_bike_share_analysis.py`. It then grants usage permission for
    this Streamlit app to the `app_public` application role, enabling access for authorized
    users within the application’s scope. This facilitates integrating a Streamlit-based
    bike share analysis tool into the database setup, with controlled access managed
    by the application role.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Uploading application files to the named stage
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The application files need to be uploaded to the named stage. They can be uploaded
    via Snowsight or through Snowpark Python code, as described in [*Chapter 2*](B19923_02.xhtml#_idTextAnchor028),
    Establishing a Foundation with Snowpark. For readers using the SnowSQL client
    to upload the files to the stage, perform the following steps:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the **native_apps** folder on your local machine.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following SnowSQL commands to upload all folders and files:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Run the following command in the worksheet to verify whether the file upload
    was successful:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After running the command, the uploaded files are displayed in the output:'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行命令后，上传的文件将在输出中显示：
- en: '![Figure 7.14 – Checking the application files via SnowSQL](img/B19923_07_14.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图7.14 – 通过SnowSQL检查应用程序文件](img/B19923_07_14.jpg)'
- en: Figure 7.14 – Checking the application files via SnowSQL
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14 – 通过SnowSQL检查应用程序文件
- en: 'We can also check the application files in Snowsight:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在Snowsight中检查应用程序文件：
- en: '![Figure 7.15 – Checking the application files via Snowsight](img/B19923_07_15.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图7.15 – 通过Snowsight检查应用程序文件](img/B19923_07_15.jpg)'
- en: Figure 7.15 – Checking the application files via Snowsight
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.15 – 通过Snowsight检查应用程序文件
- en: Now that we have uploaded the files to the stage, we will install the application
    package to Snowflake.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将文件上传到阶段，我们将安装应用程序包到Snowflake。
- en: Installing the application
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装应用程序
- en: 'Execute the following command to install the application:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令来安装应用程序：
- en: '[PRE15]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This automatically creates a new and current version of the application inside
    Snowflake. The native apps also provide the ability to version the application
    and update the version, which we will cover in the following section.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在Snowflake内部自动创建一个新的当前版本的应用程序。原生应用程序还提供了对应用程序进行版本控制和更新版本的能力，我们将在下一节中介绍。
- en: '![Figure 7.16 – Application installed](img/B19923_07_16.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图7.16 – 应用程序已安装](img/B19923_07_16.jpg)'
- en: Figure 7.16 – Application installed
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.16 – 应用程序已安装
- en: Now that the application is installed, let’s update the version of the application.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序已安装，让我们更新应用程序的版本。
- en: Versioning the application
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用程序版本控制
- en: 'In this section, we will update the application’s version and install it on
    Snowflake. We will utilize the `ALTER APPLICATION PACKAGE` command to update the
    previously created application. To update a new version, follow these steps:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更新应用程序的版本并将其安装到Snowflake。我们将使用`ALTER APPLICATION PACKAGE`命令来更新先前创建的应用程序。要更新新版本，请按照以下步骤操作：
- en: 'Run the following command to append a version to **SNOWFLAKE_NATIVE_APPS_PACKAGE**:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令将版本追加到**SNOWFLAKE_NATIVE_APPS_PACKAGE**：
- en: '[PRE16]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This will display the following output:'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将显示以下输出：
- en: '![Figure 7.17 – Modifying the application version](img/B19923_07_17.jpg)'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图7.17 – 修改应用程序版本](img/B19923_07_17.jpg)'
- en: Figure 7.17 – Modifying the application version
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.17 – 修改应用程序版本
- en: This command modifies the application package by incorporating a version derived
    from the application files uploaded to the named stage in an earlier section.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令通过结合从先前部分上传到指定阶段的文件中派生的版本来修改应用程序包。
- en: 'Next, confirm the successful update of the version by executing the following
    command:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过执行以下命令确认版本更新的成功：
- en: '[PRE17]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This will display the updated version as the output:'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将显示更新后的版本作为输出：
- en: '![Figure 7.18 – The updated version of the application](img/B19923_07_18.jpg)'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图7.18 – 应用程序的更新版本](img/B19923_07_18.jpg)'
- en: Figure 7.18 – The updated version of the application
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.18 – 应用程序的更新版本
- en: This command provides additional insights into the version, including creation
    timestamp and review status.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令提供了关于版本的额外见解，包括创建时间戳和审查状态。
- en: 'Before you install the new version, drop the existing application by running
    the following command:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您安装新版本之前，通过运行以下命令删除现有应用程序：
- en: '[PRE18]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You should see the following confirmation message:'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您应该看到以下确认消息：
- en: '![Figure 7.19 – Application deleted](img/B19923_07_19.jpg)'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图7.19 – 应用程序已删除](img/B19923_07_19.jpg)'
- en: Figure 7.19 – Application deleted
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.19 – 应用程序已删除
- en: Now that the existing application has been dropped, we can install the new application.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在现有应用程序已被删除，我们可以安装新的应用程序。
- en: 'Finally, to install the new version of the application, run the following code:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，要安装应用程序的新版本，请运行以下代码：
- en: '[PRE19]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This creates a new application based on the specified version, ensuring your
    application incorporates all the latest enhancements and features.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将基于指定的版本创建一个新的应用程序，确保您的应用程序包含所有最新的增强功能和特性。
- en: Note
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The value provided for **VERSION** serves as a label rather than a numerical
    or string value. It’s important to note that the patch number is automatically
    set to **0** when adding a new version. Subsequent patches added to the version
    will be automatically incremented. However, when introducing a new version, such
    as **V1_1**, the patch number for that specific version is reset to **0**.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: We have successfully deployed the new application version. In the next section,
    we will run the application to test it within the Snowflake environment.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Testing the application
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we will run our native application in Snowpark to perform
    the testing. While previous sections primarily utilized SQL statements for testing
    and information retrieval, Snowsight offers an alternative interface for interacting
    with and inspecting your application. Moreover, you can examine the Streamlit
    application you have deployed. To access and explore your application in Snowsight,
    follow these steps:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'In Snowsight, switch to the **ACCOUNTADMIN** role that grants you the necessary
    privileges to effectively view and manage applications within Snowsight:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.20 – Switching to the ACCOUNTADMIN role](img/B19923_07_20.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
- en: Figure 7.20 – Switching to the ACCOUNTADMIN role
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Within Snowsight’s intuitive navigation menu, locate and select the **Data
    Products** option, followed by **Apps**. This action directs you to a repository
    of installed applications within your Snowflake environment:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.21 – The native applications repository](img/B19923_07_21.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
- en: Figure 7.21 – The native applications repository
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'Locate your application within the **Installed Apps** list and select **BIKE_SHARE_NATIVE_APP**.
    This action offers a comprehensive view of your application, allowing you to delve
    into its various components and functionalities. The **Readme** tab provides access
    to the content you previously added to the README file, offering insights into
    the purpose and features of your application:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.22 – Native application README file](img/B19923_07_22.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
- en: Figure 7.22 – Native application README file
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'Locate and select **BIKE_SHARE_STREAMLIT** to access your deployed Streamlit
    application. Upon selection, the content of the **SNOWFLAKE_NATIVE_APPS_PACKAGE**
    database is showcased within a Streamlit DataFrame, facilitating dynamic interaction
    and visualization of your data:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.23 – The native application](img/B19923_07_23_V.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
- en: Figure 7.23 – The native application
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Note on step 4
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Before executing step 4, make sure all the commands under the *CREATE VIEW ON
    BSD TRAIN TABLE* section in **chapter_7.sql** are executed. This is necessary
    to access the **BSD_TRAIN** table residing in the **SNOWPARK_DEFINITIVE_GUIDE**
    database.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: The Streamlit application runs successfully within the Snowflake environment,
    highlighting data representation and interaction features.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at how to publish the native application.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Publishing the native application
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will examine publishing the application by crafting a private
    listing, utilizing the application package as its core data content. This process
    enables seamless sharing of your application with other Snowflake users, empowering
    them to install and use it within their accounts. We will start by setting the
    release directive.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过创建一个使用应用程序包作为核心数据内容的私密列表来检查应用程序的发布。此过程使您能够与其他Snowflake用户无缝共享应用程序，并使他们能够在自己的账户中安装和使用它。我们将首先设置发布指令。
- en: Setting the default release directive
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置默认发布指令
- en: 'Before proceeding with the listing creation, it’s essential to establish a
    default release directive specifying which version of your application is accessible
    to consumers. To designate version `v1_0` and patch `0` as the default release
    directive, execute the following command:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续创建列表之前，建立指定消费者可访问的应用程序版本的默认发布指令至关重要。要将版本`v1_0`和补丁`0`指定为默认发布指令，请执行以下命令：
- en: '[PRE20]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will display the following output:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示以下输出：
- en: '![Figure 7.24 – Checking the application version](img/B19923_07_24.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图7.24 – 检查应用程序版本](img/B19923_07_24.jpg)'
- en: Figure 7.24 – Checking the application version
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.24 – 检查应用程序版本
- en: The output confirms the successful establishment of the default release directive,
    ensuring clarity and consistency in version management.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 输出确认了默认发布指令的成功建立，确保了版本管理的清晰和一致性。
- en: In the next section, we will create the listing for the application.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将创建应用程序的列表。
- en: Creating a listing for your application
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为您的应用程序创建列表
- en: 'With the default release directive in place, we will create a listing for your
    application, incorporating the application package as its shared data content.
    Follow these steps to create a listing:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认发布指令就绪的情况下，我们将为您的应用程序创建一个列表，将应用程序包作为其共享数据内容。按照以下步骤创建列表：
- en: 'Open **Provider Studio** by navigating to **Data Products** | **Provider Studio**
    to access the listing creation interface:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到**数据产品** | **提供者工作室**来打开**提供者工作室**，以访问列表创建界面：
- en: '![Figure 7.25 – Provider Studio](img/B19923_07_25.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![图7.25 – 提供者工作室](img/B19923_07_25.jpg)'
- en: Figure 7.25 – Provider Studio
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.25 – 提供者工作室
- en: 'Next, initiate the listing creation by selecting **+ Listing** to open the
    **Create Listing** window, prompting you to specify the listing’s name and other
    essential details:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过选择**+ 列表**来启动列表创建，打开**创建列表**窗口，提示您指定列表的名称和其他必要细节：
- en: '![Figure 7.26 – The Create Listing dialog box](img/B19923_07_26.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图7.26 – 创建列表对话框](img/B19923_07_26.jpg)'
- en: Figure 7.26 – The Create Listing dialog box
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.26 – 创建列表对话框
- en: 'Enter a descriptive name for your listing and choose the **Only Specified Consumers**
    visibility option to ensure private sharing with specific accounts only. Select
    the application package associated with the listing, effectively linking it as
    the core data content. Provide a comprehensive description of your listing to
    inform potential users about its functionality and purpose:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的列表输入一个描述性的名称，并选择**仅指定消费者**可见性选项，以确保仅与特定账户进行私密共享。选择与列表关联的应用程序包，有效地将其链接为核心数据内容。提供您列表的全面描述，以便让潜在用户了解其功能和目的：
- en: '![Figure 7.27 – Creating a listing description](img/B19923_07_27.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图7.27 – 创建列表描述](img/B19923_07_27.jpg)'
- en: Figure 7.27 – Creating a listing description
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.27 – 创建列表描述
- en: 'Add the consumer account by including the account identifier for the account
    you’re utilizing to test the consumer experience of installing the application
    from the listing:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过包含用于测试从列表安装应用程序的消费者体验的账户标识符来添加消费者账户：
- en: '![Figure 7.28 – Adding the Consumer account](img/B19923_07_28.0.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图7.28 – 添加消费者账户](img/B19923_07_28.0.jpg)'
- en: Figure 7.28 – Adding the Consumer account
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.28 – 添加消费者账户
- en: Now you have successfully curated a private listing containing your application
    package as the shared data content, facilitating streamlined dissemination and
    installation of your application among designated users.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已成功创建了一个包含应用程序包作为共享数据内容的私密列表，便于在指定用户之间简化应用程序的传播和安装。
- en: The following section will discuss how to manage the native application.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将讨论如何管理原生应用程序。
- en: Managing the native application
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理原生应用程序
- en: Configuring and managing installed applications created with the Native App
    Framework involves various tasks, including viewing installed applications, accessing
    README information, granting application roles to account roles, and uninstalling
    applications. Let’s delve into each aspect in more detail.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 配置和管理使用原生应用程序框架创建的已安装应用程序涉及各种任务，包括查看已安装应用程序、访问README信息、将应用程序角色授予账户角色以及卸载应用程序。让我们更详细地探讨每个方面。
- en: Viewing installed applications
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看已安装的应用程序
- en: 'To access and view installed applications or Streamlit apps associated with
    your account, follow the following steps:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问和查看与您的账户关联的已安装应用程序或Streamlit应用程序，请按照以下步骤操作：
- en: 'From the navigation menu, select **Data Products** and **Apps** to access the
    list of installed applications:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导航菜单中，选择**数据产品**和**应用程序**以访问已安装应用程序的列表：
- en: '![Figure 7.29 – The list of installed applications](img/B19923_07_29.0.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图7.29 – 已安装应用程序列表](img/B19923_07_29.0.jpg)'
- en: Figure 7.29 – The list of installed applications
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.29 – 已安装应用程序列表
- en: 'Review the list of installed applications, then select the desired application.
    If you choose an application, the app interface will be displayed:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看已安装应用程序的列表，然后选择所需的应用程序。如果您选择一个应用程序，将显示应用程序界面：
- en: '![Figure 7.30 – The Streamlit application](img/B19923_07_30.0.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图7.30 – Streamlit应用程序](img/B19923_07_30.0.jpg)'
- en: Figure 7.30 – The Streamlit application
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.30 – Streamlit应用程序
- en: Next, we will cover how to view README for the application.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍如何查看应用程序的README。
- en: Viewing README for applications
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看应用程序的README
- en: 'The README provides a meaningful description and other details related to the
    application. Select the application from the list to access the README, then click
    on the **Readme** icon in the toolbar to view the README associated with the application:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: README提供了有意义的描述以及其他与该应用程序相关的详细信息。从列表中选择应用程序以访问README，然后在工具栏中点击**README**图标以查看与应用程序关联的README：
- en: '![Figure 7.31 – The Streamlit README information](img/B19923_07_31.0.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图7.31 – Streamlit README信息](img/B19923_07_31.0.jpg)'
- en: Figure 7.31 – The Streamlit README information
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.31 – Streamlit的README信息
- en: Next, we will cover managing access to the application by granting it to roles.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍通过授予角色来管理应用程序访问权限。
- en: Managing access to the application
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理应用程序访问
- en: 'To grant an application role access, select the application and select **Manage
    Access**. Click on **Add roles**, then select the account role to which you want
    to grant access to an application role. Click **Done** to confirm:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 要授予应用程序角色访问权限，请选择应用程序并选择**管理访问**。点击**添加角色**，然后选择您想授予应用程序角色访问权限的账户角色。点击**完成**以确认：
- en: '![Figure 7.32 – Application access](img/B19923_07_32.0.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图7.32 – 应用程序访问](img/B19923_07_32.0.jpg)'
- en: Figure 7.32 – Application access
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.32 – 应用程序访问
- en: 'Alternatively, you can grant application roles to account roles in the consumer
    account by running the following command:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以在消费者账户中通过运行以下命令来将应用程序角色授予账户角色：
- en: '[PRE21]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the final section, we will learn how to uninstall an installed application.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节，我们将学习如何卸载已安装的应用程序。
- en: Removing an installed application
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除已安装的应用程序
- en: 'The application can be removed using the Snowsight UI or the command line.
    To remove the application using Snowsight, click on the ellipsis (**...**) next
    to the application and choose **Uninstall**. Confirm the action by selecting **Uninstall**:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以使用Snowsight UI或命令行进行删除。要使用Snowsight删除应用程序，请点击应用程序旁边的省略号（**...**），然后选择**卸载**。通过选择**卸载**来确认操作：
- en: '![Figure 7.33 – Uninstalling an application](img/B19923_07_33.0.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图7.33 – 卸载应用程序](img/B19923_07_33.0.jpg)'
- en: Figure 7.33 – Uninstalling an application
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.33 – 卸载应用程序
- en: 'We can also uninstall it via command by executing the following in the worksheet:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过在工作表中执行以下命令来通过命令行卸载它：
- en: '[PRE22]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This concludes the management of native applications. Snowflake provides an
    easy way to do this. We will conclude this chapter with a summary.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了原生应用程序的管理。Snowflake提供了一种简单的方法来做这件事。我们将以总结结束本章。
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored Native Apps within the Snowflake ecosystem, uncovering
    their dynamic landscape and intrinsic value. The chapter commenced with an insightful
    introduction to Native Apps in Snowflake, where we delved into their foundational
    aspects, including robust security features and their significance in the broader
    native apps landscape. We explored Streamlit in Snowflake, a powerful tool for
    developing immersive data science and machine learning applications. We provided
    a comprehensive overview of Streamlit, highlighting its intuitive nature and seamless
    integration with Snowflake. We navigated through the process of deploying the
    first Streamlit application within Snowflake, empowering readers to harness this
    powerful combination for data-driven insights.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Snowflake生态系统中的原生应用，揭示了其动态的景观和内在价值。本章从对Snowflake中原生应用的深入介绍开始，我们深入探讨了其基础方面，包括强大的安全特性和在更广泛的原生应用景观中的重要性。我们探讨了Snowflake中的Streamlit，这是一个用于开发沉浸式数据科学和机器学习应用的强大工具。我们提供了Streamlit的全面概述，强调了其直观性和与Snowflake的无缝集成。我们指导读者通过在Snowflake中部署第一个Streamlit应用程序的过程，使他们能够利用这种强大的组合来获取数据驱动的洞察。
- en: Overall, this chapter provided a comprehensive overview of Native Apps in Snowflake,
    empowering you with the knowledge and tools needed to harness the full potential
    of this innovative technology within your data workflows. In the next chapter,
    we will discuss Snowpark Container Services.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，本章提供了Snowflake中原生应用的全面概述，为您提供了利用这种创新技术在数据工作流程中充分发挥其潜能所需的知识和工具。在下一章中，我们将讨论Snowpark容器服务。
