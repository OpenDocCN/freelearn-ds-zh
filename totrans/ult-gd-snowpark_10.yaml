- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developing a Native Application with Snowpark
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In today’s data-driven world, the demand for actionable insights is at an all-time
    high. However, traditional data analysis workflows often need help with slow processing
    times, siloed data, and complex development procedures. This is where Snowpark,
    with its unique features for native applications, comes to the rescue. By offering
    a powerful and innovative solution, Snowpark overcomes these challenges and opens
    up new revenue streams for organizations through distribution in the Snowflake
    Marketplace.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the Native App Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing the native application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing the native application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the native application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To set up the environment, please refer to the technical requirements in the
    previous chapter. The supporting materials are available at [https://github.com/PacktPublishing/The-Ultimate-Guide-To-Snowpark](https://github.com/PacktPublishing/The-Ultimate-Guide-To-Snowpark).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the Native Apps Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data analysis has evolved beyond static reports. In today’s business landscape,
    real-time insights, interactive visuals, and seamless integration with operational
    tools are in high demand. While traditional methods utilizing SQL or pre-built
    dashboards have their place, they need more agility and flexibility for modern
    data exploration. This is where native applications step in, offering exciting
    potential for immediate and actionable insights and sparking new possibilities
    for your data analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Snowflake native applications offer a unique advantage by allowing you to develop
    applications directly within the Data Cloud. These applications reside alongside
    your data, eliminating the need for data movement or external connectors. This
    removes the data transfer bottleneck between systems and significantly reduces
    network latency. Snowflake’s architecture, optimized for parallel processing and
    distributed storage, enables faster analysis of complex queries and large datasets
    than traditional models. Moreover, the native applications benefit from Snowflake’s
    secure foundation, which offers a multi-layered security architecture with features
    such as encryption, access controls, and audit trails without separate infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Snowflake’s native application Landscape
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Snowflake Native App Framework is a powerful tool for building data applications
    that utilize Snowflake’s core functionality. With this framework, you can extend
    the capabilities of Snowflake features by sharing data and relevant business logic
    with other Snowflake accounts. This can include using Streamlit apps, stored procedures,
    and functions written in the Snowpark API, JavaScript, and SQL. By leveraging
    the power of Snowflake’s capabilities, you can create sophisticated applications
    that are tailored to your unique needs.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to expanding Snowflake’s features, the Snowflake Native App Framework
    also allows you to share your applications with others. You can distribute your
    apps through free or paid listings in the Snowflake Marketplace, or privately
    distribute them to specific consumers. Furthermore, this framework allows you
    to create rich visualizations in your application using Streamlit. With the Snowflake
    Native App Framework, you have all the tools you need to create powerful, scalable,
    and flexible data applications that meet your organization’s needs.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, the Snowflake Native App Framework provides a comprehensive solution
    for building sophisticated data applications. Whether you need to expand Snowflake’s
    capabilities, share your applications with others, or create rich visualizations,
    this framework has you covered. With its powerful features and scalability, the
    Snowflake Native App Framework is an essential tool for any organization looking
    to build data applications that leverage Snowflake’s full potential.
  prefs: []
  type: TYPE_NORMAL
- en: Snowflake native applications consist of business logic that defines the core
    functionality of your application, encompassing tasks such as data transformations,
    calculations, and model predictions. The data model can be developed using Snowpark,
    where native applications leverage Snowflake’s powerful engine to interact with
    your data efficiently. Snowpark enables you to manipulate tables, query datasets,
    and extract meaningful insights. The user interface can be developed using Streamlit,
    and users can interact with the application natively within Snowflake.
  prefs: []
  type: TYPE_NORMAL
- en: Snowpark bridges the gap between traditional data analysis and modern application
    development by offering several key features that make it the ideal engine for
    building native applications. The applications seamlessly scale with your data
    volume, eliminating the need for manual infrastructure provisioning.
  prefs: []
  type: TYPE_NORMAL
- en: Before diving deep into developing a Snowpark application, let us understand
    the benefits that Native Apps provide.
  prefs: []
  type: TYPE_NORMAL
- en: Native App Framework components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Snowflake Native App Framework** components consist of the **provider**,
    the developer of the apps and the distributor of them for consumption, and the
    **consumer**, who accesses the data and application that the provider distributes.
    The high-level components of the Native App Framework are shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Native App Framework components](img/B19923_07_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Native App Framework components
  prefs: []
  type: TYPE_NORMAL
- en: The provider account is where the application is developed and packaged for
    distribution. The package includes the application code, Snowpark models, and
    associated data. It also consists of the various licenses and entitlements required
    for the application packages. The application is then packed and can be made available
    for distribution.
  prefs: []
  type: TYPE_NORMAL
- en: The provider can distribute the packages as a public marketplace listing that
    other organizations can consume or through a private listing, which can also be
    distributed as internal apps within the same organization. The consumer account
    deploys the application and can consume it with local data and access external
    systems. The app for this can be built using Streamlit in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Streamlit in Snowflake
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Streamlit is an open source Python library that makes creating and sharing custom
    web apps for machine learning and data science easy. It allows you to build and
    deploy powerful data applications quickly. Streamlit in Snowflake helps you move
    beyond pure data and enter the territory of application logic, making the application
    come alive and transforming insights into actions and reactions. Using Streamlit
    in Snowflake, you can build applications that process and use data in Snowflake
    without moving data or application code to an external system. The Native App
    can embed interactive data visualizations and user interfaces directly into the
    app, enabling dynamic charts and graphs that update as users interact with the
    data, and interactive data exploration tools for users to drill down and uncover
    more profound insights.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s discuss the various benefits provided by Native Apps.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of Native Apps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Native applications built within Snowflake offer unparalleled advantages for
    data analysis and decision-making. Native Apps provide multiple benefits; by offering
    streamlined development with Snowpark, they eliminate the steep learning curve
    typically associated with a development framework. Developers can seamlessly transition
    to data manipulation within Snowflake’s robust cloud environment, allowing rapid
    innovation. This empowers developers to focus on building impactful applications
    and extracting valuable insights without syntax roadblocks.
  prefs: []
  type: TYPE_NORMAL
- en: Snowflake’s integration with Streamlit enables developers to unleash the power
    of their existing Python expertise directly within Snowflake. Developers can build
    sophisticated applications for data exploration, machine learning, and interactive
    dashboards. This eliminates context switching and maximizes productivity within
    Snowflake’s secure and scalable environment. Snowflake’s *data residency* principle
    ensures that valuable information remains within the secure perimeter, significantly
    reducing the risk of data breaches.
  prefs: []
  type: TYPE_NORMAL
- en: Native applications seamlessly interface with existing Snowflake features and
    tools, such as Tasks and Streams, creating an integrated analytics environment.
    Leveraging Snowflake Tasks for automated execution and scheduling, along with
    Snowflake Streams or Snowpipe for real-time data ingestion and delivery, ensures
    continuous updates and enhances performance. Snowflake **user-defined functions**
    (**UDFs**) and stored procedures also improve flexibility and minimize data movement.
    We will explore Streamlit in Snowflake in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: As we delve deeper into this chapter, we will utilize the familiar Bike Sharing
    dataset and its associated Snowpark model we saw in the previous chapters and
    develop a Streamlit application using Snowsight.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the native application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The initial step involves developing a Streamlit application to illustrate the
    development of the Snowpark model. The application provides a user-friendly interface
    that streamlines the exploration and understanding of Snowpark’s underlying data
    and modeling techniques. Within Snowflake, the Streamlit application can be developed
    through a dedicated Python editor within Snowsight. This editor empowers users
    to write, edit, and execute code for their Streamlit applications effortlessly.
    Notably, it offers invaluable features such as auto-completion and comprehensive
    documentation, facilitating a smooth and intuitive development experience while
    leveraging the full potential of Streamlit and Snowpark functionalities. We will
    be using this editor to develop the Streamlit application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s delve into the detailed steps of creating a Streamlit application within
    the Snowflake environment:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The **CREATE STREAMLIT** privilege is required for the user at the schema level
    to develop the application and this application will utilize warehouse compute
    to run it, so choose the warehouse size appropriately. X-Small will be sufficient
    for the Streamlit and Native Apps developed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon successful login, select **Projects** from the left navigation bar within
    Snowsight and select **Streamlit** to initiate the Streamlit application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Streamlit Snowsight](img/B19923_07_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Streamlit Snowsight
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the Streamlit projects section, click the **+ Streamlit App** button
    to create a new Streamlit application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Streamlit app creation](img/B19923_07_3_V.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Streamlit app creation
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you click the button, the **Create Streamlit App** window will appear.
    Provide a name for your application, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Configuring the application details](img/B19923_07_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – Configuring the application details
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the appropriate warehouse from the drop-down menu where you wish to
    execute your application’s queries. Specify the database and schema where the
    application will be hosted from the respective drop-down menus:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Defining the execution environment](img/B19923_07_5_V.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – Defining the execution environment
  prefs: []
  type: TYPE_NORMAL
- en: 'Finalize the creation process by clicking the **Create** button, which initiates
    the setup of your Streamlit application. Upon successful creation, Streamlit will
    be launched in your Snowflake editor, presenting an example of the Streamlit application
    in the **Viewer** mode. This mode offers a preview of how the application will
    appear to end users, facilitating visualization and assessment of its user interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.6 – The Streamlit Snowflake editor](img/B19923_07_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – The Streamlit Snowflake editor
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discover and familiarize ourselves with the Streamlit
    editor.
  prefs: []
  type: TYPE_NORMAL
- en: The Streamlit editor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Streamlit editor in Snowflake helps develop the Streamlit application within
    Snowflake. The editor is built into the Snowsight interface, making it easier
    to create without needing an external environment. The Streamlit in Snowflake
    interface is structured into three primary panes.
  prefs: []
  type: TYPE_NORMAL
- en: The object browser provides visibility into the databases, schemas, and views
    accessible under your permissions, aiding in data exploration and access. The
    Streamlit editor houses a dedicated Python editor tailored to craft your Streamlit
    application code, facilitating seamless development and customization. The Streamlit
    preview displays the running Streamlit application in real time, allowing you
    to observe its behavior and appearance as you make modifications.
  prefs: []
  type: TYPE_NORMAL
- en: By default, only the Streamlit editor and preview panes are visible. However,
    you can adjust the interface layout according to your preferences. Use the **Show**/**Hide**
    buttons in the lower-left corner of the Streamlit in Snowflake editor to toggle
    the visibility of different panes according to your workflow requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are familiar with the interface, let’s create our first Streamlit
    application in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Streamlit application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will build an application using the Streamlit code from
    the `chapter_7` folder of the GitHub repository ([https://github.com/PacktPublishing/The-Ultimate-Guide-To-Snowpark/tree/main/chapter_7](https://github.com/PacktPublishing/The-Ultimate-Guide-To-Snowpark/tree/main/chapter_7)).
    The SnowparkML code has been extensively covered in previous chapters and is available
    in the repository. Copy and paste the code in the `streamlit_bike_share_analysis.py`
    file from the repository into the Streamlit editor. The code requires the `BSD_TRAIN`
    table created from the *Bike Sharing* dataset that we have used before. The `chapter_7_data_load.ipynb`
    file can be run to create the required table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, execute the Streamlit application by selecting the **Run** option to refresh,
    and the result will be updated within the Streamlit preview pane:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – The Streamlit App preview](img/B19923_07_7_V.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 – The Streamlit App preview
  prefs: []
  type: TYPE_NORMAL
- en: 'The code requires several packages to be installed in your Streamlit environment.
    Click on the **Packages** button in the code editor and select the following packages:'
  prefs: []
  type: TYPE_NORMAL
- en: Matplotlib
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seaborn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SciPy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Snowflake-ml-python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You have successfully run your first Streamlit app inside Snowflake. You can
    select the app to execute it within the Snowsight context:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – The Streamlit app](img/B19923_07_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.8 – The Streamlit app
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Snowsight offers a convenient platform for crafting single-page Streamlit applications.
    However, deploying multi-page Streamlit apps requires a slightly different approach,
    necessitating the utilization of SQL commands. Once the deployment process is
    complete, you can seamlessly navigate and interact with the multi-page application
    directly within Snowsight’s interface.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will develop and push the Streamlit application
    using the Native App Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Developing with the Native App Framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that our Streamlit application is operational, let’s explore the process
    of transforming it into a Native App within the Snowflake ecosystem. In this section,
    we’ll give a detailed walkthrough on leveraging the Native App Framework to develop
    applications to share data and associated business logic with other Snowflake
    accounts. We will primarily demonstrate this using the Snowsight web interface,
    which can also be created using a client such as VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following sequential steps will convert your existing Streamlit app into
    a native application in Snowflake:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the application files
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating an application package
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uploading application files to the named stage
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installing the application
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Versioning the application
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Testing the application
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will start with the first step, creating the application files.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the application files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating the application files involves creating the setup script and the manifest
    file, which are vital components that the Native App Framework requires.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the setup script
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The setup script is an SQL file that executes automatically when consumers
    install the application in their accounts. It facilitates seamless configuration
    and setup processes and consists of the initialization instructions required to
    configure the application. To initiate the creation of the setup script, follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by creating a directory structure on your local filesystem. Create
    a folder named **native_apps** to serve as the root directory for your application’s
    external files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within this folder, create a subfolder called **scripts** to store the script
    files. This folder will contain all the script files necessary for the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the **scripts** folder, create a new file called **setup.sql** and add
    the following statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will be seeing the detailed explanation of the previous code as we move through
    this section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Streamlit app file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We will incorporate the application logic and the Streamlit app, leveraging
    its capabilities for data science and machine learning tasks. Utilizing the Streamlit
    app enhances user interaction and facilitates data visualization. We will start
    the process by creating the Streamlit app:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a subfolder named **streamlit** within the **native_apps** directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the folder, create a file called **streamlit_bike_share_analysis.py**.
    The code for this is available within the repository inside the **chapter_7**
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Copy and paste the following code into this file and save it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Creating the README file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The README file serves as a descriptive guide outlining your application’s
    functionality. It is readily accessible when viewing your application within Snowsight.
    To generate the README file for your application, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the **native_apps** directory and create a file called **readme.md**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Populate the **readme.md** file with the following content detailing the purpose
    and features of your application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we can create the manifest file in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the manifest file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The manifest file, which uses YAML syntax, contains essential configuration
    details about the application. It is a foundational document outlining crucial
    specifications for proper functionality, and every application developed within
    the Native App Framework necessitates a corresponding manifest file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate the manifest file, proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Within the **native_apps** folder, create a new file named **manifest.yml**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Populate the **manifest.yml** file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `setup_script` property specifies the location of the setup script relative
    to the manifest file’s location. Ensure that the path and filename specified correspond
    precisely to the setup script created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The manifest file is crucial for your project. It must be named **manifest.yml**
    and placed at the root level. All file paths, including the setup scripts, are
    relative to this file’s location. Fundamental properties such as **manifest_version**,
    **artifacts**, and **setup_script** are mandatory to ensure proper functioning.
    You can optionally include the **readme** property to provide additional documentation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will create an application package for the native apps.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an application package
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, you will create an application package, a container for the
    application’s resources. The application package extends Snowflake’s database
    to encompass additional application-related information, serving as a consolidated
    container housing shared data content and applications. To create an application
    package, your role needs to have the **Create Application Package** privilege.
    Execute the following command to grant the privilege:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once executed, you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – Role creation](img/B19923_07_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.9 – Role creation
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the following command to create the `SNOWFLAKE_NATIVE_APPS_PACKAGE`
    application package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You will receive the following output that confirms the package has been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – Package creation](img/B19923_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.10 – Package creation
  prefs: []
  type: TYPE_NORMAL
- en: 'The application package will be created, and the current context will be switched
    to `SNOWFLAKE_NATIVE_APPS_PACKAGE`. We can confirm the list of packages by running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This will display the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – Showing the packages](img/B19923_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.11 – Showing the packages
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the application packages are created, the next step is to make the
    named stage for uploading the application files. Switch to the context of the
    application package by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This will display the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12 – Using snowflake_native_apps_package](img/B19923_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.12 – Using snowflake_native_apps_package
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need a schema to host the stage. Create a schema by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the schema is created, you’ll see the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13 – Creating a new schema](img/B19923_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.13 – Creating a new schema
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create the stage in this schema. Create a stage by running
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: With this step, you’ve established a named stage within the application package,
    providing a designated space to upload the files essential for building your application.
  prefs: []
  type: TYPE_NORMAL
- en: Note on setup.sql
  prefs: []
  type: TYPE_NORMAL
- en: The following set of SQL commands are part of **setup.sql** and are packaged
    inside the native apps folder in **chapter_7**. This file will be uploaded to
    the stage area and will be utilized when we create a Native Apps application,
    so the code need not be executed in the Snowflake worksheet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see what the `set.sql` file encompasses to create a Native Apps application.
    We will also be creating a role that is required for the application. To create
    an application role, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This code initializes an application role named `app_public`. It then creates
    or updates a versioned schema named `code_schema`. Finally, it grants permission
    for the `app_public` application role to use the `code_schema` schema. This setup
    is commonly used for managing access control and schema organization in database
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following code to incorporate the Streamlit app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This code creates a Streamlit app named `bike_share_streamlit` within the `code_schema`
    schema, pulling its content from the `/streamlit` directory and its main file
    from `/streamlit_bike_share_analysis.py`. It then grants usage permission for
    this Streamlit app to the `app_public` application role, enabling access for authorized
    users within the application’s scope. This facilitates integrating a Streamlit-based
    bike share analysis tool into the database setup, with controlled access managed
    by the application role.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading application files to the named stage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The application files need to be uploaded to the named stage. They can be uploaded
    via Snowsight or through Snowpark Python code, as described in [*Chapter 2*](B19923_02.xhtml#_idTextAnchor028),
    Establishing a Foundation with Snowpark. For readers using the SnowSQL client
    to upload the files to the stage, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the **native_apps** folder on your local machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following SnowSQL commands to upload all folders and files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following command in the worksheet to verify whether the file upload
    was successful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After running the command, the uploaded files are displayed in the output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.14 – Checking the application files via SnowSQL](img/B19923_07_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.14 – Checking the application files via SnowSQL
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also check the application files in Snowsight:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.15 – Checking the application files via Snowsight](img/B19923_07_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.15 – Checking the application files via Snowsight
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have uploaded the files to the stage, we will install the application
    package to Snowflake.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Execute the following command to install the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This automatically creates a new and current version of the application inside
    Snowflake. The native apps also provide the ability to version the application
    and update the version, which we will cover in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.16 – Application installed](img/B19923_07_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.16 – Application installed
  prefs: []
  type: TYPE_NORMAL
- en: Now that the application is installed, let’s update the version of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning the application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we will update the application’s version and install it on
    Snowflake. We will utilize the `ALTER APPLICATION PACKAGE` command to update the
    previously created application. To update a new version, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to append a version to **SNOWFLAKE_NATIVE_APPS_PACKAGE**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will display the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.17 – Modifying the application version](img/B19923_07_17.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 7.17 – Modifying the application version
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This command modifies the application package by incorporating a version derived
    from the application files uploaded to the named stage in an earlier section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, confirm the successful update of the version by executing the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will display the updated version as the output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.18 – The updated version of the application](img/B19923_07_18.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 7.18 – The updated version of the application
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This command provides additional insights into the version, including creation
    timestamp and review status.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Before you install the new version, drop the existing application by running
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following confirmation message:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.19 – Application deleted](img/B19923_07_19.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 7.19 – Application deleted
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that the existing application has been dropped, we can install the new application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, to install the new version of the application, run the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This creates a new application based on the specified version, ensuring your
    application incorporates all the latest enhancements and features.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The value provided for **VERSION** serves as a label rather than a numerical
    or string value. It’s important to note that the patch number is automatically
    set to **0** when adding a new version. Subsequent patches added to the version
    will be automatically incremented. However, when introducing a new version, such
    as **V1_1**, the patch number for that specific version is reset to **0**.
  prefs: []
  type: TYPE_NORMAL
- en: We have successfully deployed the new application version. In the next section,
    we will run the application to test it within the Snowflake environment.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we will run our native application in Snowpark to perform
    the testing. While previous sections primarily utilized SQL statements for testing
    and information retrieval, Snowsight offers an alternative interface for interacting
    with and inspecting your application. Moreover, you can examine the Streamlit
    application you have deployed. To access and explore your application in Snowsight,
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Snowsight, switch to the **ACCOUNTADMIN** role that grants you the necessary
    privileges to effectively view and manage applications within Snowsight:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.20 – Switching to the ACCOUNTADMIN role](img/B19923_07_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.20 – Switching to the ACCOUNTADMIN role
  prefs: []
  type: TYPE_NORMAL
- en: 'Within Snowsight’s intuitive navigation menu, locate and select the **Data
    Products** option, followed by **Apps**. This action directs you to a repository
    of installed applications within your Snowflake environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.21 – The native applications repository](img/B19923_07_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.21 – The native applications repository
  prefs: []
  type: TYPE_NORMAL
- en: 'Locate your application within the **Installed Apps** list and select **BIKE_SHARE_NATIVE_APP**.
    This action offers a comprehensive view of your application, allowing you to delve
    into its various components and functionalities. The **Readme** tab provides access
    to the content you previously added to the README file, offering insights into
    the purpose and features of your application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.22 – Native application README file](img/B19923_07_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.22 – Native application README file
  prefs: []
  type: TYPE_NORMAL
- en: 'Locate and select **BIKE_SHARE_STREAMLIT** to access your deployed Streamlit
    application. Upon selection, the content of the **SNOWFLAKE_NATIVE_APPS_PACKAGE**
    database is showcased within a Streamlit DataFrame, facilitating dynamic interaction
    and visualization of your data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.23 – The native application](img/B19923_07_23_V.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.23 – The native application
  prefs: []
  type: TYPE_NORMAL
- en: Note on step 4
  prefs: []
  type: TYPE_NORMAL
- en: Before executing step 4, make sure all the commands under the *CREATE VIEW ON
    BSD TRAIN TABLE* section in **chapter_7.sql** are executed. This is necessary
    to access the **BSD_TRAIN** table residing in the **SNOWPARK_DEFINITIVE_GUIDE**
    database.
  prefs: []
  type: TYPE_NORMAL
- en: The Streamlit application runs successfully within the Snowflake environment,
    highlighting data representation and interaction features.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at how to publish the native application.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing the native application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will examine publishing the application by crafting a private
    listing, utilizing the application package as its core data content. This process
    enables seamless sharing of your application with other Snowflake users, empowering
    them to install and use it within their accounts. We will start by setting the
    release directive.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the default release directive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before proceeding with the listing creation, it’s essential to establish a
    default release directive specifying which version of your application is accessible
    to consumers. To designate version `v1_0` and patch `0` as the default release
    directive, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This will display the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.24 – Checking the application version](img/B19923_07_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.24 – Checking the application version
  prefs: []
  type: TYPE_NORMAL
- en: The output confirms the successful establishment of the default release directive,
    ensuring clarity and consistency in version management.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will create the listing for the application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a listing for your application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the default release directive in place, we will create a listing for your
    application, incorporating the application package as its shared data content.
    Follow these steps to create a listing:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open **Provider Studio** by navigating to **Data Products** | **Provider Studio**
    to access the listing creation interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.25 – Provider Studio](img/B19923_07_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.25 – Provider Studio
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, initiate the listing creation by selecting **+ Listing** to open the
    **Create Listing** window, prompting you to specify the listing’s name and other
    essential details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.26 – The Create Listing dialog box](img/B19923_07_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.26 – The Create Listing dialog box
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter a descriptive name for your listing and choose the **Only Specified Consumers**
    visibility option to ensure private sharing with specific accounts only. Select
    the application package associated with the listing, effectively linking it as
    the core data content. Provide a comprehensive description of your listing to
    inform potential users about its functionality and purpose:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.27 – Creating a listing description](img/B19923_07_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.27 – Creating a listing description
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the consumer account by including the account identifier for the account
    you’re utilizing to test the consumer experience of installing the application
    from the listing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.28 – Adding the Consumer account](img/B19923_07_28.0.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.28 – Adding the Consumer account
  prefs: []
  type: TYPE_NORMAL
- en: Now you have successfully curated a private listing containing your application
    package as the shared data content, facilitating streamlined dissemination and
    installation of your application among designated users.
  prefs: []
  type: TYPE_NORMAL
- en: The following section will discuss how to manage the native application.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the native application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configuring and managing installed applications created with the Native App
    Framework involves various tasks, including viewing installed applications, accessing
    README information, granting application roles to account roles, and uninstalling
    applications. Let’s delve into each aspect in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing installed applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To access and view installed applications or Streamlit apps associated with
    your account, follow the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the navigation menu, select **Data Products** and **Apps** to access the
    list of installed applications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.29 – The list of installed applications](img/B19923_07_29.0.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.29 – The list of installed applications
  prefs: []
  type: TYPE_NORMAL
- en: 'Review the list of installed applications, then select the desired application.
    If you choose an application, the app interface will be displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.30 – The Streamlit application](img/B19923_07_30.0.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.30 – The Streamlit application
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will cover how to view README for the application.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing README for applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The README provides a meaningful description and other details related to the
    application. Select the application from the list to access the README, then click
    on the **Readme** icon in the toolbar to view the README associated with the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.31 – The Streamlit README information](img/B19923_07_31.0.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.31 – The Streamlit README information
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will cover managing access to the application by granting it to roles.
  prefs: []
  type: TYPE_NORMAL
- en: Managing access to the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To grant an application role access, select the application and select **Manage
    Access**. Click on **Add roles**, then select the account role to which you want
    to grant access to an application role. Click **Done** to confirm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.32 – Application access](img/B19923_07_32.0.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.32 – Application access
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can grant application roles to account roles in the consumer
    account by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the final section, we will learn how to uninstall an installed application.
  prefs: []
  type: TYPE_NORMAL
- en: Removing an installed application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The application can be removed using the Snowsight UI or the command line.
    To remove the application using Snowsight, click on the ellipsis (**...**) next
    to the application and choose **Uninstall**. Confirm the action by selecting **Uninstall**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.33 – Uninstalling an application](img/B19923_07_33.0.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.33 – Uninstalling an application
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also uninstall it via command by executing the following in the worksheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This concludes the management of native applications. Snowflake provides an
    easy way to do this. We will conclude this chapter with a summary.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored Native Apps within the Snowflake ecosystem, uncovering
    their dynamic landscape and intrinsic value. The chapter commenced with an insightful
    introduction to Native Apps in Snowflake, where we delved into their foundational
    aspects, including robust security features and their significance in the broader
    native apps landscape. We explored Streamlit in Snowflake, a powerful tool for
    developing immersive data science and machine learning applications. We provided
    a comprehensive overview of Streamlit, highlighting its intuitive nature and seamless
    integration with Snowflake. We navigated through the process of deploying the
    first Streamlit application within Snowflake, empowering readers to harness this
    powerful combination for data-driven insights.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, this chapter provided a comprehensive overview of Native Apps in Snowflake,
    empowering you with the knowledge and tools needed to harness the full potential
    of this innovative technology within your data workflows. In the next chapter,
    we will discuss Snowpark Container Services.
  prefs: []
  type: TYPE_NORMAL
