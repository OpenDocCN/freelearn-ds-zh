- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: 'Time Series Analysis: Statistics, Plots, and Forecasting'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间序列分析：统计、图表和预测
- en: In the realm of mathematical analysis, particularly in the study of data and
    trends, time series charts play a pivotal role. A time series chart is a graphical
    representation that displays data points collected over a sequence of time intervals.
    This tool is indispensable in various fields, including economics, finance, environmental
    science, and social sciences, for analyzing patterns, trends, and fluctuations
    in data over time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学分析领域，尤其是在数据趋势研究方面，时间序列图表扮演着关键角色。时间序列图表是显示在一系列时间间隔内收集到的数据点的图形表示。这个工具在经济学、金融、环境科学和社会科学等众多领域都是不可或缺的，用于分析数据随时间变化的模式、趋势和波动。
- en: 'A typical time series chart comprises two essential components: the time axis
    and the data axis. The time axis represents the progression of time, which can
    be measured in various units, such as seconds, minutes, hours, days, months, or
    years. The data axis displays the values of the variable being studied, which
    can be anything from stock prices and temperature readings to population counts
    and sales figures.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的时间序列图表包含两个基本组件：时间轴和数据轴。时间轴表示时间的推移，可以以各种单位来衡量，如秒、分钟、小时、天、月或年。数据轴显示被研究变量的值，可以是股价、温度读数、人口计数或销售数据等。
- en: 'To construct a time series chart, you must do the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建时间序列图表，你必须执行以下操作：
- en: '**Data collection**: Gather data points at regular time intervals or time stamps.
    These intervals should be consistent to accurately capture temporal patterns.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据收集**：在固定的时间间隔或时间戳上收集数据点。这些间隔应该保持一致，以便准确捕捉时间模式。'
- en: '**Data representation**: Plot the collected data points on the graph, aligning
    each point with its corresponding time stamp on the time axis.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据表示**：在图表上绘制收集到的数据点，将每个点与其对应的时间戳对齐在时间轴上。'
- en: '**Axis scaling**: Choose appropriate scaling for both the time axis and the
    data axis. This ensures that the patterns are visible and accurately represented.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**坐标轴缩放**：选择时间轴和数据轴的适当缩放比例。这确保了模式可见且准确表示。'
- en: '**Connect data points**: Depending on the context, data points can be connected
    with lines, curves, or bars. Connecting points can reveal trends more effectively.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接数据点**：根据上下文，数据点可以用线、曲线或条形连接。连接点可以更有效地揭示趋势。'
- en: 'A time series chart’s primary function is to enable the analysis of trends,
    patterns, and anomalies in the data. Several insights can be gained from such
    analysis:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列图表的主要功能是使数据中的趋势、模式和异常分析成为可能。可以从这种分析中获得以下见解：
- en: '**Trend identification**: Time series charts help identify long-term trends,
    such as gradual increases or decreases in values over time. These trends can provide
    valuable information for decision-making.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**趋势识别**：时间序列图表有助于识别长期趋势，如随时间逐渐增加或减少的值。这些趋势可以为决策提供宝贵信息。'
- en: '**Seasonal variations**: Seasonal patterns, such as spikes in sales during
    holiday seasons, can be identified by observing regular fluctuations in the data
    over specific periods.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**季节性变化**：通过观察特定时期内数据的规律性波动，可以识别出季节性模式，例如假日季节销售激增。'
- en: '**Cyclic patterns**: In addition to seasonal variations, cyclic patterns –
    repeating but irregular fluctuations – can be observed. These might be influenced
    by factors such as economic cycles or environmental changes.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**周期性模式**：除了季节性变化外，还可以观察到周期性模式——重复但非规律性的波动。这些可能受经济周期或环境变化等因素的影响。'
- en: '**Volatility and outliers**: Sudden spikes or dips in the data can indicate
    volatility or outliers, drawing attention to events or factors affecting the variable
    being measured.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**波动性和异常值**：数据中的突然上升或下降可能表明波动性或异常值，引起对影响被测变量的事件或因素的注意。'
- en: Time series charts also serve as a foundation for forecasting and predictive
    analysis. Mathematical models can be applied to historical data to make predictions
    about future trends and values. It is important to note that when I say make predictions,
    I do mean that we are making inferences about what could be likely to happen if
    all things remain the same. Techniques such as moving averages, exponential smoothing,
    and **autoregressive integrated moving average** (**ARIMA**) models are commonly
    used for this purpose.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列图也构成了预测分析和预测分析的基础。可以将数学模型应用于历史数据，以预测未来的趋势和值。需要注意的是，当我说做出预测时，我的确是指我们在推断如果所有事情都保持不变，可能会发生什么。
- en: In the realm of mathematical analysis, a time series chart is a powerful tool
    that aids in understanding the dynamics of data over time. By visually representing
    data points and trends, it allows researchers, analysts, and decision-makers to
    extract valuable insights, identify patterns, and make informed predictions. Through
    the lens of mathematical analysis, time series charts provide a structured approach
    to comprehending temporal data, thereby contributing significantly to fields that
    rely on data-driven decision-making.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学分析领域，时间序列图是一种强大的工具，有助于理解数据随时间变化的动态。通过直观地表示数据点和趋势，它使研究人员、分析师和决策者能够提取有价值的见解，识别模式，并做出明智的预测。通过数学分析的角度来看，时间序列图提供了一种理解时间数据的结构化方法，从而对依赖数据驱动决策的领域做出了重大贡献。
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Generating random time series objects in R
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在R中生成随机时间序列对象
- en: Time series plotting with R
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用R进行时间序列绘图
- en: Auto ARIMA modeling with `healthyR.ts`
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`healthyR.ts`进行自动ARIMA建模
- en: Creating a Brownian motion with `healthyR.ts`
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`healthyR.ts`创建布朗运动
- en: Time series plotting – basic plots and ACF/PACF plots
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间序列绘图 – 基本绘图和ACF/PACF图
- en: Time series statistics and statistical forecasting
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间序列统计和统计预测
- en: Time series forecasting with deep learning – LSTM
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于深度学习的时间序列预测 – LSTM
- en: Technical requirements
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: There are a few technical requirements for this chapter. Note that the code
    for this chapter can be found at [https://github.com/PacktPublishing/Extending-Excel-with-Python-and-R/tree/main/Chapter%2010](https://github.com/PacktPublishing/Extending-Excel-with-Python-and-R/tree/main/Chapter%2010).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本章有一些技术要求。请注意，本章的代码可以在[https://github.com/PacktPublishing/Extending-Excel-with-Python-and-R/tree/main/Chapter%2010](https://github.com/PacktPublishing/Extending-Excel-with-Python-and-R/tree/main/Chapter%2010)找到。
- en: 'Some of the packages that we will be using in this chapter are as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将使用的一些包如下：
- en: '`healthyR.ts`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`healthyR.ts`'
- en: '`forecast`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forecast`'
- en: '`timetk`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timetk`'
- en: '`Modeltime`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Modeltime`'
- en: '`prophet (``for Python)`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prophet (``for Python)`'
- en: '`keras`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keras`'
- en: '`tensorflow`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tensorflow`'
- en: We will start by creating time series objects in base R. The basic object class
    for a time series object in R is `ts` and objects can be coerced to that object
    by either using the `ts()` function directly or calling `as.ts()` on an object
    such as a vector.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在基础R中创建时间序列对象。R中时间序列对象的基本对象类是`ts`，可以通过直接使用`ts()`函数或在一个向量等对象上调用`as.ts()`来将对象强制转换为该对象。
- en: Generating random time series objects in R
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在R中生成随机时间序列对象
- en: 'We are going to generate some random time series objects in base R. Doing this
    is very simple as base R comes with some distribution functions already packed
    in. We will make use of the random normal distribution by making calls to the
    `rnorm()` function. This function has three parameters to provide arguments to:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在基础R中生成一些随机时间序列对象。这样做非常简单，因为基础R已经内置了一些分布函数。我们将通过调用`rnorm()`函数来使用随机正态分布。此函数有三个参数，用于提供以下参数：
- en: '`n`: The number of points to be generated'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n`: 要生成的点的数量'
- en: '`mean`: The mean of the distribution, with a default of 0'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mean`: 分布的均值，默认为0'
- en: '`sd`: The standard deviation of the distribution, with the default being 1'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sd`: 分布的标准差，默认值为1'
- en: 'Let’s go ahead and generate our first random vector. We will call it `x`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续生成我们的第一个随机向量。我们将称之为`x`：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding code, we did the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们做了以下操作：
- en: '`set.seed(123)`: This line is all about ensuring that the random numbers that
    are generated in your code are consistent each time you run it. By setting a seed
    value (in this case, `123`), you ensure that the random numbers that are generated
    by your code will be the same every time you run it. This is useful for reproducibility
    in your analysis.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set.seed(123)`: 这行代码的目的是确保每次运行代码时生成的随机数都是一致的。通过设置种子值（在这个例子中是`123`），你确保每次运行代码时生成的随机数将是相同的。这对于分析的重复性很有用。'
- en: '`n <- 25`: Here, you’re defining a variable called `n` and setting its value
    to `25`. This variable represents the number of data points you want to generate
    in your random time series.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n <- 25`: 在这里，你正在定义一个名为`n`的变量并将其值设置为`25`。这个变量代表你想要在随机时间序列中生成的数据点的数量。'
- en: '`x <- rnorm(n)`: This is where the actual data generation happens. You’re creating
    a new variable, `x`, and using the `rnorm()` function to generate random numbers.
    These numbers are drawn from a Gaussian (or normal) distribution, which is often
    called a bell curve. `n` specifies the number of random data points to generate,
    which in this case is 25.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x <- rnorm(n)`: 这实际上是数据生成的地方。你正在创建一个新的变量`x`，并使用`rnorm()`函数生成随机数。这些数字是从高斯（或正态）分布中抽取的，通常被称为钟形曲线。`n`指定了要生成的随机数据点的数量，在这个例子中是25。'
- en: '`head(x)`: Finally, you’re using the `head()` function to display the first
    few values of the `x` variable. This helps you quickly inspect what the generated
    data looks like. It’s a handy way to get a glimpse of your data without printing
    the entire dataset.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`head(x)`: 最后，你正在使用`head()`函数来显示`x`变量的前几个值。这有助于你快速检查生成的数据看起来像什么。这是一种方便的方法，可以在不打印整个数据集的情况下查看数据的一瞥。'
- en: To summarize, this code sets a random seed for reproducibility, specifies the
    number of data points you want (`25`), and generates these data points from a
    Gaussian distribution, storing them in the `x` variable. Then, it shows the first
    few values of `x` using the `head()` function. This code is often used in data
    analysis and statistics when you need random data to work with or simulate real-world
    scenarios.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，这段代码设置了一个随机种子以确保可重复性，指定了您想要的数据点数量（`25`），并从高斯分布中生成这些数据点，将它们存储在`x`变量中。然后，它使用`head()`函数显示了`x`的前几个值。这段代码在需要随机数据来处理或模拟现实世界场景的数据分析和统计学中经常被使用。
- en: 'Now, let’s convert this vector, `x`, into a time series object using the `ts()`
    function:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`ts()`函数将这个向量`x`转换为时间序列对象：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let’s check the class of the newly created object:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查新创建的对象的类：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We must do the same for its structure and attributes:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须对其结构和属性做同样的处理：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So, what happened exactly? Let’s go over it in a simple yet concise manner.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，到底发生了什么？让我们以简单而简洁的方式回顾一下。
- en: 'This R code does the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这段R代码执行以下操作：
- en: '`ts_obj <- ts(x)`: This creates a time series object (`ts_obj`) from a vector
    or data series, `x`. This step converts `x` into a time series format.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ts_obj <- ts(x)`: 这是从向量或数据序列`x`创建一个时间序列对象（`ts_obj`）。这一步将`x`转换为时间序列格式。'
- en: '`class(ts_obj)`: This checks and displays the class of `ts_obj`. This should
    return `ts`, indicating that `ts_obj` is indeed a time series.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class(ts_obj)`: 这将检查并显示`ts_obj`的类。这应该返回`ts`，表示`ts_obj`确实是一个时间序列。'
- en: '`str(ts_obj)`: This line displays the structure of `ts_obj`, providing information
    about the time series. In this case, it shows that the time series has 25 data
    points ranging from 1 to 25, along with the values themselves.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`str(ts_obj)`: 这行代码显示了`ts_obj`的结构，提供了关于时间序列的信息。在这种情况下，它显示时间序列有25个数据点，范围从1到25，以及相应的值。'
- en: '`attributes(ts_obj)`: This shows the attributes of the time series object.
    In this case, it displays the time span (`tsp`) with values of `1 25 1`, which
    means that the time series starts from period 1 and ends at period 25 with a frequency
    of 1.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attributes(ts_obj)`: 这显示了时间序列对象的属性。在这种情况下，它显示了时间跨度（`tsp`）的值为`1 25 1`，这意味着时间序列从周期1开始，到周期25结束，频率为1。'
- en: 'So, this code essentially takes a vector, `x`, converts it into a time series
    object, and then provides information about the class and structure of the resulting
    time series. Now, let’s visualize the time series by using the `plot` function.
    We can do this with `plot(ts_obj)`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这段代码本质上是将一个向量`x`转换为时间序列对象，然后提供关于结果时间序列的类和结构的信息。现在，让我们使用`plot`函数来可视化时间序列。我们可以通过`plot(ts_obj)`来实现这一点：
- en: '![Figure 10.1 – Plot of a time series object from rnorm(25)](img/B19142_10_1.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 来自rnorm(25)的时间序列对象的绘图](img/B19142_10_1.jpg)'
- en: Figure 10.1 – Plot of a time series object from rnorm(25)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered how to coerce a vector into a time series object, we
    can discuss how to change the start, end, and frequency parameters.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating the time series parameters
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we are going to use the previous vector we created from `rnorm()` and convert
    it into different time series objects with different starts, ends, and frequencies.
    This sort of thing is very simple to do in base R.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see some code manipulation first; then, we will go through and explain
    the examples:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here are the explanations for each of the preceding examples. The last one
    in the preceding code block shows the output of the last manipulation:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '`ts(x, start = 1980)`: This creates a time series with a start date in `1980`.
    The exact month and day are not specified, so the default is January 1, 1980.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ts(x, start = c(1980, 05))`: This sets the start date to May 1980 (year and
    month) explicitly.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ts(x, start = 1980, frequency = 12)`: This line creates a time series with
    a start date in `1980` and a monthly frequency, indicating that each data point
    represents one month.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ts(x, start = 1980, frequency = 12/3)`: This sets the start year to `1980`
    and specifies a frequency of 4, which means each data point is a quarter (three
    months) apart.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ts(x, end = 2023)`: This creates a time series with an end date in `2023`.
    The start date is not specified here, so it defaults to the beginning of the series.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ts(x, end = 2023, frequency = 12)`: This line indicates that the end date
    is `2023` with a monthly frequency, assuming each data point represents one month.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ts(x, end = 2023, frequency = 12/3)`: This sets the end year to `2023` and
    specifies a frequency of 4, meaning each data point is a quarter (three months)
    apart.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These variations allow you to control the temporal characteristics of your time
    series data, such as the start and end points and the frequency of observations.
    Now that we have generated some data, let’s plot it out.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Time series plotting
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will cover plotting time series objects, along with plotting
    some diagnostics such as decomposition. These plots include time series plots
    themselves, `readxl` package:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This produces the following chart:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Visualizing the AirPassengers time series dataset](img/B19142_10_2.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – Visualizing the AirPassengers time series dataset
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, it is easy to see that the data has a trend and a seasonal cycle
    component. This observation will lead us to our next visual. We will decompose
    the data into its parts and visualize the decomposition. The decomposition of
    the time series breaks the data down into the following parts:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: The observed data
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The trend of the data
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The seasonal cycle of the data
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The remaining “randomness” or “residual/remainder”
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s go ahead and see what it looks like. First, we have the code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here’s the plot:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Plot of a decomposed time series](img/B19142_10_3.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Plot of a decomposed time series
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 分解时间序列的图
- en: Now that we have visualized the decomposition, we can start analyzing the ACF
    and PACF plots.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经可视化了分解，我们可以开始分析ACF和PACF图。
- en: Creating ACF and PACF plots in R
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在R中创建ACF和PACF图
- en: In this section, we are going to cover ACF and PACF plots. An ACF plot is an
    autocorrelation function plot. An autocorrelation function is the relationship
    between a current observation in time against a previous observation in time.
    It tells you how correlated a current observation is compared to different lags
    of the same time series. So, if there is a strong seasonal demand for beer, you
    will see a strong correlation for them at the same seasonal period before it.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍ACF和PACF图。ACF图是自相关函数图。自相关函数是当前时间点的观察值与之前时间点的观察值之间的关系。它告诉你当前观察值与同一时间序列的不同滞后之间的相关性如何。因此，如果啤酒有强烈的季节性需求，你将在之前的季节性周期中看到与之相关的强烈相关性。
- en: 'First, let’s look at the output of the `acf()` function:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看`acf()`函数的输出：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here’s the plot for it:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的图：
- en: '![Figure 10.4 – ACF plot of the AirPassengers data](img/B19142_10_4.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – AirPassengers数据的ACF图](img/B19142_10_4.jpg)'
- en: Figure 10.4 – ACF plot of the AirPassengers data
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – AirPassengers数据的ACF图
- en: Here, we can see that all of the points are significantly related to their previous
    points because the data itself is trending upward. However, we can also see that
    there are peaks and valleys in the data, which is representative of the seasonal
    correlations.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到所有点都与它们的前一个点有显著的相关性，因为数据本身是向上趋势的。然而，我们也可以看到数据中有峰值和谷值，这代表了季节性相关性。
- en: Now, let’s take a look at the PACF plot, which is also generated by the `acf()`
    function where the type is set to “partial.”
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看PACF图，它也是通过将`acf()`函数的类型设置为“partial”而生成的。
- en: 'The partial autocorrelation is the relationship between an observation, *t*,
    and some observation, *t-n*. With a relationship between *t* and the previous
    observations through *t-n* removed, the partial autocorrelation is the result
    of removing the effects of the terms at shorter lags. Now, let’s look at the PACF
    of the same time series, `acf(ap_ts, type = "``partial")`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 偏自相关是观察值`t`与某些观察值`t-n`之间的关系。通过移除`t`与通过`t-n`的先前观察值之间的关系，偏自相关是移除较短滞后项的影响的结果。现在，让我们看看同一时间序列的PACF，`acf(ap_ts,
    type = "partial")`：
- en: '![Figure 10.5 – PACF of the AirPassengers data](img/B19142_10_5.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5 – AirPassengers数据的PACF](img/B19142_10_5.jpg)'
- en: Figure 10.5 – PACF of the AirPassengers data
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 – AirPassengers数据的PACF
- en: With that, we’ve gone over how to quickly create ACF and PACF plots in R. We
    have also provided a very quick overview of what they are. Now, let’s learn how
    to model the time series with the `healthyR.ts` library.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些，我们已经介绍了如何在R中快速创建ACF和PACF图。我们还提供了一个非常快速的了解它们是什么的概述。现在，让我们学习如何使用`healthyR.ts`库对时间序列进行建模。
- en: Auto ARIMA modeling with healthyR.ts
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用healthyR.ts进行自动ARIMA建模
- en: Time series, just like any other set of data, can be modeled. The methods are
    vast, both old and new. In this section, we are going to discuss ARIMA modeling,
    and more specifically building an automatic ARIMA model with the `healthyR.ts`
    library in R. ARIMA models themselves attempt to describe the autocorrelations
    in the data.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列，就像任何其他数据集一样，可以被建模。方法众多，既有古老的也有新的。在本节中，我们将讨论ARIMA建模，特别是使用R中的`healthyR.ts`库构建自动ARIMA模型。ARIMA模型本身试图描述数据中的自相关性。
- en: In this section, we will use a workflow that ends with the `ts_auto_arima()`
    function creating and fitting a tuned model. This model requires our data to be
    in tibble format. So, to do this, we will use the AirPassengers dataset and make
    sure it is a tibble.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用一个以`ts_auto_arima()`函数创建和拟合调整后的模型结束的工作流程。此模型需要我们的数据以tibble格式。因此，为了做到这一点，我们将使用AirPassengers数据集并确保它是一个tibble。
- en: 'Let’s get started with the dataset we have already brought in and coerce it
    into a tibble:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们已经引入的数据集开始，并将其强制转换为tibble：
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding code, we loaded the `healthyR.ts` and `dplyr` libraries and
    then took the already existing `ap_ts` time series object and converted it into
    a tibble using the `ts_to_tbl()` function from the `healthyR.ts` library. The
    next thing we have to do is create a train/test split using the `time_series_split()`
    function from the `timetk` library:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们加载了`healthyR.ts`和`dplyr`库，然后使用`healthyR.ts`库中的`ts_to_tbl()`函数将已经存在的`ap_ts`时间序列对象转换为tibble。接下来，我们必须使用`timetk`库中的`time_series_split()`函数创建一个训练/测试分割：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now that we have created the analysis/assess data splits, we are ready to run
    the main function. This function is intended to be a boilerplate function in that
    it will do most things automatically. However, you can always take the model and
    do what you wish with it. These boilerplate functions from `healthyR.ts` are not
    meant to be the end-all-be-all.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了分析/评估数据分割，我们就可以运行主函数了。这个函数旨在成为一个样板函数，它会自动完成大多数工作。然而，你总是可以取用模型并对其进行你想要的操作。`healthyR.ts`中的这些样板函数并不打算成为终极解决方案。
- en: 'Let’s run the function now and then take a look at the outputs:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在运行这个函数，然后看看输出：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding, we have provided the tibble that holds the data and the number
    of cores that we want to use – in our case, `10`. Next, we supplied the column
    that holds the date – in this case, `date_col` – with the value column being `x`
    from our supplied tibble. Next up was our resampling object, splits, and then
    our formula, which gets passed to the recipe function internally to the `ts_auto_arima()`
    function. In this case, it is `x` against the date. We supply a grid size of `20`
    to make the tuning grid and a slice limit of `5` so that no more than five slices
    of data are generated. Most importantly, we set the `.tune` parameter to `TRUE`.
    This instructs the function to go ahead with model tuning. Model tuning can result
    in it taking a few seconds/minutes for data to be returned.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面，我们提供了包含数据和我们要使用的核心数（在我们的案例中是`10`）的tibble。接下来，我们提供了包含日期的列——在这个案例中是`date_col`——值列来自我们提供的tibble中的`x`。接下来是重采样对象，分割，然后是我们的公式，它被传递到`ts_auto_arima()`函数内部的recipe函数。在这种情况下，它是`x`对日期。我们提供了一个`20`的网格大小来制作调整网格，以及一个`5`的切片限制，以确保不会生成超过五个数据切片。最重要的是，我们将`.tune`参数设置为`TRUE`。这指示函数继续进行模型调整。模型调整可能会导致数据返回需要几秒钟/几分钟。
- en: 'Let’s look at the output. The first thing that we will look at is the recipe
    information:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看输出。我们将首先查看配方信息：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: So, from the preceding output, we can see that we have both a single outcome
    and a predictor variable. This is all we need for an auto ARIMA model with no
    exogenous regressors.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从前面的输出中，我们可以看到我们有一个单一的结果变量和一个预测变量。对于一个没有外生回归变量的自动ARIMA模型来说，这已经足够了。
- en: 'Now, let’s look at the model information:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看模型信息：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding code, we can see that all the parameters of the model are
    set to `tune::tune()`. This will allow the model to be run through the tuning
    grid:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到模型的所有参数都设置为`tune::tune()`。这将允许模型通过调整网格运行：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following workflow object that’s created shows that the recipe has no steps
    to it as no transformations of any type are being performed:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的以下工作流程对象显示，配方没有任何步骤，因为没有进行任何类型的转换：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The fitted workflow object shows that the best model that was selected was the
    `ARIMA(4,1,2)(1,0,1)[12]` model. It also gives us our coefficients and model AIC.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 拟合的工作流程对象显示，选定的最佳模型是`ARIMA(4,1,2)(1,0,1)[12]`模型。它还提供了我们的系数和模型AIC。
- en: 'Next, we will take a look at the `model_calibration` object of the return output:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看返回输出的`model_calibration`对象：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here’s the resulting plot:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是生成的图表：
- en: '![Figure 10.6 – Auto ARIMA calibration plot](img/B19142_10_6.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6 – 自动ARIMA校准图](img/B19142_10_6.jpg)'
- en: Figure 10.6 – Auto ARIMA calibration plot
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 – 自动ARIMA校准图
- en: 'Lastly, we are going to go over the `tuned_model` object of the return:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将回顾返回的`tuned_model`对象：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: From the preceding code, we can see that there is a great deal of information
    that comes from this portion of what is returned from the function. This should
    contain everything you need to make an informed decision about whether you should
    keep tinkering or move on.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以看到从这个函数返回的这一部分有很多信息。这应该包含你做出明智决定所需的所有信息，决定你是否应该继续调整或继续前进。
- en: 'Let’s look at the last plot, which is returned as both a static `ggplot2` object
    and a `plotly` object:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看最后一个图表，它作为静态`ggplot2`对象和`plotly`对象返回：
- en: '![Figure 10.7 – The tuning grid of the auto ARIMA model](img/B19142_10_7.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图10.7 – 自动ARIMA模型的调优网格](img/B19142_10_7.jpg)'
- en: Figure 10.7 – The tuning grid of the auto ARIMA model
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 – 自动ARIMA模型的调优网格
- en: With this done, let us now see how Brownian motion concept works.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，让我们看看布朗运动的概念是如何工作的。
- en: Creating a Brownian motion with healthyR.ts
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用healthyR.ts创建布朗运动
- en: The final time series plot that we are going to showcase is the **Brownian motion**.
    Brownian motion, also known as the *Wiener process*, is a fundamental concept
    in finance and mathematics that describes the random movement of particles in
    a fluid. In the context of finance, it is often used to model the price movement
    of financial instruments such as stocks, commodities, and currencies.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要展示的最后一个时间序列图是**布朗运动**。布朗运动，也称为*维纳过程*，是金融和数学中的一个基本概念，描述了流体中粒子的随机运动。在金融的背景下，它通常用于模拟股票、商品和货币等金融工具的价格变动。
- en: 'Here are some of the key characteristics of Brownian motion:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 布朗运动的一些关键特征如下：
- en: '**Randomness**: Brownian motion is inherently random. The future direction
    and magnitude of movement at any point in time cannot be predicted with certainty.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**随机性**：布朗运动本质上是随机的。在任何时间点，未来方向和移动幅度都不能被确定地预测。'
- en: '**Continuous path**: The path of a Brownian motion is continuous, meaning that
    the asset’s price can move smoothly without sudden jumps or gaps.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连续路径**：布朗运动的路径是连续的，这意味着资产的价格可以平滑移动，没有突然的跳跃或缺口。'
- en: '**Independent increments**: The changes in the asset’s price over non-overlapping
    time intervals are independent of each other. In other words, the price movement
    in one interval does not affect the price movement in another.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独立增量**：资产价格在非重叠时间间隔内的变化是相互独立的。换句话说，一个时间间隔的价格变动不会影响另一个时间间隔的价格变动。'
- en: '**Gaussian distribution**: The increments of a Brownian motion (that is, the
    changes in price) are normally distributed, following a Gaussian or normal distribution.
    This is in line with the notion that in financial markets, small price changes
    are more common than large ones.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高斯分布**：布朗运动的增量（即价格变化）是正态分布的，遵循高斯或正态分布。这与金融市场中小幅度价格变动比大幅度变动更常见的观点一致。'
- en: '**Constant variance**: The variance of the price increments remains constant
    over time. This is sometimes referred to as the **homoscedastic** property.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**恒定方差**：价格增量的方差随时间保持恒定。这有时被称为**同方差**属性。'
- en: 'Mathematically, the movement of an asset’s price, *S(t)*, over time, *t*, can
    be described using the stochastic differential equation:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学上讲，资产价格*S(t)*随时间*t*的变化可以用随机微分方程来描述：
- en: 'Here, we have the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有以下内容：
- en: '*dS(t)* is the infinitesimal change in the asset’s price over a small time
    interval, *dt*'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*dS(t)* 是资产价格在微小时间间隔*dt*内的无穷小变化'
- en: '*μ* is the drift or expected average rate of return of the asset over time'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*μ* 是资产随时间变化的漂移或预期平均回报率'
- en: '*σ* is the volatility of the asset, representing the standard deviation of
    its price changes'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*σ* 是资产的波动性，代表其价格变化的标准差'
- en: '*dW(t)* is the Wiener process, representing a random increment'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*dW(t)* 是维纳过程，代表一个随机增量'
- en: The Brownian motion is a cornerstone of financial models such as the Black-Scholes
    option pricing model and the Vasicek interest rate model, among others. It helps
    in understanding and estimating the behavior of financial instruments by capturing
    their inherent randomness and volatility. However, it’s important to note that
    real financial markets can deviate from a perfect Brownian motion due to factors
    such as market sentiment, news, and other external influences.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 布朗运动是金融模型（如Black-Scholes期权定价模型和Vasicek利率模型）的基石之一。它通过捕捉其固有的随机性和波动性，有助于理解和估计金融工具的行为。然而，需要注意的是，由于市场情绪、新闻和其他外部因素的影响，实际金融市场可能偏离完美的布朗运动。
- en: 'We can quickly generate a Brownian motion and plot its output with the `healthyR.ts`
    library. Here’s the code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`healthyR.ts`库快速生成布朗运动并绘制其输出。以下是代码：
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here’s the output of the preceding code. This is a random process, so your
    output will likely not match:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是前面代码的输出。这是一个随机过程，所以你的输出可能不会匹配：
- en: '![Figure 10.8 – Creating and viewing a Brownian motion with the healthyR.ts
    library](img/B19142_10_8.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图10.8 – 使用healthyR.ts库创建和查看布朗运动](img/B19142_10_8.jpg)'
- en: Figure 10.8 – Creating and viewing a Brownian motion with the healthyR.ts library
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8 – 使用 healthyR.ts 库创建和查看布朗运动
- en: Now that we have gone over time series data in R, let’s go over to Python and
    see how it is done there.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了 R 中的时间序列数据，让我们转到 Python 看看那里是如何操作的。
- en: Time series analysis in Python – statistics, plots, and forecasting
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 中的时间序列分析 – 统计、绘图和预测
- en: Before diving into time series analysis, it’s crucial to have data to work with.
    In this section, we’ll walk through the process of creating mock time series data,
    saving it to an Excel file, and then reading it back into pandas. This will serve
    as our foundation for the upcoming time series analysis.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究时间序列分析之前，拥有可工作的数据至关重要。在本节中，我们将介绍创建模拟时间序列数据、将其保存到 Excel 文件中，然后将其读回到 pandas
    的过程。这将成为我们进行时间序列分析的基础。
- en: 'As always, we’ll start by loading the relevant libraries:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们将从加载相关的库开始：
- en: '[PRE18]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we must create the sample data and save it to Excel so that it can be
    used in the rest of this chapter:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须创建样本数据并将其保存到 Excel 中，以便在本章的其余部分使用：
- en: '[PRE19]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we must load the data from Excel and have a look at the loaded data,
    as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须从 Excel 中加载数据，并查看加载的数据，如下所示：
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this example, we generate a synthetic time series with a linear trend, sine-wave
    seasonal component, and random noise. This kind of dataset is more representative
    of real-world time series data, where patterns often involve a combination of
    these elements. The dataset is then saved to an Excel file, and you can read it
    back into Python for analysis as needed.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们生成一个具有线性趋势、正弦波季节成分和随机噪声的合成时间序列。这种数据集更真实地反映了现实世界中的时间序列数据，其中模式通常涉及这些元素的组合。然后，数据集被保存到
    Excel 文件中，您可以根据需要将其读回到 Python 进行分析。
- en: As we discussed in [*Chapter 6*](B19142_06.xhtml#_idTextAnchor119), the first
    step of analysis is plotting (insert sinister laugh)!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [*第 6 章*](B19142_06.xhtml#_idTextAnchor119) 中讨论的，分析的第一步是绘图（插入邪恶的笑声）！
- en: Time series plotting – basic plots and ACF/PACF plots
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间序列绘图 – 基本绘图和 ACF/PACF 图
- en: Visualizing time series data is a crucial step in understanding its underlying
    patterns and trends. In this section, we’ll explore various time series plots
    and how to create them using Python. These visualizations help us gain insights
    into seasonality, trends, and autocorrelation within the time series data.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化时间序列数据是理解其潜在模式和趋势的关键步骤。在本节中，我们将探讨各种时间序列图以及如何使用 Python 创建它们。这些可视化有助于我们深入了解时间序列数据中的季节性、趋势和自相关性。
- en: 'We’ll start by loading the required libraries:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先加载所需的库：
- en: '[PRE21]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, we must load the data from Excel and ensure the date information is converted
    correctly:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须从 Excel 中加载数据，并确保日期信息被正确转换：
- en: '[PRE22]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we can create a basic plot of the time series for a first look:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建时间序列的基本图，以便进行初步查看：
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is what the plot looks like:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是该图的样子：
- en: '![Figure 10.9 - Caption](img/B19142_10_9.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.9 - 标题](img/B19142_10_9.jpg)'
- en: Figure 10.9 - Caption
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9 - 标题
- en: 'Next, we must create the more advanced ACF and PACF plots with the following
    code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须使用以下代码创建更高级的 ACF 和 PACF 图：
- en: '[PRE24]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The resulting plots are shown here:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图如下所示：
- en: '![Figure 10.10 – ACF and PACF plots for lags 1 and 2](img/B19142_10_10.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.10 – 滞后 1 和 2 的 ACF 和 PACF 图](img/B19142_10_10.jpg)'
- en: Figure 10.10 – ACF and PACF plots for lags 1 and 2
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10 – 滞后 1 和 2 的 ACF 和 PACF 图
- en: Here, we started by loading the time series data from an Excel file and converting
    the **Date** column into a datetime index. Then, we created a time series plot
    to visualize the data over time. Additionally, we generated ACF and PACF plots
    to explore autocorrelation patterns within the time series. These plots are valuable
    for identifying potential lag values for time series models.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先从 Excel 文件中加载数据，并将 **日期** 列转换为 datetime 索引。然后，我们创建了一个时间序列图来可视化数据随时间的变化。此外，我们还生成了
    ACF 和 PACF 图来探索时间序列中的自相关模式。这些图对于识别时间序列模型中可能的滞后值非常有价值。
- en: Now, let’s have a look at how ACF and PACF plots help with gaining insights
    into time series data. In particular, we’ll see how they can be used to understand
    seasonality, trends, and autocorrelation.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 ACF 和 PACF 图如何帮助我们深入了解时间序列数据。特别是，我们将看到它们如何被用来理解季节性、趋势和自相关性。
- en: Autocorrelation function (ACF) plot
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自相关函数 (ACF) 图
- en: The ACF plot shows the correlation between a time series and its lagged values.
    In other words, it quantifies how well the current value of the series is correlated
    with its past values.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ACF图显示了时间序列与其滞后值之间的相关性。换句话说，它量化了当前值与过去值的相关程度。
- en: Peaks in the ACF plot at specific lags indicate potential seasonality or periodic
    patterns in the data. For instance, a significant peak at lag 7 in a daily series
    suggests a weekly seasonality, while a peak at lag 12 in a monthly series may
    indicate a yearly seasonality.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ACF图在特定滞后处的峰值表示数据中可能存在的季节性或周期性模式。例如，在每日序列中滞后7处的显著峰值表明存在每周季节性，而在月度序列中滞后12处的峰值可能表明存在年度季节性。
- en: By analyzing the ACF plot, you can identify the lag values at which correlations
    significantly deviate from zero. These lags can provide insights into the seasonality
    of the data. Additionally, identifying exponential decay in ACF can suggest an
    autoregressive component in your time series model.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分析ACF图，您可以识别出相关性显著偏离零的滞后值。这些滞后值可以提供有关数据季节性的见解。此外，识别ACF中的指数衰减可以表明时间序列模型中存在自回归成分。
- en: Partial autocorrelation function (PACF) plot
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部分自相关函数（PACF）图
- en: The PACF plot measures the direct relationship between a time series and its
    lagged values while removing the effects of intermediate lags.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: PACF图衡量时间序列与其滞后值之间的直接关系，同时消除中间滞后值的影响。
- en: Peaks in the PACF plot at specific lags indicate the number of lagged values
    that directly impact the current value of the series. For example, a significant
    peak at lag 1 and no significant peaks beyond that suggest a first-order **autoregressive**
    (**AR**) process.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: PACF图在特定滞后处的峰值表示直接影响当前值的时间序列滞后值的数量。例如，滞后1处的一个显著峰值以及之后没有显著峰值表明存在一阶**自回归**（**AR**）过程。
- en: The PACF plot helps in determining the order of autoregressive terms (p) in
    ARIMA models. It can also reveal abrupt changes in the time series, indicating
    structural breaks or shifts.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: PACF图有助于确定ARIMA模型中自回归项（p）的阶数。它还可以揭示时间序列中的突然变化，表明结构断裂或位移。
- en: By analyzing these plots in conjunction with your time series data, you can
    gain valuable insights into the presence of seasonality, trends, and autocorrelation.
    These insights are instrumental in selecting appropriate time series models and
    making accurate forecasts.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合分析这些图表和您的时间序列数据，您可以获得有关季节性、趋势和自相关性的宝贵见解。这些见解在选择适当的时间序列模型和进行准确预测方面至关重要。
- en: The plots shown in *Figure 10**.9* show that for the PACF plot, only lag 1 has
    a strong autocorrelation, while the ACF plot is tricked by the way the random
    data was generated and shows a high autocorrelation across all lags investigated.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图10.9*中显示的图中，对于PACF图，只有滞后1具有强烈的自相关性，而ACF图由于随机数据生成的方式而被误导，在所有研究的滞后中都显示出高度的自相关性。
- en: 'With the insights gained from these plots, we can move on to the meat of the
    matter: statistical analysis and forecasting'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从这些图表中获得见解，我们可以继续进行实质性的分析：统计分析与预测
- en: Time series statistics and statistical forecasting
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间序列统计与统计预测
- en: Data exploration and statistical analysis are crucial steps in understanding
    the characteristics of time series data. In this section, we’ll walk you through
    how to perform data exploration and apply statistical analysis techniques in Python
    to gain valuable insights into your time series.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 数据探索和统计分析是理解时间序列数据特征的关键步骤。在本节中，我们将向您展示如何使用Python进行数据探索和运用统计分析技术，以获得对时间序列的宝贵见解。
- en: Statistical analysis for time series data
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间序列数据的统计分析
- en: 'After exploring the data using the plots in the previous section, let’s move
    on to statistical analysis to gain a deeper understanding. This section focuses
    on two areas:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中使用图表探索数据后，让我们继续进行统计分析，以获得更深入的理解。本节重点关注两个领域：
- en: '**The Augmented Dickey-Fuller (ADF) test**: This statistical test is used to
    determine whether the time series data is stationary. Stationary data is easier
    to model and forecast.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Augmented Dickey-Fuller (ADF) 测试**：这种统计测试用于确定时间序列数据是否平稳。平稳数据更容易建模和预测。'
- en: '**Time series decomposition**: Time series decomposition separates the data
    into its constituent components: trend, seasonality, and residuals. This decomposition
    aids in isolating patterns for forecasting.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间序列分解**：时间序列分解将数据分解为其组成部分：趋势、季节性和残差。这种分解有助于隔离用于预测的模式。'
- en: We’ll understand both of these in the following sections.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中了解这两者。
- en: The ADF test
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ADF测试
- en: The ADF test is a statistical method that’s used to evaluate the *stationarity*
    of a time series. Stationarity is a fundamental concept in time series analysis
    as it simplifies the modeling process. A stationary time series has statistical
    properties, such as constant mean and variance, that do not change over time.
    Non-stationary data, on the other hand, exhibits trends or seasonality, making
    it challenging to model and forecast accurately.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ADF测试是一种用于评估时间序列**平稳性**的统计方法。平稳性是时间序列分析中的一个基本概念，因为它简化了建模过程。平稳时间序列具有统计属性，如恒定的均值和方差，这些属性不会随时间变化。另一方面，非平稳数据表现出趋势或季节性，这使得准确建模和预测变得具有挑战性。
- en: In the ADF test, the null hypothesis (H0) assumes that the data is non-stationary.
    The alternative hypothesis (H1) suggests that the data is stationary. By analyzing
    the p-value obtained from the test, you can determine whether to reject the null
    hypothesis. A low p-value (typically less than 0.05) indicates that the data is
    stationary, while a high p-value suggests non-stationarity. Therefore, when conducting
    the ADF test, a p-value less than 0.05 is an indicator of a stationary time series.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在ADF测试中，零假设（H0）假定数据是非平稳的。备择假设（H1）表明数据是平稳的。通过分析从测试中获得的p值，你可以确定是否拒绝零假设。低p值（通常小于0.05）表明数据是平稳的，而高p值则表明非平稳性。因此，在进行ADF测试时，p值小于0.05是平稳时间序列的一个指标。
- en: 'Here is a code sample that implements the ADF test in Python using our trusty
    `statsmodels` library:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个代码示例，展示了如何使用我们信任的`statsmodels`库在Python中实现ADF测试：
- en: '[PRE25]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Not surprisingly, we failed to reject the null hypothesis as the time series
    data we generated earlier has a clear linear trend and hence it is not stationary.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，我们没有拒绝零假设，因为我们之前生成的时序数据具有明显的线性趋势，因此它不是平稳的。
- en: 'For further insights, we can analyze the detailed output further:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得更深入的见解，我们可以进一步分析详细的输出：
- en: '![Figure 10.11 – ADF test results](img/B19142_10_11.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图10.11 – ADF测试结果](img/B19142_10_11.jpg)'
- en: Figure 10.11 – ADF test results
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11 – ADF测试结果
- en: 'As you can see, the result of the ADF test, as returned by `adfuller`, contains
    several components:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，ADF测试的结果，由`adfuller`返回，包含几个组成部分：
- en: '`-0.24536819384067887`, in our case) is the test statistic. This statistic
    is used to assess the null hypothesis that a unit root is present in a time series
    dataset. The more negative (or less positive) the test statistic, the stronger
    the evidence against the null hypothesis.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的情况下（`-0.24536819384067887`）是测试统计量。这个统计量用于评估时序数据集中是否存在单位根的零假设。测试统计量越负（或越不积极），对零假设的证据就越强。
- en: '`0.9328933413659218`, in our case) is the p-value associated with the test
    statistic. It represents the probability of observing the given test statistic
    if the null hypothesis were true. A small p-value (typically less than 0.05) suggests
    rejecting the null hypothesis in favor of stationarity.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的情况下（`0.9328933413659218`）是与测试统计量相关的p值。它代表如果零假设为真，观察给定测试统计量的概率。小的p值（通常小于0.05）表明拒绝零假设，支持平稳性。
- en: '`9`, in our case) represents the number of lags used in the regression when
    estimating the ADF test.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的情况下（`9`））代表在估计ADF测试时回归中使用的滞后数。
- en: '`720`, in our case) represents the number of observations used in the ADF regression.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的情况下（`720`）代表在ADF回归中使用的观测数。
- en: '**Dictionary**: The next part of the result is a dictionary containing critical
    values for different confidence levels (1%, 5%, and 10%). These critical values
    are used to determine the significance of the test statistic.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字典**：结果的下一段是一个包含不同置信水平（1%、5%和10%）临界值的字典。这些临界值用于确定测试统计量的显著性。'
- en: '`1208.8292254446185`, in our case) is the maximized IC. It represents a measure
    of the goodness-of-fit of the model. Lower values of the IC indicate a better
    fit.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的情况下（`1208.8292254446185`）是最大化的IC。它代表模型拟合优度的一个度量。IC的值越低，拟合度越好。
- en: In summary, you would typically interpret the ADF test result by focusing on
    the test statistic and p-value. If the test statistic is more negative (or less
    positive) and the p-value is small (typically less than 0.05), it suggests rejecting
    the null hypothesis of a unit root and concluding that the time series is stationary.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，你通常会通过关注测试统计量和 p 值来解释 ADF 测试结果。如果测试统计量更负（或更正）且 p 值较小（通常小于 0.05），则表明拒绝单位根的零假设，并得出时间序列是平稳的结论。
- en: Time series decomposition
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时间序列分解
- en: 'Time series decomposition is a technique that’s used to break down a time series
    dataset into its key components: trend, seasonality, and residuals. These components
    provide valuable insights into the underlying patterns of the time series, making
    it easier to understand and forecast.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列分解是一种将时间序列数据集分解为其关键组成部分（趋势、季节性和残差）的技术。这些组成部分为理解时间序列的潜在模式提供了宝贵的见解，使其更容易理解和预测。
- en: 'Let’s understand each of these components:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解这些组成部分：
- en: '**Trend**: The trend component represents the underlying long-term movement
    or tendency in the data. It captures the overall direction – that is, whether
    data is increasing or decreasing over time.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**趋势**：趋势组成部分代表数据中的潜在长期运动或趋势。它捕捉整体方向——即数据随时间增加或减少。'
- en: '**Seasonality**: Seasonality refers to the repeating patterns in the data at
    fixed intervals. These could be daily, weekly, monthly, or yearly patterns, depending
    on the data. Detecting seasonality is crucial for understanding periodic trends
    and adjusting for them during forecasting.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**季节性**：季节性指的是数据在固定间隔内重复出现的模式。这些模式可能是每日、每周、每月或每年的模式，具体取决于数据。检测季节性对于理解周期性趋势并在预测中调整它们至关重要。'
- en: '**Residuals**: Residuals are the irregular or random components of the time
    series data. They represent what remains after removing the trend and seasonality.
    Analyzing residuals helps identify any leftover patterns or unusual events in
    the data.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**残差**：残差是时间序列数据的非规则或随机组成部分。它们代表在去除趋势和季节性之后剩余的部分。分析残差有助于识别数据中的任何剩余模式或异常事件。'
- en: In our code, we apply time series decomposition to break down the time series
    into its constituent components, and we visualize each component. This process
    allows us to understand the structure of the data, making it easier to identify
    underlying patterns for forecasting.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们应用时间序列分解将时间序列分解为其组成部分，并可视化每个组成部分。这个过程使我们能够理解数据的结构，从而更容易地识别预测中的潜在模式。
- en: 'Let’s have a look at an implementation for time series decomposition in Python:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Python 中时间序列分解的一个实现：
- en: '[PRE26]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The resulting plot is self-explanatory (especially as it reflects how the data
    was artificially generated):'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图是自解释的（特别是因为它反映了数据是如何人工生成的）：
- en: /
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: /
- en: '![Figure 10.12 – The time series decomposed](img/B19142_10_12.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.12 – 时间序列分解](img/B19142_10_12.jpg)'
- en: Figure 10.12 – The time series decomposed
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.12 – 时间序列分解
- en: 'In this section, we have covered the basic statistics that can help you understand
    your time series and the core techniques to handle the most typical challenges
    to modeling: decomposition and how to interpret the components. With a deeper
    understanding of our time series thanks to the plots provided and statistical
    analysis, we can move on to the highest value-added step: prediction.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了可以帮助你理解时间序列和解决建模中最典型挑战的核心技术：分解和如何解释组成部分。通过提供的图表和统计分析，我们对时间序列有了更深入的理解，可以继续进行最有价值的步骤：预测。
- en: Understanding predictive modeling approaches
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解预测建模方法
- en: In this section, we’ll delve into predictive modeling approaches using two powerful
    Python libraries – `statsmodels` and `prophet`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入探讨使用两个强大的 Python 库——`statsmodels` 和 `prophet`——进行预测建模方法。
- en: These libraries provide diverse tools to tackle time series forecasting, enabling
    you to make informed decisions and predictions based on your time series data.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这些库提供了多样化的工具来处理时间序列预测，使你能够根据时间序列数据做出明智的决定和预测。
- en: Forecasting with statsmodels
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 statsmodels 进行预测
- en: '`statsmodels` is a popular library in the Python ecosystem that offers a wide
    range of statistical tools, including time series analysis. For forecasting, it
    provides functionality for building ARIMA models. ARIMA models are a staple in
    time series analysis, allowing you to capture and model complex patterns within
    your data.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Building an ARIMA model with `statsmodels` involves selecting the appropriate
    order of differencing, autoregressive components, and moving average components
    to best represent the underlying patterns of the data. Once the model has been
    established, you can make forecasts and evaluate its performance.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it is very important to note that since the time series we have is
    not stationary, we should be modeling the changes or differences in our time series.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have a look at the workflow in code!
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the necessary libraries and load the data:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, check for stationarity and decide if we want to model the time series
    itself or the differences:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now (with the differenced data since our time series is not stationary), we
    can build the actual model and fit it:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Optionally, we could perform some hypertuning on the order parameters instead
    of basing our decision on the graphs only. However, for this example, this will
    suffice. Hypertuning is the action of tuning the parameters defining the model
    rather than the parameters fitted to the data, such as the order of the ARIMA
    model.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we can create our forecast with the trained model.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that since we modeled the differenced data, we need to translate the forecasts
    back into the actual time series:'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, we must calculate the basic statistics and use them to calculate a confidence
    interval:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, we must plot the forecast together with the original time series for
    visual evaluation of the model:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The resulting plot gives us some nice insights:'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.13 – The time series and the statsmodel forecast](img/B19142_10_13.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
- en: Figure 10.13 – The time series and the statsmodel forecast
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: We can see that while the trend is nicely captured and some of the seasonality
    also appears, the model is too simplistic to fully capture the nature of the time
    series.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'To remedy this, we can use a more complex model from a dedicated time series
    library: `prophet`.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Time series forecasting with Facebook’s prophet
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The specialized `prophet` library is designed explicitly for time series forecasting
    tasks. It is known for its ease of use and extensive model selection for a wide
    variety of forecasting scenarios.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '`prophet` provides an intuitive way to model time series data. It also features
    tools for hyperparameter optimization and forecasting evaluation.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'The code we will use is also visibly simpler:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must load the necessary libraries, read the Excel data in, and prepare
    it by creating a DataFrame with the columns `prophet` expects:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, we must customize the model a little using domain knowledge (in this
    case, coming from the fact that we generated the data this way):'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, we can create our forecast and plot it and its components:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以创建我们的预测并绘制它及其组成部分：
- en: '[PRE35]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The resulting plot shows a much higher quality forecast than `statsmodel` with
    a tight confidence interval. The seasonality is captured visibly, along with the
    trend:'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 生成的图表显示了一个比`statsmodel`更高的预测质量，置信区间更紧密。季节性和趋势都得到了明显的捕捉：
- en: '![Figure 10.14 – The time series and the prophet forecast](img/B19142_10_14.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![图10.14 – 时间序列和prophet预测](img/B19142_10_14.jpg)'
- en: Figure 10.14 – The time series and the prophet forecast
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.14 – 时间序列和prophet预测
- en: 'To dig deeper into the model fit, let’s have a look at the components of the
    fitted time series model:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入了解模型拟合，让我们看看拟合的时间序列模型的组成部分：
- en: '![Figure 10.15 – The components of the time series model fitted by prophet](img/B19142_10_15.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![图10.15 – 由prophet拟合的时间序列模型的组成部分](img/B19142_10_15.jpg)'
- en: Figure 10.15 – The components of the time series model fitted by prophet
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.15 – 由prophet拟合的时间序列模型的组成部分
- en: As you can see, `prophet` fits a model in a very simple way without having to
    guess what the starting parameters are. You can and should use any domain knowledge
    to improve the initial model.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`prophet`以非常简单的方式拟合模型，无需猜测起始参数。您可以使用并应该使用任何领域知识来改进初始模型。
- en: 'In the preceding code, we switched off the default weekly seasonality and added
    a custom annual seasonality. We can do much more if necessary:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们关闭了默认的每周季节性，并添加了自定义的年度季节性。如果需要，我们可以做更多的事情：
- en: We can add a custom holiday calendar, for example, using the `model.add_country_holidays(country_name='US')`
    command
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以添加自定义的假日日历，例如，使用`model.add_country_holidays(country_name='US')`命令。
- en: We can play around with change points if we are sure they are present but unsure
    exactly where
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们确信存在变化点，但不确定具体位置，我们可以尝试调整变化点。
- en: We can hypertune the Fourier order of the custom seasonality
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以调整自定义季节性的傅里叶阶数。
- en: With the forecasting done with `statsmodel` and `prophet`, it’s time to wrap
    up this section and move on to the next.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`statsmodel`和`prophet`完成预测后，是时候总结本节内容并继续下一部分了。
- en: In this section, you built a strong foundation in statistical analysis and forecasting
    for your time series data. These skills are crucial for understanding past trends
    and making predictions, enabling data-driven decisions and insights.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您为时间序列数据建立了强大的统计分析与预测基础。这些技能对于理解过去趋势和做出预测至关重要，能够支持数据驱动的决策和洞察。
- en: In the next section, we will have a look at deep learning models for time series
    analysis.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨用于时间序列分析的深度学习模型。
- en: Time series forecasting with deep learning – LSTM
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深度学习时间序列预测 – LSTM
- en: This section will give you insights into advanced time series forecasting techniques
    using deep learning models. Whether you’re working with traditional time series
    data or more complex, high-dimensional data, these deep learning models can help
    you make more accurate predictions. In particular, we will cover the `keras`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将向您介绍使用深度学习模型的高级时间序列预测技术。无论您是处理传统时间序列数据还是更复杂、高维度的数据，这些深度学习模型都能帮助您做出更准确的预测。特别是，我们将涵盖`keras`。
- en: 'We will be using `keras` with a `tensorflow` backend, so you need to install
    both libraries:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`keras`和`tensorflow`后端，因此您需要安装这两个库：
- en: 'As always, let’s load the necessary libraries and preprocess some time series
    data:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像往常一样，让我们加载必要的库并预处理一些时间序列数据：
- en: '[PRE36]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'With the dataset prepared, we will split it into training and testing sets
    and reshape them for LSTM input:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据集准备就绪后，我们将将其分为训练集和测试集，并重新塑形以供LSTM输入：
- en: '[PRE37]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now that the data has been prepared, let’s create and train an LSTM model:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据准备就绪后，让我们创建并训练一个LSTM模型：
- en: '[PRE38]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This code defines a simple LSTM model, compiles it, and trains it using our
    training data. You can customize the model architecture and training parameters
    as needed for your specific time series analysis. Note that the training time
    is significantly longer than with the simpler models we used in the previous section.
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码定义了一个简单的LSTM模型，编译它，并使用我们的训练数据进行训练。您可以根据您特定的时序分析需要自定义模型架构和训练参数。请注意，训练时间比我们在上一节中使用的简单模型长得多。
- en: 'Once the model has been trained, we can make predictions and scale them back
    so that we can compare them with the original dataset:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模型训练完成后，我们可以做出预测并将它们缩放回原始数据集进行比较：
- en: '[PRE39]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, visualize the actual dataset and the prediction for the test set:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，可视化实际数据集和测试集的预测：
- en: '[PRE40]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The resulting image is quite impressive for such a small dataset and simple
    model:'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于如此小的数据集和简单的模型，生成的图像相当令人印象深刻：
- en: '![Figure 10.16 – The actual data (in blue) and the prediction for the test
    set (in green)](img/B19142_10_16.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![图10.16 – 实际数据（蓝色）和测试集预测（绿色）](img/B19142_10_16.jpg)'
- en: Figure 10.16 – The actual data (in blue) and the prediction for the test set
    (in green)
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.16 – 实际数据（蓝色）和测试集预测（绿色）
- en: Remember that this is a basic example. LSTM models can be significantly more
    complex, and you might need to explore techniques such as stacked LSTMs, hyperparameter
    tuning, and more, depending on your specific time series data.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这是一个基本示例。LSTM模型可以显著更复杂，你可能需要探索堆叠LSTM、超参数调整等技术，具体取决于你的时间序列数据。
- en: This concludes our journey into time series analysis with Python. Let’s recap
    what you have learned in this chapter!
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们使用Python进行时间序列分析之旅的结束。让我们回顾一下本章你学到了什么！
- en: Summary
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we delved into the fascinating world of time series analysis.
    We began by exploring time series plotting, mastering essential plots, and understanding
    the significance of ACF/PACF plots.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了时间序列分析的迷人世界。我们首先探索了时间序列绘图，掌握了基本绘图，并理解了ACF/PACF图的重要性。
- en: Moving forward, we ventured into time series statistics, including the ADF test,
    time series decomposition, and statistical forecasting with tools such as `statsmodels`
    and `prophet`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们进入了时间序列统计领域，包括ADF测试、时间序列分解以及使用`statsmodels`和`prophet`等工具进行统计预测。
- en: To elevate our forecasting game, we embraced deep learning, employing LSTM networks
    using Python’s `keras` library. We learned to develop accurate time series forecasts
    and create insightful visualizations for data-driven insights.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提升我们的预测能力，我们采用了深度学习，使用Python的`keras`库来应用LSTM网络。我们学会了开发准确的时间序列预测，并创建深入的数据驱动洞察的视觉化。
- en: This chapter equipped us with a comprehensive set of skills for time series
    analysis, enabling us to unravel the hidden patterns and insights within time-based
    data, from plotting to statistical analysis and deep learning forecasting.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为我们提供了一套全面的时间序列分析技能，使我们能够揭示基于时间数据的隐藏模式和洞察，从绘图到统计分析再到深度学习预测。
- en: In the next chapter, we will discuss a different integration method – that is,
    calling R and Python from Excel directly.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论不同的集成方法——即直接从Excel调用R和Python。
- en: 'Part 4: The Other Way Around – Calling R and Python from Excel'
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四部分：反过来调用——从Excel调用R和Python
- en: In this part, you willl unlock the power of R and Python within Excel with comprehensive
    solutions designed for seamless integration. You will discover how to leverage
    BERT and `xlwings` for streamlined communication between Excel and your preferred
    programming language locally. You will explore open source API solutions such
    as Plumber and FastAPI, along with commercial offerings such as Posit Connect
    and ownR, to expand the capabilities of your Excel workflow with API-based integration.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分，你将解锁在Excel中R和Python的强大功能，通过为无缝集成设计的全面解决方案。你将发现如何利用BERT和`xlwings`在Excel和你的首选编程语言之间实现流畅的通信。你将探索开源API解决方案，如Plumber和FastAPI，以及商业产品如Posit
    Connect和ownR，以通过基于API的集成扩展Excel工作流程的功能。
- en: 'This part has the following chapter:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 11*](B19142_11.xhtml#_idTextAnchor215), *Calling R/Python Locally
    from Excel Directly or via an API*'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B19142_11.xhtml#_idTextAnchor215)，*从Excel直接或通过API调用R/Python*'
