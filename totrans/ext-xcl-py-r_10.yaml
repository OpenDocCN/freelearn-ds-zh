- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Time Series Analysis: Statistics, Plots, and Forecasting'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the realm of mathematical analysis, particularly in the study of data and
    trends, time series charts play a pivotal role. A time series chart is a graphical
    representation that displays data points collected over a sequence of time intervals.
    This tool is indispensable in various fields, including economics, finance, environmental
    science, and social sciences, for analyzing patterns, trends, and fluctuations
    in data over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical time series chart comprises two essential components: the time axis
    and the data axis. The time axis represents the progression of time, which can
    be measured in various units, such as seconds, minutes, hours, days, months, or
    years. The data axis displays the values of the variable being studied, which
    can be anything from stock prices and temperature readings to population counts
    and sales figures.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To construct a time series chart, you must do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data collection**: Gather data points at regular time intervals or time stamps.
    These intervals should be consistent to accurately capture temporal patterns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data representation**: Plot the collected data points on the graph, aligning
    each point with its corresponding time stamp on the time axis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Axis scaling**: Choose appropriate scaling for both the time axis and the
    data axis. This ensures that the patterns are visible and accurately represented.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Connect data points**: Depending on the context, data points can be connected
    with lines, curves, or bars. Connecting points can reveal trends more effectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A time series chart’s primary function is to enable the analysis of trends,
    patterns, and anomalies in the data. Several insights can be gained from such
    analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Trend identification**: Time series charts help identify long-term trends,
    such as gradual increases or decreases in values over time. These trends can provide
    valuable information for decision-making.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Seasonal variations**: Seasonal patterns, such as spikes in sales during
    holiday seasons, can be identified by observing regular fluctuations in the data
    over specific periods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cyclic patterns**: In addition to seasonal variations, cyclic patterns –
    repeating but irregular fluctuations – can be observed. These might be influenced
    by factors such as economic cycles or environmental changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Volatility and outliers**: Sudden spikes or dips in the data can indicate
    volatility or outliers, drawing attention to events or factors affecting the variable
    being measured.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time series charts also serve as a foundation for forecasting and predictive
    analysis. Mathematical models can be applied to historical data to make predictions
    about future trends and values. It is important to note that when I say make predictions,
    I do mean that we are making inferences about what could be likely to happen if
    all things remain the same. Techniques such as moving averages, exponential smoothing,
    and **autoregressive integrated moving average** (**ARIMA**) models are commonly
    used for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: In the realm of mathematical analysis, a time series chart is a powerful tool
    that aids in understanding the dynamics of data over time. By visually representing
    data points and trends, it allows researchers, analysts, and decision-makers to
    extract valuable insights, identify patterns, and make informed predictions. Through
    the lens of mathematical analysis, time series charts provide a structured approach
    to comprehending temporal data, thereby contributing significantly to fields that
    rely on data-driven decision-making.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Generating random time series objects in R
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time series plotting with R
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auto ARIMA modeling with `healthyR.ts`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Brownian motion with `healthyR.ts`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time series plotting – basic plots and ACF/PACF plots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time series statistics and statistical forecasting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time series forecasting with deep learning – LSTM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few technical requirements for this chapter. Note that the code
    for this chapter can be found at [https://github.com/PacktPublishing/Extending-Excel-with-Python-and-R/tree/main/Chapter%2010](https://github.com/PacktPublishing/Extending-Excel-with-Python-and-R/tree/main/Chapter%2010).
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the packages that we will be using in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`healthyR.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forecast`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timetk`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Modeltime`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prophet (``for Python)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`keras`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tensorflow`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start by creating time series objects in base R. The basic object class
    for a time series object in R is `ts` and objects can be coerced to that object
    by either using the `ts()` function directly or calling `as.ts()` on an object
    such as a vector.
  prefs: []
  type: TYPE_NORMAL
- en: Generating random time series objects in R
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to generate some random time series objects in base R. Doing this
    is very simple as base R comes with some distribution functions already packed
    in. We will make use of the random normal distribution by making calls to the
    `rnorm()` function. This function has three parameters to provide arguments to:'
  prefs: []
  type: TYPE_NORMAL
- en: '`n`: The number of points to be generated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mean`: The mean of the distribution, with a default of 0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sd`: The standard deviation of the distribution, with the default being 1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s go ahead and generate our first random vector. We will call it `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`set.seed(123)`: This line is all about ensuring that the random numbers that
    are generated in your code are consistent each time you run it. By setting a seed
    value (in this case, `123`), you ensure that the random numbers that are generated
    by your code will be the same every time you run it. This is useful for reproducibility
    in your analysis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`n <- 25`: Here, you’re defining a variable called `n` and setting its value
    to `25`. This variable represents the number of data points you want to generate
    in your random time series.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x <- rnorm(n)`: This is where the actual data generation happens. You’re creating
    a new variable, `x`, and using the `rnorm()` function to generate random numbers.
    These numbers are drawn from a Gaussian (or normal) distribution, which is often
    called a bell curve. `n` specifies the number of random data points to generate,
    which in this case is 25.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`head(x)`: Finally, you’re using the `head()` function to display the first
    few values of the `x` variable. This helps you quickly inspect what the generated
    data looks like. It’s a handy way to get a glimpse of your data without printing
    the entire dataset.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To summarize, this code sets a random seed for reproducibility, specifies the
    number of data points you want (`25`), and generates these data points from a
    Gaussian distribution, storing them in the `x` variable. Then, it shows the first
    few values of `x` using the `head()` function. This code is often used in data
    analysis and statistics when you need random data to work with or simulate real-world
    scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s convert this vector, `x`, into a time series object using the `ts()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s check the class of the newly created object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We must do the same for its structure and attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: So, what happened exactly? Let’s go over it in a simple yet concise manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'This R code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ts_obj <- ts(x)`: This creates a time series object (`ts_obj`) from a vector
    or data series, `x`. This step converts `x` into a time series format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`class(ts_obj)`: This checks and displays the class of `ts_obj`. This should
    return `ts`, indicating that `ts_obj` is indeed a time series.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`str(ts_obj)`: This line displays the structure of `ts_obj`, providing information
    about the time series. In this case, it shows that the time series has 25 data
    points ranging from 1 to 25, along with the values themselves.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`attributes(ts_obj)`: This shows the attributes of the time series object.
    In this case, it displays the time span (`tsp`) with values of `1 25 1`, which
    means that the time series starts from period 1 and ends at period 25 with a frequency
    of 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, this code essentially takes a vector, `x`, converts it into a time series
    object, and then provides information about the class and structure of the resulting
    time series. Now, let’s visualize the time series by using the `plot` function.
    We can do this with `plot(ts_obj)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Plot of a time series object from rnorm(25)](img/B19142_10_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Plot of a time series object from rnorm(25)
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered how to coerce a vector into a time series object, we
    can discuss how to change the start, end, and frequency parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating the time series parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we are going to use the previous vector we created from `rnorm()` and convert
    it into different time series objects with different starts, ends, and frequencies.
    This sort of thing is very simple to do in base R.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see some code manipulation first; then, we will go through and explain
    the examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the explanations for each of the preceding examples. The last one
    in the preceding code block shows the output of the last manipulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ts(x, start = 1980)`: This creates a time series with a start date in `1980`.
    The exact month and day are not specified, so the default is January 1, 1980.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ts(x, start = c(1980, 05))`: This sets the start date to May 1980 (year and
    month) explicitly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ts(x, start = 1980, frequency = 12)`: This line creates a time series with
    a start date in `1980` and a monthly frequency, indicating that each data point
    represents one month.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ts(x, start = 1980, frequency = 12/3)`: This sets the start year to `1980`
    and specifies a frequency of 4, which means each data point is a quarter (three
    months) apart.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ts(x, end = 2023)`: This creates a time series with an end date in `2023`.
    The start date is not specified here, so it defaults to the beginning of the series.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ts(x, end = 2023, frequency = 12)`: This line indicates that the end date
    is `2023` with a monthly frequency, assuming each data point represents one month.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ts(x, end = 2023, frequency = 12/3)`: This sets the end year to `2023` and
    specifies a frequency of 4, meaning each data point is a quarter (three months)
    apart.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These variations allow you to control the temporal characteristics of your time
    series data, such as the start and end points and the frequency of observations.
    Now that we have generated some data, let’s plot it out.
  prefs: []
  type: TYPE_NORMAL
- en: Time series plotting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will cover plotting time series objects, along with plotting
    some diagnostics such as decomposition. These plots include time series plots
    themselves, `readxl` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Visualizing the AirPassengers time series dataset](img/B19142_10_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – Visualizing the AirPassengers time series dataset
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, it is easy to see that the data has a trend and a seasonal cycle
    component. This observation will lead us to our next visual. We will decompose
    the data into its parts and visualize the decomposition. The decomposition of
    the time series breaks the data down into the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The observed data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The trend of the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The seasonal cycle of the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The remaining “randomness” or “residual/remainder”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s go ahead and see what it looks like. First, we have the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Plot of a decomposed time series](img/B19142_10_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Plot of a decomposed time series
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have visualized the decomposition, we can start analyzing the ACF
    and PACF plots.
  prefs: []
  type: TYPE_NORMAL
- en: Creating ACF and PACF plots in R
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to cover ACF and PACF plots. An ACF plot is an
    autocorrelation function plot. An autocorrelation function is the relationship
    between a current observation in time against a previous observation in time.
    It tells you how correlated a current observation is compared to different lags
    of the same time series. So, if there is a strong seasonal demand for beer, you
    will see a strong correlation for them at the same seasonal period before it.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s look at the output of the `acf()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the plot for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – ACF plot of the AirPassengers data](img/B19142_10_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – ACF plot of the AirPassengers data
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see that all of the points are significantly related to their previous
    points because the data itself is trending upward. However, we can also see that
    there are peaks and valleys in the data, which is representative of the seasonal
    correlations.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s take a look at the PACF plot, which is also generated by the `acf()`
    function where the type is set to “partial.”
  prefs: []
  type: TYPE_NORMAL
- en: 'The partial autocorrelation is the relationship between an observation, *t*,
    and some observation, *t-n*. With a relationship between *t* and the previous
    observations through *t-n* removed, the partial autocorrelation is the result
    of removing the effects of the terms at shorter lags. Now, let’s look at the PACF
    of the same time series, `acf(ap_ts, type = "``partial")`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – PACF of the AirPassengers data](img/B19142_10_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – PACF of the AirPassengers data
  prefs: []
  type: TYPE_NORMAL
- en: With that, we’ve gone over how to quickly create ACF and PACF plots in R. We
    have also provided a very quick overview of what they are. Now, let’s learn how
    to model the time series with the `healthyR.ts` library.
  prefs: []
  type: TYPE_NORMAL
- en: Auto ARIMA modeling with healthyR.ts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Time series, just like any other set of data, can be modeled. The methods are
    vast, both old and new. In this section, we are going to discuss ARIMA modeling,
    and more specifically building an automatic ARIMA model with the `healthyR.ts`
    library in R. ARIMA models themselves attempt to describe the autocorrelations
    in the data.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will use a workflow that ends with the `ts_auto_arima()`
    function creating and fitting a tuned model. This model requires our data to be
    in tibble format. So, to do this, we will use the AirPassengers dataset and make
    sure it is a tibble.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get started with the dataset we have already brought in and coerce it
    into a tibble:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we loaded the `healthyR.ts` and `dplyr` libraries and
    then took the already existing `ap_ts` time series object and converted it into
    a tibble using the `ts_to_tbl()` function from the `healthyR.ts` library. The
    next thing we have to do is create a train/test split using the `time_series_split()`
    function from the `timetk` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have created the analysis/assess data splits, we are ready to run
    the main function. This function is intended to be a boilerplate function in that
    it will do most things automatically. However, you can always take the model and
    do what you wish with it. These boilerplate functions from `healthyR.ts` are not
    meant to be the end-all-be-all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run the function now and then take a look at the outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding, we have provided the tibble that holds the data and the number
    of cores that we want to use – in our case, `10`. Next, we supplied the column
    that holds the date – in this case, `date_col` – with the value column being `x`
    from our supplied tibble. Next up was our resampling object, splits, and then
    our formula, which gets passed to the recipe function internally to the `ts_auto_arima()`
    function. In this case, it is `x` against the date. We supply a grid size of `20`
    to make the tuning grid and a slice limit of `5` so that no more than five slices
    of data are generated. Most importantly, we set the `.tune` parameter to `TRUE`.
    This instructs the function to go ahead with model tuning. Model tuning can result
    in it taking a few seconds/minutes for data to be returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the output. The first thing that we will look at is the recipe
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: So, from the preceding output, we can see that we have both a single outcome
    and a predictor variable. This is all we need for an auto ARIMA model with no
    exogenous regressors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at the model information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that all the parameters of the model are
    set to `tune::tune()`. This will allow the model to be run through the tuning
    grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following workflow object that’s created shows that the recipe has no steps
    to it as no transformations of any type are being performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The fitted workflow object shows that the best model that was selected was the
    `ARIMA(4,1,2)(1,0,1)[12]` model. It also gives us our coefficients and model AIC.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will take a look at the `model_calibration` object of the return output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the resulting plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Auto ARIMA calibration plot](img/B19142_10_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – Auto ARIMA calibration plot
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we are going to go over the `tuned_model` object of the return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding code, we can see that there is a great deal of information
    that comes from this portion of what is returned from the function. This should
    contain everything you need to make an informed decision about whether you should
    keep tinkering or move on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the last plot, which is returned as both a static `ggplot2` object
    and a `plotly` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – The tuning grid of the auto ARIMA model](img/B19142_10_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – The tuning grid of the auto ARIMA model
  prefs: []
  type: TYPE_NORMAL
- en: With this done, let us now see how Brownian motion concept works.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Brownian motion with healthyR.ts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final time series plot that we are going to showcase is the **Brownian motion**.
    Brownian motion, also known as the *Wiener process*, is a fundamental concept
    in finance and mathematics that describes the random movement of particles in
    a fluid. In the context of finance, it is often used to model the price movement
    of financial instruments such as stocks, commodities, and currencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the key characteristics of Brownian motion:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Randomness**: Brownian motion is inherently random. The future direction
    and magnitude of movement at any point in time cannot be predicted with certainty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous path**: The path of a Brownian motion is continuous, meaning that
    the asset’s price can move smoothly without sudden jumps or gaps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Independent increments**: The changes in the asset’s price over non-overlapping
    time intervals are independent of each other. In other words, the price movement
    in one interval does not affect the price movement in another.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gaussian distribution**: The increments of a Brownian motion (that is, the
    changes in price) are normally distributed, following a Gaussian or normal distribution.
    This is in line with the notion that in financial markets, small price changes
    are more common than large ones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Constant variance**: The variance of the price increments remains constant
    over time. This is sometimes referred to as the **homoscedastic** property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mathematically, the movement of an asset’s price, *S(t)*, over time, *t*, can
    be described using the stochastic differential equation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*dS(t)* is the infinitesimal change in the asset’s price over a small time
    interval, *dt*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*μ* is the drift or expected average rate of return of the asset over time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*σ* is the volatility of the asset, representing the standard deviation of
    its price changes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*dW(t)* is the Wiener process, representing a random increment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Brownian motion is a cornerstone of financial models such as the Black-Scholes
    option pricing model and the Vasicek interest rate model, among others. It helps
    in understanding and estimating the behavior of financial instruments by capturing
    their inherent randomness and volatility. However, it’s important to note that
    real financial markets can deviate from a perfect Brownian motion due to factors
    such as market sentiment, news, and other external influences.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can quickly generate a Brownian motion and plot its output with the `healthyR.ts`
    library. Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output of the preceding code. This is a random process, so your
    output will likely not match:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Creating and viewing a Brownian motion with the healthyR.ts
    library](img/B19142_10_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 – Creating and viewing a Brownian motion with the healthyR.ts library
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have gone over time series data in R, let’s go over to Python and
    see how it is done there.
  prefs: []
  type: TYPE_NORMAL
- en: Time series analysis in Python – statistics, plots, and forecasting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before diving into time series analysis, it’s crucial to have data to work with.
    In this section, we’ll walk through the process of creating mock time series data,
    saving it to an Excel file, and then reading it back into pandas. This will serve
    as our foundation for the upcoming time series analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, we’ll start by loading the relevant libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we must create the sample data and save it to Excel so that it can be
    used in the rest of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we must load the data from Excel and have a look at the loaded data,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we generate a synthetic time series with a linear trend, sine-wave
    seasonal component, and random noise. This kind of dataset is more representative
    of real-world time series data, where patterns often involve a combination of
    these elements. The dataset is then saved to an Excel file, and you can read it
    back into Python for analysis as needed.
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed in [*Chapter 6*](B19142_06.xhtml#_idTextAnchor119), the first
    step of analysis is plotting (insert sinister laugh)!
  prefs: []
  type: TYPE_NORMAL
- en: Time series plotting – basic plots and ACF/PACF plots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visualizing time series data is a crucial step in understanding its underlying
    patterns and trends. In this section, we’ll explore various time series plots
    and how to create them using Python. These visualizations help us gain insights
    into seasonality, trends, and autocorrelation within the time series data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start by loading the required libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we must load the data from Excel and ensure the date information is converted
    correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create a basic plot of the time series for a first look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what the plot looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 - Caption](img/B19142_10_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.9 - Caption
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we must create the more advanced ACF and PACF plots with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting plots are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10 – ACF and PACF plots for lags 1 and 2](img/B19142_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.10 – ACF and PACF plots for lags 1 and 2
  prefs: []
  type: TYPE_NORMAL
- en: Here, we started by loading the time series data from an Excel file and converting
    the **Date** column into a datetime index. Then, we created a time series plot
    to visualize the data over time. Additionally, we generated ACF and PACF plots
    to explore autocorrelation patterns within the time series. These plots are valuable
    for identifying potential lag values for time series models.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s have a look at how ACF and PACF plots help with gaining insights
    into time series data. In particular, we’ll see how they can be used to understand
    seasonality, trends, and autocorrelation.
  prefs: []
  type: TYPE_NORMAL
- en: Autocorrelation function (ACF) plot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ACF plot shows the correlation between a time series and its lagged values.
    In other words, it quantifies how well the current value of the series is correlated
    with its past values.
  prefs: []
  type: TYPE_NORMAL
- en: Peaks in the ACF plot at specific lags indicate potential seasonality or periodic
    patterns in the data. For instance, a significant peak at lag 7 in a daily series
    suggests a weekly seasonality, while a peak at lag 12 in a monthly series may
    indicate a yearly seasonality.
  prefs: []
  type: TYPE_NORMAL
- en: By analyzing the ACF plot, you can identify the lag values at which correlations
    significantly deviate from zero. These lags can provide insights into the seasonality
    of the data. Additionally, identifying exponential decay in ACF can suggest an
    autoregressive component in your time series model.
  prefs: []
  type: TYPE_NORMAL
- en: Partial autocorrelation function (PACF) plot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The PACF plot measures the direct relationship between a time series and its
    lagged values while removing the effects of intermediate lags.
  prefs: []
  type: TYPE_NORMAL
- en: Peaks in the PACF plot at specific lags indicate the number of lagged values
    that directly impact the current value of the series. For example, a significant
    peak at lag 1 and no significant peaks beyond that suggest a first-order **autoregressive**
    (**AR**) process.
  prefs: []
  type: TYPE_NORMAL
- en: The PACF plot helps in determining the order of autoregressive terms (p) in
    ARIMA models. It can also reveal abrupt changes in the time series, indicating
    structural breaks or shifts.
  prefs: []
  type: TYPE_NORMAL
- en: By analyzing these plots in conjunction with your time series data, you can
    gain valuable insights into the presence of seasonality, trends, and autocorrelation.
    These insights are instrumental in selecting appropriate time series models and
    making accurate forecasts.
  prefs: []
  type: TYPE_NORMAL
- en: The plots shown in *Figure 10**.9* show that for the PACF plot, only lag 1 has
    a strong autocorrelation, while the ACF plot is tricked by the way the random
    data was generated and shows a high autocorrelation across all lags investigated.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the insights gained from these plots, we can move on to the meat of the
    matter: statistical analysis and forecasting'
  prefs: []
  type: TYPE_NORMAL
- en: Time series statistics and statistical forecasting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data exploration and statistical analysis are crucial steps in understanding
    the characteristics of time series data. In this section, we’ll walk you through
    how to perform data exploration and apply statistical analysis techniques in Python
    to gain valuable insights into your time series.
  prefs: []
  type: TYPE_NORMAL
- en: Statistical analysis for time series data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After exploring the data using the plots in the previous section, let’s move
    on to statistical analysis to gain a deeper understanding. This section focuses
    on two areas:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Augmented Dickey-Fuller (ADF) test**: This statistical test is used to
    determine whether the time series data is stationary. Stationary data is easier
    to model and forecast.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Time series decomposition**: Time series decomposition separates the data
    into its constituent components: trend, seasonality, and residuals. This decomposition
    aids in isolating patterns for forecasting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll understand both of these in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: The ADF test
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ADF test is a statistical method that’s used to evaluate the *stationarity*
    of a time series. Stationarity is a fundamental concept in time series analysis
    as it simplifies the modeling process. A stationary time series has statistical
    properties, such as constant mean and variance, that do not change over time.
    Non-stationary data, on the other hand, exhibits trends or seasonality, making
    it challenging to model and forecast accurately.
  prefs: []
  type: TYPE_NORMAL
- en: In the ADF test, the null hypothesis (H0) assumes that the data is non-stationary.
    The alternative hypothesis (H1) suggests that the data is stationary. By analyzing
    the p-value obtained from the test, you can determine whether to reject the null
    hypothesis. A low p-value (typically less than 0.05) indicates that the data is
    stationary, while a high p-value suggests non-stationarity. Therefore, when conducting
    the ADF test, a p-value less than 0.05 is an indicator of a stationary time series.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code sample that implements the ADF test in Python using our trusty
    `statsmodels` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Not surprisingly, we failed to reject the null hypothesis as the time series
    data we generated earlier has a clear linear trend and hence it is not stationary.
  prefs: []
  type: TYPE_NORMAL
- en: 'For further insights, we can analyze the detailed output further:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11 – ADF test results](img/B19142_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.11 – ADF test results
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the result of the ADF test, as returned by `adfuller`, contains
    several components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-0.24536819384067887`, in our case) is the test statistic. This statistic
    is used to assess the null hypothesis that a unit root is present in a time series
    dataset. The more negative (or less positive) the test statistic, the stronger
    the evidence against the null hypothesis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0.9328933413659218`, in our case) is the p-value associated with the test
    statistic. It represents the probability of observing the given test statistic
    if the null hypothesis were true. A small p-value (typically less than 0.05) suggests
    rejecting the null hypothesis in favor of stationarity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`9`, in our case) represents the number of lags used in the regression when
    estimating the ADF test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`720`, in our case) represents the number of observations used in the ADF regression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dictionary**: The next part of the result is a dictionary containing critical
    values for different confidence levels (1%, 5%, and 10%). These critical values
    are used to determine the significance of the test statistic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1208.8292254446185`, in our case) is the maximized IC. It represents a measure
    of the goodness-of-fit of the model. Lower values of the IC indicate a better
    fit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, you would typically interpret the ADF test result by focusing on
    the test statistic and p-value. If the test statistic is more negative (or less
    positive) and the p-value is small (typically less than 0.05), it suggests rejecting
    the null hypothesis of a unit root and concluding that the time series is stationary.
  prefs: []
  type: TYPE_NORMAL
- en: Time series decomposition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Time series decomposition is a technique that’s used to break down a time series
    dataset into its key components: trend, seasonality, and residuals. These components
    provide valuable insights into the underlying patterns of the time series, making
    it easier to understand and forecast.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s understand each of these components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Trend**: The trend component represents the underlying long-term movement
    or tendency in the data. It captures the overall direction – that is, whether
    data is increasing or decreasing over time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Seasonality**: Seasonality refers to the repeating patterns in the data at
    fixed intervals. These could be daily, weekly, monthly, or yearly patterns, depending
    on the data. Detecting seasonality is crucial for understanding periodic trends
    and adjusting for them during forecasting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Residuals**: Residuals are the irregular or random components of the time
    series data. They represent what remains after removing the trend and seasonality.
    Analyzing residuals helps identify any leftover patterns or unusual events in
    the data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our code, we apply time series decomposition to break down the time series
    into its constituent components, and we visualize each component. This process
    allows us to understand the structure of the data, making it easier to identify
    underlying patterns for forecasting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at an implementation for time series decomposition in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting plot is self-explanatory (especially as it reflects how the data
    was artificially generated):'
  prefs: []
  type: TYPE_NORMAL
- en: /
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12 – The time series decomposed](img/B19142_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.12 – The time series decomposed
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we have covered the basic statistics that can help you understand
    your time series and the core techniques to handle the most typical challenges
    to modeling: decomposition and how to interpret the components. With a deeper
    understanding of our time series thanks to the plots provided and statistical
    analysis, we can move on to the highest value-added step: prediction.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding predictive modeling approaches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll delve into predictive modeling approaches using two powerful
    Python libraries – `statsmodels` and `prophet`.
  prefs: []
  type: TYPE_NORMAL
- en: These libraries provide diverse tools to tackle time series forecasting, enabling
    you to make informed decisions and predictions based on your time series data.
  prefs: []
  type: TYPE_NORMAL
- en: Forecasting with statsmodels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`statsmodels` is a popular library in the Python ecosystem that offers a wide
    range of statistical tools, including time series analysis. For forecasting, it
    provides functionality for building ARIMA models. ARIMA models are a staple in
    time series analysis, allowing you to capture and model complex patterns within
    your data.'
  prefs: []
  type: TYPE_NORMAL
- en: Building an ARIMA model with `statsmodels` involves selecting the appropriate
    order of differencing, autoregressive components, and moving average components
    to best represent the underlying patterns of the data. Once the model has been
    established, you can make forecasts and evaluate its performance.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it is very important to note that since the time series we have is
    not stationary, we should be modeling the changes or differences in our time series.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have a look at the workflow in code!
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the necessary libraries and load the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, check for stationarity and decide if we want to model the time series
    itself or the differences:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now (with the differenced data since our time series is not stationary), we
    can build the actual model and fit it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Optionally, we could perform some hypertuning on the order parameters instead
    of basing our decision on the graphs only. However, for this example, this will
    suffice. Hypertuning is the action of tuning the parameters defining the model
    rather than the parameters fitted to the data, such as the order of the ARIMA
    model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we can create our forecast with the trained model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that since we modeled the differenced data, we need to translate the forecasts
    back into the actual time series:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we must calculate the basic statistics and use them to calculate a confidence
    interval:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we must plot the forecast together with the original time series for
    visual evaluation of the model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The resulting plot gives us some nice insights:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.13 – The time series and the statsmodel forecast](img/B19142_10_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.13 – The time series and the statsmodel forecast
  prefs: []
  type: TYPE_NORMAL
- en: We can see that while the trend is nicely captured and some of the seasonality
    also appears, the model is too simplistic to fully capture the nature of the time
    series.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remedy this, we can use a more complex model from a dedicated time series
    library: `prophet`.'
  prefs: []
  type: TYPE_NORMAL
- en: Time series forecasting with Facebook’s prophet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The specialized `prophet` library is designed explicitly for time series forecasting
    tasks. It is known for its ease of use and extensive model selection for a wide
    variety of forecasting scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: '`prophet` provides an intuitive way to model time series data. It also features
    tools for hyperparameter optimization and forecasting evaluation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code we will use is also visibly simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must load the necessary libraries, read the Excel data in, and prepare
    it by creating a DataFrame with the columns `prophet` expects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we must customize the model a little using domain knowledge (in this
    case, coming from the fact that we generated the data this way):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we can create our forecast and plot it and its components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The resulting plot shows a much higher quality forecast than `statsmodel` with
    a tight confidence interval. The seasonality is captured visibly, along with the
    trend:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.14 – The time series and the prophet forecast](img/B19142_10_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.14 – The time series and the prophet forecast
  prefs: []
  type: TYPE_NORMAL
- en: 'To dig deeper into the model fit, let’s have a look at the components of the
    fitted time series model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.15 – The components of the time series model fitted by prophet](img/B19142_10_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.15 – The components of the time series model fitted by prophet
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, `prophet` fits a model in a very simple way without having to
    guess what the starting parameters are. You can and should use any domain knowledge
    to improve the initial model.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, we switched off the default weekly seasonality and added
    a custom annual seasonality. We can do much more if necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: We can add a custom holiday calendar, for example, using the `model.add_country_holidays(country_name='US')`
    command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can play around with change points if we are sure they are present but unsure
    exactly where
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can hypertune the Fourier order of the custom seasonality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the forecasting done with `statsmodel` and `prophet`, it’s time to wrap
    up this section and move on to the next.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you built a strong foundation in statistical analysis and forecasting
    for your time series data. These skills are crucial for understanding past trends
    and making predictions, enabling data-driven decisions and insights.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will have a look at deep learning models for time series
    analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Time series forecasting with deep learning – LSTM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will give you insights into advanced time series forecasting techniques
    using deep learning models. Whether you’re working with traditional time series
    data or more complex, high-dimensional data, these deep learning models can help
    you make more accurate predictions. In particular, we will cover the `keras`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using `keras` with a `tensorflow` backend, so you need to install
    both libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, let’s load the necessary libraries and preprocess some time series
    data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the dataset prepared, we will split it into training and testing sets
    and reshape them for LSTM input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that the data has been prepared, let’s create and train an LSTM model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code defines a simple LSTM model, compiles it, and trains it using our
    training data. You can customize the model architecture and training parameters
    as needed for your specific time series analysis. Note that the training time
    is significantly longer than with the simpler models we used in the previous section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once the model has been trained, we can make predictions and scale them back
    so that we can compare them with the original dataset:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, visualize the actual dataset and the prediction for the test set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The resulting image is quite impressive for such a small dataset and simple
    model:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.16 – The actual data (in blue) and the prediction for the test
    set (in green)](img/B19142_10_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.16 – The actual data (in blue) and the prediction for the test set
    (in green)
  prefs: []
  type: TYPE_NORMAL
- en: Remember that this is a basic example. LSTM models can be significantly more
    complex, and you might need to explore techniques such as stacked LSTMs, hyperparameter
    tuning, and more, depending on your specific time series data.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our journey into time series analysis with Python. Let’s recap
    what you have learned in this chapter!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we delved into the fascinating world of time series analysis.
    We began by exploring time series plotting, mastering essential plots, and understanding
    the significance of ACF/PACF plots.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, we ventured into time series statistics, including the ADF test,
    time series decomposition, and statistical forecasting with tools such as `statsmodels`
    and `prophet`.
  prefs: []
  type: TYPE_NORMAL
- en: To elevate our forecasting game, we embraced deep learning, employing LSTM networks
    using Python’s `keras` library. We learned to develop accurate time series forecasts
    and create insightful visualizations for data-driven insights.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter equipped us with a comprehensive set of skills for time series
    analysis, enabling us to unravel the hidden patterns and insights within time-based
    data, from plotting to statistical analysis and deep learning forecasting.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss a different integration method – that is,
    calling R and Python from Excel directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 4: The Other Way Around – Calling R and Python from Excel'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, you willl unlock the power of R and Python within Excel with comprehensive
    solutions designed for seamless integration. You will discover how to leverage
    BERT and `xlwings` for streamlined communication between Excel and your preferred
    programming language locally. You will explore open source API solutions such
    as Plumber and FastAPI, along with commercial offerings such as Posit Connect
    and ownR, to expand the capabilities of your Excel workflow with API-based integration.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B19142_11.xhtml#_idTextAnchor215), *Calling R/Python Locally
    from Excel Directly or via an API*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
