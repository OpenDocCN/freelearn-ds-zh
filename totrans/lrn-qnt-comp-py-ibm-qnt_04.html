<html><head></head><body><div><div><div><h1 class="chapterNumber">4</h1>
    <h1 id="_idParaDest-63" class="chapterTitle">Understanding Basic Quantum Computing Principles</h1>
    <p class="normal">Quantum computing, particularly its algorithms, leverages three quantum computing principles, namely, <strong class="keyWord">superposition</strong>, <strong class="keyWord">entanglement</strong>, and <strong class="keyWord">interference</strong>. In this chapter, we’ll review each of these so that we can understand what each provides, the effect it has on each qubit, and how to represent them using the quantum gate sets provided to us. The quantum computers hosted on the <strong class="keyWord">IBM Quantum Platform</strong> leverage all these principles using the various quantum gates, some of which you used earlier in this book.</p>
    <p class="normal">The following topics will be covered in this chapter:</p>
    <ul>
      <li class="bulletList">Introducing quantum computing</li>
      <li class="bulletList">Understanding superposition</li>
      <li class="bulletList">Understanding entanglement</li>
      <li class="bulletList">Understanding interference</li>
      <li class="bulletList">Exploring the Bell states</li>
    </ul>
    <h1 id="_idParaDest-64" class="heading-1">Technical requirements</h1>
    <p class="normal">In this chapter, some general knowledge of physics is recommended; however, my goal is for the explanations to help you understand the quantum principles without the need for you to register for a physics course. Here is the full source code used throughout this book: <a href="https://github.com/PacktPublishing/Learn-Quantum-Computing-with-Python-and-IBM-Quantum-Experience">https://github.com/PacktPublishing/Learn-Quantum-Computing-with-Python-and-IBM-Quantum-Experience</a>.</p>
    <h1 id="_idParaDest-65" class="heading-1">Introducing quantum computing</h1>
    <p class="normal">Quantum computing isn’t <a id="_idIndexMarker155"/>a subject that is as common as learning algebra or reading some of the literary classics. However, for most scientists and engineers or people in any other field that includes studying physics, quantum computing is part of the curriculum. Those of us who don’t quite recall our studies in physics, or have never studied it, need not worry, as this section aims to provide you with information that will either refresh your recollection of the topic or at least, perhaps, help you understand what each of the principles used in quantum computing means. Let’s start with a general definition of quantum mechanics.</p>
    <p class="normal"><strong class="keyWord">Quantum mechanics</strong>, as <a id="_idIndexMarker156"/>defined by most texts, is the study of nature at its smallest scale—in this case, the subatomic scale. The study of quantum mechanics is not new. Its growth began in the early 1900s thanks to the efforts of many physicists, whose names still chime in many of the current theories and experiments. The names of such physicists include Erwin Schrödinger, Max Planck, Werner Heisenberg, Max Born, Paul Dirac, and Albert Einstein, among others. As the years passed, many other scientists expanded on the foundations of quantum mechanics and began performing experiments that challenged many of the classical theories, theories such as the photoelectric effect as well as more modern approaches such as the wave function, which is used to provide various physical properties of a particle.</p>
    <p class="normal">One of the more popular experiments that have come out of quantum mechanics is the <strong class="keyWord">double-slit experiment</strong>. Although this is <a id="_idIndexMarker157"/>found in classical mechanics, it is referenced in quantum <a id="_idIndexMarker158"/>computing to describe the behavior of a <strong class="keyWord">quantum bit</strong> (<strong class="keyWord">qubit</strong>). It is in this experiment that researchers were able to demonstrate that light (or photons) can be characterized as both waves and particles.</p>
    <p class="normal">Many distinct experiments have been conducted over the years that illustrate this phenomenon, one of which was to fire photon particles through a double slit one at a time, where at the other side of the double slit, there was a screen that captured, as a point, the location where each particle would hit. When only one slit was open, all the particles would appear as <a id="_idIndexMarker159"/>a stack of points directly behind the slit, as shown in the following diagram:</p>
    <figure class="mediaobject"><img src="img/B18420_04_01.png" alt="Diagram, schematic  Description automatically generated" width="427" height="314"/></figure>
    <p class="packt_figref">Figure 4.1: Single-slit experiment (image source: https://commons.wikimedia.org/wiki/File:SingleSlitDiffraction.GIF)</p>
    <p class="normal">From the <a id="_idIndexMarker160"/>previous diagram, you can see that all the particles are captured in an area directly across the slit. Here, the angle theta <img src="img/_eqn_001.png" alt="" width="10" height="16"/> indicates the angle from the center of the slit (pattern) to the first minimum intensity.</p>
    <p class="normal">However, when the second slit was open, it was imagined that there would be an identical stack of points on the screen, therefore two stacks. But this was not the case, as what was captured appeared to be a formation altogether different than what would be expected from a particle. In fact, it had the characteristics of a wave in that the points on the screen seemed<a id="_idIndexMarker161"/> to display a diffraction pattern, as shown in the following diagram:</p>
    <figure class="mediaobject"><img src="img/B18420_04_02.png" alt="Diagram  Description automatically generated" width="548" height="268"/></figure>
    <p class="packt_figref">Figure 4.2: Double-slit experiment (image source: https://commons.wikimedia.org/wiki/File:Double-slit.PNG)</p>
    <p class="normal">From the previous diagram, you can see that all the particles are spread out from the center with interference gaps.</p>
    <p class="normal">This diffraction pattern is caused by the interference of the light waves passing through the slits. Here, there are more points at the center of the screen than there are toward the outer ends of the observing screen. This interference of individual particles is the basis for what is now known<a id="_idIndexMarker162"/> as <strong class="keyWord">wave-particle duality</strong>, which generally infers that photons of light can behave like both a wave and a particle. This property is used in quantum computing, particularly in algorithms such as Grover’s and Shor’s algorithms.</p>
    <div><p class="normal">This <a id="_idIndexMarker163"/>wave-particle phenomenon gave birth to lots of interesting research and development such as<a id="_idIndexMarker164"/> the <strong class="keyWord">Copenhagen interpretation</strong>, the <strong class="keyWord">many-worlds interpretation</strong>, and<a id="_idIndexMarker165"/> the <strong class="keyWord">De Broglie-Bohm</strong> theory.</p>
    </div>
    <p class="normal">What this illustrates is that the light appeared as bands of light in certain areas of the board with some probability. By observing the preceding diagram, you can see that there is a higher probability that the electron fired from the gun will land in the center band of the screen as opposed to the outer bands as illustrated by the darker shades of gray. Also, note that due to interference, the spaces in between the bands that capture the electrons have less probability (blank areas between bands).</p>
    <p class="normal">It is these effects of wave interference and probabilities that we will cover in this chapter, but first, we will start with the electron itself to understand superposition.</p>
    <h1 id="_idParaDest-66" class="heading-1">Understanding superposition</h1>
    <p class="normal"><strong class="keyWord">Superposition</strong> is<a id="_idIndexMarker166"/> something we generally can’t see with the naked eye. It’s defined as a combination of two similar yet distinct phenomena occurring at once: for example, being able to whistle and hum at the same time. Both are the same in that they are audible waves but distinct in how they sound. You can whistle without humming, and vice versa; however, doing them both at the same time is placing them in a superposition as you are creating a combination of both distinct sounds at the same time.</p>
    <p class="normal">In quantum mechanics, we are typically discussing the superposition of an electron. Since an electron is very small and there are so many of them, it is hard to distinguish one with even a powerful microscope. It is commonly referred to as an elementary particle. There are, however, some analogies in the classical world that we can use to illustrate what superposition is. For example, a spinning coin is what most texts use to describe superposition. </p>
    <p class="normal">While it is spinning, we can say that it is in the state of both heads and tails. It isn’t until the coin collapses that we see what the final state of the coin is. This explains<a id="_idIndexMarker167"/> superposition from a probability perspective; however, the formal definition is commonly found in any classical physics book when describing the spin of an electron. I will leave this for you to search for as there are lots of references and resources available online that go into detail.</p>
    <p class="normal">In this chapter, we’re going to use this spinning coin analogy just to help you understand the general principle of superposition. However, once we start working on our quantum circuits, you will see some of the differences between superposition and its probabilistic behavior in the classical world versus its behavior in the quantum world.</p>
    <p class="normal">Let’s start by reviewing the random effects we saw in the slit experiments in the classical world.</p>
    <h2 id="_idParaDest-67" class="heading-2">Learning about classical randomness</h2>
    <p class="normal">Previously, we discussed the<a id="_idIndexMarker168"/> randomness of a spinning coin as an example. However, the spinning coin and its results are not as random as we think. Just because we cannot guess the correct answer when a coin is spun on a table or flipped in the air does not make it random. What leads us to believe that it’s random is the fact that we don’t have all the information necessary to know or predict or, in fact, determine that the coin will land on either heads or tails.</p>
    <p class="normal">All the relevant information, such as the weight of the coin, its shape, the amount of force required to spin the coin, the air resistance, the friction of the platform the coin is rolling on, and so on, as well as the information of the environment itself, is not known to us in order for us to determine what the outcome would be after spinning a coin. It’s because of this lack of information that we assume the spinning of the coin is random. If we had some function that could calculate all this information, then we would always successfully determine the outcome of the spinning coin.</p>
    <p class="normal">The same can be said about random number generators. As an example, when we trigger a computer to generate a random number, the computer uses a variety of information to calculate and generate a so-called random number. These parameters can include information such as the current daytime that the request was triggered, information about the user or the system itself, and so on.</p>
    <p class="normal">These types of random number<a id="_idIndexMarker169"/> generators are often referred to as <strong class="keyWord">pseudorandom number </strong>(<strong class="keyWord">PSRN</strong>) <strong class="keyWord">generators</strong> or <strong class="keyWord">deterministic random bit (DRB) generators</strong>. They<a id="_idIndexMarker170"/> are only as random as the calculation or seed values provided that are allowed. For example, if we knew the parameters used and how they were used to generate this random number, then we would be able to determine the generated random number every time.</p>
    <p class="normal">Now I don’t want you to worry about anyone determining the calculations or cryptographic keys that you may have generated. We use these PSRN generators because of the precision and granularity that they encompass to generate this number, which is such that any deviation can drastically alter the results.</p>
    <p class="normal"><em class="italic">So, why bother reviewing the probabilistic and random nature of a spinning coin?</em> One, it’s to explain the difference between randomness, or what we believe is random, in the classical world versus randomness in the quantum world. Two, at some point we will need to leave any form of classical analogy and accept the fact that the quantum behavior is not obvious nor easily measured. If you wish to get a deeper understanding of these phenomena, which we cannot easily describe using classical physics or analogies, I recommend<a id="_idIndexMarker171"/> about reading the <strong class="keyWord">Heisenberg uncertainty principle</strong>.</p>
    <p class="normal">In the classic world, we learned <a id="_idIndexMarker172"/>that if we had all the information available, we can more than likely determine an outcome. However, in the previous section, where we described the double-slit experiment, we saw that we couldn’t determine where on the screen the electron was going to hit. We understood the probabilities of where it would land based on our experiment. But even then, we could not deterministically identify where precisely the electron was going to land on the screen. You’ll see an example of this when we create our superposition circuit in the next section.</p>
    <p class="normal">For those who wish to learn a little more about this photonic phenomenon, I would suggest reading the book by the famous physicist Richard Feynman titled <em class="italic">QED: The Strange Theory of Light and Matter</em>.</p>
    <h2 id="_idParaDest-68" class="heading-2">Preparing a qubit in a superposition state</h2>
    <p class="normal">In this section, we <a id="_idIndexMarker173"/>are going to create a<a id="_idIndexMarker174"/> circuit with a single qubit and set an operator on the qubit to set it in a superposition state. But before we do that, let’s quickly define what a superposition state is.</p>
    <p class="normal">We define the qubit as having two basis energy states, one of which is the ground (0) state and the second of which is the excited (1) state, as illustrated in <em class="italic">Figure 4.3</em>. The state value name of each basis state could be anything we choose, but since the results from our circuit will be fed back to a classic system, we will use binary values to define our states—in this case, the binary values 0 and 1. To say that the superposition of two states is <em class="italic">being in both 0 and 1 at the same time</em> is incorrect. The proper way to state that a qubit is in a superposition state is to say that it is <em class="italic">in a complex linear combination of states where, in this case, the states are 0 and 1</em>.</p>
    <p class="normal">A simple analogy of this is to perhaps think of a bit as a standard light switch. In one position the light is on, in the other position the light is off. It’s either one or the other. This is analogous to a bit, either <em class="italic">0</em> or <em class="italic">1</em> (Off or On, respectively). Now consider a light dimmer switch (technically, a rheostat) where the switch can be rotated to the On position and then rotated all the way down to the Off position. What you can also do with a dimmer is slide the switch to anyplace in between off and on, this in turn adjusts the intensity, or amplitude, of the amount of light emitted. Now, when you have the dimmer in between the On and Off position, you don’t say the light is “On and Off at the same time” do you? Of course not. It is more of a combination of the two. Keep in mind of course, this is not the definition of a qubit, it’s just a simple example of why saying something is two things at once is not entirely correct.</p>
    <p class="normal">Visualizing the state of a qubit is generally difficult, particularly multi-qubit states, which involve more than one qubit and multiple quantum states. One of the earlier visualization models developed was the 2-state sphere that provided a geometrical representation of a 2-level quantum mechanical system called<a id="_idIndexMarker175"/> the <strong class="keyWord">Bloch sphere</strong>. The following figure is an example of a Bloch sphere, which represents a single qubit and its two orthogonal basis states, which are located on opposite poles. On the north pole, we have the basis state <img src="img/B18420_04_006.png" alt="" width="23" height="25"/><a id="_idIndexMarker176"/>, while on the south pole, we have the basis state <img src="img/B18420_04_007.png" alt="" width="23" height="25"/><a id="_idIndexMarker177"/>. The symbols surrounding the basis state values are the commonly used notations in most quantum computing text. This is <a id="_idIndexMarker178"/>called <strong class="keyWord">Dirac notation</strong>, which was named after the English theoretical physicist Paul Dirac, who first conceived the notation, which he called<a id="_idIndexMarker179"/> the <strong class="keyWord">Bra-Ket notation</strong>. Bra-Ket and Dirac notation are generally used interchangeably as they refer to the same thing, as we’ll see later. Each has its unique form as follows, <strong class="keyWord">Bra</strong> has the <a id="_idIndexMarker180"/>following form, <img src="img/_eqn_004.png" alt="" width="21" height="25"/><a id="_idIndexMarker181"/>, and <strong class="keyWord">Ket</strong> has the following<a id="_idIndexMarker182"/> form, <img src="img/B18420_04_006.png" alt="" width="23" height="25"/><a id="_idIndexMarker183"/>, where each denotes a mathematical <em class="italic">linear form</em> and <em class="italic">vector</em>, respectively.</p>
    <figure class="mediaobject"><img src="img/B18420_04_03.png" alt="Figure 4.3 - Two basis states of a qubit on a Bloch sphere " width="195" height="221"/></figure>
    <p class="packt_figref">Figure 4.3: Two basis states of a qubit on a Bloch sphere</p>
    <p class="normal">OK, so let’s <a id="_idIndexMarker184"/>stop talking, and let’s start <a id="_idIndexMarker185"/>coding. We’re going to create a quantum circuit with a single qubit. We will then execute the circuit so that we can obtain the same result we can see in the preceding screenshot, which is the initial state of the qubit, state <img src="img/B18420_04_006.png" alt="" width="23" height="25"/><a id="_idIndexMarker186"/>.</p>
    <p class="normal">Before we get started, let’s first import the helper file into your working directory. It contains a series of functions that will help us in two ways. First, it will provide a series of functions we can use to quickly get us started to execute circuits without having to cover any details just yet. But not to worry, you will learn the details as we progress throughout the book, and the dependency of the helper file will surely disappear. Second, this will also help keep the code base up to date as new features and changes happen, so that updates can be made to keep code running far beyond the current version. The location of the helper file is in the GitHub repo linked at the beginning of this chapter, titled <code class="inlineCode">helper_file_1.0.ipynb</code>. Be aware that you may need to set up your account if you want to use a quantum system and not the local simulators on your device. If so, please open the <code class="inlineCode">setup_save_account.ipynb</code> file and enter your API token in the specified attribute and run the file. Once you do, that will save your API on your local machine, so you won’t have to set up each time.</p>
    <p class="normal">Open a new Qiskit Notebook and enter the following code into the next empty cell:</p>
    <pre class="programlisting code"><code class="hljs-code"># Load helper file
%run helper_file_1.0.ipynb
# Create a simple circuit
qc = QuantumCircuit(1,1)
# Get the state vector of the circuit
stateVectorResult = Statevector(qc)
# Display the state vector results onto a Bloch sphere
plot_bloch_multivector(stateVectorResult)
</code></pre>
    <p class="normal">The first line will load the helper file into the working notebook. The file contains functions that we will use to import the functions and libraries we need to get started, such as those needed for executing circuits on simulators and backend systems and returning the results of our circuits. The next line creates a quantum circuit that includes <code class="inlineCode">1</code> qubit and 1 classical bit, and in the next line we will pass the quantum circuit to the <code class="inlineCode">Statevector</code> object, which will generate the state vector of the quantum circuit. This will return the resulting object, which will contain the state vector results. Finally, we display the results on a Bloch sphere, which should display what you saw in <em class="italic">Figure 4.3</em>.</p>
    <p class="normal">Each qubit, as mentioned earlier, is made up of two basis states, which, in this example, reside on opposite poles of the Bloch sphere. These two basis states are what we would submit back to the classical system as our result—either one or the other. The vector representing these two points originates from the origin of the Bloch sphere, as you can see in the previous diagram or the result from your experiment. If we were to notate this as a vector, we <a id="_idIndexMarker187"/>would write the<a id="_idIndexMarker188"/> following:</p>
    <p class="center"><img src="img/B18420_04_002.png" alt="" width="83" height="42"/><a id="_idIndexMarker189"/></p>
    <p class="normal">Since the opposite would apply to the opposite pole, we would notate it as follows:</p>
    <p class="center"><img src="img/B18420_04_003.png" alt="" width="79" height="40"/><a id="_idIndexMarker190"/></p>
    <p class="normal">From observing the vector values, you can see that flipping the values of the vector is like a classical bit flip. Now that we understand the vector representation of a qubit, let’s continue and set the qubit in a superposition state:</p>
    <ol>
      <li class="numberedList" value="1">Insert a new cell at the bottom of the current notebook and enter the following code:
        <pre class="programlisting code-one"><code class="hljs-code"># Place the qubit in a superposition state
# by adding a Hadamard (H) gate
qc.h(0)
# Draw the circuit
qc.draw(output='mpl')
</code></pre>
        <ul>
          <li class="bulletList">The first line places a <strong class="keyWord">Hadamard (H)</strong> gate onto the first qubit, identified by the qubit’s index value (<code class="inlineCode">0</code>). It then calls the <code class="inlineCode">draw()</code> function, which will draw the circuit diagram; note that the <code class="inlineCode">output</code> parameter is added just to get a nicer output. If you would like to include these visualization features, be sure to install <code class="inlineCode">qiskit[visualization]</code> from pip (<code class="inlineCode">pip install qiskit[visualization]</code>). Otherwise, you can remove the parameter and get standard text visualization outputs.</li>
        </ul>
      </li>
    </ol>
    <p class="normal-one">After running the previous cell, you should see the following circuit image, which represents adding the Hadamard gate to the qubit and the classical bit just below:</p>
    <figure class="mediaobject"> <img src="img/B18420_04_04.png" alt="A diagram of a square with a blue square and black text  Description automatically generated" width="163" height="159"/></figure>
    <p class="packt_figref">Figure 4.4: Circuit with a Hadamard (H) gate added to a qubit</p>
    <p class="normal-one">The <strong class="keyWord">Hadamard gate</strong> (H gate) is a <a id="_idIndexMarker191"/>quantum gate that places the qubit in a superposition state, or, more specifically, a complex linear combination of the basis states, which means that when we measure the qubit, it will have an equal probability result of measuring a 0 or 1. Or in other words, it would collapse to one of the basis state values of <img src="img/B18420_04_006.png" alt="" width="23" height="25"/><a id="_idIndexMarker192"/> or <img src="img/B18420_02_003.png" alt="" width="23" height="25"/><a id="_idIndexMarker193"/>.</p>
    <p class="normal-one">Mathematically, the<a id="_idIndexMarker194"/> superposition <a id="_idIndexMarker195"/>state is obtained with the application of the Hadamard gate, and its results are represented in the following two superposition equations, which, as you can see, depends on which of the two basis states, <img src="img/B18420_04_006.png" alt="" width="23" height="25"/><a id="_idIndexMarker196"/> or <img src="img/B18420_04_007.png" alt="" width="23" height="25"/><a id="_idIndexMarker197"/>, it was in prior to applying the Hadamard gate. The first superposition equation <img src="img/B18420_04_008.png" alt="" width="25" height="25"/><a id="_idIndexMarker198"/> is as follows and originates from the <img src="img/B18420_04_006.png" alt="" width="23" height="25"/><a id="_idIndexMarker199"/> state, which is often referred to as the positive <img src="img/B18420_04_010.png" alt="" width="29" height="25"/><a id="_idIndexMarker200"/> superposition state:</p>
    <p class="center"><img src="img/B18420_04_011.png" alt="" width="131" height="52"/><a id="_idIndexMarker201"/></p>
    <p class="normal-one">The second superposition equation <img src="img/B18420_04_012.png" alt="" width="25" height="25"/><a id="_idIndexMarker202"/>, originating from the <img src="img/B18420_02_003.png" alt="" width="23" height="25"/><a id="_idIndexMarker203"/> state, is as follows, which is often referred to as the negative <img src="img/B18420_04_014.png" alt="" width="29" height="25"/><a id="_idIndexMarker204"/> superposition state:</p>
    <p class="center"><img src="img/B18420_04_015.png" alt="" width="131" height="52"/><a id="_idIndexMarker205"/></p>
    <p class="normal-one">Visually, on the Bloch sphere, this is equal to a π⁄2 rotation about the <em class="italic">X</em> and <em class="italic">Z</em> axes of the Bloch sphere. These rotations are Cartesian rotations, which rotate counterclockwise around the specified axis, in this case, the <em class="italic">X</em> and <em class="italic">Z</em> axes.</p>
    <ol>
      <li class="numberedList" value="2">Now, let’s get the state vector of our circuit, and see what the resulting quantum state will look like, and where the state vector lands on the Bloch sphere. In the following code, you will call the <code class="inlineCode">Statevector</code> object and pass the quantum circuit into the <code class="inlineCode">constructor</code> argument, the result of which will change the state of the qubit to a superposition state from the initial state, which you will see in the resulting Bloch sphere’s output:
        <pre class="programlisting code-one"><code class="hljs-code"># Get the state vector of the circuit
stateVectorResult = Statevector(qc)
# Display the Bloch sphere
plot_bloch_multivector(stateVectorResult)
</code></pre>
      </li>
    </ol>
    <p class="normal-one">You should now <a id="_idIndexMarker206"/>see the results <a id="_idIndexMarker207"/>plotted on the Bloch sphere in a superposition of <img src="img/B18420_04_006.png" alt="" width="23" height="25"/><a id="_idIndexMarker208"/> and <img src="img/B18420_02_003.png" alt="" width="23" height="25"/><a id="_idIndexMarker209"/>, as illustrated in the following figure:</p>
    <figure class="mediaobject"><img src="img/B18420_04_05.png" alt="Figure 4.5 - Superposition of a qubit after 90° rotation around the X and Z axes  " width="205" height="227"/></figure>
    <p class="packt_figref">Figure 4.5: Superposition of a qubit after 90° rotation of the <img src="img/B18420_04_006.png" alt="" width="23" height="25"/><a id="_idIndexMarker210"/> basis state</p>
    <p class="normal-one">As you can see in the preceding screenshot, this has placed the vector on the positive <em class="italic">X</em> axis, as described previously when adding an H gate from the <img src="img/B18420_04_006.png" alt="" width="23" height="25"/><a id="_idIndexMarker211"/> basis state. One thing to note is that visually, this could also have been done by rotating the <em class="italic">Y</em> axis by 90 degrees.</p>
    <ol>
      <li class="numberedList" value="3">Now, let’s clear the circuit by recreating the <code class="inlineCode">QuantumCircuit</code> object with the same name. This time, we will initialize the qubit to the <img src="img/B18420_02_003.png" alt="" width="23" height="25"/><a id="_idIndexMarker212"/> state first and then apply a Hadamard gate to see what happens to the vector. Initialize the <code class="inlineCode">qubit</code> to the <img src="img/B18420_04_006.png" alt="" width="23" height="25"/><a id="_idIndexMarker213"/> state and place it in a superposition. Clear the circuit and initialize the qubit to <code class="inlineCode">1</code> before applying a Hadamard gate:
        <pre class="programlisting code-one"><code class="hljs-code">#Reset our quantum circuit
qc = QuantumCircuit(1)
#Rotate the qubit from 0 to 1 using the X (NOT) gate
qc.x(0)
#Add a Hadamard gate
qc.h(0)
#Draw the circuit
qc.draw(output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">You should now see the following circuit; in this case, we have omitted the classical bit when<a id="_idIndexMarker214"/> constructing our quantum circuit, which is why you do not see the classical bit <a id="_idIndexMarker215"/>in the following figure:</p>
    <figure class="mediaobject"><img src="img/B18420_04_06.png" alt="Figure 4.6 - Applying an H gate superposition from an opposite base state  " width="278" height="58"/></figure>
    <p class="packt_figref">Figure 4.6: Applying an H gate superposition to the base state <img src="img/B18420_02_003.png" alt="" width="23" height="25"/><a id="_idIndexMarker216"/></p>
    <ol>
      <li class="numberedList" value="4">Now, let’s execute the circuit and plot the result on the Bloch sphere using the same code you used to execute the previous circuit:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18420_04_07.png" alt="Figure 4.7 - Superposition of a qubit after 90° rotation around the X and Z axes from the  state " width="207" height="250"/></figure>
    <p class="packt_figref">Figure 4.7: Superposition of a qubit after 90° rotation around the X and Z axes from the <img src="img/B18420_02_003.png" alt="" width="23" height="25"/><a id="_idIndexMarker217"/> state</p>
    <p class="normal-one"><em class="italic">Do you see the difference between adding an H gate to a qubit in the <img src="img/B18420_04_006.png" alt="" width="23" height="25"/></em><em class="italic"><a id="_idIndexMarker218"/></em> <em class="italic">state (Figure 4.5) and adding it to a qubit in the</em> <img src="img/B18420_02_003.png" alt="" width="23" height="25"/><a id="_idIndexMarker219"/> <em class="italic">state in the preceding figure?</em></p>
    <p class="normal-one">Of course, the<a id="_idIndexMarker220"/> difference is where it lands on the <em class="italic">X</em> axis! Because the vector falls onto the positive <em class="italic">X</em> axis when applying a Hadamard gate to the <img src="img/B18420_04_006.png" alt="" width="23" height="25"/><a id="_idIndexMarker221"/> state, this is commonly notated as <img src="img/B18420_04_008.png" alt="" width="25" height="25"/><a id="_idIndexMarker222"/>. This logically means that the vector falls onto the negative <em class="italic">X</em> axis when applying a Hadamard gate to the <img src="img/B18420_02_003.png" alt="" width="23" height="25"/><a id="_idIndexMarker223"/> state. This is commonly notated as <img src="img/B18420_04_012.png" alt="" width="25" height="25"/><a id="_idIndexMarker224"/>.</p>
    <p class="normal-one">Now, look at the <a id="_idIndexMarker225"/>right side of the superposition equations and pay close attention to the signs in between:</p>
    <p class="center"><img src="img/B18420_04_011.png" alt="" width="131" height="52"/><a id="_idIndexMarker226"/></p>
    <p class="center"><img src="img/B18420_04_015.png" alt="" width="131" height="52"/><a id="_idIndexMarker227"/></p>
    <p class="normal-one">Notice that the signs match the direction of where the vector lands after the Hadamard gate is applied. From the <img src="img/B18420_04_006.png" alt="" width="23" height="25"/><a id="_idIndexMarker228"/> state, it moves toward the positive (+) direction of the <em class="italic">X</em> axis, and from the <img src="img/B18420_02_003.png" alt="" width="23" height="25"/><a id="_idIndexMarker229"/> state, it moves toward the negative (-) direction of the <em class="italic">X</em> axis.</p>
    <p class="normal-one">This difference is referred to as a phase difference between the two results. This will be very important later in this and subsequent chapters, as phase difference plays an important role in many quantum algorithms and blends itself into the topic of interference, as we will learn shortly.</p>
    <p class="normal-one">One last thing that we will discuss before moving on is to now look back to our earlier discussion on probabilities. Now that we’ve learned what superposition looks like in a circuit and on a Bloch sphere, let’s execute and see what the probabilities are when we measure the qubit after it is in superposition. As you may recall from our first analogy of flipping or spinning a coin, we said that once the coin is spinning, it is in a superposition of heads or tails, or in this example, 0 or 1.</p>
    <p class="normal-one">Once we observe the outcome, the result of the coin will be one or the other. However, classically, this is pseudorandom, as we learned. But in quantum computing, electron detection is truly random as there is no way to determine its outcome without<a id="_idIndexMarker230"/> disturbing it due to the <strong class="keyWord">Heisenberg uncertainty principle</strong>.</p>
    <div><p class="normal">The <strong class="keyWord">Heisenberg uncertainty principle</strong>, introduced by<a id="_idIndexMarker231"/> Werner Heisenberg in 1927, describes how it is not possible to predict the <em class="italic">momentum</em> of a particle from its initial conditions if the <em class="italic">position</em> is more precisely determined. The same is said for the reverse, where it is not possible to predict the position of a particle from its initial conditions if the momentum is more precisely determined.</p>
    </div>
    <p class="normal-one">This is the same as measuring a qubit; we are, in essence, measuring it, and therefore forcing it to collapse into one of two basis states.</p>
    <ol>
      <li class="numberedList" value="5">Then, measure the <a id="_idIndexMarker232"/>qubit after it is <a id="_idIndexMarker233"/>in superposition and recreate the circuit. Let’s start from the <img src="img/B18420_04_006.png" alt="" width="23" height="25"/><a id="_idIndexMarker234"/> state and apply a Hadamard gate, as we did earlier:
        <pre class="programlisting code-one"><code class="hljs-code"># Recreate the circuit with a single qubit and classical bit
qc = QuantumCircuit(1,1)
# Add a Hadamard gate
qc.h(0)
</code></pre>
      </li>
      <li class="numberedList">Now, using our helper function, let’s create a circuit that includes a measurement operator so that we can measure the qubit, which will collapse into one of two states, as follows:
        <pre class="programlisting code-one"><code class="hljs-code"># Create a measurement circuit with 1 qubit and 1 bit
measurement_circuit = create_circuit(1,True)
# Concatenate the circuits together
full_circuit = qc.compose(measurement_circuit)
# Draw the full circuit
full_circuit.draw(output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">In the previous code, we created a measurement circuit that includes a measurement operation that basically collapses the qubit from its current state to that of either 0 or 1. The second line of the code then concatenates the first circuit <code class="inlineCode">qc</code> and this new <code class="inlineCode">measurement_circuit</code> together, creating a new circuit called <code class="inlineCode">full_circuit</code> which will be drawn as follows:</p>
    <figure class="mediaobject"><img src="img/B18420_04_08.png" alt="Figure 4.8 - Full circuit with rotation and measurement from qubit (q) to classic bit (c) " width="269" height="133"/></figure>
    <p class="packt_figref">Figure 4.8: Full circuit with rotation and measurement from qubit (q) to classic bit (c)</p>
    <p class="normal-one">The previous <a id="_idIndexMarker235"/>diagram illustrates <a id="_idIndexMarker236"/>our full circuit, which you can see now includes two new components, the first of which is the classic register below the quantum register. The second component is the measurement operator, which will extract the result of the qubit and pass it onto the classical bit. The result will collapse the state of the qubit to either 1 or 0.</p>
    <ol>
      <li class="numberedList" value="7">Now, let’s run this circuit to see what results we get back. We will add a few <code class="inlineCode">shots</code> and see the results. <code class="inlineCode">Shots</code> refer to running through the experiment a few times and aggregating its results. We’ll use our helper file to help us run this circuit:
        <pre class="programlisting code-one"><code class="hljs-code"># Run the quantum circuit and obtain results
transpiled_QC, result, stateVectorResult = simulate_on_sampler(full_circuit, None, None)
counts = result[0].data.c.get_counts()
print(counts)
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The previous code will now use a different backend from our helper file, the <code class="inlineCode">BasicSimulator</code> rather than the <code class="inlineCode">Statevector</code>, which will allow us to obtain the measured results of the circuit. In this case, we will extract <code class="inlineCode">counts</code>, which stores the number of times the measurement resulted in either a 0 or 1 out of <code class="inlineCode">1024</code> <code class="inlineCode">shots</code>.</p>
    <p class="normal-one">The result of the previous code is as follows:</p>
    <pre class="programlisting code-one"><code class="hljs-code">{'1': 478, '0': 546}
</code></pre>
    <p class="normal-one">Notice that the results are almost 50%, which illustrates that you can have an equal probability of landing on either the 0 or 1 state for each shot!</p>
    <div><p class="normal">Note that your actual value results might be different than what was shown previously, but the probability should be close to 50%. Retry running the code a few times and play around with the number of <code class="inlineCode">shots</code> to see if you get any differences. The limitation for <code class="inlineCode">shots</code> can be found in the <code class="inlineCode">max_shots</code> value for each simulator and quantum system’s properties.</p>
    </div>
    <p class="normal">The reason why we <a id="_idIndexMarker237"/>run so many shots of a circuit is to<a id="_idIndexMarker238"/> get enough measurements to obtain accurate statistics of a measurement operation on a superposition state that is probabilistic. The noise in the system contributes to the deviation from a perfect statistic of 50/50 in the counts, because the near-term quantum devices used these days are not fault-tolerant yet. Fault-tolerant devices are those that have logical qubits, which can comprise one or more physical qubits, and are used to minimize errors so that operations complete as specified by the quantum circuits. They exhibit very low error rates and large quantum volumes, which we will cover in <em class="chapterRef">Chapter 9</em>, <em class="italic">Optimizing and Visualizing Circuits</em>. Current near-term devices need to run multiple shots to provide your quantum algorithm with good probabilistic results.</p>
    <h2 id="_idParaDest-69" class="heading-2">Building a coin-flipping experiment</h2>
    <p class="normal">If you’ve ever taken a<a id="_idIndexMarker239"/> course in probability and statistics, you might have seen the coin flip example. In this example, you are given an unbiased coin to flip multiple times and track the results of each flip (experiment) as either heads or tails. What this experiment illustrates is that with an unbiased coin and enough samples, you will see that the probability of either heads or tails starts to converge to about 50%.</p>
    <p class="normal">This means that, after running enough experiments, the number of times the coin lands on heads becomes very closely equal to the number of times that it lands on tails.</p>
    <p class="normal">Let’s give this a try in the IBM Quantum Composer, to better visualize what’s happening (note, backend systems might not be available or the same, so use any backend you see available. Like most of the backends throughout this book, we’ll be using those that were available at the time of writing this:</p>
    <ol>
      <li class="numberedList" value="1">Open the <a id="_idIndexMarker240"/>Composer Editor and create a new blank circuit.</li>
      <li class="numberedList">For simplicity, let’s remove all except one qubit. This will simplify our results.</li>
      <li class="numberedList">Click and drag the Hadamard gate onto the first qubit.</li>
      <li class="numberedList">Click and drag the measurement operation onto the first qubit after the H gate. This will indicate that you wish the value of this qubit to be measured, and assign its resulting value of either 1 or 0 to the corresponding classic bit; in this case, the bit at position 0, as shown in the following screenshot:</li>
    </ol>
    <figure class="mediaobject"> <img src="img/B18420_04_09.png" alt="A picture containing schematic  Description automatically generated" width="756" height="584"/></figure>
    <p class="packt_figref">Figure 4.9: Coin flip experiment</p>
    <ol>
      <li class="numberedList" value="5">Name<a id="_idIndexMarker241"/> your circuit <code class="inlineCode">Coin flip</code> and save it.</li>
      <li class="numberedList">Click <strong class="screenText">Setup and run</strong> to expand the options.</li>
      <li class="numberedList">Select a backend device and set the run count to <code class="inlineCode">1024</code>. This will run the experiment 1,024 times. Note at the time of this writing there are some changes occurring which might change how to run a circuit using Composer. If so, please refer to the instructions on the platform for any changes.</li>
      <li class="numberedList">Click <strong class="screenText">Run on ‘device selected’</strong>.</li>
      <li class="numberedList">Once completed, click on the completed experiment in the <strong class="screenText">Composer jobs</strong> list.</li>
    </ol>
    <p class="normal">The measurement outcome results will now show two different states. Remember that the Computational basis states are represented along the <em class="italic">X</em> axis, which you can see is either a 0 or 1:</p>
    <figure class="mediaobject"><img src="img/B18420_04_10.png" alt="Bar chart  Description automatically generated with medium confidence" width="351" height="580"/></figure>
    <p class="packt_figref">Figure 4.10: Coin flip results</p>
    <p class="normal">Another <a id="_idIndexMarker242"/>thing to note is the <code class="inlineCode">Frequency</code> (the <em class="italic">X</em> axis) of each of the two states. This will differ each time you run the experiment as it represents how many times the outcome was either 0 or 1 for each shot.</p>
    <p class="normal">What you will notice from the preceding screenshot is that the results will fall close to 50% each time you run the experiment. Rerun the experiment a few more times and examine the results for yourself. The use of the Hadamard gate allows you to place a qubit on a circuit into a linear combination of the two basis states, 0 and 1. As mentioned earlier, this helps to leverage superposition.</p>
    <h1 id="_idParaDest-70" class="heading-1">Understanding entanglement</h1>
    <p class="normal">The second quantum computing principle used by quantum computers <a id="_idIndexMarker243"/>is <strong class="keyWord">entanglement</strong>. By entangling two or more qubits, we are, in essence, linking the value of one qubit and synchronizing it with one or more other qubits. By synchronizing it, we mean that if we measure (observe) the value of one of the entangled qubits, then we can be sure that the other qubit will have the same value, whether we measure it at the same time or sometime later.</p>
    <p class="normal"><strong class="keyWord">Entanglement</strong> is probably one of the most interesting of the three quantum computing principles. This is mainly because it still baffles physicists to this day, with many taking different philosophical sides in the discussion. I won’t bore you with the details, but I will aim to provide you with enough information for you to understand what entanglement is, but not to have a way to prove it to create quantum algorithms and applications. Yes, it sounds confusing, but believe me, the devil is in the detail and there just isn’t enough space for us to formulate a comprehensive answer to how entanglement works. But enough of that—let’s get to work!</p>
    <p class="normal">Quantum entanglement, or just entanglement, is simply defined as a quantum mechanical phenomenon that occurs when two or more particles have correlated states. What this, in essence, means is that if you have two particles or, for our purposes, qubits, that are entangled, this means that when we measure one qubit, we can determine the result of the other qubit based on the measurement of the first qubit.</p>
    <p class="normal">As you may recall from our previous example, if we put a qubit in a superposition and we measure that qubit, we have a 50/50 split as to whether that qubit would collapse to either of two states, <img src="img/B18420_04_006.png" alt="" width="23" height="25"/><a id="_idIndexMarker244"/> or <img src="img/B18420_02_003.png" alt="" width="23" height="25"/><a id="_idIndexMarker245"/>.</p>
    <p class="normal">Now, if that same qubit were entangled with another qubit and we were to measure one of the qubits, that qubit will be either <img src="img/B18420_04_006.png" alt="" width="23" height="25"/><a id="_idIndexMarker246"/> or <img src="img/B18420_02_003.png" alt="" width="23" height="25"/><a id="_idIndexMarker247"/>. However, if we were to measure the second qubit, either at the exact same time or sometime later, it too will have the same value as the first qubit we measured!</p>
    <div><p class="normal">One thing to note is that this can also be the opposite if you so choose it to be. For example, let’s say you set the second qubit to the <img src="img/B18420_04_039.png" alt="" width="21" height="25"/><a id="_idIndexMarker248"/> state prior to entangling. You have now entangled opposite states. These combinations of entangled states will be covered in more detail when we discuss quantum algorithms in <em class="italic">Chapter 12, Applying Quantum Algorithms</em>.</p>
    </div>
    <p class="normal">You’re probably thinking,<em class="italic"> how can this be?</em> If we take two qubits and place them in superposition and we measure them separately, we will correctly see that each qubit will collapse to a value of 1 or 0, where each time we measure the qubits individually, it may not collapse to the same value at the same time. This means that if we run the experiment one shot at a time, we would see that, sometimes, the first qubit will measure 0, while the second qubit could measure 0 or 1.</p>
    <p class="normal">Both are separate and <a id="_idIndexMarker249"/>do not know the value of each other either before, during, or after measurement. However, if we were to entangle the two qubits and repeat the same experiment, we would see that the qubits will measure the exact same values each time! Each will result in one of four different outcomes of either 00, 11, 01, or 10. Each of these four is based on what is known as the Bell states, which will be covered later in the chapter.</p>
    <p class="normal"><em class="italic">Impossible</em>, you say? Well, it’s a good thing for us that we now have a quantum computer that we can run and try this out!</p>
    <h2 id="_idParaDest-71" class="heading-2">Implementing the behavior of entangled qubits</h2>
    <p class="normal">In the following code, we will <a id="_idIndexMarker250"/>see that when qubits are not entangled, their results are such that we cannot infer what the result of one qubit would be based on the result of the other qubit. Since we are measuring two qubits, our results will be listed as two-bit values:</p>
    <ol>
      <li class="numberedList" value="1">First, we’ll create a<a id="_idIndexMarker251"/> new circuit with two qubits, place them each in superposition, and measure them:
        <pre class="programlisting code-one"><code class="hljs-code">#Create a circuit with 2 qubits and 2 classical bits
qc = QuantumCircuit(2,2)
#Add an H gate to each
qc.h(0)
qc.h(1)
#Measure the qubits to the classical bit
qc.measure([0,1],[0,1])
#Draw the circuit
qc.draw(output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">In the preceding code, we created a quantum circuit with two qubits, added an H gate to each of the qubits so that we can place each qubit into a superposition state, and finally, added a measurement from each qubit to its respective bit.</p>
    <p class="normal-one">The result from the previous code should display the following circuit, where we can see that each qubit has an H gate that’s measured to its respective classical bit register; that is, qubit 0 to bit 0 and qubit 1 to bit 1:</p>
    <figure class="mediaobject"><img src="img/B18420_04_11.png" alt="Figure 4.9 - Two qubits in superposition and measured to their respective classic bits  " width="328" height="199"/></figure>
    <p class="packt_figref">Figure 4.11: Two qubits in superposition and measured to their respective classic bits</p>
    <ol>
      <li class="numberedList" value="2">Then, we execute the circuit and display the results:
        <pre class="programlisting code-one"><code class="hljs-code"># Run the quantum circuit
transpiledQC, result, stateVectorResult = simulate_on_sampler(qc, None, None)
#Obtain the results and display on a histogram
counts = result[0].data.c.get_counts()
plot_histogram(counts)
</code></pre>
      </li>
    </ol>
    <p class="normal-one">In the previous <a id="_idIndexMarker252"/>code, we created the backend to run on the simulator with <code class="inlineCode">1000</code> <code class="inlineCode">shots</code> and plot the results in a histogram to review them.</p>
    <div><p class="normal">Note from the following results that the outcomes are very random from each qubit, which is what we expected. One thing I would also like to mention regarding notation is the ordering of the qubits. When written, the order of the qubits is a little different than the bit order. In quantum notation, the first qubit is also listed on the left-hand side, while subsequent qubits are added toward the right-hand side. In binary notation, however, the first bit is on the right-hand side, while subsequent bits are added toward the left-hand side.</p>
      <p class="normal">For example, if we want to represent the 3-qubit value of the number 5, we would do so using <img src="img/B18420_04_040.png" alt="" width="42" height="25"/><a id="_idIndexMarker253"/>, which is the same as the bit representation of the same number. However, the qubit order here is different as the first qubit is listed in the left position (q[0]), the second qubit (q[1]) is listed in the middle position, and the last qubit (q[2]) is listed in the right position.</p>
      <p class="normal">On the other hand, in binary notation, the first bit (b[0]) is in the right position and moves up in order to the left. When measuring, we link the results from the qubit to the bit (as shown in the preceding screenshot), which correctly maps the results of each qubit to its respective binary position so that our results are in the expected bit order.</p>
    </div>
    <p class="normal-one">The plotted histogram is shown in the following screenshot:</p>
    <figure class="mediaobject"><img src="img/B18420_04_12.png" alt="Figure 4.10 - Random results of all combinations from both qubits " width="656" height="447"/></figure>
    <p class="packt_figref">Figure 4.12: Random results of all combinations from both qubits</p>
    <p class="normal-one">In the previous screenshot, each qubit has collapsed to a state of either 0 or 1, so since there are two qubits, we should expect to see all four random results, which are <strong class="keyWord">00</strong>, <strong class="keyWord">01</strong>, <strong class="keyWord">10</strong>, and <strong class="keyWord">11</strong>. Your probability results might differ a bit, but <a id="_idIndexMarker254"/>overall, they should all be close to 25% probability.</p>
    <ol>
      <li class="numberedList" value="3">This is expected, so let’s entangle the two qubits and see what happens then. For this, we will entangle the two qubits and rerun the experiment.</li>
    </ol>
    <p class="normal-one">Let’s entangle the two qubits by adding a multi-qubit <a id="_idIndexMarker255"/>gate called a <strong class="keyWord">Controlled</strong> <strong class="keyWord">NOT</strong> (<strong class="keyWord">CNOT</strong>) gate. Let me explain what this gate is before we include it in our circuit.</p>
    <p class="normal-one">The CNOT gate is a multi-qubit gate that operates on one qubit based on the value of another. What this means is that the qubit gate has two connecting points—one called <strong class="keyWord">control</strong> and another called <strong class="keyWord">target</strong>. The target is generally an operator, such as a <strong class="keyWord">NOT</strong> (<em class="italic">X</em>) gate, which would flip the qubit from 0 to 1, or vice versa.</p>
    <p class="normal-one">However, the target operator can also be almost any operation, such as an H gate, a Y gate (which flips 180° around the <em class="italic">Y</em> axis), and so on. It could even be another control, but we will get into those fancy gates in <em class="chapterRef">Chapter 6</em>, <em class="italic">Understanding Quantum Logic Gates</em>.</p>
    <p class="normal-one">The CNOT gate acts in such a manner that when the qubit tied to the control is set to 0, the value of the target qubit does not change, meaning the target operator will not be enabled. However, if the value of the control qubit is 1, this will trigger the target operator. This would, therefore, in the case of a CNOT gate, enable a NOT operation on the target qubit, causing it to flip 180° around the <em class="italic">X</em> axis from its current position. This is illustrated in <em class="italic">Figure 4.13</em>, where qubit 0 is the control and qubit 1 is the target; in this case, the target is a NOT gate, hence making this a CNOT gate.</p>
    <p class="normal-one">The following logic table represents the control and target value updates based on the value of the control for a CNOT gate, as well as the states before and after the CNOT gate:</p>
    <figure class="mediaobject"><img src="img/B18420_04_13.png" alt="Table 4.1 - Two qubit CNOT logic table " width="439" height="194"/></figure>
    <p class="packt_figref">Table 4.1: Two-qubit CNOT logic table</p>
    <p class="normal-one">Now that we can <a id="_idIndexMarker256"/>see how the CNOT gate works on two qubits, we will update our circuit so that we can entangle the qubits together. In the following code, we will create a circuit with 2 qubits where we will apply a Hadamard gate to the first qubit and then entangle the first qubit with the second qubit using a CNOT gate:</p>
    <pre class="programlisting code-one"><code class="hljs-code"># Create a circuit with 2 qubits and 2 classic bits
qc = QuantumCircuit(2,2)
# Add an H gate to just the first qubit
qc.h(0)
# Add the CNOT gate to entangle the two qubits,
# where the first qubit is the control, and the
# second qubit is the target.
qc.cx(0,1)
# Measure the qubits to the classical bit
qc.measure([0,1],[0,1])
# Draw the circuit
qc.draw(output='mpl')
</code></pre>
    <p class="normal-one">The resulting diagram of the circuit should look as follows:</p>
    <figure class="mediaobject"><img src="img/B18420_04_14.png" alt="Figure 4.11 - Entanglement of two qubits " width="364" height="169"/></figure>
    <p class="packt_figref">Figure 4.13: Entanglement of two qubits</p>
    <p class="normal-one">The previous screenshot shows you that, this time, we are only placing a Hadamard gate on the first qubit and leaving the second qubit to be operated on only by the CNOT gate. Since qubit 1 (q<sub class="subscript">1</sub>) is set as the target, it will be dependent on the control qubit, which, in this case, is qubit 0 (q<sub class="subscript">0</sub>).</p>
    <ol>
      <li class="numberedList" value="4">Now, we will <a id="_idIndexMarker257"/>run the experiment and plot the results. This is similar to the previous experiments we completed, where we will execute the circuit, extract the result counts, and plot them on a histogram to visualize the results:
        <pre class="programlisting code-one"><code class="hljs-code"># Run the quantum circuit
transpiledQC, result = run_qasm_circuit(qc, None, None)
counts = result.get_counts(qc)
plot_distribution(counts)
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The results shown in the following screenshot show two quantum computing principles—the superposition of the qubits, 0 and 1, and the entanglement—where both qubits’ (control and target) results are strongly correlated as either <strong class="keyWord">00</strong> or <strong class="keyWord">11</strong>:</p>
    <figure class="mediaobject"><img src="img/B18420_04_15.png" alt="Figure 4.12 - Results of two entangled qubits  " width="507" height="343"/></figure>
    <p class="packt_figref">Figure 4.14: Results of two entangled qubits</p>
    <p class="normal">Let’s extend our coin-flipping example by adding another coin and entangling them together so that when we run our experiment, we can determine the value of one coin without having to measure the other.</p>
    <h2 id="_idParaDest-72" class="heading-2">Entangling two coins together</h2>
    <p class="normal">In the same<a id="_idIndexMarker258"/> way as our previous experiment, each qubit will represent a coin. In order to do this, we will use a CNOT<strong class="keyWord"> </strong>gate, which connects two qubits where one is the source and the other the target.</p>
    <p class="normal">Let’s try entangling our coins (qubits) to see how this works:</p>
    <ol>
      <li class="numberedList" value="1">Open the Composer and create a new blank circuit with 2 qubits. As a reminder, you can increase or decrease the number of qubits by selecting a qubit and clicking on either the + or trash icon to add or remove a qubit from the circuit, respectively.</li>
      <li class="numberedList">Click and drag a Hadamard gate onto the first qubit, q<sub class="subscript">0</sub>.</li>
      <li class="numberedList">Click and drag the CNOT gate (<em class="italic">round white gate with crosshairs on blue background</em>) onto the first qubit, q<sub class="subscript">1</sub>. This will assign the control qubit to the first qubit. When selecting the CNOT gate, the first qubit you drop it on will be set as the control. Visually, the source control of the CNOT gate is a solid dot on the qubit to which the gate was dragged on to (see <em class="italic">Figure 4.15</em>).</li>
    </ol>
    <p class="normal-one">By default, the target will set itself to the next qubit. In this case, it will drop to qubit 2. Visually, the target for a CNOT is a large dot with a cross in the middle, made to resemble a target.</p>
    <ol>
      <li class="numberedList" value="4">Click and drag a measurement operator onto each of the two first qubits as shown in the following screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18420_04_16.png" alt="Diagram  Description automatically generated with medium confidence" width="704" height="198"/></figure>
    <p class="packt_figref">Figure 4.15: Entangled qubit circuit representing entangled coins</p>
    <ol>
      <li class="numberedList" value="5">Name and save your experiment as <code class="inlineCode">Entangled coins</code>.</li>
      <li class="numberedList">Click <strong class="screenText">Setup and run</strong> on the circuit to launch the <strong class="screenText">Setup and run</strong> dialog.</li>
      <li class="numberedList">Select any device from the backend selection as the backend device and select the <code class="inlineCode">shots </code>value to <code class="inlineCode">1024</code>. This will run the experiment 1,024 times, which is the default value that you can change if need be.</li>
      <li class="numberedList">Click <strong class="screenText">Run on</strong> and select whichever device you selected in the previous step.</li>
      <li class="numberedList">Once completed, click the <code class="inlineCode">Entangled coins</code> experiment from the <code class="inlineCode">Completed jobs</code> list.</li>
    </ol>
    <p class="normal">Now let’s review the <a id="_idIndexMarker259"/>results and see what happens when we entangle two qubits:</p>
    <figure class="mediaobject"> <img src="img/B18420_04_17.png" alt="Chart, bar chart  Description automatically generated" width="425" height="681"/></figure>
    <p class="packt_figref">Figure 4.16: Entangled coins results</p>
    <p class="normal">As you can see in the <a id="_idIndexMarker260"/>preceding screenshot, the results still have two states, as they did in the previous experiment. However, one thing to observe here is the results of the two qubits. Note that the state of both qubits is either 00 or 11.</p>
    <p class="normal">What makes this experiment interesting is when we flipped one coin in the previous experiment, you saw that the results were 50% (0 or 1). However, now we are running the same experiment, but we are entangling another coin. In effect, this results in both coins becoming entangled together and thus their states will always be the same as each other. This means that if we flip both coins and we observe one of the coin values, then we know that the other entangled coin will be the same value.</p>
    <p class="normal">Now that you are familiar with superposition and entanglement, let’s move on to the last quantum computing principle, which is interference.</p>
    <h1 id="_idParaDest-73" class="heading-1">Understanding interference</h1>
    <p class="normal">One of the benefits of quantum computing is its ability to interleave these principles in such a way that usually, while<a id="_idIndexMarker261"/> explaining one, you can very easily describe the other. We did this earlier in this chapter with respect to interference. Let’s review and see where we have come across this phenomenon and its usage so far.</p>
    <p class="normal">First, recall that, at the beginning of this chapter, we described the double-slit experiment. There, we discussed how an electron can act as both a wave and a particle. When acting like a wave, we saw that the experiment illustrated how the electrons traveled and landed at certain spots on the observation screen. The pattern that it displayed was generally one that we recognize from classic physics as wave interference.</p>
    <p class="normal">The pattern had probabilistic results along the backboard, as shown in the observing screen in <em class="italic">Figure 4.2</em>, where the center of the screen has the highest number of electrons and the blank areas along both sides had the least to none. This is due to the two types of interference of the particle waves, namely, <strong class="keyWord">constructive</strong> and <strong class="keyWord">destructive</strong>. Constructive interference<a id="_idIndexMarker262"/> occurs when the peaks of two waves are summed up <a id="_idIndexMarker263"/>where the resulting amplitude is equal to the total positive sum of the two individual waves.</p>
    <p class="normal">Destructive interference<a id="_idIndexMarker264"/> occurs similarly to constructive interference except that the amplitudes<a id="_idIndexMarker265"/> of the waves are opposite in that when summing them together, the two waves cancel each other out.</p>
    <p class="normal">The following diagram<a id="_idIndexMarker266"/> illustrates the constructive and destructive <a id="_idIndexMarker267"/>wave interference of two waves when <a id="_idIndexMarker268"/>they are <a id="_idIndexMarker269"/>added together:</p>
    <figure class="mediaobject"><img src="img/B18420_04_18.png" alt="Chart  Description automatically generated" width="511" height="179"/></figure>
    <p class="packt_figref">Figure 4.17: Constructive (left) and destructive (right) wave interferences (image source: https://commons.wikimedia.org/wiki/File:Interference_of_two_waves.svg)</p>
    <p class="normal">The preceding diagram illustrates how two waves interfere with each other constructively and destructively. The two waves toward the bottom of the diagram represent the individual amplitudes of each wave, while the top line represents the added amplitude values, which represent the result of the interference between the two waves.</p>
    <p class="normal">Now that you understand the difference between constructive and destructive interference, <em class="italic">how can we apply this to what we’ve learned so far?</em> Well, if you recall, earlier, when we placed a qubit in superposition, we had two distinct results.</p>
    <p class="normal">One was from the basis state <img src="img/B18420_04_006.png" alt="" width="23" height="25"/><a id="_idIndexMarker270"/>, while the other was from the basis state <img src="img/B18420_02_003.png" alt="" width="23" height="25"/><a id="_idIndexMarker271"/>. Do you remember when we started at either of these two qubit basis states, where on the <em class="italic">X</em> axis of the qubit the Hadamard landed? From <img src="img/B18420_04_006.png" alt="" width="23" height="25"/><a id="_idIndexMarker272"/>, it would land on the positive side of the <em class="italic">X</em> axis, but if we placed the qubit into superposition starting from the <img src="img/B18420_02_003.png" alt="" width="23" height="25"/><a id="_idIndexMarker273"/> state, it would land on the negative <em class="italic">X</em> axis.</p>
    <p class="normal">Having the ability to place the qubit state vector on either the positive or negative <em class="italic">X</em> axis provides us with a way to place the qubit in either a positive or negative state. Very similar to the waves in the preceding diagram, which have positive (peaks) and negative (troughs) amplitudes, qubits can also represent similar states. Let’s simplify this by re-introducing the two Dirac notation values, <img src="img/B18420_04_008.png" alt="" width="25" height="25"/><a id="_idIndexMarker274"/>, and <img src="img/B18420_04_012.png" alt="" width="25" height="25"/><a id="_idIndexMarker275"/>, where the <img src="img/B18420_04_008.png" alt="" width="25" height="25"/><a id="_idIndexMarker276"/> state represents the state vector on the positive <em class="italic">X</em> axis, and the <img src="img/B18420_04_012.png" alt="" width="25" height="25"/><a id="_idIndexMarker277"/> state represents the state vector on the negative <em class="italic">X</em> axis.</p>
    <p class="normal">These new vector definitions, which represent the vector state of a qubit in superposition, will be used by some of the algorithms as a technique to identify certain values and react to them using interference—techniques such <a id="_idIndexMarker278"/>as <strong class="keyWord">amplitude estimation</strong> and search algorithms<a id="_idIndexMarker279"/> such as <strong class="keyWord">Grover’s</strong> <strong class="keyWord">algorithm</strong>.</p>
    <p class="normal">In this section, we reviewed the quantum computing principle of interference. This, along with the other two principles, superposition and entanglement, will come in handy as you learn about how these principles are used in quantum algorithms in ways that provide potential speed up over classical algorithms. To do so, we will review an example that we will use throughout this book, to understand the very foundation of <a id="_idIndexMarker280"/>all quantum algorithms, the <strong class="keyWord">Bell states</strong>.</p>
    <h1 id="_idParaDest-74" class="heading-1">Exploring the Bell states</h1>
    <p class="normal">For most of the examples in this book, you will notice that we reuse a simple two-qubit quantum circuit to run many of our experiments. This circuit contains two gates, a single-qubit gate, and a multi-qubit gate, a Hadamard and CNOT, respectively.</p>
    <p class="normal">The reason for choosing this was not random. In fact, this circuit has a name, the Bell state. The Bell state, which was originally described in a theoretical paper by John Bell in 1964, describes how there are four maximally entangled quantum states between two qubits that are in a superposition <a id="_idIndexMarker281"/>state. These four states are commonly referred to as the <strong class="keyWord">Bell states</strong>.</p>
    <p class="normal">At this point, you may be wondering why this is so important. Well, if we can prepare qubits to a particular state, in this case, the maximally entangled state, this can help streamline the creation of various quantum circuits and algorithms. To learn more about this, let’s first prepare the four Bell states, and perhaps, along the way, you might see its importance and understand the significance to some use cases such as quantum teleportation or super dense coding.</p>
    <h2 id="_idParaDest-75" class="heading-2">Preparing the Bell states</h2>
    <p class="normal">We’ll begin by first <a id="_idIndexMarker282"/>preparing the Bell state that we will use throughout this book.</p>
    <p class="normal">We’ll label each of these states as we create them, this first one being labeled as <img src="img/B18420_04_049.png" alt="" width="35" height="25"/><a id="_idIndexMarker283"/>. Preparing the Bell state entails three simple steps:</p>
    <ol>
      <li class="numberedList" value="1">Prepare your two-qubit input values. For this first state, <img src="img/B18420_04_050.png" alt="" width="35" height="25"/><a id="_idIndexMarker284"/>, we will use the initialized state of <img src="img/B18420_04_051.png" alt="" width="33" height="25"/><a id="_idIndexMarker285"/>:</li>
    </ol>
    <p class="center"><img src="img/B18420_04_052.png" alt="" width="90" height="25"/><a id="_idIndexMarker286"/></p>
    <ol>
      <li class="numberedList" value="2">Next, add a Hadamard to the first qubit. This will place the first qubit in a superposition state:</li>
    </ol>
    <p class="center"><img src="img/B18420_04_053.png" alt="" width="185" height="52"/><a id="_idIndexMarker287"/></p>
    <ol>
      <li class="numberedList" value="3">Finally, add a CNOT gate, where the control is set to the qubit in superposition. In this case, the first qubit and the target are set to the second qubit. Doing so will ensure that when the first qubit is 1, this will trigger the target qubit to rotate about the <em class="italic">X</em> axis from the <img src="img/B18420_04_006.png" alt="" width="23" height="25"/><a id="_idIndexMarker288"/> state to the <img src="img/B18420_04_055.png" alt="" width="19" height="25"/><a id="_idIndexMarker289"/> state, or else it will remain in the <img src="img/B18420_04_006.png" alt="" width="23" height="25"/><a id="_idIndexMarker290"/> state. This gives us our final state:</li>
    </ol>
    <p class="center"><img src="img/B18420_04_057.png" alt="" width="177" height="52"/><a id="_idIndexMarker291"/></p>
    <p class="normal">This final state is the first Bell state, <img src="img/B18420_04_049.png" alt="" width="35" height="25"/><a id="_idIndexMarker292"/>, which will result in an equal probability of either <img src="img/B18420_04_051.png" alt="" width="33" height="25"/><a id="_idIndexMarker293"/> or <img src="img/B18420_04_060.png" alt="" width="33" height="25"/><a id="_idIndexMarker294"/>.</p>
    <p class="normal">The only difference between preparing the first Bell state and the others is just in <em class="italic">step 1</em>, where you need to prepare your inputs. <em class="italic">Step 2</em> and <em class="italic">step 3</em> are the same for all. What this means is that for a two-qubit circuit, the remaining input states in <em class="italic">step 1</em> to prepare are <img src="img/B18420_04_061.png" alt="" width="33" height="25"/><a id="_idIndexMarker295"/>, <img src="img/B18420_04_062.png" alt="" width="33" height="25"/><a id="_idIndexMarker296"/>, and <img src="img/B18420_04_060.png" alt="" width="33" height="25"/><a id="_idIndexMarker297"/>. Luckily for us, the following formula can be used to help us identify the remaining Bell states:</p>
    <p class="center"><img src="img/B18420_04_064.png" alt="" width="313" height="52"/><a id="_idIndexMarker298"/></p>
    <p class="normal">By using this<a id="_idIndexMarker299"/> formula, we can calculate that all four Bell states are as follows:</p>
    <ul>
      <li class="bulletList">For the input state <img src="img/B18420_04_051.png" alt="" width="33" height="25"/><a id="_idIndexMarker300"/>, we get the following equation:</li>
    </ul>
    <p class="center"><img src="img/B18420_04_066.png" alt="" width="177" height="52"/><a id="_idIndexMarker301"/></p>
    <ul>
      <li class="bulletList">For the input state <img src="img/B18420_04_061.png" alt="" width="33" height="25"/><a id="_idIndexMarker302"/>, we get the following equation:</li>
    </ul>
    <p class="center"><img src="img/B18420_04_068.png" alt="" width="177" height="52"/><a id="_idIndexMarker303"/></p>
    <ul>
      <li class="bulletList">For the input state <img src="img/B18420_04_062.png" alt="" width="33" height="25"/><a id="_idIndexMarker304"/>, we get the following equation:</li>
    </ul>
    <p class="center"><img src="img/B18420_04_070.png" alt="" width="181" height="52"/><a id="_idIndexMarker305"/></p>
    <ul>
      <li class="bulletList">For the <a id="_idIndexMarker306"/>input state <img src="img/B18420_04_060.png" alt="" width="33" height="25"/><a id="_idIndexMarker307"/>, we get the following equation:</li>
    </ul>
    <p class="center"><img src="img/B18420_04_072.png" alt="" width="181" height="52"/><a id="_idIndexMarker308"/></p>
    <p class="normal">Now, let’s create these circuits by executing all the Bell states on both a simulator and a quantum computer.</p>
    <h2 id="_idParaDest-76" class="heading-2">Implementing the Bell states</h2>
    <p class="normal">In this section, we<a id="_idIndexMarker309"/> will create the first two initial states, <img src="img/B18420_04_051.png" alt="" width="33" height="25"/><a id="_idIndexMarker310"/> and <img src="img/B18420_04_062.png" alt="" width="33" height="25"/><a id="_idIndexMarker311"/>, and leave you to create the remaining input states:</p>
    <ol>
      <li class="numberedList" value="1">We’ll begin by creating the first Bell state, <img src="img/B18420_04_051.png" alt="" width="33" height="25"/><a id="_idIndexMarker312"/>. Let’s create a two-qubit <code class="inlineCode">QuantumCircuit</code> circuit, and prepare the input state, <img src="img/B18420_04_051.png" alt="" width="33" height="25"/><a id="_idIndexMarker313"/>. Since all quantum circuits are initialized to the state <img src="img/B18420_04_051.png" alt="" width="33" height="25"/><a id="_idIndexMarker314"/>, we do not need to do anything to the circuit. We’ll add a barrier to indicate the separation between steps:
        <pre class="programlisting code-one"><code class="hljs-code"># State 1: |/+&gt;
state1 = QuantumCircuit(2)
# Initialize input to |0,0&gt;
state1.barrier()
</code></pre>
      </li>
      <li class="numberedList">Then, add a Hadamard gate to the first qubit:
        <pre class="programlisting code-one"><code class="hljs-code"># Prepare the Bell state
state1.h(0)
</code></pre>
      </li>
      <li class="numberedList">Add a CNOT gate where the control is the first qubit, and the target is the second qubit:
        <pre class="programlisting code-one"><code class="hljs-code">state1.cx(0,1)
</code></pre>
      </li>
      <li class="numberedList">Finally, add measurements to all qubits and draw the circuit:
        <pre class="programlisting code-one"><code class="hljs-code">state1.measure_all()
state1.draw(output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This will render the final circuit for our first Bell state, <img src="img/B18420_04_051.png" alt="" width="33" height="25"/><a id="_idIndexMarker315"/>, as follows:</p>
    <figure class="mediaobject"><img src="img/B18420_04_19.png" alt="Figure 13.1 – Prepared Bell state,  " width="556" height="185"/></figure>
    <p class="packt_figref">Figure 4.18: Prepared Bell state,<img src="img/B18420_04_079.png" alt="" width="102" height="25"/><a id="_idIndexMarker316"/></p>
    <ol>
      <li class="numberedList" value="5">Now let’s <a id="_idIndexMarker317"/>execute this circuit with our helper function. Set the <code class="inlineCode">simulator</code> argument to specify whether you want to execute it on a simulator or quantum system. To avoid any noise in our results, in this example, we will run the circuit on a quantum simulator to verify that our results are as expected:
        <pre class="programlisting code-one"><code class="hljs-code"># Execute the Bell state |/+&gt;
transpiledQC, result, stateVectorResult = simulate_on_sampler(state1, None, None)
# Obtain the results and display on a histogram
counts = result[0].data.meas.get_counts()
plot_histogram(counts)
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The results of this experiment render the following familiar output, which confirms the first Bell state, 00:</p>
    <figure class="mediaobject"><img src="img/B18420_04_20.png" alt="Figure 13.2 – Results of the Bell state,  " width="552" height="369"/></figure>
    <p class="packt_figref">Figure 4.19: Results for the first state, <img src="img/B18420_04_080.png" alt="" width="102" height="25"/><a id="_idIndexMarker318"/></p>
    <ol>
      <li class="numberedList" value="6">We’ll now continue to represent the next state, <img src="img/B18420_04_081.png" alt="" width="104" height="25"/><a id="_idIndexMarker319"/>, and confirm the results as we did previously.</li>
    </ol>
    <p class="normal-one">As mentioned earlier, the only difference between the four Bell states is in the first step, which is to prepare the input states. In this case, our input state is <img src="img/B18420_04_062.png" alt="" width="33" height="25"/><a id="_idIndexMarker320"/>. We can follow the same steps as before after adding an <em class="italic">X</em> gate to the second qubit:</p>
    <pre class="programlisting code-one"><code class="hljs-code"># State 2: |/+&gt;
state2 = QuantumCircuit(2)
# Initialize input state to |1,0&gt;
state2.x(1)
state2.barrier()
# Prepare the Bell state
state2.h(0)
state2.cx(0,1)
state2.measure_all()
state2.draw(output='mpl')
</code></pre>
    <p class="normal-one">This will<a id="_idIndexMarker321"/> result in the following circuit, which is very similar to the first except for the added <em class="italic">X</em> gate in the preparation step:</p>
    <figure class="mediaobject"><img src="img/B18420_04_21.png" alt="Figure 13.3 – Prepared Bell state" width="659" height="201"/></figure>
    <p class="packt_figref">Figure 4.20: Prepared Bell state, <img src="img/B18420_04_083.png" alt="" width="104" height="25"/><a id="_idIndexMarker322"/></p>
    <ol>
      <li class="numberedList" value="7">As with the first Bell state, let’s execute this circuit and observe the results:
        <pre class="programlisting code-one"><code class="hljs-code"># Execute the Bell state |/+&gt;
transpiledQC, result, stateVectorResult = simulate_on_sampler(state1, None, None)
# Obtain the results and display on a histogram
counts = result[0].data.meas.get_counts()
plot_histogram(counts)
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The results from executing the preceding circuit are as follows:</p>
    <figure class="mediaobject"><img src="img/B18420_04_22.png" alt="Figure 13.4 – Results of the Bell state" width="572" height="390"/></figure>
    <p class="packt_figref">Figure 4.21: Results of the Bell state, <img src="img/B18420_04_081.png" alt="" width="104" height="25"/><a id="_idIndexMarker323"/></p>
    <p class="normal">After reviewing<a id="_idIndexMarker324"/> both results, we should note a couple of things. The first is that we can see from the first Bell state that both qubits are equally entangled, in that if you were to measure one qubit, let’s say the first one, then you would know that the second qubit should be in the same state. Hence, if you measure the first qubit and the result is 0, then without measuring, you know the state of the second qubit.</p>
    <p class="normal">Whether you measure the second qubit at the same time or at a later juncture, the same can be said about the second Bell state; the only difference, in that case, is that if you measure one qubit, then you know that the other will result in the opposite basis state value. Hence, if the first qubit results in 0, then the second qubit will result in 1, or vice versa.</p>
    <p class="normal">This correlation between two<a id="_idIndexMarker325"/> qubits is the basis for two famous quantum applications—<strong class="keyWord">quantum teleportation</strong> and <strong class="keyWord">super dense coding</strong>, where, in each, there are two qubits that are prepared in an<a id="_idIndexMarker326"/> entangled state. This preparation of the two qubits is represented by the Bell states, where the preparation can be in either of the four Bell states we have just described.</p>
    <p class="normal">When reading about use cases that describe quantum teleportation, you will hear a similar example to this: <em class="italic">Eve prepares a pair of entangled qubits and sends one to Alice and the other to Bob</em>; you’ll now know how Eve prepares the pair of entangled qubits.</p>
    <p class="normal">Now that we understand the Bell states and how they can be applied in applications such as quantum teleportation and super dense coding, we’ll continue our journey in later chapters to illustrate how quantum algorithms offer computational advantages over classical systems.</p>
    <h1 id="_idParaDest-77" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, you learned about the three quantum computing principles used in quantum computing. You created a quantum circuit and placed a qubit in superposition and an entangled state between two qubits in a quantum circuit.</p>
    <p class="normal">You also understood the two types of interference, constructive and destructive, and learned how they are notated and represented individually as qubits by placing them in superposition to create <img src="img/B18420_04_008.png" alt="" width="25" height="25"/><a id="_idIndexMarker327"/> and <img src="img/B18420_04_012.png" alt="" width="25" height="25"/><a id="_idIndexMarker328"/> simulations.</p>
    <p class="normal">You also had a sneak peek at some Qiskit development skills by leveraging some quantum gates such as the Hadamard and CNOT gates, as well as operations such as measurements. This will prepare you for future chapters when you will create circuits where these gates and operations are commonly used in various algorithms. This makes sense as these gates and operations represent the core quantum computing principles that we have learned.</p>
    <p class="normal">You also ran a couple of experiments: the first one was an experiment that simulated a coin toss in which a circuit was created using the Hadamard gate, which leveraged superposition. The second experiment also simulated a coin toss, only we had entangled each of the two coins together. This is an expansion of the second circuit, which included your first multi-gate, a CNOT gate. These allowed you to examine how both superposition and entanglement results map from your quantum circuit to the classical bit outputs. We also learned about the Bell states, which illustrate a great example of the use and advantage we get with quantum entanglement. These four special states that represent a linear combination of superposition states will be used when learning about quantum algorithms in later chapters of this book.</p>
    <p class="normal">In the next chapter, we will learn about all the other gates, both single and multi, to understand the operations they perform on each qubit.</p>
    <h1 id="_idParaDest-78" class="heading-1">Questions</h1>
    <ol>
      <li class="numberedList" value="1">How would you create a circuit that entangles two qubits where each qubit is different (that is, 01, 10)?</li>
      <li class="numberedList">Create a circuit with a multi-qubit gate, such as a Controlled-Hadamard gate.</li>
      <li class="numberedList">Create all 4 Bell states in a circuit.</li>
      <li class="numberedList">What are the three quantum computation principles?</li>
    </ol>
    <h1 id="_idParaDest-79" class="heading-1">Join us on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
    <p class="normal"><a href="Chapter_4.xhtml">https://packt.link/3FyN1</a></p>
    <p class="normal"><img src="img/QR_Code2617625996838265931.png" alt="" width="165" height="165"/></p>
  </div>
</div></div></body></html>