["```py\nlibc.printf(\"Pi is approximately %f.\\n\", ctypes.c_double(3.14)) \n```", "```py\n#include <cuda_runtime.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n```", "```py\nextern \"C\" __global__ void mandelbrot_ker(float * lattice, float * mandelbrot_graph, int max_iters, float upper_bound_squared, int lattice_size)\n{\n```", "```py\n    int tid = blockIdx.x * blockDim.x + threadIdx.x;\n\n    if ( tid < lattice_size*lattice_size )\n    {\n        int i = tid % lattice_size;\n        int j = lattice_size - 1 - (tid / lattice_size);\n\n        float c_re = lattice[i];\n        float c_im = lattice[j];\n```", "```py\n        float z_re = 0.0f;\n        float z_im = 0.0f;\n\n        mandelbrot_graph[tid] = 1;\n```", "```py\n        for (int k = 0; k < max_iters; k++)\n        {\n            float temp;\n\n            temp = z_re*z_re - z_im*z_im + c_re;\n            z_im = 2*z_re*z_im + c_im;\n            z_re = temp;\n\n            if ( (z_re*z_re + z_im*z_im) > upper_bound_squared )\n            {\n                mandelbrot_graph[tid] = 0;\n                break;\n            }\n        }\n```", "```py\n    }\n    return;\n}\n```", "```py\nextern \"C\" __declspec(dllexport) void launch_mandelbrot(float * lattice,  float * mandelbrot_graph, int max_iters, float upper_bound, int lattice_size)\n{\n```", "```py\n    int num_bytes_lattice = sizeof(float) * lattice_size;\n    int num_bytes_graph = sizeof(float)* lattice_size*lattice_size;\n\n    float * d_lattice;\n    float * d_mandelbrot_graph;\n\n    cudaMalloc((float **) &d_lattice, num_bytes_lattice);\n    cudaMalloc((float **) &d_mandelbrot_graph, num_bytes_graph);\n\n    cudaMemcpy(d_lattice, lattice, num_bytes_lattice, cudaMemcpyHostToDevice);\n```", "```py\n    int grid_size = (int)  ceil(  ( (double) lattice_size*lattice_size ) / ( (double) 32 ) );\n```", "```py\n    mandelbrot_ker <<< grid_size, 32 >>> (d_lattice,  d_mandelbrot_graph, max_iters, upper_bound*upper_bound, lattice_size);\n```", "```py\n    cudaMemcpy(mandelbrot_graph, d_mandelbrot_graph, num_bytes_graph, cudaMemcpyDeviceToHost);    \n    cudaFree(d_lattice);\n    cudaFree(d_mandelbrot_graph);\n}\n```", "```py\nnvcc -Xcompiler -fPIC -shared -o mandelbrot.so mandelbrot.cu\n```", "```py\nnvcc -shared -o mandelbrot.dll mandelbrot.cu\n```", "```py\nfrom __future__ import division\nfrom time import time\nimport matplotlib\nfrom matplotlib import pyplot as plt\nimport numpy as np\nfrom ctypes import *\n```", "```py\nmandel_dll = CDLL('./mandelbrot.dll')\n```", "```py\nmandel_c = mandel_dll.launch_mandelbrot\n```", "```py\nmandel_c.argtypes = [POINTER(c_float), POINTER(c_float), c_int, c_float, c_int]\n```", "```py\ndef mandelbrot(breadth, low, high, max_iters, upper_bound):\n```", "```py\n lattice = np.linspace(low, high, breadth, dtype=np.float32)\n```", "```py\n    out = np.empty(shape=(lattice.size,lattice.size), dtype=np.float32)\n```", "```py\n mandel_c(lattice.ctypes.data_as(POINTER(c_float)), out.ctypes.data_as(POINTER(c_float)), c_int(max_iters), c_float(upper_bound), c_int(lattice.size) ) \n return out\n```", "```py\nif __name__ == '__main__':\n    t1 = time()\n    mandel = mandelbrot(512,-2,2,256, 2)\n    t2 = time()\n    mandel_time = t2 - t1\n    print 'It took %s seconds to calculate the Mandelbrot graph.' % mandel_time\n    plt.figure(1)\n    plt.imshow(mandel, extent=(-2, 2, -2, 2))\n    plt.show()\n```", "```py\nnvcc -ptx -o mandelbrot.ptx mandelbrot.cu\n```", "```py\nfrom __future__ import division\nfrom time import time\nimport matplotlib\nfrom matplotlib import pyplot as plt\nimport numpy as np\nimport pycuda\nfrom pycuda import gpuarray\nimport pycuda.autoinit\n```", "```py\nmandel_mod = pycuda.driver.module_from_file('./mandelbrot.ptx')\n```", "```py\nmandel_ker = mandel_mod.get_function('mandelbrot_ker')\n```", "```py\ndef mandelbrot(breadth, low, high, max_iters, upper_bound):\n    lattice = gpuarray.to_gpu(np.linspace(low, high, breadth, dtype=np.   \n    out_gpu = gpuarray.empty(shape=(lattice.size,lattice.size), dtype=np.float32)\n    gridsize = int(np.ceil(lattice.size**2 / 32))\n    mandel_ker(lattice, out_gpu, np.int32(256), np.float32(upper_bound**2), np.int32(lattice.size), grid=(gridsize, 1, 1), block=(32,1,1))\n    out = out_gpu.get()\n\n    return out\n```", "```py\nif __name__ == '__main__':\n    t1 = time()\n    mandel = mandelbrot(512,-2,2,256,2)\n    t2 = time()\n    mandel_time = t2 - t1\n    print 'It took %s seconds to calculate the Mandelbrot graph.' % mandel_time\n    plt.figure(1)\n    plt.imshow(mandel, extent=(-2, 2, -2, 2))\n    plt.show()\n```", "```py\nfrom ctypes import *\nimport sys\nif 'linux' in sys.platform:\n cuda = CDLL('libcuda.so')\nelif 'win' in sys.platform:\n cuda = CDLL('nvcuda.dll')\n```", "```py\ncuInit = cuda.cuInit\ncuInit.argtypes = [c_uint]\ncuInit.restype = int\n```", "```py\ncuDeviceGetCount = cuda.cuDeviceGetCount\ncuDeviceGetCount.argtypes = [POINTER(c_int)]\ncuDeviceGetCount.restype = int\n```", "```py\ncuDeviceGet = cuda.cuDeviceGet\ncuDeviceGet.argtypes = [POINTER(c_int), c_int]\ncuDeviceGet.restype = int\n```", "```py\n CUresult cuCtxCreate ( CUcontext* pctx, unsigned int flags, CUdevice dev )\n```", "```py\ncuCtxCreate = cuda.cuCtxCreate\ncuCtxCreate.argtypes = [c_void_p, c_uint, c_int]\ncuCtxCreate.restype = int\n```", "```py\ncuModuleLoad = cuda.cuModuleLoad\ncuModuleLoad.argtypes = [c_void_p, c_char_p]\ncuModuleLoad.restype = int\n```", "```py\ncuCtxSynchronize = cuda.cuCtxSynchronize\ncuCtxSynchronize.argtypes = []\ncuCtxSynchronize.restype = int\n```", "```py\ncuModuleGetFunction = cuda.cuModuleGetFunction\n cuModuleGetFunction.argtypes = [c_void_p, c_void_p, c_char_p ]\n cuModuleGetFunction.restype = int\n```", "```py\ncuMemAlloc = cuda.cuMemAlloc\ncuMemAlloc.argtypes = [c_void_p, c_size_t]\ncuMemAlloc.restype = int\n\ncuMemcpyHtoD = cuda.cuMemcpyHtoD\ncuMemcpyHtoD.argtypes = [c_void_p, c_void_p, c_size_t]\ncuMemAlloc.restype = int\n\ncuMemcpyDtoH = cuda.cuMemcpyDtoH\ncuMemcpyDtoH.argtypes = [c_void_p, c_void_p, c_size_t]\ncuMemcpyDtoH.restype = int\n\ncuMemFree = cuda.cuMemFree\ncuMemFree.argtypes = [c_void_p] \ncuMemFree.restype = int\n```", "```py\nCUresult cuLaunchKernel ( CUfunction f, unsigned int gridDimX, unsigned int gridDimY, unsigned int gridDimZ, unsigned int blockDimX, unsigned int blockDimY, unsigned int blockDimZ, unsigned int sharedMemBytes, CUstream hStream, void** kernelParams, void** extra )  \n```", "```py\ncuLaunchKernel = cuda.cuLaunchKernel\ncuLaunchKernel.argtypes = [c_void_p, c_uint, c_uint, c_uint, c_uint, c_uint, c_uint, c_uint, c_void_p, c_void_p, c_void_p]\ncuLaunchKernel.restype = int\n```", "```py\ncuCtxDestroy = cuda.cuCtxDestroy\ncuCtxDestroy.argtypes = [c_void_p]\ncuCtxDestroy.restype = int\n```", "```py\nfrom __future__ import division\nfrom time import time\nimport matplotlib\nfrom matplotlib import pyplot as plt\nimport numpy as np\nfrom cuda_driver import *\n```", "```py\ndef mandelbrot(breadth, low, high, max_iters, upper_bound):\n cuInit(0)\n cnt = c_int(0)\n cuDeviceGetCount(byref(cnt))\n if cnt.value == 0:\n  raise Exception('No GPU device found!')\n```", "```py\n cuDevice = c_int(0)\n cuDeviceGet(byref(cuDevice), 0)\n cuContext = c_void_p()\n cuCtxCreate(byref(cuContext), 0, cuDevice)\n```", "```py\n cuModule = c_void_p()\n cuModuleLoad(byref(cuModule), c_char_p('./mandelbrot.ptx'))\n```", "```py\n lattice = np.linspace(low, high, breadth, dtype=np.float32)\n lattice_c = lattice.ctypes.data_as(POINTER(c_float))\n lattice_gpu = c_void_p(0)\n graph = np.zeros(shape=(lattice.size, lattice.size), dtype=np.float32)\n cuMemAlloc(byref(lattice_gpu), c_size_t(lattice.size*sizeof(c_float)))\n graph_gpu = c_void_p(0)\n cuMemAlloc(byref(graph_gpu), c_size_t(lattice.size**2 * sizeof(c_float)))\n cuMemcpyHtoD(lattice_gpu, lattice_c, c_size_t(lattice.size*sizeof(c_float)))\n```", "```py\n mandel_ker = c_void_p(0)\n cuModuleGetFunction(byref(mandel_ker), cuModule, c_char_p('mandelbrot_ker'))\n max_iters = c_int(max_iters)\n upper_bound_squared = c_float(upper_bound**2)\n lattice_size = c_int(lattice.size)\n```", "```py\nvoid * mandel_params [] = {&lattice_gpu, &graph_gpu, &max_iters, &upper_bound_squared, &lattice_size};\n```", "```py\nmandel_args0 = [lattice_gpu, graph_gpu, max_iters, upper_bound_squared, lattice_size ]\n```", "```py\nmandel_args = [c_void_p(addressof(x)) for x in mandel_args0]\n```", "```py\n mandel_params = (c_void_p * len(mandel_args))(*mandel_args)\n```", "```py\n gridsize = int(np.ceil(lattice.size**2 / 32))\n cuLaunchKernel(mandel_ker, gridsize, 1, 1, 32, 1, 1, 10000, None, mandel_params, None)\n cuCtxSynchronize()\n```", "```py\n cuMemcpyDtoH( cast(graph.ctypes.data, c_void_p), graph_gpu,  c_size_t(lattice.size**2 *sizeof(c_float)))\n```", "```py\n cuMemFree(lattice_gpu)\n cuMemFree(graph_gpu)\n cuCtxDestroy(cuContext)\n return graph\n```", "```py\nif __name__ == '__main__':\n t1 = time()\n mandel = mandelbrot(512,-2,2,256, 2)\n t2 = time()\n mandel_time = t2 - t1\n print 'It took %s seconds to calculate the Mandelbrot graph.' % mandel_time\n\n fig = plt.figure(1)\n plt.imshow(mandel, extent=(-2, 2, -2, 2))\n plt.show()\n```"]