<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 1. Fundamentals of the Python Language for ArcGIS"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Fundamentals of the Python Language for ArcGIS</h1></div></div></div><p>Python<a id="id0" class="indexterm"/> supports many of the programming constructs found in other languages. In this chapter, we'll cover many of the basic language constructs found in Python. Initially, we'll cover how to create new Python scripts and edit existing scripts. From there, we'll delve into language features, such as adding comments to your code, creating and assigning data to variables, and built-in variable typing with Python, which makes coding with Python easy and compact. </p><p>Next, we'll look at the various built-in data-types that Python offers, such as strings, numbers, lists, and dictionaries. Classes and objects are a fundamental concept in object-oriented programming and in the Python language. We'll introduce you to these complex data structures, which you'll use extensively when you write geoprocessing scripts with ArcGIS.</p><p>In addition, we'll cover statements including decision support and looping structures for making decisions in your code and/or looping through a code block multiple times along with <code class="literal">with</code> statements, which are used extensively with the new <code class="literal">cursor</code> objects in the Arcpy Data Access module. Finally, you'll learn how to access modules that provide additional functionality to the Python language. By the end of this chapter, you will have learned the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to create and edit new Python scripts</li><li class="listitem" style="list-style-type: disc">Python language features </li><li class="listitem" style="list-style-type: disc">Comments and data variables</li><li class="listitem" style="list-style-type: disc">Built-in datatypes (Strings, Numbers, Lists, and Dictionaries)</li><li class="listitem" style="list-style-type: disc">Complex data structures</li><li class="listitem" style="list-style-type: disc">Looping structures</li><li class="listitem" style="list-style-type: disc">Additional Python functionality</li></ul></div><div class="section" title="Using IDLE for Python script development"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Using IDLE for Python script development</h1></div></div></div><p>As I mentioned<a id="id1" class="indexterm"/>
<a id="id2" class="indexterm"/> in the preface, when you install ArcGIS Desktop, Python<a id="id3" class="indexterm"/> is also installed along with a tool called IDLE that allows you to write your own code. <span class="strong"><strong>IDLE</strong></span>
<a id="id4" class="indexterm"/> stands for <span class="strong"><strong>Integrated DeveLopment Environment</strong></span>. Because it is available with every ArcGIS Desktop installation, we'll use the IDLE development environment for many of the scripts that we write in this book along with the Python window embedded in <a id="id5" class="indexterm"/>ArcGIS Desktop. As you progress as a programmer, you may find other development tools that you prefer over IDLE. You can write your code in any of these tools.</p><div class="section" title="The Python shell window"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>The Python shell window</h2></div></div></div><p>To start the IDLE <a id="id6" class="indexterm"/>development environment for Python, you can go to <span class="strong"><strong>Start</strong></span> | <span class="strong"><strong>Programs</strong></span> | <span class="strong"><strong>ArcGIS</strong></span> | <span class="strong"><strong>Python 2.7</strong></span> | <span class="strong"><strong>IDLE</strong></span>. Please note that the version of Python installed with ArcGIS will differ depending upon the ArcGIS version that you have installed. For example, ArcGIS 10.0<a id="id7" class="indexterm"/> uses <a id="id8" class="indexterm"/>Python 2.6 while ArcGIS 10.1 uses Python 2.7.</p><p>A Python shell window similar to the screenshot will be displayed:</p><div class="mediaobject"><img src="images/4445_01_1.jpg" alt="The Python shell window"/></div><p>The Python shell window is used for output and error messages generated by scripts. A common mistake for beginners is to assume that the geoprocessing scripts will be written in this shell window. That is not the case. You will need to create a separate code window to hold your scripts. </p><p>Although the shell window isn't used to write entire scripts, it can be used to interactively write code and get immediate feedback. ArcGIS has a built-in Python shell window that you can use in much the same way. We'll examine the ArcGIS Python window in the next chapter.</p></div><div class="section" title="The Python script window"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>The Python script window</h2></div></div></div><p>Your scripts will be written in IDLE inside a separate window known as the <a id="id9" class="indexterm"/>
<span class="strong"><strong>Python script window</strong></span>. To create a new code window, select <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>New Window</strong></span> from the IDLE shell window. A window similar to that in the following screenshot will be displayed:</p><div class="mediaobject"><img src="images/4445_01_2.jpg" alt="The Python script window"/></div><p>Your Python scripts will be written inside this new code window. Each script will need to be saved to a local or network drive. By default, scripts are saved with a<a id="id10" class="indexterm"/> <code class="literal">.py</code> file extension.</p></div><div class="section" title="Editing existing Python scripts"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Editing existing Python scripts</h2></div></div></div><p>Existing Python<a id="id11" class="indexterm"/>
<a id="id12" class="indexterm"/> script files can be opened from Windows Explorer by right-clicking on the file and selecting <span class="strong"><strong>Edit with IDLE</strong></span>, which brings up a new shell window along with the script loaded in the Python script editor. You can see an example of this in the following screenshot:</p><div class="mediaobject"><img src="images/4445_01_3.jpg" alt="Editing existing Python scripts"/></div><p>In this<a id="id13" class="indexterm"/>
<a id="id14" class="indexterm"/> instance, we have loaded the <code class="literal">ListFeatureClasses.py</code> script with IDLE. The code is loaded inside the script window:</p><div class="mediaobject"><img src="images/4445_01_4.jpg" alt="Editing existing Python scripts"/></div><p>Now that the code window is open, you can begin writing or editing code. You can also perform some basic script debugging with the IDLE interface. Debugging is the process of identifying and <a id="id15" class="indexterm"/>
<a id="id16" class="indexterm"/>fixing errors in your code.</p></div><div class="section" title="Executing scripts from IDLE"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Executing scripts from IDLE</h2></div></div></div><p>Once you've <a id="id17" class="indexterm"/>
<a id="id18" class="indexterm"/>written a geoprocessing script<a id="id19" class="indexterm"/> in the IDLE code window or opened an existing script, you can execute the code from the interface. IDLE does provide functionality that allows you to check the syntax of your code before running the script. In the code window, select <span class="strong"><strong>Run</strong></span> | <span class="strong"><strong>Check Module</strong></span> to perform a syntax check of your code. </p><p>Any syntax errors will be displayed in the shell window. If there aren't any syntax errors, you should just see the prompt in the shell window. While the IDLE interface can be used to check for syntax errors, it doesn't provide a way of checking for logical errors in your code nor does it provide more advanced debugging tools found in other development environments, such as PythonWin<a id="id20" class="indexterm"/> or <a id="id21" class="indexterm"/>Wingware.</p><p>Once you're satisfied that no syntax errors exist in your code, you can run the script. Select <span class="strong"><strong>Run</strong></span> | <span class="strong"><strong>Run Module</strong></span> to execute the script:</p><div class="mediaobject"><img src="images/4445_01_7.jpg" alt="Executing scripts from IDLE"/></div><p>Any error messages will be written to the shell window along with output from <code class="literal">print</code> statements and system-generated messages. The <code class="literal">print</code> statement<a id="id22" class="indexterm"/> simply outputs a string to the shell window. It is often used for updating the status of a running script or for debugging the<a id="id23" class="indexterm"/>
<a id="id24" class="indexterm"/> code.</p></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Python language fundamentals"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Python language fundamentals</h1></div></div></div><p>To effectively <a id="id25" class="indexterm"/>write geoprocessing scripts for ArcGIS, you are going to need to understand at least the basic constructs of the Python language. Python is easier to learn than most other programming languages, but it does take some time to learn and effectively use it. This section will teach you how to create variables, assign various datatypes to variables, understand the different types of data that can be assigned to variables, use different types of statements, use objects, read and write files, and import third-party Python modules.</p><div class="section" title="Commenting code"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Commenting code</h2></div></div></div><p>Python scripts should <a id="id26" class="indexterm"/>follow a common structure. The beginning <a id="id27" class="indexterm"/>of each script should serve as documentation detailing the script name, author, and a general description of the processing provided by the script. This documentation is accomplished in Python through the use of comments. Comments<a id="id28" class="indexterm"/> are lines of code that you add to your script that serve as a documentation of what functionality the script provides. These lines of code begin with a single pound sign (<code class="literal">#</code>) or a double pound sign (<code class="literal">##</code>), and are followed by whatever text you need to document the code. The Python interpreter does not execute these lines of code. They are simply used for documenting your code. In the next screenshot, the commented lines of code are displayed in red. You should also strive to include comments throughout your script to describe important sections of your script. This will be useful to you (or another programmer) when the time comes to update your scripts.</p><div class="mediaobject"><img src="images/4445_01_5.jpg" alt="Commenting code"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.PacktPub.com">http://www.PacktPub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.PacktPub.com/support">http://www.PacktPub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div></div><div class="section" title="Importing modules"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Importing modules</h2></div></div></div><p>Although <a id="id29" class="indexterm"/>Python includes many built-in functions, you will <a id="id30" class="indexterm"/>frequently need to access specific bundles of functionality, which are stored in external modules. For instance, the <span class="strong"><strong>Math module</strong></span>
<a id="id31" class="indexterm"/> stores specific functions related to processing numeric values and the <span class="strong"><strong>R module</strong></span>
<a id="id32" class="indexterm"/> provides statistical analysis functions. Modules are imported through the use of the<a id="id33" class="indexterm"/> <code class="literal">import</code> statement. When writing geoprocessing scripts with ArcGIS, you will always need to import the ArcPy module, which is the Python package for accessing GIS tools and functions provided by ArcGIS. <code class="literal">import</code> statements will be the first lines of code (not including comments) in your scripts:</p><div class="informalexample"><pre class="programlisting">import arcpy, os</pre></div></div><div class="section" title="Variables"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Variables</h2></div></div></div><p>At a high level, you can think <a id="id34" class="indexterm"/>
<a id="id35" class="indexterm"/>of a variable as an area in your computer's memory reserved for storing values while the script is running. Variables that you define in Python are given a name and a value. The values assigned to variables can then be accessed by different areas of your script as needed, simply by referring to the variable name. For example, you might create a variable that contains a feature class name, which is then used by the <span class="strong"><strong>Buffer</strong></span> tool to create a new output dataset. To create a variable, simply give it a name followed by the assignment operator, which is just an equal sign (<code class="literal">=</code>), and then a value:</p><div class="informalexample"><pre class="programlisting">fcParcels = "Parcels"
fcStreets = "Streets"</pre></div><p>The following table illustrates the variable name and values assigned to the variable using the preceding code example:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Variable name</p>
</th><th style="text-align: left" valign="bottom">
<p>Variable value</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">fcParcels</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Parcels</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">fcStreets</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Streets</code>
</p>
</td></tr></tbody></table></div><p>There are certain naming rules that you must follow when creating variables, including the following: </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Can contain <a id="id36" class="indexterm"/>letters, numbers, and underscores</li><li class="listitem" style="list-style-type: disc">First character must be a letter</li><li class="listitem" style="list-style-type: disc">No special characters in variable name other an underscore</li><li class="listitem" style="list-style-type: disc">Can't use Python keywords</li></ul></div><p>There are a few dozen Python keywords that must be avoided including <code class="literal">class</code>, <code class="literal">if</code>, <code class="literal">for</code>, <code class="literal">while</code>, and others. </p><p>Some examples of legal variable<a id="id37" class="indexterm"/> names in Python:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">featureClassParcel</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">fieldPopulation</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">field2</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ssn</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">my_name</code></li></ul></div><p>Some examples of illegal variable names in Python:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">class</code> (Python keyword)</li><li class="listitem" style="list-style-type: disc"><code class="literal">return</code> (Python <a id="id38" class="indexterm"/>keyword)</li><li class="listitem" style="list-style-type: disc"><code class="literal">$featureClass</code> (illegal character, must start with a letter)</li><li class="listitem" style="list-style-type: disc"><code class="literal">2fields</code> (must start with a letter)</li><li class="listitem" style="list-style-type: disc"><code class="literal">parcels&amp;Streets</code> (illegal character)</li></ul></div><p>Python is a <a id="id39" class="indexterm"/>
<a id="id40" class="indexterm"/>case-sensitive language, so pay particular attention to the capitalization and naming of variables in your scripts. Case-sensitivity issues are probably the most common source of errors for new Python <a id="id41" class="indexterm"/>programmers, so always consider this as a possibility when you encounter errors in your code. Let's look at an example. The following is a list of three variables; note that although each variable name is the same, the casing is different, resulting in three distinct variables.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">mapsize = "22x34"</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">MapSize = "8x11"</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Mapsize = "36x48"</code></li></ul></div><p>If you print these variables, you will get the following output:</p><div class="informalexample"><pre class="programlisting">print mapsize
&gt;&gt;&gt; 22x34

print MapSize
&gt;&gt;&gt; 8x11

print Mapsize
&gt;&gt;&gt;36x48</pre></div><p>Python variable names need to be consistent throughout the script. Best practice is to use camel casing, wherein the first word of a variable name is all lowercase and then each successive word begins with an uppercase letter. This concept is illustrated in the following example with the variable name <code class="literal">fieldOwnerName</code>. The first word (<code class="literal">field</code>) is all lower case followed by an uppercase letter for the second word (<code class="literal">Owner</code>) and third word (<code class="literal">Name</code>):</p><div class="informalexample"><pre class="programlisting">fieldOwnerName</pre></div><p>In Python, variables are dynamically typed. <span class="strong"><strong>Dynamic typing</strong></span>
<a id="id42" class="indexterm"/> means that you can define a variable and assign data to it without specifically defining that a variable name will contain a specific type of data. Commonly used datatypes that can be assigned to variables include the following:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Datatype</p>
</th><th style="text-align: left" valign="bottom">
<p>Example value</p>
</th><th style="text-align: left" valign="bottom">
<p>Code example</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>String</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">"Streets"</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">fcName = "Streets"</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Number</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">3.14</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">percChange = 3.14</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Boolean</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">True</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">ftrChanged = true</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>List</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Streets, Parcels, Streams</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">lstFC = ["Streets", "Parcels", "Streams"]</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Dictionary</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">'0':Streets,'1':Parcels</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">dictFC = {'0':Streets,'1':Parcels]</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Object</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Extent</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">spatialExt = map.extent</code>
</p>
</td></tr></tbody></table></div><p>We will <a id="id43" class="indexterm"/>
<a id="id44" class="indexterm"/>discuss each of these data-types<a id="id45" class="indexterm"/> in greater detail in the coming sections.</p><p>For instance, in C# you would need to define a variable's name and type before using it. This is not necessary in Python. To use a variable, simply give it a name and value, and you can begin using it right away. Python does the work behind the scenes to figure out what type of data is being held in the variable. </p><p>For example, in C# .NET you would need to name and define the datatype for a variable before working with the variable. In the following code example, we've created a new variable called <code class="literal">aTouchdown</code>, which is defined as an integer variable, meaning that it can contain only integer data. We then assign the value <code class="literal">6</code> to the variable:</p><div class="informalexample"><pre class="programlisting">int aTouchdown;
aTouchdown = 6;</pre></div><p>In Python, this same variable can be created and assigned data through dynamic typing. The Python interpreter is tasked with dynamically figuring out what type of data is assigned to the variable:</p><div class="informalexample"><pre class="programlisting">aTouchdown = 6</pre></div><p>Your Python geoprocessing scripts for ArcGIS will often need to reference the location of a dataset on your computer or perhaps a shared server. References to these datasets will often consist of paths stored in a variable. In Python, pathnames are a special case that deserve some extra mention. The backslash character in Python is a reserved escape character and a line continuation character, thus there is a need to define paths using two back slashes, a single forward slash, or a regular single backslash prefixed with the letter <code class="literal">r</code>. These pathnames are always stored as strings in Python. You'll see an example of this in the following section.</p><p>Illegal path reference:</p><div class="informalexample"><pre class="programlisting">fcParcels = "c:\Data\Parcels.shp"</pre></div><p>Legal path references:</p><div class="informalexample"><pre class="programlisting">fcParcels = "c:/Data/Parcels.shp"
fcParcels = "c:\\Data\\Parcels.shp"
fcParcels = r"c:\Data\Parcels.shp"</pre></div><p>There<a id="id46" class="indexterm"/>
<a id="id47" class="indexterm"/> may be times when you know that your script will need a variable, but don't necessarily know ahead of time what data will be assigned to the variable. In these cases, you could simply define a variable without assigning data to it. Data that is assigned to the variable can also be changed while the script is running.</p><p>Variables can hold many different kinds of data including primitive datatypes such as strings and numbers along with more complex data, such as lists, dictionaries and even objects. We're going to examine the different types of data that can be assigned to a variable along with various functions that are provided by Python for manipulating the data.</p></div><div class="section" title="Built-in datatypes"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Built-in datatypes</h2></div></div></div><p>Python has a number of <a id="id48" class="indexterm"/>
<a id="id49" class="indexterm"/>built-in data-types. The first built-in type that we will discuss is the <code class="literal">string</code> data-type. We've already seen several examples of <code class="literal">string</code> variables, but these types of variables can be manipulated in a lot of ways, so let's take a closer look at this data-type. </p><div class="section" title="Strings"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec01"/>Strings</h3></div></div></div><p>Strings<a id="id50" class="indexterm"/> are ordered <a id="id51" class="indexterm"/>collections of characters used to store and represent text-based information. This is a rather dry way of saying that string variables hold text. String variables are surrounded by single or double quotes when being assigned to a variable. Examples could include a name, feature class name, a <code class="literal">Where</code> clause, or anything else that can be encoded as text. </p><div class="section" title="String manipulation"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl4sec01"/>String manipulation</h4></div></div></div><p>Strings can be <a id="id52" class="indexterm"/>manipulated in a number of ways in Python. String concatenation is one of the more commonly used functions and is simple to accomplish. The <code class="literal">+</code> operator<a id="id53" class="indexterm"/> is used with string variables on either side of the operator to produce a new string variable that ties the two string variables together:</p><div class="informalexample"><pre class="programlisting">shpStreets = "c:\\GISData\\Streets" + ".shp"
print shpStreets</pre></div><p>Running this code example produces the following result:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt;c:\GISData\Streets.shp</pre></div><p>String equality can be tested using Python's <code class="literal">==</code> operator<a id="id54" class="indexterm"/>, which is simply two equal signs placed together. Don't confuse the equality operator with the assignment operator, which is a single equal to sign. The equality operator tests two variables for equality, while the assignment operator assigns a value to a variable:</p><div class="informalexample"><pre class="programlisting">firstName = "Eric"
lastName = "Pimpler"
firstName == lastname</pre></div><p>Running this code<a id="id55" class="indexterm"/> example produces the following result:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt;False</pre></div><p>Strings can be tested for containment using the <code class="literal">in</code> operator, which returns <code class="literal">True</code> if the first operand is contained in the second.</p><div class="informalexample"><pre class="programlisting">fcName = "Floodplain.shp"
print ".shp" in fcName
&gt;&gt;&gt;True</pre></div><p>I briefly mentioned that strings are an ordered collection of characters. What does this mean? It simply means that we can access individual characters or a series of characters from the string. In Python, this is referred to as <span class="strong"><strong>indexing</strong></span>
<a id="id56" class="indexterm"/> in the case of accessing an individual character, and <span class="strong"><strong>slicing</strong></span>
<a id="id57" class="indexterm"/> in the case of accessing a series of characters.</p><p>Characters in a string are obtained by providing the numeric offset contained within square brackets after a string. For example, you could obtain the first string character in the <code class="literal">fc</code> variable by using the syntax <code class="literal">fc[0]</code>. Negative offsets can be used to search backwards from the end of a string. In this case, the last character in a string is stored at index <code class="literal">-1</code>. Indexing always creates a new variable to hold the character:</p><div class="informalexample"><pre class="programlisting">fc = "Floodplain.shp"
print fc[0]
&gt;&gt;&gt;'F'
print fc[10]
&gt;&gt;&gt;'.'
print fc[13]
&gt;&gt;&gt;'p'</pre></div><p>The following image illustrates how strings are an ordered collection of characters with the first character occupying position <span class="strong"><strong>0</strong></span>, the second character occupying position <span class="strong"><strong>1</strong></span>, and each successive character occupying the next index number:</p><div class="mediaobject"><img src="images/4445_01_6.jpg" alt="String manipulation"/></div><p>While string indexing allows you to obtain a single character from a string variable, string slicing enables you to extract a contiguous sequence of strings. The format and syntax is similar to indexing, but with the addition of a second offset, which is used to tell Python how many characters to return. </p><p>The following code <a id="id58" class="indexterm"/>example provides an example of string slicing. The <code class="literal">theString</code> variable has been assigned a value of <code class="literal">Floodplain.shp</code>. To obtain a sliced variable with the contents of <code class="literal">Flood</code>, you would use the <code class="literal">theString[0:5]</code> syntax:</p><div class="informalexample"><pre class="programlisting">theString = "Floodplain.shp"
print theString[0:5]
&gt;&gt;&gt;Flood</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>Python slicing returns the characters beginning with the first offset up to, but not including, the second offset. This can be particularly confusing for new Python programmers and is a common source of error. In our example, the returned variable will contain the characters <code class="literal">Flood</code>. The first character, which occupies position <code class="literal">0</code>, is <code class="literal">F</code>. The last character returned is index <code class="literal">4</code>, which corresponds to the character <code class="literal">d</code>. Notice that index number <code class="literal">5</code> is not included since Python slicing only returns characters up to but not including the second offset.</p></div></div><p>Either of the offsets can be left off. This in effect creates a wild card. In the case of <code class="literal">theString[1:]</code>, you are telling Python to return all characters starting from the second character to the end of the string. In the second case, <code class="literal">theString[:-1]</code>, you are telling Python to start at character zero and return all characters except the last. </p><p>Python is an excellent language for manipulating strings and there are many additional functions that you can use to process this type of data. Most of these are beyond the scope of this text, but in general all of the following string manipulation functions<a id="id59" class="indexterm"/> are available:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">String length</li><li class="listitem" style="list-style-type: disc">Casing functions for conversion to upper and lower case</li><li class="listitem" style="list-style-type: disc">Removal of leading and trailing whitespace</li><li class="listitem" style="list-style-type: disc">Finding a character within a string</li><li class="listitem" style="list-style-type: disc">Replacement of text</li><li class="listitem" style="list-style-type: disc">Splitting into a list of words based on a delimiter</li><li class="listitem" style="list-style-type: disc">Formatting</li></ul></div></div></div><div class="section" title="Numbers"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec02"/>Numbers</h3></div></div></div><p>Python also has <a id="id60" class="indexterm"/>built-in support for <a id="id61" class="indexterm"/>numeric data including <code class="literal">int</code>, <code class="literal">long</code>, <code class="literal">float</code>, and <code class="literal">complex</code> values. Numbers are assigned to variables in much the same way as strings, with the exception that you do not enclose the value in quotes and obviously it must be a numeric value. </p><p>Python supports all the commonly used numeric operators including addition, subtraction, multiplication, division, and modulus or remainder. In addition, functions for returning the absolute value, conversion of strings to numeric datatypes, and rounding are also available.</p><p>Although Python<a id="id62" class="indexterm"/> provides a<a id="id63" class="indexterm"/> few built-in mathematical functions, the <code class="literal">math</code> module can be used to access a wide variety of more advanced <code class="literal">math</code> functions. To use these functions, you must specifically import the <code class="literal">math</code> module as follows:</p><div class="informalexample"><pre class="programlisting">import math</pre></div><p>Functions provided by the <code class="literal">math</code> module<a id="id64" class="indexterm"/> include those for returning the ceiling and floor of a number, the absolute value, trigonometric functions, logarithmic functions, angular conversion, and hyperbolic functions.</p></div><div class="section" title="Lists"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec03"/>Lists</h3></div></div></div><p>A third built-in <a id="id65" class="indexterm"/>datatype provided by Python is the <code class="literal">list</code>. <a id="id66" class="indexterm"/>A list is an ordered collection of objects that can hold any type of data supported by Python as well as being able to hold multiple datatypes at the same time. This could be numbers, strings, other lists, dictionaries, or objects. So, for instance, a list variable could hold numeric and string data at the same time. Lists are zero-based, with the first element in the list occupying position <code class="literal">0</code>. Each successive object in the list is incremented by one. In addition, lists have the special capability of dynamically growing and shrinking.</p><p>Lists are created by assigning a series of values enclosed by brackets. To pull a value from a list, simply use an integer value in brackets along with the variable name. The following code example provides an illustration of this. You can also use slicing with lists to return multiple values. <span class="strong"><strong>Slicing</strong></span>
<a id="id67" class="indexterm"/> a list always returns a new list variable. </p><div class="informalexample"><pre class="programlisting">fcList = ["Hydrants", "Water Mains", "Valves", "Wells"]
fc = fcList[0]
print fc
&gt;&gt;&gt;Hydrants
fc = fcList[3]
print fc
&gt;&gt;&gt;Wells</pre></div><p>Lists are dynamic in nature, enabling them to grow, shrink, and change contents. This is all done without the need to create a new copy of the list. Changing values in a list can be accomplished either through indexing or slicing. Indexing allows you to change a single value, while slicing allows you to change multiple list items. </p><p>Lists have a number of methods that allow you to manipulate the values that are part of the list. You can sort the contents of the list in either an ascending or descending order through the use of the<a id="id68" class="indexterm"/> <code class="literal">sort()</code> method. Items can be added to a list with the <code class="literal">append()</code> method,<a id="id69" class="indexterm"/> which adds an object to the end of the list, and with the <code class="literal">insert()</code> method<a id="id70" class="indexterm"/> which inserts an object at a position within the list. Items can be removed from a list with the <code class="literal">remove()</code> method<a id="id71" class="indexterm"/> which removes the first occurrence of a value from the list, or <code class="literal">the pop()</code> method<a id="id72" class="indexterm"/> which removes <a id="id73" class="indexterm"/>and returns the object last added to the list. The <a id="id74" class="indexterm"/>contents of the list can also be reversed with the<a id="id75" class="indexterm"/> <code class="literal">reverse()</code> method.</p></div><div class="section" title="Tuples"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec04"/>Tuples</h3></div></div></div><p>Tuples <a id="id76" class="indexterm"/>are similar <a id="id77" class="indexterm"/>to lists but with some important differences. Just like lists, tuples contain a sequence of values. The only difference is that tuples can't be changed, and they are referred to with parentheses instead of square brackets. Creating a tuple is as simple as placing a number of comma-separated values inside parentheses, as shown in the following code example:</p><div class="informalexample"><pre class="programlisting">fcTuples = ("Hydrants", "Water Mains", "Valves", "Wells")</pre></div><p>Like lists, tuple indices start with an index value of <code class="literal">0</code>. Access to values stored in a tuple occurs in the same way as lists. This is illustrated in the following code example:</p><div class="informalexample"><pre class="programlisting">fcTuples = ("Hydrants", "Water Mains", "Valves", "Wells")
print fcTuples[1]
&gt;&gt;&gt;Water Mains</pre></div><p>Tuples are typically used in place of a list when it is important for the contents of the structure to be static. You can't insure this with a list, but you can with a tuple.</p></div><div class="section" title="Dictionaries"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec05"/>Dictionaries</h3></div></div></div><p>Dictionaries <a id="id78" class="indexterm"/>are a second type of <a id="id79" class="indexterm"/>collection object in Python. They are similar to lists, except that dictionaries are an unordered collection of objects. Instead of fetching objects from the collection through the use of an offset, items in a dictionary are stored and fetched by a key. Each key in a dictionary has an associated value. Similar to lists, dictionaries can grow and shrink in place through the use of methods on the <code class="literal">dictionary</code> class. In the following code example, you will learn to create and populate a dictionary and see how values can be accessed through the use of a key. Dictionaries are created with the use of curly braces. Inside these braces each key is surrounded by quotes followed by a colon and then a value that is associated with the key. These key/value pairs are separated by commas:</p><div class="informalexample"><pre class="programlisting">##create the dictionary
dictLayers = {'Roads': 0, 'Airports': 1, 'Rail': 2}

##access the dictionary by key
dictLayers['Airports']
&gt;&gt;&gt;1
dictLayers['Rail']
&gt;&gt;&gt;2</pre></div><p>Basic <a id="id80" class="indexterm"/>dictionary operations include getting the number of items in a dictionary, getting a value using the key, determining if a key exists, converting the keys to a list, and getting a list of values. Dictionary objects can be changed, expanded, and shrunk in place. <a id="id81" class="indexterm"/>What this means is that Python does not have to create a new <code class="literal">dictionary</code> object to hold the altered version of the dictionary. Assigning values to a dictionary key is accomplished by stating the key value in brackets and setting it equal to some value.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>Unlike lists, dictionaries can't be sliced due to the fact that their contents are unordered. Should you have the need to iterate over all values in a dictionary, simply use the<a id="id82" class="indexterm"/> <code class="literal">keys()</code> method, which returns a collection of all the keys in the dictionary and which can then be used individually to set or get the value.</p></div></div></div></div><div class="section" title="Classes and objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>Classes and objects</h2></div></div></div><p>Classes<a id="id83" class="indexterm"/> and <a id="id84" class="indexterm"/>objects are a fundamental concept in object-oriented programming. While Python is more of a procedural language, it also supports object-oriented programming. In object-oriented programming, classes are used to create object instances. You can think of classes as blueprints for the creation of one or more objects. Each object instance has the same properties and methods, but the data contained in an object can and usually will differ. Objects <a id="id85" class="indexterm"/>are complex datatypes in<a id="id86" class="indexterm"/> Python composed of properties and methods, and can be assigned to variables just like any other datatype. Properties contain data associated with an object, while methods are actions that an object can perform. </p><p>These concepts are best illustrated with an example. In ArcPy, the <code class="literal">Extent</code> class is a rectangle specified by providing the coordinate of the lower-left corner and the coordinate of the upper-right corner in map units. The <code class="literal">Extent</code> class<a id="id87" class="indexterm"/> contains a number of properties and methods. Properties include<a id="id88" class="indexterm"/> <code class="literal">XMin</code>,<a id="id89" class="indexterm"/> <code class="literal">XMax</code>,<a id="id90" class="indexterm"/> <code class="literal">YMin</code>, and<a id="id91" class="indexterm"/> <code class="literal">YMax</code>, <code class="literal">spatialReference</code>, and others. The minimum and maximum of x and y properties provide the coordinates for the extent rectangle. The <code class="literal">spatialReference</code> property<a id="id92" class="indexterm"/> holds a reference to a <code class="literal">SpatialReference</code> object for the <code class="literal">Extent</code>. Object instances of the <code class="literal">Extent</code> class can be used both to set and get the values of these properties through dot notation. An example of this is seen in the following code example:</p><div class="informalexample"><pre class="programlisting">import arcpy
fc = "c:/ArcpyBook/data/TravisCounty/TravisCounty.shp"

# Fetch each feature from the cursor and examine the extent properties and spatial reference
for row in arcpy.da.SearchCursor(fc, ["SHAPE@"]):
  # get the extent of the county boundary
  ext = row[0].extent
  # print out the bounding coordinates and spatial reference
  print "XMin: " + ext.XMin
  print "XMax: " + ext.XMax
  print "YMin: " + ext.YMin
  print "YMax: " + ext.YMax
  print "Spatial Reference: " + ext.spatialReference.name</pre></div><p>Running this script yields the following output:</p><div class="informalexample"><pre class="programlisting">XMin: 2977896.74002
XMax: 3230651.20622
YMin: 9981999.27708
YMax:10200100.7854
Spatial Reference: NAD_1983_StatePlane_Texas_Central_FIPS_4203_Feet</pre></div><p>The <code class="literal">Extent</code> class<a id="id93" class="indexterm"/> also has<a id="id94" class="indexterm"/> a number <a id="id95" class="indexterm"/>of methods, which are actions that an object can perform. In the case of this particular object, most of the methods are related to performing some sort of geometric test between the <code class="literal">Extent</code> object and another geometry. Examples include<a id="id96" class="indexterm"/> <code class="literal">contains()</code>, <a id="id97" class="indexterm"/>
<code class="literal">crosses()</code>,<a id="id98" class="indexterm"/> <code class="literal">disjoint()</code>,<a id="id99" class="indexterm"/> <code class="literal">equals()</code>,<a id="id100" class="indexterm"/> <code class="literal">overlaps()</code>,<a id="id101" class="indexterm"/> <code class="literal">touches()</code>,and<a id="id102" class="indexterm"/> <code class="literal">within()</code>. </p><p>One additional object-oriented concept that you need to understand is dot notation. <span class="strong"><strong>Dot notation</strong></span> <a id="id103" class="indexterm"/> provides a way of accessing the properties and methods of an object. It is used to indicate that a property or method belongs to a particular class. </p><p>The syntax for using the dot notation includes an object instance followed by a dot and then the property or method. The syntax is the same regardless of whether you're accessing a property or a method. A parenthesis, and zero or more parameters, at the end of the word following the dot indicates that a method is being accessed. Here are a couple of examples to better illustrate this concept:</p><div class="informalexample"><pre class="programlisting">Property: extent.XMin
Method: extent.touches()</pre></div></div><div class="section" title="Statements"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec16"/>Statements</h2></div></div></div><p>Each line <a id="id104" class="indexterm"/>of code that you write with Python is known as a <a id="id105" class="indexterm"/> <span class="strong"><strong>statement</strong></span>. There are many different kinds of statements, including those that create and assign data to variables, decision support statements that branch your code based on a test, looping statements that execute a code block multiple times, and others. There are various rules that your code will need to follow as you create the statements that are part of your script. You've already encountered one type of statement: variable creation and assignment. </p><div class="section" title="Decision support statements"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec06"/>Decision support statements</h3></div></div></div><p>The <code class="literal">if</code>/<code class="literal">elif</code>/<code class="literal">else</code> statement<a id="id106" class="indexterm"/> is <a id="id107" class="indexterm"/>
<a id="id108" class="indexterm"/>the primary decision making statement in Python and tests for a true/false condition. Decision statements enable you to control the flow of your programs. Here are some example decisions that you can make in your code: if the variable holds a point feature class, get the X, Y coordinates; if the feature class name equals <code class="literal">Roads</code> then get the <code class="literal">Name</code> field.</p><p>Decision statements such as <code class="literal">if</code>/<code class="literal">elif</code>/<code class="literal">else</code> test for a true/false condition. In Python, a "true" value means any nonzero number or nonempty object. A "false" value indicates "not true" and is represented in Python with a zero number or empty object. Comparison tests return values of one or zero (true or false). Boolean and/or operators return a true or false operand value.</p><div class="informalexample"><pre class="programlisting">if fcName == 'Roads':
  gp.Buffer_analysis(fc, "c:\\temp\\roads.shp", 100)
elif fcName == 'Rail':
  gp.Buffer_analysis(fc, "c:\\temp\\rail.shp", 50)
else:
  print "Can't buffer this layer"
)</pre></div><p>Python code must follow certain syntax rules. Statements execute one after another, until your code branches. Branching typically occurs through the use of <code class="literal">if</code>/<code class="literal">elif</code>/<code class="literal">else</code>. In addition, the use of looping structures, such as <code class="literal">for </code> <a id="id109" class="indexterm"/>and <code class="literal">while</code>, <a id="id110" class="indexterm"/>can alter the statement flow. Python automatically detects statement and block boundaries, so there is no need for braces or delimiters around your blocks of code. Instead, indentation is used to group statements in a block. Many languages terminate statements with the use of a semicolon, but Python simply uses the end of line character to mark the end of a statement. Compound statements<a id="id111" class="indexterm"/> include a "<code class="literal">:</code>" character. Compound statements follow the pattern: header terminated by a colon. Blocks of code are then written as individual statements and are indented underneath the header. </p><p>Statement indentation<a id="id112" class="indexterm"/> deserves a special mention as it is critical to the way Python interprets code. As I mentioned, a contiguous section of code is detected by Python through the use of indentation. By default, all Python statements should be left-justified until looping, decision support, <code class="literal">try</code>/<code class="literal">except</code>, and <code class="literal">with</code> statements are used. This includes <code class="literal">for</code> and <code class="literal">while</code> loops, <code class="literal">if</code>/<code class="literal">else</code> statements, <code class="literal">try</code>/<code class="literal">except</code> statements, and <code class="literal">with</code> statements. All statements <a id="id113" class="indexterm"/>
<a id="id114" class="indexterm"/>indented with the same distance belong to the same block of code until that block is ended by a line less indented. </p></div><div class="section" title="Looping statements"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec07"/>Looping statements</h3></div></div></div><p>Looping statements allow <a id="id115" class="indexterm"/>
<a id="id116" class="indexterm"/>your program to repeat lines of code over and over as necessary. <code class="literal">while</code> loops repeatedly execute a block of statements as long as the test at the top of the loop evaluates to true. When the condition test evaluates to false, Python begins interpreting code immediately after the <code class="literal">while</code> loop<a id="id117" class="indexterm"/>. In the next code example, a value of <code class="literal">10</code> has been assigned to the variable<code class="literal"> x</code>. The test for the <code class="literal">while</code> loop then checks to see if <code class="literal">x</code> is less than <code class="literal">100</code>. If <code class="literal">x</code> is less than <code class="literal">100</code> the current value of <code class="literal">x</code> is printed to the screen and the value of <code class="literal">x</code> is incremented by <code class="literal">10</code>. Processing then continues with the <code class="literal">while</code> loop test. The second time, the value of <code class="literal">x</code> will be 20; so the test evaluates to true once again. This process continues until <code class="literal">x</code> is larger than <code class="literal">100</code>. At this time, the test will evaluate to false and processing will stop. It is very important that your <code class="literal">while</code> statements have some way of breaking out of the loop. Otherwise, you will wind up in an infinite loop. An infinite loop is a sequence of instructions in a computer program that loops endlessly, either due to the loop having no terminating condition, having one that can never be met, or one that causes the loop to start over:</p><div class="informalexample"><pre class="programlisting">x = 10
while x &lt; 100:
 print x
 x = x + 10</pre></div><p>
<code class="literal">for</code> loops execute a block of statements a predetermined number of times. They come in two varieties—a counted loop for running a block of code a set number of times, and a list loop that enables you to loop through all objects in a list. The list loop in the following example executes once for each value in the dictionary and then stops looping: </p><div class="informalexample"><pre class="programlisting">dictLayers = {"Roads":"Line","Rail":"Line","Parks":"Polygon"}
lstLayers = dictLayers.keys()
for x in lstLayers:
  print dictLayers[x]</pre></div><p>There are times when it will be necessary for you to break out of the execution of a loop. The <code class="literal">break</code> <a id="id118" class="indexterm"/>and <code class="literal">continue</code> statements <a id="id119" class="indexterm"/>can be used to do this. <code class="literal">break</code> jumps out of the closest enclosing loop while <code class="literal">continue</code> jumps back to the top of the closest enclosing loop. These statements can appear anywhere inside the block of code. </p></div><div class="section" title="Try statements"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec08"/>Try statements</h3></div></div></div><p>A <code class="literal">try</code> statement<a id="id120" class="indexterm"/>
<a id="id121" class="indexterm"/> is a complete, compound statement that is used to handle exceptions. Exceptions are a high-level control device used primarily for error interception or triggering. Exceptions in Python can either be intercepted or triggered. When an error condition occurs in your code, Python automatically triggers an exception, which may or may not be handled by your code. It is up to you as a programmer to catch an automatically triggered exception. Exceptions can also be triggered manually by your code. In this case, you would also provide an exception handling routine to catch these manually triggered exceptions. </p><p>There are two basic types of try statements: <code class="literal">try</code>/<code class="literal">except</code>/<code class="literal">else</code> and <code class="literal">try</code>/<code class="literal">finally</code>. The basic <code class="literal">try</code> statement starts with a <code class="literal">try</code> header line followed by a block of indented statements, then one or more optional except clauses that name exceptions to be caught, and an optional <code class="literal">else</code> clause at the end:</p><div class="informalexample"><pre class="programlisting">import arcpy
import sys

inFeatureClass = arcpy.GetParameterAsText(0)
outFeatureClass = arcpy.GetParameterAsText(1)

try:
  # If the output feature class exists, raise an error
  
  if arcpy.Exists(inFeatureClass):
    raise overwriteError(outFeatureClass)
  else:
    # Additional processing steps
    

except overwriteError as e:
  # Use message ID 12, and provide the output feature class
  #  to complete the message.
  
  arcpy.AddIDMessage("Error", 12, str(e))</pre></div><p>The <code class="literal">try</code>/<code class="literal">except</code>/<code class="literal">else</code> statement<a id="id122" class="indexterm"/> works as follows. Once inside a <code class="literal">try</code> statement, Python marks the fact that you are in a <code class="literal">try</code> block and knows that any exception condition that occurs at this point will be sent to the various <code class="literal">except</code> statements for handling. If a matching exception is found, the code block inside the <code class="literal">except</code> block is executed. The code then picks up below the full <code class="literal">try</code> statement. The <code class="literal">else</code> statements are not executed in this case. Each statement inside the <code class="literal">try</code> block is executed. Assuming that no exception conditions occur, the code pointer will then jump to the <code class="literal">else</code> statement and execute the code block contained by the <code class="literal">else</code> statement before moving to the next line of code below the try block. </p><p>The other type of <code class="literal">try</code> statement is the <code class="literal">try</code>/<code class="literal">finally</code> statement which allows for finalization actions. When a <code class="literal">finally</code> clause is used in a <code class="literal">try</code> statement, its block of statements always run at the very end, whether an error condition occurs or not. </p><p>The <code class="literal">try</code>/<code class="literal">finally</code> <a id="id123" class="indexterm"/>
<a id="id124" class="indexterm"/>statement works as <a id="id125" class="indexterm"/>follows. If an exception occurs, Python runs the <code class="literal">try</code> block, then the <code class="literal">finally</code> block, and then execution continues past the entire <code class="literal">try</code> statement. If an exception does not occur during execution, Python runs the <code class="literal">try</code> block, then the <code class="literal">finally</code> block. This is useful when you want to make sure an action happens after a code block runs, regardless of whether an error condition occurs. Cleanup operations, such as closing a file or a connection to a database are commonly placed inside a <code class="literal">finally</code> block to ensure that they are executed regardless of whether an exception occurs in your code:</p><div class="informalexample"><pre class="programlisting">import arcpy
from arcpy import env

try:
  if arcpy.CheckExtension("3D") == "Available":
    arcpy.CheckOutExtension("3D")
  else:
    # Raise a custom exception
    raise LicenseError
  
  env.workspace = "D:/GrosMorne"
  arcpy.HillShade_3d("WesternBrook", "westbrook_hill", 300)
  arcpy.Aspect_3d("WesternBrook", "westbrook_aspect")

except LicenseError:
  print "3D Analyst license is unavailable" 
except:
  print arcpy.GetMessages(2)
finally:
  # Check in the 3D Analyst extension
  arcpy.CheckInExtension("3D")</pre></div></div><div class="section" title="with statements"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec09"/>with statements</h3></div></div></div><p>The <code class="literal">with</code> statement<a id="id126" class="indexterm"/>
<a id="id127" class="indexterm"/> is handy when you have two related operations that need to be executed as a pair with a block of code in between. A common scenario for using <code class="literal">with</code> statements is opening, reading, and closing a file. Opening and closing a file are the related operations, and reading a file and doing something with the contents is the block of code in between. When writing geoprocessing scripts with ArcGIS, the new <code class="literal">cursor</code> objects introduced with version 10.1 of ArcGIS are ideal for using <code class="literal">with</code> statements. We'll discuss <code class="literal">cursor</code> objects in great detail in a later chapter, but I'll briefly describe these objects now. Cursors are an in-memory copy of records from the attribute table of a feature class or table. There are various types of cursors. Insert cursors allow you to insert new records, search cursors are a read-only copy of records, and update cursors allow you to edit or delete records. Cursor objects are opened, processed in some way, and closed automatically using a <code class="literal">with</code> statement. </p><p>The closure of a file or cursor object is handled automatically by the <code class="literal">with</code> statement resulting in cleaner, more efficient coding. It's basically like using a <code class="literal">try</code>/<code class="literal">finally</code> block but with fewer lines of code. In the following code example, the <code class="literal">with</code> block is used to create a new search cursor, read information from the cursor, and implicitly close the cursor:</p><div class="informalexample"><pre class="programlisting">import arcpy

fc = "c:/data/city.gdb/streets"

# For each row print the Object ID field, and use the SHAPE@AREA
# token to access geometry properties

<span class="strong"><strong>with arcpy.da.SearchCursor(fc, ("OID@", "SHAPE@AREA")) as cursor:</strong></span>
  for row in cursor:
    print("Feature {0} has an area of {1}".format(row[0], row[1]))</pre></div></div></div><div class="section" title="File I/O"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec17"/>File I/O</h2></div></div></div><p>You will often find it necessary <a id="id128" class="indexterm"/>
<a id="id129" class="indexterm"/>to retrieve or write information to files on your computer. Python has a built-in object type that provides a way to access files for many tasks. We're only going to cover a small subset of the file manipulation functionality provided, but we'll touch on the most commonly used functions including opening and closing files, and reading and writing data to a file.</p><p>Python's <code class="literal">open()</code> function creates a file object, which serves as a link to a file residing on your computer. You must call the <code class="literal">open()</code> function<a id="id130" class="indexterm"/> on a file before reading and/or writing data to a file. The first parameter for the <code class="literal">open()</code> function is a path to the file you'd like to open. The second parameter corresponds to a mode, which is typically read (<code class="literal">r</code>), write (<code class="literal">w</code>), or append (<code class="literal">a</code>). A value of <code class="literal">r</code> indicates that you'd like to open the file for read only operations, while a value of <code class="literal">w</code> indicates you'd like to open the file for write operations. In the event that you open a file that already exists for write operations, this will overwrite any data currently in the file, so you must be careful with write mode. Append mode (<code class="literal">a</code>) will open a file for write operations, but instead of overwriting any existing data, it will append the new data to the end of the file. The following code example shows the use of the <code class="literal">open()</code> function for opening a text file in a read-only mode:</p><div class="informalexample"><pre class="programlisting">f = open('Wildfires.txt','r')</pre></div><p>After you've completed read/write operations on a file, you should always close the file with the<a id="id131" class="indexterm"/> <code class="literal">close()</code> method.</p><p>After a file has been opened, data can be read from it in a number of ways and using various methods. The most typical scenario would be to read data one line at a time from a file through the<a id="id132" class="indexterm"/> <code class="literal">readline()</code> method. <code class="literal">readline()</code> can be used to read the file one line at a time into a string variable. You would need to create a looping mechanism in your <a id="id133" class="indexterm"/>
<a id="id134" class="indexterm"/>Python code to read the entire file line by line. If you would prefer to read the entire file into a variable, you can use the<a id="id135" class="indexterm"/> <code class="literal">read()</code> method, which will read the file up to the <span class="strong"><strong>end of file</strong></span> (<span class="strong"><strong>EOF</strong></span>) marker<a id="id136" class="indexterm"/>. You can also use the <code class="literal">readlines()</code> method<a id="id137" class="indexterm"/> to read the entire contents of a file, separating each line into individual strings, until the EOF is found. </p><p>In the following code example, we have opened a text file called <code class="literal">Wildfires.txt</code> in read-only mode and used the <code class="literal">readlines()</code> method on the file to read its entire contents into a variable called <code class="literal">lstFires</code>, which is a Python list containing each line of the file as a separate string value in the list. In this case, the <code class="literal">Wildfire.txt</code> file is a comma-delimited text file containing the latitude and longitude of the fire along with the confidence values for each file. We then loop through each line of text in <code class="literal">lstFires</code> and use the <code class="literal">split()</code> function<a id="id138" class="indexterm"/> to extract the values based on a comma as the delimiter, including the latitude, longitude, and confidence values. The latitude and longitude values are used to create a new <code class="literal">Point</code> object, which is then inserted into the feature class using an insert cursor:</p><div class="informalexample"><pre class="programlisting">import arcpy, os
try:
 
  arcpy.env.workspace = "C:/data/WildlandFires.mdb"
  # open the file to read
  f = open('Wildfires.txt','r')

<span class="strong"><strong>  lstFires = f.readlines()</strong></span>
  cur = arcpy.InsertCursor("FireIncidents")
  
  for fire in lstFires:
    if 'Latitude' in fire:
      continue
    vals = fire.split(",")
    latitude = float(vals[0])
    longitude = float(vals[1])
    confid = int(vals[2])
    pnt = arcpy.Point(longitude,latitude)
    feat = cur.newRow()
    feat.shape = pnt
    feat.setValue("CONFIDENCEVALUE", confid)
    cur.insertRow(feat)
    except:
  print arcpy.GetMessages()
finally:
	del cur
	f.close()</pre></div><p>Just as is the case <a id="id139" class="indexterm"/>
<a id="id140" class="indexterm"/>with reading files, there are a number of methods that you can use to write data to a file. The <code class="literal">write()</code> function<a id="id141" class="indexterm"/> is probably the easiest to use and takes a single string argument and writes it to a file. The <code class="literal">writelines()</code> function<a id="id142" class="indexterm"/> can be used to write out the contents of a list structure to a file. In the following code example, we have created a list structure called <code class="literal">fcList</code>, which contains a list of feature classes. We can write this list to a file using the <code class="literal">writelines()</code> method:</p><div class="informalexample"><pre class="programlisting">outfile = open('c:\\temp\\data.txt','w')
fcList = ["Streams", "Roads", "Counties"]
outfile.writelines(fcList)</pre></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Summary</h1></div></div></div><p>In this chapter, we covered some of the fundamental Python programming concepts that you'll need to understand before you can write effective geoprocessing scripts. We began the chapter with an overview of the IDLE development environment for writing and debugging Python scripts. You learned how to create a new script, edit existing scripts, check for syntax errors, and execute the script. We also covered the basic language constructs including importing modules, creating and assigning variables, if/else statements, looping statements, and the various data-types including strings, numbers, Booleans, lists, dictionaries, and objects. You also learned how to read and write text files.</p><p>In the next chapter, you will learn the basic techniques for writing geoprocessing scripts for ArcGIS with Python. You'll learn how to use the embedded Python window in ArcGIS Desktop, import the ArcPy package to your scripts, execute <code class="literal">ArcToolbox</code> tools from your scripts, use the help system when writing scripts, use variables to store data, and access the various ArcPy modules.</p></div></div>
</body></html>