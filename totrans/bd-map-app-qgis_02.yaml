- en: Chapter 2. The QGIS Python Console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the ways in which you can use the QGIS Python
    Console as a geospatial development tool. We will also use the console as a looking-glass
    to examine the world of QGIS programming. In particular, we will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Explore the ways in which the console can be used to develop and execute Python
    code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to write Python scripts using the console's built-in source code editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discover various tips and techniques to work with the QGIS Console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Figure out how to manipulate the current project within QGIS using Python commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access geospatial data and perform geospatial calculations using the console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use various QGIS user-interface elements within our Python programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While you briefly used the QGIS Console in the previous chapter, it is worth
    examining the QGIS Console window in more detail, so that you are aware of the
    various features that are available.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t already have it open, choose the **Python Console** item from
    the **Plugins** menu to open the console. The following screenshot shows the various
    parts of the console window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the console](img/00010.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a closer look at these various parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Clear console** button wipes out the contents of the interpreter log
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Import Class** pop up contains shortcuts to import some commonly-used
    PyQGIS classes![Using the console](img/00011.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are equivalent to typing `import Processing`, `from PyQt4.QtCore import
    *`, and `from PyQt4.QtGui import *`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The **Run command** button simply executes the command you have typed in the
    Python shell field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course, you can also run the entered command by pressing the *Return* key,
    so this command is only useful if you really want to run a command using the mouse.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The **Show editor** button shows or hides the built-in source code editor. We'll
    look at this shortly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Settings** button displays the console's Settings window, allowing you
    to customize the way the console looks and behaves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Help** button brings up the built-in help viewer page, which contains
    useful information about how to use the console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Python Shell** field is where you type your Python commands and other
    input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Interpreter Log** shows a complete history of the commands you have typed
    and the Python interpreter's output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we've already seen, you can type Python commands in the shell and press the
    *Return* key to execute them. The commands you type, along with the Python interpreter's
    output, appear in the Interpreter Log.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python Shell has been designed to make it easier to work with Python interactively.
    The following features are currently supported:'
  prefs: []
  type: TYPE_NORMAL
- en: Pressing the up and down arrow keys will move through the command history, making
    it easy to re-enter the Python commands you typed earlier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can display a list of previously-entered commands by pressing *Ctrl* + *Shift*
    + *Space* (*command* + *Shift* + *Space* on Mac).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you select some text in the Interpreter Log, you can use the **Enter Selected**
    command to move that text to the shell and execute it. This command is available
    in the console's pop-up menu, or it can be accessed by pressing *Ctrl* + *E* (*command*
    + *E* if you are running Mac OS X).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Python Shell supports **auto-completion**. As you type, a pop-up menu appears,
    showing you the matching class, function, and method names within the PyQGIS and
    PyQt APIs. You can then press the up and down arrow keys to select the exact name
    you want, and press the *Tab* key to select it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you type an opening parenthesis, the console automatically enters the closing
    parenthesis for you. You can turn this off by using the **Settings** window if
    you wish.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you type `from XXX`, the console enters the word `import` for you automatically.
    Once again, you can turn this off in the **Settings** window if you don't like
    this behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you type the opening parenthesis for a function or method, the C++ signature
    for that function or method will be displayed. Despite being in C++ format, this
    tells you which parameters are expected and the type of value being returned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can type `_api` into the shell; your web browser will open the PyQGIS API
    reference documentation. Similarly, if you type `_pyqgis`, your web browser will
    display the PyQGIS Developer Cookbook.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While typing commands into the Python Shell is a useful way of exploring the
    QGIS Python libraries, and is good for one-off commands, it quickly gets tedious
    if you have to type multiple lines of Python text or repeat the same set of commands
    over and over. After all, this is why we store Python code in `.py` files and
    execute them, rather than just typing everything into the Python command-line
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: The QGIS Console comes with its own editor, allowing you to write Python scripts
    and execute them directly within the console. Let's take a quick look at how this
    works.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the QGIS Console open, click on the **Show Editor** icon (![Using the
    console](img/00012.jpeg)). The console window will be split in half, with the
    Python source code editor now taking up the right-hand side of the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the console](img/00013.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The various toolbar icons provide standard editing behavior such as loading
    and saving files, copying and pasting text, checking syntax, and executing your
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the console](img/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You'll probably want to memorize the top three icons as there are currently
    no keyboard shortcuts to open and save Python scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the console editor to create a simple Python program and run it.
    With a QGIS project loaded, type the following into the editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can probably guess, this program prints out the names of the various
    layers within the current project. To run this program, save it by clicking on
    the **Save As...** toolbar icon; then, either click on the **Run script** toolbar
    icon (![Using the console](img/00015.jpeg)), or type the keyboard shortcut, *Ctrl*
    + *Shift* + *E* (that''s *command* + *Shift* + *E* on Mac). You should see something
    like the following appear in the Interpreter Log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that QGIS uses the `execfile()` function (which is part of the Python standard
    library) to execute your script.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your program didn't display the names of any layers, make sure you have a
    project loaded with at least one layer. In this example, we've used the example
    project we created in the previous chapter, which had three layers in it.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there is a lot more that we can do with the QGIS Console and its
    built-in Python editor, and we'll be using it to do useful work shortly. Before
    we do, though, there are two final things you should know about the QGIS Console.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, the console itself is written in Python using PyQt and the `PyQScintilla2`
    editor. You can learn a lot about how QGIS has been implemented by looking through
    the source code to the console, which is available at [https://github.com/qgis/QGIS/tree/master/python/console](https://github.com/qgis/QGIS/tree/master/python/console).
  prefs: []
  type: TYPE_NORMAL
- en: 'The second thing you should know is that the console is implemented as a Qt
    "Dockable" window; that is, it can be dragged into a pane within the main QGIS
    window. If you click and hold the console''s title bar, you can drag it inside
    the main window, as shown in the following illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the console](img/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The console can be moved into any of the existing panes within the QGIS window,
    and it will stay there until you move it out.
  prefs: []
  type: TYPE_NORMAL
- en: To turn the console into a window again, click on the title bar and drag it
    out of the QGIS window. Alternatively, you can double-click on the console's title
    bar to switch between having it as a standalone window or a docked pane.
  prefs: []
  type: TYPE_NORMAL
- en: 'This docking behavior can be annoying if you''re working on a small screen,
    where you can accidentally dock the console window while moving it out of the
    way so you can see what is beneath it. Fortunately, since the QGIS Console is
    implemented in PyQt, you can disable this quite easily by running the following
    Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want, you can create a startup script that automatically shows the console
    and makes it nondockable whenever QGIS starts up. The startup script is stored
    in a hidden directory in your user or home folder. Using your file manager, look
    for a hidden directory named `.qgis2` (or `.qgis`, depending on which version
    of QGIS you are running) in your user or home directory (for Mac OS X, you can
    use the **Go to Folder...** item in the Finder''s **Go** menu). Inside this directory,
    there will be a subdirectory named `python`. Inside the `python` directory, create
    a file named `startup.py` and place the following into this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the only thing we changed was to add a call to `console.show_console()`
    to open the console window when QGIS starts.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the console is currently docked, this script won't undock it, although it
    will prevent you from accidentally docking the console again.
  prefs: []
  type: TYPE_NORMAL
- en: Working with geospatial data in the console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have used the QGIS Console as a glorified Python interpreter, running
    standard Python programs and manipulating the QGIS user interface. But QGIS is
    a Geographical Information System (GIS), and one of the main uses of a GIS is
    to manipulate and query geospatial data. So, let's write some Python code to work
    with geospatial data directly within the QGIS Console.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapter, we loaded three shapefiles into a QGIS project using
    Python. Here is a typical instruction we used to load a shapefile into a QGIS
    map layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'While this is useful if you want to create a QGIS project programmatically,
    you may just want to load a shapefile so you can analyze its contents, without
    putting the data into a map layer. To do this, we have to get an appropriate **data
    provider** and ask it to open the shapefile, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `isValid()` method will return `False` if the shapefile cannot be loaded;
    this allows us to fail gracefully if there is an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the data provider, we can ask it for the list of fields used to
    hold the attribute values for each of the shapefile''s features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also scan through the features within the shapefile using a `QgsFeatureRequest`
    object. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this is just a taste of what can be done using the QGIS libraries
    to query and manipulate geospatial data. However, let's use what we've learned
    to build a simple program that calculates and displays information about the contents
    of a shapefile. Shapefiles hold geospatial features such as polygons, lines and
    points, and each feature can have any number of attributes associated with it.
    We'll write a program that opens and scans through a shapefile, identifying the
    features and calculating the length of each line feature and the area of each
    polygon feature. We'll also calculate the total length and area across all the
    features.
  prefs: []
  type: TYPE_NORMAL
- en: One of the challenges we'll have to deal with is the fact that the shapefile
    can be in any map projection. This means that our calculation of the area and
    length has to take the map projection into account; if, for example, we simply
    calculated the linear length of a feature in a shapefile that uses the EPSG 4326
    projection (that is, lat/long coordinates), then the calculated length will be
    in degrees of latitude and longitude—which is a completely meaningless figure.
    We'll want to calculate the feature lengths in kilometers, and the areas in square
    kilometers. This is possible but requires us to do a bit more work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started with our program. Start by creating a new Python script
    and enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the program easier to use, we''re going to define a function and place
    all our program logic inside this function, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s start writing the contents of the `analyze_shapefile()` function.
    So far, we''ve been hardwiring the name of the shapefile, but this time, let''s
    use QGIS''s graphical interface to prompt the user to select a shapefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then open the selected shapefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In order to identify a feature, we need to display a meaningful label for the
    feature. To do this, we'll look for an attribute with a likely-looking name. If
    there is no suitable attribute, we'll have to use the feature's ID instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by building a list of the various attributes stored in this shapefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re now ready to start scanning through the shapefile''s features. Before
    we do this, though, let''s initialize a couple of variables to hold the totals
    we need to calculate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We also need to set up a `QgsDistanceArea` object to do the distance and area
    calculations for us.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We'll use this object to calculate the true length and area of the shapefile's
    features in meters and square meters respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re now ready to scan through the contents of the shapefile, processing
    each feature in turn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'For each feature, we want to calculate a label that identifies that feature.
    We''ll do this by looking for an attribute called `"name"`, `"NAME"`, or `"Name"`,
    and using that attribute''s value as the feature label. If there is no attribute
    with one of these field names, we''ll fall back to using the feature''s ID instead.
    Here is the relevant code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to obtain the geometry object associated with the feature. The
    geometry object represents a polygon, line, or point. Getting a reference to the
    feature''s underlying geometry object is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use the `QgsDistanceArea` calculator we initialized earlier to calculate
    the length of a line feature and the area of a polygon feature. To do this, we''ll
    first have to identify the type of feature we are dealing with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'For line geometries, we''ll calculate the length of the line and update the
    total length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'For polygon geometries, we''ll calculate the area of the polygon and update
    the total area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, for the other types of geometries, we''ll simply display the geometry''s
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve done these calculations, we can display the feature''s label
    together with the information we calculated about this feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, when we''ve finished iterating over the features, we can display the
    total line length and polygon area for all the features in the shapefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This completes our program for analyzing the contents of a shapefile. The full
    source for this program is available in the code samples provided with this book.
    To test our program, type or copy and paste it into the console''s script editor,
    save the file, and click on the **Run Script** button (or press *Ctrl* + *Shift*
    + *E*). Here''s an example of what the program''s output looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This output was produced using the World Borders dataset, available at [http://thematicmapping.org/downloads/world_borders.php](http://thematicmapping.org/downloads/world_borders.php).
    This is a useful set of geospatial data, which provides simple world maps and
    associated metadata. If you haven't already done so, you should grab yourself
    a copy of this dataset, as we'll be using this shapefile throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it is quite possible to create Python programs that read and
    analyze geospatial data, and you can run these programs directly from within the
    QGIS Console. It is also possible to create and manipulate geospatial data sources
    using the PyQGIS libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting the QGIS user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the example program we created earlier has very limited user interaction,
    it is quite possible to build your program to directly use the QGIS user interface
    elements such as the status bar, the message bar, progress indicators, and the
    QGIS logging window. You can also create custom forms and windows so that the
    output of your program looks just like any other feature of QGIS itself. Let's
    take a closer look at how some of these QGIS user-interface elements can be used
    from within your Python programs.
  prefs: []
  type: TYPE_NORMAL
- en: The status bar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The QGIS window has a status bar. You can use it to display the current status
    of your Python program, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The status message will appear at the bottom of the window, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The status bar](img/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, there isn''t much room on the status bar, so you''ll need to
    keep your status message short. To hide the message again, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The message bar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A message bar appears within a window to display messages to the user, for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The message bar](img/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Message bars have several useful features:'
  prefs: []
  type: TYPE_NORMAL
- en: Messages can be stacked so that if multiple messages appear at once, the user
    won't miss the earlier messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Messages have a level, which indicates the importance of the message, and affects
    how the message is displayed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Messages have an optional title as well as the text to be displayed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Messages can stay on the screen until the user closes them, or they can time
    out, disappearing automatically after a given number of seconds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can add various Qt widgets to the message bar to customize its behavior
    and appearance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any window in QGIS can have its own message bar. The `iface` variable has a
    `messageBar()` method, which returns the message bar for the main QGIS window,
    but you can also add a message bar to your own custom windows if you wish.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a message to a message bar, you call the message bar''s `pushMessage()`
    method. To create a message without a title, you use the following method signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To include a title, use the following method signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In both cases, the `level` parameter can be set to `QgsMessageBar.INFO`, `QgsMessageBar.WARNING`,
    or `QgsMessageBar.CRITICAL`, and if the `duration` parameter is specified, it
    will be the number of seconds before the message is hidden.
  prefs: []
  type: TYPE_NORMAL
- en: To remove all the messages currently being shown, you can call the `messageBar.clearWidgets()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Progress indicators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also make use of the message bar to display a Qt progress indicator.
    To do this, use the `messageBar.createMessage()` method to create a widget to
    display your message, then modify the widget to include additional Qt controls,
    and finally call the `messageBar.pushWidget()` method to display the message and
    the controls you added. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is a bug in the Mac version of QGIS 2.2, which prevents the user interface
    from updating while your Python code is running. A workaround for this is to use
    threads, as described in the following article: [http://snorf.net/blog/2013/12/07/multithreading-in-qgis-python-plugins](http://snorf.net/blog/2013/12/07/multithreading-in-qgis-python-plugins)'
  prefs: []
  type: TYPE_NORMAL
- en: QGIS logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use the built-in logging facilities of QGIS to display the output in
    a separate window. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The log messages will be shown in the log view, which you can show by navigating
    to **View** | **Panels** | **Log Messages**.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wish, you can change the importance of your message by adding a message
    level to the `logMessage()` call, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Rather than being mixed in with other QGIS messages, you can also choose to
    have all your log messages appear in a pane by themselves, by adding a tag to
    the `logMessage()` call as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Your log messages will then appear in a panel by themselves, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![QGIS logging](img/00019.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Custom dialogs and windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As QGIS is built on top of Qt, you can use the PyQt classes to create your
    own windows and dialog boxes, and display them directly from within your Python
    code. For example, here''s a script that displays a custom dialog box that prompts
    the user to enter a latitude and longitude value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this script will cause the following dialog box to be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom dialogs and windows](img/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If the user clicks on the **OK** button, the entered latitude and longitude
    values will be printed to the console. Of course, this is just a simple example—there's
    no error checking or conversion of the entered values from text back to numbers.
    However, this is just a simple example. There's a lot more that can be done using
    the PyQt libraries, and people have written entire books on the subject. However,
    the main thing to realize now is that, because QGIS is built on top of Qt, you
    can use all of the features of PyQt to build sophisticated user interfaces. You're
    certainly not limited to using the Python console to interact with the user.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the QGIS Python Console, and how to use it for
    a variety of programming tasks. We also used the console to delve more deeply
    into the QGIS Python programming environment.
  prefs: []
  type: TYPE_NORMAL
- en: As we worked through this chapter, we learned what the various toolbar buttons
    and controls do within the QGIS Console, and how to enter commands using the Python
    Shell. We looked at how we can use the Python Interpreter Log to view the previous
    output and re-enter commands you executed earlier. We saw the ways in which you
    can use autocompletion to enter your Python code more quickly, and also learned
    about the parameters that the various PyQGIS functions and methods accept.
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at how to enter and execute Python scripts using the built-in
    source code editor. We discovered that the Python Console is itself written in
    Python, allowing you to explore the source code and manipulate the console itself
    using the Python code.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to create a startup script that is run automatically whenever
    QGIS starts up, and how you can use this to set up the console to open automatically
    and prevent it from acting as a dockable window.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we examined the process of loading geospatial data directly using your
    Python scripts, without first having to load it into a QGIS map layer. We saw
    how to identify the attributes defined by a shapefile, how to scan through the
    features within a shapefile, and the ways in which the PyQGIS libraries allow
    you to perform common geospatial calculations.
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at the various ways in which you can make use of QGIS user interface
    elements within your Python scripts, including the status bar, message bars, progress
    indicators, and the QGIS message log.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we saw how you can use standard PyQt classes to create your own windows
    and dialog boxes to provide a sophisticated user interface for your Python scripts.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we will work more directly with the QGIS Python libraries,
    learning how these libraries are structured and how you can use them to perform
    various sorts of geospatial data manipulation and display the results on a map.
  prefs: []
  type: TYPE_NORMAL
