<html><head></head><body><div class="chapter" title="Chapter&#xA0;11.&#xA0;Social Network Analysis of the R Ecosystem"><div class="titlepage"><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Social Network Analysis of the R Ecosystem</h1></div></div></div><p>Although the concept of social networks has a pretty long history, starting at the beginning of the last century, <span class="strong"><strong>social network analysis</strong></span> (<span class="strong"><strong>SNA</strong></span>) <a class="indexterm" id="id830"/>became extremely popular only in the last decade, probably due to the success of huge social media sites and the availability of related data. In this chapter, we are going to take a look on how to retrieve and load such data, then analyze and visualize such networks by heavily <a class="indexterm" id="id831"/>using the <code class="literal">igraph</code> package.</p><p>
<code class="literal">Igraph</code> is an open source network analysis tool made by Gábor Csárdi. The software ships with a wide variety of network analysis methods, and it can be used in R, C, C++, and Python as well.</p><p>In this chapter, we will cover the following topics with some examples on the R ecosystem:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Loading and handling network data</li><li class="listitem" style="list-style-type: disc">Network centrality metrics</li><li class="listitem" style="list-style-type: disc">Visualizing network graphs</li></ul></div><div class="section" title="Loading network data"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec74"/>Loading network data</h1></div></div></div><p>Probably the easiest way to<a class="indexterm" id="id832"/> retrieve network-flavored information on the R ecosystem is to analyze how R packages depend on each other. Based on <a class="link" href="ch02.html" title="Chapter 2. Getting Data from the Web">Chapter 2</a>, <span class="emphasis"><em>Getting the Data</em></span>, we could try to load this data via HTTP parsing of the CRAN mirrors but, luckily, R has a built-in function to return all available R packages from CRAN<a class="indexterm" id="id833"/> with some useful meta-information as well:</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip17"/>Tip</h3><p>The number of packages hosted on CRAN is growing from day to day. As we are working with live data, the actual results you see might be slightly different.</p></div></div><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; library(tools)</strong></span>
<span class="strong"><strong>&gt; pkgs &lt;- available.packages()</strong></span>
<span class="strong"><strong>&gt; str(pkgs)</strong></span>
<span class="strong"><strong> chr [1:6548, 1:17] "A3" "abc" "ABCanalysis" "abcdeFBA" ...</strong></span>
<span class="strong"><strong> - attr(*, "dimnames")=List of 2</strong></span>
<span class="strong"><strong>  ..$ : chr [1:6548] "A3" "abc" "ABCanalysis" "abcdeFBA" ...</strong></span>
<span class="strong"><strong>  ..$ : chr [1:17] "Package" "Version" "Priority" "Depends" ...</strong></span>
</pre></div><p>So we have a matrix<a class="indexterm" id="id834"/> with more than 6,500 rows, and the fourth column includes the dependencies in a comma-separated list. Instead of parsing those strings and cleaning the data from the package versions and other relatively unimportant characters, let's use another handy function from the tools package<a class="indexterm" id="id835"/> to do the dirty work:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; head(package.dependencies(pkgs), 2)</strong></span>
<span class="strong"><strong>$A3</strong></span>
<span class="strong"><strong>     [,1]      [,2] [,3]    </strong></span>
<span class="strong"><strong>[1,] "R"       "&gt;=" "2.15.0"</strong></span>
<span class="strong"><strong>[2,] "xtable"  NA   NA      </strong></span>
<span class="strong"><strong>[3,] "pbapply" NA   NA      </strong></span>

<span class="strong"><strong>$abc</strong></span>
<span class="strong"><strong>     [,1]       [,2] [,3]  </strong></span>
<span class="strong"><strong>[1,] "R"        "&gt;=" "2.10"</strong></span>
<span class="strong"><strong>[2,] "nnet"     NA   NA    </strong></span>
<span class="strong"><strong>[3,] "quantreg" NA   NA    </strong></span>
<span class="strong"><strong>[4,] "MASS"     NA   NA    </strong></span>
<span class="strong"><strong>[5,] "locfit"   NA   NA    </strong></span>
</pre></div><p>So the <code class="literal">package.dependencies</code> function returns a long named list of matrixes: one for each R package, which includes the required package name and version to install and load the referred package. Besides the very same function can retrieve the list of packages that are imported or suggested by others via the <code class="literal">depLevel</code> argument. We will use this information to build a richer dataset with different types of connections between the R packages.</p><p>The following script creates the <code class="literal">data.frame</code>, in which each line represents a connection between two R packages. The <code class="literal">src</code> column shows which R package refers to the <code class="literal">dep</code> package, and the label <a class="indexterm" id="id836"/>describes the type of connection:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; library(plyr)</strong></span>
<span class="strong"><strong>&gt; edges &lt;- ldply(</strong></span>
<span class="strong"><strong>+   c('Depends', 'Imports', 'Suggests'), function(depLevel) {</strong></span>
<span class="strong"><strong>+     deps &lt;- package.dependencies(pkgs, depLevel = depLevel)</strong></span>
<span class="strong"><strong>+     ldply(names(deps), function(pkg)</strong></span>
<span class="strong"><strong>+         if (!identical(deps[[pkg]], NA))</strong></span>
<span class="strong"><strong>+             data.frame(</strong></span>
<span class="strong"><strong>+                 src   = pkg,</strong></span>
<span class="strong"><strong>+                 dep   = deps[[pkg]][, 1],</strong></span>
<span class="strong"><strong>+                 label = depLevel,</strong></span>
<span class="strong"><strong>+                 stringsAsFactors = FALSE))</strong></span>
<span class="strong"><strong>+ })</strong></span>
</pre></div><p>Although this code snippet might seem complex at first sight, we simply look up the dependencies of each package (like in a loop), return a row of <code class="literal">data.frame</code>, and nest it in another loop, which iterates through all previously mentioned R package connection types. The resulting R object is really straightforward to understand:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; str(edges)</strong></span>
<span class="strong"><strong>'data.frame':  26960 obs. of  3 variables:</strong></span>
<span class="strong"><strong> $ src  : chr  "A3" "A3" "A3" "abc" ...</strong></span>
<span class="strong"><strong> $ dep  : chr  "R" "xtable" "pbapply" "R" ...</strong></span>
<span class="strong"><strong> $ label: chr  "Depends" "Depends" "Depends" "Depends" ...</strong></span>
</pre></div></div></div>
<div class="section" title="Centrality measures of networks"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec75"/>Centrality measures of networks</h1></div></div></div><p>So we have identified almost 30,000 <a class="indexterm" id="id837"/>relations between our 6,500 packages. Is it a sparse or dense network? In other words, how many connections do we have out of all possible package dependencies? What if all the packages depend on all other packages? We do not really need any feature-rich package to calculate that:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; nrow(edges) / (nrow(pkgs) * (nrow(pkgs) - 1))</strong></span>
<span class="strong"><strong>[1] 0.0006288816</strong></span>
</pre></div><p>This is a rather low percentage, which makes the life of R sysadmins rather easy compared to maintaining a dense network of R software. But who are the central players in this game? Which are the top-most dependent R packages?</p><p>We can also compute a rather trivial metric to answer this question without any serious SNA knowledge, as this can be defined as "Which R package is mentioned the most times in the <code class="literal">dep</code> column of the edges dataset"? Or, in plain English: "Which package has the most reverse dependencies?"</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; head(sort(table(edges$dep), decreasing = TRUE))</strong></span>
<span class="strong"><strong>       R  methods     MASS    stats testthat  lattice </strong></span>
<span class="strong"><strong>    3702      933      915      601      513      447</strong></span>
</pre></div><p>It seems that almost 50 <a class="indexterm" id="id838"/>percent of the packages depend on a minimal version of R. So as not to distort our directed network, let's remove these edges:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; edges &lt;- edges[edges$dep != 'R', ]</strong></span>
</pre></div><p>And now it's time to transform our list of connections into a real graph object to compute more advanced metrics, and also to visualize the data:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; library(igraph)</strong></span>
<span class="strong"><strong>&gt; g &lt;- graph.data.frame(edges)</strong></span>
<span class="strong"><strong>&gt; summary(g)</strong></span>
<span class="strong"><strong>IGRAPH DN-- 5811 23258 -- </strong></span>
<span class="strong"><strong>attr: name (v/c), label (e/c)</strong></span>
</pre></div><p>After loading the package, the <code class="literal">graph.data.frame</code> function transforms various data sources into an <code class="literal">igraph</code> object. This is an extremely useful class with a variety of supported methods. The summary simply prints the number of vertices and edges, which shows that around 700 R packages have no dependencies. Let's compute the previously discussed and manually computed metrics with <code class="literal">igraph</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; graph.density(g)</strong></span>
<span class="strong"><strong>[1] 0.0006888828</strong></span>
<span class="strong"><strong>&gt; head(sort(degree(g), decreasing = TRUE))</strong></span>
<span class="strong"><strong> methods     MASS    stats testthat  ggplot2  lattice </strong></span>
<span class="strong"><strong>     933      923      601      516      459      454</strong></span>
</pre></div><p>It's not that surprising to see<a class="indexterm" id="id839"/> the <code class="literal">methods</code> package at the top of the list, as it's often required in packages with complex <code class="literal">S4</code> methods and classes. The <code class="literal">MASS</code> <a class="indexterm" id="id840"/>and <code class="literal">stats</code> packages<a class="indexterm" id="id841"/> include most of the often used statistical methods, but what about the others? The <a class="indexterm" id="id842"/>
<code class="literal">lattice</code> and <code class="literal">ggplot2</code> packages <a class="indexterm" id="id843"/>are extremely smart and feature-full graphing engines, and <code class="literal">testthat</code> <a class="indexterm" id="id844"/>is one of the most popular unit-testing extensions of R; this must be mentioned in the package descriptions before submitting new packages to the central CRAN servers.</p><p>But <code class="literal">degree</code> is only one of the available centrality metrics for social networks. Unfortunately, computing closeness, which shows the distance of each node from the others, is not really meaningful when it comes to dependency, but <code class="literal">betweenness</code> is a really interesting comparison to the preceding results:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; head(sort(betweenness(g), decreasing = TRUE))</strong></span>
<span class="strong"><strong>   Hmisc     nlme  ggplot2     MASS multcomp      rms </strong></span>
<span class="strong"><strong>943085.3 774245.2 769692.2 613696.9 453615.3 323629.8</strong></span>
</pre></div><p>This metric shows the <a class="indexterm" id="id845"/>number of times each package acts as a bridge (the only connecting node between two others) in the shortest path between the other packages. So it's not about having a lot of depending packages; rather, it shows the importance of the packages from a more global perspective. Just imagine if a package with a high <code class="literal">betweenness</code> was deprecated and removed from CRAN; not only the directly dependent packages, but also all other packages in the dependency tree would be in a rather awkward situation.</p></div>
<div class="section" title="Visualizing network data"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec76"/>Visualizing network data</h1></div></div></div><p>To compare these two<a class="indexterm" id="id846"/> metrics, let's draw a simple scatter plot showing each R package by <code class="literal">degree</code> and <code class="literal">betweenness</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; plot(degree(g), betweenness(g), type = 'n',</strong></span>
<span class="strong"><strong>+   main = 'Centrality of R package dependencies')</strong></span>
<span class="strong"><strong>&gt; text(degree(g), betweenness(g), labels = V(g)$name)</strong></span>
</pre></div><div class="mediaobject"><img alt="Visualizing network data" src="graphics/2028OS_11_01.jpg"/></div><p>Relax; we will be soon able to generate much more spectacular and instructive plots in a few minutes! But the preceding plot shows that there are some packages with a rather low number of direct dependents that still have a great impact on the global R ecosystem.</p><p>Before we proceed, let's filter our dataset and graph to include far fewer vertices by building the dependency tree of<a class="indexterm" id="id847"/> the <code class="literal">igraph</code> package, including all packages it <a class="indexterm" id="id848"/>depends on or imports from:</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip18"/>Tip</h3><p>The following short list of <code class="literal">igraph</code> dependencies was generated in April 2015. Since then, a major new version of <code class="literal">igraph</code> has been released with a lot more dependencies due to importing from the <code class="literal">magrittr</code> and <code class="literal">NMF</code> packages, so the following examples repeated on your computer will return a much larger network and graphs. For educational purposes, we are showing the smaller network in the following outputs.</p></div></div><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; edges &lt;- edges[edges$label != 'Suggests', ]</strong></span>
<span class="strong"><strong>&gt; deptree &lt;- edges$dep[edges$src == 'igraph']</strong></span>
<span class="strong"><strong>&gt; while (!all(edges$dep[edges$src %in% deptree] %in% deptree))</strong></span>
<span class="strong"><strong>+   deptree &lt;- union(deptree, edges$dep[edges$src %in% deptree])</strong></span>
<span class="strong"><strong>&gt; deptree</strong></span>
<span class="strong"><strong>[1] "methods"   "Matrix"    "graphics"  "grid"      "stats"</strong></span>
<span class="strong"><strong>[6] "utils"     "lattice"   "grDevices"</strong></span>
</pre></div><p>So we need the previously mentioned eight packages to be able to use the <code class="literal">igraph</code> package. Please note that not all of these are direct dependencies; some are dependencies from other packages. To draw a visual<a class="indexterm" id="id849"/> representation of this dependency tree, let's create the related graph object and plot it:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; g &lt;- graph.data.frame(edges[edges$src %in% c('igraph', deptree), ])</strong></span>
<span class="strong"><strong>&gt; plot(g)</strong></span>
</pre></div><div class="mediaobject"><img alt="Visualizing network data" src="graphics/2028OS_11_02.jpg"/></div><p>Well, the <code class="literal">igraph</code> package <a class="indexterm" id="id850"/>literally depends on only one package, although it also <a class="indexterm" id="id851"/>imports some functions from the <code class="literal">Matrix</code> package. All the other previously mentioned packages are dependencies of the latter.</p><p>To draw a more intuitive version of the preceding plot to suggest this statement, we might consider removing the dependency labels and represent that aspect by colors, and we can also emphasize the direct dependencies of <code class="literal">igraph</code> by <code class="literal">vertex</code> colors. We can modify the attributes of vertices and edges via the <code class="literal">V</code> and <code class="literal">E</code> functions:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; V(g)$label.color &lt;- 'orange'</strong></span>
<span class="strong"><strong>&gt; V(g)$label.color[V(g)$name == 'igraph'] &lt;- 'darkred'</strong></span>
<span class="strong"><strong>&gt; V(g)$label.color[V(g)$name %in%</strong></span>
<span class="strong"><strong>+        edges$dep[edges$src == 'igraph']] &lt;- 'orangered'</strong></span>
<span class="strong"><strong>&gt; E(g)$color &lt;- c('blue', 'green')[factor(df$label)]</strong></span>
<span class="strong"><strong>&gt; plot(g, vertex.shape = 'none', edge.label = NA)</strong></span>
</pre></div><div class="mediaobject"><img alt="Visualizing network data" src="graphics/2028OS_11_03.jpg"/></div><p>Much better! Our central topic, the<a class="indexterm" id="id852"/> <code class="literal">igraph</code> package, is highlighted in dark red, the <a class="indexterm" id="id853"/>two direct dependencies are marked in dark orange, and all the other dependencies are colored in lighter orange. Similarly, we emphasize the <code class="literal">Depends</code> relations in blue compared to the vast majority of other Imports connections.</p><div class="section" title="Interactive network plots"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec73"/>Interactive network plots</h2></div></div></div><p>What if you do not like the order<a class="indexterm" id="id854"/> of the vertices in the preceding plot? Feel free to rerun the last command to produce new results, or draw with <code class="literal">tkplot</code> for a dynamic plot, where you can design your custom layout by dragging-and-dropping the vertices:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; tkplot(g, edge.label = NA)</strong></span>
</pre></div><div class="mediaobject"><img alt="Interactive network plots" src="graphics/2028OS_11_04.jpg"/></div><p>Can we do any better? Although<a class="indexterm" id="id855"/> this result is extremely useful, it lacks the immediate appeal of the currently trending, JavaScript-empowered interactive plots. So let's recreate this interactive plot with JavaScript, right from R! <code class="literal">htmlwidgets</code> and <a class="indexterm" id="id856"/>the <code class="literal">visNetwork</code> package, discussed in more detail in the <a class="link" href="ch13.html" title="Chapter 13. Data Around Us">Chapter 13</a>, <span class="emphasis"><em>Data Around Us</em></span>, can help us with this task, even without any JavaScript knowledge. Simply pass the extracted nodes and edge datasets to the <code class="literal">visNetwork</code> function:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; library(visNetwork)</strong></span>
<span class="strong"><strong>&gt; nodes &lt;- get.data.frame(g, 'vertices')</strong></span>
<span class="strong"><strong>&gt; names(nodes) &lt;- c('id', 'color')</strong></span>
<span class="strong"><strong>&gt; edges &lt;- get.data.frame(g)</strong></span>
<span class="strong"><strong>&gt; visNetwork(nodes, edges)</strong></span>
</pre></div><div class="mediaobject"><img alt="Interactive network plots" src="graphics/2028OS_11_05.jpg"/></div></div><div class="section" title="Custom plot layouts"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec74"/>Custom plot layouts</h2></div></div></div><p>Alternatively, we can also generate<a class="indexterm" id="id857"/> such hierarchical plots in a programmatic way, by drawing the denominator tree of this directed plot:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; g &lt;- dominator.tree(g, root = "igraph")$domtree</strong></span>
<span class="strong"><strong>&gt; plot(g, layout = layout.reingold.tilford(g, root = "igraph"), </strong></span>
<span class="strong"><strong>+   vertex.shape = 'none')</strong></span>
</pre></div><div class="mediaobject"><img alt="Custom plot layouts" src="graphics/2028OS_11_06.jpg"/></div></div><div class="section" title="Analyzing R package dependencies with an R package"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec75"/>Analyzing R package dependencies with an R package</h2></div></div></div><p>As we are using R, a statistical<a class="indexterm" id="id858"/> programming environment whose most exciting and useful feature is its community, we might prefer to look for other, already implemented solutions for this research. After a quick Google search, and having looked up a few questions on StackOverflow or posts<a class="indexterm" id="id859"/> on <a class="ulink" href="http://www.r-bloggers.com/">http://www.r-bloggers.com/</a>, it's pretty easy to find the Revolution Analytics<a class="indexterm" id="id860"/> <code class="literal">miniCRAN</code> package, which has some related and useful functions:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; library(miniCRAN)</strong></span>
<span class="strong"><strong>&gt; pkgs &lt;- pkgAvail()</strong></span>
<span class="strong"><strong>&gt; pkgDep('igraph', availPkgs = pkgs, suggests = FALSE,</strong></span>
<span class="strong"><strong>+   includeBasePkgs = TRUE)</strong></span>
<span class="strong"><strong>[1] "igraph"    "methods"   "Matrix"    "graphics"  "grid"</strong></span>
<span class="strong"><strong>[6] "stats"     "utils"     "lattice"   "grDevices"</strong></span>
<span class="strong"><strong>&gt; plot(makeDepGraph('igraph', pkgs, suggests = FALSE,</strong></span>
<span class="strong"><strong>+   includeBasePkgs = TRUE))</strong></span>
</pre></div><div class="mediaobject"><img alt="Analyzing R package dependencies with an R package" src="graphics/2028OS_11_07.jpg"/></div><p>But let's get back to the <a class="indexterm" id="id861"/>original question: How do we analyze network data?</p></div></div>
<div class="section" title="Further network analysis resources"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec77"/>Further network analysis resources</h1></div></div></div><p>Besides its really impressive and useful data visualization, the <code class="literal">igraph</code> package has<a class="indexterm" id="id862"/> a lot more to offer. Unfortunately, this short chapter cannot provide a decent introduction to network analysis theory, but I suggest that you skim through the package documentation as it comes with useful, self-explanatory examples and good references.</p><p>In short, network analysis provides various ways to compute centrality and density metrics, like we did at the beginning of this chapter, and also to identify bridges and simulate changes in the network; there are really powerful methods to segment the nodes in the network as well.</p><p>For example, in the <span class="emphasis"><em>Financial Networks</em></span> chapter of the <span class="emphasis"><em>Introduction to R for Quantitative Finance</em></span> book, which I coauthored, we developed R scripts to identify <span class="strong"><strong>systemically important financial institutions</strong></span>(<span class="strong"><strong>SIFI</strong></span>)<a class="indexterm" id="id863"/> in Hungary based on the transaction-level network data of the interbank lending market. This dataset and network theory help us to model and potentially predict future financial crises, and also to simulate the effect of central intervention.</p><p>A more detailed, freely available summary on this research was presented at the R/Finance 2015<a class="indexterm" id="id864"/> conference in Chicago <a class="ulink" href="http://www.rinfinance.com/agenda/2015/talk/GergelyDaroczi.pdf">http://www.rinfinance.com/agenda/2015/talk/GergelyDaroczi.pdf</a>, along with a Shiny application <a class="ulink" href="https://bit.ly/rfin2015-hunbanks">https://bit.ly/rfin2015-hunbanks</a>, and a related, simulation-based infection-model was described in the <span class="emphasis"><em>Systemic Risk</em></span> chapter of the <span class="emphasis"><em>Mastering R for Quantitative Finance</em></span> book as well.</p><p>The main idea behind this joint research was to identify core, peripheral, and semi-peripheral financial institutions based on the network formed by interbank lending transactions. The nodes being banks, the edges are defined as lend events between those, so we can interpret the bridges between periphery nodes as the intermediary bank between smaller banks, which usually do not lend money to each other directly.</p><p>The interesting question, after resolving some technical issues with the dataset, was to simulate what happens if an intermediary bank defaults, and if this unfortunate event might also affect other financial institutions.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec78"/>Summary</h1></div></div></div><p>This short chapter introduced a new data structure in the form of graph datasets, and we visualized small networks with various R packages, including static and interactive methods as well. In the next two chapters, we will familiarize ourselves with two other frequently used data types: first we will analyze temporal, then spatial data.</p></div></body></html>