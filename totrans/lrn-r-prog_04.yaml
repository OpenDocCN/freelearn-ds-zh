- en: Chapter 4. Basic Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Expressions are the building blocks of a function. R has a very clear syntax
    that suggests that an expression is either a symbol or a function call.
  prefs: []
  type: TYPE_NORMAL
- en: Although everything we do is in essence implemented by functions, R gives some
    functions a special syntax so that it is more friendly to write readable R code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next few sections, we will see the following fundamental expressions
    that are given a special syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: Assignment expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loop expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assignment expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Assignment may be one of the most fundamental expressions in all programming
    languages. What it does is assign or bind a value to a symbol so that we can refer
    to the value by that symbol later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite the similarity, R adopts the `<-` operator to perform assignment. This
    is a bit different from many other languages using `=` although this is also allowed
    in R:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We don't have to declare the symbol and its type before assigning a value to
    it. If a symbol does not exist in the environment, the assignment will create
    that symbol. If a symbol already exists, the assignment will not end up in conflict,
    but will rebind the new value to that symbol.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative assignment operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are some alternate yet equivalent operators we can use. Compared to `x
    <- f(z)`, which binds the value of `f(z)` to symbol `x`, we can also use `->`
    to perform assignment in the opposite direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even chain the assignment operators so that a set of symbols all take
    the same value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The expression `0` is evaluated only once so that the same value is assigned
    to the three symbols. To verify how it works, we can change`0` to a random number
    generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `rnorm(1)` method generates a random number following the standard normal
    distribution. If each assignment re-invokes the random number generator, each
    symbol will have different values. In fact, however, it does not happen. Later,
    I will explain what really happens and you will have a better understanding of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like other programming languages, `=` also can perform assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you are familiar with other popular programming languages such as Python,
    Java, and C#, you may find it almost an industry standard to use `=` as the assignment
    operator and may feel uncomfortable using `<-`, which requires more typing. However,
    Google's *R Style Guide* ([https://google.github.io/styleguide/Rguide.xml#assignment](https://google.github.io/styleguide/Rguide.xml#assignment))
    suggests the usage of `<-` instead of `=`, even though both are allowed and have
    exactly the same effect when they are used as assignment operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, I will provide a simple explanation to the subtle difference between
    `<-` and `=`. Let''s first create a `f()` function that takes two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The function basically prints the value of the two arguments. Then, let''s
    use this function to demonstrate the difference between the two operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses both `<-` and `=` operators but they play different
    roles. The `<-` operator in the first two lines is used as an assignment operator,
    while `=` in the third line specifies a named argument input for the `f()` method.
  prefs: []
  type: TYPE_NORMAL
- en: More specifically, the `<-` operator evaluates the expression on its right-hand
    side `c(1, 2, 3)` and assigns the evaluated value to the symbol (variable) on
    the left-hand side `x`. The `=` operator is not used as an assignment operator
    but to match the function argument by name.
  prefs: []
  type: TYPE_NORMAL
- en: 'We know that the `<-` and `=` operators are interchangeable when they are used
    as assignment operators. Therefore, the preceding code is equivalent to the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we only use the `=` operator but for two different purposes: in the first
    two lines, `=` performs an assignment, while in the third line `=` specifies the
    named argument.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see what happens if we change every `=` to `<-`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this code, you will find that the outputs are similar. However,
    if you inspect the environment, you will observe the difference: a new `input`
    variable is now created in the environment and gains the value of `c(1, 2, 3)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'So, what happened? Actually, in the third line, two things happened: First,
    the assignment, `input <- x`, introduces a new `input` symbol to the environment
    and results in `x`. Then, the value of `input` is provided to the first argument
    of function `f()`. In other words, the first function argument is not matched
    by name but by position.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To elaborate, we will conduct more experiments. The standard usage of the function
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If we replace both `=` with `<-`, the result looks the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'For the code using `=`, we can exchange the two named arguments without changing
    the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, however, if we exchange `=` for `<-`, the values of `input` and `data` are
    also exchanged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code has the same effect as that of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This code not only results in `f(y, x)`, but unnecessarily creates additional `data`
    and `input` variables in the current environment.
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding examples and experiments, the bottom line is clear. To reduce
    ambiguity, it is allowed to use either `<-` or `=` as the assignment operator
    and only use `=` to specify the named argument for functions. In conclusion, for
    better readability of R code, as the Google Style Guide suggests, only use `<-`
    for assignment and `=` to specify named arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Using backticks with non-standard names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assignment operators allow us to assign a value to a variable (or a symbol or
    name). However, direct assignment limits the format of the name. It contains only
    letters from a to z, A to Z (R is case-sensitive), the underscore(`_`), and dot(`.`),
    and it should not contain spaces or start with an underscore(`_`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some valid names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are invalid names due to violating naming rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding names violate the rules in different ways. The `some data` variable
    name contains a space, `_data` starts with `_`, and `Population(Millions)` is
    not a symbol name but a function call. In practice, it is quite likely that some
    invalid names might indeed be column names in a data table, such as the third
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 'To walk around, we need to use back-ticks to quote the invalid names to make
    them valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To refer to these variables, also use backticks; otherwise, they will still
    be regarded as invalid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Backticks can be used wherever we create a symbol, irrespective of whether
    it is a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It does not even matter if it is a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If the symbol name cannot be validly referred to directly, we also need to
    use quotation marks to refer to the symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'An exception is `data.frame()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, even if we use backticks around a name with unusual symbols,
    the resulting `data.frame` variable will replace those symbols with the dots or
    using `make.names()`, a method that can be confirmed by looking at the column
    names of the resulting `data.frame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This often happens when you import a table such as the following CSV data resulted
    from an experiment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'When you read the CSV data using `read.csv()`, the `Population(before)` and `Population(after)` variable
    will not preserve their original names, but will change them to valid names in
    R using the `make.names()` method. To know what names we will get, we can run
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, this behavior is undesirable. To disable it, set `check.names =
    FALSE` when you call either `read.csv()` or `data.frame()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding call, `stringAsFactors = FALSE` avoids converting character
    vectors to factors and `check.names = FALSE` avoids applying `make.names()` on
    the column names. With these two arguments, the `data.frame` variable created
    will preserve most aspects of the input data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as I mentioned, to access the column with special symbols, use backticks
    to quote the name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Backticks make it possible to create and access variables, with symbols not
    allowed in direct assignment. This does not mean using such names is recommended.
    Rather, it can make the code harder to read and more error-prone, and it makes
    it more difficult to work with external tools that impose strict naming rules.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, using backticks to create special variable names should be avoided
    unless absolutely necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is common that the logic of a program is not perfectly sequential but contains
    several branches dependent on certain conditions. Therefore, one of the most basic
    constructs of a typical programming language is its conditional expressions. In
    R, `if` can be used to branch the logic flow by logical conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Using if as a statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like many other programming languages, the `if` expression works with a logical
    condition. In R, a logical condition is represented by an expression producing
    a single-element logical vector. For example, we can write a simple function `check_positive`
    that returns `1` if a positive number is provided and nothing otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding function, `x > 0` is the condition to check. If the condition
    is satisfied, then the function returns `1`. Let''s verify the function with various
    inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'It seems that the function works as expected. If we add some `else if` and `else`
    branches, the function can be generalized as the sign function that returns **1**
    for positive input, `-1` for negative input, and `0` for 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function has the same functionality as the built-in function
    `sign()`. To verify its logic, just call it with different inputs with full coverage
    of the conditional branches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The function does not need to return anything. We can also perform actions
    that return nothing (more accurately, `NULL`) depending on various conditions.
    The following function always does not explicitly return a value, but it sends
    a message in the console. The kind of message depends on the sign of the input
    number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use a similar method, that is `say_sign()`, to test its logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The workflow for evaluating `if` statement branches is quite straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: First, evaluate `cond1` in the first `if (cond1) { expr1 }`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `cond1` is `TRUE`, then evaluate its corresponding expression `{ expr1 }`.
    Otherwise, evaluate the `cond2` condition in the next `else if (cond2)` branch
    and so forth.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the conditions in all `if` and `else if` branches are violated, then evaluate
    the expression in the `else` branch, if any.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: According to the workflow, an `if` statement can be more flexible than you might
    think. For example, an `if` statement can be in one of the following forms.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest form is a simple `if` statement branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'A more complete form is with an `else` branch that deals with situations where `cond1`
    is not `TRUE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'An even more complex form is with one or more `else if` branches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding conditional branches, the branch conditions (`cond1`, `cond2`,
    and `cond3`) may or may not be related. For example, the simple grading policy
    perfectly fits the branching logic in the preceding template in which each branch
    condition is a slice of the score range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In this case, each branch condition in `else if` actually implicitly assumes
    that the previous condition does not hold; that is, `score >= 80` actually means `score
    < 90` and `score >= 80`, which is dependent on previous conditions. As a result,
    we cannot switch the order of these branches without explicitly stating the assumptions
    and making all branches independent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume we switch some of the branches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'It is obvious that only `grade(59)` got the right grade and all others are
    broken. To fix the function without reordering the conditions, we need to rewrite
    the condition so that they do not depend on the order of evaluation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This makes the function much more verbose than the first correct version. Therefore,
    it is important to figure out the correct order for branch conditions and be careful
    of the dependency of each branch.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, R provides convenient functions such as `cut()`, which does exactly
    the same thing. Read the documentation by typing in `?cut` for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Using if as an expression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since `if` is in essence a primitive function, its returned value is the value
    of the expression in the branch whose condition is satisfied. Therefore, `if`
    can be used as an inline expression too. Take the `check_positive()` method for
    example. Rather than writing `return()` in the conditional expression, we can
    also return the value of the `if` statement expression in the function body to
    achieve the same goal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, the expression syntax can to be simplified to merely one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the return value of a function is the value of its last expression in
    the function body, `return()` can be removed in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The same principle also applies to the `check_sign()` method. A simpler form
    of `check_sign()` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'To explicitly get the value of the `if` expression, we can implement a grade
    reporting function that mentions the grade of a student, given the student name
    and their score:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `if` statement as an expression seems more compact and less verbose.
    However, in practice, it is rarely the case that all conditions are simple numeric
    comparisons and return simple values. For more complex conditions and branching,
    I suggest that you use `if` as a statement to clearly state different branches
    and do not omit `{}` to avoid unnecessary mistakes. The following function is
    a bad example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The function author wants to add something to say to some branches. Without
    `{}` brackets around the branch expression, you are very likely to write code
    with syntax errors when you add more behaviors to conditional branches. If you
    evaluate the preceding code in the console, you will get enough errors to confuse
    you for a while:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'A better form of the function that avoids such potential pitfalls is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The function seems a bit more verbose, but it is more robust to changes and
    clearer in its logic. Remember, it is always better to be correct than short.
  prefs: []
  type: TYPE_NORMAL
- en: Using if with vectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All the example functions created earlier only work with a single-value input.
    If we provide a vector, the functions will produce warnings because if does not
    work with multi-element vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding output, we can see that the `if` statement ignores all but
    the first element, if a multi-element logical vector is supplied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The expression throws a warning saying that only the first element (`1 > 2`)
    will be used. In fact, its logic is unclear when we try to condition an expression
    on a logical vector since its values can be mixed up with `TRUE` and `FALSE` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some logical functions are useful to avoid such ambiguity. For example, the `any()`
    method returns `TRUE` if at least one element in the given vector is `TRUE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, if what we really mean is to print the message if any single value
    is greater than `2`, we should call the `any()` method in the condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'If we mean to print the first message if all values are greater than `2`, we
    should instead call the `all()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, every time we use an `if` expression to branch the workflow, we should
    ensure that the condition is a single-value logical vector. Otherwise, something
    unexpected may happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another exception is `NA`, which is also a single-value logical vector but
    can cause an error as an `if` condition without notice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `check()` function works perfectly for typical numeric vectors with no
    missing values. However, if argument `x` contains a missing value, the function
    may end up in an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: From this example, we should be careful of missing values when we write `if`
    conditions. If the logic is complicated and the input data is diverse, you cannot
    easily walk around handling missing values in appropriate ways. Note that the `any()`
    and `all()` methods both accept `na.rm` to handle missing values. We should take
    this into account too when writing conditions.
  prefs: []
  type: TYPE_NORMAL
- en: One way to simplify condition checking is to use `isTRUE(x)`, which calls  `identical(TRUE,
    x)` internally. In this case, only a single `TRUE` value will meet the condition
    and all other values will not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using vectorized if: ifelse'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An alternate method to branch a computation is `ifelse()`. This function accepts
    a logical vector as the test condition and returns a vector. For each element
    in the logical test condition, if the value is `TRUE`, then the corresponding
    element in the second argument `yes` will be chosen. If the value is `FALSE`,
    then the corresponding element in the third argument `no` will be chosen. In other
    words, `ifelse()` is the vectorized version of `if`, as demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the `yes` and `no` arguments can be recycled, we can rewrite `check_positive()`
    using `ifelse()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: One difference between `check_positive()` (using the `if` statement) and `check_positive2()`
    (using `ifelse`) is subtle: `check_positive(-1)` does not return values explicitly,
    but `chek_positive2(-1)` returns 0\. The `if` statement does not necessarily return
    a value explicitly by using only one `if` but not `else`. By contrast, `ifelse()`
    always returns a vector because you have to specify the values in both `yes` and `no`
    arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another reminder is that `ifelse()` and `if` are not always able to achieve
    the same goal if you simply replace one with the other. For example, imagine you
    want to return a two-element vector according to a condition. Let''s assume we
    use `ifelse()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Only the first element of the `yes` argument is returned. If you want to return
    the `yes` argument, you need to modify the condition to `c(TRUE, TRUE)`, which
    looks a bit unnatural.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use `if`, then the expression looks much more natural:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'If the demand is a vectorized input and output, then another problem is that,
    if the `yes` argument is a numeric vector and the `no` argument is a character
    vector, a condition with mixed `TRUE` and `FALSE` values will coerce all elements
    in the output vector to be able to represent all values. Thus, a character vector
    is produced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Using switch to branch values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In contrast with if, which deals with `TRUE` and `FALSE` conditions, `switch`
    works with a number or a string and chooses a branch to return according to the
    input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose the input is an integer `n`. The `switch` keyword works in a way that
    returns the value of the n^(th) arguments in following the first argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'If the input integer is out of bounds and does not match any given argument,
    no visible value is explicitly returned (in fact, an invisible `NULL` is returned):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The `switch()` method has a different behavior when working with string input.
    It returns the value of the first argument that matches its name with the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'For the first `switch`, `a = 1` matches the variable `a`. For the second, `b
    = 2` matches the variable `b`. If no argument matches the input, an invisible `NULL`
    value will be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'To cover all possibilities, we can add a last argument (without argument name)
    that captures all other inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Compared to the `ifelse()` method, `switch()` behaves more like `if()` method.
    It only accepts a single value input (number of string) but it can return anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: In conclusion, `if`, `ifelse()`, and `switch()` have slightly different behaviors.
    You should apply them in different situations accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Loop expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Loop (or iteration) evaluates an expression repeatedly by either iterating over
    a vector (`for`) or checking whether a condition is violated (while).
  prefs: []
  type: TYPE_NORMAL
- en: Such language constructs largely reduce the redundancy of the code if the same
    task is run over and over again each time with some changes in input.
  prefs: []
  type: TYPE_NORMAL
- en: Using the for loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `for` loop evaluates an expression by iterating over a given vector or
    list. The syntax of a `for` loop is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, `expr` will be evaluated iteratively, with `var` taking the value of
    each element of `vector` in turn. If `vector` has `n` elements, then the preceding
    loop is equivalent to evaluating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, we can create a loop to iterate over `1:3` with iterator variable `i`.
    In each iteration, we will show text on the screen to indicate the value of `i`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The iterator works with not only numeric vectors but all vectors. For example,
    we can replace the integer vector `1:3` with a character vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also replace it with a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can replace it with a data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Previously, we mentioned that a data frame is a list in which each element (column)
    must have the same length. Therefore, the preceding loop iterates over the columns
    rather than rows, which is consistent with the behavior of `for` when it iterates
    over an ordinary list.
  prefs: []
  type: TYPE_NORMAL
- en: However, in many cases, we want to iterate over a data frame row by row. We
    can do this using `for`, but over an integer sequence from 1 to the number of
    rows of the data frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'As long as `i` gets a row number, we can single out that particular row from
    the data frame and do something with it. The following code iterates over a data
    frame row by row and prints the structure of each row using `str()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: I should give a little warning here that iterating over a data frame row by
    row is generally not a good idea because it can be slow and verbose. A better
    way is to use either the apply family functions covered in [Chapter 5](ch05.html
    "Chapter 5. Working with Basic Objects"), *Working with Basic Objects*, or more
    powerful yet advanced package functions covered in [Chapter 12](ch12.html "Chapter 12. Data
    Manipulation"), *Data Manipulation*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding examples, each iteration of the `for` loops is independent.
    In some cases, however, the iterations alter variables outside the loop to keep
    track of certain states or keep a record of an accumulation. The simplest example
    is counting the sum from 1 to 100:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example demonstrates an accumulation using the `for` loop. The
    following example produces a simple realization of a random walk using a random
    number generator that samples from normal distribution `rnorm()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The plot generated is as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the for loop](img/image_04_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Although the `for` loops in the preceding two examples have a one-step dependency
    on the previous result, they can be simplified using existing functions such as
    the `sum()` method and `cumsum()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The basic idea in the implementation of these functions is similar to the preceding
    `for` loops, but they are vectorized and implemented in C so that they can be
    a lot faster than a `for` loop in R. Therefore, you should first consider using
    these built-in functions if possible.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the flow of a for loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, it is useful to intervene in a `for` loop. In each iteration, we
    can choose to interrupt the `for` loop, to skip the current iteration, or do nothing
    and finish the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use break to terminate a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be used, for example, to find a solution to a problem. The following
    code attempts to find the numbers between 1,000 and 1,100 that satisfy `(i ^ 2)
    %% 11` equals `(i ^ 3) %% 17`, where `^` is the power operator and `%%` is the
    modulo operator that returns the remainder of a division:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'If you only need one number in the range to satisfy the condition, you can
    replace the record tracking expression with a simple break:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Once a solution is found, the `for` loop breaks and the last value of `i` is
    preserved in the current environment so that you know the solution that satisfies
    the condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some other cases, skipping an iteration in a `for` loop is also useful.
    We can use the `next` keyword to skip the rest expressions in the current iteration
    and directly jump to the next iteration of the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Creating nested for loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The expression in a `for` loop can be anything, including another `for` loop.
    For example, if we want to exhaust all permutations of the elements in a vector,
    we can write a two-level nested `for` loop to solve the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'If you only need permutations that contain distinct elements, you can add a
    test condition in the inner `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can just negate the condition and replace the expression
    in the inner `for` loop with the following code to get exactly the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code demonstrates how nested loops work, but it is not optimal
    to solve the problem. Some built-in functions help generate combinations or permutations
    of vector elements. The `combn()` method produces a matrix of combinations of
    vector elements, given an atomic vector and the number of elements in each combination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the preceding examples implemented using the `for` loop, `expand.grid()`
    produces a data frame containing all permutations of elements in multiple vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Although the `for` loop can be powerful, there are functions designed for certain
    tasks. It is better to consider using built-in functions than directly putting
    everything in a `for` loop. In the following chapter, I will introduce `lapply()`
    and related functions to replace many `for` loops, which makes code easier to
    write and understand.
  prefs: []
  type: TYPE_NORMAL
- en: Using the while loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In contrast to the `for` loop, the `while` loop does not stop running until
    the given condition is violated.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following `while` loop starts with `x = 0`. Each time, the
    loop checks whether `x <= 10` holds. If so, the inner expressions are evaluated;
    otherwise, the `while` loop terminates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: If we remove `x <- x + 1` so that `x` no longer gains any increment, the code
    will run forever (until R is terminated by force). Therefore, the while loop can
    sometimes be dangerous if not properly implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the `for` loop, flow control statements (`break` and `next`) are also
    applicable in `while`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'In practice, the `while` loop is often used where the number of iterations
    is unknown. This usually happens when we fetch rows chunk-by-chunk from the result
    set of a database query. The code may look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: First, we query all records whose type is 1 from a database through the con
    connection. Once the database returns a result set, `res`, we can fetch data from
    the result set chunk by chunk and process one chunk each time. Since the number
    of records is unknown prior to the query, we need to use a while loop that breaks
    when all data is completely fetched, which is indicated by `dbHasCompleted()`.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, we avoid fetching a (perhaps huge) data frame to memory. Instead,
    we work with small chunks. This allows us to process a large amount of data with
    only a small working set in memory. However, the major premise is that the algorithm
    `process()` must support processing data chunk by chunk.
  prefs: []
  type: TYPE_NORMAL
- en: You may not be familiar with the preceding code example or the terminologies,
    but don't worry. We will cover database topics in detail in a later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the `for` loop and the `while` loop, R also provides the `repeat`
    loop. Like `while (TRUE)`, the `repeat` keyword is also a real loop, because it
    does not require an explicit termination condition or boundary unless `break`
    is hit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: However, the `repeat` keyword can be very dangerous and is not recommended in
    practice.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the syntax of assignment, conditional expressions,
    and loops. In the section on assignment, you got to know the naming rules of variables
    and how to walk around. In the section on conditional expressions, you learned
    how to use the `if` statement as either a statement or an expression, and how `ifelse()`is
    distinct from `if` when dealing with vectors. In the section on loops, you learned
    about the similarities and differences between `for` loops and `while` loops.
    Now, we are equipped with the basic expressions to control the logic flow of an
    R program.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will use what you learned in the previous chapters
    and see what you can do with the basic objects representing data and basic expressions
    representing our logic. You will learn about basic functions in various categories
    as the building blocks of data transformation and statistical analysis.
  prefs: []
  type: TYPE_NORMAL
