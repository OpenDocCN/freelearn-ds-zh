- en: Chapter 4. Basic Expressions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 基本表达式
- en: Expressions are the building blocks of a function. R has a very clear syntax
    that suggests that an expression is either a symbol or a function call.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式是函数的构建块。R 有一个非常清晰的语法，表明一个表达式要么是一个符号，要么是一个函数调用。
- en: Although everything we do is in essence implemented by functions, R gives some
    functions a special syntax so that it is more friendly to write readable R code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们做的所有事情本质上都是由函数实现的，但 R 给一些函数提供了特殊的语法，以便编写更易于阅读的 R 代码。
- en: 'In the next few sections, we will see the following fundamental expressions
    that are given a special syntax:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将看到以下一些基本表达式，它们具有特殊的语法：
- en: Assignment expressions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋值表达式
- en: Conditional expressions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件表达式
- en: Loop expressions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环表达式
- en: Assignment expressions
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 赋值表达式
- en: Assignment may be one of the most fundamental expressions in all programming
    languages. What it does is assign or bind a value to a symbol so that we can refer
    to the value by that symbol later.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值可能是所有编程语言中最基本的表达式之一。它所做的就是将值分配或绑定到符号上，这样我们就可以通过该符号稍后引用该值。
- en: 'Despite the similarity, R adopts the `<-` operator to perform assignment. This
    is a bit different from many other languages using `=` although this is also allowed
    in R:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管相似，R 使用 `<-` 操作符进行赋值。这与许多使用 `=` 的其他语言略有不同，尽管在 R 中也允许使用 `=`：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We don't have to declare the symbol and its type before assigning a value to
    it. If a symbol does not exist in the environment, the assignment will create
    that symbol. If a symbol already exists, the assignment will not end up in conflict,
    but will rebind the new value to that symbol.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在给符号赋值之前不需要声明其符号和类型。如果一个符号在环境中不存在，赋值将创建该符号。如果符号已经存在，赋值不会导致冲突，而是将新值重新绑定到该符号上。
- en: Alternative assignment operators
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替代赋值操作符
- en: 'There are some alternate yet equivalent operators we can use. Compared to `x
    <- f(z)`, which binds the value of `f(z)` to symbol `x`, we can also use `->`
    to perform assignment in the opposite direction:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一些等价的替代操作符。与 `x <- f(z)` 相比，它将 `f(z)` 的值绑定到符号 `x` 上，我们也可以使用 `->` 来执行相反方向的赋值：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can even chain the assignment operators so that a set of symbols all take
    the same value:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以将赋值操作符链式使用，以便一组符号都取相同的值：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The expression `0` is evaluated only once so that the same value is assigned
    to the three symbols. To verify how it works, we can change`0` to a random number
    generator:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式 `0` 只计算一次，因此相同的值被分配给三个符号。为了验证其工作原理，我们可以将 `0` 改为一个随机数生成器：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `rnorm(1)` method generates a random number following the standard normal
    distribution. If each assignment re-invokes the random number generator, each
    symbol will have different values. In fact, however, it does not happen. Later,
    I will explain what really happens and you will have a better understanding of it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`rnorm(1)` 方法生成一个符合标准正态分布的随机数。如果每次赋值都重新调用随机数生成器，每个符号将具有不同的值。然而，实际上并不会发生这种情况。稍后，我将解释究竟发生了什么，并帮助你更好地理解这一点。'
- en: 'Like other programming languages, `=` also can perform assignment:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他编程语言一样，`=` 也可以执行赋值：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you are familiar with other popular programming languages such as Python,
    Java, and C#, you may find it almost an industry standard to use `=` as the assignment
    operator and may feel uncomfortable using `<-`, which requires more typing. However,
    Google's *R Style Guide* ([https://google.github.io/styleguide/Rguide.xml#assignment](https://google.github.io/styleguide/Rguide.xml#assignment))
    suggests the usage of `<-` instead of `=`, even though both are allowed and have
    exactly the same effect when they are used as assignment operators.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉其他流行的编程语言，如 Python、Java 和 C#，你可能会发现使用 `=` 作为赋值操作符几乎成为行业标准，可能会觉得使用 `<-`
    不舒服，因为需要更多输入。然而，谷歌的 *R 风格指南* ([https://google.github.io/styleguide/Rguide.xml#assignment](https://google.github.io/styleguide/Rguide.xml#assignment))
    建议使用 `<-` 而不是 `=`，尽管两者都被允许，并且当它们用作赋值操作符时具有完全相同的效果。
- en: 'Here, I will provide a simple explanation to the subtle difference between
    `<-` and `=`. Let''s first create a `f()` function that takes two arguments:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我将提供一个简单的解释来说明 `<-` 和 `=` 之间的细微差别。让我们首先创建一个 `f()` 函数，它接受两个参数：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The function basically prints the value of the two arguments. Then, let''s
    use this function to demonstrate the difference between the two operators:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数基本上打印两个参数的值。然后，让我们使用这个函数来展示两个操作符之间的区别：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding code uses both `<-` and `=` operators but they play different
    roles. The `<-` operator in the first two lines is used as an assignment operator,
    while `=` in the third line specifies a named argument input for the `f()` method.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用了 `<-` 和 `=` 操作符，但它们扮演不同的角色。前两行中的 `<-` 操作符用作赋值操作符，而第三行中的 `=` 在 `f()` 方法中指定了一个命名参数
    `input`。
- en: More specifically, the `<-` operator evaluates the expression on its right-hand
    side `c(1, 2, 3)` and assigns the evaluated value to the symbol (variable) on
    the left-hand side `x`. The `=` operator is not used as an assignment operator
    but to match the function argument by name.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，`<-` 操作符评估其右侧的表达式 `c(1, 2, 3)` 并将评估后的值赋给左侧的符号（变量）`x`。`=` 操作符不作为赋值操作符使用，而是用于通过名称匹配函数参数。
- en: 'We know that the `<-` and `=` operators are interchangeable when they are used
    as assignment operators. Therefore, the preceding code is equivalent to the following
    code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道当作为赋值操作符使用时，`<-` 和 `=` 操作符是可以互换的。因此，前面的代码等同于以下代码：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, we only use the `=` operator but for two different purposes: in the first
    two lines, `=` performs an assignment, while in the third line `=` specifies the
    named argument.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只使用了 `=` 操作符，但用于两个不同的目的：在前两行中，`=` 执行赋值，而在第三行中 `=` 指定了命名参数。
- en: 'Now, let''s see what happens if we change every `=` to `<-`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如果我们将所有的 `=` 都改为 `<-` 会发生什么：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you run this code, you will find that the outputs are similar. However,
    if you inspect the environment, you will observe the difference: a new `input`
    variable is now created in the environment and gains the value of `c(1, 2, 3)`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这段代码，你会发现输出相似。然而，如果你检查环境，你会观察到差异：现在环境中创建了一个新的 `input` 变量，并获得了 `c(1, 2,
    3)` 的值：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'So, what happened? Actually, in the third line, two things happened: First,
    the assignment, `input <- x`, introduces a new `input` symbol to the environment
    and results in `x`. Then, the value of `input` is provided to the first argument
    of function `f()`. In other words, the first function argument is not matched
    by name but by position.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，发生了什么？实际上，在第三行中发生了两件事：首先，赋值 `input <- x` 将一个新的 `input` 符号引入环境并得到 `x`。然后，`input`
    的值提供给函数 `f()` 的第一个参数。换句话说，第一个函数参数不是通过名称匹配，而是通过位置匹配。
- en: 'To elaborate, we will conduct more experiments. The standard usage of the function
    is as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步阐述，我们将进行更多实验。函数的标准用法如下：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we replace both `=` with `<-`, the result looks the same:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将两个 `=` 都替换为 `<-`，结果看起来相同：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For the code using `=`, we can exchange the two named arguments without changing
    the result:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用 `=` 的代码，我们可以交换两个命名参数而不改变结果：
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this case, however, if we exchange `=` for `<-`, the values of `input` and `data` are
    also exchanged:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这种情况下，如果我们用 `<-` 代替 `=`，`input` 和 `data` 的值也会交换：
- en: '[PRE13]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following code has the same effect as that of the preceding code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码与前面代码具有相同的效果：
- en: '[PRE14]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This code not only results in `f(y, x)`, but unnecessarily creates additional `data`
    and `input` variables in the current environment.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码不仅导致 `f(y, x)`，而且在不必要的情况下在当前环境中创建了额外的 `data` 和 `input` 变量。
- en: From the preceding examples and experiments, the bottom line is clear. To reduce
    ambiguity, it is allowed to use either `<-` or `=` as the assignment operator
    and only use `=` to specify the named argument for functions. In conclusion, for
    better readability of R code, as the Google Style Guide suggests, only use `<-`
    for assignment and `=` to specify named arguments.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的例子和实验中，我们可以得出结论。为了减少歧义，允许使用 `<-` 或 `=` 作为赋值操作符，并且只使用 `=` 为函数指定命名参数。总之，为了提高
    R 代码的可读性，正如 Google 风格指南所建议的，只使用 `<-` 进行赋值，使用 `=` 指定命名参数。
- en: Using backticks with non-standard names
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用非标准名称的反引号
- en: Assignment operators allow us to assign a value to a variable (or a symbol or
    name). However, direct assignment limits the format of the name. It contains only
    letters from a to z, A to Z (R is case-sensitive), the underscore(`_`), and dot(`.`),
    and it should not contain spaces or start with an underscore(`_`).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值操作符允许我们将值赋给变量（或符号或名称）。然而，直接赋值限制了名称的格式。它只包含从 a 到 z，从 A 到 Z 的字母（R 区分大小写），下划线（`_`）和点（`.`），并且不应包含空格或以下划线开头（`_`）。
- en: 'The following are some valid names:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些有效的名称：
- en: '[PRE15]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following are invalid names due to violating naming rules:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下名称无效，因为违反了命名规则：
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding names violate the rules in different ways. The `some data` variable
    name contains a space, `_data` starts with `_`, and `Population(Millions)` is
    not a symbol name but a function call. In practice, it is quite likely that some
    invalid names might indeed be column names in a data table, such as the third
    name.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的名称以不同的方式违反了规则。`some data`变量名包含空格，`_data`以下划线开头，而`Population(Millions)`不是一个符号名，而是一个函数调用。在实践中，某些无效的名称确实可能是数据表中的列名，例如第三个名称。
- en: 'To walk around, we need to use back-ticks to quote the invalid names to make
    them valid:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绕过这个问题，我们需要使用反引号来引用无效的名称，使其变得有效：
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To refer to these variables, also use backticks; otherwise, they will still
    be regarded as invalid:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要引用这些变量，也使用反引号；否则，它们仍然被视为无效：
- en: '[PRE18]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Backticks can be used wherever we create a symbol, irrespective of whether
    it is a function:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 反引号可以在我们创建符号的任何地方使用，无论它是否是一个函数：
- en: '[PRE19]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It does not even matter if it is a list:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 即使它是一个列表：
- en: '[PRE20]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If the symbol name cannot be validly referred to directly, we also need to
    use quotation marks to refer to the symbol:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果符号名不能直接有效引用，我们还需要使用引号来引用该符号：
- en: '[PRE21]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'An exception is `data.frame()`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`data.frame()`是一个例外：'
- en: '[PRE22]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Unfortunately, even if we use backticks around a name with unusual symbols,
    the resulting `data.frame` variable will replace those symbols with the dots or
    using `make.names()`, a method that can be confirmed by looking at the column
    names of the resulting `data.frame`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，即使我们在具有不寻常符号的名称周围使用反引号，生成的`data.frame`变量也会用点替换这些符号或使用`make.names()`方法，这一点可以通过查看生成的`data.frame`的列名来确认：
- en: '[PRE23]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This often happens when you import a table such as the following CSV data resulted
    from an experiment:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况通常发生在你导入如下CSV数据表时，该数据表是实验结果：
- en: '[PRE24]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When you read the CSV data using `read.csv()`, the `Population(before)` and `Population(after)` variable
    will not preserve their original names, but will change them to valid names in
    R using the `make.names()` method. To know what names we will get, we can run
    the following command:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`read.csv()`读取CSV数据时，`Population(before)`和`Population(after)`变量将不会保留它们的原始名称，而是会使用`make.names()`方法在R中将它们更改为有效的名称。要了解我们将得到什么名称，我们可以运行以下命令：
- en: '[PRE25]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Sometimes, this behavior is undesirable. To disable it, set `check.names =
    FALSE` when you call either `read.csv()` or `data.frame()`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，这种行为是不希望的。要禁用它，在调用`read.csv()`或`data.frame()`时设置`check.names = FALSE`：
- en: '[PRE26]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding call, `stringAsFactors = FALSE` avoids converting character
    vectors to factors and `check.names = FALSE` avoids applying `make.names()` on
    the column names. With these two arguments, the `data.frame` variable created
    will preserve most aspects of the input data.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的调用中，`stringAsFactors = FALSE`避免了将字符向量转换为因子，`check.names = FALSE`避免了在列名上应用`make.names()`。有了这两个参数，创建的`data.frame`变量将保留输入数据的大部分方面。
- en: 'Just as I mentioned, to access the column with special symbols, use backticks
    to quote the name:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我提到的，要访问具有特殊符号的列，使用反引号来引用名称：
- en: '[PRE27]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Backticks make it possible to create and access variables, with symbols not
    allowed in direct assignment. This does not mean using such names is recommended.
    Rather, it can make the code harder to read and more error-prone, and it makes
    it more difficult to work with external tools that impose strict naming rules.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 反引号使得创建和访问变量成为可能，直接赋值时不允许使用符号。这并不意味着使用这样的名称是推荐的。相反，它可能会使代码更难以阅读和更容易出错，并且使得与强制执行严格命名规则的外部工具一起工作变得更加困难。
- en: In conclusion, using backticks to create special variable names should be avoided
    unless absolutely necessary.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，除非绝对必要，否则应避免使用反引号创建特殊变量名。
- en: Conditional expressions
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件表达式
- en: It is common that the logic of a program is not perfectly sequential but contains
    several branches dependent on certain conditions. Therefore, one of the most basic
    constructs of a typical programming language is its conditional expressions. In
    R, `if` can be used to branch the logic flow by logical conditions.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，程序的逻辑不是完全顺序的，而是包含依赖于某些条件的几个分支。因此，典型编程语言中最基本的构造之一是其条件表达式。在R中，`if`可以通过逻辑条件来分支逻辑流程。
- en: Using if as a statement
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用if作为语句
- en: 'Like many other programming languages, the `if` expression works with a logical
    condition. In R, a logical condition is represented by an expression producing
    a single-element logical vector. For example, we can write a simple function `check_positive`
    that returns `1` if a positive number is provided and nothing otherwise:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他编程语言一样，`if`表达式与逻辑条件一起工作。在R中，逻辑条件由产生单个元素逻辑向量的表达式表示。例如，我们可以编写一个简单的函数`check_positive`，如果提供正数则返回`1`，否则不返回任何内容：
- en: '[PRE28]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the preceding function, `x > 0` is the condition to check. If the condition
    is satisfied, then the function returns `1`. Let''s verify the function with various
    inputs:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数中，`x > 0`是检查的条件。如果条件满足，则函数返回`1`。让我们用各种输入来验证这个函数：
- en: '[PRE29]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'It seems that the function works as expected. If we add some `else if` and `else`
    branches, the function can be generalized as the sign function that returns **1**
    for positive input, `-1` for negative input, and `0` for 0:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来函数按预期工作。如果我们添加一些`else if`和`else`分支，函数可以概括为返回**1**的正输入，负输入返回`-1`，0返回0的符号函数：
- en: '[PRE30]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The preceding function has the same functionality as the built-in function
    `sign()`. To verify its logic, just call it with different inputs with full coverage
    of the conditional branches:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数与内置函数`sign()`具有相同的功能。为了验证其逻辑，只需用不同输入调用它，并全面覆盖条件分支即可：
- en: '[PRE31]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The function does not need to return anything. We can also perform actions
    that return nothing (more accurately, `NULL`) depending on various conditions.
    The following function always does not explicitly return a value, but it sends
    a message in the console. The kind of message depends on the sign of the input
    number:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 函数不需要返回任何内容。我们也可以根据各种条件执行不返回任何内容（更准确地说，是`NULL`）的操作。以下函数始终不显式返回值，但会在控制台发送消息。消息的类型取决于输入数字的符号：
- en: '[PRE32]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can use a similar method, that is `say_sign()`, to test its logic:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类似的方法，即`say_sign()`，来测试其逻辑：
- en: '[PRE33]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The workflow for evaluating `if` statement branches is quite straightforward:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 评估`if`语句分支的工作流程相当直接：
- en: First, evaluate `cond1` in the first `if (cond1) { expr1 }`.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在第一个`if (cond1) { expr1 }`中评估`cond1`。
- en: If `cond1` is `TRUE`, then evaluate its corresponding expression `{ expr1 }`.
    Otherwise, evaluate the `cond2` condition in the next `else if (cond2)` branch
    and so forth.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`cond1`是`TRUE`，则评估其对应的表达式`{ expr1 }`。否则，评估下一个`else if (cond2)`分支中的`cond2`条件，依此类推。
- en: If the conditions in all `if` and `else if` branches are violated, then evaluate
    the expression in the `else` branch, if any.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果所有`if`和`else if`分支的条件都被违反，那么如果存在，评估`else`分支中的表达式。
- en: According to the workflow, an `if` statement can be more flexible than you might
    think. For example, an `if` statement can be in one of the following forms.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 根据工作流程，`if`语句可能比你想象的更灵活。例如，`if`语句可以有以下几种形式之一。
- en: 'The simplest form is a simple `if` statement branch:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的形式是一个简单的`if`语句分支：
- en: '[PRE34]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'A more complete form is with an `else` branch that deals with situations where `cond1`
    is not `TRUE`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 更完整的形式是包含一个`else`分支，用于处理`cond1`不是`TRUE`的情况：
- en: '[PRE35]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'An even more complex form is with one or more `else if` branches:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的形式是包含一个或多个`else if`分支：
- en: '[PRE36]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the preceding conditional branches, the branch conditions (`cond1`, `cond2`,
    and `cond3`) may or may not be related. For example, the simple grading policy
    perfectly fits the branching logic in the preceding template in which each branch
    condition is a slice of the score range:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的条件分支中，分支条件（`cond1`、`cond2`和`cond3`）可能相关也可能不相关。例如，简单的评分策略完美地符合前面模板中的分支逻辑，其中每个分支条件都是分数范围的切片：
- en: '[PRE37]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this case, each branch condition in `else if` actually implicitly assumes
    that the previous condition does not hold; that is, `score >= 80` actually means `score
    < 90` and `score >= 80`, which is dependent on previous conditions. As a result,
    we cannot switch the order of these branches without explicitly stating the assumptions
    and making all branches independent.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`else if`中的每个分支条件实际上隐含地假设前面的条件不成立；也就是说，`score >= 80`实际上意味着`score < 90`和`score
    >= 80`，这依赖于前面的条件。因此，我们无法在不明确陈述假设并使所有分支独立的情况下改变这些分支的顺序。
- en: 'Let''s assume we switch some of the branches:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们切换了一些分支：
- en: '[PRE38]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'It is obvious that only `grade(59)` got the right grade and all others are
    broken. To fix the function without reordering the conditions, we need to rewrite
    the condition so that they do not depend on the order of evaluation:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，只有`grade(59)`得到了正确的成绩，而其他所有都失败了。为了在不重新排序条件的情况下修复函数，我们需要重新编写条件，使它们不依赖于评估顺序：
- en: '[PRE39]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This makes the function much more verbose than the first correct version. Therefore,
    it is important to figure out the correct order for branch conditions and be careful
    of the dependency of each branch.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得函数比第一个正确版本更冗长。因此，确定分支条件的正确顺序并注意每个分支的依赖性非常重要。
- en: Fortunately, R provides convenient functions such as `cut()`, which does exactly
    the same thing. Read the documentation by typing in `?cut` for more details.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，R提供了方便的函数，如`cut()`，它正好做同样的事情。通过输入`?cut`来阅读文档以获取更多详细信息。
- en: Using if as an expression
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将if用作表达式
- en: 'Since `if` is in essence a primitive function, its returned value is the value
    of the expression in the branch whose condition is satisfied. Therefore, `if`
    can be used as an inline expression too. Take the `check_positive()` method for
    example. Rather than writing `return()` in the conditional expression, we can
    also return the value of the `if` statement expression in the function body to
    achieve the same goal:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`if`本质上是一个原始函数，其返回值是满足条件的分支中的表达式值。因此，`if`也可以用作内联表达式。以`check_positive()`方法为例。我们可以在条件表达式中不写`return()`，而是在函数体中返回`if`语句表达式的值，以达到相同的目的：
- en: '[PRE40]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In fact, the expression syntax can to be simplified to merely one line:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，表达式语法可以简化为仅仅一行：
- en: '[PRE41]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Since the return value of a function is the value of its last expression in
    the function body, `return()` can be removed in this case:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数的返回值是函数体中最后一个表达式的值，在这种情况下可以省略`return()`：
- en: '[PRE42]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The same principle also applies to the `check_sign()` method. A simpler form
    of `check_sign()` is as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的原则也适用于`check_sign()`方法。`check_sign()`的一个更简单的形式如下：
- en: '[PRE43]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To explicitly get the value of the `if` expression, we can implement a grade
    reporting function that mentions the grade of a student, given the student name
    and their score:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显式获取`if`表达式的值，我们可以实现一个成绩报告函数，该函数根据学生姓名和他们的分数提及学生的成绩：
- en: '[PRE44]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Using the `if` statement as an expression seems more compact and less verbose.
    However, in practice, it is rarely the case that all conditions are simple numeric
    comparisons and return simple values. For more complex conditions and branching,
    I suggest that you use `if` as a statement to clearly state different branches
    and do not omit `{}` to avoid unnecessary mistakes. The following function is
    a bad example:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 将`if`语句用作表达式看起来更紧凑，也更简洁。然而，在实践中，并非所有条件都是简单的数值比较并返回简单值。对于更复杂的条件和分支，我建议您使用`if`作为语句来清楚地说明不同的分支，并且不要省略`{}`以避免不必要的错误。以下是一个不好的例子：
- en: '[PRE45]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The function author wants to add something to say to some branches. Without
    `{}` brackets around the branch expression, you are very likely to write code
    with syntax errors when you add more behaviors to conditional branches. If you
    evaluate the preceding code in the console, you will get enough errors to confuse
    you for a while:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 函数作者想要向某些分支添加一些说明。如果没有在分支表达式周围使用`{}`括号，当您向条件分支添加更多行为时，您很可能编写出有语法错误的代码。如果您在控制台中评估前面的代码，您将得到足够的错误，让您困惑一段时间：
- en: '[PRE46]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'A better form of the function that avoids such potential pitfalls is as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 避免这种潜在陷阱的函数更好形式如下：
- en: '[PRE47]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The function seems a bit more verbose, but it is more robust to changes and
    clearer in its logic. Remember, it is always better to be correct than short.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 函数看起来有点冗长，但它对变化的鲁棒性更强，逻辑也更清晰。记住，总是正确比简洁更重要。
- en: Using if with vectors
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将if与向量一起使用
- en: 'All the example functions created earlier only work with a single-value input.
    If we provide a vector, the functions will produce warnings because if does not
    work with multi-element vectors:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的示例函数都只适用于单值输入。如果我们提供一个向量，函数将产生警告，因为`if`不适用于多元素向量：
- en: '[PRE48]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'From the preceding output, we can see that the `if` statement ignores all but
    the first element, if a multi-element logical vector is supplied:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，我们可以看到，如果提供了多元素逻辑向量，`if`语句会忽略除了第一个元素之外的所有元素：
- en: '[PRE49]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The expression throws a warning saying that only the first element (`1 > 2`)
    will be used. In fact, its logic is unclear when we try to condition an expression
    on a logical vector since its values can be mixed up with `TRUE` and `FALSE` values.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式会抛出一个警告，说明只会使用第一个元素（`1 > 2`）。实际上，当我们尝试在逻辑向量上条件化表达式时，其逻辑是不清晰的，因为其值可能会与`TRUE`和`FALSE`值混淆。
- en: 'Some logical functions are useful to avoid such ambiguity. For example, the `any()`
    method returns `TRUE` if at least one element in the given vector is `TRUE`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一些逻辑函数有助于避免这种歧义。例如，`any()`方法如果给定向量中至少有一个元素是`TRUE`，则返回`TRUE`：
- en: '[PRE50]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Therefore, if what we really mean is to print the message if any single value
    is greater than `2`, we should call the `any()` method in the condition:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们真正想要打印消息，如果任何单个值大于`2`，我们应该在条件中调用`any()`方法：
- en: '[PRE51]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If we mean to print the first message if all values are greater than `2`, we
    should instead call the `all()` method:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要打印第一个消息，如果所有值都大于`2`，我们应该改用调用`all()`方法：
- en: '[PRE52]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Therefore, every time we use an `if` expression to branch the workflow, we should
    ensure that the condition is a single-value logical vector. Otherwise, something
    unexpected may happen.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每次我们使用`if`表达式分支工作流程时，我们应该确保条件是一个单值逻辑向量。否则，可能会发生意外的情况。
- en: 'Another exception is `NA`, which is also a single-value logical vector but
    can cause an error as an `if` condition without notice:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例外是`NA`，它也是一个单值逻辑向量，但如果没有注意可能会在`if`条件中引起错误：
- en: '[PRE53]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `check()` function works perfectly for typical numeric vectors with no
    missing values. However, if argument `x` contains a missing value, the function
    may end up in an error:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`check()`函数对于没有缺失值的典型数值向量工作得很好。然而，如果参数`x`包含缺失值，函数最终可能会出错：'
- en: '[PRE54]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: From this example, we should be careful of missing values when we write `if`
    conditions. If the logic is complicated and the input data is diverse, you cannot
    easily walk around handling missing values in appropriate ways. Note that the `any()`
    and `all()` methods both accept `na.rm` to handle missing values. We should take
    this into account too when writing conditions.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中，我们应该在编写`if`条件时小心缺失值。如果逻辑复杂且输入数据多样，您不能轻易地以适当的方式处理缺失值。请注意，`any()`和`all()`方法都接受`na.rm`来处理缺失值。我们在编写条件时也应该考虑这一点。
- en: One way to simplify condition checking is to use `isTRUE(x)`, which calls  `identical(TRUE,
    x)` internally. In this case, only a single `TRUE` value will meet the condition
    and all other values will not.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 简化条件检查的一种方法是用`isTRUE(x)`，它内部调用`identical(TRUE, x)`。在这种情况下，只有单个`TRUE`值会满足条件，而所有其他值则不会。
- en: 'Using vectorized if: ifelse'
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用向量化的`ifelse`：`ifelse`
- en: 'An alternate method to branch a computation is `ifelse()`. This function accepts
    a logical vector as the test condition and returns a vector. For each element
    in the logical test condition, if the value is `TRUE`, then the corresponding
    element in the second argument `yes` will be chosen. If the value is `FALSE`,
    then the corresponding element in the third argument `no` will be chosen. In other
    words, `ifelse()` is the vectorized version of `if`, as demonstrated here:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 分支计算的另一种方法是`ifelse()`。这个函数接受一个逻辑向量作为测试条件，并返回一个向量。对于逻辑测试条件中的每个元素，如果值为`TRUE`，则选择第二个参数`yes`中的相应元素。如果值为`FALSE`，则选择第三个参数`no`中的相应元素。换句话说，`ifelse()`是`if`的向量版本，如下所示：
- en: '[PRE55]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Since the `yes` and `no` arguments can be recycled, we can rewrite `check_positive()`
    using `ifelse()`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`yes`和`no`参数可以被回收利用，我们可以使用`ifelse()`重新编写`check_positive()`函数：
- en: '[PRE56]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: One difference between `check_positive()` (using the `if` statement) and `check_positive2()`
    (using `ifelse`) is subtle: `check_positive(-1)` does not return values explicitly,
    but `chek_positive2(-1)` returns 0\. The `if` statement does not necessarily return
    a value explicitly by using only one `if` but not `else`. By contrast, `ifelse()`
    always returns a vector because you have to specify the values in both `yes` and `no`
    arguments.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`check_positive()`（使用`if`语句）和`check_positive2()`（使用`ifelse`）之间的一个细微差别是：`check_positive(-1)`不会显式地返回值，但`chek_positive2(-1)`返回0。`if`语句不一定通过仅使用一个`if`而不是`else`来显式地返回一个值。相比之下，`ifelse()`总是返回一个向量，因为您必须在`yes`和`no`参数中指定值。'
- en: 'Another reminder is that `ifelse()` and `if` are not always able to achieve
    the same goal if you simply replace one with the other. For example, imagine you
    want to return a two-element vector according to a condition. Let''s assume we
    use `ifelse()`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个提醒是，如果你只是简单地将一个替换为另一个，`ifelse()` 和 `if` 并不一定总是能够达到相同的目标。例如，假设你想根据条件返回一个包含两个元素的向量。让我们假设我们使用
    `ifelse()`：
- en: '[PRE57]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Only the first element of the `yes` argument is returned. If you want to return
    the `yes` argument, you need to modify the condition to `c(TRUE, TRUE)`, which
    looks a bit unnatural.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 只有 `yes` 参数的第一个元素被返回。如果你想返回 `yes` 参数，你需要修改条件为 `c(TRUE, TRUE)`，这看起来有点不自然。
- en: 'If we use `if`, then the expression looks much more natural:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `if`，那么表达式看起来会更加自然：
- en: '[PRE58]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If the demand is a vectorized input and output, then another problem is that,
    if the `yes` argument is a numeric vector and the `no` argument is a character
    vector, a condition with mixed `TRUE` and `FALSE` values will coerce all elements
    in the output vector to be able to represent all values. Thus, a character vector
    is produced:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需求是矢量化输入和输出，那么另一个问题是，如果 `yes` 参数是数值向量而 `no` 参数是字符向量，则具有混合 `TRUE` 和 `FALSE`
    值的条件将强制输出向量中的所有元素能够表示所有值。因此，将产生一个字符向量：
- en: '[PRE59]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Using switch to branch values
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 switch 分支值
- en: In contrast with if, which deals with `TRUE` and `FALSE` conditions, `switch`
    works with a number or a string and chooses a branch to return according to the
    input.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 与处理 `TRUE` 和 `FALSE` 条件的 `if` 相比，`switch` 使用数字或字符串，并根据输入选择一个分支返回。
- en: 'Suppose the input is an integer `n`. The `switch` keyword works in a way that
    returns the value of the n^(th) arguments in following the first argument:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 假设输入是一个整数 `n`。`switch` 关键字以返回第一个参数之后 n^(th) 个参数值的方式工作：
- en: '[PRE60]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'If the input integer is out of bounds and does not match any given argument,
    no visible value is explicitly returned (in fact, an invisible `NULL` is returned):'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入的整数超出范围且不匹配任何给定参数，则不会显式返回任何可见值（实际上，返回了一个不可见的 `NULL`）：
- en: '[PRE61]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `switch()` method has a different behavior when working with string input.
    It returns the value of the first argument that matches its name with the input:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当与字符串输入一起工作时，`switch()` 方法的行为有所不同。它返回与输入名称匹配的第一个参数的值：
- en: '[PRE62]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'For the first `switch`, `a = 1` matches the variable `a`. For the second, `b
    = 2` matches the variable `b`. If no argument matches the input, an invisible `NULL`
    value will be returned:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个 `switch`，`a = 1` 匹配变量 `a`。对于第二个，`b = 2` 匹配变量 `b`。如果没有参数匹配输入，将返回一个不可见的
    `NULL` 值：
- en: '[PRE63]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'To cover all possibilities, we can add a last argument (without argument name)
    that captures all other inputs:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了涵盖所有可能性，我们可以添加一个最后一个参数（不带参数名称），以捕获所有其他输入：
- en: '[PRE64]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Compared to the `ifelse()` method, `switch()` behaves more like `if()` method.
    It only accepts a single value input (number of string) but it can return anything:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `ifelse()` 方法相比，`switch()` 的行为更类似于 `if()` 方法。它只接受单个值输入（字符串数量），但它可以返回任何内容：
- en: '[PRE65]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In conclusion, `if`, `ifelse()`, and `switch()` have slightly different behaviors.
    You should apply them in different situations accordingly.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`if`、`ifelse()` 和 `switch()` 有略微不同的行为。你应该根据不同的情况相应地应用它们。
- en: Loop expressions
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环表达式
- en: Loop (or iteration) evaluates an expression repeatedly by either iterating over
    a vector (`for`) or checking whether a condition is violated (while).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 循环（或迭代）通过遍历向量（`for`）或检查条件是否被违反（`while`）来重复评估表达式。
- en: Such language constructs largely reduce the redundancy of the code if the same
    task is run over and over again each time with some changes in input.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果相同的任务每次运行时都进行一些输入上的更改，这种语言结构在很大程度上减少了代码的冗余。
- en: Using the for loop
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 for 循环
- en: 'The `for` loop evaluates an expression by iterating over a given vector or
    list. The syntax of a `for` loop is as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环通过遍历给定的向量或列表来评估表达式。`for` 循环的语法如下：'
- en: '[PRE66]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Then, `expr` will be evaluated iteratively, with `var` taking the value of
    each element of `vector` in turn. If `vector` has `n` elements, then the preceding
    loop is equivalent to evaluating:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`expr` 将迭代评估，`var` 依次取 `vector` 中每个元素的值。如果 `vector` 有 `n` 个元素，则前面的循环相当于评估以下表达式：
- en: '[PRE67]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'For example, we can create a loop to iterate over `1:3` with iterator variable `i`.
    In each iteration, we will show text on the screen to indicate the value of `i`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以创建一个循环来遍历 `1:3`，迭代变量为 `i`。在每次迭代中，我们将在屏幕上显示文本以指示 `i` 的值：
- en: '[PRE68]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The iterator works with not only numeric vectors but all vectors. For example,
    we can replace the integer vector `1:3` with a character vector:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器不仅与数值向量一起工作，还与所有向量一起工作。例如，我们可以用字符向量替换整数向量`1:3`：
- en: '[PRE69]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We can also replace it with a list:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以用列表替换它：
- en: '[PRE70]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Alternatively, we can replace it with a data frame:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以用数据框替换它：
- en: '[PRE71]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Previously, we mentioned that a data frame is a list in which each element (column)
    must have the same length. Therefore, the preceding loop iterates over the columns
    rather than rows, which is consistent with the behavior of `for` when it iterates
    over an ordinary list.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们提到，数据框是一个列表，其中每个元素（列）必须具有相同的长度。因此，前面的循环是遍历列而不是行，这与`for`遍历普通列表时的行为一致。
- en: However, in many cases, we want to iterate over a data frame row by row. We
    can do this using `for`, but over an integer sequence from 1 to the number of
    rows of the data frame.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在许多情况下，我们希望逐行遍历数据框。我们可以使用`for`循环来实现这一点，但遍历的是从1到数据框行数的整数序列。
- en: 'As long as `i` gets a row number, we can single out that particular row from
    the data frame and do something with it. The following code iterates over a data
    frame row by row and prints the structure of each row using `str()`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 只要`i`获取行号，我们就可以从数据框中单独提取那一行并对其进行操作。以下代码逐行遍历数据框并使用`str()`打印每行的结构：
- en: '[PRE72]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: I should give a little warning here that iterating over a data frame row by
    row is generally not a good idea because it can be slow and verbose. A better
    way is to use either the apply family functions covered in [Chapter 5](ch05.html
    "Chapter 5. Working with Basic Objects"), *Working with Basic Objects*, or more
    powerful yet advanced package functions covered in [Chapter 12](ch12.html "Chapter 12. Data
    Manipulation"), *Data Manipulation*.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该在这里提醒一下，逐行遍历数据框通常不是一个好主意，因为它可能很慢且冗长。更好的方法是使用第5章中介绍的`apply`族函数，或者第12章中介绍的更强大、更高级的包函数。
- en: 'In the preceding examples, each iteration of the `for` loops is independent.
    In some cases, however, the iterations alter variables outside the loop to keep
    track of certain states or keep a record of an accumulation. The simplest example
    is counting the sum from 1 to 100:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`for`循环的每次迭代都是独立的。然而，在某些情况下，迭代会改变循环外的变量以跟踪某些状态或记录累积。最简单的例子是从1加到100的求和：
- en: '[PRE73]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The preceding example demonstrates an accumulation using the `for` loop. The
    following example produces a simple realization of a random walk using a random
    number generator that samples from normal distribution `rnorm()`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子演示了使用`for`循环进行累积。下面的例子使用从正态分布`rnorm()`采样的随机数生成器产生一个简单的随机游走实现：
- en: '[PRE74]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The plot generated is as shown:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图如下所示：
- en: '![Using the for loop](img/image_04_001.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![使用for循环](img/image_04_001.jpg)'
- en: 'Although the `for` loops in the preceding two examples have a one-step dependency
    on the previous result, they can be simplified using existing functions such as
    the `sum()` method and `cumsum()`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面两个例子中的`for`循环对前一个结果有一个一步的依赖关系，但可以使用现有的函数（如`sum()`方法和`cumsum()`）来简化它们：
- en: '[PRE75]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The basic idea in the implementation of these functions is similar to the preceding
    `for` loops, but they are vectorized and implemented in C so that they can be
    a lot faster than a `for` loop in R. Therefore, you should first consider using
    these built-in functions if possible.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的实现基本思想与前面的`for`循环类似，但它们是向量化的，并在C语言中实现，因此它们比R中的`for`循环要快得多。因此，如果可能的话，你应该首先考虑使用这些内置函数。
- en: Managing the flow of a for loop
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理for循环的流程
- en: Sometimes, it is useful to intervene in a `for` loop. In each iteration, we
    can choose to interrupt the `for` loop, to skip the current iteration, or do nothing
    and finish the loop.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在`for`循环中干预是有用的。在每次迭代中，我们可以选择中断`for`循环，跳过当前迭代，或者什么都不做并完成循环。
- en: 'We can use break to terminate a `for` loop:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`break`来终止`for`循环：
- en: '[PRE76]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This can be used, for example, to find a solution to a problem. The following
    code attempts to find the numbers between 1,000 and 1,100 that satisfy `(i ^ 2)
    %% 11` equals `(i ^ 3) %% 17`, where `^` is the power operator and `%%` is the
    modulo operator that returns the remainder of a division:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用来，例如，找到一个问题的解决方案。以下代码尝试找到满足`(i ^ 2) %% 11`等于`(i ^ 3) %% 17`的数字，其中`^`是幂运算符，`%%`是取模运算符，它返回除法的余数：
- en: '[PRE77]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'If you only need one number in the range to satisfy the condition, you can
    replace the record tracking expression with a simple break:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需要范围内的一个数字来满足条件，你可以用简单的 `break` 语句替换记录跟踪表达式：
- en: '[PRE78]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Once a solution is found, the `for` loop breaks and the last value of `i` is
    preserved in the current environment so that you know the solution that satisfies
    the condition.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到解决方案，`for` 循环就会中断，并将 `i` 的最后一个值保留在当前环境中，这样你就可以知道满足条件的解决方案。
- en: 'In some other cases, skipping an iteration in a `for` loop is also useful.
    We can use the `next` keyword to skip the rest expressions in the current iteration
    and directly jump to the next iteration of the loop:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些其他情况下，跳过 `for` 循环中的迭代也是有用的。我们可以使用 `next` 关键字跳过当前迭代中的其余表达式，并直接跳转到循环的下一个迭代：
- en: '[PRE79]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Creating nested for loops
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建嵌套的 `for` 循环
- en: 'The expression in a `for` loop can be anything, including another `for` loop.
    For example, if we want to exhaust all permutations of the elements in a vector,
    we can write a two-level nested `for` loop to solve the problem:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环中的表达式可以是任何东西，包括另一个 `for` 循环。例如，如果我们想穷尽向量中所有元素的排列组合，我们可以编写一个两层的嵌套 `for`
    循环来解决问题：'
- en: '[PRE80]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'If you only need permutations that contain distinct elements, you can add a
    test condition in the inner `for` loop:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需要包含不同元素的排列，你可以在内层 `for` 循环中添加一个测试条件：
- en: '[PRE81]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Alternatively, you can just negate the condition and replace the expression
    in the inner `for` loop with the following code to get exactly the same result:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以简单地否定条件，并将内层 `for` 循环中的表达式替换为以下代码以获得相同的结果：
- en: '[PRE82]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The preceding code demonstrates how nested loops work, but it is not optimal
    to solve the problem. Some built-in functions help generate combinations or permutations
    of vector elements. The `combn()` method produces a matrix of combinations of
    vector elements, given an atomic vector and the number of elements in each combination:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码演示了嵌套循环的工作原理，但用这种方法解决问题并不最优。一些内置函数可以帮助生成向量元素的组合或排列。`combn()` 方法根据原子向量和每个组合中的元素数量生成向量元素的组合矩阵：
- en: '[PRE83]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Similar to the preceding examples implemented using the `for` loop, `expand.grid()`
    produces a data frame containing all permutations of elements in multiple vectors:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用 `for` 循环实现的先前列举的例子类似，`expand.grid()` 生成一个包含多个向量中所有排列的数据框：
- en: '[PRE84]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Although the `for` loop can be powerful, there are functions designed for certain
    tasks. It is better to consider using built-in functions than directly putting
    everything in a `for` loop. In the following chapter, I will introduce `lapply()`
    and related functions to replace many `for` loops, which makes code easier to
    write and understand.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`for`循环可能很强大，但有一些函数是为特定任务设计的。最好考虑使用内置函数，而不是直接将所有内容放入 `for` 循环中。在下一章中，我将介绍
    `lapply()` 和相关函数来替换许多 `for` 循环，这使得代码更容易编写和理解。
- en: Using the while loop
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `while` 循环
- en: In contrast to the `for` loop, the `while` loop does not stop running until
    the given condition is violated.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `for` 循环相反，`while` 循环不会在给定条件违反之前停止运行。
- en: 'For example, the following `while` loop starts with `x = 0`. Each time, the
    loop checks whether `x <= 10` holds. If so, the inner expressions are evaluated;
    otherwise, the `while` loop terminates:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下 `while` 循环从 `x = 0` 开始。每次循环都会检查 `x <= 10` 是否成立。如果是，则评估内层表达式；否则，`while`
    循环终止：
- en: '[PRE85]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: If we remove `x <- x + 1` so that `x` no longer gains any increment, the code
    will run forever (until R is terminated by force). Therefore, the while loop can
    sometimes be dangerous if not properly implemented.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们移除 `x <- x + 1` 以使 `x` 不再增加任何增量，代码将无限运行（直到强制终止 R）。因此，如果实现不当，`while` 循环有时可能很危险。
- en: 'Like the `for` loop, flow control statements (`break` and `next`) are also
    applicable in `while`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `for` 循环一样，流程控制语句（`break` 和 `next`）也适用于 `while`：
- en: '[PRE86]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'In practice, the `while` loop is often used where the number of iterations
    is unknown. This usually happens when we fetch rows chunk-by-chunk from the result
    set of a database query. The code may look as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，`while` 循环通常用于迭代次数未知的情况。这通常发生在我们从数据库查询的结果集中分块获取行时。代码可能看起来如下所示：
- en: '[PRE87]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: First, we query all records whose type is 1 from a database through the con
    connection. Once the database returns a result set, `res`, we can fetch data from
    the result set chunk by chunk and process one chunk each time. Since the number
    of records is unknown prior to the query, we need to use a while loop that breaks
    when all data is completely fetched, which is indicated by `dbHasCompleted()`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过`con`连接从数据库中查询类型为1的所有记录。一旦数据库返回结果集`res`，我们就可以分块从结果集中获取数据，每次处理一个数据块。由于在查询之前不知道记录的数量，我们需要使用一个while循环，当所有数据完全获取时通过`dbHasCompleted()`来终止循环。
- en: In this way, we avoid fetching a (perhaps huge) data frame to memory. Instead,
    we work with small chunks. This allows us to process a large amount of data with
    only a small working set in memory. However, the major premise is that the algorithm
    `process()` must support processing data chunk by chunk.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做，我们避免了将（可能很大的）数据框加载到内存中。相反，我们处理小块数据。这使我们能够仅使用内存中的小工作集处理大量数据。然而，主要前提是算法`process()`必须支持分块处理数据。
- en: You may not be familiar with the preceding code example or the terminologies,
    but don't worry. We will cover database topics in detail in a later chapter.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不熟悉前面的代码示例或术语，但不用担心。我们将在后面的章节中详细讲解数据库主题。
- en: 'In addition to the `for` loop and the `while` loop, R also provides the `repeat`
    loop. Like `while (TRUE)`, the `repeat` keyword is also a real loop, because it
    does not require an explicit termination condition or boundary unless `break`
    is hit:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`for`循环和`while`循环之外，R还提供了`repeat`循环。像`while (TRUE)`一样，`repeat`关键字也是一个真正的循环，因为它不需要显式的终止条件或边界，除非遇到`break`：
- en: '[PRE88]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: However, the `repeat` keyword can be very dangerous and is not recommended in
    practice.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`repeat`关键字可能非常危险，并且在实践中并不推荐使用。
- en: Summary
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned the syntax of assignment, conditional expressions,
    and loops. In the section on assignment, you got to know the naming rules of variables
    and how to walk around. In the section on conditional expressions, you learned
    how to use the `if` statement as either a statement or an expression, and how `ifelse()`is
    distinct from `if` when dealing with vectors. In the section on loops, you learned
    about the similarities and differences between `for` loops and `while` loops.
    Now, we are equipped with the basic expressions to control the logic flow of an
    R program.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了赋值、条件表达式和循环的语法。在赋值部分，你了解了变量的命名规则以及如何避免命名冲突。在条件表达式部分，你学习了如何将`if`语句用作语句或表达式，以及`ifelse()`在处理向量时与`if`的区别。在循环部分，你学习了`for`循环和`while`循环的相似之处和不同之处。现在，我们已经拥有了控制R程序逻辑流程的基本表达式。
- en: In the next chapter, you will use what you learned in the previous chapters
    and see what you can do with the basic objects representing data and basic expressions
    representing our logic. You will learn about basic functions in various categories
    as the building blocks of data transformation and statistical analysis.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将使用前面章节中学到的知识，看看你可以用表示数据和表示我们逻辑的基本对象以及基本表达式做什么。你将学习各种类别中的基本函数，作为数据转换和统计分析的构建块。
