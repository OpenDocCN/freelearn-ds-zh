- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applying Quantum Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we considered the fundamentals that highlight the difference
    between classical and quantum systems, particularly the use of superposition and
    entanglement. In this chapter, we will focus on algorithms that have the potential
    to solve more applicable problems, such as periodicity and searching. These algorithms
    differ from the earlier algorithms as they are used in various domains and are
    included in many modern quantum algorithms. A few examples of these quantum algorithms
    are the **quantum amplitude estimation**, **variational quantum eigensolvers**,
    and **quantum support vector machine** algorithms. Having a good understanding
    of these algorithms will help you when learning about or creating your own algorithms
    as the techniques used can be applied in many industries. In this chapter, we
    will cover some of the fundamental principles and techniques that these more modern,
    and complex, algorithms leverage, to help you better understand them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Periodic algorithms** can be used to solve factorization or phase estimation
    problems. **Search algorithms** can also provide some speedup over classical algorithms
    in how they leverage amplitude amplification to find a specified entry.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding periodic quantum algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Quantum Fourier Transform algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Grover’s search algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After completing this chapter, you will be able to grasp the concepts of these
    algorithms and leverage the algorithms already provided in **Qiskit**, so you
    can use them without having to *reinvent the wheel*.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter assumes that you are familiar with some of the basic quantum algorithm
    components, such as superposition, oracles, phase kickback, and programming with
    Qiskit. You are also expected to understand basic linear algebra, such as multiplying
    matrices, the complex conjugation of a matrix, and inner products. Some advanced
    mathematics, such as an understanding of the **Fourier transform**, is also assumed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the source code used throughout this book: [https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition](https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding periodic quantum algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 11*, *Understanding Quantum Algorithms*, we covered algorithms that
    use phase kickback to solve various problems.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will start by understanding periodic quantum algorithms.
    Periodic functions are those where values are repeated over time. Your watch,
    for example, is periodic in that each minute has 60 seconds, each hour has 60
    minutes, and each day has 24 hours.
  prefs: []
  type: TYPE_NORMAL
- en: If you have your watch set up with the hours from 1 to 12, then your watch has
    2 periods per day, in that your watch will cycle through the numbers 1 to 12 twice
    in one day. Of course, this is separate from the AM and PM indicators, whether
    it is before or after midday. Periodic functions occur all around us in many ways,
    so understanding how to relate them to a quantum circuit is key to understanding
    many of the quantum algorithms, including one of the most famous, **Grover’s algorithm**.
  prefs: []
  type: TYPE_NORMAL
- en: But for now, we will begin by extending our understanding of periodic functions,
    particularly how we can understand and implement the **Quantum Fourier Transform**
    (**QFT**) algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the QFT algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: QFT is related to **Discrete Fourier Transform** (**DFT**) in that it too can
    transform from one domain to another.
  prefs: []
  type: TYPE_NORMAL
- en: '**DFT** converts a finite sequence of samples into a complex-valued function
    of frequency that is used to analyze many applications, such as image processing
    and signal processing, and can also be used to help solve partial differential
    equations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'DFT is used to transfer signals from the time domain to the frequency domain,
    or in a more generalized description, mapping one domain, *x*, to another domain,
    ![](img/B18420_12_001.png), with the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_12_002.png)'
  prefs: []
  type: TYPE_IMG
- en: Similarly, we can define a quantum transformation as a transformation from one
    basis to another. For example, all the computations we have done in this book
    so far have been measured according to the *Z* basis. This means our basis states
    have been set on the *Z*-axis of the qubit with the states ![](img/B18420_05_004.png)
    and ![](img/B18420_05_005.png), referring to the positive and negative ends of
    the *Z*-axis on the Bloch sphere, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: There are, of course, other basis states that we can transition to if needed.
    One example is the *X*-axis of the qubit, where the basis states there are ![](img/B18420_04_008.png)
    and ![](img/B18420_04_012.png), which refer to the positive and negative ends
    of the *X*-axis on the Bloch sphere, respectively. QFT would transform between
    these two basis states. The QFT is used by many quantum algorithms, including
    Shor’s, as it has been shown to have improvements over the classical implementation
    of a discrete Fourier transform.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will work through a simple example of a QFT algorithm to
    extend our understanding of it when we see it used in many other quantum algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll begin by applying QFT to a simple three-qubit quantum state.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the QFT algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before getting into the details, let’s first get an understanding of what each
    axis represents. As you recall from the Bloch sphere, one of the visual representations
    of a qubit, it is made up of three axes, *X*, *Y*, and *Z*. Rotations around the
    *X* and *Y* axes are what we use to adjust the amplitude of the qubit, that is,
    down along the longitude of the Bloch sphere (the North Pole to the South Pole).
    Rotation around the *Z*-axis is what we use to adjust the phase of the qubit,
    that is, around the latitude of the Bloch sphere.
  prefs: []
  type: TYPE_NORMAL
- en: Each axis is a basis state, named by the axis, i.e. *X*-basis, *Y*-basis, and
    *Z*-basis. In quantum, the *Z*-axis is generally referred to as the computational
    basis and either the *X-* and *Y*-axis can be the Fourier basis. In this example,
    we will set the *X*-basis as the Fourier basis. The QFT transform is generally
    a transformation from one basis to another, in this case, from the computational
    (*Z*) basis to the Fourier (*X*) basis.
  prefs: []
  type: TYPE_NORMAL
- en: 'To transform our quantum function from one basis state to another, we need
    to apply QFT, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_12_007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding equation, *Z – basis* refers to the basis states on the *Z*-axis,
    ![](img/B18420_05_004.png) and ![](img/B18420_05_005.png), and *X – basis* refers
    to the basis states (often referred to as the phase states because rotation around
    them refers to rotations around the *Z*-axis) on the *X*-axis, ![](img/B18420_09_050.png)
    and ![](img/B18420_09_052.png). The Qiskit documentation ([https://docs.quantum.ibm.com/](https://docs.quantum.ibm.com/))
    refers to the Fourier basis with a tilde (*~*), where *QFT* is the QFT Transform
    applied to the state ![](img/B18420_05_005.png), given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_12_013.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This can be equated, where the transformation is represented by the QFT between
    the amplitudes of *x*[j] and *y*[k], as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_12_014.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let’s see how we can implement QFT in a quantum circuit.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the QFT algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s begin by deriving our implementation based on an input state ![](img/B18420_12_015.png),.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative is to apply it sequentially to the following formula as we move
    from qubit to qubit. For this example, we will operate as follows; given a state
    ![](img/B18420_12_016.png), we will apply a Hadamard gate where we add the phase
    based on the state ![](img/B18420_12_015.png), where each value, j[i], is appended
    to the phase, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_12_018.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the following exercise, we will implement the QFT of ![](img/B18420_12_019.png),
    where ![](img/B18420_12_020.png). It’s important to note that the fractional parts
    of the exponents are binary, not decimal:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll begin by opening a new Jupyter notebook and import some common objects
    and run our helper file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we’ll create a quantum circuit where the width is equal to the length
    of our state value, `''110''`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have created our quantum circuit, let’s initialize the state, *s*,
    to ![](img/B18420_12_021.png). Since we write from the least significant position,
    we will reverse `s` accordingly as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code will initialize and render our circuit as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.5 – Initializing the state, s, to |110 ](img/B18420_12_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.1: Initializing the state, s, to ![](img/B18420_12_021.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have prepared our state, we can begin transforming it using QFT.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s review our transformation equation with our state ![](img/B18420_12_021.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_12_024.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This states that for each qubit where we apply a Hadamard gate, we will need
    to include rotations while traversing from the qubit down to the least significant
    qubit—hence, ![](img/B18420_12_025.png). As we traverse down, the qubit states
    decrease by each degree. This means each of the controlled phase rotations, **Control
    Rotation** (**CROT**), is based on the following matrix representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_12_026.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding equation, CROT(q)k is the CU[1] gate, and the parameter *q*
    is set as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_12_027.png)'
  prefs: []
  type: TYPE_IMG
- en: Therefore, we’ll start with the most significant qubit, *q*[2], from our state
    ![](img/B18420_05_035.png), as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting at the most significant qubit, we’ll add a Hadamard gate to the circuit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have our first step, the next step is to add CROT(![](img/B18420_06_162.png))
    gates starting at *k=2*, which is the index of the most significant qubit position,
    q[2], and our parameter ![](img/B18420_06_162.png) starts at the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18420_12_031.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We add the CROT gates from most significant to least significant, starting
    at ![](img/B18420_07_009.png), and doubling the denominator of the parameter as
    we move down each qubit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We then repeat this as we traverse from the current qubit down to the next
    qubit—in this case, *q*[0]:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As we are traversing down, the denominator on the parameter is doubling in
    size as well, such that the next parameter ![](img/B18420_06_162.png) is as follows
    (note that all qubits are initialized to the state ![](img/B18420_05_004.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_12_035.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This renders the following circuit, which now includes the Hadamard gate and
    the two CROT gates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_12_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.2: The first set of transformations starting from the most significant
    qubit'
  prefs: []
  type: TYPE_NORMAL
- en: 'That completes the first level, which dealt with the most significant qubit.
    We will now move down to the next qubit (the second most significant qubit) and
    repeat the process of adding a Hadamard gate, followed by CROT(q) gates, where
    the phase rotations get smaller as we traverse down each qubit. Let’s continue
    to the next qubit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is the same as *step 4* of adding a Hadamard gate; now, we apply the control
    rotation gate in the same manner as we did earlier and then draw the circuit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will complete the second transformation, which will render the following
    circuit, which starts with a Hadamard gate and then appends the CROT gates afterward:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B18420_12_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.3: The next transformation set starting at the next qubit down'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will run our transformation on the last qubit, and then draw the circuit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since this is the last qubit and the least significant qubit, it has no lower
    levels, so we complete the CROT phase of the QFT. This renders the following circuit
    so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a graph  Description automatically generated with medium
    confidence](img/B18420_12_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.4: The final transformation of our QFT circuit'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, once we have set all the rotations, we need to apply swap gates to
    reverse our results. We need to do this to complete the QFT and set the values
    in the proper order. The swap is performed from the outermost qubits moving inward
    until you reach the last two qubits in the middle (if the total number of qubits
    is even), or until you reach the last two pairs with a single qubit in the middle
    (if the total number of qubits is odd).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To simplify this, we can create a function that will swap the outer qubits
    and work its way toward the middle. In this case, since we only have three qubits,
    we will only swap the outer two qubits, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can run our quantum circuit through the `add_swap_gates` function and
    complete the circuit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will render our QFT circuit, which encodes our `''110''` value, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a graph  Description automatically generated with medium
    confidence](img/B18420_12_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.5: The QFT circuit that encodes ‘110’'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s include some helper functions, similar to the functions we created in
    the previous chapter, that will run on either simulators or quantum systems. This
    time, we will include an option to select the number of shots.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To visualize our QFT results, we can execute the preceding circuit using the
    state vector simulator to see our final QFT encoding for each qubit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code results in the following encoding for each qubit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.10 – A Bloch sphere representation of the ''110'' QFT encoded value
    ](img/B18420_12_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.6: A Bloch sphere representation of the ‘110’ QFT encoded value'
  prefs: []
  type: TYPE_NORMAL
- en: Note that q[0] (q[2] before the swap) has rotated ![](img/B18420_12_036.png)
    (which is a Hadamard (H) plus a ![](img/B18420_12_037.png) rotation), q[1] has
    rotated ![](img/B18420_12_038.png)(H), and *q*[2] (q[0] before the swap) has rotated
    0, mainly due to q[0] having a value of 0 before the swap because it was initialized
    to ![](img/B18420_07_007.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that each qubit is in a superposition state and varies by phase based
    on the `''110''` encoded value. We can also represent this using the `qsphere`
    object, which will have the same information, only represented in a single sphere
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following diagram, we can see that the information is encoded into the
    QSphere and has its encoded representation in the phase and state vector indicated
    by the color wheel and QSphere, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chart, radar chart  Description automatically generated](img/B18420_12_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.7: A QSphere representation of the QFT representation of the ‘110’
    state'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the colors indicate the phase of each state specified in the results
    where, at the time of this writing, green indicates ![](img/B18420_12_036.png)-degree
    phase rotation for rotation states ‘000’ and ‘100’.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have just completed encoding your first QFT! This is an
    algorithm that you will see in many other algorithms that depend on periodic functionality.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about the QFT algorithm and implemented it as well.
    One thing we have not covered, but which is important to mention, is that the
    QFT also has an inverse function called the **Inverse Quantum Fourier Transform**
    (**IQFT**). This is quite simply the reverse of the QFT and in essence transforms
    the quantum state from the quantum Fourier basis back to the computational basis.
    This is done, as described, by reversing the functionality which was performed
    when transforming the QFT which includes reverse rotations. That is to say, if
    we rotated a qubit ![](img/B18420_12_041.png), then when performing an IQFT, we
    would rotate the qubit by the same angle, only this time in the opposite direction,
    i.e. ![](img/B18420_12_042.png).
  prefs: []
  type: TYPE_NORMAL
- en: With an understanding of the basis of state transformation, you are now able
    to leverage this in many periodic functions and algorithms, such as estimating
    eigenvalues or unitary matrices and factoring discrete logarithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will look at one of the more famous search algorithms: **Grover’s
    algorithm**.'
  prefs: []
  type: TYPE_NORMAL
- en: Learning about Grover’s search algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Search algorithms are unique in that they can be leveraged by various algorithms
    to find information, whether in a data repository or a list of values, such as
    features in an image. The advantage with quantum, of course, is in the potential
    for speeding up the search. **Grover’s algorithm** is one such example. It uses
    a well-known technique that allows the use of interference to amplify certain
    states in our quantum circuit in a way that will increase the amplitude of the
    value we are searching for and decrease those that we are not. Let’s start, as
    always, by describing the problem, where each state is analogous to an entry in
    an unordered list.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The problem here is also very simple: we are given a set of states where all
    states are set to 0, except one state which is set to 1\. We wish to identify
    which one of those states is set to 1.'
  prefs: []
  type: TYPE_NORMAL
- en: Classically, this can be done in, in the best case, 1 step, if the first value
    is set. In the worst case, it would take *N* steps, where *N* is the total number
    of states and the last state is set. This means that on average, it will take
    *N/2* steps to find the value as we would need to check each value individually.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, this is not ideal if our set is a very large list. We need to find
    a better way to find our value. This is where, in 1996, Lov Grover came in and
    discovered a way to solve this problem with his now-famous quantum algorithm.
    We’ll step through the implementation of Grover’s algorithm as we try to search
    for a value in a three-qubit circuit.
  prefs: []
  type: TYPE_NORMAL
- en: 'To describe this problem using functions, we can state the following, given
    a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_12_043.png)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding equation, ![](img/B18420_12_044.png) for all cases of *x*
    except for a specific case, *x**, such that ![](img/B18420_12_045.png). Find the
    value of *x**. Since we will be working with qubits, let’s select a value *N*,
    such that *N* = 2^n.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have defined our problem, let’s step through Grover’s search algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Grover’s search algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Grover’s algorithm is similar to the Deutsch-Jozsa and Bernstein-Vazirani algorithms
    in that it too leverages an oracle. However, note that the example given here
    illustrates a very simple oracle where we know the tagged state beforehand. This
    is done for demonstration purposes here; however, in real-world applications,
    the oracle will not only be more complex, but we will also have no idea which
    state will be tagged.
  prefs: []
  type: TYPE_NORMAL
- en: Another similarity between Deutsch-Josza and Grover’s algorithm is that Grover’s
    also leverages interference in a way that it will increase the amplitude of the
    state we are searching for while decreasing all other states, which in turn increases
    the speed by ![](img/B18420_12_046.png), where *N* is the number of states to
    search. This means that rather than iterating through each value within N, we
    take an exponential speedup, similar to what we did with Deutsch-Josza.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll begin by explaining Grover’s search process in order to obtain an understanding
    of how it works. For a deeper description of the mathematics behind this, I recommend
    the book *Dancing with Qubits* by Robert S. Sutor, which covers this in greater
    detail.
  prefs: []
  type: TYPE_NORMAL
- en: Grover’s search algorithm can be broken down into two main components—perhaps
    three, if you count initializing all qubits into superposition and adding measurements
    at the end—but that is something that most quantum algorithms do, so we’ll just
    stick to the two main points. The first is referred to as **Grover’s oracle**,
    and the second is the **Grover diffusion operator**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will describe a two-qubit system that, when placed in superposition
    by applying a Hadamard gate to each qubit, provides four possible states—**00**,
    **01**, **10**, and **11**—as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph with numbers and lines  Description automatically generated with
    medium confidence](img/B18420_12_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.8: Two qubits in a superposition state'
  prefs: []
  type: TYPE_NORMAL
- en: When in this state, the average equals the probability amplitude, which in this
    case is **0.25**, as indicated by the dotted line across the top of each state.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we’ll say the state that we wish to search for is the state
    `'10'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first component is the **oracle**, *U*[f]. This is where we generally tag
    the value we are searching for. By tagging, I mean we will signal that the state
    that we are searching for will be identified by simply changing the sign of the
    state from positive to negative. The transition would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph with blue squares  Description automatically generated](img/B18420_12_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.9: Changing the sign of the state to negative'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have changed the sign, we can’t, unfortunately, just measure and
    go at this point—mainly because, as we know, the probability amplitudes are squared,
    so our results would all still be equal, which does not provide us with any new
    information about what we are searching for. However, since we are working with
    amplitudes, we can leverage interference here by increasing the amplitude of the
    state we tagged and decreasing the amplitude of the other states. *How do we do
    this?* By incorporating the second component of Grover’s search, the **diffusion
    operator**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second component of Grover’s algorithm is the **Grover diffusion operator**.
    Here, we will be performing a mathematical step known as *inversion about the
    mean*. What this does is invert the distance between the average and the peak
    of each state. This is analogous to having each state flip reflectively about
    the average mean. Visually, the transition will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph with blue squares and numbers  Description automatically generated](img/B18420_12_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.10: Inversion about the mean amplifies the states constructively
    and destructively'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from the results of performing the inversion about the mean, the
    amplification of the tagged state is now significantly higher than the other states.
    If we were to now take a measurement, we would see that the result with the higher
    probability is the state we are searching for. Keep in mind, of course, that this
    is all done with a single query to our quantum circuit!
  prefs: []
  type: TYPE_NORMAL
- en: One thing to note is that when the number of states, *N*, is large, this means
    we will need to repeat the diffusion operator steps (and not the oracle constructor
    steps) multiple times, which is what constructs and destructs the amplitudes.
    The number of times to optimize the results is ![](img/B18420_12_047.png), where
    *n* is the number of qubits.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement Grover’s search algorithm next.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Grover’s search algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As usual, we’ll explain each step described in the previous section while we
    work through the algorithm step by step. To start, create a new Qiskit notebook
    for this example and work through the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll begin by declaring the value we want to set. Let’s set the value to `110`.
    This way, we can use a three-qubit circuit to implement Grover’s algorithm and
    place all the qubits in superposition by adding a Hadamard gate to each qubit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will render our initialized circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.15 – Initialized quantum circuit in superposition ](img/B18420_12_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.11: Initialized quantum circuit in superposition'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we want to encode the state that we want to search—in this case, it is
    the state ![](img/B18420_12_048.png). Here, we will reverse the state and encode
    `N` in the circuit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For each step, we will add a barrier so that we can see the process rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.16 – Encoding our state ''110'', we mark the ''0'' qubits in the
    state with an X gate ](img/B18420_12_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.12: Encoding our state ‘110’, we mark the ‘0’ qubits in the state
    with an X gate'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will create Grover’s oracle. What we will do here is first set the
    most significant qubit in a superposition state, followed by a CNOT gate where
    the target is the most significant qubit, and the source is all the other qubits.
    Then, place another Hadamard gate on the most significant qubit to complete the
    oracle. This will negate the state that we set in the previous source cell, ![](img/B18420_12_021.png):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code renders the following circuit, which we see sets the two
    CNOT gates in our oracle surrounded by **H** gates on the most significant qubit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.17 – Applying Grover''s oracle to the circuit ](img/B18420_12_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.13: Applying Grover’s oracle to the circuit'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we want to reset the state that we are searching in the circuit so that
    it returns to the superposition value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code completes Grover’s oracle, which we described earlier as
    the first component of Grover’s search algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.18 – The first component of Grover''s search algorithm ](img/B18420_12_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.14: The first component of Grover’s search algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will implement the second component, the Grover diffusion operator.
    We start by applying all the qubits in a superposition state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This renders the following superposition state, followed by Grover’s oracle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chart, box and whisker chart  Description automatically generated](img/B18420_12_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.15: The first step in the Grover diffusion operator: apply H gates
    to all qubits'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will flip all the 0-state qubits to their negative phase. Here, the
    most significant qubit is set as the target of the two CNOT gates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This renders the next step in the diffusion operator—that is, inversion about
    the mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.20 – The second step of the diffusion operator to invert about
    the mean ](img/B18420_12_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.16: The second step of the diffusion operator: to invert about the
    mean'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we wrap up the Grover diffusion operator by applying the first step
    in reverse. Since we applied a set of H gates across all qubits, followed by a
    set of X gates, also across all qubits, we will reverse this in the following
    manner. Apply X gates across all qubits, then apply H gates across all qubits:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code completes the Grover diffusion operator component of the
    quantum circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.21 – The complete Grover''s algorithm circuit ](img/B18420_12_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.17: The complete Grover’s algorithm circuit'
  prefs: []
  type: TYPE_NORMAL
- en: To determine the ideal number of times to repeat the diffusion operator, `n`,
    we simply need to compute n as follows,
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_12_050.png)'
  prefs: []
  type: TYPE_IMG
- en: where N is the number of (log N) qubits N=4 for two qubits; In this example,
    we should add a second diffusion operator to bring the error down from 3% to 1%.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we’ll just add measurement operators and prepare to run the circuit on
    the backend, but first on a local simulator on your device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code will prepare the following quantum circuit to run on either
    a simulator or quantum computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.22 – The complete quantum circuit ready to run on a simulator or
    quantum system ](img/B18420_12_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.18: The complete quantum circuit ready to run on a simulator or quantum
    system'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start by running the function we created to execute our circuit using
    the Sampler primitive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After executing the circuit, this will print and plot our results as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following figure, we can see that the state we are searching has the
    higher probability, a quasi-probability of 0.559%, whereas all the other states
    have a significantly lower probability of around 0.05%:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.23 – Results of executing Grover''s search of state 110 on a quantum
    simulator ](img/B18420_12_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.19: Results of executing Grover’s search of state 110 on a Sampler'
  prefs: []
  type: TYPE_NORMAL
- en: Success! As expected, our Grover’s algorithm implementation has found the state
    within a single query.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s try it on a quantum device. We’ll select the quantum computer that
    is the least busy and operational and has the number of qubits necessary to run
    our quantum circuit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code will print out the least busy quantum computer and assign
    it to the `backend` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now execute this as we did previously with the simulator, then print
    and plot the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once completed, you should see something similar to the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now plot the quasi distribution of the results on a graph using the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will display the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph with numbers and a bar  Description automatically generated](img/B18420_12_20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.20: Probability distribution'
  prefs: []
  type: TYPE_NORMAL
- en: This, of course, depends on the device itself as each system is different from
    one another. However, the results should be clear that the state with the highest
    probability is the state that we are searching for—in this case, ![](img/B18420_12_021.png).
  prefs: []
  type: TYPE_NORMAL
- en: As we can see here, the result with the highest probability is the state we
    are searching for, and the other states have a lower probability. We can see enough
    of a difference between each state to observe that the Grover’s search algorithm
    that we implemented does indeed identify the state we are searching for. You might
    also want to try this with a larger value N, just so you can observe the results.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have successfully implemented a variety of quantum algorithms,
    which are foundational to understanding how quantum computers are different in
    how they solve problems compared to classical systems and how they have the potential
    to solve real-world problems.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many algorithms that implement many of the techniques we covered in
    this and the previous chapter on quantum algorithms, many of which you will see
    used in other algorithms, such as the **quantum amplitude estimation** and **variational
    quantum eigensolver** algorithms, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: I do strongly suggest trying variations of these algorithms yourself to get
    a better feel and understanding of how they work.
  prefs: []
  type: TYPE_NORMAL
- en: In the next and final chapter, we will look at the features that are built into
    Qiskit, which allow you as a researcher or developer to leverage them to create
    your own quantum algorithms. You will gain the skills to integrate these algorithms
    into your existing research or applications without having to worry about developing
    circuits, mitigating against noise, or any of the other components that make up
    an algorithm in Qiskit. This book has already done the heavy lifting for you,
    so you can simply implement the algorithm and process the results as you see fit.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What other problems can you solve using periodic functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement QFT on a five-qubit state—for example, `'10110'`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using Grover’s algorithm, find the following states: `''101''`, `''001''`,
    and `''010''`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many iterations of Grover’s diffusion operator would you need to run to
    find the state ![](img/B18420_12_052.png)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rerun the Grover’s search example. Only repeat Grover’s diffusion operator twice
    and note the difference in the result. What do you see that is different? What
    would you expect to change if you ran it more than three times?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Join us on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/3FyN1](Chapter_12.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code2617625996838265933.png)'
  prefs: []
  type: TYPE_IMG
