- en: gpx_dict = xmltodict.parse(gpx_file.read())
  prefs: []
  type: TYPE_NORMAL
- en: print("Waypoint:")
  prefs: []
  type: TYPE_NORMAL
- en: print(gpx_dict['gpx']['wpt'][0].keys())
  prefs: []
  type: TYPE_NORMAL
- en: print("Geocache:")
  prefs: []
  type: TYPE_NORMAL
- en: print(gpx_dict['gpx']['wpt'][0]['geocache'].keys())
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Now, edit the if __name__ == ''__main__'': block to test the code: if __name__
    == "__main__":'
  prefs: []
  type: TYPE_NORMAL
- en: gdal.PushErrorHandler('CPLQuietErrorHandler')
  prefs: []
  type: TYPE_NORMAL
- en: read_gpx_file("../../data/geocaching.gpx")
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Run the code again with *Shift* + *F10* and look at the results: Waypoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[u''@lat'', u''@lon'', u''time'', u''name'', u''desc'', u''src'', u''url'',
    u''urlname'', u''sym'', u''type'', u''geocache'']'
  prefs: []
  type: TYPE_NORMAL
- en: 'Geocache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[u''@status'', u''@xmlns'', u''name'', u''owner'', u''locale'', u''state'',
    u''country'', u''type'', u''container'', u''difficulty'', u''terrain'', u''summary'',
    u''description'', u''hints'', u''licence'', u''logs'', u''geokrety'']'
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: With the print(gpx_dict['gpx']['wpt'][0].keys())statement, we obtained the value
    of gpx and then that of wpt, which is a list. Then, we got the keys of the first
    element on this list and printed it.
  prefs: []
  type: TYPE_NORMAL
- en: Next, through print(gpx_dict['gpx']['wpt'][0]['geocache'].keys()), we got the
    value of geocache and also printed its keys.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the output and note that it’s the same thing that we did when we were
    exploring the GPX file structure in PyCharm. The structure is now available as
    a dictionary, including the tag’s properties, which are represented in the dictionary
    with an @ symbol.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a nice and easy way to handle the dictionary of the GPX file,
    let’s extract and flatten the relevant information and make the function return
    it. Edit the read_gpx_file function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def read_gpx_file(file_path):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Reads a GPX file containing geocaching points.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param str file_path: The full path to the file.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: 'with open(file_path) as gpx_file:'
  prefs: []
  type: TYPE_NORMAL
- en: gpx_dict = xmltodict.parse(gpx_file.read())
  prefs: []
  type: TYPE_NORMAL
- en: output = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for wpt in gpx_dict[''gpx''][''wpt'']:'
  prefs: []
  type: TYPE_NORMAL
- en: geometry = [wpt.pop('@lat'), wpt.pop('@lon')]
  prefs: []
  type: TYPE_NORMAL
- en: If geocache is not on the dict, skip this wpt.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: geocache = wpt.pop('geocache')
  prefs: []
  type: TYPE_NORMAL
- en: 'except KeyError:'
  prefs: []
  type: TYPE_NORMAL
- en: continue
  prefs: []
  type: TYPE_NORMAL
- en: 'attributes = {''status'': geocache.pop(''@status'')}'
  prefs: []
  type: TYPE_NORMAL
- en: Merge the dictionaries.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: attributes.update(wpt)
  prefs: []
  type: TYPE_NORMAL
- en: attributes.update(geocache)
  prefs: []
  type: TYPE_NORMAL
- en: Construct a GeoJSON feature and append to the list.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: feature = {
  prefs: []
  type: TYPE_NORMAL
- en: '"type": "Feature",'
  prefs: []
  type: TYPE_NORMAL
- en: '"geometry": {'
  prefs: []
  type: TYPE_NORMAL
- en: '"type": "Point",'
  prefs: []
  type: TYPE_NORMAL
- en: '"coordinates": geometry},'
  prefs: []
  type: TYPE_NORMAL
- en: '"properties": attributes}'
  prefs: []
  type: TYPE_NORMAL
- en: output.append(feature)
  prefs: []
  type: TYPE_NORMAL
- en: return output
  prefs: []
  type: TYPE_NORMAL
- en: Note that here, we used the dictionary’s pop method; this method returns the
    value of a given key and removes the key from the dictionary. The objective is
    to have two dictionaries only with attributes (properties) that can be merged
    into a single dictionary of attributes; the merging is done with the update method.
  prefs: []
  type: TYPE_NORMAL
- en: Some waypoints doesn’t have the geocache key, when this happens, we catch the
    exception and skip this point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the information is combined in a dictionary with a GeoJSON-like structure.
    You can do this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Edit the if __name__ == ''__main__'': block using the following code: if
    __name__ == "__main__":'
  prefs: []
  type: TYPE_NORMAL
- en: gdal.PushErrorHandler('CPLQuietErrorHandler')
  prefs: []
  type: TYPE_NORMAL
- en: points = read_gpx_file("../../data/geocaching.gpx") print points[0]['properties'].keys()
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Run the code, and you will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[''status'', u''logs'', u''locale'', u''terrain'', u''sym'', u''geokrety'',
    u''difficulty'', u''licence'', u''owner'', u''urlname'', u''desc'', u''@xmlns'',
    u''src'', u''container'', u''name'', u''url'', u''country'', u''description'',
    u''summary'', u''state'', u''time'', u''hints'', u''type'']'
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: That’s great! Now, all the geocache attributes are contained inside the *properties*
    of the feature.
  prefs: []
  type: TYPE_NORMAL
- en: '**Returning the homogeneous data**'
  prefs: []
  type: TYPE_NORMAL
- en: We have a read_gpx_file function that returns a list of features in a dictionary
    and an open_vector_file function that returns an OGR datasource. We also have
    a get_datasource_information function that returns the information that we need
    about the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it’s time to combine these functions in order to be able to read multiple
    types of data (GPX, Shapefiles, and many more). To do this, we will change the
    open_vector_file function so that it can make decisions depending on the file
    format and convert the data in order to always return the same structure. Perform
    the following steps: 1\. First, make sure that the functions inside geo_function.py
    are in the correct order; if not, rearrange them to be in this order:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def read_gpx_file(file_path):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def get_datasource_information(datasource, print_results=False): def open_vector_file(file_path):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def create_transform(src_epsg, dst_epsg):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def transform_geometries(datasource, src_epsg, dst_epsg):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def transform_points(points, src_epsg=4326, dst_epsg=3395): 2\. Now, add a
    new function to transform OGR features into dictionaries as we did with the GPX
    file. This function can be inserted anywhere before open_vector_file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def read_ogr_features(layer):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Convert OGR features from a layer into dictionaries.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param layer: OGR layer.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: features = []
  prefs: []
  type: TYPE_NORMAL
- en: layer_defn = layer.GetLayerDefn()
  prefs: []
  type: TYPE_NORMAL
- en: layer.ResetReading()
  prefs: []
  type: TYPE_NORMAL
- en: type = ogr.GeometryTypeToName(layer.GetGeomType())
  prefs: []
  type: TYPE_NORMAL
- en: 'for item in layer:'
  prefs: []
  type: TYPE_NORMAL
- en: attributes = {}
  prefs: []
  type: TYPE_NORMAL
- en: 'for index in range(layer_defn.GetFieldCount()):'
  prefs: []
  type: TYPE_NORMAL
- en: field_defn = layer_defn.GetFieldDefn(index)
  prefs: []
  type: TYPE_NORMAL
- en: key = field_defn.GetName()
  prefs: []
  type: TYPE_NORMAL
- en: value = item.GetFieldAsString(index)
  prefs: []
  type: TYPE_NORMAL
- en: attributes[key] = value
  prefs: []
  type: TYPE_NORMAL
- en: feature = {
  prefs: []
  type: TYPE_NORMAL
- en: '"type": "Feature",'
  prefs: []
  type: TYPE_NORMAL
- en: '"geometry": {'
  prefs: []
  type: TYPE_NORMAL
- en: '"type": type,'
  prefs: []
  type: TYPE_NORMAL
- en: '"coordinates": item.GetGeometryRef().ExportToWkt()},'
  prefs: []
  type: TYPE_NORMAL
- en: '"properties": attributes}'
  prefs: []
  type: TYPE_NORMAL
- en: features.append(feature)
  prefs: []
  type: TYPE_NORMAL
- en: return features
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Now, edit the open_vector_file function via the following code: def open_vector_file(file_path):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Opens an vector file compatible with OGR or a GPX file.'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a list of features and informations about the file.
  prefs: []
  type: TYPE_NORMAL
- en: ':param str file_path: The full path to the file.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: datasource = ogr.Open(file_path)
  prefs: []
  type: TYPE_NORMAL
- en: Check if the file was opened.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if not datasource:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if not os.path.isfile(file_path):'
  prefs: []
  type: TYPE_NORMAL
- en: message = "Wrong path."
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: message = "File format is invalid."
  prefs: []
  type: TYPE_NORMAL
- en: raise IOError('Error opening the file {}\n{}'.format(
  prefs: []
  type: TYPE_NORMAL
- en: file_path, message))
  prefs: []
  type: TYPE_NORMAL
- en: metadata = get_datasource_information(datasource)
  prefs: []
  type: TYPE_NORMAL
- en: file_name, file_extension = os.path.splitext(file_path)
  prefs: []
  type: TYPE_NORMAL
- en: Check if it's a GPX and read it if so.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if file_extension in [''.gpx'', ''.GPX'']:'
  prefs: []
  type: TYPE_NORMAL
- en: features = read_gpx_file(file_path)
  prefs: []
  type: TYPE_NORMAL
- en: If not, use OGR to get the features.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: features = read_ogr_features(
  prefs: []
  type: TYPE_NORMAL
- en: datasource.GetLayerByIndex(0))
  prefs: []
  type: TYPE_NORMAL
- en: return features, metadata
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Just to make sure that everything is fine, let’s test the code by opening
    two different file types. Edit the if __name__ == ''__main__'': block, as follows:
    if __name__ == "__main__":'
  prefs: []
  type: TYPE_NORMAL
- en: gdal.PushErrorHandler('CPLQuietErrorHandler')
  prefs: []
  type: TYPE_NORMAL
- en: points, metadata = open_vector_file(
  prefs: []
  type: TYPE_NORMAL
- en: '"../../data/geocaching.shp")'
  prefs: []
  type: TYPE_NORMAL
- en: print points[0]['properties'].keys()
  prefs: []
  type: TYPE_NORMAL
- en: points, metadata = open_vector_file(
  prefs: []
  type: TYPE_NORMAL
- en: '"../../data/geocaching.gpx")'
  prefs: []
  type: TYPE_NORMAL
- en: print points[0]['properties'].keys()
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Run the code and take a look at the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[''src'', ''dgpsid'', ''vdop'', ''sat'', ''name'', ''hdop'', ''url'', ''fix'',
    ''pdop'','
  prefs: []
  type: TYPE_NORMAL
- en: '''sym'', ''ele'', ''ageofdgpsd'', ''time'', ''urlname'', ''magvar'', ''cmt'',
    ''type'','
  prefs: []
  type: TYPE_NORMAL
- en: '''geoidheigh'', ''desc'']'
  prefs: []
  type: TYPE_NORMAL
- en: '[''status'', u''logs'', u''locale'', u''terrain'', u''sym'', u''geokrety'',
    u''difficulty'', u''licence'', u''owner'', u''urlname'', u''desc'', u''@xmlns'',
    u''src'', u''container'', u''name'', u''url'', u''country'', u''description'',
    u''summary'', u''state'', u''time'', u''hints'', u''type'']'
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: '**Converting the data into Geocache objects** So far, we have defined the Geocache
    class; it has the latitude and longitude properties and a method to return this
    pair of coordinates. PointCollection is a collection of geocaches.'
  prefs: []
  type: TYPE_NORMAL
- en: We also have the open_vector_file function that returns a list of dictionaries
    representing features.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will reach a higher level of abstraction by implementing the process
    of importing data into the PointCollection class by making use of the open_vector_file
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Open your models.py file and edit the imports at the beginning of the file
    by executing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Import gdal
  prefs: []
  type: TYPE_NORMAL
- en: import os
  prefs: []
  type: TYPE_NORMAL
- en: from pprint import pprint
  prefs: []
  type: TYPE_NORMAL
- en: from utils.geo_functions import open_vector_file
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Now, let’s make PointCollection automatically import a file when it’s instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the models.py file, change your class __init__ method, and add the import_data
    and _parse_data methods. Run this script:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class PointCollection(object):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, file_path=None):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""This class represents a group of vector data."""'
  prefs: []
  type: TYPE_NORMAL
- en: self.data = []
  prefs: []
  type: TYPE_NORMAL
- en: self.epsg = None
  prefs: []
  type: TYPE_NORMAL
- en: 'if file_path:'
  prefs: []
  type: TYPE_NORMAL
- en: self.import_data(file_path)
  prefs: []
  type: TYPE_NORMAL
- en: 'def import_data(self, file_path):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Opens an vector file compatible with OGR and parses the data.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param str file_path: The full path to the file.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: features, metadata = open_vector_file(file_path)
  prefs: []
  type: TYPE_NORMAL
- en: self._parse_data(features)
  prefs: []
  type: TYPE_NORMAL
- en: self.epsg = metadata['epsg']
  prefs: []
  type: TYPE_NORMAL
- en: 'print("File imported: {}".format(file_path))'
  prefs: []
  type: TYPE_NORMAL
- en: 'def _parse_data(self, features):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Transforms the data into Geocache objects.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param features: A list of features.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: 'for feature in features:'
  prefs: []
  type: TYPE_NORMAL
- en: geom = feature['geometry']['coordinates']
  prefs: []
  type: TYPE_NORMAL
- en: attributes = feature['properties']
  prefs: []
  type: TYPE_NORMAL
- en: cache_point = Geocache(geom[0], geom[1],
  prefs: []
  type: TYPE_NORMAL
- en: attributes = attributes) self.data.append(cache_point)
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Now, we will just need to adapt the Geocache class to receive and store
    the attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace it with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class Geocache(object):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""This class represents a single geocaching point."""'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, lat, lon, attributes=None):'
  prefs: []
  type: TYPE_NORMAL
- en: self.lat = lat
  prefs: []
  type: TYPE_NORMAL
- en: self.lon = lon
  prefs: []
  type: TYPE_NORMAL
- en: self.attributes = attributes
  prefs: []
  type: TYPE_NORMAL
- en: '@property'
  prefs: []
  type: TYPE_NORMAL
- en: 'def coordinates(self):'
  prefs: []
  type: TYPE_NORMAL
- en: return self.lat, self.lon
  prefs: []
  type: TYPE_NORMAL
- en: The attribute arguments are called **keyword arguments**. Keyword arguments
    are optional, and the default value is the value defined after the equal symbol.
  prefs: []
  type: TYPE_NORMAL
- en: As at this moment there is no standardization in data format for geocaching,
    we will store all the attributes that are read from the source file unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, you are not obliged to define which properties a class instance will
    have in advance; the properties can be added during the code’s execution. However,
    it’s good practice to define them in the __init __ method because it avoids mistakes,
    such as trying to access undefined properties. PyCharm can track these properties
    and warn you about typos. It also serves as documentation.
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Before we test the code, edit the PointCollection class and add a method
    that shows some information for us, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '#...'
  prefs: []
  type: TYPE_NORMAL
- en: 'def describe(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'print("SRS EPSG code: {}".format(self.epsg))'
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Number of features: {}".format(len(self.data))) 2\. In order to test
    your code, edit the if __name__ == ''__main__'' block via the following lines
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: gdal.PushErrorHandler('CPLQuietErrorHandler')
  prefs: []
  type: TYPE_NORMAL
- en: '**vector_data = PointCollection("../data/geocaching.gpx")** vector_data.print_information()'
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Now, run the code. You should see the following output: File imported:
    ../data/geocaching.gpx'
  prefs: []
  type: TYPE_NORMAL
- en: 'SRS EPSG code: 4326'
  prefs: []
  type: TYPE_NORMAL
- en: 'Number of features: 112'
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: '**Merging multiple sources of data**'
  prefs: []
  type: TYPE_NORMAL
- en: Now that our data is in the form of PointCollection containing Geocache objects,
    merging data from multiple files or multiple PointCollection data should be easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Make another test. First, we will see whether we can import multiple files
    and edit the if __name__ == ''__main__'' block of the models.py file. Execute
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: gdal.PushErrorHandler('CPLQuietErrorHandler')
  prefs: []
  type: TYPE_NORMAL
- en: vector_data = PointCollection("../data/geocaching.gpx") vector_data.describe()
  prefs: []
  type: TYPE_NORMAL
- en: vector_data.import_data("../data/geocaching.shp") vector_data.describe()
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Run the code again. Now, you should see the number of features double after
    you import another file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'File imported: ../data/geocaching.gpx'
  prefs: []
  type: TYPE_NORMAL
- en: 'SRS EPSG code: 4326'
  prefs: []
  type: TYPE_NORMAL
- en: 'Number of features: 112'
  prefs: []
  type: TYPE_NORMAL
- en: 'File imported: ../data/geocaching.shp'
  prefs: []
  type: TYPE_NORMAL
- en: 'SRS EPSG code: None'
  prefs: []
  type: TYPE_NORMAL
- en: 'Number of features: 242'
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Let’s implement something very elegant. We will add a magic method to our
    PointCollection class so that we can merge the content of two instances.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Edit the PointCollection class and add the __add__ method just after the
    __init__
  prefs: []
  type: TYPE_NORMAL
- en: 'method via the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class PointCollection(object):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, file_path=None):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""This class represents a group of vector data."""'
  prefs: []
  type: TYPE_NORMAL
- en: self.data = []
  prefs: []
  type: TYPE_NORMAL
- en: self.epsg = None
  prefs: []
  type: TYPE_NORMAL
- en: 'if file_path:'
  prefs: []
  type: TYPE_NORMAL
- en: self.import_data(file_path)
  prefs: []
  type: TYPE_NORMAL
- en: 'def __add__(self, other):'
  prefs: []
  type: TYPE_NORMAL
- en: self.data += other.data
  prefs: []
  type: TYPE_NORMAL
- en: return self
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the __init__ method, the __add__ method is one of Python’s *magic
    methods*.
  prefs: []
  type: TYPE_NORMAL
- en: 'These methods are not called directly; they are automatically called when something
    specific happens. The __init__ method is called when the class is instantiated,
    and the __add__ method is called when the plus (+) operator is used. So, to merge
    the data of two PointCollection instances, we just need to sum them. Here’s what
    we need to do for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Edit the if __name__ == ''__main__'': block, as follows: if __name__ ==
    ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: gdal.PushErrorHandler('CPLQuietErrorHandler')
  prefs: []
  type: TYPE_NORMAL
- en: my_data = PointCollection("../data/geocaching.gpx") my_other_data = PointCollection("../data/geocaching.shp")
    merged_data = my_data + my_other_data
  prefs: []
  type: TYPE_NORMAL
- en: merged_data.describe()
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Then, run the code and take a look at the results:'
  prefs: []
  type: TYPE_NORMAL
- en: 'File imported: ../data/geocaching.gpx'
  prefs: []
  type: TYPE_NORMAL
- en: 'File imported: ../data/geocaching.shp'
  prefs: []
  type: TYPE_NORMAL
- en: 'SRS EPSG code: 4326'
  prefs: []
  type: TYPE_NORMAL
- en: 'Number of features: 242'
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: '**Integrating new functionality into the**'
  prefs: []
  type: TYPE_NORMAL
- en: '**application**'
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 2,](index_split_000.html#p103) *The Geocaching App*, we developed
    the application so that it could find points close to your location. However,
    the data was organized differently inside the application; although it was a very
    efficient way of handling data, it became very hard for us to understand how to
    perform operations on this data.
  prefs: []
  type: TYPE_NORMAL
- en: Through abstraction, we implemented a new form of data representation—one that
    is very intuitive and easy to use.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will change the application so that it can use this new type of data
    to perform its functions and also to aggregate the new capability of combining
    multiple sources of data.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the GeocachingApp and PointCollection classes; you may notice
    that they have some parts that look similar to each other. Both of them store
    data and have methods to open data.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, with little modification, if we transfer methods from one class
    to another, we could end up with a functional application, and that’s what we
    will do. However, instead of copying and pasting, we will use Python’s class inheritance.
    We will take the GeocachingApp class and make it inherit all the functionality
    of the PointCollection class.
  prefs: []
  type: TYPE_NORMAL
- en: For a complete understanding, we will go through the processes one method at
    a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your geocaching_app.py file, and now, let’s focus on the class declarations
    and __init__ method. Make the following changes on the imports section, and in
    the class, you can keep the other methods as they are; don’t delete them:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from pprint import pprint
  prefs: []
  type: TYPE_NORMAL
- en: import gdal
  prefs: []
  type: TYPE_NORMAL
- en: import numpy as np
  prefs: []
  type: TYPE_NORMAL
- en: import math
  prefs: []
  type: TYPE_NORMAL
- en: from utils.geo_functions import transform_geometries
  prefs: []
  type: TYPE_NORMAL
- en: from utils.geo_functions import transform_points
  prefs: []
  type: TYPE_NORMAL
- en: from models import Geocache, PointCollection
  prefs: []
  type: TYPE_NORMAL
- en: 'class GeocachingApp(PointCollection):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, data_file=None, my_location=None):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Application class.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param data_file: An OGR compatible file'
  prefs: []
  type: TYPE_NORMAL
- en: with geocaching points.
  prefs: []
  type: TYPE_NORMAL
- en: ':param my_location: Coordinates of your location.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: super(GeocachingApp, self).__init__(file_path=data_file)
  prefs: []
  type: TYPE_NORMAL
- en: self._datasource = None
  prefs: []
  type: TYPE_NORMAL
- en: self._transformed_geoms = None
  prefs: []
  type: TYPE_NORMAL
- en: self._my_location = None
  prefs: []
  type: TYPE_NORMAL
- en: self.distances = None
  prefs: []
  type: TYPE_NORMAL
- en: '#Delete the code containing "if data_file…"'
  prefs: []
  type: TYPE_NORMAL
- en: 'if my_location:'
  prefs: []
  type: TYPE_NORMAL
- en: self.my_location = my_location
  prefs: []
  type: TYPE_NORMAL
- en: In the class declaration (class GeocachingApp(PointCollection)), we added GeocachingClass,
    which tells Python that the GeocachingApp class should inherit methods and properties
    from PointCollection. However, as both classes have an __init__ method, unless
    we do something, the Geocaching app’s __init__ method will completely overwrite
    the PointCollection method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want both of the __init__ methods called, so we will use the super() function.
    This tells Python to call the __init__ method of the inherited class. Also, as
    the PointCollection class handles the files importing now, we will pass the data_file
    argument to it. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Let’s test it and check whether the inheritance works. Go to the if __name__
    ==
  prefs: []
  type: TYPE_NORMAL
- en: '''__main__'': block at the end of the file and edit it as follows: if __name__
    == "__main__":'
  prefs: []
  type: TYPE_NORMAL
- en: gdal.PushErrorHandler('CPLQuietErrorHandler')
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the application:'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: my_app = GeocachingApp()
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will call a method from the PointCollection class: my_app.import_data("../data/geocaching.gpx")'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 2\. In fact, as you type the code, you may notice that PyCharm’s auto-completion
    feature now includes methods and properties from the inherited class.
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Run the code, and you should see this output:'
  prefs: []
  type: TYPE_NORMAL
- en: 'File imported: ../data/geocaching.gpx'
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have just used class inheritance with success. This is
    a very powerful and handy feature of Python.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, the challenge was to find a way to combine data from multiple
    sources.
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this is to make code that can take different types of data
    and transform it into a common type of object.
  prefs: []
  type: TYPE_NORMAL
- en: In order to achieve this, we first created two new Python classes. The first
    was the Geocache class, which represents a single geocache location and contains
    its coordinates, a name, and a description. The second was the PointCollection
    class, which represents a collection of Geocache objects. This class has the ability
    to import and convert the information from as many files as needed.
  prefs: []
  type: TYPE_NORMAL
- en: This technique that we used is called **abstraction**; its foundations reside
    in hiding complex procedures behind objects that can be easily understood by humans.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we integrated this new layer of abstraction into the application using
    class inheritance. The GeocachingApp class inherited the PointCollection, and
    in the end, it could behave similarly to any and both of them at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, while we will improve the application’s capability to search
    for points, you will also learn other ways of combining classes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter 4\. Improving the App Search**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Capabilities**'
  prefs: []
  type: TYPE_NORMAL
- en: So far, our app is capable of simply searching points that are close to a defined
    location. In this chapter, we are going to make a huge steep and make our app
    filter the data by geographic boundaries and by any field in the data.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to search geocaching points that
    are inside a given city, state, country, or any boundary defined by you. In addition,
    you will be able to search points by any of its properties such as difficult levels,
    name, user, and so on. It will also be possible to combine multiple filters.
  prefs: []
  type: TYPE_NORMAL
- en: In the process, we will see how to work with polygons and how the relations
    between geometries can be analyzed in a geoprocessing application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve these goals, we will go through the following topics: How to describe
    polygons using well-known text'
  prefs: []
  type: TYPE_NORMAL
- en: Using the Shapely package to handle geometries
  prefs: []
  type: TYPE_NORMAL
- en: Importing polygon data
  prefs: []
  type: TYPE_NORMAL
- en: Importing line data
  prefs: []
  type: TYPE_NORMAL
- en: The use of base classes and inheritance
  prefs: []
  type: TYPE_NORMAL
- en: The types of geometry relationships
  prefs: []
  type: TYPE_NORMAL
- en: Filtering by multiple properties and method chaining
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 19](img/index-176_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Working with polygons**'
  prefs: []
  type: TYPE_NORMAL
- en: Supposing we want to filter our data by a given region, it’s possible to assume
    that this region is represented by a polygon.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the following image represents the world counties’ borders, it
    was rendered from a Shapefile where each feature is a country and it’s geometry
    is a polygon.
  prefs: []
  type: TYPE_NORMAL
- en: Differently from the geocaching point, whose geometries are only a pair of coordinates,
    a polygon is a sequence of at least three-point coordinates beginning and ending
    at the same point.
  prefs: []
  type: TYPE_NORMAL
- en: By now, you can assume that we won’t be able to store the polygon’s coordinates
    with the same structure that we had with the geocaching point. We will need to
    store the whole OGR geometry or store something that can be transformed from or
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: How these polygons are represented is an important subject, because mastering
    it allows you to manipulate them any way you need to do any kind of work. It also
    allows you to build polygons from point coordinates (from a GPS for example) or
    form shapes such as a rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 20](img/index-177_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Knowing well-known text**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Well-known text** (**WKT**) is a human readable markup language to represent
    geometries in a spatial application. It was originally defined by the **Open Geospatial
    Consortium** (**OGC**) and is accepted by many software as a form of data exchange.
    The WKT has a binary equivalent called **well-known binary** (**WKB**). It is
    used for data storage and transfer where human readability is not required.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through some examples to see how WKT works. First, we will create an
    OGR
  prefs: []
  type: TYPE_NORMAL
- en: 'geometry of the polygon shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Make a copy of your Chapter3 folder inside the geopy project and rename
    it to Chapter4\.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Locate the Chapter4\experiments directory and delete the files inside it.
    If you don’t have this directory, create it.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Inside the Chapter4\experiments folder, create a new Python file. To do
    this in PyCharm, right-click on the folder and choose **New** | **Python File**.
    Name this file wkt_experiments.py.
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Type the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import ogr
  prefs: []
  type: TYPE_NORMAL
- en: wkt_rectangle = "POLYGON ((1 1, 1 9, 8 9, 8 1, 1 1))"
  prefs: []
  type: TYPE_NORMAL
- en: geometry = ogr.CreateGeometryFromWkt(wkt_rectangle)
  prefs: []
  type: TYPE_NORMAL
- en: print(geometry.__class__)
  prefs: []
  type: TYPE_NORMAL
- en: print(geometry.Area())
  prefs: []
  type: TYPE_NORMAL
- en: print(8*7)
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Now run it ( *Alt* + *Shift* + *F10* and choose wkt_experiments). You should
    see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: <class 'osgeo.ogr.Geometry'>
  prefs: []
  type: TYPE_NORMAL
- en: '56.0'
  prefs: []
  type: TYPE_NORMAL
- en: '56'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 21](img/index-178_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: What we did here was to define the WKT representation of a polygon in a Python
    string. Note that it started from coordinate 1.1 and listed all the coordinates
    clockwise ending at 1.1 again (the direction is not important; it could also be
    counter clockwise).
  prefs: []
  type: TYPE_NORMAL
- en: In the next line, we called OGR’s CreateGeometryFromWkt function that passed
    the string as a parameter. Internally, it converted the string into a OGR geometry
    object.
  prefs: []
  type: TYPE_NORMAL
- en: To make sure that everything went fine in the next three lines, we printed the
    class name of the object, the area calculated by OGR, and the manually calculated
    area.
  prefs: []
  type: TYPE_NORMAL
- en: Now, a more complicated polygon, one with a hole in the middle or an *island*.
  prefs: []
  type: TYPE_NORMAL
- en: '6\. Edit your code:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import ogr
  prefs: []
  type: TYPE_NORMAL
- en: wkt_rectangle = "POLYGON ((1 1, 1 9, 8 9, 8 1, 1 1))"
  prefs: []
  type: TYPE_NORMAL
- en: geometry = ogr.CreateGeometryFromWkt(wkt_rectangle)
  prefs: []
  type: TYPE_NORMAL
- en: print(geometry.__class__)
  prefs: []
  type: TYPE_NORMAL
- en: print(geometry.Area())
  prefs: []
  type: TYPE_NORMAL
- en: print(8*7)
  prefs: []
  type: TYPE_NORMAL
- en: wkt_rectangle2 = "POLYGON ((1 1, 8 1, 8 9, 1 9, 1 1)," \
  prefs: []
  type: TYPE_NORMAL
- en: '"(4 2, 4 5, 7 5, 7 2, 4 2))"'
  prefs: []
  type: TYPE_NORMAL
- en: geometry2 = ogr.CreateGeometryFromWkt(wkt_rectangle2)
  prefs: []
  type: TYPE_NORMAL
- en: print(geometry.__class__)
  prefs: []
  type: TYPE_NORMAL
- en: print(geometry2.Area())
  prefs: []
  type: TYPE_NORMAL
- en: print((8*7) - (3*3))
  prefs: []
  type: TYPE_NORMAL
- en: '7\. Now run it again ( *Shift* + *F10*). You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: <class 'osgeo.ogr.Geometry'>
  prefs: []
  type: TYPE_NORMAL
- en: '56.0'
  prefs: []
  type: TYPE_NORMAL
- en: '56'
  prefs: []
  type: TYPE_NORMAL
- en: <class 'osgeo.ogr.Geometry'>
  prefs: []
  type: TYPE_NORMAL
- en: '47.0'
  prefs: []
  type: TYPE_NORMAL
- en: '47'
  prefs: []
  type: TYPE_NORMAL
- en: Every polygon ring comes inside the parenthesis separated by commas. The exterior
    ring should be described first, then all the interior rings.
  prefs: []
  type: TYPE_NORMAL
- en: Managing geometries with WKT gets complicated as the complexity and the number
    of coordinates increase. To solve this and other problems, we will use another
    package that will make things a lot easier for us.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Shapely to handle geometries**'
  prefs: []
  type: TYPE_NORMAL
- en: Shapely is a Python package for the analysis of planar features. It uses functions
    from the GEOS library and a port of the **Java Topology Suite** (**JTS**).
  prefs: []
  type: TYPE_NORMAL
- en: It has mainly the same classes and functions as OGR while dealing with geometries.
  prefs: []
  type: TYPE_NORMAL
- en: Although it’s not a replacement for OGR, it has a more *pythonic* and a very
    intuitive interface, it is better optimized, and it has a well-developed documentation.
  prefs: []
  type: TYPE_NORMAL
- en: To make things clear, Shapely is intended to analyze geometries and only geometries.
    It does not handle features’ attributes, neither is it capable of reading and
    writing geospatial files.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a direct comparison of Shapely and OGR, we are going to rewrite the previous
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Add the following lines to the wkt_experiments.py file (you can keep or
    remove the previous code, it’s up to you):'
  prefs: []
  type: TYPE_NORMAL
- en: from shapely.geometry import Polygon
  prefs: []
  type: TYPE_NORMAL
- en: print('Examples with Shapely')
  prefs: []
  type: TYPE_NORMAL
- en: polygon1 = Polygon([(1, 1), (1, 9), (8, 9), (8, 1), (1, 1)]) print(polygon1.__class__)
  prefs: []
  type: TYPE_NORMAL
- en: print(polygon1.area)
  prefs: []
  type: TYPE_NORMAL
- en: polygon2 = Polygon([(1, 1), (1, 9), (8, 9), (8, 1), (1, 1)], [[(4, 2), (4, 5),(7,
    5), (7, 2), (4, 2)]])
  prefs: []
  type: TYPE_NORMAL
- en: print(polygon2.__class__)
  prefs: []
  type: TYPE_NORMAL
- en: print(polygon2.area)
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Now run the code again and look at the output:'
  prefs: []
  type: TYPE_NORMAL
- en: Examples with Shapely
  prefs: []
  type: TYPE_NORMAL
- en: <class 'shapely.geometry.polygon.Polygon'>
  prefs: []
  type: TYPE_NORMAL
- en: '56.0'
  prefs: []
  type: TYPE_NORMAL
- en: <class 'shapely.geometry.polygon.Polygon'>
  prefs: []
  type: TYPE_NORMAL
- en: '47.0'
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: Everything worked as expected, but you may notice a few differences. First,
    in order to create the polygon, we passed a list of tuples (it could be a list
    of lists) where each tuple is a point coordinate. This small change makes a big
    difference; lists are much easier to manipulate than strings.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, when we print the name of the class of the object created by Shapely,
    we see that it’s a Polygon class and not a Geometry as it was with OGR. This represents
    a higher level of abstraction as explained in [Chapter 3](index_split_000.html#p142),
    *Combining Multiple Data Sources*. With it comes all the goodies of abstraction
    and less worries about the internal functionality.
  prefs: []
  type: TYPE_NORMAL
- en: As you typed the code, specifically print(polygon1.area), PyCharm showed you
    a list
  prefs: []
  type: TYPE_NORMAL
- en: of methods for the Polygon class. This is another feature of Shapely, it is
    a well-written and IDE-friendly Python package. The consequence is that it allows
    you to take autocompletion, code inspections, refactoring, and a lot of the other
    features that come with modern IDEs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Importing polygons**'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the basics on how to work with polygons and we know how to
    represent and store them, we will go back to our app and add the ability to import
    geospatial files containing polygons. As we did with the points, we will abstract
    the features into the Python objects and we will also use class inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s look at the code we already wrote. In the models.py file, we have
    the PointCollection class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class PointCollection(object):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, file_path=None):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""This class represents a group of vector data."""'
  prefs: []
  type: TYPE_NORMAL
- en: self.data = []
  prefs: []
  type: TYPE_NORMAL
- en: self.epsg = None
  prefs: []
  type: TYPE_NORMAL
- en: 'if file_path:'
  prefs: []
  type: TYPE_NORMAL
- en: self.import_data(file_path)
  prefs: []
  type: TYPE_NORMAL
- en: 'def __add__(self, other):'
  prefs: []
  type: TYPE_NORMAL
- en: self.data += other.data
  prefs: []
  type: TYPE_NORMAL
- en: return self
  prefs: []
  type: TYPE_NORMAL
- en: 'def import_data(self, file_path):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Opens an vector file compatible with OGR and parses the data.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param str file_path: The full path to the file.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: features, metadata = open_vector_file(file_path)
  prefs: []
  type: TYPE_NORMAL
- en: self._parse_data(features)
  prefs: []
  type: TYPE_NORMAL
- en: self.epsg = metadata['epsg']
  prefs: []
  type: TYPE_NORMAL
- en: 'print("File imported: {}".format(file_path))'
  prefs: []
  type: TYPE_NORMAL
- en: 'def _parse_data(self, features):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Transforms the data into Geocache objects.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param features: A list of features.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: 'for feature in features:'
  prefs: []
  type: TYPE_NORMAL
- en: geom = feature['geometry']['coordinates']
  prefs: []
  type: TYPE_NORMAL
- en: attributes = feature['properties']
  prefs: []
  type: TYPE_NORMAL
- en: cache_point = Geocache(geom[0], geom[1],
  prefs: []
  type: TYPE_NORMAL
- en: attributes = attributes)
  prefs: []
  type: TYPE_NORMAL
- en: self.data.append(cache_point)
  prefs: []
  type: TYPE_NORMAL
- en: 'def describe(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'print("SRS EPSG code: {}".format(self.epsg))'
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Number of features: {}".format(len(self.data))) This class represents
    a collection of geocaching points and is responsible for importing these points
    and converting and storing them. These are exactly the same functionality that
    we want to implement to import polygons.'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, you saw how it’s possible, through inheritance, to
    make a class inherit functionalities from other classes. We will use this same
    technique to use what we already have to import the polygons.
  prefs: []
  type: TYPE_NORMAL
- en: Since the processing of geocaching points and polygons may have its particularities,
    it will need some of the things to be specific for each one. A specific example
    is the _parse_data method that, for now, converts features into geocaching points.
  prefs: []
  type: TYPE_NORMAL
- en: So, it’s not a good idea to make the class that represents polygons to inherit
    directly from the PointCollection class. Instead, the idea is to have two base
    classes, one that represents a single object and other that represents a collection
    of that object. These base classes will contain methods that are common to the
    points and the polygons, then the child classes will contain methods specific
    for each case.
  prefs: []
  type: TYPE_NORMAL
- en: The polygons that we will import could be countries, boundaries, states, or
    provinces of a country, city, district regions, and so on. Since it’s not clear
    yet, let’s call it *boundaries*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is explained in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. We will start creating the BaseGeoObject object and adapting from the Geocache
    class. Open the models.py file in the Chapter4 folder.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Make a copy of the Geocache class with all its methods (copy and paste).
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Rename the first copy to BaseGeoObject and change docstring to something
    like
  prefs: []
  type: TYPE_NORMAL
- en: '"Base class for single geo objects.". You should have this: class BaseGeoObject(object):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Base class for a single geo object."""'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, lat, lon, attributes=None):'
  prefs: []
  type: TYPE_NORMAL
- en: self.lat = lat
  prefs: []
  type: TYPE_NORMAL
- en: self.lon = lon
  prefs: []
  type: TYPE_NORMAL
- en: self.attributes = attributes
  prefs: []
  type: TYPE_NORMAL
- en: '@property'
  prefs: []
  type: TYPE_NORMAL
- en: 'def coordinates(self):'
  prefs: []
  type: TYPE_NORMAL
- en: return self.lat, self.lon
  prefs: []
  type: TYPE_NORMAL
- en: 'class Geocache(object):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""This class represents a single geocaching point."""'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, lat, lon, attributes=None):'
  prefs: []
  type: TYPE_NORMAL
- en: self.lat = lat
  prefs: []
  type: TYPE_NORMAL
- en: self.lon = lon
  prefs: []
  type: TYPE_NORMAL
- en: self.attributes = attributes
  prefs: []
  type: TYPE_NORMAL
- en: '@property'
  prefs: []
  type: TYPE_NORMAL
- en: 'def coordinates(self):'
  prefs: []
  type: TYPE_NORMAL
- en: return self.lat, self.lon
  prefs: []
  type: TYPE_NORMAL
- en: Now try to think, looking at both of the classes, what is specific for the Geocache,
    what doesn’t belong to a generic GeoObject or what belongs to it, and what properties
    and methods every type of geospatial object could have.
  prefs: []
  type: TYPE_NORMAL
- en: This separation could lead to some debate, and sometimes, depending on the complexity
    of the project and the nature of what you are dealing with, it may be hard to
    reach a final
  prefs: []
  type: TYPE_NORMAL
- en: state in the first iteration through the code. In your projects, you may need
    to come back and change how the classes are organized more than once.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, I’m going to propose the following logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lat, lon**: These properties are for the Geocache only. As we saw, we may
    have other types of geometries and we want to generalize how the geometries are
    stored.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Attributes**: All the objects should have this property.'
  prefs: []
  type: TYPE_NORMAL
- en: '**A __repr__ method**: This is another *magic method* like __init__ and __add__
    that we had in the previous chapter. __repr__ is called when you use the print()
    function on an object. We will add it and set it to not be implemented on the
    base class, because every type of object should have its own representation.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Coordinates property**: All geo objects should have coordinates, but how
    it is implemented here is specific to the Geocache. We will change that to a generic
    form: a geom property that will contain the object geometry.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make the first changes to these classes. Edit your code to be as follows:
    class BaseGeoObject(object):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Base class for a single geo object."""'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, geometry, attributes=None):'
  prefs: []
  type: TYPE_NORMAL
- en: self.geom = geometry
  prefs: []
  type: TYPE_NORMAL
- en: self.attributes = attributes
  prefs: []
  type: TYPE_NORMAL
- en: '@property'
  prefs: []
  type: TYPE_NORMAL
- en: 'def coordinates(self):'
  prefs: []
  type: TYPE_NORMAL
- en: raise NotImplementedError
  prefs: []
  type: TYPE_NORMAL
- en: 'def __repr__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: raise NotImplementedError
  prefs: []
  type: TYPE_NORMAL
- en: 'class Geocache(BaseGeoObject):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""This class represents a single geocaching point."""'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, geometry, attributes=None):'
  prefs: []
  type: TYPE_NORMAL
- en: super(Geocache, self).__init__(geometry, attributes)
  prefs: []
  type: TYPE_NORMAL
- en: 'def __repr__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: name = self.attributes.get('name', 'Unnamed')
  prefs: []
  type: TYPE_NORMAL
- en: return "{} {} - {}".format(self.geom.x,
  prefs: []
  type: TYPE_NORMAL
- en: self.geom.y, name)
  prefs: []
  type: TYPE_NORMAL
- en: A geom property was added to the class as a required argument while instantiating
    it. In this property, we will store the Shapely object. The lat and lon properties
    were removed; they can be accessed directly from the Shapely object (geom) and
    we will adapt PointCollection to do this.
  prefs: []
  type: TYPE_NORMAL
- en: The __repr__ method of the Geocache class returns a string containing the coordinates
    of the point and the name attribute when it’s available or Unnamed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the Boundary class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class Boundary(BaseGeoObject):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Represents a single political Boundary."""'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __repr__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: return self.name
  prefs: []
  type: TYPE_NORMAL
- en: For now, the Boundary class is almost the same as the BaseGeoObject class, so
    we only change the __repr__ method, so it returns only the name of the boundary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to edit the collection classes. Our PointCollection class
    is almost compatible with the new organization. We only need to make a few changes
    to the _parse_data method, transform this class into a base class, and create
    the classes that will inherit from it:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. First, like we did earlier, make a copy of the PointCollection class.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Now, rename the first occurrence of this class and change its docstring:
    class BaseGeoCollection(object):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""This class represents a collection of spatial data."""'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Go to the _parse_data method and alter it to be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '#...'
  prefs: []
  type: TYPE_NORMAL
- en: 'def _parse_data(self, features):'
  prefs: []
  type: TYPE_NORMAL
- en: raise NotImplementedError
  prefs: []
  type: TYPE_NORMAL
- en: 'What we did here was we explicitly told that this method is not implemented
    in the base class. This is a good practice for two reasons: first it is a hint
    for the programmer that this method needs to be implemented when this class is
    inherited and it also states the *signature* for the method (the arguments that
    it should receive). Secondly, if it is not implemented, Python will raise NotImplementedError
    instead of AttributeError, leading to a better debugging experience.'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Before we continue, edit the imported modules at the beginning of the file
    to match the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from __future__ import print_function
  prefs: []
  type: TYPE_NORMAL
- en: import gdal
  prefs: []
  type: TYPE_NORMAL
- en: from shapely.geometry import Point
  prefs: []
  type: TYPE_NORMAL
- en: from shapely import wkb, wkt
  prefs: []
  type: TYPE_NORMAL
- en: from utils.geo_functions import open_vector_file
  prefs: []
  type: TYPE_NORMAL
- en: 2\. The base class is ready and now we are going to edit the PointCollection
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, you can remove all the methods from this class. Leave only the docstring
    and the _parse_data method.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Edit the class declaration and make it inherit from BaseGeoCollection.
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Finally, edit the _parse_data method to be compliant with the geometry
    represented by Shapely objects. Your code should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class PointCollection(BaseGeoCollection):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""This class represents a collection of'
  prefs: []
  type: TYPE_NORMAL
- en: geocaching points.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: 'def _parse_data(self, features):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Transforms the data into Geocache objects.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param features: A list of features.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: 'for feature in features:'
  prefs: []
  type: TYPE_NORMAL
- en: coords = feature['geometry']['coordinates']
  prefs: []
  type: TYPE_NORMAL
- en: point = Point(float(coords[1]), float(coords[0]))
  prefs: []
  type: TYPE_NORMAL
- en: attributes = feature['properties']
  prefs: []
  type: TYPE_NORMAL
- en: cache_point = Geocache(point, attributes = attributes)
  prefs: []
  type: TYPE_NORMAL
- en: self.data.append(cache_point)
  prefs: []
  type: TYPE_NORMAL
- en: Note that the difference is that while instancing the Geocache, instead of passing
    the coordinates, we are now passing a Point object, which is an instance of the
    Point class provided by Shapely.
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Next we are going to create the BoundaryCollection class. Insert this code
    anywhere after the base classes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class BoundaryCollection(BaseGeoCollection):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""This class represents a collection of'
  prefs: []
  type: TYPE_NORMAL
- en: geographic boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: 'def _parse_data(self, features):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for feature in features:'
  prefs: []
  type: TYPE_NORMAL
- en: geom = feature['geometry']['coordinates']
  prefs: []
  type: TYPE_NORMAL
- en: attributes = feature['properties']
  prefs: []
  type: TYPE_NORMAL
- en: polygon = wkt.loads(geom)
  prefs: []
  type: TYPE_NORMAL
- en: boundary = Boundary(geometry=polygon,
  prefs: []
  type: TYPE_NORMAL
- en: attributes=attributes)
  prefs: []
  type: TYPE_NORMAL
- en: self.data.append(boundary)
  prefs: []
  type: TYPE_NORMAL
- en: The difference from PointCollection is that we are now creating polygons and
    instances of the Boundary class. Note how the polygon is created with the statement
    wkt.loads(geom).
  prefs: []
  type: TYPE_NORMAL
- en: '6\. We are almost done. Check whether everything is correct. The complete models.py
    file should contain the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from __future__ import print_function
  prefs: []
  type: TYPE_NORMAL
- en: import gdal
  prefs: []
  type: TYPE_NORMAL
- en: from shapely.geometry import Point
  prefs: []
  type: TYPE_NORMAL
- en: from shapely import wkb, wkt
  prefs: []
  type: TYPE_NORMAL
- en: from utils.geo_functions import open_vector_file
  prefs: []
  type: TYPE_NORMAL
- en: 'class BaseGeoObject(object):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Base class for a single geo object."""'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, geometry, attributes=None):'
  prefs: []
  type: TYPE_NORMAL
- en: self.geom = geometry
  prefs: []
  type: TYPE_NORMAL
- en: self.attributes = attributes
  prefs: []
  type: TYPE_NORMAL
- en: '@property'
  prefs: []
  type: TYPE_NORMAL
- en: 'def coordinates(self):'
  prefs: []
  type: TYPE_NORMAL
- en: raise NotImplementedError
  prefs: []
  type: TYPE_NORMAL
- en: 'def __repr__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: raise NotImplementedError
  prefs: []
  type: TYPE_NORMAL
- en: 'class Geocache(BaseGeoObject):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""This class represents a single geocaching point."""'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, geometry, attributes=None):'
  prefs: []
  type: TYPE_NORMAL
- en: super(Geocache, self).__init__(geometry, attributes)
  prefs: []
  type: TYPE_NORMAL
- en: 'def __repr__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: name = self.attributes.get('name', 'Unnamed')
  prefs: []
  type: TYPE_NORMAL
- en: return "{} {} - {}".format(self.geom.x,
  prefs: []
  type: TYPE_NORMAL
- en: self.geom.y, name)
  prefs: []
  type: TYPE_NORMAL
- en: 'class Boundary(BaseGeoObject):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Represents a single geographic boundary."""'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __repr__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: return self.attributes.get('name', 'Unnamed')
  prefs: []
  type: TYPE_NORMAL
- en: 'class BaseGeoCollection(object):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""This class represents a collection of spatial data."""'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, file_path=None):'
  prefs: []
  type: TYPE_NORMAL
- en: self.data = []
  prefs: []
  type: TYPE_NORMAL
- en: self.epsg = None
  prefs: []
  type: TYPE_NORMAL
- en: 'if file_path:'
  prefs: []
  type: TYPE_NORMAL
- en: self.import_data(file_path)
  prefs: []
  type: TYPE_NORMAL
- en: 'def __add__(self, other):'
  prefs: []
  type: TYPE_NORMAL
- en: self.data += other.data
  prefs: []
  type: TYPE_NORMAL
- en: return self
  prefs: []
  type: TYPE_NORMAL
- en: 'def import_data(self, file_path):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Opens an vector file compatible with OGR and parses the data.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param str file_path: The full path to the file.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: features, metadata = open_vector_file(file_path)
  prefs: []
  type: TYPE_NORMAL
- en: self._parse_data(features)
  prefs: []
  type: TYPE_NORMAL
- en: self.epsg = metadata['epsg']
  prefs: []
  type: TYPE_NORMAL
- en: 'print("File imported: {}".format(file_path))'
  prefs: []
  type: TYPE_NORMAL
- en: 'def _parse_data(self, features):'
  prefs: []
  type: TYPE_NORMAL
- en: raise NotImplementedError
  prefs: []
  type: TYPE_NORMAL
- en: 'def describe(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'print("SRS EPSG code: {}".format(self.epsg))'
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Number of features: {}".format(len(self.data))) class PointCollection(BaseGeoCollection):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""This class represents a collection of'
  prefs: []
  type: TYPE_NORMAL
- en: geocaching points.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: 'def _parse_data(self, features):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Transforms the data into Geocache objects.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param features: A list of features.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: 'for feature in features:'
  prefs: []
  type: TYPE_NORMAL
- en: coords = feature['geometry']['coordinates']
  prefs: []
  type: TYPE_NORMAL
- en: point = Point(coords)
  prefs: []
  type: TYPE_NORMAL
- en: attributes = feature['properties']
  prefs: []
  type: TYPE_NORMAL
- en: cache_point = Geocache(point, attributes=attributes)
  prefs: []
  type: TYPE_NORMAL
- en: self.data.append(cache_point)
  prefs: []
  type: TYPE_NORMAL
- en: 'class BoundaryCollection(BaseGeoCollection):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""This class represents a collection of'
  prefs: []
  type: TYPE_NORMAL
- en: geographic boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: 'def _parse_data(self, features):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for feature in features:'
  prefs: []
  type: TYPE_NORMAL
- en: geom = feature['geometry']['coordinates']
  prefs: []
  type: TYPE_NORMAL
- en: attributes = feature['properties']
  prefs: []
  type: TYPE_NORMAL
- en: polygon = wkt.loads(geom)
  prefs: []
  type: TYPE_NORMAL
- en: boundary = Boundary(geometry=polygon,
  prefs: []
  type: TYPE_NORMAL
- en: attributes=attributes)
  prefs: []
  type: TYPE_NORMAL
- en: self.data.append(boundary)
  prefs: []
  type: TYPE_NORMAL
- en: 7\. Now, in order to test it, go to the end of the file and edit the if __name__
    ==
  prefs: []
  type: TYPE_NORMAL
- en: '''__main__'': block:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: 'world = BoundaryCollection("../data/world_borders_simple.shp") for item in
    world.data:'
  prefs: []
  type: TYPE_NORMAL
- en: print(item)
  prefs: []
  type: TYPE_NORMAL
- en: '8\. Now run it, press *Alt* + *Shift* + *F10*, and select models. If everything
    is OK, you should see a long list of the unnamed countries:'
  prefs: []
  type: TYPE_NORMAL
- en: 'File imported: ../data/world_borders_simple.shp'
  prefs: []
  type: TYPE_NORMAL
- en: Unnamed
  prefs: []
  type: TYPE_NORMAL
- en: Unnamed
  prefs: []
  type: TYPE_NORMAL
- en: Unnamed
  prefs: []
  type: TYPE_NORMAL
- en: Unnamed…
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: This is disappointing. We expected to see the names of the countries, but for
    some reason, the program failed to get it from the attributes. We will solve this
    problem in the next topic.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the attributes’ values**'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore the attributes of the world borders to find out why we were unable
    to get the names.
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Edit the if __name__ == ''__main__'': block:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: world = BoundaryCollection("../data/world_borders_simple.shp") print(world.data[0].attributes.keys())
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Run the code and look at the output:'
  prefs: []
  type: TYPE_NORMAL
- en: 'File imported: ../data/world_borders_simple.shp'
  prefs: []
  type: TYPE_NORMAL
- en: '[''SUBREGION'', ''POP2005'', ''REGION'', ''ISO3'', ''ISO2'', ''FIPS'', ''UN'','
  prefs: []
  type: TYPE_NORMAL
- en: '''NAME'']'
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: What we did was we got the first item in world.data and then printed its attribute
    keys. The list shown in the output has a NAME key, but it is all in the uppercase.
    This is very common for Shapefiles whose data is contained in the DBF files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we don’t want to worry if the attributes’ names are in the uppercase
    or lowercase, we have two possible solutions: convert the names at the moment
    of the import or convert the names on the fly when the attribute value is requested.'
  prefs: []
  type: TYPE_NORMAL
- en: Depending on your application, you may achieve better performance with one or
    the other method. Here, for didactic purposes, we will opt for the on-the-fly
    conversion and add a little spice to it.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Instead of accessing the attributes directly, let’s make a method that will
    do it for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the BaseGeoObject class’ __init__ method and also add a get_attribute
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class BaseGeoObject(object):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Base class for a single geo object."""'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, geometry, attributes=None):'
  prefs: []
  type: TYPE_NORMAL
- en: self.geom = geometry
  prefs: []
  type: TYPE_NORMAL
- en: self.attributes = attributes
  prefs: []
  type: TYPE_NORMAL
- en: '**# Makes a lookup table of case insensitive attributes.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**self._attributes_lowercase = {}**'
  prefs: []
  type: TYPE_NORMAL
- en: '**for key in self.attributes.keys():**'
  prefs: []
  type: TYPE_NORMAL
- en: '**self._attributes_lowercase[key.lower()] = key**'
  prefs: []
  type: TYPE_NORMAL
- en: '@property'
  prefs: []
  type: TYPE_NORMAL
- en: 'def coordinates(self):'
  prefs: []
  type: TYPE_NORMAL
- en: raise NotImplementedError
  prefs: []
  type: TYPE_NORMAL
- en: 'def get_attribute(self, attr_name, case_sensitive=False):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Gets an attribute by its name.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param attr_name: The name of the attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param case_sensitive: True or False.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: 'if not case_sensitive:'
  prefs: []
  type: TYPE_NORMAL
- en: attr_name = attr_name.lower()
  prefs: []
  type: TYPE_NORMAL
- en: attr_name = self._attributes_lowercase[attr_name]
  prefs: []
  type: TYPE_NORMAL
- en: return self.attributes[attr_name]
  prefs: []
  type: TYPE_NORMAL
- en: 'def __repr__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: raise NotImplementedError
  prefs: []
  type: TYPE_NORMAL
- en: In the __init__ method, we made a dictionary that contains the equivalence between
    lowercase attribute names and the original names. If you search the Internet,
    there is a number of techniques to implement case-insensitive dictionaries. But
    the one we implemented here allows us to preserve the original names, giving the
    user the option to choose whether he wants the search to be case-sensitive or
    not.
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Now, edit the Boundary class to use the new method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class Boundary(BaseGeoObject):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Represents a single geographic boundary."""'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __repr__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: return self.get_attribute('name')
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Edit the if __name__ == ''__main__'': block:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: 'world = BoundaryCollection("../data/world_borders_simple.shp") for item in
    world.data:'
  prefs: []
  type: TYPE_NORMAL
- en: print(item)
  prefs: []
  type: TYPE_NORMAL
- en: '6\. Run the code again. Now, you should have a beautiful list of country names:
    File imported: ../data/world_borders_simple.shp'
  prefs: []
  type: TYPE_NORMAL
- en: Antigua and Barbuda
  prefs: []
  type: TYPE_NORMAL
- en: Algeria
  prefs: []
  type: TYPE_NORMAL
- en: Azerbaijan
  prefs: []
  type: TYPE_NORMAL
- en: Albania
  prefs: []
  type: TYPE_NORMAL
- en: Armenia…
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: '**Importing lines**'
  prefs: []
  type: TYPE_NORMAL
- en: As we did with the geocaching points and political boundaries, we will implement
    the ability of the program to import lines (that is, linestrings). These lines
    can represent roads, rivers, power lines, and so on. With this kind of features,
    we will be able to search for points that are close to a given road for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lines and the collection of lines will also be the subclasses of BaseGeoObject
    and BaseGeoCollection. Let’s start by making a LineString and a LineStringCollection
    class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Insert this new class into the models.py file. It could be anywhere after
    the base classes’ definition:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class LineString(BaseGeoObject):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Represents a single linestring."""'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __repr__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: return self.get_attribute('name')
  prefs: []
  type: TYPE_NORMAL
- en: Again, we only implement the __repr__ method. The other functionalities are
    inherited from the BaseGeoObject class.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Now, add the class representing a collection of linestrings and its _parse_data
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class LineStringCollection(BaseGeoCollection):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Represents a collection of linestrings."""'
  prefs: []
  type: TYPE_NORMAL
- en: 'def _parse_data(self, features):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for feature in features:'
  prefs: []
  type: TYPE_NORMAL
- en: geom = feature['geometry']['coordinates']
  prefs: []
  type: TYPE_NORMAL
- en: attributes = feature['properties']
  prefs: []
  type: TYPE_NORMAL
- en: line = wkt.loads(geom)
  prefs: []
  type: TYPE_NORMAL
- en: linestring = LineString(geometry=line,
  prefs: []
  type: TYPE_NORMAL
- en: attributes=attributes)
  prefs: []
  type: TYPE_NORMAL
- en: self.data.append(linestring)
  prefs: []
  type: TYPE_NORMAL
- en: In order to test our new classes, we are going to use a shapefile containing
    USA’s main roads.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 22](img/index-196_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '3\. Edit the if __name__ == ''__main__'': block at the end of the file. You
    can comment the previous code if you wish instead of deleting it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: usa_roads = LineStringCollection('../data/roads.shp')
  prefs: []
  type: TYPE_NORMAL
- en: 'for item in usa_roads.data:'
  prefs: []
  type: TYPE_NORMAL
- en: print(item)
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Run the code. You should get a big list of the road names in the output
    console: File imported: ../data/roads.shp'
  prefs: []
  type: TYPE_NORMAL
- en: State Route 131
  prefs: []
  type: TYPE_NORMAL
- en: State Route 3
  prefs: []
  type: TYPE_NORMAL
- en: State Route 3
  prefs: []
  type: TYPE_NORMAL
- en: State Route 3
  prefs: []
  type: TYPE_NORMAL
- en: State Route 411
  prefs: []
  type: TYPE_NORMAL
- en: State Route 3
  prefs: []
  type: TYPE_NORMAL
- en: State Route 3
  prefs: []
  type: TYPE_NORMAL
- en: State Route 5, State Route 786…
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: In order to make our output more meaningful, we can change how each LineString
    class is printed. Remember that the special method named __repr__ is called when
    you use the print() function on an object, and it should return a string to be
    printed.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s return more information when LineString is printed.
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Edit your LineString class and change the __repr__ method, so it returns
    the road name and length:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class LineString(BaseGeoObject):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Represents a single linestring."""'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __repr__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: length = self.geom.length
  prefs: []
  type: TYPE_NORMAL
- en: return "{} - {}".format(self.get_attribute('name'), length)
  prefs: []
  type: TYPE_NORMAL
- en: Here, we used Python’s string formatting to compose a string that can be returned
    by this method.
  prefs: []
  type: TYPE_NORMAL
- en: '6\. Run the code and see the new output:'
  prefs: []
  type: TYPE_NORMAL
- en: 'File imported: ../data/roads.shp'
  prefs: []
  type: TYPE_NORMAL
- en: US Route 395-0.16619770512
  prefs: []
  type: TYPE_NORMAL
- en: US Route 30-0.0432070790491
  prefs: []
  type: TYPE_NORMAL
- en: State Route 84-0.0256320861143
  prefs: []
  type: TYPE_NORMAL
- en: US Route 6-0.336460513878
  prefs: []
  type: TYPE_NORMAL
- en: US Route 40-0.107844768871
  prefs: []
  type: TYPE_NORMAL
- en: State Route 272-0.0264889614357…
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: Although it’s much better than before, it still has a problem. The length is
    in degrees, and it means little or nothing to us because we are used to meters,
    miles, or any other linear unity. So, we need to convert the unity before we print
    the length.
  prefs: []
  type: TYPE_NORMAL
- en: '**Converting the spatial reference system**'
  prefs: []
  type: TYPE_NORMAL
- en: '**and units**'
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, we already did this kind of operation before and now we are going
    to adapt it to our data model.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will transform the coordinates of the geometries only when they are needed.
    To perform the transformation, we will create a new utility function, as follows:
    1\. Open geo_functions.py in our utils folder and create a new function: def transform_geometry(geom,
    src_epsg=4326, dst_epsg=3395):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Transforms a single wkb geometry.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param geom: wkb geom.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param src_epsg: EPSG code for the source geometry.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param dst_epsg: EPSG code for the destination geometry.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: ogr_geom = ogr.CreateGeometryFromWkb(geom)
  prefs: []
  type: TYPE_NORMAL
- en: ogr_transformation = create_transform(src_epsg, dst_epsg)
  prefs: []
  type: TYPE_NORMAL
- en: ogr_geom.Transform(ogr_transformation)
  prefs: []
  type: TYPE_NORMAL
- en: return ogr_geom.ExportToWkb()
  prefs: []
  type: TYPE_NORMAL
- en: It takes as arguments geometries in the WKB format, its EPSG code, and the EPSG
  prefs: []
  type: TYPE_NORMAL
- en: code for the desired coordinate system for the output. It performs the transformation
    and returns a WKB geometry again.
  prefs: []
  type: TYPE_NORMAL
- en: Now back to the models; let’s import this function and use it.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Edit the import at the beginning of the models.py file:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from __future__ import print_function
  prefs: []
  type: TYPE_NORMAL
- en: import gdal
  prefs: []
  type: TYPE_NORMAL
- en: from shapely.geometry import Point
  prefs: []
  type: TYPE_NORMAL
- en: from shapely import wkb, wkt
  prefs: []
  type: TYPE_NORMAL
- en: from utils.geo_functions import open_vector_file
  prefs: []
  type: TYPE_NORMAL
- en: '**from utils.geo_functions import transform_geometry**'
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Now, edit BaseGeoObject, so our classes can inherit this new functionality:
    class BaseGeoObject(object):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Base class for a single geo object."""'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, geometry, attributes=None):'
  prefs: []
  type: TYPE_NORMAL
- en: self.geom = geometry
  prefs: []
  type: TYPE_NORMAL
- en: self.attributes = attributes
  prefs: []
  type: TYPE_NORMAL
- en: '**self.wm_geom = None**'
  prefs: []
  type: TYPE_NORMAL
- en: Makes a lookup table of case insensitive attributes.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: self._attributes_lowercase = {}
  prefs: []
  type: TYPE_NORMAL
- en: 'for key in self.attributes.keys():'
  prefs: []
  type: TYPE_NORMAL
- en: self._attributes_lowercase[key.lower()] = key
  prefs: []
  type: TYPE_NORMAL
- en: '**def transformed_geom(self):**'
  prefs: []
  type: TYPE_NORMAL
- en: '**"""Returns the geometry transformed into WorldMercator** **coordinate system.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**"""**'
  prefs: []
  type: TYPE_NORMAL
- en: '**if not self.wm_geom:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**geom = transform_geometry(self.geom.wkb)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**self.wm_geom = wkb.loads(geom)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**return self.wm_geom**'
  prefs: []
  type: TYPE_NORMAL
- en: 'def get_attribute(self, attr_name, case_sensitive=False):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Gets an attribute by its name.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param attr_name: The name of the attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param case_sensitive: True or False.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: 'if not case_sensitive:'
  prefs: []
  type: TYPE_NORMAL
- en: attr_name = attr_name.lower()
  prefs: []
  type: TYPE_NORMAL
- en: attr_name = self._attributes_lowercase[attr_name]
  prefs: []
  type: TYPE_NORMAL
- en: return self.attributes[attr_name]
  prefs: []
  type: TYPE_NORMAL
- en: 'def __repr__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: raise NotImplementedError
  prefs: []
  type: TYPE_NORMAL
- en: Note that we opted to keep the geometries in both the coordinate systems. The
    geometry in WorldMercator is stored in the wm_geom property the first time the
    transformation occurs. The next time transformed_geom is called, it will only
    get the property value. This is called **memorization** and we will see more of
    this technique later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on your application, this may be a good practice because you may want
    to use different coordinate systems for specific purposes. For example, to draw
    a map, you may want to use lat/lon and, to perform calculation, you would need
    the coordinates in meters. The downside is that the memory consumption is higher,
    because you will be storing two sets of geometry.
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Finally, we go back to the LineString class and change its __repr__ method
    to use transformed_geom to calculate the length:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class LineString(BaseGeoObject):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Represents a single linestring."""'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __repr__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'return "{}-{}".format(self.get_attribute(''name''), **self.transformed_geom().length)**
    5\. Run the code and see the new output:'
  prefs: []
  type: TYPE_NORMAL
- en: 'File imported: ../data/roads.shp'
  prefs: []
  type: TYPE_NORMAL
- en: State Route 3-100928.690515
  prefs: []
  type: TYPE_NORMAL
- en: State Route 411-3262.29448315
  prefs: []
  type: TYPE_NORMAL
- en: State Route 3-331878.76971
  prefs: []
  type: TYPE_NORMAL
- en: State Route 3-56013.8246795.73…
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: It’s much better now as we can see the road lengths in meters. But it is still
    not perfect
  prefs: []
  type: TYPE_NORMAL
- en: because, normally, we would want the lengths in kilometres or miles. So, we
    need to convert the unit.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 1,](index_split_000.html#p45) *Preparing the Work Environment*,
    we made a beautiful function capable of performing these transformations; we used
    it to convert area units. Using it as a template, we are going to implement it
    to convert length units.
  prefs: []
  type: TYPE_NORMAL
- en: Since it’s a function that can be used in other parts of any application, we
    are going to put it into the geo_functions.py module in the utils package (that
    is, directory).
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Edit the geo_functions.py files and copy and paste the function that we
    used in
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 1,](index_split_000.html#p45) *Preparing the Work Environment*, to
    calculate and transform area units.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will keep it there for later use:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def calculate_areas(geometries, unity=''km2''):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Calculate the area for a list of ogr geometries."""'
  prefs: []
  type: TYPE_NORMAL
- en: conversion_factor = {
  prefs: []
  type: TYPE_NORMAL
- en: '''sqmi'': 2589988.11,'
  prefs: []
  type: TYPE_NORMAL
- en: '''km2'': 1000000,'
  prefs: []
  type: TYPE_NORMAL
- en: '''m'': 1}'
  prefs: []
  type: TYPE_NORMAL
- en: 'if unity not in conversion_factor:'
  prefs: []
  type: TYPE_NORMAL
- en: raise ValueError(
  prefs: []
  type: TYPE_NORMAL
- en: '"This unity is not defined: {}".format(unity))'
  prefs: []
  type: TYPE_NORMAL
- en: areas = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for geom in geometries:'
  prefs: []
  type: TYPE_NORMAL
- en: area = geom.Area()
  prefs: []
  type: TYPE_NORMAL
- en: areas.append(area / conversion_factor[unity])
  prefs: []
  type: TYPE_NORMAL
- en: return areas
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Duplicate this function (copy and paste) and edit it to make it like the
    following code: def convert_length_unit(value, unit=''km'', decimal_places=2):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Convert the leng unit of a given value.'
  prefs: []
  type: TYPE_NORMAL
- en: The input is in meters and the output is set by the unity
  prefs: []
  type: TYPE_NORMAL
- en: argument.
  prefs: []
  type: TYPE_NORMAL
- en: ':param value: Input value in meters.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param unit: The desired output unit.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param decimal_places: Number of decimal places of the output.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: conversion_factor = {
  prefs: []
  type: TYPE_NORMAL
- en: '''mi'': 0.000621371192,'
  prefs: []
  type: TYPE_NORMAL
- en: '''km'': 0.001,'
  prefs: []
  type: TYPE_NORMAL
- en: '''m'': 1.0}'
  prefs: []
  type: TYPE_NORMAL
- en: 'if unit not in conversion_factor:'
  prefs: []
  type: TYPE_NORMAL
- en: raise ValueError(
  prefs: []
  type: TYPE_NORMAL
- en: '"This unit is not defined: {}".format(unit))'
  prefs: []
  type: TYPE_NORMAL
- en: return round(value * conversion_factor[unit], decimal_places) Again, it’s a
    very versatile function because you can easily change its code to add more conversion
    factors to it. Here, we also introduced the round() function, so we can see a
    more readable result. By default, it will round the result to two decimal places,
    which in most cases, is enough for a good representation of length.
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Go back to the models and import this new function after the other imports:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from __future__ import print_function
  prefs: []
  type: TYPE_NORMAL
- en: import gdal
  prefs: []
  type: TYPE_NORMAL
- en: from shapely.geometry import Point
  prefs: []
  type: TYPE_NORMAL
- en: from shapely import wkb, wkt
  prefs: []
  type: TYPE_NORMAL
- en: from utils.geo_functions import open_vector_file
  prefs: []
  type: TYPE_NORMAL
- en: from utils.geo_functions import transform_geometry
  prefs: []
  type: TYPE_NORMAL
- en: '**from utils.geo_functions import convert_length_unit**'
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Now edit the LineString class. We will add a *convenience method* (we will
    see more about this later in the chapter) that will return the length in a converted
    unit, change the __repr__ value to use it, and also improve the string formatting
    to display the unit and get a better output:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class LineString(BaseGeoObject):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Represents a single linestring."""'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __repr__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: '**unit = ''km''**'
  prefs: []
  type: TYPE_NORMAL
- en: '**return "{} ({}{})".format(self.get_attribute(''name''),** **self.length(unit),
    unit)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**def length(self, unit=''km''):**'
  prefs: []
  type: TYPE_NORMAL
- en: '**"""Convenience method that returns the length of the** **linestring in a
    given unit.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**:param unit: The desired output unit.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**"""**'
  prefs: []
  type: TYPE_NORMAL
- en: '**return convert_length_unit(self.transformed_geom().length,** **unit)**'
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Run the code again and see what we have accomplished:'
  prefs: []
  type: TYPE_NORMAL
- en: 'File imported: ../data/roads.shp'
  prefs: []
  type: TYPE_NORMAL
- en: State Route 146 (10.77km)
  prefs: []
  type: TYPE_NORMAL
- en: US Route 7, US Route 20 (5.81km)
  prefs: []
  type: TYPE_NORMAL
- en: State Route 295 (13.67km)
  prefs: []
  type: TYPE_NORMAL
- en: Interstate Route 90 (3.55km)
  prefs: []
  type: TYPE_NORMAL
- en: State Route 152 (18.22km)
  prefs: []
  type: TYPE_NORMAL
- en: State Route 73 (65.19km)
  prefs: []
  type: TYPE_NORMAL
- en: State Route 20 (53.89km)
  prefs: []
  type: TYPE_NORMAL
- en: State Route 95 (10.38km)
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: '**Geometry relationships**'
  prefs: []
  type: TYPE_NORMAL
- en: We want to filter the geocaching points that fall inside a given boundary (a
    country, state, city, and so on.). In order to perform this kind of filtering,
    we need to verify every point and see whether it’s inside the polygon representing
    the boundary.
  prefs: []
  type: TYPE_NORMAL
- en: In geoprocessing, the relations between the two geometries are described by
    a set of known predicates. These relationships are very important because they
    allow conditions to be made, so one can perform operations and calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Shapely comes with a complete set of predicates that analyze the relation of
    the two geometries. Before we go further in our app, let’s take a look at the
    possible relation checks.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 23](img/index-205_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Touches**'
  prefs: []
  type: TYPE_NORMAL
- en: This is true if the geometries have one or more points in common without their
    interiors intersecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 24](img/index-206_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Crosses**'
  prefs: []
  type: TYPE_NORMAL
- en: This is true if there is an intersection between the two objects without one
    containing the other.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 25](img/index-207_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Contains**'
  prefs: []
  type: TYPE_NORMAL
- en: This indicates if one object completely contains the other object; all the boundaries,
    lines, or points must be inside the first object.
  prefs: []
  type: TYPE_NORMAL
- en: '**Within**'
  prefs: []
  type: TYPE_NORMAL
- en: This is true if one geometry is contained in another geometry. It’s the same
    as *Contains*, but if you switch the two geometries.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 26](img/index-209_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Equals or almost equals**'
  prefs: []
  type: TYPE_NORMAL
- en: This is true if the two objects have the same boundary and interior. Almost
    equals allows a configurable tolerance in the precision of the test.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 27](img/index-210_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Intersects**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This indicates that one geometry intersects the other in any way. It is true
    if any of these relations are true: contains, crosses, equals, touches, and within.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 28](img/index-211_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Disjoint**'
  prefs: []
  type: TYPE_NORMAL
- en: This returns true if the two geometries have no relation between them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filtering by attributes and relations**'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how geometries relate to each other, we can search points using
    these relations. We already have the means for importing the points and the polygons
    that represent any kind of boundaries that may be of our interest.
  prefs: []
  type: TYPE_NORMAL
- en: The data that comes with the book files contains examples of world countries’
    boundaries, but you are free to search the Internet for any data that is significant
    to you. Remember only that the data coordinates should be in latitudes and longitudes,
    and they need to have a name field.
  prefs: []
  type: TYPE_NORMAL
- en: For our tests, I prepared a special set of geocaching points that spans the
    whole globe, and as an exercise, we will filter these points by a country.
  prefs: []
  type: TYPE_NORMAL
- en: 'The proposed workflow is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the points and boundaries
  prefs: []
  type: TYPE_NORMAL
- en: Find the boundary that we want to use
  prefs: []
  type: TYPE_NORMAL
- en: Filter the points by that boundary
  prefs: []
  type: TYPE_NORMAL
- en: Return the points to the user
  prefs: []
  type: TYPE_NORMAL
- en: To find the points that we want, we will iterate over the data until it hits
    a match. Iterations can be costly in terms of processing depending on the amount
    of data and on the operations that are performed on each loop. Let’s keep this
    in mind.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step in the workflow is already done, so let’s write the code to
    find the boundary of our interest. If you are using the data provided, we can
    find the boundary of your country as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Go to the BoundaryCollection class and add a new method get_by_name: class
    BoundaryCollection(BaseGeoCollection):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""This class represents a collection of'
  prefs: []
  type: TYPE_NORMAL
- en: geographic boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: 'def _parse_data(self, features):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for feature in features:'
  prefs: []
  type: TYPE_NORMAL
- en: geom = feature['geometry']['coordinates']
  prefs: []
  type: TYPE_NORMAL
- en: attributes = feature['properties']
  prefs: []
  type: TYPE_NORMAL
- en: polygon = wkt.loads(geom)
  prefs: []
  type: TYPE_NORMAL
- en: boundary = Boundary(geometry=polygon,
  prefs: []
  type: TYPE_NORMAL
- en: attributes=attributes)
  prefs: []
  type: TYPE_NORMAL
- en: self.data.append(boundary)
  prefs: []
  type: TYPE_NORMAL
- en: 'def get_by_name(self, name):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Find an object by its name attribute and returns it."""'
  prefs: []
  type: TYPE_NORMAL
- en: 'for item in self.data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if item.get_attribute(''name'') == name:'
  prefs: []
  type: TYPE_NORMAL
- en: return item
  prefs: []
  type: TYPE_NORMAL
- en: raise LookupError(
  prefs: []
  type: TYPE_NORMAL
- en: '"Object not found with the name: {}".format(name)) This very simple method
    iterates over the data. When it finds the first boundary'
  prefs: []
  type: TYPE_NORMAL
- en: whose name property matches the name passed as an argument, the function execution
    stops and the object is returned. If nothing is found, LookupError will be raised.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Let’s play with it. Go to the if __name__ == ''__main__'': block at the
    end of the file and edit it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: world = BoundaryCollection("../data/world_borders_simple.shp") print(world.get_by_name('Brazil'))
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Try the different countries’ names and see the results. If it’s found,
    you should have an output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'File imported: ../data/world_borders_simple.shp'
  prefs: []
  type: TYPE_NORMAL
- en: Brazil
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: '4\. If it’s not found, you should get a nice exception:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Traceback (most recent call last):'
  prefs: []
  type: TYPE_NORMAL
- en: File "Chapter 4/code/models.py", line 153, in <module> print(world_Boundarys.get_by_name('Foo'))
  prefs: []
  type: TYPE_NORMAL
- en: File "Chapter 4/code/models.py", line 148, in get_by_name
  prefs: []
  type: TYPE_NORMAL
- en: '''Object not found with the name: {}''.format(name))'
  prefs: []
  type: TYPE_NORMAL
- en: 'LookupError: Object not found with the name: Foo'
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 1
  prefs: []
  type: TYPE_NORMAL
- en: 'Very well, our method works nice and with an additional (almost) unexpected
    feature: it’s not specific for the boundaries; it can be used to find any type
    of GeoObject. Take a look and notice how it only uses properties that are available
    in our base classes.'
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Move the get_by_name method to the BaseGeoCollection class and test you
    code again. Remember that the order of the methods inside a class is irrelevant
    for the class’ behavior, but the best practices recommend you to put the magic
    methods first, then the private ones, and then the others. Your complete BaseGeoCollection
    class should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class BaseGeoCollection(object):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""This class represents a collection of spatial data."""'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, file_path=None):'
  prefs: []
  type: TYPE_NORMAL
- en: self.data = []
  prefs: []
  type: TYPE_NORMAL
- en: self.epsg = None
  prefs: []
  type: TYPE_NORMAL
- en: 'if file_path:'
  prefs: []
  type: TYPE_NORMAL
- en: self.import_data(file_path)
  prefs: []
  type: TYPE_NORMAL
- en: 'def __add__(self, other):'
  prefs: []
  type: TYPE_NORMAL
- en: self.data += other.data
  prefs: []
  type: TYPE_NORMAL
- en: return self
  prefs: []
  type: TYPE_NORMAL
- en: 'def _parse_data(self, features):'
  prefs: []
  type: TYPE_NORMAL
- en: raise NotImplementedError
  prefs: []
  type: TYPE_NORMAL
- en: 'def import_data(self, file_path):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Opens an vector file compatible with OGR and parses the data.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param str file_path: The full path to the file.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: features, metadata = open_vector_file(file_path)
  prefs: []
  type: TYPE_NORMAL
- en: self._parse_data(features)
  prefs: []
  type: TYPE_NORMAL
- en: self.epsg = metadata['epsg']
  prefs: []
  type: TYPE_NORMAL
- en: 'print("File imported: {}".format(file_path))'
  prefs: []
  type: TYPE_NORMAL
- en: 'def describe(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'print("SRS EPSG code: {}".format(self.epsg))'
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Number of features: {}".format(len(self.data))) def get_by_name(self,
    name):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Find an object by its name attribute and returns it."""'
  prefs: []
  type: TYPE_NORMAL
- en: 'for item in self.data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if item.get_attribute(''name'') == name:'
  prefs: []
  type: TYPE_NORMAL
- en: return item
  prefs: []
  type: TYPE_NORMAL
- en: raise LookupError(
  prefs: []
  type: TYPE_NORMAL
- en: '"Object not found with the name: {}".format(name)) Now, in the next step, we
    will search for the points that are within the boundary that we found. This time,
    we will create a method directly inside the BaseGeoCollection class, so it becomes
    available to the PointCollection and the BoundaryCollection classes through inheritance.
    By doing this, we will get a bonus feature—we are able to filter the boundaries
    by another boundary.'
  prefs: []
  type: TYPE_NORMAL
- en: '6\. Go to the BaseGeoCollection class and add the method filter_by_boundary:'
  prefs: []
  type: TYPE_NORMAL
- en: '#...'
  prefs: []
  type: TYPE_NORMAL
- en: 'def filter_by_boundary(self, boundary):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Filters the data by a given boundary"""'
  prefs: []
  type: TYPE_NORMAL
- en: result = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for item in self.data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if item.geom.within(boundary.geom):'
  prefs: []
  type: TYPE_NORMAL
- en: result.append(item)
  prefs: []
  type: TYPE_NORMAL
- en: return result
  prefs: []
  type: TYPE_NORMAL
- en: Here, we created a variable result containing a list to store the objects that
    passes the test. The within predicate is used to test every item if it is inside
    the boundary that is passed as an argument. In this case, if nothing is found,
    no exception is raised and an empty list is returned.
  prefs: []
  type: TYPE_NORMAL
- en: '7\. Edit the testing code in the if __name__ == ''__main__'': block: if __name__
    == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: gdal.PushErrorHandler('CPLQuietErrorHandler')
  prefs: []
  type: TYPE_NORMAL
- en: world = BoundaryCollection("../data/world_borders_simple.shp") geocaching_points
    = PointCollection("../data/geocaching.gpx") usa_boundary = world.get_by_name('United
    States')
  prefs: []
  type: TYPE_NORMAL
- en: 'result = geocaching_points.filter_by_boundary(usa_boundary) for item in result:'
  prefs: []
  type: TYPE_NORMAL
- en: print(item)
  prefs: []
  type: TYPE_NORMAL
- en: While testing, two instances are created, one from the BoundaryCollection class
    and one from the PointCollection class. The data files are passed as arguments.
    Then, the country of interest is found and stored in the usa_boundary variable.
    This variable is then passed to the filter_by_boundary method.
  prefs: []
  type: TYPE_NORMAL
- en: '8\. Run the code. You should see a long list of geocaches as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: -78.90175 42.89648 - LaSalle Park No 1
  prefs: []
  type: TYPE_NORMAL
- en: -78.89818 42.89293 - LaSalle Park No 2
  prefs: []
  type: TYPE_NORMAL
- en: -78.47808 43.02617 - A Unique Walk in Akron
  prefs: []
  type: TYPE_NORMAL
- en: -78.93865 42.95982 - A view of Strawberry Island
  prefs: []
  type: TYPE_NORMAL
- en: -78.90007 42.7484 - A View to a Windmill
  prefs: []
  type: TYPE_NORMAL
- en: -79.07533 43.08133 - A Virtual Made in the Mist
  prefs: []
  type: TYPE_NORMAL
- en: -74.43207 43.86942 - Adirondack Museum Guestbook…
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: As expected, it prints a list of Geocache objects whose representation given
    by the __repr__ method is their coordinates and names.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filtering by multiple attributes**'
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to search the geocaching points by their attributes. For example,
    we may want to filter the points by the author of the geocache, by the level of
    difficulty to find the geocache, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: We will borrow the techniques used in the methods that allowed us to get a GeoObject
    by its name property and the method that filtered by a polygon. The difference
    here is that we must allow the attribute that we want to filter by to be passed
    as a parameter, and we want to have the capability to combine multiple fields.
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Let’s start adding a simple filter method in the BaseGeoCollection class:'
  prefs: []
  type: TYPE_NORMAL
- en: '#...'
  prefs: []
  type: TYPE_NORMAL
- en: 'def filter(self, attribute, value):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Filters the collection by an attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param attribute: The name of the attribute to filter by.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param value: The filtering value.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: result = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for item in self.data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if item.get_attribute(attribute) == value:'
  prefs: []
  type: TYPE_NORMAL
- en: result.append(item)
  prefs: []
  type: TYPE_NORMAL
- en: return result
  prefs: []
  type: TYPE_NORMAL
- en: 'This method takes two arguments: the attribute name that we want to filter
    by and the value that this attribute needs to have to pass the filter. Different
    from get_by_name, this filtering function accumulates every object found into
    a list and returns this list.'
  prefs: []
  type: TYPE_NORMAL
- en: '2\. To test the filtering method, edit the if __name__ == ''__main__'': block.
    We will filter the geocache points whose level of difficulty is 1:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: gdal.PushErrorHandler('CPLQuietErrorHandler')
  prefs: []
  type: TYPE_NORMAL
- en: points = PointCollection("../data/geocaching.gpx") result = points.filter('difficulty',
    '1')
  prefs: []
  type: TYPE_NORMAL
- en: points.describe()
  prefs: []
  type: TYPE_NORMAL
- en: print("Found {} points".format(len(result)))
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Run the code. You should have this output:'
  prefs: []
  type: TYPE_NORMAL
- en: 'File imported: ../data/geocaching.gpx'
  prefs: []
  type: TYPE_NORMAL
- en: 'SRS EPSG code: 4326'
  prefs: []
  type: TYPE_NORMAL
- en: 'Number of features: 112'
  prefs: []
  type: TYPE_NORMAL
- en: Found 38 points
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: From a total of 112 points, 38 match our criteria.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chaining filters**'
  prefs: []
  type: TYPE_NORMAL
- en: This part deserves a topic because we are going to use a very handy Python technique
    that you will most certainly need more than once to solve your geoprocessing challenges.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we can apply a single filter that will return a list of objects. If
    we want to apply more than one filter, we can simply make the filter function
    return another collection object with the results, instead of returning a list.
    This way, we can make it possible to take the results from one filtering and filter
    them again, thus narrowing the results.
  prefs: []
  type: TYPE_NORMAL
- en: Besides being surprisingly simple, this solution is also very efficient in terms
    of processing, because at each filtering pass, the results are smaller and the
    number of iterations reduces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python allows function calls to be chained. This means that we don’t need to
    store each step into a variable. We can simply put each call one after another
    in a very elegant and intuitive pattern as exemplified here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'my_points = points.filter(''difficulty'', ''1'').filter(''status'', ''Available'')
    Note that this is an and condition. It will return the points that satisfy both
    the filters. But since we implemented the __add__ method to the BaseGeoCollection
    class, we can easily achieve an or type of filtering:'
  prefs: []
  type: TYPE_NORMAL
- en: my_points = points.filter('difficulty', '1') + points.filter('difficulty',
  prefs: []
  type: TYPE_NORMAL
- en: '''2'')'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Let’s make our method return a new instance to make this work. Edit the
    filter method in the BaseGeoCollection class:'
  prefs: []
  type: TYPE_NORMAL
- en: '#...'
  prefs: []
  type: TYPE_NORMAL
- en: 'def filter(self, attribute, value):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Filters the collection by an attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param attribute: The name of the attribute to filter by.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param value: The filtering value.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: result = self.__class__()
  prefs: []
  type: TYPE_NORMAL
- en: 'for item in self.data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if getattr(item, attribute) == value:'
  prefs: []
  type: TYPE_NORMAL
- en: result.data.append(item)
  prefs: []
  type: TYPE_NORMAL
- en: return result
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the result is an instance of the same class that originated the instance
    where the method was called, because __class__ is a property that contains the
    class that originated the instance. Since we are using inheritance, this ensures
    that we have the result in the same type and the data. Although this is a very
    simple solution, it works very well. Let’s try it:'
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Edit the if __name__ == ''__main__'': block, so we can filter the points
    that match the two conditions (the and condition):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: gdal.PushErrorHandler('CPLQuietErrorHandler') points = PointCollection("../data/geocaching.gpx")
    result = points.filter('difficulty', '1').filter('container',
  prefs: []
  type: TYPE_NORMAL
- en: '''Virtual'')'
  prefs: []
  type: TYPE_NORMAL
- en: points.describe()
  prefs: []
  type: TYPE_NORMAL
- en: result.describe()
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'File imported: ../data/geocaching.gpx'
  prefs: []
  type: TYPE_NORMAL
- en: 'SRS EPSG code: 4326'
  prefs: []
  type: TYPE_NORMAL
- en: 'Number of features: 112'
  prefs: []
  type: TYPE_NORMAL
- en: 'SRS EPSG code: None'
  prefs: []
  type: TYPE_NORMAL
- en: 'Number of features: 34'
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: From the previous test, we know that 38 points are of difficulty 1, now we got
    34
  prefs: []
  type: TYPE_NORMAL
- en: points because of those 38 points, four does not have a container = Virtual.
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Try another test this time using an or condition:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: gdal.PushErrorHandler('CPLQuietErrorHandler')
  prefs: []
  type: TYPE_NORMAL
- en: points = PointCollection("../data/geocaching.gpx") result = points.filter('difficulty',
    '1') + points.filter(
  prefs: []
  type: TYPE_NORMAL
- en: '''difficulty'', ''2'')'
  prefs: []
  type: TYPE_NORMAL
- en: points.describe()
  prefs: []
  type: TYPE_NORMAL
- en: result.describe()
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Run the code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'File imported: ../data/geocaching.gpx'
  prefs: []
  type: TYPE_NORMAL
- en: 'SRS EPSG code: 4326'
  prefs: []
  type: TYPE_NORMAL
- en: 'Number of features: 112'
  prefs: []
  type: TYPE_NORMAL
- en: 'SRS EPSG code: None'
  prefs: []
  type: TYPE_NORMAL
- en: 'Number of features: 50'
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: This time, these 38 points of difficulty 1 were combined with another 12 points
    of difficulty 2\.
  prefs: []
  type: TYPE_NORMAL
- en: '**Integrating with the app**'
  prefs: []
  type: TYPE_NORMAL
- en: As we continue to work with increasing levels of abstraction, think of our app’s
    organization. We have two types of data and we have the GeocachingApp class with
    high level functionality. At this point, what we want is to enable the app to
    filter like we did in the tests, but in a simple and straightforward way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the app as it is at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class GeocachingApp(PointCollection):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, data_file=None, my_location=None):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Application class.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param data_file: An OGR compatible file'
  prefs: []
  type: TYPE_NORMAL
- en: with geocaching points.
  prefs: []
  type: TYPE_NORMAL
- en: ':param my_location: Coordinates of your location.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: super(GeocachingApp, self).__init__(file_path=data_file)
  prefs: []
  type: TYPE_NORMAL
- en: self._datasource = None
  prefs: []
  type: TYPE_NORMAL
- en: self._transformed_geoms = None
  prefs: []
  type: TYPE_NORMAL
- en: self._my_location = None
  prefs: []
  type: TYPE_NORMAL
- en: self.distances = None
  prefs: []
  type: TYPE_NORMAL
- en: 'if my_location:'
  prefs: []
  type: TYPE_NORMAL
- en: self.my_location = my_location
  prefs: []
  type: TYPE_NORMAL
- en: '@property'
  prefs: []
  type: TYPE_NORMAL
- en: 'def my_location(self):'
  prefs: []
  type: TYPE_NORMAL
- en: return self._my_location
  prefs: []
  type: TYPE_NORMAL
- en: '@my_location.setter'
  prefs: []
  type: TYPE_NORMAL
- en: 'def my_location(self, coordinates):'
  prefs: []
  type: TYPE_NORMAL
- en: self._my_location = transform_points([coordinates])[0]
  prefs: []
  type: TYPE_NORMAL
- en: 'def calculate_distances(self):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Calculates the distance between a'
  prefs: []
  type: TYPE_NORMAL
- en: set of points and a given location.
  prefs: []
  type: TYPE_NORMAL
- en: ':return: A list of distances in the same order as'
  prefs: []
  type: TYPE_NORMAL
- en: the points.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: xa = self.my_location[0]
  prefs: []
  type: TYPE_NORMAL
- en: ya = self.my_location[1]
  prefs: []
  type: TYPE_NORMAL
- en: points = self._transformed_geoms
  prefs: []
  type: TYPE_NORMAL
- en: distances = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for geom in points:'
  prefs: []
  type: TYPE_NORMAL
- en: point_distance = math.sqrt(
  prefs: []
  type: TYPE_NORMAL
- en: (geom.GetX() - xa)**2 + (geom.GetY() - ya))
  prefs: []
  type: TYPE_NORMAL
- en: distances.append(point_distance)
  prefs: []
  type: TYPE_NORMAL
- en: return distances
  prefs: []
  type: TYPE_NORMAL
- en: 'def find_closest_point(self):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Find the closest point to a given location and'
  prefs: []
  type: TYPE_NORMAL
- en: return the cache that's on that point.
  prefs: []
  type: TYPE_NORMAL
- en: ':return: OGR feature containing the point.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: Part 1\.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: distances = self.calculate_distances()
  prefs: []
  type: TYPE_NORMAL
- en: index = np.argmin(distances)
  prefs: []
  type: TYPE_NORMAL
- en: Part 2\.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: layer = self._datasource.GetLayerByIndex(0)
  prefs: []
  type: TYPE_NORMAL
- en: feature = layer.GetFeature(index)
  prefs: []
  type: TYPE_NORMAL
- en: 'print "Closest point at: {}m".format(distances[index]) return feature'
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance was used to give the app the functionality contained in the PointCollection
    class. But this schema won’t work anymore because we now have two types of data.
    We have to remove the inheritance and make a different approach.
  prefs: []
  type: TYPE_NORMAL
- en: What we will do is store instances of the collection classes (PointCollection
    and BoundaryCollection), and implement the methods that will relate them in the
    same way it was done in the tests of the chaining filters topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the imports and the class’ definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Open your geocaching_app.py file and edit the imports section at the beginning
    of the file to include new classes:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import gdal
  prefs: []
  type: TYPE_NORMAL
- en: import numpy as np
  prefs: []
  type: TYPE_NORMAL
- en: import math
  prefs: []
  type: TYPE_NORMAL
- en: from utils.geo_functions import transform_points
  prefs: []
  type: TYPE_NORMAL
- en: from models import PointCollection, BoundaryCollection
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Now, edit the GeocachingApp class definition and the __init__ method to
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class GeocachingApp(object):'
  prefs: []
  type: TYPE_NORMAL
- en: def __init__(self,
  prefs: []
  type: TYPE_NORMAL
- en: geocaching_file=None,
  prefs: []
  type: TYPE_NORMAL
- en: boundary_file=None,
  prefs: []
  type: TYPE_NORMAL
- en: 'my_location=None):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Application class.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param geocaching_file: An OGR compatible file'
  prefs: []
  type: TYPE_NORMAL
- en: with geocaching points.
  prefs: []
  type: TYPE_NORMAL
- en: ':param boundary_file: A file with boundaries.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param my_location: Coordinates of your location.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: self.geocaching_data = PointCollection(geocaching_file)
  prefs: []
  type: TYPE_NORMAL
- en: self.boundaries = BoundaryCollection(boundary_file)
  prefs: []
  type: TYPE_NORMAL
- en: self._my_location = None
  prefs: []
  type: TYPE_NORMAL
- en: 'if my_location:'
  prefs: []
  type: TYPE_NORMAL
- en: self.my_location = my_location
  prefs: []
  type: TYPE_NORMAL
- en: The inheritance was removed and now the data is stored in the geocaching_data
    and
  prefs: []
  type: TYPE_NORMAL
- en: boundaries properties. Optionally, if the user passes a file with geocaching
    data or with boundary data to the GeocachingApp class, these same files are passed
    as an argument to the PointCollection and BoundaryCollection creations.
  prefs: []
  type: TYPE_NORMAL
- en: With what you have now, you can already do any type of filtering. You just need
    to access geocaching_data and boundaries and do exactly what we did before. Let’s
    try it.
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Go to the end of the file where there is a line with if __name__ == "__main__":
    and edit the code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == "__main__":'
  prefs: []
  type: TYPE_NORMAL
- en: my_app = GeocachingApp("../data/geocaching.gpx",
  prefs: []
  type: TYPE_NORMAL
- en: '"../data/world_borders_simple.shp")'
  prefs: []
  type: TYPE_NORMAL
- en: usa_boundary = my_app.boundaries.get_by_name('United States') result = my_app.geocaching_data.filter_by_boundary(
  prefs: []
  type: TYPE_NORMAL
- en: usa_boundary)
  prefs: []
  type: TYPE_NORMAL
- en: print(result)
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Now run it. Remember that whenever you want to run a different file, you
    need to press *Alt* + *Shift* + *F10* and choose the file in the popup. You should
    see the output with the list of geocaching points again.
  prefs: []
  type: TYPE_NORMAL
- en: But let’s suppose that there is a kind of filtering that is expected to be needed
    multiple times or, maybe, there is a filtering that you want to make explicit.
  prefs: []
  type: TYPE_NORMAL
- en: Following the same example, suppose that we are filtering by a country name
    in this case.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the GeocachingApp class, which stands in the highest level of abstraction
    in our code to implement this or any other high level filtering method.
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Add this method to the GeocachingApp class:'
  prefs: []
  type: TYPE_NORMAL
- en: '#...'
  prefs: []
  type: TYPE_NORMAL
- en: 'def filter_by_country(self, name):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Filter by a country with a given name.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param name: The name of the boundary (ex. county name)'
  prefs: []
  type: TYPE_NORMAL
- en: ':return: PointCollection'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: boundary = self.boundaries.get_by_name(name)
  prefs: []
  type: TYPE_NORMAL
- en: return self.geocaching_data.filter_by_boundary(boundary)
  prefs: []
  type: TYPE_NORMAL
- en: In computer programming, this is also called **convenience method**. It’s a
    method created for convenience in order to solve a more complex task or to avoid
    boilerplate code (that is, to avoid code repetition).
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we saw that the different types of relationships between geometries
    can be tested, and that these tests can be used in the program to solve problems.
  prefs: []
  type: TYPE_NORMAL
- en: In order to filter by polygons, first we used the same code to import these
    polygons into the system like we did with the points, but this time we used Shapely
    to abstract the geometries of the polygons and points. Finally, we used geometry
    relationships to search for points inside the polygons.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we implemented a way to filter the data by the name property and we made
    it filter the data by any property of the object or any combination of properties.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we adapted the app class to work with the new changes and saw that
    it’s possible to add convenience methods to it in order to simplify some tasks.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start working on the Map Maker App and create means
    to visualize our data.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter 5\. Making Maps**'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start a new application and use it to produce nice
    maps from vector data.
  prefs: []
  type: TYPE_NORMAL
- en: In order to produce these maps, we will use Mapnik, one of the world’s most
    used mapping packages. The objective is to understand how it works and adapt it
    to make an easy-to-use mapping application.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapters, we produced some very functional classes that abstract
    geographic data; we will make this app capable of consuming this type of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know Mapnik and see how it works
  prefs: []
  type: TYPE_NORMAL
- en: Seeing the differences between pure Python and XML when defining a map Experimenting
    with different styles
  prefs: []
  type: TYPE_NORMAL
- en: Using Python objects as a source of data for Mapnik
  prefs: []
  type: TYPE_NORMAL
- en: Abstracting Mapnik into a high-level application
  prefs: []
  type: TYPE_NORMAL
- en: '**Knowing Mapnik**'
  prefs: []
  type: TYPE_NORMAL
- en: Mapnik is the tool that we will use to produce our maps. It’s a very powerful
    mapping library used by many websites.
  prefs: []
  type: TYPE_NORMAL
- en: In this first topic, we will go through some experiments to get to know Mapnik’s
    features.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will perform a few experiments with Mapnik in order to know how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s organize the code for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Inside your geopy project, copy the Chapter4 folder and rename it to Chapter5\.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Inside the Chapter5 folder, create a new folder named mapnik_experiments.
    To do that, right-click in your Chapter5 folder and choose **New** | **Directory**.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Still in Chapter5, create another folder named output; we will place the
    maps and images we create into that folder.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making a map with pure Python**'
  prefs: []
  type: TYPE_NORMAL
- en: Mapnik has two ways to define a map; one uses pure Python code, the other an
    XML file.
  prefs: []
  type: TYPE_NORMAL
- en: Mapnik’s Python API is very extensive and wraps almost all of the package’s
    functionalities. In the next steps we will experiment with making a map with Python
    code only.
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Inside mapnik_experiments, create a Python file named mapnik_python.py.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Type the following code into mapnik_python.py:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import mapnik
  prefs: []
  type: TYPE_NORMAL
- en: Create a Map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: map = mapnik.Map(800, 600)
  prefs: []
  type: TYPE_NORMAL
- en: Set the background color of the map.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: map.background = mapnik.Color('white')
  prefs: []
  type: TYPE_NORMAL
- en: Create a Style and a Rule.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: style = mapnik.Style()
  prefs: []
  type: TYPE_NORMAL
- en: rule = mapnik.Rule()
  prefs: []
  type: TYPE_NORMAL
- en: Create a PolygonSymbolizer to fill the polygons and
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: add it to the rule.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: polygon_symbolizer = mapnik.PolygonSymbolizer(
  prefs: []
  type: TYPE_NORMAL
- en: mapnik.Color('#f2eff9'))
  prefs: []
  type: TYPE_NORMAL
- en: rule.symbols.append(polygon_symbolizer)
  prefs: []
  type: TYPE_NORMAL
- en: Create a LineSymbolizer to style the polygons borders and
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: add it to the rule.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: line_symbolizer = mapnik.LineSymbolizer(
  prefs: []
  type: TYPE_NORMAL
- en: mapnik.Color('rgb(50%,50%,50%)'), 0.1)
  prefs: []
  type: TYPE_NORMAL
- en: rule.symbols.append(line_symbolizer)
  prefs: []
  type: TYPE_NORMAL
- en: Add the rule to the style.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: style.rules.append(rule)
  prefs: []
  type: TYPE_NORMAL
- en: Add the Style to the Map.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: map.append_style('My Style', style)
  prefs: []
  type: TYPE_NORMAL
- en: Create a data source from a shapefile.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: data = mapnik.Shapefile(file='../../data/world_borders_simple.shp')
  prefs: []
  type: TYPE_NORMAL
- en: Create a layer giving it the name 'world'.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: layer = mapnik.Layer('world')
  prefs: []
  type: TYPE_NORMAL
- en: Set the layer data source and add the style to the layer.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: layer.datasource = data
  prefs: []
  type: TYPE_NORMAL
- en: layer.styles.append('My Style')
  prefs: []
  type: TYPE_NORMAL
- en: Add the layer to the map.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: map.layers.append(layer)
  prefs: []
  type: TYPE_NORMAL
- en: Zoom the map to the extent of all layers.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: map.zoom_all()
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 29](img/index-231_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Write the map to a image.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: mapnik.render_to_file(map,'../output/world.png', 'png')
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Now run the code; press *Alt* + *Shift* + *F10* and select mapnik_python.
  prefs: []
  type: TYPE_NORMAL
- en: '4\. There should be a new file named world.png inside your output folder. You
    can view this image in PyCharm; just double-click it. You should see this: Congratulations
    on creating this first beautiful map; note the superior quality of this rendering
    and how quickly Mapnik does its job.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Making a map with a style sheet**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using only Python code, the map styles, layers, and other definitions
    can be put inside an XML file. Let’s try this:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Inside the mapnik_experiments folder, create a new file named map_style.xml.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Type the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: <Map background-color="white">
  prefs: []
  type: TYPE_NORMAL
- en: <Style name="My Style">
  prefs: []
  type: TYPE_NORMAL
- en: <Rule>
  prefs: []
  type: TYPE_NORMAL
- en: <PolygonSymbolizer fill="#f2eff9" />
  prefs: []
  type: TYPE_NORMAL
- en: <LineSymbolizer stroke="rgb(50%,50%,50%)" stroke-width="0.1" />
  prefs: []
  type: TYPE_NORMAL
- en: </Rule>
  prefs: []
  type: TYPE_NORMAL
- en: </Style>
  prefs: []
  type: TYPE_NORMAL
- en: <Layer name="world">
  prefs: []
  type: TYPE_NORMAL
- en: <StyleName>My Style</StyleName>
  prefs: []
  type: TYPE_NORMAL
- en: <Datasource>
  prefs: []
  type: TYPE_NORMAL
- en: <Parameter name="file">
  prefs: []
  type: TYPE_NORMAL
- en: ../../data/world_borders_simple.shp
  prefs: []
  type: TYPE_NORMAL
- en: </Parameter>
  prefs: []
  type: TYPE_NORMAL
- en: <Parameter name="type">shape</Parameter>
  prefs: []
  type: TYPE_NORMAL
- en: </Datasource>
  prefs: []
  type: TYPE_NORMAL
- en: </Layer>
  prefs: []
  type: TYPE_NORMAL
- en: </Map>
  prefs: []
  type: TYPE_NORMAL
- en: This is the style definition of your map. Although PyCharm is a Python IDE,
    it’s also capable of recognizing a lot of file types including XML; it should
    help you with the tags and should apply a nice coloring to the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you need the Python code to generate this map:'
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Create a Python file named mapnik_xml.py inside the mapnik_experiments
    folder and type this code:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import mapnik
  prefs: []
  type: TYPE_NORMAL
- en: map = mapnik.Map(800, 600)
  prefs: []
  type: TYPE_NORMAL
- en: mapnik.load_map(map, 'map_style.xml')
  prefs: []
  type: TYPE_NORMAL
- en: map.zoom_all()
  prefs: []
  type: TYPE_NORMAL
- en: mapnik.render_to_file(map, '../output/world2.png')
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Run this file. Remember that, to run a different file from the previous
    one, you need to press *Alt* + *Shift* + *F10* and select it.
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Open the generated image (world2.png) that is inside the output folder;
    you should see exactly the same result as before.
  prefs: []
  type: TYPE_NORMAL
- en: Styling maps in Python and XML has almost the same features. Except for a few
    very specific situations, you can obtain exactly the same results using either
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In those simple examples, there are two things to be noticed while using Python
    or XML: code readability and organization. Looking at the XML code, you should
    see that the map, styles, and rules have a tree-like organization; this is very
    clear here but in the pure Python definition this get confusing and can lead to
    mistakes.'
  prefs: []
  type: TYPE_NORMAL
- en: This is a very simple map but, as you add more rules and symbolizers, things
    starts to get very confusing and hard to understand using pure Python.
  prefs: []
  type: TYPE_NORMAL
- en: Another important point is that it’s a good idea to separate the map creation
    logic from the style. We will see how that helps to keep your code very clean
    and reusable in the next topic.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating utility functions to generate**'
  prefs: []
  type: TYPE_NORMAL
- en: '**maps**'
  prefs: []
  type: TYPE_NORMAL
- en: Now we will create the first function that will compose our application.
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Still in the mapnik_experiments folder, create a new file: map_functions.py.'
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Insert the code as follows into that file:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import mapnik
  prefs: []
  type: TYPE_NORMAL
- en: 'def create_map(style_file, output_image, size=(800, 600)):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Creates a map from a XML file and writes it to an image.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param style_file: Mapnik XML file.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param output_image: Name of the output image file.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param size: Size of the map in pixels.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: map = mapnik.Map(*size)
  prefs: []
  type: TYPE_NORMAL
- en: mapnik.load_map(map, style_file)
  prefs: []
  type: TYPE_NORMAL
- en: map.zoom_all()
  prefs: []
  type: TYPE_NORMAL
- en: mapnik.render_to_file(map, output_image)
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: create_map('map_style.xml', '../output/world3.png',
  prefs: []
  type: TYPE_NORMAL
- en: size=(400, 400))
  prefs: []
  type: TYPE_NORMAL
- en: 'What we did here is pack the map generation code into a function that we can
    reuse in the future. It takes two required arguments: the XML style file and the
    name of the image file that Mapnik will write the results to.'
  prefs: []
  type: TYPE_NORMAL
- en: The third optional parameter is the size of the map that will be created; you
    can pass a list or a tuple with the width and height of the map in pixels. This
    tuple or list is then unpacked with the * symbol into mapnik.Map arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, again we used the if __name__ == ''__main__'': technique to test the
    code.'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that everything that is inside this if block is run only if the file
    is called directly. On the other hand, if this file is imported as a module, this
    code will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the *Creating the application entry point* section in [Chapter 2](index_split_000.html#p103),
    *The Geocaching* *App*, if you need more information on that technique.
  prefs: []
  type: TYPE_NORMAL
- en: '**Changing the data source at runtime**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a useful function; now we can create maps from XML files with a single
    line of code. But there is a flaw: the data source (the shapefile that will be
    used) is hardcoded inside the XML. Suppose that we want to generate maps for a
    bunch of shapefiles; for every file we would need to change the XML, impeding
    the execution of batch operations.'
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there are two ways that we can change the data source file that
    Mapnik will use without manually changing the XML. We can make code to edit the
    XML for us, or we can mix XML and Python in the map definition.
  prefs: []
  type: TYPE_NORMAL
- en: Mapnik’s Map object has a couple of properties that can be accessed. At the
    moment, we are interested in accessing the layer, because the layer contains the
    data source that we want to define or change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every Map instance contains a layers property that returns a Layers object
    containing all the layers defined in the map. This object behaves like a list
    of Layer objects in which its items could be iterated or retrieved by an index.
    In turn, the Layer object contains the name and the data source properties. Let’s
    take a look how this works: **Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the Mapnik API documentation at: [http://mapnik.org/docs/v2.2.0/api/python/.](http://mapnik.org/docs/v2.2.0/api/python/)'
  prefs: []
  type: TYPE_NORMAL
- en: There you can find all the classes, methods, and properties that are available.
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Change your function so we can inspect the properties of the map object:
    def create_map(style_file, output_image, size=(800, 600)):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Creates a map from a XML file and writes it to an image.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param style_file: Mapnik XML file.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param output_image: Name of the output image file.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param size: Size of the map in pixels.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: map = mapnik.Map(*size)
  prefs: []
  type: TYPE_NORMAL
- en: mapnik.load_map(map, style_file)
  prefs: []
  type: TYPE_NORMAL
- en: '**layers = map.layers**'
  prefs: []
  type: TYPE_NORMAL
- en: '**layer = layers[0]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**print(layer)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**print(layer.name)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**print(layer.datasource)**'
  prefs: []
  type: TYPE_NORMAL
- en: map.zoom_all()
  prefs: []
  type: TYPE_NORMAL
- en: mapnik.render_to_file(map, output_image)
  prefs: []
  type: TYPE_NORMAL
- en: The highlighted code gets the layers object and the first layer in it (at index
    0), then prints it, its name, and the data source properties.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Just rerun the code and you should get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: <mapnik._mapnik.Layer object at 0x01E579F0>
  prefs: []
  type: TYPE_NORMAL
- en: world
  prefs: []
  type: TYPE_NORMAL
- en: <mapnik.Datasource object at 0x01F3E9F0>
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: As you see in the output, the first layer is the world layer defined in the
    XML and it has a data source. This data source is what we want to set or modify
    during code execution.
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Make another test. Open the map_style.xml file and remove the data source
    from the definition, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: <Map background-color="white">
  prefs: []
  type: TYPE_NORMAL
- en: <Style name="My Style">
  prefs: []
  type: TYPE_NORMAL
- en: <Rule>
  prefs: []
  type: TYPE_NORMAL
- en: <PolygonSymbolizer fill="#f2eff9" />
  prefs: []
  type: TYPE_NORMAL
- en: <LineSymbolizer stroke="rgb(50%,50%,50%)" stroke-width="0.1" />
  prefs: []
  type: TYPE_NORMAL
- en: </Rule>
  prefs: []
  type: TYPE_NORMAL
- en: </Style>
  prefs: []
  type: TYPE_NORMAL
- en: <Layer name="world">
  prefs: []
  type: TYPE_NORMAL
- en: <StyleName>My Style</StyleName>
  prefs: []
  type: TYPE_NORMAL
- en: </Layer>
  prefs: []
  type: TYPE_NORMAL
- en: </Map>
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Run the code again and see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: <mapnik._mapnik.Layer object at 0x01DD79F0>
  prefs: []
  type: TYPE_NORMAL
- en: world
  prefs: []
  type: TYPE_NORMAL
- en: None
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: Now, when we print the data source property, it shows None because we removed
    it from the definition; also the image (world3.png) is empty because there is
    no data to display. Now we are going to define it in the Python code.
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Edit the map_functions.py file:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import mapnik
  prefs: []
  type: TYPE_NORMAL
- en: 'def create_map(shapefile, style_file, output_image, size=(800, 600)):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Creates a map from a XML file and writes it to an image.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param shapefile: Shapefile containing the data for the map.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param style_file: Mapnik XML file.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param output_image: Name of the output image file.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param size: Size of the map in pixels.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: map = mapnik.Map(*size)
  prefs: []
  type: TYPE_NORMAL
- en: mapnik.load_map(map, style_file)
  prefs: []
  type: TYPE_NORMAL
- en: data source = mapnik.Shapefile(file=shapefile)
  prefs: []
  type: TYPE_NORMAL
- en: layers = map.layers
  prefs: []
  type: TYPE_NORMAL
- en: layer = layers[0]
  prefs: []
  type: TYPE_NORMAL
- en: layer.datasource = data source
  prefs: []
  type: TYPE_NORMAL
- en: map.zoom_all()
  prefs: []
  type: TYPE_NORMAL
- en: mapnik.render_to_file(map, output_image)
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: create_map('../../data/world_borders_simple.shp',
  prefs: []
  type: TYPE_NORMAL
- en: '''map_style.xml'', ''../output/world3.png'','
  prefs: []
  type: TYPE_NORMAL
- en: size=(400, 400))
  prefs: []
  type: TYPE_NORMAL
- en: The new required argument in the function is the name of the shapefile containing
    the data. In the code we create a Mapnik data source from this file, get the first
    layer, and set its data source to the one that was created. Run the code and look
    at the output, you should see the rendered world map. Besides setting the data
    source, it is possible to combine XML and Python to change the map definition
    any way you want.
  prefs: []
  type: TYPE_NORMAL
- en: '**Automatically previewing the map**'
  prefs: []
  type: TYPE_NORMAL
- en: As we start to play with the map style, it could get a little boring to manually
    open the image every time we want to see the results. So we will write a function
    that will automatically open and display the image for us when we run the code.
    To do that we will use the **Open Computer Vision** (**OpenCV**) package.
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Import the package at the beginning of the map_functions.py file: import
    mapnik'
  prefs: []
  type: TYPE_NORMAL
- en: import cv2
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Create this new function before the create_map function: def display_map(image_file):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Opens and displays a map image file.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param image_file: Path to the image.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: image = cv2.imread(image_file)
  prefs: []
  type: TYPE_NORMAL
- en: cv2.imshow('image', image)
  prefs: []
  type: TYPE_NORMAL
- en: cv2.waitKey(0)
  prefs: []
  type: TYPE_NORMAL
- en: cv2.destroyAllWindows()
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Now change our tests to call the function; to do that, edit the if __name__
    ==
  prefs: []
  type: TYPE_NORMAL
- en: '''__main__'': block:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: map_image = '../output/world3.png'
  prefs: []
  type: TYPE_NORMAL
- en: create_map('../../data/world_borders_simple.shp',
  prefs: []
  type: TYPE_NORMAL
- en: '''map_style.xml'',map_image, size=(400, 400))'
  prefs: []
  type: TYPE_NORMAL
- en: display_map(map_image)
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Run the code. Now you should see a window pop up with the map image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 30](img/index-240_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We won’t explore OpenCV functionality in depth now; just note that cv2.waitKey(0)
    halts code execution until any key is pressed or the window is closed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Styling maps**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a function to generate the map and an easy way to preview
    them, we will experiment with the style options:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. First, lets produce a bigger map so we can better see the changes. Edit
    the if __name__ == ''__main__'': block at the end of the map_functions.py file,
    changing the size argument of the create_map function call:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: map_image = '../output/world3.png'
  prefs: []
  type: TYPE_NORMAL
- en: create_map('../../data/world_borders_simple.shp',
  prefs: []
  type: TYPE_NORMAL
- en: '''map_style.xml'',map_image, size=(1024, 500))'
  prefs: []
  type: TYPE_NORMAL
- en: display_map(map_image)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 31](img/index-243_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Map style**'
  prefs: []
  type: TYPE_NORMAL
- en: The map is the canvas for the drawing; it is possible to change the background
    color or the background image, the coordinate reference system, and a few other
    options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try changing the background:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. In the file map_style.xml edit the map tag to change the background color.
    You can use a hexadecimal value, a color name, or an RGB combination. Try this
    as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: <Map background-color="#f8be78">
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Run the code and see the changes.
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Now try using an image as the background for the map. I provided one as
    an example that will resemble old paper; change the map tag again:'
  prefs: []
  type: TYPE_NORMAL
- en: <Map background-color="#f8be78"
  prefs: []
  type: TYPE_NORMAL
- en: 'background-image="../../data/images/old-paper.png"> 4\. Run the code, you should
    see this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Note that background-image supersedes background-color in order of importance
    when the map is generated.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 32](img/index-244_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Polygon style**'
  prefs: []
  type: TYPE_NORMAL
- en: In the XML tree that you have in your map_style.xml file, you should notice
    that, after the <Map> tag, you have the <Style> tag and then the <Rule> tag. We
    will explore them later; for now we will go directly to the symbolizers.
  prefs: []
  type: TYPE_NORMAL
- en: Each symbolizer is used to style a different type of geometry or part of the
    map. The first one that we used is the PolygonSymbolizer tag, which is used to
    style the internal area of the polygon with a solid color.
  prefs: []
  type: TYPE_NORMAL
- en: 'The polygon has also another possible symbolizer: the PolygonPatternSymbolizer
    tag, which fills the polygon with an image pattern. Let’s see how it works: 1\.
    Change the style again; let’s include a pattern symbolizer after the PolygonSymbolizer
    tag:'
  prefs: []
  type: TYPE_NORMAL
- en: <Map background-color="#f8be78"
  prefs: []
  type: TYPE_NORMAL
- en: background-image="../../data/images/old-paper.png">
  prefs: []
  type: TYPE_NORMAL
- en: <Style name="My Style">
  prefs: []
  type: TYPE_NORMAL
- en: <Rule>
  prefs: []
  type: TYPE_NORMAL
- en: <PolygonSymbolizer fill="#f2eff9" />
  prefs: []
  type: TYPE_NORMAL
- en: <PolygonPatternSymbolizer
  prefs: []
  type: TYPE_NORMAL
- en: file="../../data/images/tree_pattern.png"/>
  prefs: []
  type: TYPE_NORMAL
- en: <LineSymbolizer stroke="rgb(50%,50%,50%)" stroke-width="0.1" />
  prefs: []
  type: TYPE_NORMAL
- en: </Rule>
  prefs: []
  type: TYPE_NORMAL
- en: </Style>
  prefs: []
  type: TYPE_NORMAL
- en: <Layer name="world">
  prefs: []
  type: TYPE_NORMAL
- en: <StyleName>My Style</StyleName>
  prefs: []
  type: TYPE_NORMAL
- en: </Layer>
  prefs: []
  type: TYPE_NORMAL
- en: </Map>
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Run the code and see the results.
  prefs: []
  type: TYPE_NORMAL
- en: The style follows the **painter model**. This means that things are *painted*
    in the order that they are in the file, so the pattern was painted over the polygon
    fill.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 33](img/index-246_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Line styles**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The lines (including polygon boundaries) are styled by the LineSymbolizer tag
    and the LinePatternSymbolizer tag. For the next examples, we will return the map
    to its initial style and zoom it so we can see better how the options influence
    the generated map, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Edit the style by removing the background image and the polygon pattern.
    Also, zoom in by changing maximum-extent:'
  prefs: []
  type: TYPE_NORMAL
- en: <Map background-color="white" maximum-extent="-21,68,66,28">
  prefs: []
  type: TYPE_NORMAL
- en: <Style name="My Style">
  prefs: []
  type: TYPE_NORMAL
- en: <Rule>
  prefs: []
  type: TYPE_NORMAL
- en: <PolygonSymbolizer fill="#f2eff9" />
  prefs: []
  type: TYPE_NORMAL
- en: <LineSymbolizer stroke="rgb(50%,50%,50%)" stroke-width="0.1" />
  prefs: []
  type: TYPE_NORMAL
- en: </Rule>
  prefs: []
  type: TYPE_NORMAL
- en: </Style>
  prefs: []
  type: TYPE_NORMAL
- en: <Layer name="world">
  prefs: []
  type: TYPE_NORMAL
- en: <StyleName>My Style</StyleName>
  prefs: []
  type: TYPE_NORMAL
- en: </Layer>
  prefs: []
  type: TYPE_NORMAL
- en: </Map>
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Now change the LineSymbolizer tag:'
  prefs: []
  type: TYPE_NORMAL
- en: <LineSymbolizer stroke="red" stroke-width="3.0" /> 3\. Run the code and see
    how the lines got thicker and red.
  prefs: []
  type: TYPE_NORMAL
- en: You may notice some strange edges and points because it’s a low-resolution map
    of the world and the lines are too thick. We can improve this map by reducing
    the thickness and by using the smooth parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Edit the LineSymbolizer tag again and run the code. Now you should have
    a much clearer map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 34](img/index-247_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <LineSymbolizer stroke="red" stroke-width="1.0" smooth="0.5" />
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 35](img/index-248_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Text styles**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s add the country names to our map. To do that, we will use the TextSymbolizer
    tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Change the map_style.xml file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: <Map background-color="white" maximum-extent="-21,68,66,28">
  prefs: []
  type: TYPE_NORMAL
- en: <Style name="My Style">
  prefs: []
  type: TYPE_NORMAL
- en: <Rule>
  prefs: []
  type: TYPE_NORMAL
- en: <PolygonSymbolizer fill="#f2eff9" />
  prefs: []
  type: TYPE_NORMAL
- en: <LineSymbolizer stroke="red" stroke-width="1.0" smooth="0.5" />
  prefs: []
  type: TYPE_NORMAL
- en: <TextSymbolizer face-name="DejaVu Sans Book" size="10"
  prefs: []
  type: TYPE_NORMAL
- en: fill="black" halo-fill= "white"
  prefs: []
  type: TYPE_NORMAL
- en: halo-radius="1" placement="interior"
  prefs: []
  type: TYPE_NORMAL
- en: allow-overlap="false">[NAME]
  prefs: []
  type: TYPE_NORMAL
- en: </TextSymbolizer>
  prefs: []
  type: TYPE_NORMAL
- en: </Rule>
  prefs: []
  type: TYPE_NORMAL
- en: </Style>
  prefs: []
  type: TYPE_NORMAL
- en: <Layer name="world">
  prefs: []
  type: TYPE_NORMAL
- en: <StyleName>My Style</StyleName>
  prefs: []
  type: TYPE_NORMAL
- en: </Layer>
  prefs: []
  type: TYPE_NORMAL
- en: </Map>
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Run the code and see the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adding layers to the map**'
  prefs: []
  type: TYPE_NORMAL
- en: We saw that it’s possible to change the data source of the map with Python.
    In a Mapnik map, the data source resides inside a layer or inside the map; to
    keep it simple we will use only layers to hold the data sources.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to add more than one data source (for example, points, lines, polygons,
    or images) we need to add more layers. As an example, we will add the geocaching
    points, which we saw in the previous chapters, to the map.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to completely remove the layer definition from the XML file.
    This will complete the separation of the code into two categories: the XML contains
    only the styling and the Python code handles the data and map creation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Secondly, we will change the create_map function so it adds layers to the map.
    This change will only be an experiment before we fully implement this functionality
    on the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. In the mapnik_xml.xml file, remove the layer from the definition, change
    the style name to style1, and add a new style for the points. Also change the
    extent of the map to focus on the points. It should be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: <Map background-color="white" maximum-extent="-81,45,-69,40">
  prefs: []
  type: TYPE_NORMAL
- en: <Style name="style1">
  prefs: []
  type: TYPE_NORMAL
- en: <Rule>
  prefs: []
  type: TYPE_NORMAL
- en: <PolygonSymbolizer fill="#f2eff9" />
  prefs: []
  type: TYPE_NORMAL
- en: <LineSymbolizer stroke="red" stroke-width="1.0" smooth="0.5" />
  prefs: []
  type: TYPE_NORMAL
- en: <TextSymbolizer face-name="DejaVu Sans Book" size="10"
  prefs: []
  type: TYPE_NORMAL
- en: fill="black" halo-fill= "white"
  prefs: []
  type: TYPE_NORMAL
- en: halo-radius="1" placement="interior"
  prefs: []
  type: TYPE_NORMAL
- en: allow-overlap="false">[NAME]
  prefs: []
  type: TYPE_NORMAL
- en: </TextSymbolizer>
  prefs: []
  type: TYPE_NORMAL
- en: </Rule>
  prefs: []
  type: TYPE_NORMAL
- en: </Style>
  prefs: []
  type: TYPE_NORMAL
- en: <Style name="style2">
  prefs: []
  type: TYPE_NORMAL
- en: <Rule>
  prefs: []
  type: TYPE_NORMAL
- en: <PointSymbolizer/>
  prefs: []
  type: TYPE_NORMAL
- en: </Rule>
  prefs: []
  type: TYPE_NORMAL
- en: </Style>
  prefs: []
  type: TYPE_NORMAL
- en: </Map>
  prefs: []
  type: TYPE_NORMAL
- en: '2\. In the map_functions.py file, change your create_map function and the if
    __name__ == ''__main__'': block. The complete code should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import mapnik
  prefs: []
  type: TYPE_NORMAL
- en: import cv2
  prefs: []
  type: TYPE_NORMAL
- en: 'def display_map(image_file):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Opens and displays a map image file.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param image_file: Path to the image.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: image = cv2.imread(image_file)
  prefs: []
  type: TYPE_NORMAL
- en: cv2.imshow('image', image)
  prefs: []
  type: TYPE_NORMAL
- en: cv2.waitKey(0)
  prefs: []
  type: TYPE_NORMAL
- en: cv2.destroyAllWindows()
  prefs: []
  type: TYPE_NORMAL
- en: 'def create_map(shapefile, gpx_file, style_file, output_image, size=(800, 600)):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Creates a map from a XML file and writes it to an image.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param shapefile: Shapefile containing the data for the map.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param style_file: Mapnik XML file.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param output_image: Name of the output image file.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param size: Size of the map in pixels.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: map = mapnik.Map(*size)
  prefs: []
  type: TYPE_NORMAL
- en: mapnik.load_map(map, style_file)
  prefs: []
  type: TYPE_NORMAL
- en: layers = map.layers
  prefs: []
  type: TYPE_NORMAL
- en: Add the shapefile.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: world_datasource = mapnik.Shapefile(file=shapefile)
  prefs: []
  type: TYPE_NORMAL
- en: world_layer = mapnik.Layer('world')
  prefs: []
  type: TYPE_NORMAL
- en: world_layer.datasource = world_datasource
  prefs: []
  type: TYPE_NORMAL
- en: world_layer.styles.append('style1')
  prefs: []
  type: TYPE_NORMAL
- en: layers.append(world_layer)
  prefs: []
  type: TYPE_NORMAL
- en: Add the shapefile.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: points_datasource = mapnik.Ogr(file=gpx_file, layer='waypoints') points_layer
    = mapnik.Layer('geocaching_points')
  prefs: []
  type: TYPE_NORMAL
- en: points_layer.datasource = points_datasource
  prefs: []
  type: TYPE_NORMAL
- en: points_layer.styles.append('style2')
  prefs: []
  type: TYPE_NORMAL
- en: layers.append(points_layer)
  prefs: []
  type: TYPE_NORMAL
- en: map.zoom_all()
  prefs: []
  type: TYPE_NORMAL
- en: mapnik.render_to_file(map, output_image)
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: map_image = '../output/world3.png'
  prefs: []
  type: TYPE_NORMAL
- en: create_map('../../data/world_borders_simple.shp',
  prefs: []
  type: TYPE_NORMAL
- en: '''../../data/geocaching.gpx'','
  prefs: []
  type: TYPE_NORMAL
- en: '''map_style.xml'',map_image, size=(1024, 500))'
  prefs: []
  type: TYPE_NORMAL
- en: display_map(map_image)
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the function accepts two files: one shapefile with the world borders and
    one GPX file containing waypoints. For each file, a data source and a layer containing
    it are created and added to the map list of layers. We also define the styles
    for the layer using the style names defined in the XML.'
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Run the code; you should see the points rendered over the world borders
    with the default PointSymbolizer style:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 36](img/index-251_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Point styles**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are going to improve the visual representation of the points: 1\. Edit
    the map_style.xml file and change the point style:'
  prefs: []
  type: TYPE_NORMAL
- en: <Map background-color="white" maximum-extent="-81,45,-69,40">
  prefs: []
  type: TYPE_NORMAL
- en: <Style name="style1">
  prefs: []
  type: TYPE_NORMAL
- en: <Rule>
  prefs: []
  type: TYPE_NORMAL
- en: <PolygonSymbolizer fill="#f2eff9" />
  prefs: []
  type: TYPE_NORMAL
- en: <LineSymbolizer stroke="red" stroke-width="1.0" smooth="0.5" />
  prefs: []
  type: TYPE_NORMAL
- en: <TextSymbolizer face-name="DejaVu Sans Book" size="10"
  prefs: []
  type: TYPE_NORMAL
- en: fill="black" halo-fill= "white"
  prefs: []
  type: TYPE_NORMAL
- en: halo-radius="1" placement="interior"
  prefs: []
  type: TYPE_NORMAL
- en: allow-overlap="false">[NAME]
  prefs: []
  type: TYPE_NORMAL
- en: </TextSymbolizer>
  prefs: []
  type: TYPE_NORMAL
- en: </Rule>
  prefs: []
  type: TYPE_NORMAL
- en: </Style>
  prefs: []
  type: TYPE_NORMAL
- en: <Style name="style2">
  prefs: []
  type: TYPE_NORMAL
- en: <Rule>
  prefs: []
  type: TYPE_NORMAL
- en: <PointSymbolizer file="../../data/images/marker.svg"
  prefs: []
  type: TYPE_NORMAL
- en: transform="scale(0.3)"/>
  prefs: []
  type: TYPE_NORMAL
- en: </Rule>
  prefs: []
  type: TYPE_NORMAL
- en: </Style>
  prefs: []
  type: TYPE_NORMAL
- en: </Map>
  prefs: []
  type: TYPE_NORMAL
- en: We introduce the use of a **Scalable Vector Graphics** (**SVG**) file to represent
    the point; the advantage of this kind of file is that it can be scaled or zoomed
    without distortions because it is composed of vectors and not pixels.
  prefs: []
  type: TYPE_NORMAL
- en: Since the SVG that we used is too big for our map, it was used with the transform
    parameter to scale the image.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: You can find more about SVG transformations at
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.w3.org/TR/SVG/coords.html.](http://www.w3.org/TR/SVG/coords.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Run your code and take a look at the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 37](img/index-253_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: If you need symbols for your projects, you can find a good collection in the
    **Noun** **Project**, which aggregates creations from the community around the
    world at
  prefs: []
  type: TYPE_NORMAL
- en: '[https://thenounproject.com/.](https://thenounproject.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: We have a beautiful representation of the points, and now we are going to add
    more information on them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Python objects as a source of data**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs: []
  type: TYPE_NORMAL
- en: Mapnik for Windows does not come with the Python Datasource plugin and a workaround
    will be provided for Windows users; just follow the steps.
  prefs: []
  type: TYPE_NORMAL
- en: Data is represented internally on Mapnik by a Datasource object. This object
    is responsible for accessing the source of the data (for example, a file containing
    the data, a database, and so on) and transforming the features provided by this
    source of data into Feature objects. In turn, the Feature object contains a geometry
    and a number of properties (attributes). This organization is very similar to
    what we have seen in [Chapter 4](#p174), *Improving the App Search Capabilities*,
    in the topic *How geographic data is represented*.
  prefs: []
  type: TYPE_NORMAL
- en: If we could hack into a Datasource and provide the features the way we want,
    we would be able to make Mapnik use Python objects that we provide as a source
    of data.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of using a Python object as a Datasource, instead of a file for
    example, is that we can perform any kind of transformation and analysis on the
    data and then feed it to Mapnik without needing to save it to disk. By doing that,
    we keep the data in memory, increase the performance of the application, and make
    it more versatile and easy-to-use.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Mapnik comes with a class already prepared for this kind of operation;
    as you may have guessed, it’s called PythonDatasource.
  prefs: []
  type: TYPE_NORMAL
- en: As we prepare to build our application, in this step we will produce a class
    that inherits from mapnik.PythonDatasource and implements the required methods
    for it to work.
  prefs: []
  type: TYPE_NORMAL
- en: First, we are going to take a look at Mapnik’s source code in order to understand
    the logic behind the PythonDatasource class.
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Go to your Chapter5 folder and create a file named my_datasource.py.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Insert this code in that file:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import mapnik
  prefs: []
  type: TYPE_NORMAL
- en: test_datasource = mapnik.PythonDatasource()
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Now click anywhere on PythonDatasource to place your cursor on it and press
    *Ctrl*
  prefs: []
  type: TYPE_NORMAL
- en: + *B*. Or, right-click anywhere on PythonDatasource then select **Go To** |
    **Declaration**.
  prefs: []
  type: TYPE_NORMAL
- en: This will open and show the class declaration for you.
  prefs: []
  type: TYPE_NORMAL
- en: '4\. I will go through each part of the class, commenting the code. Don’t worry
    if you are not near a computer. I’ll place excerpts of the class before each explanation:
    class PythonDatasource(object):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""A base class for a Python data source.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Optional arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: envelope—a mapnik.Box2d (minx, miny, maxx, maxy) envelope
  prefs: []
  type: TYPE_NORMAL
- en: of the data source, default (-180,-90,180,90)
  prefs: []
  type: TYPE_NORMAL
- en: geometry_type—one of the DataGeometryType enumeration values, default Point
  prefs: []
  type: TYPE_NORMAL
- en: data_type—one of the DataType enumerations, default Vector
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: def __init__(self, envelope=None, geometry_type=None,
  prefs: []
  type: TYPE_NORMAL
- en: 'data_type=None):'
  prefs: []
  type: TYPE_NORMAL
- en: self.envelope = envelope or Box2d(-180, -90, 180, 90)
  prefs: []
  type: TYPE_NORMAL
- en: self.geometry_type = geometry_type or DataGeometryType.Point self.data_type
    = data_type or DataType.Vector
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the class declaration and the __init__ method; the arguments to create
    the class are all optional but if we need to we can define the envelope (that
    is, the bounding box) and two important parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'geometry_type: Can be Collection, LineString, Point, or Polygon data_type:
    Can be Vector or Raster'
  prefs: []
  type: TYPE_NORMAL
- en: 'def features(self, query):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Return an iterable which yields instances of Feature for features within
    the passed query.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Required arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: query—a Query instance specifying the region for which
  prefs: []
  type: TYPE_NORMAL
- en: features should be returned
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: return None
  prefs: []
  type: TYPE_NORMAL
- en: This is the key method for PythonDatasource to work. This method should return
    an *iterable* containing the features.
  prefs: []
  type: TYPE_NORMAL
- en: An iterable is any Python object that can be used in a for loop or, as described
    in the Python glossary, any object capable of returning its members one at a time.
    It can be a list, a tuple, a dictionary, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite the description in the docstring, this method is empty and returns
    None. It’s an indication that it should be implemented on the child classes and
    that how this iterable is created is entirely up to the programmer:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the Python glossary for information on new terms or terms that
    are still confusing for you: [https://docs.python.org/2/glossary.html.](https://docs.python.org/2/glossary.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'def features_at_point(self, point):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Rarely uses. Return an iterable which yields instances of Feature for the
    specified point."""'
  prefs: []
  type: TYPE_NORMAL
- en: return None
  prefs: []
  type: TYPE_NORMAL
- en: This is more of a convenience method, so we won’t use it.
  prefs: []
  type: TYPE_NORMAL
- en: '@classmethod'
  prefs: []
  type: TYPE_NORMAL
- en: 'def wkb_features(cls, keys, features):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""A convenience function to wrap an iterator yielding pairs'
  prefs: []
  type: TYPE_NORMAL
- en: of WKB format geometry and dictionaries of key-value pairs into mapnik features.
    Return this from
  prefs: []
  type: TYPE_NORMAL
- en: PythonDatasource.features() passing it a sequence of keys
  prefs: []
  type: TYPE_NORMAL
- en: to appear in the output and an iterator yielding features.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example. One might have a features() method in a derived class like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def features(self, query):'
  prefs: []
  type: TYPE_NORMAL
- en: '... create WKB features feat1 and feat2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: return mapnik.PythonDatasource.wkb_features(
  prefs: []
  type: TYPE_NORMAL
- en: keys = ( 'name', 'author' ),
  prefs: []
  type: TYPE_NORMAL
- en: features = [
  prefs: []
  type: TYPE_NORMAL
- en: '(feat1, { ''name'': ''feat1'', ''author'': ''alice'' }),'
  prefs: []
  type: TYPE_NORMAL
- en: '(feat2, { ''name'': ''feat2'', ''author'': ''bob'' }),'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: ctx = Context()
  prefs: []
  type: TYPE_NORMAL
- en: '[ctx.push(x) for x in keys]'
  prefs: []
  type: TYPE_NORMAL
- en: 'def make_it(feat, idx):'
  prefs: []
  type: TYPE_NORMAL
- en: f = Feature(ctx, idx)
  prefs: []
  type: TYPE_NORMAL
- en: geom, attrs = feat
  prefs: []
  type: TYPE_NORMAL
- en: f.add_geometries_from_wkb(geom)
  prefs: []
  type: TYPE_NORMAL
- en: 'for k, v in attrs.iteritems():'
  prefs: []
  type: TYPE_NORMAL
- en: f[k] = v
  prefs: []
  type: TYPE_NORMAL
- en: return f
  prefs: []
  type: TYPE_NORMAL
- en: return itertools.imap(make_it, features, itertools.count(1))
  prefs: []
  type: TYPE_NORMAL
- en: '@classmethod'
  prefs: []
  type: TYPE_NORMAL
- en: 'def wkt_features(cls, keys, features):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""A convenience function to wrap an iterator yielding pairs of WKT format
    geometry and dictionaries of key-value pairs'
  prefs: []
  type: TYPE_NORMAL
- en: into mapnik features. Return this from
  prefs: []
  type: TYPE_NORMAL
- en: PythonDatasource.features() passing it a sequence of keys
  prefs: []
  type: TYPE_NORMAL
- en: to appear in the output and an iterator yielding features.
  prefs: []
  type: TYPE_NORMAL
- en: For example. One might have a features() method in a
  prefs: []
  type: TYPE_NORMAL
- en: 'derived class like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def features(self, query):'
  prefs: []
  type: TYPE_NORMAL
- en: '... create WKT features feat1 and feat2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: return mapnik.PythonDatasource.wkt_features(
  prefs: []
  type: TYPE_NORMAL
- en: keys = ( 'name', 'author' ),
  prefs: []
  type: TYPE_NORMAL
- en: features = [
  prefs: []
  type: TYPE_NORMAL
- en: '(feat1, { ''name'': ''feat1'', ''author'': ''alice'' }),'
  prefs: []
  type: TYPE_NORMAL
- en: '(feat2, { ''name'': ''feat2'', ''author'': ''bob'' }),'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: ctx = Context()
  prefs: []
  type: TYPE_NORMAL
- en: '[ctx.push(x) for x in keys]'
  prefs: []
  type: TYPE_NORMAL
- en: 'def make_it(feat, idx):'
  prefs: []
  type: TYPE_NORMAL
- en: f = Feature(ctx, idx)
  prefs: []
  type: TYPE_NORMAL
- en: geom, attrs = feat
  prefs: []
  type: TYPE_NORMAL
- en: f.add_geometries_from_wkt(geom)
  prefs: []
  type: TYPE_NORMAL
- en: 'for k, v in attrs.iteritems():'
  prefs: []
  type: TYPE_NORMAL
- en: f[k] = v
  prefs: []
  type: TYPE_NORMAL
- en: return f
  prefs: []
  type: TYPE_NORMAL
- en: return itertools.imap(make_it, features, itertools.count(1)) These are two convenience
    functions (or methods). Take a look at the section *Integrating* *with the app*
    in [Chapter 4,](#p174) *Improving the App Search Capabilities*, if you don’t remember
    what a convenience method is. We created one there.
  prefs: []
  type: TYPE_NORMAL
- en: Those methods are an easy shortcut to creating an iterable of Mapnik features
    from a list of lists (or tuples) containing the geometries and the attributes
    in a dictionary, one from WKT geometries and one from WKB geometries (again, if
    you need, take a look at the section *Knowing well-known text* in [Chapter 4](#p174),
    *Improving the App Search Capabilities*).
  prefs: []
  type: TYPE_NORMAL
- en: One caveat is that these are not instance methods; they are class methods. Note
    the
  prefs: []
  type: TYPE_NORMAL
- en: '@classmethod before the method name; this is a decorator that changes the method’s
    behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: I won’t go into details about class methods and decorators (it would require
    an entire chapter). All we need to know is that we call this method from the class
    and not from the instance, using PythonDatasource.wkt_features() or
  prefs: []
  type: TYPE_NORMAL
- en: PythonDatasource.wkb_features().
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting this into practice, what we need to do is create a class that inherits
    from PythonDatasource and reimplements its feature method. Let’s start from the
    class skeleton and then later we will go back to the classes that we built in
    [Chapter 2](index_split_000.html#p103), *The* *Geocaching App*, [Chapter 3,](index_split_000.html#p142)
    *Combining Multiple Data Sources*, and [Chapter 4](#p174), *Improving* *the App
    Search Capabilities*, and use them as a source for the features: 1\. Edit my_datasource.py;
    remove the previous code and add the new class:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import mapnik
  prefs: []
  type: TYPE_NORMAL
- en: 'class MapDatasource(mapnik.PythonDatasource):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Implementation of Mapinik''s PythonDatasource."""'
  prefs: []
  type: TYPE_NORMAL
- en: 'def features(self, query=None):'
  prefs: []
  type: TYPE_NORMAL
- en: raise NotImplementedError
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we did was to make the query an optional argument; we won’t
    remove it because there is a risk of breaking compatibility. Then the function
    only raises an exception to the effect that it’s not implemented yet.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exporting geo objects**'
  prefs: []
  type: TYPE_NORMAL
- en: Before we continue, as part of the workaround for windows users we will need
    to export our geo objects as files.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the GeoJSON file format. It’s a good choice of format for exporting
    geographic data because:'
  prefs: []
  type: TYPE_NORMAL
- en: It’s human-readable
  prefs: []
  type: TYPE_NORMAL
- en: It’s an open standard
  prefs: []
  type: TYPE_NORMAL
- en: It’s easy to make code that exports GeoJSON
  prefs: []
  type: TYPE_NORMAL
- en: Mapnik can import it
  prefs: []
  type: TYPE_NORMAL
- en: The properties/attributes can have multiple levels
  prefs: []
  type: TYPE_NORMAL
- en: Here you can see the same example of a GeoJSON file that we saw in [Chapter
    3,](index_split_000.html#p142)
  prefs: []
  type: TYPE_NORMAL
- en: '*Combining Multiple Data Sources – How Geographic Data is Represented*. You
    don’t need to type it, we are just going to use it as a reference to write our
    export code:'
  prefs: []
  type: TYPE_NORMAL
- en: '{"type": "FeatureCollection",'
  prefs: []
  type: TYPE_NORMAL
- en: '"features": ['
  prefs: []
  type: TYPE_NORMAL
- en: '{"type": "Feature",'
  prefs: []
  type: TYPE_NORMAL
- en: '"geometry": {'
  prefs: []
  type: TYPE_NORMAL
- en: '"type": "Point",'
  prefs: []
  type: TYPE_NORMAL
- en: '"coordinates": [102.0, 0.5]},'
  prefs: []
  type: TYPE_NORMAL
- en: '"properties": {"prop0": "value0"}'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '{"type": "Feature",'
  prefs: []
  type: TYPE_NORMAL
- en: '"geometry": {'
  prefs: []
  type: TYPE_NORMAL
- en: '"type": "LineString",'
  prefs: []
  type: TYPE_NORMAL
- en: '"coordinates": [[102.0, 0.0], [103.0, 1.0], [104.0, 0.0]]'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '"properties": {'
  prefs: []
  type: TYPE_NORMAL
- en: '"prop0": "value0", "prop1": 0.0'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '{"type": "Feature",'
  prefs: []
  type: TYPE_NORMAL
- en: '"geometry": {'
  prefs: []
  type: TYPE_NORMAL
- en: '"type": "Polygon",'
  prefs: []
  type: TYPE_NORMAL
- en: '"coordinates": ['
  prefs: []
  type: TYPE_NORMAL
- en: '[ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0],'
  prefs: []
  type: TYPE_NORMAL
- en: '[100.0, 1.0], [100.0, 0.0] ]'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '"properties": {"prop0": "value0",'
  prefs: []
  type: TYPE_NORMAL
- en: '"prop1": {"this": "that"}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the file, we can see that the geo objects that we created have characteristics
    that conveniently make it very easy to export them to this file format. If we
    think of a BaseGeoObject being a GeoJSON "Feature" and a BaseGeoCollection being
    a
  prefs: []
  type: TYPE_NORMAL
- en: '"FeatureCollection", it’s easy to get started: 1\. Open your models.py file
    and go to the BaseGeoObject class. Add the export_geojson_feature method:'
  prefs: []
  type: TYPE_NORMAL
- en: '#...'
  prefs: []
  type: TYPE_NORMAL
- en: 'def export_geojson_feature(self):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Exports this object as dictionary formatted as a GeoJSON feature.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: feature = {
  prefs: []
  type: TYPE_NORMAL
- en: '"type": "Feature",'
  prefs: []
  type: TYPE_NORMAL
- en: '"geometry": mapping(self.geom),'
  prefs: []
  type: TYPE_NORMAL
- en: '"properties": self.attributes}'
  prefs: []
  type: TYPE_NORMAL
- en: return feature
  prefs: []
  type: TYPE_NORMAL
- en: The mapping function calls a *magic method* that every shapely geometry has;
    it returns the geometry as a GeoJSON representation.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Now, edit the BaseGeoCollection class. Add the export_geojson method:'
  prefs: []
  type: TYPE_NORMAL
- en: '#...'
  prefs: []
  type: TYPE_NORMAL
- en: 'def export_geojson(self, file):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Exports the collection to a GeoJSON file."""'
  prefs: []
  type: TYPE_NORMAL
- en: features = [i.export_geojson_feature() for i in self.data]
  prefs: []
  type: TYPE_NORMAL
- en: 'geojson = {"type": "FeatureCollection",'
  prefs: []
  type: TYPE_NORMAL
- en: '"features": features}'
  prefs: []
  type: TYPE_NORMAL
- en: 'with open(file, ''w'') as out_file:'
  prefs: []
  type: TYPE_NORMAL
- en: json.dump(geojson, out_file, indent=2)
  prefs: []
  type: TYPE_NORMAL
- en: 'print("File exported: {}".format(file))'
  prefs: []
  type: TYPE_NORMAL
- en: Here we used a *list comprehension* ([i.export_geojson_feature() for i in self.data])
    to generate a list of features, then used the json module to serialize the dictionary
    into a JSON.
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Import the mapping function from shapely and add the json module to your
    imports at the beginning of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from __future__ import print_function
  prefs: []
  type: TYPE_NORMAL
- en: import json
  prefs: []
  type: TYPE_NORMAL
- en: from shapely.geometry import Point, mapping
  prefs: []
  type: TYPE_NORMAL
- en: from shapely import wkb, wkt
  prefs: []
  type: TYPE_NORMAL
- en: import gdal
  prefs: []
  type: TYPE_NORMAL
- en: from utils.geo_functions import open_vector_file
  prefs: []
  type: TYPE_NORMAL
- en: from utils.geo_functions import transform_geometry
  prefs: []
  type: TYPE_NORMAL
- en: from utils.geo_functions import convert_length_unit
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Finally, let’s test it. Edit your if __name__ == ''__main__'': block: if
    __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: gdal.PushErrorHandler('CPLQuietErrorHandler')
  prefs: []
  type: TYPE_NORMAL
- en: points = PointCollection("../data/geocaching.gpx") points.export_geojson("output/data.json")
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Run the code and open the output/data.json file to check the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"type": "FeatureCollection",'
  prefs: []
  type: TYPE_NORMAL
- en: '"features": ['
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"geometry": {'
  prefs: []
  type: TYPE_NORMAL
- en: '"type": "Point",'
  prefs: []
  type: TYPE_NORMAL
- en: '"coordinates": ['
  prefs: []
  type: TYPE_NORMAL
- en: -78.90175,
  prefs: []
  type: TYPE_NORMAL
- en: '42.89648'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '"type": "Feature",'
  prefs: []
  type: TYPE_NORMAL
- en: '"properties": {'
  prefs: []
  type: TYPE_NORMAL
- en: '"status": "Available",'
  prefs: []
  type: TYPE_NORMAL
- en: '"logs": {'
  prefs: []
  type: TYPE_NORMAL
- en: '"log": ['
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"@id": "1",'
  prefs: []
  type: TYPE_NORMAL
- en: '"time": "05/09/2015T11:04:05",'
  prefs: []
  type: TYPE_NORMAL
- en: '"geocacher": "SYSTEM",'
  prefs: []
  type: TYPE_NORMAL
- en: '"text": "Attributes: Quick Cache | Kid Friendly |\n'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: Everything was neatly exported, including all the properties and logs. PyCharm
    can also inspect JSON files, so you can use the Structure panel ( *Alt* + *7*)
    to explore the file structure as you did with the GPX file.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating the Map Maker app**'
  prefs: []
  type: TYPE_NORMAL
- en: Now we will prepare an environment that is capable of using this data source.
    We are going to adapt the previous experiments into building blocks for the application
    and put them inside an application class, just as we did with the Geocaching app.
  prefs: []
  type: TYPE_NORMAL
- en: First let’s organize the folder and files.
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Create a new package called map_maker inside your Chapter5 folder. To do
    this, right-click on the folder and chose **New** | **Python Package**.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Move the my_datasource.py file to the map_make folder (drag and drop it).
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Copy the map_style.xml and map_functions.py files that are inside the mapnik_experiments
    folder to the map_maker folder.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Rename map_style.xml to styles.xml.
  prefs: []
  type: TYPE_NORMAL
- en: '5\. In the Chapter5 root, create a file named map_maker_app.py. The complete
    tree structure should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter5
  prefs: []
  type: TYPE_NORMAL
- en: │ geocaching_app.py
  prefs: []
  type: TYPE_NORMAL
- en: '| map_maker_app.py'
  prefs: []
  type: TYPE_NORMAL
- en: │ models.py
  prefs: []
  type: TYPE_NORMAL
- en: │
  prefs: []
  type: TYPE_NORMAL
- en: ├───mapnik_experiments
  prefs: []
  type: TYPE_NORMAL
- en: │
  prefs: []
  type: TYPE_NORMAL
- en: ├───map_maker
  prefs: []
  type: TYPE_NORMAL
- en: │ __init__.py
  prefs: []
  type: TYPE_NORMAL
- en: │ my_datasource.py
  prefs: []
  type: TYPE_NORMAL
- en: '| styles.xml'
  prefs: []
  type: TYPE_NORMAL
- en: '| map_functions.py'
  prefs: []
  type: TYPE_NORMAL
- en: │
  prefs: []
  type: TYPE_NORMAL
- en: ├───utils
  prefs: []
  type: TYPE_NORMAL
- en: Now we create the class that represents the application.
  prefs: []
  type: TYPE_NORMAL
- en: '6\. In the map_maker_app.py file, create this new class and its __init__ method:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import cv2
  prefs: []
  type: TYPE_NORMAL
- en: import mapnik
  prefs: []
  type: TYPE_NORMAL
- en: 'class MapMakerApp(object):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, output_image=None):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Application class."""'
  prefs: []
  type: TYPE_NORMAL
- en: self.output_image = output_image
  prefs: []
  type: TYPE_NORMAL
- en: output_image will be the image that the app will write to the maps. It’s not
    private because we may want to change it during the application execution.
  prefs: []
  type: TYPE_NORMAL
- en: '7\. Copy the display_map function from the map_functions.py file, and adapt
    it to work as a method of our new class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class MapMakerApp(object):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, output_image=None):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Application class."""'
  prefs: []
  type: TYPE_NORMAL
- en: self.output_image = output_image
  prefs: []
  type: TYPE_NORMAL
