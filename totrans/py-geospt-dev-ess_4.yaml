- en: Chapter 4. Rendering Our Geodata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter is likely to be one of the most interesting ones in this book.
    Geographic visualization of data is one of the core features of a GIS application,
    whether used as an exploratory aid or to produce a map. Learning geographic visualization
    should prove educational on different levels. In this chapter, you will learn
    how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Divide the rendering process into a series of renderings of one or more thematic
    layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement basic graphics renderings for vector and raster data, based on the
    view extent and zoom level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connect these renderings to our visual user interface, allowing interactive
    map visualization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Typical usage in a GIS is to add one or more geographic data sources or layers
    to the application, which then gets immediately rendered in a map window. In [Chapter
    3](ch03.html "Chapter 3. Designing the Visual Look of Our Application"), *Designing
    the Visual Look of Our Application*, we set this up as a MapView widget. Although
    the MapView widget is responsible to show the map in the interactive GUI, we want
    to separate the actual rendering logic in a module of its own. This way the user
    can also batch generate map renderings strictly through coding if they want.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, graphics rendering is done most efficiently using the graphic capabilities
    of the user's hardware to draw on the screen. However, Tkinter's screen drawing
    capabilities (the Tkinter Canvas widget) can be slow, quickly runs out of memory
    if too many items are drawn, and produces only rough jagged graphics with no anti-aliased
    smoothing. We instead use the approach of drawing the graphics onto a virtual
    image, and then sending that image for display in Tkinter. This gives us a slight
    lag between rendering and display, and is not as fast as using graphics hardware;
    however, it is almost up there with the speed and quality of the existing GIS
    software and much better than the Tkinter default.
  prefs: []
  type: TYPE_NORMAL
- en: Installing PyAgg
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we begin, we install the graphics rendering package that we will be using,
    called **PyAgg** created by the author. PyAgg is a high-level convenience wrapper
    around Fredrik Lundh's Python **aggdraw** bindings for the **Anti-Grain Geometry**
    C++ library. Compared to other popular rendering libraries like Matplotlib or
    Mapnik, PyAgg is incredibly lightweight at only about 2 MB and doesn't require
    advanced installation steps since it contains the necessary files precompiled.
    **PyCairo** is another lightweight graphics library, but while it has a much richer
    set of features, including line joins, line caps, and gradients, it turns out
    to be very slow at drawing large objects with many vertices. Therefore, we choose
    PyAgg for its lightness, its speed, and its convenient high level API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and install it now using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Windows command line, write `C:/Python27/Scripts/pip install pyagg`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If for some reason that does not work, you can alternatively download the ZIP
    file from [https://github.com/karimbahgat/PyAgg](https://github.com/karimbahgat/PyAgg)
    and extract it to the `site-packages` folder
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test that it imports correctly by typing `import pyagg` in Python shell
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to go for other rendering libraries, Matplotlib has an easy-to-use
    Windows installer on their website. You should couple that with **Descartes**
    to convert geographic features to objects that Matplotlib can render, installed
    as pip install Descartes from the command line.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For Mapnik, there are no precompiled version that I know of, so you will have
    to compile it on your own, following instructions from [http://wiki.openstreetmap.org/wiki/Mapnik/Installation](http://wiki.openstreetmap.org/wiki/Mapnik/Installation).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you want to try **PyCairo**, you can get a precompiled wheel file for Windows
    at [http://www.lfd.uci.edu/~gohlke/pythonlibs/#pycairo](http://www.lfd.uci.edu/~gohlke/pythonlibs/#pycairo).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that the necessary graphics library is installed, we make a module called
    `renderer.py` in the root of our `pythongis` folder. Initiate it with some imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To make it accessible to our top-level `pythongis` package, just import it
    from inside `pythongis/__init__.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: A sequence of layers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The basic idea of rendering in our GIS application is that we define a series
    of map layers that should be visualized together, such as countries, cities, and
    highways. For our convenience, we make this collection of layers into an iterable
    `LayerGroup` class with methods to add or remove layers, and a method for moving
    and changing the sequence in which these layers should be drawn. Note that it
    can hold references to one or more connected map widgets, letting it serve as
    a central layer repository for a split-view type of map application. Inside `renderer.py`,
    write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The MapCanvas drawer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we need a way to combine the group of map layers into a final composite
    map image. For this we create a `MapCanvas` class, which is a wrapper around PyAgg's
    `Canvas` class. The `MapCanvas` class creates the final rendering by asking each
    layer to render themselves onto an image (with a transparent background), and
    then overlaying them on top of each other in the correct sequence. Since each
    layer has a separate image rendering, it is possible to reorder or remove layers
    very fast without having to redraw all the layers.
  prefs: []
  type: TYPE_NORMAL
- en: Layering images on top of each other is one thing, but how do we know which
    parts of our layers to show, or where on the drawing canvas they go? To do this,
    we need to transform the coordinates of our geospatial data to the pixel coordinates
    of our image, which is actually not any different from plotting arbitrary data
    values on a graph. Usually in 2D computer graphics, transforming from one coordinate
    system to another is done by multiplying each *x* and *y* coordinate with some
    precomputed numbers, called the **affine transform coefficients**. However, arriving
    at these coefficients is not immediately intuitive and requires a bit of matrix
    math.
  prefs: []
  type: TYPE_NORMAL
- en: 'PyAgg makes our lives easier, and this is one of the main reasons we chose
    to use it. With the `custom_space` method, PyAgg allows us to tell the `Canvas`
    instance to imagine that the image on which it draws is a representation of a
    given rectangular real-world space. This space is defined by a bounding box of
    coordinates so that all the incoming data for rendering is placed in relation
    to that coordinate system, drawing only those parts that fall within its boundaries.
    PyAgg then uses that bounding box to compute the transform coefficients behind
    the scenes, with the help of Sean Gillies'' affine module. As another useful feature
    for us, PyAgg allows locking the aspect ratio of the requested view extents to
    have the same width and height ratio as the canvas image itself, to avoid the
    geographic data becoming distorted or stretched. Refer to the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The MapCanvas drawer](img/5407OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On startup, before having added any data, we set the default coordinate space
    of `MapCanvas` class with `geographic_space()`, which is just a wrapper around
    `custom_space()` using `[-180, 90, 180, -90]` as the bounds (the standard latitude
    longitude coordinate system of unprojected data) and enforces aspect ratio. By
    simply changing the coordinate space bounds, the `MapCanvas` class can be used
    to render absolutely any geographic data regardless of its coordinate system or
    CRS. This way, we can create the effect of zooming or panning the map by modifying
    the drawing transform coefficients. For this, we make use of PyAgg's convenient
    zooming methods that let us specify in human terms how we would like to zoom or
    pan the drawing transform.
  prefs: []
  type: TYPE_NORMAL
- en: 'One challenge, however, is when rendering data layers defined in different
    coordinate reference systems (CRS), as these will not line up as expected. The
    usual solution in GIS is to provide on-the-fly reprojection of all geographic
    data into a single common CRS. However, converting between geographic CRS involves
    a wide range of parameters and assumptions about the shape of the earth and the
    type of projection, which makes it more complicated than our previous affine transform.
    For these reasons and others, our application will not be dealing with CRS reprojection.
    So the main limitation of our `MapCanvas` class is that it needs all data to be
    in the same CRS in order to properly overlay them. We return briefly to the topic
    of CRS in [Chapter 8](ch08.html "Chapter 8. Looking Forward"), *Looking Forward*,
    and potential ways to add such functionality yourself. Here is the code for the
    `MapCanvas` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Individual layer renderings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `MapCanvas` class described previously was responsible to define a common
    coordinate space and combining the images of its layers, but not for any actual
    drawing. We leave this task to the individual layer classes, one for `vector`
    and one for `raster`.
  prefs: []
  type: TYPE_NORMAL
- en: Vector layers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The rendering of vector data is fairly easy. All we have to do is create a `VectorLayer`
    instance around the `VectorData` class, and optionally decide some style aspects
    of its geometries using keyword arguments. During this style options stage, we
    allow all features being styled in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On your own, you may want to expand this with the ability to style individual
    features or groups of features based on their attribute values. This will allow
    you to visualize how data flows across space.
  prefs: []
  type: TYPE_NORMAL
- en: To render itself, the vector layer creates a PyAgg Canvas with the same image
    size as its parent `MapCanvas` class, on top of a transparent background. To make
    sure it only draws the parts of the data that its parent `MapCanvas` class is
    supposed to be seeing, it is up to us to set the `coordspace_bbox` argument with
    the bounding box of the `MapCanvas` class. The layer passes this information on
    to its `Canvas` instance via `custom_space()`, so that PyAgg can calculate the
    correct drawing transform coefficients using matrix math.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to drawing each feature, PyAgg and its underlying aggdraw module
    has different drawing methods with different requirements for how its coordinates
    should be formatted. Since our geometries can be either points, lines, or polygons
    and are stored in GeoJSON formatted dictionaries, we need to translate our GeoJSON
    format to that which is expected by PyAgg. For instance, a GeoJSON polygon is
    a list of coordinate sequences, the first one being the exterior and all subsequent
    ones its holes; this information can then be sent to the PyAgg''s `draw_polygon`
    method with the arguments it expects. Instead of us learning the entire GeoJSON
    format to correctly parse the data and call on the right methods, PyAgg''s `Canvas`
    class can do this for us in the `draw_geojson` method. After drawing, the rendered
    image is remembered and made accessible to `MapCanvas`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Raster layers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a similar manner, rendering raster data is done by creating a `RasterLayer`
    class. When rendering itself, consider that each cell in a raster grid has a precise
    location and rectangular area that it covers in geographic space. To transform
    these cell coordinates from raster space to image space for visualization, the
    `RasterLayer` class has to know the coordinate view extent of the parent `MapCanvas`
    class and find where and how each raster cell should be placed within those bounds.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily for us, we already gave the `RasterData` class a method for doing this
    type of grid transform, namely, the `positioned` method that leverages PIL's quad
    transform technique. Using this method, the `RasterLayer` class specifies the
    width and height of the data it wants to return, based on the size of its parent
    `MapCanvas` class, and to only include the parts of the raster that are within
    the bounds of the `MapCavas` classes' coordinate system.
  prefs: []
  type: TYPE_NORMAL
- en: Since the data structure of our `RasterData` class is based on PIL images, all
    it has to do is combine all band images together to create a gray scale or RGB
    image, ready to be added to the `MapCanvas` class for visualization. The `positioned`
    method also transforms and returns the `nodata` mask that the `RasterLayer` class
    uses to make missing values transparent.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Currently, we do not allow customization of the colors used for visualizing
    the raster, but that should be an easy feature to add if you want to, using the
    PIL's support for color palettes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Interactively rendering our maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have ways of combining several layers into a rendered map image,
    we get to the more exciting part of how to do this interactively in our application
    with immediate results.
  prefs: []
  type: TYPE_NORMAL
- en: Linking the MapView to the renderer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After we rendered a set of layers onto a map image, this image must be sent
    to and displayed in our application for immediate feedback. This task is done
    by the MapView widget we created in [Chapter 3](ch03.html "Chapter 3. Designing
    the Visual Look of Our Application"), *Designing the Visual Look of Our Application*.
    While building our application, the idea is that all we have to worry about is
    creating this visual MapView widget; behind the scenes, the MapView will be responsible
    for creating its own `MapCanvas` renderer to do the actual work. Since the `MapCanvas`
    class needs LayerGroup to manage its layers, we will create a MapView method to
    assign a LayerGroup, in `app/toolkit/map.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We then link the two together as additional code in the MapView''s `__init__`
    method. Since the renderer requires a width and a height in pixels before it can
    be created, we schedule MapView to create it shortly after startup (because Tkinter
    won''t know how much space is required for the various widgets before startup):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Requesting to render a map
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Whenever the MapView widget wants to render a whole new map with all visible
    layers, it calls on this method, and does so in a separate thread in order to
    not freeze up the application while waiting for the results. It also updates the
    status bar on its activities and sets the horizontal scale status based on the
    new zoom level. Afterwards, it has to update the image that is placed on the viewable
    Tkinter Canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Resizing the map in proportion to window resizing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If the user changes the application window size from the original startup size,
    we need to resize the MapView''s renderer accordingly. We tell it to resize only
    after one-third of a second after the user has stopped resizing the window, because
    Tkinter''s resize event is triggered continuously during the process. What is
    important in the event of such a resize is that the coordinate system is changed
    accordingly to map the new image dimensions; fortunately for us, our PyAgg Canvas
    automatically updates and locks the aspect ratio on the drawing transform for
    us when resizing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The LayersPane as a LayerGroup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With a basic Map widget capable of rendering, we move onto adding data to the
    map, which we then can view in our application''s layers pane. The LayersPane
    widget is merely a visual representation of the sequence of layers in its connected
    LayerGroup class. Therefore, the LayersPane class in the `app/toolkit/layers.py`
    file needs a method to bind it to a LayerGroup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Adding layers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now create an `add_layer` method to the LayersPane class in `app/toolkit/layers.py`.
    To make it flexible, we allow it to add a layer either from a file path or from
    an already loaded data object.
  prefs: []
  type: TYPE_NORMAL
- en: If it detects a file path, it first runs a `from_filepath` function, where it
    decides whether to create a vector or raster data class, tells our dispatch module
    to use this data class to load the file path in a background thread, and schedules
    our application to check the results queue every 100 ms to see whether the loading
    is done.
  prefs: []
  type: TYPE_NORMAL
- en: Once loaded or if given an already loaded data object, it goes straight to adding
    the layer with the `from_loaded()` function. This creates a VectorLayer or RasterLayer
    capable of rendering itself, adds a representation of that layer responsive to
    right-click events in the LayersPane (more on this in the next section), and asks
    the dispatch to render the layer as an image and update the MapView widget(s)
    to which it is connected. If the new layer is the only one currently loaded in
    the LayersPanel, then we automatically zoom to its bounding box so that the user
    gets an immediate look at the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Editing layers in the LayersPane widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we can add layers to the LayersPane, we also want to be able to play
    around with the layers. A layer is represented as a LayerItem widget, which we
    have yet to define. We give the LayerItem a delete button on the right side, and
    a checkbox on the left side to toggle its visibility as shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Editing layers in the LayersPane widget](img/5407OS_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The delete button is going to need an icon so let''s start by getting one of
    those:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to an icon website such as [www.iconarchive.com](http://www.iconarchive.com)
    or [http://www.flaticon.com](http://www.flaticon.com).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for and choose an icon that you like.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save it as `delete_layer.png` with 32 pixel size and place it in your `app/icons`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We also define how to rename a layer''s name, which temporarily adds a Tkinter
    entry widget over the layer''s name display so the user can alter the name and
    press *Return* to accept or *ESC* to cancel. Now make the `LayerItem` class in
    `app/toolkit/layers.py` using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `LayerItem` class''s delete button and visibility checkbox in the previous
    code both called on methods in the parent LayersPane to do the work, because the
    LayersPane''s connected MapCanvas need updating afterwards. Therefore, let''s
    add these methods to the LayersPane. We also need a way to specify the function
    to be run when right-clicking any of the layers in the LayersPane:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Click-and-drag to rearrange the layer sequence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A slightly more complicated procedure is to let the user rearrange the drawing
    order of the LayerItems in the LayersPane by clicking and dragging them to a new
    position. It is an essential feature of the layered nature of any GIS software,
    but unfortunately the Tkinter GUI framework does not provide us with any drag-and-drop
    shortcuts, so we must build it from scratch. We keep it simple and only allow
    one layer to be moved at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'To rearrange a layer in the list, we first need to listen for an event where
    the user clicks a LayerItem. In such an event, we remember the position of the
    layer that we want to move and change the cursor to indicate that a drag and drop
    is underway. When the user releases the mouse-click, we loop through the screen
    coordinates of all the LayerItem widgets to detect the layer position at which
    the mouse was released. Note that the index position of the layer that is rendered
    on top of all others is the first one in the list of LayerItems, but is the last
    one in the sequence of layers in the LayerGroup. We add this listening behavior
    in the LayerItem''s `__init__` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After the user has interacted with the LayersPane to tell it where to move
    a layer, we tell its associated LayerGroup to rearrange the layer sequence based
    on the "from and to" positions. We then tell all of the MapCanvas connected to
    that LayerGroup to update their drawing order and the image being displayed. We
    must define this method in the `LayersPane` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Zooming the map image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point, we can add and remove layers to and from the map and rearrange
    their sequence, but we still cannot interact with the map itself. Here comes one
    of the great things of making our own application. One thing that users may find
    difficult with existing GIS software is that they have to choose between one of
    two modes of interacting with the map: one is the **pan** mode so that clicking
    and dragging the mouse moves the map accordingly, and the other is the **rectangle-zoom**
    mode where click and drag defines the area to zoom to.'
  prefs: []
  type: TYPE_NORMAL
- en: Switching between these two modes is not very conducive to map exploration which
    is often more of a dynamic and iterative process, involving simultaneous use of
    zooming and panning when using Google Maps. Now that we have the power to decide,
    let's combine zoom and pan by controlling them with double clicks and click and
    drag, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual zooming of the map is done by asking the MapCanvas to redraw the
    map at the given zoom level. We bind a 2x zoom factor method centered on the mouse
    to events where the user double clicks on the map. We give such zooming a one-third
    of a second lag after the user stops clicking so that the user can double click
    many times in a row for extra large zoom without overwhelming the application
    to render multiple incremental zoom images. Each time a zoom level is changed,
    we also ask to update the status bar''s zoom unit scale, which is given to us
    by the PyAgg rendering canvas. All of this listening behavior we add to the MapView''s
    `__init__` method, inside `app/toolkit/map.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Map panning and one-time rectangle zoom
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Panning the map is relatively easy since the rendered map image is simply an
    image placed inside a Tkinter scrollable Canvas widget. The rendered map image
    is always placed at the Tkinter Canvas'' [0,0] coordinates in the top-left corner,
    but when we pan the map, we make the image start following the mouse. After we
    let go, the renderer begins rendering a new map by offsetting the MapCanvas''
    PyAgg coordinate system and rerendering the map. We also allow for an alternative
    zoom mode that uses these click and release events to perform a conventional rectangle
    zoom, along with the visual guide of Tkinter''s built-in canvas rectangle drawing.
    This rectangle zoom mode should only be as a one-time event that defaults back
    to panning, since rectangle zoom is relatively rarely needed. To indicate when
    we are in rectangle zoom mode, we also replace the cursor with something like
    a magnifying glass icon whenever it is over the MapView widget, so you will need
    to find and save a `rect_zoom.png` image to `app/icons`. Moving the mouse over
    the map generally should also display the mouse coordinates in the status bar.
    We define this in the `__init__` method of the MapView widget, in `app/toolkit/map.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: A navigation toolbar
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to activate one-time rectangle zoom, we create a navigation toolbar
    in the `app/toolkit/toolbars.py` file that has to be connected to a MapView, and
    give it a button that simply turns on the one-time zoom mode of its connected
    MapView. While we are at it, we also create a toolbar button to zoom to the global
    bounding box of all of the layers in the MapView''s `layergroup`. Remember to
    find and save icons for these two new buttons, `zoom_rect.png` and `zoom_global.png`.
    Refer to the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A navigation toolbar](img/5407OS_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual zooming calls to the renderer are defined as methods of the MapView
    widget, in `app/toolkit/map.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now defined all of the necessary building blocks of a basic rendering
    application. These can be used and combined in many different ways. For instance,
    if you want to you can build an application that has a single LayerGroup/LayersPane
    connected with multiple independently zoomable MapViews, to view different locations
    of the same data simultaneously. In this book, we go for a more basic desktop
    GIS look.
  prefs: []
  type: TYPE_NORMAL
- en: Let's return to our GUI class that we created in [Chapter 3](ch03.html "Chapter 3. Designing
    the Visual Look of Our Application"), *Designing the Visual Look of Our Application*,
    and add more content to its startup phase. First we give the GUI a LayerGroup
    instance to hold our layers and link it to both the MapView and LayersPane widgets
    so they can communicate later on.
  prefs: []
  type: TYPE_NORMAL
- en: We also need a button to add data layers. There are many possible places to
    put such an important button, but for our current application, let's place it
    in the header of the LayersPane widget so that all things related to layers are
    kept logically grouped together. We want this button to have an icon, so let's
    first find and save a suitable icon as `add_layer.png` in the `app/icons` folder.
    Specifically, we want to create a button to add layers, assign it with our icon,
    and place it on the right side of the LayersPane header. When the button is clicked,
    it will run a `selectfiles` function, which opens a Tkinter file selection dialog
    window and adds all the selected files as new layers.
  prefs: []
  type: TYPE_NORMAL
- en: Loading data from a file may require that we specify the correct text encoding
    of the data. By default, we set it to `utf8`, but the user should be able to customize
    this and other data options in a separate data settings window. We store the data
    options dictionary as an attribute of the GUI class and allow it to be changed
    by user input in the settings window. This settings window is easily defined using
    our `RunToolFrame` template. To allow users to access this settings window, we
    add a data settings button right next to the add layer button. As usual, find
    and download an icon to use for the button, calling it `data_options.png`.
  prefs: []
  type: TYPE_NORMAL
- en: After that, let's create a ribbon tab for visualizing, giving it a button to
    save the contents of our MapView widget to an image file. Remember to find and
    save a `save_image.png` file, so we can give this button an icon. Finally, we
    add the navigation toolbar that we created earlier, hanging in the air in the
    upper part of the MapView.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now add this new code to our GUI class'' `__init__` method, inside `app/builder.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And that is about it! Your application should now be ready to use for rendering
    map data. Run `guitester.py`, and try to add some data and interact with the map.
    If you have done everything correctly, and, depending on your data, your screen
    should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Putting it all together](img/5407OS_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has been a fundamental milestone. We built a working geographic
    rendering module based on rearrangable layers in a LayerGroup, created a MapView
    widget for interactive displaying of these map renderings, made a visual LayersPane
    of the layers in our map, and enabled interactive zooming and panning of the MapView.
  prefs: []
  type: TYPE_NORMAL
- en: After following each step, you should now have what looks and feels like a GIS
    data inspecting application. Of course, a more sophisticated GIS needs additional
    methods not only to inspect data, but also to manage and edit data—which is what
    we turn to next.
  prefs: []
  type: TYPE_NORMAL
