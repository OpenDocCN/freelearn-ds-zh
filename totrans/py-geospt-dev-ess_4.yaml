- en: Chapter 4. Rendering Our Geodata
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章。渲染我们的地理数据
- en: 'This chapter is likely to be one of the most interesting ones in this book.
    Geographic visualization of data is one of the core features of a GIS application,
    whether used as an exploratory aid or to produce a map. Learning geographic visualization
    should prove educational on different levels. In this chapter, you will learn
    how to do the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这章可能是本书中最有趣的一章之一。数据的地形可视化是 GIS 应用程序的核心功能之一，无论是用作探索辅助工具还是用于制作地图。学习地形可视化应该在不同层面上都是有益的。在本章中，你将学习以下内容：
- en: Divide the rendering process into a series of renderings of one or more thematic
    layers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将渲染过程分解为一系列一个或多个专题图层的渲染
- en: Implement basic graphics renderings for vector and raster data, based on the
    view extent and zoom level
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据视图范围和缩放级别实现矢量数据和栅格数据的基本图形渲染
- en: Connect these renderings to our visual user interface, allowing interactive
    map visualization
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将这些渲染连接到我们的视觉用户界面，允许交互式地图可视化
- en: Rendering
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染
- en: Typical usage in a GIS is to add one or more geographic data sources or layers
    to the application, which then gets immediately rendered in a map window. In [Chapter
    3](ch03.html "Chapter 3. Designing the Visual Look of Our Application"), *Designing
    the Visual Look of Our Application*, we set this up as a MapView widget. Although
    the MapView widget is responsible to show the map in the interactive GUI, we want
    to separate the actual rendering logic in a module of its own. This way the user
    can also batch generate map renderings strictly through coding if they want.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GIS 中的典型用法是向应用程序添加一个或多个地理数据源或图层，然后它立即在地图窗口中渲染。在 [第 3 章](ch03.html "第 3 章。设计应用程序的视觉外观")，*设计应用程序的视觉外观*中，我们将它设置为
    MapView 小部件。尽管 MapView 小部件负责在交互式 GUI 中显示地图，但我们希望将实际的渲染逻辑分离到一个单独的模块中。这样，如果用户想要的话，也可以通过编码批量生成地图渲染。
- en: Usually, graphics rendering is done most efficiently using the graphic capabilities
    of the user's hardware to draw on the screen. However, Tkinter's screen drawing
    capabilities (the Tkinter Canvas widget) can be slow, quickly runs out of memory
    if too many items are drawn, and produces only rough jagged graphics with no anti-aliased
    smoothing. We instead use the approach of drawing the graphics onto a virtual
    image, and then sending that image for display in Tkinter. This gives us a slight
    lag between rendering and display, and is not as fast as using graphics hardware;
    however, it is almost up there with the speed and quality of the existing GIS
    software and much better than the Tkinter default.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，图形渲染是通过使用用户的硬件图形能力在屏幕上绘制来最有效地完成的。然而，Tkinter 的屏幕绘制能力（Tkinter Canvas 小部件）可能很慢，如果绘制太多项目，会很快耗尽内存，并且只能产生粗糙的锯齿状图形，没有抗锯齿平滑。我们改用将图形绘制到虚拟图像上的方法，然后将该图像发送到
    Tkinter 进行显示。这会在渲染和显示之间产生轻微的延迟，并且不如使用图形硬件快；然而，它几乎与现有 GIS 软件的速度和质量相当，并且比 Tkinter
    默认设置好得多。
- en: Installing PyAgg
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 PyAgg
- en: Before we begin, we install the graphics rendering package that we will be using,
    called **PyAgg** created by the author. PyAgg is a high-level convenience wrapper
    around Fredrik Lundh's Python **aggdraw** bindings for the **Anti-Grain Geometry**
    C++ library. Compared to other popular rendering libraries like Matplotlib or
    Mapnik, PyAgg is incredibly lightweight at only about 2 MB and doesn't require
    advanced installation steps since it contains the necessary files precompiled.
    **PyCairo** is another lightweight graphics library, but while it has a much richer
    set of features, including line joins, line caps, and gradients, it turns out
    to be very slow at drawing large objects with many vertices. Therefore, we choose
    PyAgg for its lightness, its speed, and its convenient high level API.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们需要安装我们将要使用的图形渲染包，这个包叫做 **PyAgg**，由作者创建。PyAgg 是围绕 Fredrik Lundh 的 Python
    **aggdraw** 绑定和 **Anti-Grain Geometry** C++ 库的高级便利包装。与 Matplotlib 或 Mapnik 等其他流行的渲染库相比，PyAgg
    非常轻量，仅约 2 MB，因为它包含了预编译的必要文件，所以不需要复杂的安装步骤。**PyCairo** 是另一个轻量级图形库，尽管它具有更丰富的功能集，包括线连接、线帽和渐变，但它绘制具有许多顶点的大对象时速度非常慢。因此，我们选择
    PyAgg，因为它轻量、速度快，并且具有方便的高级 API。
- en: 'Go ahead and install it now using the following steps:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在按照以下步骤进行安装：
- en: In the Windows command line, write `C:/Python27/Scripts/pip install pyagg`
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Windows 命令行中，输入 `C:/Python27/Scripts/pip install pyagg`
- en: If for some reason that does not work, you can alternatively download the ZIP
    file from [https://github.com/karimbahgat/PyAgg](https://github.com/karimbahgat/PyAgg)
    and extract it to the `site-packages` folder
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果出于某种原因这不起作用，你可以从[https://github.com/karimbahgat/PyAgg](https://github.com/karimbahgat/PyAgg)下载ZIP文件，并将其提取到`site-packages`文件夹中
- en: Test that it imports correctly by typing `import pyagg` in Python shell
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在Python壳中输入`import pyagg`来测试它是否正确导入
- en: Note
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to go for other rendering libraries, Matplotlib has an easy-to-use
    Windows installer on their website. You should couple that with **Descartes**
    to convert geographic features to objects that Matplotlib can render, installed
    as pip install Descartes from the command line.
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你想尝试其他渲染库，Matplotlib在其网站上提供了一个易于使用的Windows安装程序。你应该将其与**Descartes**结合使用，以将地理特征转换为Matplotlib可以渲染的对象，通过命令行安装Descartes，即使用pip
    install Descartes。
- en: For Mapnik, there are no precompiled version that I know of, so you will have
    to compile it on your own, following instructions from [http://wiki.openstreetmap.org/wiki/Mapnik/Installation](http://wiki.openstreetmap.org/wiki/Mapnik/Installation).
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于Mapnik，据我所知没有预编译版本，因此你将不得不自己编译它，按照[http://wiki.openstreetmap.org/wiki/Mapnik/Installation](http://wiki.openstreetmap.org/wiki/Mapnik/Installation)上的说明进行。
- en: If you want to try **PyCairo**, you can get a precompiled wheel file for Windows
    at [http://www.lfd.uci.edu/~gohlke/pythonlibs/#pycairo](http://www.lfd.uci.edu/~gohlke/pythonlibs/#pycairo).
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你想要尝试**PyCairo**，你可以在[http://www.lfd.uci.edu/~gohlke/pythonlibs/#pycairo](http://www.lfd.uci.edu/~gohlke/pythonlibs/#pycairo)获取Windows的预编译wheel文件。
- en: 'Now that the necessary graphics library is installed, we make a module called
    `renderer.py` in the root of our `pythongis` folder. Initiate it with some imports:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在必要的图形库已经安装，我们在`pythongis`文件夹的根目录下创建一个名为`renderer.py`的模块。通过以下导入来初始化它：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To make it accessible to our top-level `pythongis` package, just import it
    from inside `pythongis/__init__.py`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其对我们的顶级`pythongis`包可用，只需从`pythongis/__init__.py`内部导入它：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A sequence of layers
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图层序列
- en: 'The basic idea of rendering in our GIS application is that we define a series
    of map layers that should be visualized together, such as countries, cities, and
    highways. For our convenience, we make this collection of layers into an iterable
    `LayerGroup` class with methods to add or remove layers, and a method for moving
    and changing the sequence in which these layers should be drawn. Note that it
    can hold references to one or more connected map widgets, letting it serve as
    a central layer repository for a split-view type of map application. Inside `renderer.py`,
    write the following code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们GIS应用程序中渲染的基本思想是，我们定义了一系列应该一起可视化的地图图层，例如国家、城市和高速公路。为了方便起见，我们将这些图层集合到一个可迭代的`LayerGroup`类中，它具有添加或删除图层的方法，以及一个用于移动和更改这些图层绘制顺序的方法。请注意，它可以持有对一个或多个连接的地图小部件的引用，使其可以作为分割视图类型地图应用程序的中心图层存储库。在`renderer.py`内部，编写以下代码：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The MapCanvas drawer
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MapCanvas绘图器
- en: Next, we need a way to combine the group of map layers into a final composite
    map image. For this we create a `MapCanvas` class, which is a wrapper around PyAgg's
    `Canvas` class. The `MapCanvas` class creates the final rendering by asking each
    layer to render themselves onto an image (with a transparent background), and
    then overlaying them on top of each other in the correct sequence. Since each
    layer has a separate image rendering, it is possible to reorder or remove layers
    very fast without having to redraw all the layers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一种方法将地图图层组合成一个最终的复合地图图像。为此，我们创建了一个`MapCanvas`类，它是PyAgg的`Canvas`类的包装器。`MapCanvas`类通过要求每个图层将自己渲染到图像上（带有透明背景），然后按照正确的顺序将它们叠加在一起来创建最终的渲染。由于每个图层都有独立的图像渲染，因此可以非常快速地重新排序或删除图层，而无需重新绘制所有图层。
- en: Layering images on top of each other is one thing, but how do we know which
    parts of our layers to show, or where on the drawing canvas they go? To do this,
    we need to transform the coordinates of our geospatial data to the pixel coordinates
    of our image, which is actually not any different from plotting arbitrary data
    values on a graph. Usually in 2D computer graphics, transforming from one coordinate
    system to another is done by multiplying each *x* and *y* coordinate with some
    precomputed numbers, called the **affine transform coefficients**. However, arriving
    at these coefficients is not immediately intuitive and requires a bit of matrix
    math.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在图像上叠加层是一回事，但我们如何知道哪些层要显示，或者它们在绘图画布上的具体位置呢？要做到这一点，我们需要将我们的地理空间数据的坐标转换成图像的像素坐标，这实际上并不比在图上绘制任意数据值有太大区别。通常在二维计算机图形学中，从一个坐标系转换到另一个坐标系是通过将每个
    *x* 和 *y* 坐标与一些预先计算的数字相乘来完成的，这些数字被称为**仿射变换系数**。然而，得到这些系数并不立即直观，需要一点矩阵数学知识。
- en: 'PyAgg makes our lives easier, and this is one of the main reasons we chose
    to use it. With the `custom_space` method, PyAgg allows us to tell the `Canvas`
    instance to imagine that the image on which it draws is a representation of a
    given rectangular real-world space. This space is defined by a bounding box of
    coordinates so that all the incoming data for rendering is placed in relation
    to that coordinate system, drawing only those parts that fall within its boundaries.
    PyAgg then uses that bounding box to compute the transform coefficients behind
    the scenes, with the help of Sean Gillies'' affine module. As another useful feature
    for us, PyAgg allows locking the aspect ratio of the requested view extents to
    have the same width and height ratio as the canvas image itself, to avoid the
    geographic data becoming distorted or stretched. Refer to the following figure:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: PyAgg让我们的工作变得更简单，这也是我们选择使用它的主要原因之一。使用 `custom_space` 方法，PyAgg 允许我们告诉 `Canvas`
    实例，它所绘制的图像是给定矩形真实世界空间的一个表示。这个空间由坐标的边界框定义，以便所有用于渲染的数据都相对于该坐标系放置，只绘制那些在其边界内的部分。PyAgg
    然后使用那个边界框在幕后计算变换系数，在Sean Gillies的仿射模块的帮助下。作为对我们有用的另一个特性，PyAgg 允许锁定请求的视图范围的宽高比，使其与画布图像本身的宽高比相同，以避免地理数据变形或拉伸。请参考以下图示：
- en: '![The MapCanvas drawer](img/5407OS_04_01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![MapCanvas 绘图器](img/5407OS_04_01.jpg)'
- en: On startup, before having added any data, we set the default coordinate space
    of `MapCanvas` class with `geographic_space()`, which is just a wrapper around
    `custom_space()` using `[-180, 90, 180, -90]` as the bounds (the standard latitude
    longitude coordinate system of unprojected data) and enforces aspect ratio. By
    simply changing the coordinate space bounds, the `MapCanvas` class can be used
    to render absolutely any geographic data regardless of its coordinate system or
    CRS. This way, we can create the effect of zooming or panning the map by modifying
    the drawing transform coefficients. For this, we make use of PyAgg's convenient
    zooming methods that let us specify in human terms how we would like to zoom or
    pan the drawing transform.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动时，在添加任何数据之前，我们使用 `geographic_space()` 将 `MapCanvas` 类的默认坐标空间设置为，它实际上是对 `custom_space()`
    的封装，使用 `[-180, 90, 180, -90]` 作为边界（这是未投影数据的标准经纬度坐标系）并强制保持宽高比。通过简单地改变坐标空间的边界，`MapCanvas`
    类可以用来渲染任何地理数据，无论其坐标系或CRS如何。这样，我们可以通过修改绘图变换系数来创建缩放或平移地图的效果。为此，我们利用PyAgg方便的缩放方法，这些方法允许我们用人类可以理解的方式指定我们想要如何缩放或平移绘图变换。
- en: 'One challenge, however, is when rendering data layers defined in different
    coordinate reference systems (CRS), as these will not line up as expected. The
    usual solution in GIS is to provide on-the-fly reprojection of all geographic
    data into a single common CRS. However, converting between geographic CRS involves
    a wide range of parameters and assumptions about the shape of the earth and the
    type of projection, which makes it more complicated than our previous affine transform.
    For these reasons and others, our application will not be dealing with CRS reprojection.
    So the main limitation of our `MapCanvas` class is that it needs all data to be
    in the same CRS in order to properly overlay them. We return briefly to the topic
    of CRS in [Chapter 8](ch08.html "Chapter 8. Looking Forward"), *Looking Forward*,
    and potential ways to add such functionality yourself. Here is the code for the
    `MapCanvas` class:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个挑战是在渲染定义在不同坐标参考系统（CRS）中的数据层时，因为这些数据不会像预期的那样对齐。在 GIS 中，通常的解决方案是在单个公共 CRS
    中即时重投影所有地理数据。然而，在地理 CRS 之间进行转换涉及广泛的参数和对地球形状以及投影类型的假设，这使得它比我们之前的仿射变换更复杂。出于这些原因以及其他原因，我们的应用程序将不会处理
    CRS 重投影。因此，我们 `MapCanvas` 类的主要限制是需要所有数据都在相同的 CRS 中，以便正确叠加。我们简要地回到第 8 章（ch08.html
    "第 8 章. 展望未来"）的主题，*展望未来*，以及添加此类功能的方法。以下是 `MapCanvas` 类的代码：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Individual layer renderings
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单个层的渲染
- en: The `MapCanvas` class described previously was responsible to define a common
    coordinate space and combining the images of its layers, but not for any actual
    drawing. We leave this task to the individual layer classes, one for `vector`
    and one for `raster`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 之前描述的 `MapCanvas` 类负责定义一个公共坐标系并组合其层的图像，但不负责任何实际的绘制。我们将这项任务留给单个层类，一个用于 `vector`，另一个用于
    `raster`。
- en: Vector layers
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向量层
- en: The rendering of vector data is fairly easy. All we have to do is create a `VectorLayer`
    instance around the `VectorData` class, and optionally decide some style aspects
    of its geometries using keyword arguments. During this style options stage, we
    allow all features being styled in the same way.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 向量数据的渲染相当简单。我们只需在 `VectorData` 类周围创建一个 `VectorLayer` 实例，并可选地使用关键字参数决定其几何形状的一些样式方面。在样式选项阶段，我们允许所有被样式的特征以相同的方式进行样式化。
- en: Tip
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: On your own, you may want to expand this with the ability to style individual
    features or groups of features based on their attribute values. This will allow
    you to visualize how data flows across space.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 亲自尝试，你可能希望扩展此功能，以便根据其属性值对单个特征或特征组进行样式化。这将允许你可视化数据如何在空间中流动。
- en: To render itself, the vector layer creates a PyAgg Canvas with the same image
    size as its parent `MapCanvas` class, on top of a transparent background. To make
    sure it only draws the parts of the data that its parent `MapCanvas` class is
    supposed to be seeing, it is up to us to set the `coordspace_bbox` argument with
    the bounding box of the `MapCanvas` class. The layer passes this information on
    to its `Canvas` instance via `custom_space()`, so that PyAgg can calculate the
    correct drawing transform coefficients using matrix math.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了渲染自身，向量层在其父类 `MapCanvas` 的相同图像尺寸上创建一个 PyAgg Canvas，背景为透明。为了确保它只绘制其父类 `MapCanvas`
    应该看到的那些数据部分，我们需要设置 `coordspace_bbox` 参数为 `MapCanvas` 类的边界框。该层通过 `custom_space()`
    方法将此信息传递给其 `Canvas` 实例，以便 PyAgg 可以使用矩阵数学计算正确的绘图变换系数。
- en: 'When it comes to drawing each feature, PyAgg and its underlying aggdraw module
    has different drawing methods with different requirements for how its coordinates
    should be formatted. Since our geometries can be either points, lines, or polygons
    and are stored in GeoJSON formatted dictionaries, we need to translate our GeoJSON
    format to that which is expected by PyAgg. For instance, a GeoJSON polygon is
    a list of coordinate sequences, the first one being the exterior and all subsequent
    ones its holes; this information can then be sent to the PyAgg''s `draw_polygon`
    method with the arguments it expects. Instead of us learning the entire GeoJSON
    format to correctly parse the data and call on the right methods, PyAgg''s `Canvas`
    class can do this for us in the `draw_geojson` method. After drawing, the rendered
    image is remembered and made accessible to `MapCanvas`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到绘制每个特征时，PyAgg及其底层的aggdraw模块有不同的绘图方法，对坐标的格式有不同的要求。由于我们的几何可以是点、线或多边形，并且存储在GeoJSON格式的字典中，我们需要将我们的GeoJSON格式转换为PyAgg期望的格式。例如，GeoJSON多边形是一个坐标序列列表，第一个是外部，所有随后的都是孔洞；然后可以将这些信息发送到PyAgg的`draw_polygon`方法，并使用它期望的参数。我们不必学习整个GeoJSON格式来正确解析数据并调用正确的方法，PyAgg的`Canvas`类可以在`draw_geojson`方法中为我们完成这些操作。绘制后，渲染的图像会被记住并可供`MapCanvas`访问：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Raster layers
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 栅格层
- en: In a similar manner, rendering raster data is done by creating a `RasterLayer`
    class. When rendering itself, consider that each cell in a raster grid has a precise
    location and rectangular area that it covers in geographic space. To transform
    these cell coordinates from raster space to image space for visualization, the
    `RasterLayer` class has to know the coordinate view extent of the parent `MapCanvas`
    class and find where and how each raster cell should be placed within those bounds.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，渲染栅格数据是通过创建一个`RasterLayer`类来完成的。在自身渲染时，要考虑到栅格网格中的每个单元格在地理空间中都有一个精确的位置和矩形区域。为了将这些单元格坐标从栅格空间转换为图像空间以进行可视化，`RasterLayer`类必须知道父`MapCanvas`类的坐标视图范围，并确定每个栅格单元格应该放置在哪些边界内。
- en: Luckily for us, we already gave the `RasterData` class a method for doing this
    type of grid transform, namely, the `positioned` method that leverages PIL's quad
    transform technique. Using this method, the `RasterLayer` class specifies the
    width and height of the data it wants to return, based on the size of its parent
    `MapCanvas` class, and to only include the parts of the raster that are within
    the bounds of the `MapCavas` classes' coordinate system.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们之前已经为`RasterData`类提供了一个执行此类网格转换的方法，即利用PIL的quad转换技术的`positioned`方法。使用此方法，`RasterLayer`类根据其父`MapCanvas`类的大小指定要返回的数据的宽度和高度，并且只包括位于`MapCavas`类坐标系统边界内的栅格部分。
- en: Since the data structure of our `RasterData` class is based on PIL images, all
    it has to do is combine all band images together to create a gray scale or RGB
    image, ready to be added to the `MapCanvas` class for visualization. The `positioned`
    method also transforms and returns the `nodata` mask that the `RasterLayer` class
    uses to make missing values transparent.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的`RasterData`类的数据结构基于PIL图像，它只需将所有波段图像组合在一起以创建一个灰度或RGB图像，即可添加到`MapCanvas`类中进行可视化。`positioned`方法还会转换并返回`RasterLayer`类使用的`nodata`掩码，该掩码用于使缺失值透明。
- en: Tip
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Currently, we do not allow customization of the colors used for visualizing
    the raster, but that should be an easy feature to add if you want to, using the
    PIL's support for color palettes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们不允许自定义用于可视化栅格的颜色，但如果您想添加此功能，使用PIL对颜色调色板的支持应该很容易。
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Interactively rendering our maps
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交互式渲染我们的地图
- en: Now that we have ways of combining several layers into a rendered map image,
    we get to the more exciting part of how to do this interactively in our application
    with immediate results.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了将多个图层组合成渲染地图图像的方法，我们就可以进入更令人兴奋的部分，即如何在我们的应用程序中以交互式方式立即实现这一点。
- en: Linking the MapView to the renderer
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将MapView连接到渲染器
- en: 'After we rendered a set of layers onto a map image, this image must be sent
    to and displayed in our application for immediate feedback. This task is done
    by the MapView widget we created in [Chapter 3](ch03.html "Chapter 3. Designing
    the Visual Look of Our Application"), *Designing the Visual Look of Our Application*.
    While building our application, the idea is that all we have to worry about is
    creating this visual MapView widget; behind the scenes, the MapView will be responsible
    for creating its own `MapCanvas` renderer to do the actual work. Since the `MapCanvas`
    class needs LayerGroup to manage its layers, we will create a MapView method to
    assign a LayerGroup, in `app/toolkit/map.py`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将一系列图层渲染到地图图像上之后，必须将此图像发送到我们的应用程序并显示出来，以便立即获得反馈。这个任务是由我们在[第3章](ch03.html
    "第3章。设计应用程序的视觉外观")中创建的MapView小部件完成的，*设计应用程序的视觉外观*。在构建我们的应用程序时，我们的想法是，我们只需要担心创建这个可视的MapView小部件；幕后，MapView将负责创建自己的`MapCanvas`渲染器来完成实际工作。由于`MapCanvas`类需要LayerGroup来管理其图层，我们将在`app/toolkit/map.py`中创建一个MapView方法来分配一个LayerGroup：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We then link the two together as additional code in the MapView''s `__init__`
    method. Since the renderer requires a width and a height in pixels before it can
    be created, we schedule MapView to create it shortly after startup (because Tkinter
    won''t know how much space is required for the various widgets before startup):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在MapView的`__init__`方法中添加了这两个组件的链接作为额外的代码。由于渲染器在创建之前需要像素宽度和高度，我们安排MapView在启动后不久创建它（因为Tkinter在启动前不知道各种小部件需要多少空间）：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Requesting to render a map
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 请求渲染地图
- en: 'Whenever the MapView widget wants to render a whole new map with all visible
    layers, it calls on this method, and does so in a separate thread in order to
    not freeze up the application while waiting for the results. It also updates the
    status bar on its activities and sets the horizontal scale status based on the
    new zoom level. Afterwards, it has to update the image that is placed on the viewable
    Tkinter Canvas:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当MapView小部件想要渲染包含所有可见图层的整个新地图时，它会调用此方法，并在单独的线程中这样做，以避免在等待结果时冻结应用程序。它还会更新状态栏上的活动状态，并根据新的缩放级别设置水平比例状态。之后，它必须更新放置在可查看Tkinter
    Canvas上的图像：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Resizing the map in proportion to window resizing
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按比例调整地图大小以适应窗口大小
- en: 'If the user changes the application window size from the original startup size,
    we need to resize the MapView''s renderer accordingly. We tell it to resize only
    after one-third of a second after the user has stopped resizing the window, because
    Tkinter''s resize event is triggered continuously during the process. What is
    important in the event of such a resize is that the coordinate system is changed
    accordingly to map the new image dimensions; fortunately for us, our PyAgg Canvas
    automatically updates and locks the aspect ratio on the drawing transform for
    us when resizing:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户更改应用程序窗口大小为原始启动大小，我们需要相应地调整MapView的渲染器大小。我们告诉它只在用户停止调整窗口大小后一秒内调整大小，因为Tkinter的调整大小事件在过程中会连续触发。在这种情况下，重要的是坐标系统会相应地改变，以映射新的图像尺寸；幸运的是，我们的PyAgg
    Canvas在调整大小时会自动更新并锁定绘图变换的纵横比：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The LayersPane as a LayerGroup
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LayersPane作为一个图层组
- en: 'With a basic Map widget capable of rendering, we move onto adding data to the
    map, which we then can view in our application''s layers pane. The LayersPane
    widget is merely a visual representation of the sequence of layers in its connected
    LayerGroup class. Therefore, the LayersPane class in the `app/toolkit/layers.py`
    file needs a method to bind it to a LayerGroup:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们有了能够渲染的基本地图小部件后，我们继续向地图添加数据，然后我们可以在应用程序的图层面板中查看这些数据。LayersPane小部件仅仅是其连接的LayerGroup类中图层序列的视觉表示。因此，`app/toolkit/layers.py`文件中的LayersPane类需要一个方法将其绑定到LayerGroup：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Adding layers
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加图层
- en: We will now create an `add_layer` method to the LayersPane class in `app/toolkit/layers.py`.
    To make it flexible, we allow it to add a layer either from a file path or from
    an already loaded data object.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在`app/toolkit/layers.py`文件中的LayersPane类中创建一个`add_layer`方法。为了使其灵活，我们允许它从文件路径或已加载的数据对象中添加一个图层。
- en: If it detects a file path, it first runs a `from_filepath` function, where it
    decides whether to create a vector or raster data class, tells our dispatch module
    to use this data class to load the file path in a background thread, and schedules
    our application to check the results queue every 100 ms to see whether the loading
    is done.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它检测到一个文件路径，它首先运行一个 `from_filepath` 函数，其中它决定是否创建一个矢量或栅格数据类，告诉我们的调度模块使用这个数据类在后台线程中加载文件路径，并安排我们的应用程序每100毫秒检查一次结果队列，以查看是否加载完成。
- en: Once loaded or if given an already loaded data object, it goes straight to adding
    the layer with the `from_loaded()` function. This creates a VectorLayer or RasterLayer
    capable of rendering itself, adds a representation of that layer responsive to
    right-click events in the LayersPane (more on this in the next section), and asks
    the dispatch to render the layer as an image and update the MapView widget(s)
    to which it is connected. If the new layer is the only one currently loaded in
    the LayersPanel, then we automatically zoom to its bounding box so that the user
    gets an immediate look at the data.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦加载或提供了一个已加载的数据对象，它就会直接使用 `from_loaded()` 函数添加图层。这创建了一个能够渲染自己的 VectorLayer
    或 RasterLayer，并在 `LayersPane` 中添加了一个对右键事件做出响应的图层表示（更多内容将在下一节中介绍），并要求调度将图层渲染为图像并更新与之连接的
    MapView 小部件。如果新图层是当前在 `LayersPanel` 中加载的唯一图层，那么我们将自动缩放到其边界框，以便用户可以立即查看数据。
- en: 'Here is the code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是代码：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Editing layers in the LayersPane widget
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 `LayersPane` 小部件中编辑图层
- en: 'Now that we can add layers to the LayersPane, we also want to be able to play
    around with the layers. A layer is represented as a LayerItem widget, which we
    have yet to define. We give the LayerItem a delete button on the right side, and
    a checkbox on the left side to toggle its visibility as shown in the following
    diagram:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以向 `LayersPane` 添加图层，我们还想能够对图层进行一些操作。图层表示为一个 `LayerItem` 小部件，我们尚未定义它。我们在右侧为
    `LayerItem` 添加一个删除按钮，并在左侧添加一个复选框来切换其可见性，如图所示：
- en: '![Editing layers in the LayersPane widget](img/5407OS_04_02.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![在 `LayersPane` 小部件中编辑图层](img/5407OS_04_02.jpg)'
- en: 'The delete button is going to need an icon so let''s start by getting one of
    those:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 删除按钮将需要一个图标，所以让我们先获取一个：
- en: Go to an icon website such as [www.iconarchive.com](http://www.iconarchive.com)
    or [http://www.flaticon.com](http://www.flaticon.com).
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往图标网站，例如 [www.iconarchive.com](http://www.iconarchive.com) 或 [http://www.flaticon.com](http://www.flaticon.com)。
- en: Search for and choose an icon that you like.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索并选择您喜欢的图标。
- en: Save it as `delete_layer.png` with 32 pixel size and place it in your `app/icons`
    folder.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其保存为 `delete_layer.png`，大小为32像素，并将其放置在您的 `app/icons` 文件夹中。
- en: 'We also define how to rename a layer''s name, which temporarily adds a Tkinter
    entry widget over the layer''s name display so the user can alter the name and
    press *Return* to accept or *ESC* to cancel. Now make the `LayerItem` class in
    `app/toolkit/layers.py` using the following code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了如何重命名图层的名称，它暂时在图层名称显示上方添加一个 Tkinter 输入小部件，以便用户可以更改名称并按 *Return* 键接受或按
    *ESC* 键取消。现在使用以下代码在 `app/toolkit/layers.py` 中创建 `LayerItem` 类：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `LayerItem` class''s delete button and visibility checkbox in the previous
    code both called on methods in the parent LayersPane to do the work, because the
    LayersPane''s connected MapCanvas need updating afterwards. Therefore, let''s
    add these methods to the LayersPane. We also need a way to specify the function
    to be run when right-clicking any of the layers in the LayersPane:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`LayerItem` 类的删除按钮和前一个代码中的可见性复选框都调用了父级 `LayersPane` 中的方法来完成工作，因为 `LayersPane`
    的连接 `MapCanvas` 需要在之后进行更新。因此，让我们将这些方法添加到 `LayersPane` 中。我们还需要一种方法来指定在 `LayersPane`
    中右键点击任何图层时要运行的功能：'
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Click-and-drag to rearrange the layer sequence
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 点击并拖动以重新排列图层顺序
- en: A slightly more complicated procedure is to let the user rearrange the drawing
    order of the LayerItems in the LayersPane by clicking and dragging them to a new
    position. It is an essential feature of the layered nature of any GIS software,
    but unfortunately the Tkinter GUI framework does not provide us with any drag-and-drop
    shortcuts, so we must build it from scratch. We keep it simple and only allow
    one layer to be moved at a time.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一个稍微复杂一些的程序是让用户通过点击并拖动将 `LayersPane` 中 `LayerItems` 的绘制顺序重新排列到新位置。这是任何 GIS 软件分层性质的一个基本功能，但不幸的是，Tkinter
    GUI 框架没有为我们提供任何拖放快捷方式，因此我们必须从头开始构建。我们使其保持简单，并且一次只允许移动一个图层。
- en: 'To rearrange a layer in the list, we first need to listen for an event where
    the user clicks a LayerItem. In such an event, we remember the position of the
    layer that we want to move and change the cursor to indicate that a drag and drop
    is underway. When the user releases the mouse-click, we loop through the screen
    coordinates of all the LayerItem widgets to detect the layer position at which
    the mouse was released. Note that the index position of the layer that is rendered
    on top of all others is the first one in the list of LayerItems, but is the last
    one in the sequence of layers in the LayerGroup. We add this listening behavior
    in the LayerItem''s `__init__` method:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要在列表中重新排列图层，我们首先需要监听用户点击LayerItem的事件。在这样的事件中，我们记住我们想要移动的图层的位置，并将光标更改为指示正在进行拖放操作。当用户释放鼠标点击时，我们遍历所有LayerItem小部件的屏幕坐标，以检测鼠标释放时的图层位置。请注意，渲染在所有其他图层之上的图层的索引位置是列表中的第一个，但在LayerGroup的图层序列中是最后一个。我们在LayerItem的`__init__`方法中添加了这种监听行为：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After the user has interacted with the LayersPane to tell it where to move
    a layer, we tell its associated LayerGroup to rearrange the layer sequence based
    on the "from and to" positions. We then tell all of the MapCanvas connected to
    that LayerGroup to update their drawing order and the image being displayed. We
    must define this method in the `LayersPane` class:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户与LayersPane交互以告知其移动图层位置后，我们告诉其关联的LayerGroup根据“从”和“到”位置重新排列图层顺序。然后我们告诉所有连接到该LayerGroup的MapCanvas更新它们的绘制顺序和显示的图像。我们必须在`LayersPane`类中定义此方法：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Zooming the map image
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缩放地图图像
- en: 'At this point, we can add and remove layers to and from the map and rearrange
    their sequence, but we still cannot interact with the map itself. Here comes one
    of the great things of making our own application. One thing that users may find
    difficult with existing GIS software is that they have to choose between one of
    two modes of interacting with the map: one is the **pan** mode so that clicking
    and dragging the mouse moves the map accordingly, and the other is the **rectangle-zoom**
    mode where click and drag defines the area to zoom to.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以向地图添加和删除图层，并重新排列它们的顺序，但我们仍然不能与地图本身交互。这正是自己制作应用程序的一大优点之一。用户可能会发现，与现有的GIS软件相比，他们必须在这两种地图交互模式之间做出选择：一种是**平移**模式，点击并拖动鼠标会相应地移动地图；另一种是**矩形缩放**模式，点击并拖动定义要缩放的区域。
- en: Switching between these two modes is not very conducive to map exploration which
    is often more of a dynamic and iterative process, involving simultaneous use of
    zooming and panning when using Google Maps. Now that we have the power to decide,
    let's combine zoom and pan by controlling them with double clicks and click and
    drag, respectively.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种模式之间切换不利于地图探索，而地图探索通常是一个更动态和迭代的进程，涉及在Google Maps中使用时同时使用缩放和平移。现在我们有了决定权，让我们通过分别用双击和点击拖动来控制它们，将缩放和平移结合起来。
- en: 'The actual zooming of the map is done by asking the MapCanvas to redraw the
    map at the given zoom level. We bind a 2x zoom factor method centered on the mouse
    to events where the user double clicks on the map. We give such zooming a one-third
    of a second lag after the user stops clicking so that the user can double click
    many times in a row for extra large zoom without overwhelming the application
    to render multiple incremental zoom images. Each time a zoom level is changed,
    we also ask to update the status bar''s zoom unit scale, which is given to us
    by the PyAgg rendering canvas. All of this listening behavior we add to the MapView''s
    `__init__` method, inside `app/toolkit/map.py`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 地图的实际缩放是通过让MapCanvas在给定的缩放级别重新绘制地图来完成的。我们将一个以鼠标为中心的2倍缩放因子方法绑定到用户在地图上双击的事件上。当用户停止点击后，我们给这种缩放一个三分之一的秒延迟，这样用户就可以连续多次双击以实现更大的缩放，而不会使应用程序渲染多个增量缩放图像过度繁忙。每次缩放级别改变时，我们也会要求更新状态栏的缩放单位比例，这是由PyAgg渲染画布提供的。我们添加的所有这些监听行为都在`app/toolkit/map.py`文件中的MapView的`__init__`方法内部：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Map panning and one-time rectangle zoom
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 地图平移和一次性矩形缩放
- en: 'Panning the map is relatively easy since the rendered map image is simply an
    image placed inside a Tkinter scrollable Canvas widget. The rendered map image
    is always placed at the Tkinter Canvas'' [0,0] coordinates in the top-left corner,
    but when we pan the map, we make the image start following the mouse. After we
    let go, the renderer begins rendering a new map by offsetting the MapCanvas''
    PyAgg coordinate system and rerendering the map. We also allow for an alternative
    zoom mode that uses these click and release events to perform a conventional rectangle
    zoom, along with the visual guide of Tkinter''s built-in canvas rectangle drawing.
    This rectangle zoom mode should only be as a one-time event that defaults back
    to panning, since rectangle zoom is relatively rarely needed. To indicate when
    we are in rectangle zoom mode, we also replace the cursor with something like
    a magnifying glass icon whenever it is over the MapView widget, so you will need
    to find and save a `rect_zoom.png` image to `app/icons`. Moving the mouse over
    the map generally should also display the mouse coordinates in the status bar.
    We define this in the `__init__` method of the MapView widget, in `app/toolkit/map.py`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动地图相对简单，因为渲染的地图图像只是一个放置在 Tkinter 可滚动 Canvas 小部件内的图像。渲染的地图图像始终放置在 Tkinter Canvas
    的 [0,0] 坐标，即左上角，但当我们平移地图时，我们会让图像开始跟随鼠标。在我们松开鼠标后，渲染器开始通过偏移 MapCanvas 的 PyAgg 坐标系并重新渲染地图来渲染新的地图。我们还允许使用这些点击和释放事件来执行传统的矩形缩放，并配合
    Tkinter 内置的画布矩形绘制视觉引导。这种矩形缩放模式应该只作为一次事件，默认回到平移模式，因为矩形缩放相对很少需要。为了指示我们处于矩形缩放模式，我们还将在鼠标悬停在
    MapView 小部件上时，将光标替换为类似放大镜图标的东西，因此您需要找到并保存一个 `rect_zoom.png` 图像到 `app/icons` 目录。将鼠标移到地图上通常也应该在状态栏中显示鼠标坐标。我们在
    `app/toolkit/map.py` 文件中的 MapView 小部件的 `__init__` 方法中定义了这一点：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: A navigation toolbar
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导航工具栏
- en: 'In order to activate one-time rectangle zoom, we create a navigation toolbar
    in the `app/toolkit/toolbars.py` file that has to be connected to a MapView, and
    give it a button that simply turns on the one-time zoom mode of its connected
    MapView. While we are at it, we also create a toolbar button to zoom to the global
    bounding box of all of the layers in the MapView''s `layergroup`. Remember to
    find and save icons for these two new buttons, `zoom_rect.png` and `zoom_global.png`.
    Refer to the following figure:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了激活一次性的矩形缩放，我们在 `app/toolkit/toolbars.py` 文件中创建了一个导航工具栏，该工具栏必须连接到 MapView，并给它一个按钮，该按钮简单地打开其连接的
    MapView 的一次性缩放模式。在此过程中，我们还创建了一个工具栏按钮，用于缩放到 MapView 的 `layergroup` 中所有层的全局边界框。请记住找到并保存这两个新按钮的图标，`zoom_rect.png`
    和 `zoom_global.png`。参见图表：
- en: '![A navigation toolbar](img/5407OS_04_03.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![导航工具栏](img/5407OS_04_03.jpg)'
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The actual zooming calls to the renderer are defined as methods of the MapView
    widget, in `app/toolkit/map.py`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的缩放调用被定义为 MapView 小部件的方法，在 `app/toolkit/map.py` 文件中：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Putting it all together
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整合所有内容
- en: We have now defined all of the necessary building blocks of a basic rendering
    application. These can be used and combined in many different ways. For instance,
    if you want to you can build an application that has a single LayerGroup/LayersPane
    connected with multiple independently zoomable MapViews, to view different locations
    of the same data simultaneously. In this book, we go for a more basic desktop
    GIS look.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经定义了一个基本渲染应用的所有必要构建块。这些可以以许多不同的方式使用和组合。例如，如果您想，您可以构建一个应用程序，它有一个单独的 LayerGroup/LayersPane
    与多个独立可缩放的 MapView 连接，以同时查看相同数据的不同位置。在这本书中，我们选择了更基本的桌面 GIS 外观。
- en: Let's return to our GUI class that we created in [Chapter 3](ch03.html "Chapter 3. Designing
    the Visual Look of Our Application"), *Designing the Visual Look of Our Application*,
    and add more content to its startup phase. First we give the GUI a LayerGroup
    instance to hold our layers and link it to both the MapView and LayersPane widgets
    so they can communicate later on.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们在 [第 3 章](ch03.html "第 3 章。设计应用程序的视觉外观") 中创建的 GUI 类，*设计应用程序的视觉外观*，并在其启动阶段添加更多内容。首先，我们给
    GUI 一个 LayerGroup 实例来保存我们的层，并将其链接到 MapView 和 LayersPane 小部件，以便它们可以在以后进行通信。
- en: We also need a button to add data layers. There are many possible places to
    put such an important button, but for our current application, let's place it
    in the header of the LayersPane widget so that all things related to layers are
    kept logically grouped together. We want this button to have an icon, so let's
    first find and save a suitable icon as `add_layer.png` in the `app/icons` folder.
    Specifically, we want to create a button to add layers, assign it with our icon,
    and place it on the right side of the LayersPane header. When the button is clicked,
    it will run a `selectfiles` function, which opens a Tkinter file selection dialog
    window and adds all the selected files as new layers.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个按钮来添加数据层。有许多可能的位置可以放置这样一个重要的按钮，但就我们当前的应用程序而言，让我们将其放置在 LayersPane 小部件的标题栏中，以便将所有与层相关的内容逻辑上分组在一起。我们希望这个按钮有一个图标，所以让我们首先找到并保存一个合适的图标，将其命名为
    `add_layer.png` 并保存在 `app/icons` 文件夹中。具体来说，我们想要创建一个添加层的按钮，将其与我们的图标关联，并将其放置在 LayersPane
    标题栏的右侧。当按钮被点击时，它将运行一个 `selectfiles` 函数，该函数打开一个 Tkinter 文件选择对话框窗口，并将所有选定的文件作为新层添加。
- en: Loading data from a file may require that we specify the correct text encoding
    of the data. By default, we set it to `utf8`, but the user should be able to customize
    this and other data options in a separate data settings window. We store the data
    options dictionary as an attribute of the GUI class and allow it to be changed
    by user input in the settings window. This settings window is easily defined using
    our `RunToolFrame` template. To allow users to access this settings window, we
    add a data settings button right next to the add layer button. As usual, find
    and download an icon to use for the button, calling it `data_options.png`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件加载数据可能需要我们指定数据的正确文本编码。默认情况下，我们将其设置为 `utf8`，但用户应该能够在一个单独的数据设置窗口中自定义此和其他数据选项。我们将数据选项字典存储为
    GUI 类的属性，并允许用户在设置窗口中更改它。这个设置窗口可以通过我们的 `RunToolFrame` 模板轻松定义。为了允许用户访问这个设置窗口，我们在添加层按钮旁边添加了一个数据设置按钮。像往常一样，找到并下载用于按钮的图标，命名为
    `data_options.png`。
- en: After that, let's create a ribbon tab for visualizing, giving it a button to
    save the contents of our MapView widget to an image file. Remember to find and
    save a `save_image.png` file, so we can give this button an icon. Finally, we
    add the navigation toolbar that we created earlier, hanging in the air in the
    upper part of the MapView.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，让我们创建一个用于可视化的选项卡，给它一个按钮，以便将我们的 MapView 小部件的内容保存到图像文件中。记得找到并保存一个 `save_image.png`
    文件，这样我们就可以给这个按钮添加一个图标。最后，我们添加了之前创建的导航工具栏，将其悬挂在 MapView 的上部。
- en: 'Let''s now add this new code to our GUI class'' `__init__` method, inside `app/builder.py`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将这段新代码添加到我们的 GUI 类的 `__init__` 方法中，位于 `app/builder.py` 文件内：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And that is about it! Your application should now be ready to use for rendering
    map data. Run `guitester.py`, and try to add some data and interact with the map.
    If you have done everything correctly, and, depending on your data, your screen
    should look something like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 大概就是这样！你的应用程序现在应该已经准备好用于渲染地图数据了。运行 `guitester.py`，尝试添加一些数据并与地图进行交互。如果你一切都做得正确，并且根据你的数据，你的屏幕应该看起来像这样：
- en: '![Putting it all together](img/5407OS_04_04.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![将所有内容组合在一起](img/5407OS_04_04.jpg)'
- en: Summary
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has been a fundamental milestone. We built a working geographic
    rendering module based on rearrangable layers in a LayerGroup, created a MapView
    widget for interactive displaying of these map renderings, made a visual LayersPane
    of the layers in our map, and enabled interactive zooming and panning of the MapView.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是一个基本的里程碑。我们基于可重新排列的层在 LayerGroup 中构建了一个工作地理渲染模块，创建了一个用于交互显示这些地图渲染的 MapView
    小部件，制作了我们地图中层的可视化 LayersPane，并启用了 MapView 的交互式缩放和平移。
- en: After following each step, you should now have what looks and feels like a GIS
    data inspecting application. Of course, a more sophisticated GIS needs additional
    methods not only to inspect data, but also to manage and edit data—which is what
    we turn to next.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在遵循每个步骤之后，你现在应该拥有一个看起来和感觉像 GIS 数据检查应用程序的东西。当然，一个更复杂的 GIS 需要额外的功能，不仅用于检查数据，还用于管理和编辑数据——这正是我们接下来要做的。
