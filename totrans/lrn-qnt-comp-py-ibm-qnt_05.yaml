- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Understanding the Qubit
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解量子比特
- en: We are all very familiar with the classical bit, or just the bit, with respect
    to current computer hardware systems. It is the fundamental unit used to compute
    everything from simple mathematical problems, such as addition and multiplication,
    to more complex algorithms that involve a large collection of information.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都非常熟悉经典比特，或者简单地说是比特，在当前的计算机硬件系统中。它是用于计算从简单的数学问题，如加法和乘法，到涉及大量信息的更复杂算法的基本单元。
- en: Quantum computers have a similar fundamental unit called a **quantum bit,**
    or **qubit**, as it is commonly referred to. In this chapter, we will describe
    what a qubit is, both from a mathematical (computational) and a hardware perspective,
    to help you understand how they are used to calculate information. We will cover
    the differences between qubits and bits, particularly regarding how calculations
    are defined. This chapter will then transition from single to multi-qubit states
    and talk about the advantages of multi-qubit states.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 量子计算机有一个类似的基本单元，称为**量子比特**，或**qubit**，这是它的常用称呼。在本章中，我们将从数学（计算）和硬件的角度描述什么是qubit，以帮助您了解它们是如何用于计算信息的。我们将涵盖qubit和比特之间的差异，特别是关于计算是如何定义的。然后，本章将从单量子比特状态过渡到多量子比特状态，并讨论多量子比特状态的优势。
- en: We will also provide an overview of the hardware implementation of a qubit and
    how qubits are used to compute information. Since we will be using the Qiskit
    Runtime service to run our experiments, you will be using the superconducting
    qubit systems that are available to you. The descriptions and calculations are
    hardware independent; much of the information we will cover will apply to most
    of the other available quantum hardware systems.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将概述量子比特的硬件实现以及量子比特是如何用于计算信息的。由于我们将使用Qiskit Runtime服务来运行我们的实验，您将使用可用的超导量子比特系统。描述和计算是硬件无关的；我们将涵盖的大部分信息将适用于大多数其他可用的量子硬件系统。
- en: Finally, we will discuss how quantum systems read, manipulate, and control the
    flow of information to and from a qubit from a classical system.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将讨论量子系统如何从经典系统中读取、操作和控制量子比特的信息流动。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Comparing classical and quantum bits
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较经典比特和量子比特
- en: Visualizing the state vector of a qubit
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视化量子比特的状态向量
- en: Visualizing the state vectors of multiple qubits
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视化多个量子比特的状态向量
- en: Implementing qubits on a superconducting system
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在超导系统中实现量子比特
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, some basic knowledge of computer architecture, basic linear
    algebra, and binary logic might come in handy. Knowledge of how bits are used
    to calculate will be useful but is not a hard requirement as the focus will be
    primarily on the qubit. Here is the source code used throughout this book: [https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition](https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，一些基本的计算机架构知识、基本的线性代数和二进制逻辑可能会很有用。了解比特是如何用于计算的将是有用的，但不是硬性要求，因为重点将主要放在量子比特上。以下是本书中使用的源代码：[https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition](https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition)。
- en: Comparing classical and quantum bits
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较经典比特和量子比特
- en: In this section, we will compare and review the building blocks of a classical
    bit and a few of the operations that are performed on them via classical gates.
    We will then learn about the fundamental unit of a quantum computer, the qubit,
    and how it is similar to the bit, yet due to its quantum computational principles,
    which we learned about in the previous chapter, has a larger computational space
    than the bit.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将比较和回顾经典比特的构建块以及通过经典门对这些构建块执行的一些操作。然后，我们将了解量子计算机的基本单元——量子比特，以及它如何与比特相似，但由于我们在上一章中学到的量子计算原理，它比比特具有更大的计算空间。
- en: Reviewing the classical bit
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾经典比特
- en: Before we delve into what a quantum bit is and how it is used, let’s take a
    brief moment to refresh our memories about the classical bit. Just as the quantum
    bit is the fundamental building block of quantum algorithms, the bit has the same
    role in classical computational systems.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨量子比特是什么以及它是如何被使用之前，让我们花一点时间来回顾一下经典比特。正如量子比特是量子算法的基本构建块一样，比特在经典计算系统中扮演着同样的角色。
- en: In computational systems, the bit is used to define a logical state, often referenced
    as either on or off, true or false, or the most commonly used option, 1 or 0\.
    The transition between states can be applied physically either after it’s triggered
    by an operation, such as the result of an **AND gate**, or as a result of some
    input from an external entity, such as reading from an external data source. It
    is usually represented using transistors, which detect voltage differences and
    usually contain a threshold that determines whether the transistor is in a low
    (0) or high (1) state. The voltage thresholds, usually referred to as **Transistor-Transistor
    Logic** (**TTL**) voltage, are generally between 0 and 0.5 volts to indicate low
    and between 2 and 5 volts to indicate high.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算系统中，比特被用来定义逻辑状态，通常指的是开启或关闭、真或假，或者最常用的选项，1或0。状态的转换可以通过物理方式应用，要么是在操作触发后，例如**AND门**的结果，要么是外部实体输入的结果，例如从外部数据源读取。它通常使用晶体管来表示，晶体管检测电压差异，通常包含一个阈值，用于确定晶体管处于低（0）或高（1）状态。电压阈值，通常称为**晶体管-晶体管逻辑**（**TTL**）电压，通常在0到0.5伏之间表示低，在2到5伏之间表示高。
- en: 'The following diagram illustrates the simple process of a NOT operation being
    conducted on a bit. The bit is first initialized or set to a state, either 0 or
    1\. Then, an operation is performed on the bit and, depending on the result of
    the operation, the bit’s state will either change or remain the same. The information
    is then available to be read and/or stored. In this example, the NOT operation
    would change the state from 0 to 1 or vice versa:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了在比特上执行NOT操作的简单过程。比特首先被初始化或设置为一种状态，要么是0要么是1。然后，对比特执行操作，根据操作的结果，比特的状态将改变或保持不变。然后，信息就可以被读取和/或存储。在这个例子中，NOT操作将状态从0变为1或相反：
- en: '![Figure 5.1 – NOT operation of a bit ](img/B18420_05_01.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – 比特的NOT操作](img/B18420_05_01.png)'
- en: 'Figure 5.1: NOT operation of a bit'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：比特的NOT操作
- en: 'The implementation of a bit can be in various forms: flip flops, TTL, and so
    on. The information can be stored by writing the value to a persistent data repository
    to be read later. Calculations using bits are usually done using a **bitstring**,
    which is a set of individual bits combined to represent a string of 1s and 0s,
    usually noted as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 比特的实现可以有多种形式：触发器、TTL等。信息可以通过将值写入持久数据存储库来存储，以便稍后读取。使用比特的计算通常使用**比特串**进行，它是一组单独的比特组合，用来表示一系列的1和0，通常如下所示：
- en: '![](img/B18420_05_001.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18420_05_001.png)'
- en: This indicates that *x* is a bitstring of 4 bits, where each bit can be either
    `1` or `0`; for example, `0010` or `1101`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明*x*是一个4位的比特串，其中每个比特可以是`1`或`0`；例如，`0010`或`1101`。
- en: 'Calculations using bits are generally done using binary logic. For example,
    let’s say we wanted to add two numbers; say, 2 and 3\. We would simply assign
    the values 2 and 3 to a variable, which is stored in binary. Then, we would add
    the two numbers using binary addition and carry the values, which will result
    in 5, illustrated as follows. Please create a new notebook and enter the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用比特的计算通常使用二进制逻辑。例如，假设我们想要加两个数；比如说，2和3。我们只需将值2和3分配给一个变量，该变量以二进制形式存储。然后，我们使用二进制加法将两个数相加，并传递值，这将得到5，如下所示。请创建一个新的笔记本并输入以下内容：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*So, why did we go through such a simple example?* The point was not to bore
    you with a simple binary calculation; the idea was to provide a refresher about
    the mechanics of what happens at the gate level when computing on a classical
    system. This way, when describing the quantum system, it will help you compare
    and contrast the differences regarding how information is created, calculated,
    and stored. With that, we’ll move on to the next section and describe what a qubit
    is.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*那么，我们为什么要通过这样一个简单的例子呢？* 目的不是让你对简单的二进制计算感到厌烦；目的是提供一个关于在经典系统上计算时门级发生机制的知识更新。这样，在描述量子系统时，它将帮助你比较和对比信息创建、计算和存储方面的差异。有了这个，我们将继续到下一部分，并描述什么是量子比特。'
- en: Understanding the qubit
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解量子比特
- en: Similar to the bit, which we described previously, the qubit is the fundamental
    unit in quantum information science. The qubit is similar to the bit in that it
    can represent the same two states, namely 0 and 1, although a qubit represents
    a quantum state. The value of the qubit can be read. By read, we mean we can measure
    the results, which we covered in *Chapter 4*, *Understanding Basic Quantum Computing
    Principles*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前描述的比特类似，量子比特是量子信息科学中的基本单位。量子比特与比特相似，因为它可以表示相同的状态，即0和1，尽管量子比特表示量子态。量子比特的值是可以读取的。这里的“读取”意味着我们可以测量结果，这我们在
    *第4章*，*理解基本量子计算原理* 中已经讨论过。
- en: They can also be manipulated to derive calculations based on operations performed
    on each qubit. Recall that the state of a bit can be represented by either a 0
    or a 1\. A qubit can also be represented as a complex linear combination of 0
    and 1\. In order to prevent confusion and to differentiate between a bit and a
    qubit, we will use **Dirac notation**, ![](img/B18420_05_004.png) and ![](img/B18420_05_005.png),
    to represent the quantum version of the aforementioned 0 and 1 states, respectively.
    Let’s start by visualizing a few things to help us see the difference between
    the two states.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也可以被操作以推导出基于对每个量子比特执行的操作的计算。回想一下，比特的状态可以用0或1来表示。量子比特也可以表示为0和1的复线性组合。为了防止混淆并区分比特和量子比特，我们将使用
    **狄拉克符号**，![](img/B18420_05_004.png) 和 ![](img/B18420_05_005.png)，来分别表示上述0和1状态的量子版本。让我们先可视化一些东西，以帮助我们看到两种状态之间的差异。
- en: To begin, the state of a qubit is generally represented as an array or a vector
    that describes the computational basis states of the qubit, which, in a **Hilbert
    space**, is often denoted as ![](img/B18420_05_006.png).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，量子比特的状态通常表示为一个数组或向量，它描述了量子比特的计算基态，在 **希尔伯特空间** 中，这通常表示为 ![](img/B18420_05_006.png)。
- en: A Hilbert space is, in essence, a vector space of all possible real and complex
    numbers. Hilbert spaces are often applied in the context of infinite-dimensional
    vector spaces, whereas Euclidean space, for example, refers to a finite-dimensional
    linear space with an inner product.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 希尔伯特空间本质上是一个包含所有可能实数和复数的向量空间。希尔伯特空间通常应用于无限维向量空间中，而欧几里得空间，例如，指的是具有内积的有限维线性空间。
- en: 'The quantum state can be presented as two basis vectors that are orthogonal
    to each other, as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 量子态可以表示为两个相互垂直的基矢量，如下所示：
- en: '![](img/B18420_05_007.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18420_05_007.png)'
- en: 'The second vector is given as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个矢量如下所示：
- en: '![](img/B18420_05_008.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_05_008.png)'
- en: 'As we can see, bits and qubits are similar in that they can represent two basis
    states, in this case, 0 and 1\. Where the qubits differ from classical bits is
    that a qubit is always in a linear combination of basis states, which is to say
    that they are always in a superposition of ![](img/B18420_04_006.png) and ![](img/B18420_02_003.png).
    More formally, this is represented in the following format:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，比特和量子比特在它们可以表示两个基态方面是相似的，在这种情况下，是0和1。量子比特与经典比特的不同之处在于，量子比特总是处于基态的线性组合中，也就是说，它们总是处于
    ![](img/B18420_04_006.png) 和 ![](img/B18420_02_003.png) 的叠加态。更正式地说，这可以用以下格式表示：
- en: '![](img/B18420_05_011.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18420_05_011.png)'
- en: 'From the previous equation, we can say that ![](img/B18420_05_017.png) and
    ![](img/B18420_05_018.png) are complex in that the sum of their magnitudes is
    equal to 1 and each squared coefficient represents the probability amplitude,
    which represents the probability of measuring a ![](img/B18420_05_004.png) or
    a ![](img/B18420_05_005.png), of the corresponding basis state:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的方程中，我们可以看出 ![](img/B18420_05_017.png) 和 ![](img/B18420_05_018.png) 是复杂的，因为它们的幅值之和等于1，每个平方系数代表概率幅值，它代表测量对应基态的
    ![](img/B18420_05_004.png) 或 ![](img/B18420_05_005.png) 的概率：
- en: '![](img/B18420_05_014.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18420_05_014.png)'
- en: Another thing to know about quantum mechanics is that we cannot obtain the values
    of ![](img/B18420_05_017.png) and ![](img/B18420_05_018.png), even when measuring
    the qubit. Measuring a qubit requires a qubit to collapse into one of the basis
    states of 0 or 1.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 关于量子力学，还有一点需要了解，那就是我们无法获得 ![](img/B18420_05_017.png) 和 ![](img/B18420_05_018.png)
    的值，即使是在测量量子比特时。测量量子比特需要量子比特坍缩到0或1的基态之一。
- en: '![](img/B18420_05_017.png) and ![](img/B18420_05_018.png) merely provide some
    probabilistic information as to whether the results would be one or the other,
    but this is not a certainty. This is one of the mysteries of quantum mechanics.
    For now, you can conceptualize measuring a qubit as similar to observing or collapsing
    a spinning coin to reveal whether it is heads or tails. Once it’s been measured,
    or collapsed, you are not able to have the coin *continue* spinning without restarting
    the experiment, so all information is lost. You would have to repeat the full
    operation of spinning the coin again.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B18420_05_017.png]和![img/B18420_05_018.png]仅仅提供了一些关于结果是一还是另一的概率信息，但这并不确定。这是量子力学的一个谜团。目前，你可以将测量量子比特的概念化地理解为观察或折叠一个旋转的硬币以揭示它是正面还是反面。一旦测量过，或者折叠过，你就无法在不重新启动实验的情况下让硬币继续旋转，因此所有信息都会丢失。你必须再次执行旋转硬币的完整操作。'
- en: Visualizing the qubit states can be done using a simple two-dimensional plane,
    where the *x* axis is used to denote the ![](img/B18420_05_004.png) state and
    the *y* axis is used to denote the ![](img/B18420_02_003.png) state. Therefore,
    the vector can be used to represent the probability of each state, which should
    total 1.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用简单的二维平面可以可视化量子比特的状态，其中*x*轴用于表示![img/B18420_05_004.png]状态，而*y*轴用于表示![img/B18420_02_003.png]状态。因此，向量可以用来表示每个状态的概率，这些概率的总和应为1。
- en: In this section, we covered the differences between bits and qubits. In the
    next section, we will learn how to visualize qubits and their states using state
    vectors.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了比特和量子比特之间的区别。在下一节中，我们将学习如何使用状态向量来可视化量子比特及其状态。
- en: Visualizing the state vector of a qubit
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化量子比特的状态向量
- en: Another visual representation of a qubit and its states is the **Bloch sphere**,
    named after the physicist Felix Bloch. The Bloch sphere is an ordinary three-dimensional
    sphere that’s generally used as a geometrical representation of the qubit. By
    this, we mean the sphere can represent a qubit’s state as a point anywhere on
    the surface of the Bloch sphere. As described in the previous chapter, the basis
    states are represented by the north and south poles.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种表示量子比特及其状态的视觉方法是**布洛赫球面**，以物理学家费利克斯·布洛赫命名。布洛赫球面是一个普通的三个维度球面，通常用作量子比特的几何表示。通过这种方式，我们指的是球面可以表示布洛赫球面表面上的任意一点来代表量子比特的状态。正如前一章所描述的，基态由南北两极表示。
- en: Conventionally, the north pole of the Bloch sphere represents the ![](img/B18420_04_006.png)
    state, while the south pole represents the ![](img/B18420_02_003.png) state. Any
    point on the surface of the Bloch sphere can represent the linear combination
    of states as a unit vector from the center (origin) to the surface of the Bloch
    sphere.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，布洛赫球面的北极表示![img/B18420_04_006.png]状态，而南极表示![img/B18420_02_003.png]状态。布洛赫球面上的任何一点都可以表示为从中心（原点）到布洛赫球面表面的单位向量，代表状态的线性组合。
- en: 'Since we have the quantum mechanical constraint that the total probability
    of the vector must equal 1, we get the following formula:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们受到量子力学的约束，即向量的总概率必须等于1，我们得到以下公式：
- en: '![](img/B18420_05_023.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![img/B18420_05_023.png]'
- en: 'The vector can then only rotate around the ![](img/B18420_05_024.png) and ![](img/B18420_05_025.png)
    axes of the Bloch sphere by using the following representation:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，向量只能通过以下表示在布洛赫球面的![img/B18420_05_024.png]和![img/B18420_05_025.png]轴周围旋转：
- en: '![](img/B18420_05_026.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![img/B18420_05_026.png]'
- en: 'Here, ![](img/B18420_05_027.png) (representing the amplitude of the qubit)
    and ![](img/B18420_05_028.png) (representing the phase of the qubit) have the
    values (limits) ![](img/B18420_05_029.png) and ![](img/B18420_05_030.png). What
    this illustrates is that any point on the sphere is unique as long as the values
    of ![](img/B18420_05_027.png) and ![](img/B18420_05_028.png) are themselves unique,
    where ![](img/B18420_05_027.png) represents the colatitude to the *z* axis and
    ![](img/B18420_05_028.png) represents the longitude from the *x* axis. The quantum
    state ![](img/B18420_05_035.png) is set from the initial state ![](img/B18420_05_004.png)
    after the rotations of ![](img/B18420_05_027.png) and ![](img/B18420_05_028.png)
    have been applied, as illustrated in the following diagram:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，![img/B18420_05_027.png](img/B18420_05_027.png)（表示量子比特的振幅）和![img/B18420_05_028.png](img/B18420_05_028.png)（表示量子比特的相位）的值（极限）分别是![img/B18420_05_029.png](img/B18420_05_029.png)和![img/B18420_05_030.png]。这表明，只要![img/B18420_05_027.png](img/B18420_05_027.png)和![img/B18420_05_028.png]的值本身是唯一的，球面上的任何一点都是唯一的，其中![img/B18420_05_027.png]表示指向*z*轴的余纬，![img/B18420_05_028.png]表示从*x*轴起的经度。量子态![img/B18420_05_035.png](img/B18420_05_035.png)是在应用![img/B18420_05_027.png]和![img/B18420_05_028.png]的旋转之后，从初始态![img/B18420_05_004.png](img/B18420_05_004.png)设置的，如下面的图所示：
- en: '![Diagram  Description automatically generated](img/B18420_05_02.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图描述自动生成](img/B18420_05_02.png)'
- en: 'Figure 5.2: Qubit Bloch sphere'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：量子比特布洛赫球
- en: '(image source: https://commons.wikimedia.org/wiki/File: Sphere_bloch.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '（图片来源：https://commons.wikimedia.org/wiki/File: Sphere_bloch.jpg）'
- en: To continue describing a qubit, we will use visuals to help illustrate some
    key concepts that can be seen on the Bloch sphere. This will also help provide
    further hands-on exercises for you.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续描述量子比特，我们将使用视觉来帮助说明一些可以在布洛赫球上看到的关键概念。这也有助于为你提供更多的动手练习。
- en: Visualizing the representation of a qubit
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可视化量子比特的表示
- en: 'In this section, we will visualize the representation of a qubit state using
    two visualization plotters, the **Bloch sphere** and the **qsphere**. We will
    begin by creating the Bloch sphere of a qubit in the initial state of ![](img/B18420_04_006.png)
    so that we can visualize the state vector and phase of a qubit:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用两个可视化绘图器，**布洛赫球**和**qsphere**，来可视化量子比特状态的表示。我们将首先创建初始态![img/B18420_04_006.png](img/B18420_04_006.png)的量子比特的布洛赫球，以便我们可以可视化量子比特的状态向量和相位：
- en: 'Create a new notebook and we’ll start as we would with all our notebooks by
    loading our helper file first. Note, of course, if you wish to reuse the notebook
    from earlier, you can do so and skip this step:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的笔记本，我们就像处理所有我们的笔记本一样，首先加载我们的辅助文件。当然，如果你希望重用之前的笔记本，你可以这样做并跳过此步骤：
- en: '[PRE1]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Next, we will create a simple circuit with just a single qubit and use the visualization
    tools we imported to visualize the qubit state. We’ll import the first one in
    its initial state of ![](img/B18420_04_006.png).
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个只有一个量子比特的简单电路，并使用我们导入的可视化工具来可视化量子比特的状态。我们将导入第一个，其初始状态为![img/B18420_04_006.png](img/B18420_04_006.png)。
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we will run our circuit on the state vector simulator and view the results
    on the Bloch sphere by passing the `statevectorResult` object into the argument
    of the `plot_bloch_multivector` function:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在状态向量模拟器上运行我们的电路，并通过将`statevectorResult`对象传递给`plot_bloch_multivector`函数的参数来在布洛赫球上查看结果：
- en: '[PRE4]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After the preceding cell has finished executing, you should have the state vector
    results printed out on your console as follows.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的单元格执行完毕后，你应该会在你的控制台上看到如下打印出的状态向量结果。
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next, we will display first on a Bloch sphere using the `Statevector` objects
    `draw` function. This function is very similar to that of the visualization method
    we used before, except, in this case, we can include an argument describing which
    sphere to use to display the state vector information. In this example, we are
    using `bloch` to indicate a Bloch sphere; we’ll be using this going forward to
    simplify when bouncing between Bloch sphere and qsphere. Note that we should expect
    to see our state vector in the initial state of ![](img/B18420_04_006.png) since
    we have not performed any operations on the qubit.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将首先使用`Statevector`对象的`draw`函数在布洛赫球上显示。这个函数与我们之前使用的可视化方法非常相似，只不过在这种情况下，我们可以包含一个参数来描述要使用哪个球来显示状态向量信息。在这个例子中，我们使用`bloch`来表示布洛赫球；我们将继续使用它，以便在布洛赫球和qsphere之间切换时简化操作。请注意，我们应该期望看到我们的状态向量在初始态![img/B18420_04_006.png](img/B18420_04_006.png)中，因为我们没有对量子比特执行任何操作。
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output that you will see from the preceding function is the Bloch sphere
    with the qubit state pointed to the north pole or to the ![](img/B18420_04_006.png)
    state, illustrated as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 前面函数的输出将是布洛赫球，量子比特状态指向北极或 ![](img/B18420_04_006.png) 状态，如下所示：
- en: '![Figure 5.3 – Qubit Bloch sphere state vector initialized to  ](img/B18420_05_03.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – 初始化为的量子比特布洛赫球状态向量](img/B18420_05_03.png)'
- en: 'Figure 5.3: Qubit Bloch sphere state vector initialized to ![](img/B18420_04_006.png)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3：量子比特布洛赫球状态向量初始化为 ![](img/B18420_04_006.png)
- en: 'Next, we will display the state vector results on the qsphere. In this visualization,
    you will see the state vector in the same state as the Bloch sphere shown in the
    preceding diagram:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在 qsphere 上显示状态向量结果。在这个可视化中，您将看到状态向量与前面图中显示的布洛赫球处于相同的状态：
- en: '[PRE7]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You will also see that it includes the phase of the state vector represented
    by the color-shaded sphere at the bottom right, as shown in the following output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您还会看到，它包括由右下角的彩色阴影球体表示的状态向量的相位，如下面的输出所示：
- en: '![A picture containing diagram  Description automatically generated](img/B18420_05_04.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![包含图表的图片  描述自动生成](img/B18420_05_04.png)'
- en: 'Figure 5.4: Qubit state vector initialized to ![](img/B18420_04_006.png) with
    phase = 0'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4：量子比特状态向量初始化为 ![](img/B18420_04_006.png) 且相位为 0
- en: From the preceding diagram, note that the state vector at the surface of the
    qsphere is pointed toward the north pole, indicating it is in the state ![](img/B18420_04_006.png).
    It is also shaded in blue to indicate the phase of the qubit; in this case, since
    we did not shift the phase, it is set to the default phase of *0* (blue, as described
    in the legend wheel at the bottom right of the qsphere).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图中可以看出，状态向量在 qsphere 的表面指向北极，表明它处于 ![](img/B18420_04_006.png) 状态。它也被蓝色阴影覆盖，以表示量子比特的相位；在这种情况下，因为我们没有改变相位，所以它被设置为默认相位
    *0*（蓝色，如 qsphere 右下角的图例轮所示）。
- en: 'Note that all images are available in color at the following address: [ADD
    COLOR IMAGE PACK URL]'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有图像都可以在以下地址以彩色形式获取：[ADD COLOR IMAGE PACK URL]
- en: This is to indicate the phase of the state vector. The color chart at the bottom
    right of the preceding diagram is a reference to the phase of the state vector,
    which is currently *0*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了表示状态向量的相位。前面图中右下角的彩色图是状态向量相位的参考，目前为 *0*。
- en: 'Now that we are familiar with the state vector of a qubit, let’s take it out
    for a spin. We’ll start by flipping the vector from the initial state of ![](img/B18420_04_006.png)
    to the state of ![](img/B18420_02_003.png) using the NOT gate and then rerun our
    state vector and plot the results:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了量子比特的状态向量，让我们来实际操作一下。我们将首先使用 NOT 门将向量从初始状态 ![](img/B18420_04_006.png)
    翻转到 ![](img/B18420_02_003.png) 状态，然后重新运行我们的状态向量并绘制结果：
- en: '[PRE8]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you can see, we are now at the ![](img/B18420_02_003.png) state with the
    phase still at **0**, as illustrated in the following diagram:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们现在处于 ![](img/B18420_02_003.png) 状态，相位仍然为 **0**，如下面的图所示：
- en: '![Diagram  Description automatically generated with low confidence](img/B18420_05_05.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图表  描述自动生成，置信度低](img/B18420_05_05.png)'
- en: 'Figure 5.5: Qubit state vector set to ![](img/B18420_02_003.png) with phase
    = 0'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5：量子比特状态向量设置为 ![](img/B18420_02_003.png) 且相位为 0
- en: 'Next, we will place the qubit into superposition by adding a Hadamard gate
    and executing the circuit again. We’ll create a new circuit and include a Hadamard
    gate, as shown in the following code snippet, followed by executing the circuit
    and plotting the Bloch sphere of the state vector results, which indicates the
    position of the state vector. In this case, it is on the equator:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将通过添加一个哈达玛门并再次执行电路来将量子比特置于叠加态。我们将创建一个新的电路，并包括一个哈达玛门，如下面的代码片段所示，然后执行电路并绘制状态向量结果的布洛赫球，这表明状态向量的位置。在这种情况下，它位于赤道：
- en: '[PRE9]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Note that the state vector is a precise linear combination of ![](img/B18420_04_006.png)
    and ![](img/B18420_02_003.png):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，状态向量是 ![](img/B18420_04_006.png) 和 ![](img/B18420_02_003.png) 的精确线性组合：
- en: '![Figure 5.6 – Bloch sphere superposition representation, a linear combination
    of  and  ](img/B18420_05_06.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – 布洛赫球叠加表示，是 和 的线性组合](img/B18420_05_06.png)'
- en: 'Figure 5.6: Bloch sphere superposition representation, a linear combination
    of ![](img/B18420_04_006.png) and ![](img/B18420_02_003.png)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6：布洛赫球叠加表示，是 ![](img/B18420_04_006.png) 和 ![](img/B18420_02_003.png) 的线性组合
- en: Let’s see what this looks like on the qsphere by plotting the state vector results.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过绘制状态向量结果来看看qsphere上的样子。
- en: 'Plot the state vector results on the qsphere:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在qsphere上绘制状态向量结果：
- en: '[PRE10]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can see the output of the previous code snippet in the following diagram:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下图中看到上一段代码片段的输出：
- en: '![Chart  Description automatically generated](img/B18420_05_07.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图表 描述自动生成](img/B18420_05_07.png)'
- en: 'Figure 5.7: Qubit state vector set to a linear combination of ![](img/B18420_04_006.png)
    and ![](img/B18420_02_003.png), superposition'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7：量子比特状态向量设置为![](img/B18420_04_006.png)和![](img/B18420_02_003.png)的线性组合，叠加
- en: The results might seem a little confusing. You may be asking yourself why there
    are two vectors when we only have one qubit and why they are based on the Bloch
    sphere result. *Shouldn’t we only see one?* Well, the difference is that the qsphere
    visualizes something that the Bloch sphere does not; that is, the visual representation
    of the amplitude of each possible state. If you look at the size of the ball on
    the surface of the previous outcome of the qsphere when we executed either the
    ![](img/B18420_04_006.png) or ![](img/B18420_02_003.png) state, the diameter of
    the ball was much larger than the two on the surface of the preceding diagram.
    This is because the amplitude is equal for both ![](img/B18420_04_006.png) and
    ![](img/B18420_02_003.png), so the size is split between the two, whereas in the
    previous examples, the amplitude was purely in one of the two states.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可能有点令人困惑。你可能想知道为什么只有一个量子比特时却有两个向量，以及为什么它们基于Bloch球的结果。*难道我们不应该只看到一个吗？* 好吧，区别在于qsphere可视化的是Bloch球无法显示的内容；即每个可能状态的振幅的视觉表示。如果你观察在执行![](img/B18420_04_006.png)或![](img/B18420_02_003.png)状态时qsphere先前结果的球体大小，你会发现球体的直径比前一张图表面的两个球体大得多。这是因为振幅在这两种状态下是相等的，所以大小被分成了两部分，而在先前的例子中，振幅完全存在于两个状态中的一个。
- en: In this section, we learned that the qubit could represent itself as a bit by
    using the two basis states of 0 and 1\. We also saw that it can be represented
    as a linear combination of the two basis states, that is, the amplitude (longitudinal)
    and phase (latitudinal).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解到量子比特可以通过使用0和1的两个基态来表示自己。我们还看到它可以表示为两个基态的线性组合，即振幅（纵向）和相位（横向）。
- en: It is by leveraging these features that quantum algorithms can provide the potential
    for optimizing computational solutions much more than using classical bits. We
    also saw how to visualize the state of a qubit using two Qiskit visualization
    functions, the Bloch sphere and the qsphere, which provide information such as
    amplitude and phase.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正是通过利用这些特性，量子算法才能提供比使用经典比特更优化的计算解决方案的潜力。我们也看到了如何使用两个Qiskit可视化函数，即Bloch球和qsphere，来可视化量子比特的状态，这些函数提供了诸如振幅和相位等信息。
- en: In the next section, we will look at how multiple qubits are presented and how
    to visualize and plot both their real and imaginary components.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何表示多个量子比特，以及如何可视化并绘制它们的实部和虚部。
- en: Visualizing the state vectors of multiple qubits
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化多个量子比特的状态向量
- en: 'So far, we’ve learned the various ways to represent a qubit, both as a vector
    ![](img/B18420_05_065.png) and visually on a Bloch sphere. We did something similar
    with the qsphere. In this section, we will learn how to represent multiple qubits
    and how to represent them in their general state. We will start by making a slight
    update to the notation. A single qubit is presented as the following vector:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了表示量子比特的各种方法，无论是作为向量![](img/B18420_05_065.png)还是可视化在Bloch球上。我们在qsphere上也做了类似的事情。在本节中，我们将学习如何表示多个量子比特以及如何表示它们的通用状态。我们将首先对符号进行轻微的更新。单个量子比特表示为以下向量：
- en: '![](img/B18420_05_060.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_05_060.png)'
- en: 'We can therefore represent two qubits similarly, in the following form:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以以类似的方式表示两个量子比特，如下所示：
- en: '![](img/B18420_05_061.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_05_061.png)'
- en: 'From the preceding equation, you can see that the state ![](img/B18420_05_065.png)
    is used to represent multiple qubits, versus ![](img/B18420_05_065.png) for single
    qubits. The difference is case sensitive: lowercase for single qubits and uppercase
    for multiple qubits. The probability amplitudes, along with the constraint by
    the normalization of 1, can therefore be represented as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的方程中，你可以看到状态 ![](img/B18420_05_065.png) 用于表示多个量子比特，而 ![](img/B18420_05_065.png)
    用于表示单个量子比特。区别在于大小写：单个量子比特使用小写，多量子比特使用大写。因此，概率振幅以及由归一化约束的 1 可以表示如下：
- en: '![](img/B18420_05_064.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_05_064.png)'
- en: 'Let’s look at an example that comprises two qubits, the first one in the state
    ![](img/B18420_05_065.png), as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个包含两个量子比特的例子，第一个量子比特处于 ![](img/B18420_05_065.png) 状态，如下所示：
- en: '![](img/B18420_05_066.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_05_066.png)'
- en: 'The other qubit, in the state ![](img/B18420_05_067.png), is as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个量子比特，处于 ![](img/B18420_05_067.png) 状态，如下所示：
- en: '![](img/B18420_05_068.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_05_068.png)'
- en: 'Combining the two entails taking the **tensor product**, which is used to describe
    systems of multiple subsystems, of the two qubit states illustrated with the symbol
    ![](img/B18420_05_069.png), as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 结合这两个状态意味着取它们的**张量积**，用于描述多个子系统的系统，用符号 ![](img/B18420_05_069.png) 表示的两个量子比特状态如下：
- en: '![](img/B18420_05_070.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_05_070.png)'
- en: 'Multiplying across, we will get the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉相乘，我们得到以下结果：
- en: '![](img/B18420_05_071.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_05_071.png)'
- en: 'This results in the amplitude vectors, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致振幅向量如下：
- en: '![](img/B18420_05_072.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_05_072.png)'
- en: 'Finally, another way to state multi-qubits by their tensor product is by representing
    them by their product state. Here, the product state of *n* qubits is a vector
    of size 2^n. We’ll use the same two-vector example described previously. The first
    is the *00* state:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过它们的张量积表示多量子比特的另一种方式是通过它们的乘积状态。在这里，*n* 个量子比特的乘积状态是一个大小为 2^n 的向量。我们将使用之前描述的相同两个向量示例。第一个是
    *00* 状态：
- en: '![](img/B18420_05_073.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_05_073.png)'
- en: 'The *01* state is as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*01* 状态如下：'
- en: '![](img/B18420_05_074.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_05_074.png)'
- en: 'The *10* state is as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*10* 状态如下：'
- en: '![](img/B18420_05_075.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_05_075.png)'
- en: 'Lastly, the *11* state is as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*11* 状态如下：
- en: '![](img/B18420_05_076.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_05_076.png)'
- en: The main takeaway from the previous equations is that we can describe two qubits
    individually as two *2 x 1* column vectors. However, when we want to represent
    the joint state of the full system, we represent them as a tensor product, which
    produces the *4 x 1* column vector illustrated previously. This is the mathematical
    representation of the quantum state, also referred to as the computational basis
    state of a two-qubit system.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的方程中，我们可以得出结论，我们可以将两个量子比特分别表示为两个 *2 x 1* 列向量。然而，当我们想要表示整个系统的联合状态时，我们用张量积来表示它们，这产生了之前展示的
    *4 x 1* 列向量。这是量子状态的数学表示，也称为双量子比特系统的计算基态。
- en: In the next section, we’ll briefly discuss the implementation of qubits on the
    IQP systems and also discuss other technologies that are used to implement qubits.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将简要讨论在 IQP 系统上实现量子比特的方法，并讨论其他用于实现量子比特的技术。
- en: Implementing qubits on a superconducting system
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在超导系统中实现量子比特
- en: At the beginning of this chapter, we learned that classical bits can be implemented
    by various platforms that detect differences between voltages or the phase of
    a current, or by the state of a flip flop. Just as a bit has different platforms
    that are used for their implementation, so do qubits.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们了解到经典比特可以通过各种平台实现，这些平台可以检测电压或电流的相位之间的差异，或者通过触发器的状态。正如比特有用于其实现的平台一样，量子比特也是如此。
- en: Some of the more common qubit platforms are **neutral atoms**, **Quantum dots**,
    **Nitrogen-vacancy** (**NV**) centers within diamond, **trapped ions**, and **superconducting
    qubits**. Out of these platforms, it is the superconducting qubits that are used
    on the quantum devices hosted on the IQP. So, in this section, we will cover this
    platform.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一些更常见的量子比特平台包括**中性原子**、**量子点**、钻石中的**氮空位**（**NV**）中心、**俘获离子**和**超导量子比特**。在这些平台中，用于
    IQP 上量子设备的超导量子比特被使用。因此，在本节中，我们将介绍这个平台。
- en: If you want to learn more about the other platforms, you can review the book
    *Quantum Computation and Quantum Information* by Michael Nielsen and Isaac Chuang,
    which covers a lot of these in some detail.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于其他平台的信息，你可以阅读迈克尔·尼尔森和伊萨克·丘恩的书籍《量子计算与量子信息》，该书详细介绍了这些内容。
- en: A superconductor is a material made up of a combination of niobium and aluminum
    that has no electrical resistance, but this can only typically be achieved at
    very low temperatures, usually around 20 milli-Kelvin. The electrons along the
    superconductors are therefore used as the basic charge carriers that comprise
    a pair of electrons, more commonly referred to as **Cooper pairs**. This is different
    from other conductors, which generally use single electrons. Talking about the
    specifics of the quantum mechanics or superconducting behavior of the Cooper pairs
    is beyond the scope of this book. However, you can find various references in
    *Appendix A* if you are interested. For now, we can think of superconductors as
    one of the components of the superconducting circuit that makes up the qubit.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 超导体是由铌和铝的混合物制成的材料，它没有电阻，但这通常只能在非常低的温度下实现，通常在 20 毫开尔文左右。因此，超导体上的电子被用作构成一对电子的基本电荷载体，更常见的是称为**库珀对**。这与其他导体不同，其他导体通常使用单个电子。关于库珀对的量子力学或超导行为的细节讨论超出了本书的范围。然而，如果你感兴趣，可以在*附录
    A*中找到各种参考资料。现在，我们可以将超导体视为构成量子比特的超导电路的组成部分之一。
- en: Now that we have covered how to visualize the state of a qubit using the state
    vector simulator and display it on both a Bloch sphere and a qsphere, we can move
    on to the next chapter, which describes all the qubit gate operators and what
    effects they have on each other.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了如何使用状态向量模拟器来可视化量子比特的状态，并在 Bloch 球和 qsphere 上显示它，我们可以继续到下一章，该章将描述所有量子比特门操作符及其相互之间的作用。
- en: Summary
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned the difference between bits and qubits and how
    they are represented, both mathematically and visually. You also saw the difference
    between how single and multi-qubit systems are represented, including their mathematical
    representations, as well as how they are constructed and operated on. We also
    covered how to visualize the qubit as a Bloch sphere and a qsphere.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了比特和量子比特之间的区别以及它们的数学和视觉表示方式。你还看到了单量子比特和多量子比特系统是如何表示的，包括它们的数学表示，以及它们的构建和操作方式。我们还介绍了如何将量子比特可视化为
    Bloch 球和 qsphere。
- en: You now have the skills to represent the vector states of single and multiple
    qubits. You also understand the difference between representing multiple qubits
    as separate entities and as part of a complete system by using the tensor products
    of the qubits. This will help you to implement and operate the qubits on IBM Quantum
    systems.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在有了表示单量子比特和多量子比特的矢量状态的能力。你也理解了使用量子比特的张量积将多个量子比特表示为单独的实体或作为完整系统的一部分之间的区别。这将帮助你实现和操作
    IBM 量子系统上的量子比特。
- en: In the next chapter, we will cover how to perform operations on single and multiple
    qubits and how those operations are triggered on the qubits of the real devices.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍如何对单量子比特和多量子比特进行操作，以及这些操作如何在真实设备上的量子比特上触发。
- en: Questions
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which would provide visual information about the phase of a qubit—the Bloch
    sphere or the qsphere?
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个会提供关于量子比特相位的视觉信息——Bloch 球还是 qsphere？
- en: Can you visualize multiple qubits on the Bloch sphere? If not, then describe
    why you wouldn’t.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能在 Bloch 球上可视化多个量子比特吗？如果不能，请描述你为什么不能。
- en: Write out the tensor product of three qubit states in all their forms.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将三个量子比特状态的张量积以所有形式写出来。
- en: What is the probability amplitude of a three-qubit system?
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三量子比特系统的概率振幅是什么？
- en: Join us on Discord
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/3FyN1](https://packt.link/3FyN1)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/3FyN1](https://packt.link/3FyN1)'
- en: '![](img/QR_Code2617625996838265933.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code2617625996838265933.png)'
