- en: Chapter 8. Automating Analysis with Processing Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to use the graphical modeler from the QGIS
    Processing framework to create models and automate complex analysis tasks. We
    will cover all the necessary steps starting from creating the model and ending
    up with sharing the model with other users.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will go through the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The QGIS Processing framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Graphical modeler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding inputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filling in model metadata and saving
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editing models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The QGIS Processing framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The QGIS Processing framework (formerly SEXTANTE) is an QGIS core plugin that
    implements a powerful analysis and geoprocessing environment and provides a user-friendly
    interface for various native QGIS algorithms and third-party analysis software,
    such as GRASS, SAGA, Orfeo ToolBox, and many others.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Refer to the QGIS user guide at [http://docs.qgis.org/testing/en/docs/user_manual/processing/intro.html](http://docs.qgis.org/testing/en/docs/user_manual/processing/intro.html)
    if you want more information about the QGIS Processing framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Processing user interface consists of four main components. Each of them
    allows you to run algorithms in a different way. Deciding which component to use
    depends on the task and type of analysis. As the Processing plugin is activated
    by default, we can access all of its components and functionality, except the
    batch processing interface, from the Processing menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The QGIS Processing framework](img/image00498.jpeg) Toolbox: This is the
    main Processing GUI element. It provides access to all available algorithms (grouped
    by provider or purpose) and allows us to run them in single-pass and batch modes.
    The Processing Toolbox has two modes: simplified (default) and advanced. In simplified
    mode, all algorithms are placed in predefined groups and have user-friendly names,
    with the aim of helping novice users find the necessary tools. In advanced mode,
    algorithms are grouped by *providers*. Each provider represents some analysis
    package or program, for example, GRASS, Orfeo ToolBox, and so on. Also, in advanced
    mode, we have access to a larger number of algorithms, as some special providers
    are available only in this mode. In the upcoming sections, we will assume that
    the toolbox is used in advanced mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To activate advanced mode, just select the **Advanced** interface from the combobox
    at the bottom of the Processing toolbox.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![The QGIS Processing framework](img/image00499.jpeg)**history manager**: This
    stores information about all executed algorithms and their parameters so that,
    if necessary, one can easily reproduce a past action. Also, all errors, warnings,
    and information messages are displayed here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**batch processing interface**: This is used to run individual algorithms on
    multiple datasets. This interface is accessible only from the Processing Toolbox
    and is not available in the Processing menu.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![The QGIS Processing framework](img/image00500.jpeg)**graphical modeler**:
    This is used to create new algorithms by combining existing ones into a single
    workflow. It allows us to easily automate a complex analysis that involves several
    steps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will see how to use the Processing Graphical modeler
    and create our own models to automate analysis tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Graphical Modeler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already seen in previous chapters, even a simple analysis may require
    several steps. In real-life applications, much more complex tasks exist, and they
    involve and combine different processes of analysis. Running them manually is
    a time-consuming process, and it may take hours to complete. Things become even
    worse and complicated when you need to run this analysis several times with different
    input data or use the same data with different settings.
  prefs: []
  type: TYPE_NORMAL
- en: This is where the QGIS Processing framework comes to help. It allows us to automate
    repeated tasks and create new complex algorithms that involve different types
    of data processing. With the help of the Graphical modeler from the Processing
    toolbox, we can easily create our own algorithms by combining existing algorithms.
    The created model can be executed like any other Processing algorithm, and even
    used as part of another, more complex model.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two common ways of opening the Graphical Modeler:'
  prefs: []
  type: TYPE_NORMAL
- en: From the menu, go to **Processing** | **Graphical Modeler...**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the Processing Toolbox. Ensure that the Processing Toolbox uses the **Advanced**
    mode. Go to the **Models** group and expand it. In the **Tools** subgroup, find
    the **Create new model** item and double-click on it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Any of these methods will open the **Processing modeler** window, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical Modeler](img/image00501.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The **Processing modeler** window can be divided into the following main areas:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Toolbar**: This provides some useful actions, such as opening existing models,
    saving and exporting a model, the help editor, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inputs and algorithm trees**: These are located on the left side of the window
    and consist of two tabs: one contains the available inputs, and the second contains
    the available algorithms. It is worth mentioning that the **Algorithm** tab supports
    the same modes for displays of algorithms as the toolbox: simplified and advanced.
    However, note that there are no switches in this tab for changing the display
    mode. If you need to change it, you should do it in the toolbox before opening
    the modeler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Working area**: This is used to display the model structure. Here, we will
    place our building blocks and connect them to each other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The creation of the model can be divided into two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Defining the input: This means that we need to specify which data is necessary
    for analysis. All items of input that we define here will be represented later
    as algorithm parameters, and the user will be able to set them according to their
    requirements.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Defining the workflow: At this step, we establish links between input items
    and algorithms. In other words, we determine how each algorithm in the model will
    use input and output from other algorithms.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's create a model to generate density maps from a point vector layer using
    the binning technique, which was described in the *Mapping density with a hexagonal
    grid* section of [Chapter 5](part0043.xhtml#aid-190861 "Chapter 5. Answering Questions
    with Density Analysis"), *Answering Questions with Density Analysis*. To make
    this example more useful, we will create a model that generates not only a hexagonal
    density grid, but also a square density grid. This is done so that you can later
    compare the results and choose the one that you like more.
  prefs: []
  type: TYPE_NORMAL
- en: Adding inputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step of model creation is defining the input necessary for it. To
    do this, we should go over all the algorithms of the process that we want to automate
    and find out which input items are necessary. It is necessary to remember that
    some algorithms may not need separate inputs. They will use only results obtained
    in some previous steps, or in other words, the output of other algorithms. Also,
    some inputs may not be important and can be hardcoded in the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Processing modeler** supports the following kinds of input, which can
    be found in the **Inputs** tab on the left side of the modeler window:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Number: This is used for integer and floating-point values. When adding it,
    it is necessary to specify the minimum and maximum values allowed as well as a
    default value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'String: This is a string literal. There is only one additional setting, namely
    the default value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Boolean: This is a boolean value, usually used as a checkbox. It is necessary
    to specify the default state: checked or unchecked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Extent: This represents a geographical extent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Vector layer: This is used for vector layers. If necessary, it is possible
    to limit the supported geometry types to one of the available types and make this
    input optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Raster layer: This represents the raster layer in GDAL-supported format. It
    can be optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Table: This is used for geometryless tables, for example, DBF files. It can
    be optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Table field: This represents a field of the layer attribute table or geometryless
    table. It is necessary to specify the parent layer from which this field will
    be fetched.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'File: This is used to represent files and directories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To add an input, double-click on its name. A **Parameter definition** dialog
    will open. Its content depends on the input type, but common for all input types
    is a **Parameter name** field, where it is necessary to specify at least the name
    of the input. This text will be used as a caption for the corresponding field
    when the model will be executed. All other fields are different for different
    input.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also use the drag-and-drop method from the inputs/algorithms tree to
    the modeler work area when adding inputs or algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Once all the settings are specified, click on the **OK** button. A new input
    block will be added to the modeler's working area.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with adding input for our model. The first input is obvious; it
    is a vector layer to create a density map for. Double-click on the **Vector layer**
    item in the **Inputs** tab of the **Processing modeler** window to open the **Parameter
    definition** dialog, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding inputs](img/image00502.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Enter a name in **Parameter name**, for example, `Point layer`. As we don't
    want to see all available layers as input later, and search for a required layer
    through a long list, we can limit the supported geometry type by choosing the
    **Point** geometry type in the **Shape type** combobox. Finally, as this input
    is required, we leave the **Required** field as **Yes**. Click on the **OK** button
    to add the input to the modeler working area.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to make our final density map more detailed or more general, depending
    on our requirements, we need a way to adjust the cell size. So, double-click on
    the **Number** item in the **Inputs** tab to add another input.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding inputs](img/image00503.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Enter `Vertical grid spacing` as **Parameter name** as shown in the preceding
    screenshot. We can leave all other fields untouched, but it is better to specify
    them too. This should be done to prevent wrong input from users. We should now
    keep in mind the fact that different layers may have different coordinate reference
    systems (CRS). As a result, we will probably have different distance units. So,
    our numeric input should allow the user to enter values suitable for layers in
    geographic CRS (degrees) and projected CRS (meters, feet, and so on). That's why
    we use `0` as the minimum value and `99999999.999999` as the maximum value. These
    values allow us to change the cell size over a wide range, irrespective of the
    CRS used. Enter any reasonable value as **Default value** and click on **OK**
    when you're done.
  prefs: []
  type: TYPE_NORMAL
- en: As cell sizes in the horizontal and vertical directions can be different, we
    need to create another numeric parameter called `Horizontal grid spacing` using
    the same settings as you saw before.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you always need the same spacing in both the horizontal and vertical directions,
    it is better to use only one input parameter, as a single parameter can be used
    multiple times as an input in the same algorithm, or even in different algorithms.
    Later, we can adjust our model to use only one numeric parameter to define the
    grid spacing.
  prefs: []
  type: TYPE_NORMAL
- en: As you may remember from the *Mapping density with a hexagonal grid* section
    of [Chapter 5](part0043.xhtml#aid-190861 "Chapter 5. Answering Questions with
    Density Analysis"), *Answering Questions with Density Analysis*, when using a
    `Create grid` algorithm, it is necessary to specify the desired grid extent, and
    we take this extent from our input layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, for designing our model, we have two options:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the input for the grid extent. This will make our model a bit more complex,
    as we need to specify the grid extent each time we use the model, instead of specifying
    just the layer. But this option also brings more flexibility, because by having
    a separate input for the grid extent, we will be able to generate density maps
    not only for the entire layer but also for a specified region inside it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the extent from the input layer. In this case, our model will be simpler
    for users, as all they need to do is to define the layer and grid cell size. But
    on the other hand, the density map will be generated for the entire layer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As the most common use case is a density map for the entire layer, we choose
    the second option. The grid extent should be calculated automatically from the
    input point layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we have just defined almost all of the necessary input for our model: the
    input layer, and two numbers that represent the grid cell size in the horizontal
    and vertical directions. There is only one undefined input—the grid extent. You
    will learn how to extract it from the input layer in the next section, as this
    is closely related to workflow definition.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When all the input items are in place, we can start implementing a workflow.
    All the available algorithms can be found in the **Algorithms** tab on the left
    side of the modeler window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Workflow implementation is very similar to manual execution of all steps of
    analysis: we add algorithms one by one, choosing the correct input and, if necessary,
    defining the output. While the modeler allows us to add parameters and algorithms
    in any random order, it is better to add algorithms in the same order in which
    they should be executed to avoid confusion. Let''s start!'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may remember, we did not add a separate input for grid extent, and you
    may be curious to know how we will extract it from the point layer in a format
    compatible with the modeler input. The answer is simple: we will use special tools,
    which are so-called modeler-only tools. What are these? Well, all the algorithms
    that are available exclusively in the **Processing modeler** are not available
    in the toolbox. Basically, these are helper tools that can be really useful in
    different models, for example, a simple calculator or a value converter. You can
    find these tools in the **Algorithms** tab (as they are also algorithms) within
    the Modeler-only tools group.'
  prefs: []
  type: TYPE_NORMAL
- en: Right now, we need a **Vector layer bounds** tool, which takes a vector layer
    as the input and returns its extent as the output.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Besides the extent, this tool also returns four numeric values: minimum and
    maximum *x* coordinates, as well as minimum and maximum *y* coordinates. You may
    use these values as input for different algorithms.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This output value can then be used as the input in any algorithm that requires
    the extent as the input. Find the **Vector layer bounds** algorithm by typing
    its name in the filter field, and double-click on it to open the algorithm definition
    dialog as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the workflow](img/image00504.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The dialog is very simple. We will discuss definition dialogs a bit later. Right
    now, we just select our previously added **Point layer** input in the **Layer**
    combobox and click on the **OK** button to close the dialog and add the algorithm
    to the modeler working area. Now that all preparation steps are done, we are ready
    to implement the main workflow.
  prefs: []
  type: TYPE_NORMAL
- en: The first step in our analysis is grid generation, so switch to the **Algorithms**
    tab, find the `Create grid` algorithm by typing its name in the filter field,
    and double-click on it to open the algorithm definition dialog.
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the workflow](img/image00505.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the algorithm definition dialog has almost the same content
    as the algorithm dialog opened from the toolbox. The main differences are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: There is no **Log** tab where the algorithm reports its execution progress and
    other information. As the algorithm is not executed right now, this tab is not
    needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a new **Description** field. It is used to define the algorithm name
    inside the model. By default, this name is the same as the original algorithm
    name. This feature is very handy when the model contains several algorithm blocks
    that represent the same algorithm but use different inputs. In such a case, just
    assign different descriptions to this algorithm, and you will never be lost amid
    them. You will be able to identify their outputs easily.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a new **Parent algorithms** parameter at the bottom of the definition
    dialog, which does not exist when the algorithm is executed from the Processing
    toolbox. As the name implies, this parameter allows us to define parent algorithms
    for the selected algorithm, or in other words, set the algorithms' execution order.
    Parent algorithms will be executed in the specified order and before their children.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By default, when the current algorithm uses the output of another algorithm
    as its input, the latter automatically becomes a parent of the current algorithm,
    and a link between these two algorithms is created. But sometimes, one algorithm
    can depend on another even if it has not used any output from it. Here is a well-known
    example of such a situation: before executing a query against a database layer,
    it is necessary to create the database and the layer.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There is a different approach for selecting inputs and outputs. All values can
    be selected from the list of already available model inputs and outputs, generated
    by algorithms that are already added to the model algorithms. Also, values such
    as numbers, strings, booleans, and table fields can be entered manually in the
    corresponding fields. Note that you cannot change values that are entered manually
    at design time if your model is executed from the toolbox or used as part of another
    model. So, don't hardcode values unless there is an urgent need.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, proceed with the `Create grid` algorithm definition for our model. As we
    will generate two grids—hexagonal and square—using the same algorithm, we need
    to distinguish the algorithm blocks. So, change the **Description** field to `Create
    hexagon grid`. We hardcode the **Grid type** parameter by selecting `Hexagon (polygon)`
    from the combobox, as this is what we need.
  prefs: []
  type: TYPE_NORMAL
- en: In the **Grid extent** combobox, select `'Extent' from algorithm 'Vector layer
    bounds'`. This is the extent of our input layer, so the generated hexagonal grid
    will cover it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the `'Extent' from algorithm 'vector layer bounds'` text, `'Extent'` is the
    name of the output from the algorithm, and `'Vector layer bounds'` is an algorithm
    description from the **Description** field of the corresponding definition dialog.
    So, you can easily detect which output is from which algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: For horizontal and vertical grid spacing, select the previously defined input
    values from the corresponding comboboxes. You may notice that apart from the input
    values defined by us, there are some additional values produced by the **Vector
    layer bounds** algorithm. Ignore them.
  prefs: []
  type: TYPE_NORMAL
- en: Don't enter any text in the **Output** field, as the hexagonal grid generated
    by this algorithm is an intermediate, temporary output and not the final result.
    Temporary outputs will be generated and stored in the temporary directory, but
    will never be added to the QGIS main canvas after model execution. If you want
    to see these intermediate results, it is necessary to turn them into model output
    by entering descriptions for them.
  prefs: []
  type: TYPE_NORMAL
- en: When all parameters have their values assigned, click on the **OK** button to
    add the algorithm to the modeler's working area. You will see that the algorithm
    block is now connected to its inputs. Clicking on the small **+** sign near the
    **In** or **Out** labels will expand a list of inputs and/or outputs, so you can
    verify the correctness of the connections. The second click will collapse them
    back.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add another **Create grid** algorithm. Change its **Description** field to
    `Create square grid`, select `Rectangle (polygon)` as **Grid type**, and set all
    other parameters as we did earlier with hexagon grid generation. Click on the
    **OK** button when you are done. Now, we have two algorithm blocks in the modeler''s
    working area that use the same input as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the workflow](img/image00506.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next algorithm we should add is **Count points in polygon**. Find it in
    the **Algorithms** tab of the modeler window by typing its name in the filter
    field, and double-click on it to open the algorithm definition dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the workflow](img/image00507.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we also edit the **Description** field to be able to distinguish the
    results of processing different grids, for example, `Count points in hexagon grid`.
    If you look at the available choices in the **Polygons** and **Points** comboboxes,
    you will see that both have an identical set of options: `Point layer`, `''Output''
    from algorithm ''Create hexagon grid''`, and `''Output'' from algorithm ''Create
    square grid''`. The first is our previously defined input, and the second and
    third are the results produced by already added **Create grid** algorithms. As
    you can see, we can easily identify the results produced by algorithms, thanks
    to their different descriptions.'
  prefs: []
  type: TYPE_NORMAL
- en: Careful readers may ask, "Why do we see both the items in comboboxes? After
    all, they have different geometry types and we should see only those input items
    that have matching geometry types." Well, this is a current limitation of Processing—the
    modeler does not perform any accurate checks of the input. It always shows all
    of the available inputs with the corresponding type (vector, raster, or geometryless
    table) despite defined restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: So, in the **Polygons** combobox, we need to select the hexagonal grid produced
    by the **Create grid** algorithm (`'Output' from algorithm 'Create hexagon grid'`),
    and in the **Points** combobox, select the previously defined `Point layer` input.
    Leave the **Count field name** field unchanged. This parameter will be used only
    in the next step and can be safely kept hardcoded.
  prefs: []
  type: TYPE_NORMAL
- en: We again leave the **Result** field empty, as the density map produced at this
    stage is a temporary, intermediate result. It may contain empty cells, which should
    be deleted. Finally, press the **OK** button to complete the algorithm definition
    and add it to the modeler working area.
  prefs: []
  type: TYPE_NORMAL
- en: Add another **Count points in polygon** algorithm to create a square density
    map. Set its description to `Count points in square grid`, and as the **Polygon**
    input, select the output from `'Output' from algorithm 'Create square grid'`.
    All other parameters should be the same as in the previous algorithm. Also, keep
    the **Result** field empty.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can add the last algorithm to complete our simple model—**Extract by
    attribute**. With this algorithm, we will clean up our density maps from cells
    that do not contain any useful information. In other words, we will remove empty
    cells.
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the **Extract by attribute** algorithm in the **Algorithms** tab of the
    modeler window by typing its name in the filter field, and double-click on it
    to open the algorithm definition dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the workflow](img/image00508.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As before, we edit the **Description** field to distinguish the same algorithm
    blocks and their output. For the description, we choose `Extract from hexagon
    grid`. In the **Input layer** combobox, we should select the output of the **Count
    points in polygon** algorithm—`'Result' from algorithm 'Count points in hexagon
    grid'`. As we have hardcoded the field name in the previous step, we enter the
    same name in the **Selection attribute** field. Select `!=` (not equal to) from
    the **Operator** combobox and enter `0` in the **Value** field.
  prefs: []
  type: TYPE_NORMAL
- en: As this algorithm will produce a result that we want to use later, it is necessary
    to enter a result description in the **Output** field, for example, `Hexagon density
    map`. Click on the **OK** button to complete the algorithm definition and add
    it to the modeler working area. In addition to the algorithm block, this time,
    an output block will be added too.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, add another **Extract by attribute** algorithm to produce the final
    square density map. Don't forget to adjust the algorithm description, set the
    correct inputs, and specify the output name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, the model elements are placed in a slightly random order, and it
    is difficult to recognize the links between them. To improve readability and organize
    the model in a more structured way, we can drag all the blocks within working
    area. The links between them will be preserved. If necessary, you can also zoom
    in and out with the mouse wheel. Here is what final model may look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the workflow](img/image00509.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: That's all! We just create our first model, and if you have layers loaded in
    QGIS, you can try it out by clicking on the **Run model** button on the toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the workflow](img/image00510.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you see, the model execution dialog has the same look and feel as all other
    Processing algorithms. Input vector layers can be selected from already available
    layers and loaded from the disk. Numerical values can be selected with spinboxes,
    can be accompanied by a calculator, and can maintain the restrictions we set.
  prefs: []
  type: TYPE_NORMAL
- en: But don't close the modeler right now! To fully use our model, run it from the
    toolbox as a batch process, and reuse it in other models, we need to save and
    document it first. That's what we are going to do in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Filling model metadata and saving
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After creating the model, is it necessary to save it on the disk so that Processing
    will be able to load it and register within toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: By default, models are saved in JSON format with the `.model` extension in the
    models subdirectory inside the processing directory in the your QGIS user folder.
    Under Windows, this is usually `C:\Users\login\.qgis2` (`login` here is the name
    of your Windows user) and under Linux, it is `~/.qgis2`. If necessary, you can
    always change the location of the folder using the **Processing settings** dialog.
  prefs: []
  type: TYPE_NORMAL
- en: When Processing starts, it looks for files with the `.model` extension in this
    directory and loads them. Loaded models appear in the toolbox, in the **Models**
    group. Also, they are available in modeler like any other Processing algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, you may get errors if you are loading third-party models. This mainly
    occurs because some algorithms used in a particular model are not available. For
    example, a certain algorithm provider is deactivated from Processing settings,
    or the model requires additional scripts/models, which are not available in your
    Processing. In such cases, read the error message carefully and examine Processing's
    logs to learn which algorithms are missed. Activate or install them and try to
    load the problematic model again.
  prefs: []
  type: TYPE_NORMAL
- en: Before saving the model, it is necessary to define its name and the group where
    it will be placed. This information should be entered in fields above the modeler's
    working area. We choose `Density` maps as the model name and `Binning` as the
    group name. Feel free to choose your own names if you don't like these.
  prefs: []
  type: TYPE_NORMAL
- en: When the model name and group are defined, click on the **Save** button in the
    toolbar and enter the name of the model. You will see a confirmation message when
    the model is saved.
  prefs: []
  type: TYPE_NORMAL
- en: We can close the modeler window right now, but don't rush! It is good practice
    to document your models, that is, describe the input, the actions performed, and
    the final results. Such information will be extremely useful for other users,
    who may want to reuse the model in their own tasks. Also, this metadata will afterwards
    help you recall what is this model is for.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start editing the model metadata, click on the **Edit model help** button
    in the modeler dialog toolbar. A **Help editor** dialog will open, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Filling model metadata and saving](img/image00511.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This dialog is divided into three areas. At the top, there is a preview area.
    Here, the current help contents are displayed so that you can see how the final
    result will look in real-time mode. In the bottom-left part is the elements tree,
    where all help sections are listed, including algorithm description as well as
    parameters, input, and other information. In the bottom-right part, there is an
    editing area. Here, we will enter a description of the corresponding element.
  prefs: []
  type: TYPE_NORMAL
- en: To edit the description of the element, select it in the elements list and enter
    text in the **Element description** field. To save the changes, just select another
    element in the elements tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go through all the items in elements tree and enter their descriptions. For
    example, as **Algorithm description**, you can use the following text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Describe all the other fields yourself. Try to be short and, at the same time,
    give as much useful information as possible. Don't explain obvious things—it's
    better to concentrate on important details. For example, in the description of
    the grid spacing inputs, it is worth mentioning that grid spacing should be defined
    in the same distance units as those used by layer. When you're done, click on
    the **OK** button to close the **Help editor** dialog.
  prefs: []
  type: TYPE_NORMAL
- en: The model metadata will be saved automatically in the same file as the model
    itself when you click on the **Save** button in the toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: Editing models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can also load any existing model in the modeler to edit it. You can do
    this, for example, to adjust some hardcoded parameters, to redefine the workflow,
    or just to learn how it works. There are two ways of loading an existing model:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the model in toolbox by typing its name in the search field. Right-click
    on the model to open the context menu and select **Edit model**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Processing modeler from the **Processing** menu, click on the **Open
    model** button from the toolbar and navigate to the model file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To edit any input or algorithm, click on the small pencil icon in the bottom-right
    corner of the corresponding block. Also, you can choose **Edit** from the context
    menu, opened by right-clicking. Any of these actions will open a definition dialog
    where you can perform the necessary changes, for example, update the values or
    restrictions or reconnect the elements. After you have clicked on the **OK** button,
    the dialog will be closed and links between model blocks will be updated, if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: To delete unnecessary items (input or algorithm), click on the cross button
    in the top-right corner of the corresponding block, or select **Remove** from
    the item's context menu. Note that the algorithm or input can be removed only
    if there are no other elements depending on it. In other words, an input should
    not be used by any algorithm, and algorithm outputs should not be used as inputs
    in other algorithms. If you try to delete a block that has items depending on
    it, you will see a warning message and the operation will be canceled.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's edit our model. As in almost all use cases, grid cells should have
    equal dimensions in both horizontal and vertical directions. It is very good to
    leave only one numeric parameter in the model. This simplifies the model and makes
    the user's life simpler, as they will need to enter less data when executing the
    model.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to edit one of the numeric inputs and change its name to match
    the input meaning. Click on the pencil icon in the bottom-right corner of the
    **Vertical grid spacing** block, change the **Parameter** name to `Grid spacing`,
    and click on the **OK** button to save your edits.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Alternatively, you can edit the **Horizontal grid spacing** input. This replacement
    is completely safe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the definition dialog of the **Create grid** algorithm and select
    the `Grid spacing` input in both fields: **Horizontal spacing** and **Vertical
    spacing**. When you''re done, click on the **OK** button to save your edits and
    close the dialog. You will see that the connections between blocks have now changed—one
    numeric input (its name depends on the input you edited previously) is not connected
    to any algorithm. To delete this input, click on the cross in the top-right corner.
    The updated model may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Editing models](img/image00512.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you want, you can save the updated model as a new model. To do this, just
    enter a different model name and, if necessary, a group name. Then, click on the
    **Save as...** button and enter a name for the new model file.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to deactivate some parts of the model—a particular algorithm
    or even an entire branch—without deleting the corresponding blocks. This feature
    is extremely useful when you don't want to get all of the output produced by the
    model or need to debug/test a small part of it.
  prefs: []
  type: TYPE_NORMAL
- en: To deactivate an algorithm, right-click on it and select **Deactivate** in the
    context menu. The corresponding algorithm block will be grayed out, and all algorithm
    blocks that depend on it will be automatically deactivated too. Deactivated algorithms
    will be skipped during model execution and will not generate any output. This
    has an advantage—the model's execution time is reduced. Keep in mind that the
    status of the algorithms (active/deactivated) is being saved in the model file,
    and before saving a model, make sure that you don't miss anything.
  prefs: []
  type: TYPE_NORMAL
- en: To activate an algorithm, right-click on it and select **Activate** from the
    context menu. Note that this activation affects only the selected algorithm. All
    algorithms that depend on it will remain deactivated, and you'll have to activate
    them one by one.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, imagine that you don't need to generate square density maps.
    Of course, we can create a new model from an existing one by deleting unnecessary
    blocks and using the **Save as...** functionality. Creating a new model makes
    sense when you often need to generate only hexagonal density maps. But if there
    is a one-time requirement, it is better to simply deactivate the **Create square
    grid** block in our model, and all the dependent blocks will be deactivated too.
    So, you can execute the model, generate only hexagonal density maps, and then
    activate the disabled blocks again.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have created useful models that may help other users, it would be good
    to share them with the community so that others don't need to reinvent the wheel.
  prefs: []
  type: TYPE_NORMAL
- en: As the saved Processing model is a single file in JSON format, the easiest way
    to share it with others is to send it to those who are interested in it, or upload
    the model file to any file sharing or hosting site and provide everyone with a
    link to this file.
  prefs: []
  type: TYPE_NORMAL
- en: A bit more complex—but at the same time, a very convenient and user-friendly—way
    is to publish your model in the Processing models and scripts community repository.
    This repository was created in the spring of 2014, and provides a centralized
    way to share Processing scripts and models among QGIS users.
  prefs: []
  type: TYPE_NORMAL
- en: To put your model into this repository, you need to fork the GitHub repository
    ([https://github.com/qgis/QGIS-Processing](https://github.com/qgis/QGIS-Processing)),
    commit your model in your fork, and issue a pull request.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To learn more about Git, use one of the Packt''s books, such as *Git: Version
    Control for Everyone*, and refer to the GitHub documentation at [https://help.github.com/](https://help.github.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to send the model to the qgis-developer mailing list, or directly
    to one of Processing's developers and ask them to put it into the repository.
  prefs: []
  type: TYPE_NORMAL
- en: To get models from this repository, use the **Get models from on-line script
    collection** tool located in the **Tools** subgroup under the **Models** item
    in the Processing toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use the Graphical modeler from the QGIS
    Processing framework to create geoprocessing models from multiple algorithms.
    The Modeler allows us to automate analyses and increase productivity by combining
    complex analyses that require several steps into a single, easy-to-use algorithm
    that can be reused.
  prefs: []
  type: TYPE_NORMAL
- en: We also covered additional important topics, including documenting models and
    sharing them with other users.
  prefs: []
  type: TYPE_NORMAL
