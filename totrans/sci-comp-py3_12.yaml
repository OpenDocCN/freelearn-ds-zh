- en: Chapter 12. Input and Output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will cover some options for handling data files. Depending
    on the data and the desired format, there are several options for reading and
    writing. We will show some of the most useful alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: File handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'File I/O (input and output) is essential in a number of scenarios. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with measured or scanned data. Measurements are stored in files that
    need to be read to be analyzed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with other programs. Save results to files so that they can be imported
    in other applications, and vice-versa.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing information for future reference or comparisons.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing data and results with others, possibly on other platforms using other
    software.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we will cover how to handle file I/O in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Python, an object of type `file` represents the contents of a physical file
    stored on disk. A new `file` object may be created using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The contents of the file may be accessed, for instance, with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Usage of file objects requires some care. The problem is that a file has to
    be closed before it can be reread or used by other applications, which is done
    using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It is, however, not that simple because an exception might be triggered before
    the call to `close` is executed, which will skip the closing code (consider the
    following example). A simple way to make sure that a file will be properly closed
    is to use context managers. This construction, using the `with` keyword, is explained
    in more detail in section *Exception* in [Chapter 10](ch10.html "Chapter 10. Error
    Handling"), *Error Handling*. Here is how it is used with files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This ensures that the file is closed when one exits the `with` block, even
    if an exception is raised inside the block. The command works with context manager
    objects. We recommend that you read more on context managers in section *Exception*
    in [Chapter 10](ch10.html "Chapter 10. Error Handling"), *Error Handling*. Here
    is an example showing why the `with` construct is desirable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'An exception is raised before the file is closed. The file remains open, and
    there is no guarantee of what data is written in the file or when it is written.
    Hence, the proper way to achieve the same result is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In that case, the file is cleanly closed just after the exception (here, `ZeroDivisionError`)
    is raised. Notice also that there is no need to close the file explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Files are iterable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A file is, in particular, iterable (refer to section *Iterators* of [Chapter
    9](ch09.html "Chapter 9. Iterating"), *Iterating*). Files iterate their lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The lines of the file are returned as strings. The string method `split` is
    a possible tool to convert the string to a list of strings. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the `myfile` object is iterable, we can also do a direct extraction into
    a list, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: File modes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you can see in these examples of file handling, the `open` function takes
    at least two arguments. The first is obviously the filename, and the second is
    a string describing the way in which the file will be used. There are several
    such modes for opening files; the basic ones are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `'r'`, `'r+'`, and `'a'` modes require that the file exists, whereas `'w'`
    will create a new file if no file with that name exists. Reading and writing with
    `'r'` and `'w'` is most common, as you saw in previous examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider an example of opening a file and adding data at the end of the file
    without modifying what is already there using the append `''a''` mode. Note the
    line break,`\n` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: NumPy methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NumPy has built-in methods for reading and writing NumPy array data to text
    files. These are `numpy.loadtxt` and `numpy.savetxt`.
  prefs: []
  type: TYPE_NORMAL
- en: savetxt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Writing an array to a text file is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two useful parameters given as strings, `fmt` and `delimiter`, which
    control the format and the delimiter between columns. The defaults are space for
    the delimiter and `%.18e` for the format, which corresponds to the exponential
    format with all digits. The formatting parameters are used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: loadtxt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Reading to an array from a text file is done with the help of the following
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Due to the fact that each row in an array must have the same length, each row
    in the text file must have the same number of elements. Similar to `savetxt`,
    the default values are `float` and the delimiter is `space`. These can be set
    using the `dtype` and `delimiter` parameters. Another useful parameter is `comments`,
    which can be used to mark what symbol is used for comments in the data file. An
    example for using the formatting parameters is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Pickling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The read and write methods you just saw convert data to strings before writing.
    Complex types (such as objects and classes) cannot be written this way. With Python’s
    pickle module, you can save any object and also multiple objects to file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data can be saved in plaintext (ASCII) format or using a slightly more efficient
    binary format. There are two main methods: `dump`, which saves a pickled representation
    of a Python object to a file, and `load`, which retrieves a pickled object from
    the file. The basic usage is like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the order in which the two objects are returned. Besides the two main
    methods, it is sometimes useful to serialize a Python object to a string instead
    of a file. This is done with `dumps` and `load`. Consider an example for serializing
    an array and a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: A good example of using `dumps` is when you need to write Python objects or
    NumPy arrays to a database. These usually have support for storing strings, which
    makes it easy to write and read complex data and objects without any special modules.
    Besides the pickle module, there is also an optimized version called `cPickle`.
    It is written in C and is an option if you need fast reading and writing. The
    data produced by pickle and *cPickle* is identical and can be interchanged.
  prefs: []
  type: TYPE_NORMAL
- en: Shelves
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Objects in dictionaries can be accessed by keys. There is a similar way to
    access particular data in a file by first assigning it a key. This is possible
    by using the module shelve:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the section *File handling*, we saw that the built-in `open` command generates
    a context manager, and we saw why this is important for handling external resources,
    such as files. In contrast to this command, `sv.open` does not create a context
    manager by itself. The `closing` command from the `contextlib` module is needed
    to transform it into an appropriate context manager. Consider the following example
    of restoring the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: A shelve object has all dictionary methods, for example, keys and values, and
    can be used in the same way as a dictionary. Note that changes are only written
    in the file after the `close` or `sync` method has been called.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing Matlab data files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SciPy has the ability to read and write data in Matlab’s `.mat` file format
    using the module. The commands are `loadmat` and `savemat`. To load data, use
    the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The variable data now contains a dictionary, with keys corresponding to the
    variable names saved in the `.mat` file. The variables are in NumPy array format.
    Saving to `.mat` files involves creating a dictionary with all the variables you
    want to save (variable name and value). The command is then `savemat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This saves the NumPy arrays `x` and `y` with the same names when read into Matlab.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SciPy comes with some basic functions for handling images. The module function
    will read images to NumPy arrays. The function will save an array as an image.
    The following will read a *JPEG* image to an array, print the shape and type,
    then create a new array with a resized image, and write the new image to file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the data type. Images are almost always stored with pixel values in the
    range *0...255*  as 8-bit unsigned integers. The third shape value shows how many
    color channels the image has. In this case, *3* means it is a color image with
    values stored in this order: red `im[0]`, green `im[1]`, blue `im[2]`. A gray
    scale image would only have one channel.'
  prefs: []
  type: TYPE_NORMAL
- en: For working with images, the SciPy module `scipy.misc` contains many useful
    basic image processing functions such as filtering, transforms, and measurements.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: File handling is inevitable when dealing with measurements and other sources
    of a larger amount of data. Also communication with other programs and tools is
    done via file handling.
  prefs: []
  type: TYPE_NORMAL
- en: You learned to see a file as a Python object like others with important methods
    such as `readlines` and `write`. We showed how files can be protected by special
    attributes, which may allow only read or only write access.
  prefs: []
  type: TYPE_NORMAL
- en: The way you write to a file often influences the speed of the process. We saw
    how data is stored by pickling or by using the `shelve` method.
  prefs: []
  type: TYPE_NORMAL
