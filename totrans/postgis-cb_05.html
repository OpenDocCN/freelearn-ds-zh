<html><head></head><body>
        

                            
                    <h1 class="header-title">Working with Raster Data</h1>
                
            
            
                
<p>In this chapter, we will cover the following:</p>
<ul>
<li>Getting and loading rasters</li>
<li>Working with basic raster information and analysis</li>
<li>Performing simple map-algebra operations</li>
<li>Combining geometries with rasters for analysis</li>
<li>Converting between rasters and geometries</li>
<li>Processing and loading rasters with GDAL VRT</li>
<li>Warping and resampling rasters</li>
<li>Performing advanced map-algebra operations</li>
<li>Executing DEM operations</li>
<li>Sharing and visualizing rasters through SQL</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>In this chapter, the recipes are presented in a step-by-step workflow that you may apply while working with a raster. This entails loading the raster, getting a basic understanding of the raster, processing and analyzing it, and delivering it to consumers. We intentionally add some detours to the workflow to reflect the reality that the raster, in its original form, may be confusing and not suitable for analysis. At the end of this chapter, you should be able to take the lessons learned from the recipes and confidently apply them to solve your raster problems.</p>
<p>Before going further, we should describe what a raster is, and what a raster is used for. At the simplest level, a raster is a photo or image with information describing where to place the raster on the Earth's surface. A photograph typically has three sets of values: one set for each primary color (red, green, and blue). A raster also has sets of values, often more than those found in a photograph. Each set of values is known as a <strong>band</strong>. So, a photograph typically has three bands, while a raster has at least one band. Like digital photographs, rasters come in a variety of file formats. Common raster formats you may come across include PNG, JPEG, GeoTIFF, HDF5, and NetCDF. Since rasters can have many bands and even more values, they can be used to store large quantities of data in an efficient manner. Due to their efficiency, rasters are used for satellite and aerial sensors and modeled surfaces, such as weather forecasts.</p>
<p>There are a few keywords used in this chapter and in the PostGIS ecosystem that need to be defined:</p>
<ul>
<li><strong>Raster</strong>: This is the PostGIS data type for storing raster files in PostgreSQL.</li>
<li><strong>Tile</strong>: This is a small chunk of the original raster file to be stored in one column of a table's row. Each tile has its own set of spatial information, and thus is independent of all the other tiles in the same column of the same table, even if the other tiles are from the same original raster file.</li>
<li><strong>Coverage</strong>: This consists of all the tiles of a single raster column from one table.</li>
</ul>
<p>We make heavy use of GDAL in this chapter. GDAL is generally considered the de facto Swiss Army knife for working with rasters. GDAL is not a single application, but is a raster-abstraction library with many useful utilities. Through GDAL, you can get the metadata of a raster, convert that raster to a different format, and warp that raster among many other capabilities. For our needs in this chapter, we will use three GDAL utilities: <kbd>gdalinfo</kbd>, <kbd>gdalbuildvrt</kbd>, and <kbd>gdal_translate</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting and loading rasters</h1>
                
            
            
                
<p>In this recipe, we load most of the rasters used in this chapter. These rasters are examples of satellite imagery and model-generated surfaces, two of the most common raster sources.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>If you have not done so already, create a directory and copy the chapter's datasets; for Windows, use the following commands:</p>
<pre><strong>&gt; mkdir C:\postgis_cookbook\data\chap05</strong>
<strong>&gt; cp -r /path/to/book_dataset/chap05 C:\postgis_cookbook\data\chap05</strong></pre>
<p>For Linux or macOS, go into the folder you wish to use and run the following commands, where <kbd>/path/to/book_dataset/chap05</kbd> is the path where you originally stored the book source code:</p>
<pre><strong>&gt; mkdir -p data/chap05</strong>
<strong>&gt; cd data/chap05</strong>
<strong>&gt; cp -r /path/to/book_dataset/chap05</strong></pre>
<p>You should also create a new schema for this chapter in the database:</p>
<pre><strong>&gt; psql -d postgis_cookbook -c "CREATE SCHEMA chp05"</strong> </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>We will start with the PRISM average monthly minimum-temperature raster dataset for 2016 with coverage for the continental United States. The raster is provided by the PRISM Climate Group at Oregon State University, with additional rasters available at <a href="http://www.prism.oregonstate.edu/mtd/">http://www.prism.oregonstate.edu/mtd/</a>.</p>
<p>On the command line, navigate to the <kbd>PRISM</kbd> directory as follows:</p>
<pre><strong>&gt; cd C:\postgis_cookbook\data\chap05\PRISM</strong> </pre>
<p>Let us spot check one of the PRISM rasters with the GDAL utility <kbd>gdalinfo</kbd>. It is always a good practice to inspect at least one raster to get an idea of the metadata and ensure that the raster does not have any issues. This can be done using the following command:</p>
<pre><strong>&gt; gdalinfo PRISM_tmin_provisional_4kmM2_201703_asc.asc</strong></pre>
<p>The <kbd>gdalinfo</kbd> output is as follows:</p>
<div><img src="img/3097d298-ff89-49c1-be46-01d1b67344c6.png" style="width:40.00em;height:24.08em;"/></div>
<p>The <kbd>gdalinfo</kbd> output reveals that the raster has no issues, as evidenced by the <kbd>Corner Coordinates</kbd>, <kbd>Pixel Size</kbd>, <kbd>Band</kbd>, and <kbd>Coordinate System</kbd> being unempty.</p>
<p>Looking through the metadata, we find that the metadata about the spatial reference system indicates that raster uses the NAD83 coordinate system. We can double-check this by searching for the details of NAD83 in the <kbd>spatial_ref_sys</kbd> table:</p>
<pre><strong>SELECT srid, auth_name, auth_srid, srtext, proj4text <br/>FROM </strong><strong>spatial_ref_sys WHERE proj4text LIKE '%NAD83%'</strong> </pre>
<p>Comparing the text of <kbd>srtext</kbd> to the PRISM raster's metadata spatial attributes, we find that the raster is in EPSG (SRID 4269).</p>
<p>You can load the PRISM rasters into the <kbd>chp05.prism</kbd> table with <kbd>raster2pgsql</kbd>, which will import the raster files to the database in a similar manner as the <kbd>shp2pgsql</kbd> command:</p>
<pre><strong>&gt; raster2pgsql -s 4269 -t 100x100 -F -I -C -Y .\PRISM_tmin_provisional_4kmM2_*_asc.asc <br/>chp05.prism | psql -d postgis_cookbook -U me</strong></pre>
<p>The <kbd>raster2pgsql</kbd> command is called with the following flags:</p>
<ul>
<li><kbd>-s</kbd>: This flag assigns SRID<kbd>4269</kbd> to the imported rasters.</li>
<li><kbd>-t</kbd>: This flag denotes the tile size. It chunks the imported rasters into smaller and more manageable pieces; each record added to the table will be, at most, 100 x 100 pixels.</li>
<li><kbd>-F</kbd>: This flag adds a column to the table and fills it with the raster's filename.</li>
<li><kbd>-I</kbd>: This flag creates a GIST spatial index on the table's raster column.</li>
<li><kbd>-C</kbd>: This flag applies the standard set of constraints on the table. The standard set of constraints includes checks for dimension, scale, skew, upper-left coordinate, and SRID.</li>
<li><kbd>-Y</kbd>: This flag instructs <kbd>raster2pgsql</kbd> to use <kbd>COPY</kbd> statements instead of <kbd>INSERT</kbd> statements. <kbd>COPY</kbd> is typically faster than <kbd>INSERT</kbd>.</li>
</ul>
<p>There is a reason why we passed <kbd>-F</kbd> to <kbd>raster2pgsql</kbd>. If you look at the filenames of the PRISM rasters, you'll note the year and month. So, let's convert the value in the <kbd>filename</kbd> column to a date in the table:</p>
<pre><strong>ALTER TABLE chp05.prism ADD COLUMN month_year DATE; 
UPDATE chp05.prism SET  month_year = ( SUBSTRING(split_part(filename, '_', 5), 0, 5) || '-' ||  SUBSTRING(split_part(filename, '_', 5), 5, 4) || '-01' ) :: DATE;</strong> </pre>
<p>This is all that needs to be done with the <kbd>PRISM</kbd> rasters for now.</p>
<p>Now, let's import a <strong>Shuttle Radar Topography Mission</strong> (<strong>SRTM</strong>) raster. The SRTM raster is from the SRTM that was conducted by the NASA Jet Propulsion Laboratory in February, 2000. This raster and others like it are available at: <a href="http://dds.cr.usgs.gov/srtm/version2_1/SRTM1/">http://dds.cr.usgs.gov/srtm/version2_1/SRTM1/</a>.<a href="http://dds.cr.usgs.gov/srtm/version2_1/SRTM1/"/></p>
<p>Change the current directory to the <kbd>SRTM</kbd> directory:</p>
<pre><strong>&gt; cd C:\postgis_cookbook\data\chap05\SRTM</strong></pre>
<p>Make sure you spot check the SRTM raster with <kbd>gdalinfo</kbd> to ensure that it is valid and has a value for <kbd>Coordinate System</kbd>. Once checked, import the SRTM raster into the <kbd>chp05.srtm</kbd> table:</p>
<pre><strong>&gt; raster2pgsql -s 4326 -t 100x100 -F -I -C -Y N37W123.hgt chp05.srtm | psql -d postgis_cookbook</strong></pre>
<p>We use the same <kbd>raster2pgsql</kbd> flags for the SRTM raster as those for the PRISM rasters.</p>
<p>We also need to import a <kbd>shapefile</kbd> of San Francisco provided by the City and County of San Francisco, available with the book's dataset files, or the one found on the following link, after exporting the data to a shapefile:</p>
<p><a href="https://data.sfgov.org/Geographic-Locations-and-Boundaries/SF-Shoreline-and-Islands/rgcx-5tix">https://data.sfgov.org/Geographic-Locations-and-Boundaries/SF-Shoreline-and-Islands/rgcx-5tix</a></p>
<div><img src="img/8fc8441e-bfdc-43c7-a64f-bc6aed696736.png" style="width:52.58em;height:51.58em;"/></div>
<p>The San Francisco's boundaries from the book's files will be used in many of the follow-up recipes, and it must be loaded to the database as follows:</p>
<pre><strong>&gt; cd C:\postgis_cookbook\data\chap05\SFPoly</strong>
<strong>&gt; shp2pgsql -s 4326 -I sfpoly.shp chp05.sfpoly | psql -d postgis_cookbook -U me</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>In this recipe, we imported the required PRISM and SRTM rasters needed for the rest of the recipes. We also imported a <kbd>shapefile</kbd> containing San Francisco's boundaries to be used in the various raster analyses. Now, on to the fun!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Working with basic raster information and analysis</h1>
                
            
            
                
<p>So far, we've checked and imported the PRISM and SRTM rasters into the <kbd>chp05</kbd> schema of the <kbd>postgis_cookbook</kbd> database. We will now proceed to work with the rasters within the database.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>In this recipe, we explore functions that provide insight into the raster attributes and characteristics found in the <kbd>postgis_cookbook</kbd> database. In doing so, we can see if what is found in the database matches the information provided by accessing <kbd>gdalinfo</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>PostGIS includes the <kbd>raster_columns</kbd> view to provide a high-level summary of all the raster columns found in the database. This view is similar to the <kbd>geometry_columns</kbd> and <kbd>geography_columns</kbd> views in function and form.</p>
<p>Let's run the following SQL query in the <kbd>raster_columns</kbd> view to see what information is available in the <kbd>prism</kbd> table:</p>
<pre><strong>SELECT 
  r_table_name, 
  r_raster_column, 
  srid, 
  scale_x, 
  scale_y, 
  blocksize_x, 
  blocksize_y, 
  same_alignment, 
  regular_blocking, 
  num_bands, 
  pixel_types, 
  nodata_values, 
  out_db, 
  ST_AsText(extent) AS extent FROM raster_columns WHERE r_table_name = 'prism';</strong> </pre>
<p>The SQL query returns a record similar to the following:</p>
<div><img src="img/3b19975a-d332-498c-84f9-8fa9db10c094.png"/></div>
<div><img src="img/48ea6133-ae9f-4066-b507-326d7e9ce775.png"/></div>
<pre class="packt_figure"><strong>(1 row)</strong></pre>
<p>If you look back at the <kbd>gdalinfo</kbd> output for one of the PRISM rasters, you'll see that the values for the scales (the pixel size) match. The flags passed to <kbd>raster2pgsql</kbd>, specifying tile size and <kbd>SRID</kbd>, worked.</p>
<p>Let's see what the metadata of a single raster tile looks like. We will use the <kbd>ST_Metadata()</kbd> function:</p>
<pre><strong>SELECT  rid,  (ST_Metadata(rast)).* 
FROM chp05.prism 
WHERE month_year = '2017-03-01'::date 
LIMIT 1;</strong> </pre>
<p>The output will look similar to the following:</p>
<div><img src="img/e1f006b3-060e-47b9-9897-9d0da65d15be.png"/></div>
<p>Use <kbd>ST_BandMetadata()</kbd> to examine the first and only band of raster tiles at the record ID <kbd>54</kbd>:</p>
<pre><strong>SELECT  rid,  (ST_BandMetadata(rast, 1)).* 
FROM chp05.prism 
WHERE rid = 54;</strong> </pre>
<p>The results indicate that the band is of pixel type <kbd>32BF</kbd>, and has a <kbd>NODATA</kbd> value of <kbd>-9999</kbd>. The <kbd>NODATA</kbd> value is the value assigned to an empty pixel:</p>
<div><img src="img/4ae15d6a-9090-4723-884b-208b358b927d.png" style="width:34.00em;height:5.08em;"/></div>
<p>Now, to do something a bit more useful, run some basic statistic functions on this raster tile.</p>
<p>First, let's compute the summary statistics (count, mean, standard deviation, min, and max) with <kbd>ST_SummaryStats() for an specific raster, in this case, number 54</kbd>:</p>
<pre><strong>WITH stats AS (SELECT (ST_SummaryStats(rast, 1)).*  FROM prism  WHERE rid = 54) 
SELECT  count,  sum,  round(mean::numeric, 2) AS mean,  round(stddev::numeric, 2) AS stddev,  min,  max 
FROM stats;</strong> </pre>
<p>The output of the preceding code will be as follows:</p>
<div><img src="img/90003a6a-40f3-463f-ace0-879fa17846be.png" style="width:47.33em;height:4.83em;"/></div>
<p>In the summary statistics, if the <kbd>count</kbd> indicates less than <em>10,000 (100<sup>2</sup>)</em>, it means that the raster is 10,000-count/100. In this case, the raster tile is about 0% <kbd>NODATA</kbd>.</p>
<p>Let's see how the values of the raster tile are distributed with <kbd>ST_Histogram()</kbd>:</p>
<pre><strong>WITH hist AS ( 
  SELECT (ST_Histogram(rast, 1)).* FROM chp05.prism WHERE rid = 54 
) 
SELECT round(min::numeric, 2) AS min, round(max::numeric, 2) AS max, count, round(percent::numeric, 2) AS percent FROM hist 
ORDER BY min;</strong> </pre>
<p>The output will look as follows:</p>
<div><img src="img/ad639382-a20d-4612-93ff-afb2712f14e6.png" style="width:22.50em;height:29.25em;"/></div>
<p>It looks like about 78% of all of the values are at or below <kbd>1370.50</kbd>. Another way to see how the pixel values are distributed is to use <kbd>ST_Quantile()</kbd>:</p>
<pre><strong>SELECT (ST_Quantile(rast, 1)).* 
FROM chp05.prism 
WHERE rid = 54;</strong> </pre>
<p>The output of the preceding code is as follows:</p>
<div><img src="img/3afabcee-98d7-4579-b881-74f51c6baa61.png" style="width:22.25em;height:12.83em;"/></div>
<p>Let's see what the top 10 occurring values are in the raster tile with <kbd>ST_ValueCount()</kbd>:</p>
<pre><strong>SELECT (ST_ValueCount(rast, 1)).* 
FROM chp05.prism WHERE rid = 54 
ORDER BY count DESC, value 
LIMIT 10;</strong> </pre>
<p>The output of the code is as follows:</p>
<div><img src="img/f4015129-1c61-447e-bdb1-ea3ef7ea20f1.png" style="width:15.58em;height:19.50em;"/></div>
<p>The <kbd>ST_ValueCount</kbd> allows other combinations of parameters that will allow rounding up of the values in order to aggregate some of the results, but a previous subset of values to look for must be defined; for example, the following code will count the appearance of values <kbd>2</kbd>, <kbd>3</kbd>, <kbd>2.5</kbd>, <kbd>5.612999</kbd> and <kbd>4.176</kbd> rounded to the fifth decimal point <kbd>0.00001</kbd>:</p>
<pre><strong>SELECT (ST_ValueCount(rast, 1, true, ARRAY[2,3,2.5,5.612999,4.176]::double precision[] ,0.0001)).* 
FROM chp05.prism 
WHERE rid = 54 
ORDER BY count DESC, value 
LIMIT 10;</strong> </pre>
<p class="mce-root">The results show the number of elements that appear similar to the rounded-up values in the array. The two values borrowed from the results on the previous figure, confirm the counting:</p>
<div><img src="img/2fbe1084-94b5-4ac2-bf6d-35715532211c.png" style="width:16.42em;height:12.25em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>In the first part of this recipe, we looked at the metadata of the <kbd>prism</kbd> raster table and a single raster tile. We focused on that single raster tile to run a variety of statistics. The statistics provided some idea of what the data looks like.</p>
<p>We mentioned that the pixel values looked wrong when we looked at the output from <kbd>ST_SummaryStats()</kbd>. This same issue continued in the output from subsequent statistics functions. We also found that the values were in Celsius degrees. In the next recipe, we will recompute all the pixel values to their true values with a map-algebra operation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Performing simple map-algebra operations</h1>
                
            
            
                
<p>In the previous recipe, we saw that the values in the PRISM rasters did not look correct for temperature values. After looking at the PRISM metadata, we learned that the values were scaled by <kbd>100</kbd>.</p>
<p>In this recipe, we will process the scaled values to get the true values. Doing this will prevent future end-user confusion, which is always a good thing.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>PostGIS provides two types of map-algebra functions, both of which return a new raster with one band. The type you use depends on the problem being solved and the number of raster bands involved.</p>
<p>The first map-algebra function (<kbd>ST_MapAlgebra()</kbd> or <kbd>ST_MapAlgebraExpr()</kbd>) depends on a valid, user-provided PostgreSQL algebraic expression that is called for every pixel. The expression can be as simple as an equation, or as complex as a logic-heavy SQL expression. If the map-algebra operation only requires at most two raster bands, and the expression is not complicated, you should have no problems using the expression-based map-algebra function.</p>
<p>The second map-algebra function (<kbd>ST_MapAlgebra()</kbd>, <kbd>ST_MapAlgebraFct()</kbd>, or <kbd>ST_MapAlgebraFctNgb()</kbd>) requires the user to provide an appropriate PostgreSQL function to be called for each pixel. The function being called can be written in any of the PostgreSQL PL languages (for example, PL/pgSQL, PL/R, PL/Perl), and be as complex as needed. This type is more challenging to use than the expression map-algebra function type, but it has the flexibility to work on any number of raster bands.</p>
<p>For this recipe, we use only the expression-based map-algebra function, <kbd>ST_MapAlgebra()</kbd>, to create a new band with the temperature values in Fahrenheit, and then append this band to the processed raster. If you are not using PostGIS 2.1 or a later version, use the equivalent <kbd>ST_MapAlgebraExpr()</kbd> function.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>With any operation that is going to take a while and/or modify a stored raster, it is best to test that operation to ensure there are no mistakes and the output looks correct.</p>
<p>Let's run <kbd>ST_MapAlgebra()</kbd> on one raster tile, and compare the summary statistics before and after the map-algebra operation:</p>
<pre><strong>WITH stats AS ( 
  SELECT 
    'before' AS state, 
    (ST_SummaryStats(rast, 1)).*</strong><br/><strong>  FROM chp05.prism 
  WHERE rid = 54 
  UNION ALL 
  SELECT 
    'after' AS state, (ST_SummaryStats(ST_MapAlgebra(rast, 1, '32BF', '([rast]*9/5)+32', -9999), 1 )).* 
  FROM chp05.prism 
  WHERE rid = 54 
) 
SELECT 
  state, 
  count, 
  round(sum::numeric, 2) AS sum, 
  round(mean::numeric, 2) AS mean, 
  round(stddev::numeric, 2) AS stddev, 
  round(min::numeric, 2) AS min, 
  round(max::numeric, 2) AS max 
FROM stats ORDER BY state DESC;</strong> </pre>
<p>The output looks as follows:</p>
<div><img class="alignnone size-full wp-image-407 image-border" src="img/148cc3c8-884d-4252-b969-e4d13c2727cf.png" style="width:38.42em;height:6.58em;"/></div>
<p>In the <kbd>ST_MapAlgebra()</kbd> function, we indicate that the output raster's band will have a pixel type of <kbd>32BF</kbd> and a <kbd>NODATA</kbd> value of <kbd>-9999</kbd>. We use the expression <kbd>'([rast]*9/5)+32'</kbd> to convert each pixel value to its new value in Fahrenheit. Before <kbd>ST_MapAlgebra()</kbd> evaluates the expression, the pixel value replaces the placeholder <kbd>'[rast]'</kbd>. There are several other placeholders available, and they can be found in the <kbd>ST_MapAlgebra()</kbd> documentation.</p>
<p>Looking at the summary statistics and comparing the before and after processing, we see that the map-algebra operation works correctly. So, let's correct the entire table. We will append the band created from <kbd>ST_MapAlgebra()</kbd> to the existing raster:</p>
<pre><strong>UPDATE chp05.prism SET  rast = ST_AddBand(rast, ST_MapAlgebra(rast, 1, '32BF', '([rast]*9/5)+32', -999), 1    ); 
ERROR:  new row for relation "prism" violates check constraint </strong><strong>" enforce_nodata_values_rast"</strong> </pre>
<p>The SQL query will not work. Why? If you remember, when we loaded the PRISM rasters, we instructed <kbd>raster2pgsql</kbd> to add the standard constraints with the <kbd>-C</kbd> flag. It looks like we violated at least one of those constraints.</p>
<p>When installed, the standard constraints enforce a set of rules on each value of a raster column in the table. These rules guarantee that each raster column value has the same (or appropriate) attributes. The standard constraints comprise the following rules:</p>
<ul>
<li><strong>Width and height</strong>: This rule states that all the rasters must have the same width and height</li>
<li><strong>Scale X and Y</strong>: This rule states that all the rasters must have the same scale X and Y</li>
<li><strong>SRID</strong>: This rule states that all rasters must have the same SRID</li>
<li><strong>Same alignment</strong>: This rule states that all rasters must be aligned to one another</li>
<li><strong>Maximum extent</strong>: This rule states that all rasters must be within the table's maximum extent</li>
<li><strong>Number of bands</strong>: This rule states that all rasters must have the same number of bands</li>
<li><strong>NODATA values</strong>: This rule states that all raster bands at a specific index must have the same NODATA value</li>
<li><strong>Out-db</strong>: This rule states that all raster bands at a specific index must be <kbd>in-db</kbd> or <kbd>out-db</kbd>, not both</li>
<li><strong>Pixel type</strong>: This rule states that all raster bands at a specific index must be of the same pixel type</li>
</ul>
<p>The error message indicates that we violated the <kbd>out-db</kbd> constraint. But we can't accept the error message as it is, because we are not doing anything related to <kbd>out-db</kbd>. All we are doing is adding a second band to the raster. Adding the second band violates the <kbd>out-db</kbd> constraint, because the constraint is prepared only for one band in the raster, not a raster with two bands.</p>
<p>We will have to drop the constraints, make our changes, and reapply the constraints:</p>
<pre><strong>SELECT DropRasterConstraints('chp05', 'prism', 'rast'::name);<br/></strong></pre>
<p>After this command, we will have the following output showing the constraints were dropped:</p>
<div><img src="img/fedf15ae-fcc8-444f-80b2-f166a5e9eb2c.png"/></div>
<pre><strong>UPDATE chp05.prism SET rast = ST_AddBand(rast, ST_MapAlgebra(rast, 1, '32BF', ' ([rast]*9/5)+32', -9999), 1); 
SELECT AddRasterConstraints('chp05', 'prism', 'rast'::name);</strong> </pre>
<p>The <kbd>UPDATE</kbd> will take some time, and the output will look as follows, showing that the constraints were added again:</p>
<div><img src="img/55eddef7-c396-4e29-8e3d-2282490b2462.png"/></div>
<p>There is not much information provided in the output, so we will inspect the rasters. We will look at one raster tile:</p>
<pre><strong>SELECT (ST_Metadata(rast)).numbands 
FROM chp05.prism 
WHERE rid = 54;</strong> </pre>
<p>The output is as follows:</p>
<div><img src="img/9b88f202-5686-4413-87d7-d3d675ced876.png"/></div>
<p>The raster has two bands. The following are the details of these two bands:</p>
<pre><strong>SELECT 1 AS bandnum, (ST_BandMetadata(rast, 1)).* 
FROM chp05.prism 
WHERE rid = 54 
UNION ALL 
SELECT 2 AS bandnum, (ST_BandMetadata(rast, 2)).* 
FROM chp05.prism 
WHERE rid = 54 
ORDER BY bandnum;</strong> </pre>
<p>The output looks as follows:</p>
<div><img src="img/3aabe0af-6362-4e68-9bd2-823a6094f42c.png" style="width:32.92em;height:7.00em;"/></div>
<p>The first band is the same as the new second band with the correct attributes (the <kbd>32BF</kbd> pixel type, and the <kbd>NODATA value</kbd> of <kbd>-9999</kbd>) that we specified in the call to <kbd>ST_MapAlgebra()</kbd>.The real test, though, is to look at the summary statistics:</p>
<pre><strong>WITH stats AS ( 
  SELECT 
    1 AS bandnum, 
    (ST_SummaryStats(rast, 1)).* 
  FROM chp05.prism 
  WHERE rid = 54 
  UNION ALL 
  SELECT 
    2 AS bandnum, 
    (ST_SummaryStats(rast, 2)).* 
  FROM chp05.prism 
  WHERE rid = 54 
) 
SELECT 
  bandnum, 
  count, 
  round(sum::numeric, 2) AS sum, 
  round(mean::numeric, 2) AS mean, 
  round(stddev::numeric, 2) AS stddev, 
  round(min::numeric, 2) AS min, 
  round(max::numeric, 2) AS max 
FROM stats ORDER BY bandnum;</strong> </pre>
<p>The output is as follows:</p>
<div><img class="alignnone size-full wp-image-408 image-border" src="img/d6f09e95-8821-4ca2-8387-24e06ec0c549.png" style="width:36.75em;height:6.25em;"/></div>
<p>The summary statistics show that band <kbd>2</kbd> is correct after the values from band <kbd>1</kbd> were transformed into Fahrenheit; that is, the mean temperature is <kbd>6.05</kbd> of band 1 in degrees Celsius, and <kbd>42.90</kbd> in degrees Fahrenheit in band 2).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>In this recipe, we applied a simple map-algebra operation with <kbd>ST_MapAlgebra()</kbd> to correct the pixel values. In a later recipe, we will present an advanced map-algebra operation to demonstrate the power of <kbd>ST_MapAlgebra()</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Combining geometries with rasters for analysis</h1>
                
            
            
                
<p>In the previous two recipes, we ran basic statistics only on one raster tile. Though running operations on a specific raster is great, it is not very helpful for answering real questions. In this recipe, we will use geometries to filter, clip, and unite raster tiles so that we can answer questions for a specific area.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We will use the San Francisco boundaries geometry previously imported into the <kbd>sfpoly</kbd> table. If you have not imported the boundaries, refer to the first recipe of this chapter for instructions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Since we are to look at rasters in the context of San Francisco, an easy question to ask is: what was the average temperature for March, 2017 in San Francisco? Have a look at the following code:</p>
<pre><strong>SELECT (ST_SummaryStats(ST_Union(ST_Clip(prism.rast, 1, ST_Transform(sf.geom, 4269), TRUE)), 1)).mean 
FROM chp05.prism 
JOIN chp05.sfpoly sf ON ST_Intersects(prism.rast, ST_Transform(sf.geom, 4269)) 
WHERE prism.month_year = '2017-03-01'::date;</strong> </pre>
<p>In the preceding SQL query, there are four items to pay attention to, which are as follows:</p>
<ul>
<li><kbd>ST_Transform()</kbd>: This method converts the geometry's coordinates from one spatial reference system to another. Transforming a geometry is typically faster than transforming a raster. Transforming a raster requires the pixel values to be resampled, a compute-intensive process, and one that could introduce undesirable results. If possible, always transform a geometry before transforming a raster, because spatial joins need to use the same SRID.</li>
<li><kbd>ST_Intersects()</kbd>: The <kbd>ST_Intersects()</kbd> method found in the <kbd>JOIN ON</kbd> clause tests if the raster tile and the geometry spatially intersect. It will use any available spatial indexes. Depending on the installed version of PostGIS, <kbd>ST_Intersects()</kbd> will implicitly convert the input geometry to a raster (PostGIS 2.0), or the input raster to a geometry (PostGIS 2.1), before comparing the two inputs.</li>
<li><kbd>ST_Clip()</kbd>: This method trims each intersecting raster tile only to the area that intersects the geometry. It eliminates the pixels that are not spatially part of the geometry. Like <kbd>ST_Intersects()</kbd>, the geometry is implicitly converted to a raster before clipping.</li>
<li><kbd>ST_Union()</kbd>: This method aggregates and merges the clipped raster tiles into one raster for further processing.</li>
</ul>
<p>The following output shows the average minimum temperature for San Francisco:</p>
<div><img src="img/c5a35ea8-33f3-4803-a851-e2faf9c15a82.png" style="width:15.08em;height:5.08em;"/></div>
<p>San Francisco was really cold in March, 2017. So, how does the rest of 2017 look? Is San Francisco always cold?</p>
<pre><strong>SELECT prism.month_year, (ST_SummaryStats(ST_Union(ST_Clip(prism.rast, 1, ST_Transform(sf.geom, 4269), TRUE)), 1)).mean 
FROM chp05.prism 
JOIN chp05.sfpoly sf ON ST_Intersects(prism.rast, ST_Transform(sf.geom, 4269)) 
GROUP BY prism.month_year 
ORDER BY prism.month_year; </strong></pre>
<p>The only change from the prior SQL query is the removal of the <kbd>WHERE</kbd> clause and the addition of a <kbd>GROUP BY</kbd> clause. Since <kbd>ST_Union()</kbd> is an aggregate function, we need to group the clipped rasters by <kbd>month_year</kbd>.</p>
<p>The output is as follows:</p>
<div><img class="alignnone size-full wp-image-409 image-border" src="img/e9831fb6-74b2-44e8-bea1-95158f76b513.png" style="width:21.83em;height:12.50em;"/></div>
<p>Based on the results, the late summer months of 2017 were the warmest, though not by a huge margin.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>By using a geometry to filter the rasters in the prism table, only a small set of rasters needed clipping with the geometry and unionizing to compute the mean. This maximized the query performance, and more importantly, provided the answer to our question.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Converting between rasters and geometries</h1>
                
            
            
                
<p>In the last recipe, we used the geometries to filter and clip rasters only to the areas of interest. The <kbd>ST_Clip()</kbd> and <kbd>ST_Intersects()</kbd> functions implicitly converted the geometry before relating it to the raster.</p>
<p>PostGIS provides several functions for converting rasters to geometries. Depending on the function, a pixel can be returned as an area or a point.</p>
<p>PostGIS provides one function for converting geometries to rasters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>In this recipe, we will convert rasters to geometries, and geometries to rasters. We will use the <kbd>ST_DumpAsPolygons()</kbd> and <kbd>ST_PixelsAsPolygons()</kbd> functions to convert rasters to geometries. We will then convert geometries to rasters using <kbd>ST_AsRaster()</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Let's adapt part of the query used in the last recipe to find out the average minimum temperature in San Francisco. We replace <kbd>ST_SummaryStats()</kbd> with <kbd>ST_DumpAsPolygons()</kbd>, and then return the geometries as <kbd>WKT</kbd>:</p>
<pre><strong>WITH geoms AS (SELECT ST_DumpAsPolygons(ST_Union(ST_Clip(prism.rast, 1, ST_Transform(sf.geom, 4269), TRUE)), 1 ) AS gv 
FROM chp05.prism </strong><br/><strong>JOIN chp05.sfpoly sf ON ST_Intersects(prism.rast, ST_Transform(sf.geom, 4269)) 
WHERE prism.month_year = '2017-03-01'::date ) 
SELECT (gv).val, ST_AsText((gv).geom) AS geom 
FROM geoms;</strong> </pre>
<p>The output is as follows:</p>
<div><img class="alignnone size-full wp-image-410 image-border" src="img/1b3a693b-b340-4c5e-99d7-9ea38b7e0ae3.png" style="width:31.42em;height:14.92em;"/></div>
<p>Now, replace the <kbd>ST_DumpAsPolygons()</kbd> function with <kbd>ST_PixelsAsPolyons()</kbd>:</p>
<pre><strong>WITH geoms AS (SELECT (ST_PixelAsPolygons(ST_Union(ST_Clip(prism.rast, 1, ST_Transform(sf.geom, 4269), TRUE)), 1 )) AS gv 
FROM chp05.prism 
JOIN chp05.sfpoly sf ON ST_Intersects(prism.rast, ST_Transform(sf.geom, 4269)) 
WHERE prism.month_year = '2017-03-01'::date) 
SELECT (gv).val, ST_AsText((gv).geom) AS geom 
FROM geoms;</strong> </pre>
<p>The output is as follows:</p>
<div><img src="img/ee245520-e737-4ab3-be13-c0a35bfc7a7a.png" style="width:19.25em;height:15.00em;"/></div>
<p>Again, the query results have been trimmed. What is important is the number of rows returned. <kbd>ST_PixelsAsPolygons()</kbd> returns significantly more geometries than <kbd>ST_DumpAsPolygons()</kbd>. This is due to the different mechanism used in each function.</p>
<p>The following images show the difference between <kbd>ST_DumpAsPolygons()</kbd> and <kbd>ST_PixelsAsPolygons()</kbd>. The <kbd>ST_DumpAsPolygons()</kbd> function only dumps pixels with a value and unites these pixels with the same value. The <kbd>ST_PixelsAsPolygons()</kbd> function does not merge pixels and dumps all of them, as shown in the following diagrams:</p>
<div><img src="img/01d80a68-2208-47ea-9e9d-60b7751d96f6.png" style="width:36.42em;height:10.50em;"/></div>
<p>The <kbd>ST_PixelsAsPolygons()</kbd> function returns one geometry for each pixel. If there are 100 pixels, there will be 100 geometries. Each geometry of <kbd>ST_DumpAsPolygons()</kbd> is the union of all of the pixels in an area with the same value. If there are 100 pixels, there may be up to 100 geometries.</p>
<p>There is one other significant difference between <kbd>ST_PixelAsPolygons()</kbd> and <kbd>ST_DumpAsPolygons()</kbd>. Unlike <kbd>ST_DumpAsPolygons()</kbd>, <kbd>ST_PixelAsPolygons()</kbd> returns a geometry for pixels with the <kbd>NODATA</kbd> value, and has an empty value for the <kbd>val</kbd> column.</p>
<p>Let's convert a geometry to a raster with <kbd>ST_AsRaster()</kbd>. We insert <kbd>ST_AsRaster()</kbd> to return a raster with a pixel size of 100 by <kbd>-100</kbd> meters containing four bands of the pixel type <kbd>8BUI</kbd>. Each of these bands will have a pixel <kbd>NODATA</kbd> value of <kbd>0</kbd>, and a specific pixel value (<kbd>29</kbd>, <kbd>194</kbd>, <kbd>178</kbd>, and <kbd>255</kbd> for each band respectively). The units for the pixel size are determined by the geometry's projection, which is also the projection of the created raster:</p>
<pre><strong>SELECT ST_AsRaster( 
  sf.geom, 
  100., -100., 
  ARRAY['8BUI', '8BUI', '8BUI', '8BUI']::text[], 
  ARRAY[29, 194, 178, 255]::double precision[], 
  ARRAY[0, 0, 0, 0]::double precision[] 
) 
FROM sfpoly sf;</strong> </pre>
<p>If we visualize the generated raster of San Francisco's boundaries and overlay the source geometry, we get the following result, which is a zoomed-in view of the San Francisco boundary's geometry converted to a raster with <kbd>ST_AsRaster()</kbd>:</p>
<div><img src="img/6c03dfb9-4e3b-4402-83e2-76bdf153ec9d.png" style="width:29.75em;height:18.42em;"/></div>
<p>Though it is great that the geometry is now a raster, relating the generated raster to other rasters requires additional processing. This is because the generated raster and the other raster will most likely not be aligned. If the two rasters are not aligned, most PostGIS raster functions do not work. The following figure shows two non-aligned rasters (simplified to pixel grids):</p>
<div><img src="img/f351f242-0287-46de-a31f-2c7265bb24c6.png" style="width:27.08em;height:11.17em;"/></div>
<p>The pixel grids of Raster 1 and Raster 2 are not aligned. If the rasters are aligned, the edges of one grid's cell will be on top of one of the other grid's cell's edges.</p>
<p>When a geometry needs to be converted to a raster so as to relate to an existing raster, use that existing raster as a reference when calling <kbd>ST_AsRaster()</kbd>:</p>
<pre><strong>SELECT ST_AsRaster( 
  sf.geom, prism.rast, 
  ARRAY['8BUI', '8BUI', '8BUI', '8BUI']::text[], 
  ARRAY[29, 194, 178, 255]::double precision[], 
  ARRAY[0, 0, 0, 0]::double precision[] 
) 
FROM chp05.sfpoly sf 
CROSS JOIN chp05.prism 
WHERE prism.rid = 1;</strong> </pre>
<p>In the preceding query, we use the raster tile at <kbd>rid = 1</kbd> as our reference raster. The <kbd>ST_AsRaster()</kbd> function uses the reference raster's metadata to create the geometry's raster. If the geometry and reference raster have different SRIDs, the geometry is transformed to the same SRID before creating the raster.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>In this recipe, we converted rasters to geometries. We also created new rasters from geometries. The ability to convert between rasters and geometries allows the use of functions that would otherwise not be possible.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Processing and loading rasters with GDAL VRT</h1>
                
            
            
                
<p>Though PostGIS has plenty of functions for working with rasters, it is sometimes more convenient and more efficient to work on the source rasters before importing them into the database. One of the times when working with rasters outside the database is more efficient is when the raster contains subdatasets, typically found in HDF4, HDF5, and NetCDF files.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>In this recipe, we will preprocess a MODIS raster with the <strong>GDAL VRT</strong> format to filter and rearrange the subdatasets. Internally, a VRT file is comprised of XML tags. This means we can create a VRT file with any text editor. But since creating a VRT file manually can be tedious, we will use the <kbd>gdalbuildvrt</kbd> utility.</p>
<p>The MODIS raster we use is provided by NASA, and is available in the source package.</p>
<p>You will need GDAL built with HDF4 support to continue with this recipe, as MODIS rasters are usually in the HDF4-EOS format.</p>
<p>The following screenshot shows the MODIS raster used in this recipe and the next two recipes. In the following image, we see parts of California, Nevada, Arizona, and Baja California:</p>
<div><img src="img/f7362496-dfd3-48f7-ba11-cd620533c4a3.png" style="width:20.08em;height:21.42em;"/></div>
<p>To allow PostGIS to properly support MODIS rasters, we will also need to add the MODIS Sinusoidal projection to the <kbd>spatial_ref_sys</kbd> table.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>On the command line, navigate to the <kbd>MODIS</kbd> directory:</p>
<pre> <strong>&gt; cd C:\postgis_cookbook\data\chap05\MODIS</strong></pre>
<p>In the <kbd>MODIS</kbd> directory, there should be several files. One of these files has the name <kbd>srs.sql</kbd> and contains the <kbd>INSERT</kbd> statement needed for the MODIS Sinusoidal projection. Run the <kbd>INSERT</kbd> statement:</p>
<pre><strong>&gt; psql -d postgis_cookbook -f srs.sql</strong></pre>
<p>The main file has the extension HDF. Let's check the metadata of that HDF file:</p>
<pre><strong>&gt; gdalinfo MYD09A1.A2012161.h08v05.005.2012170065756.hdf</strong></pre>
<p>When run, <kbd>gdalinfo</kbd> outputs a lot of information. We are looking for the list of subdatasets found in the <kbd>Subdatasets</kbd> section:</p>
<pre><strong>Subdatasets:</strong> </pre>
<div><img src="img/87853995-72fa-4d08-be9d-cda58f44b7fe.png" style="width:33.83em;height:39.75em;"/></div>
<p>Each subdataset is one variable of the <kbd>MODIS</kbd> raster included in the source code for this chapter. For our purposes, we only need the first four subdatasets, which are as follows:</p>
<ul>
<li>Subdataset 1: 620 - 670 nm (red)</li>
<li>Subdataset 2: 841 - 876 nm (near infrared or NIR)</li>
<li>Subdataset 3: 459 - 479 nm (blue)</li>
<li>Subdataset 4: 545 - 565 nm (green)</li>
</ul>
<p>The VRT format allows us to select the subdatasets to be included in the VRT raster as well as change the order of the subdatasets. We want to rearrange the subdatasets so that they are in the RGB order.</p>
<p>Let's call <kbd>gdalbuildvrt</kbd> to create a VRT file for our MODIS raster. Do not run the following!</p>
<pre><strong>&gt; gdalbuildvrt -separate  modis.vrt <br/> HDF4_EOS:EOS_GRID:"MYD09A1.A2012161.h08v05.005.2012170065756.hdf":MOD_Grid_500m_Surface_Reflectance:sur_refl_b01 <br/> HDF4_EOS:EOS_GRID:"MYD09A1.A2012161.h08v05.005.2012170065756.hdf":MOD_Grid_500m_Surface_Reflectance:sur_refl_b04 <br/> HDF4_EOS:EOS_GRID:"MYD09A1.A2012161.h08v05.005.2012170065756.hdf":MOD_Grid_500m_Surface_Reflectance:sur_refl_b03 <br/> HDF4_EOS:EOS_GRID:"MYD09A1.A2012161.h08v05.005.2012170065756.hdf":MOD_Grid_500m_Surface_Reflectance:sur_refl_b02</strong></pre>
<p>We really hope you did not run the preceding code. The command does work but is too long and cumbersome. It would be better if we can pass a file indicating the subdatasets to include and their order in the VRT. Thankfully, <kbd>gdalbuildvrt</kbd> provides such an option with the <kbd>-input_file_list</kbd> flag.</p>
<p>In the MODIS directory, the <kbd>modis.txt</kbd> file can be passed to <kbd>gdalbuildvrt</kbd> with the <kbd>-input_file_list</kbd> flag. Each line of the <kbd>modis.txt</kbd> file is the name of a subdataset. The order of the subdatasets in the text file dictates the placement of each subdataset in the VRT:</p>
<pre><strong>HDF4_EOS:EOS_GRID:"MYD09A1.A2012161.h08v05.005.2012170065756.hdf":MOD_Grid_500m_Surface_Reflectance:sur_refl_b01 
HDF4_EOS:EOS_GRID:"MYD09A1.A2012161.h08v05.005.2012170065756.hdf":MOD_Grid_500m_Surface_Reflectance:sur_refl_b04 
HDF4_EOS:EOS_GRID:"MYD09A1.A2012161.h08v05.005.2012170065756.hdf":MOD_Grid_500m_Surface_Reflectance:sur_refl_b03 
HDF4_EOS:EOS_GRID:"MYD09A1.A2012161.h08v05.005.2012170065756.hdf":MOD_Grid_500m_Surface_Reflectance:sur_refl_b02</strong> </pre>
<p>Now, call <kbd>gdalbuildvrt</kbd> with <kbd>modis.txt</kbd> in the following manner:</p>
<pre><strong>&gt; gdalbuildvrt -separate -input_file_list modis.txt modis.vrt</strong> </pre>
<p>Feel free to inspect the generated <kbd>modis.vrt</kbd> VRT file in your favorite text editor. Since the contents of the VRT file are just XML tags, it is easy to make additions, changes, and deletions.</p>
<p>We will do one last thing before importing our processed MODIS raster into PostGIS. We will convert the VRT file to a GeoTIFF file with the <kbd>gdal_translate</kbd> utility, because not all applications have built-in support for HDF4, HDF5, NetCDF, or VRT, and the superior portability of GeoTIFF:</p>
<pre><strong>&gt; gdal_translate -of GTiff modis.vrt modis.tif</strong></pre>
<p>Finally, import <kbd>modis.tif</kbd> with <kbd>raster2pgsql</kbd>:</p>
<pre><strong>&gt; raster2pgsql -s 96974 -F -I -C -Y modis.tif chp05.modis | psql -d postgis_cookbook</strong></pre>
<p>The <kbd>raster2pgsql</kbd> supports a long list of input formats. You can call the command with the option -G to see the complete list.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>This recipe was all about processing a MODIS raster into a form suitable for use in PostGIS. We used the <kbd>gdalbuildvrt</kbd> utility to create our VRT. As a bonus, we used <kbd>gdal_translate</kbd> to convert between raster formats; in this case, from VRT to GeoTIFF.</p>
<p>If you're feeling particularly adventurous, try using <kbd>gdalbuildvrt</kbd> to create a VRT of the 12 PRISM rasters with each raster as a separate band.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Warping and resampling rasters</h1>
                
            
            
                
<p>In the previous recipe, we processed a MODIS raster to extract only those subdatasets that are of interest, in a more suitable order. Once done with the extraction, we imported the MODIS raster into its own table.</p>
<p>Here, we make use of the warping capabilities provided in PostGIS. This ranges from simply transforming the MODIS raster to a more suitable projection, to creating an overview by resampling the pixel size.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We will use several PostGIS warping functions, specifically <kbd>ST_Transform()</kbd> and <kbd>ST_Rescale()</kbd>. The <kbd>ST_Transform()</kbd> function reprojects a raster to a new spatial reference system (for example, from WGS84 to NAD83). The <kbd>ST_Rescale()</kbd> function shrinks or grows the pixel size of a raster.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>The first thing we will do is transform our raster, since the MODIS rasters have their own unique spatial-reference system. We will convert the raster from <strong>MODIS Sinusoidal projection</strong> to <strong>US National Atlas Equal Area</strong> (<strong>SRID 2163</strong>).</p>
<p>Before we transform the raster, we will clip the MODIS raster with our San Francisco boundaries geometry. By clipping our raster before transformation, the operation takes less time than it does to transform and then clip the raster:</p>
<pre><strong>SELECT  ST_Transform(ST_Clip(m.rast, ST_Transform(sf.geom, 96974)), 2163) 
FROM chp05.modis m 
CROSS JOIN chp05.sfpoly sf;</strong> </pre>
<p>The following image shows the clipped MODIS raster with the San Francisco boundaries on top for comparison:</p>
<div><img src="img/5eeb5b42-d394-4eb1-9148-c14b19dd11c2.png"/></div>
<p>When we call <kbd>ST_Transform()</kbd> on the MODIS raster, we only pass the destination <kbd>SRID 2163</kbd>. We could specify other parameters, such as the <strong>resampling algorithm</strong> and <strong>error tolerance</strong>. The default resampling algorithm and error tolerance are set to <kbd>NearestNeighbor</kbd> and <kbd>0.125</kbd>. Using a different algorithm and/or lowering the error tolerance may improve the quality of the resampled raster at the cost of more processing time.</p>
<p>Let's transform the MODIS raster again, this time specifying the resampling algorithm and error tolerance as <kbd>Cubic</kbd> and <kbd>0.05</kbd>, respectively. We also indicate that the transformed raster must be aligned to a reference raster:</p>
<pre><strong>SELECT  ST_Transform(ST_Clip(m.rast, ST_Transform(sf.geom, 96974)), </strong><br/><strong> prism.rast, 'cubic', 0.05) 
FROM chp05.modis m 
CROSS JOIN chp05.prism 
CROSS JOIN chp05.sfpoly sf 
WHERE prism.rid = 1; </strong></pre>
<p>Unlike the prior queries where we transform the MODIS raster, let's create an <strong>overview</strong>. An overview is a lower-resolution version of the source raster. If you are familiar with pyramids, an overview is level one of a pyramid, while the source raster is the base level:</p>
<pre><strong>WITH meta AS (SELECT (ST_Metadata(rast)).* FROM chp05.modis) 
SELECT ST_Rescale(modis.rast, meta.scalex * 4., meta.scaley * 4., 'cubic') AS rast 
FROM chp05.modis 
CROSS JOIN meta;</strong> </pre>
<p>The overview is 25% of the resolution of the original MODIS raster. This means four times the scale, and one quarter the width and height. To prevent hardcoding the desired scale X and scale Y, we use the MODIS raster's scale X and scale Y returned by <kbd>ST_Metadata()</kbd>. As you can see in the following image, the overview has a coarser resolution:</p>
<div><img src="img/2081166c-bb2d-4bab-afba-760afffe7893.png" style="width:39.08em;height:21.33em;"/></div>
<p>The rescaled raster is more pixelated due to the reduction of resolution.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Using some of PostGIS's resampling capabilities, we projected the MODIS raster to a different spatial reference with <kbd>ST_Transform()</kbd> as well as controlled the quality of the projected raster. We also created an overview with <kbd>ST_Rescale()</kbd>.</p>
<p>Using these functions and other PostGIS resampling functions, you should be able to manipulate all the rasters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Performing advanced map-algebra operations</h1>
                
            
            
                
<p>In a prior recipe, we used the expression-based map-algebra function <kbd>ST_MapAlgebra()</kbd> to convert the PRISM pixel values to their true values. The expression-based <kbd>ST_MapAlgebra()</kbd> method is easy to use, but limited to operating on at most two raster bands. This restricts the <kbd>ST_MapAlgebra()</kbd> function's usefulness for processes that require more than two input raster bands, such as the <strong>Normalized Difference Vegetation Index</strong> (<strong>NDVI</strong>) and the <strong>Enhanced Vegetation Index</strong> (<strong>EVI</strong>).</p>
<p>There is a variant of <kbd>ST_MapAlgebra()</kbd> designed to support an unlimited number of input raster bands. Instead of taking an expression, this <kbd>ST_MapAlgebra()</kbd> variant requires a callback function. This callback function is run for each set of input pixel values, and returns either a new pixel value, or <kbd>NULL</kbd> for the output pixel. Additionally, this variant of <kbd>ST_MapAlgebra()</kbd> permits operations on neighborhoods (sets of pixels around a center pixel).</p>
<p>PostGIS comes with a set of ready-to-use <kbd>ST_MapAlgebra()</kbd> callback functions. All of these functions are intended for neighborhood calculations, such as computing the average value of a neighborhood, or interpolating empty pixel values.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We will use the MODIS raster to compute the EVI. EVI is a three-band operation consisting of the red, blue, and near-infrared bands. To do an <kbd>ST_MapAlgebra()</kbd> operation on three bands, PostGIS 2.1 or a higher version is required.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To use <kbd>ST_MapAlgebra()</kbd> on more than two bands, we must use the callback function variant. This means we need to create a callback function. Callback functions can be written in any PostgreSQL PL language, such as PL/pgSQL or PL/R. Our callback functions are all written in PL/pgSQL, as this language is always included with a base PostgreSQL installation.</p>
<p>Our callback function uses the following equation to compute the three-band EVI:</p>
<div><img class="fm-editor-equation" src="img/192bfa71-ccfe-4947-be4b-38379be780d6.png" style="width:22.58em;height:2.50em;"/></div>
<p>The following code implements the MODIS EVI function in SQL:</p>
<pre><strong>CREATE OR REPLACE FUNCTION chp05.modis_evi(value double precision[][][], "position" int[][], VARIADIC userargs text[]) 
RETURNS double precision 
AS $$ 
DECLARE 
  L double precision; 
  C1 double precision; 
  C2 double precision; 
  G double precision; 
  _value double precision[3]; 
  _n double precision; 
  _d double precision; 
BEGIN 
  -- userargs provides coefficients 
  L := userargs[1]::double precision; 
  C1 := userargs[2]::double precision; 
  C2 := userargs[3]::double precision; 
  G := userargs[4]::double precision; 
  -- rescale values, optional 
  _value[1] := value[1][1][1] * 0.0001; 
  _value[2] := value[2][1][1] * 0.0001; 
  _value[3] := value[3][1][1] * 0.0001; 
  -- value can't be NULL 
  IF 
    _value[1] IS NULL OR 
    _value[2] IS NULL OR 
    _value[3] IS NULL 
    THEN 
      RETURN NULL; 
  END IF; 
  -- compute numerator and denominator 
  _n := (_value[3] - _value[1]); 
  _d := (_value[3] + (C1 * _value[1]) - (C2 * _value[2]) + L); 
  -- prevent division by zero 
  IF _d::numeric(16, 10) = 0.::numeric(16, 10) THEN 
    RETURN NULL; 
  END IF; 
  RETURN G * (_n / _d); 
END; 
$$ LANGUAGE plpgsql IMMUTABLE;</strong> </pre>
<p>If you can't create the function, you probably do not have the necessary privileges in the database.</p>
<p>There are several characteristics required for all of the callback functions. These are as follows:</p>
<ul>
<li>All <kbd>ST_MapAlgebra()</kbd> callback functions must have three input parameters, namely, <kbd>double precision[]</kbd>, <kbd>integer[]</kbd>, and <kbd>variadic text[]</kbd>. The <kbd>value</kbd> parameter is a 3D array where the first dimension denotes the raster index, the second dimension the Y axis, and the third dimension the X axis. The position parameter is an array of two dimensions, with the first dimension indicating the raster index, and the second dimension consisting of the X, Y coordinates of the center pixel. The last parameter, <kbd>userargs</kbd>, is a 1D array of zero or more elements containing values that a user wants to pass to the <kbd>callback</kbd> function. If visualized, the parameters look like the following:</li>
</ul>
<pre>        value = ARRAY[ 1 =&gt; <br/>          [ -- raster 1 
            [pixval, pixval, pixval], -- row of raster 1 
            [pixval, pixval, pixval], 
            [pixval, pixval, pixval] 
          ], 
          2 =&gt; [ -- raster 2 
            [pixval, pixval, pixval], -- row of raster 2 
            [pixval, pixval, pixval], 
            [pixval, pixval, pixval] 
          ], 
          ... 
          N =&gt; [ -- raster N 
            [pixval, pixval, pixval], -- row of raster 
            [pixval, pixval, pixval], 
            [pixval, pixval, pixval] 
          ] 
        ]; 
        pos := ARRAY[ 
          0 =&gt; [x-coordinate, y-coordinate], -- center pixel o f output raster 
          1 =&gt; [x-coordinate, y-coordinate], -- center pixel o f raster 1 
          2 =&gt; [x-coordinate, y-coordinate], -- center pixel o f raster 2 
          ... 
          N =&gt; [x-coordinate, y-coordinate], -- center pixel o f raster N 
        ]; 
        userargs := ARRAY[ 
          'arg1', 
          'arg2', 
          ... 
          'argN' 
        ]; </pre>
<ul>
<li>All <kbd>ST_MapAlgebra()</kbd> callback functions must return a double-precision value.</li>
</ul>
<p>If the callback functions are not correctly structured, the <kbd>ST_MapAlgebra()</kbd> function will fail or behave incorrectly.</p>
<p>In the function body, we convert the user arguments to their correct datatypes, rescale the pixel values, check that no pixel values are <kbd>NULL</kbd> (arithmetic operations with <kbd>NULL</kbd> values always result in <kbd>NULL</kbd>), compute the numerator and denominator components of <kbd>EVI</kbd>, check that the denominator is not zero (prevent division by zero), and then finish the computation of <kbd>EVI</kbd>.</p>
<p>Now we call our callback function, <kbd>modis_evi(),</kbd> with <kbd>ST_MapAlgebra()</kbd>:</p>
<pre><strong>SELECT ST_MapAlgebra(rast, ARRAY[1, 3, 4]::int[], -- only use the red, blue a 
nd near infrared bands 'chp05.modis_evi(</strong><br/><strong>  double precision[], int[], text[])'::regprocedure, </strong><br/><strong>  -- signature for callback function '32BF', </strong><br/><strong>  -- output pixel type 'FIRST', 
  NULL, 0, 0, '1.', -- L '6.', -- C1 '7.5', -- C2 '2.5' -- G 
) AS rast 
FROM modis m;</strong> </pre>
<p>In our call to <kbd>ST_MapAlgebra()</kbd>, there are three criteria to take note of, which are as follows:</p>
<ul>
<li>The signature for the <kbd>modis_evi()</kbd> callback function. When passing the callback function to <kbd>ST_MapAlgebra()</kbd>, it must be written as a string containing the function name and the input-parameter types.</li>
<li>The last four function parameters (<kbd>'1.'</kbd>, <kbd>'6.'</kbd>, <kbd>'7.5'</kbd>, <kbd>'2.5'</kbd>) are user-defined arguments that are passed for processing by the <kbd>callback</kbd> function.</li>
<li>The order of the band numbers affects the order of the pixel values passed to the callback function.</li>
</ul>
<p>The following images show the MODIS raster before and after running the EVI operation. The EVI raster has a pale white to dark green colormap applied for highlighting areas of high vegetation:</p>
<div><img src="img/4eb54f5a-f324-4005-a135-6db27f6c12b1.png" style="width:39.25em;height:22.00em;"/></div>
<p>If you are unable to run the standard EVI operation, or want more practice, we will now compute a two-band EVI. We will use the <kbd>ST_MapAlgebraFct()</kbd> function. Please note that <kbd>ST_MapAlgebraFct()</kbd> is deprecated in PostGIS 2.1, and may be removed in the future versions.</p>
<p>For the two-band EVI, we will use the following <kbd>callback</kbd> function. The two-band EVI equation is computed with the following code:</p>
<pre><strong>CREATE OR REPLACE FUNCTION chp05.modis_evi2(value1 double precision, value2 double precision, pos int[], VARIADIC userargs text[]) 
RETURNS double precision 
AS $$ 
DECLARE 
  L double precision; 
  C double precision; 
  G double precision; 
  _value1 double precision; 
  _value2 double precision; 
  _n double precision; 
  _d double precision; 
BEGIN 
  -- userargs provides coefficients 
  L := userargs[1]::double precision; 
  C := userargs[2]::double precision; 
  G := userargs[3]::double precision; 
  -- value can't be NULL 
  IF 
    value1 IS NULL OR 
    value2 IS NULL 
    THEN 
      RETURN NULL; 
  END IF; 
  _value1 := value1 * 0.0001; 
  _value2 := value2 * 0.0001; 
  -- compute numerator and denominator 
  _n := (_value2 - _value1); 
  _d := (L + _value2 + (C * _value1)); 
  -- prevent division by zero 
  IF _d::numeric(16, 10) = 0.::numeric(16, 10) THEN 
    RETURN NULL; 
  END IF; 
  RETURN G * (_n / _d); 
END; 
$$ LANGUAGE plpgsql IMMUTABLE;</strong> </pre>
<p>Like <kbd>ST_MapAlgebra()</kbd> callback functions, <kbd>ST_MapAlgebraFct()</kbd> requires callback functions to be structured in a specific manner. There is a difference between the callback function for <kbd>ST_MapAlgebraFct()</kbd> and the prior one for <kbd>ST_MapAlgebra()</kbd>. This function has two simple pixel-value parameters instead of an array for all pixel values:</p>
<pre><strong>SELECT ST_MapAlgebraFct( 
   rast, 1, -- red band 
   rast, 4, -- NIR band 
   'modis_evi2(double precision, double precision, int[], text[])'::regprocedure,</strong><br/><strong>   -- signature for callback function '32BF', -- output pixel type 'FIRST', 
   '1.', -- L '2.4', -- C '2.5' -- G) AS rast 
FROM chp05.modis m;</strong> </pre>
<p>Besides the difference in function names, <kbd>ST_MapAlgebraFct()</kbd> is called differently than <kbd>ST_MapAlgebra()</kbd>. The same raster is passed to <kbd>ST_MapAlgebraFct()</kbd> twice. The other difference is that there is one less user-defined argument being passed to the <kbd>callback</kbd> function, as the two-band EVI has one less coefficient.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We demonstrated some of the advanced uses of PostGIS's map-algebra functions by computing the three-band and two-band EVIs from our MODIS raster. This was achieved using <kbd>ST_MapAlgebra()</kbd> and <kbd>ST_MapAlgebraFct()</kbd>, respectively. With some planning, PostGIS's map-algebra functions can be applied to other uses, such as edge detection and contrast stretching.</p>
<p class="packt_figure">For additional practice, write your own callback function to generate an <em>NDVI</em> raster from the MODIS raster. The equation for NDVI is: <em>NDVI = ((IR - R)/(IR + R)) </em>where <em>IR</em> is the pixel value on the infrared band, and <em>R</em> is the pixel value on the red band. This index generates values between -1.0 and 1.0, in which negative values usually represent non-green elements (water, snow, clouds), and values close to zero represent rocks and deserted land.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Executing DEM operations</h1>
                
            
            
                
<p>PostGIS comes with several functions for use on digital elevation model (DEM) rasters to solve terrain-related problems. Though these problems have historically been in the hydrology domain, they can now be found elsewhere; for example, finding the most fuel-efficient route from point A to point B or determining the best location on a roof for a solar panel. PostGIS 2.0 introduced <kbd>ST_Slope()</kbd>, <kbd>ST_Aspect()</kbd>, and <kbd>ST_HillShade()</kbd> while PostGIS 2.1 added the new functions <kbd>ST_TRI()</kbd>, <kbd>ST_TPI()</kbd>, and <kbd>ST_Roughness()</kbd>, and new variants of existing elevation functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We will use the SRTM raster, loaded as 100 x 100 tiles, in this chapter's first recipe. With it, we will generate slope and hillshade rasters using San Francisco as our area of interest.</p>
<p>The next two queries in the How to do it section use variants of <kbd>ST_Slope()</kbd> and <kbd>ST_HillShade()</kbd> that are only available in PostGIS 2.1 or higher versions. The new variants permit the specification of a custom extent to constrain the processing area of the input raster.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Let's generate a slope raster from a subset of our SRTM raster tiles using <kbd>ST_Slope()</kbd>. A slope raster computes the rate of elevation change from one pixel to a neighboring pixel:</p>
<pre><strong>WITH r AS ( -- union of filtered tiles 
  SELECT ST_Transform(ST_Union(srtm.rast), 3310) AS rast 
  FROM chp05.srtm 
  JOIN chp05.sfpoly sf ON ST_DWithin(ST_Transform(srtm.rast::geometry,  
     3310), ST_Transform(sf.geom, 3310), 1000)),  
  cx AS ( -- custom extent 
    SELECT ST_AsRaster(ST_Transform(sf.geom, 3310), r.rast) AS rast 
    FROM chp05.sfpoly sf CROSS JOIN r 
  ) 
  SELECT ST_Clip(ST_Slope(r.rast, 1, cx.rast), ST_Transform(sf.geom, 3310)) AS rast FROM r 
CROSS JOIN cx 
CROSS JOIN chp05.sfpoly sf;</strong> </pre>
<p>All spatial objects in this query are projected to <strong>California Albers</strong> (<strong>SRID 3310</strong>), a projection with units in meters. This projection eases the use of <kbd>ST_DWithin()</kbd> to broaden our area of interest to include the tiles within 1,000 meters of San Francisco's boundaries, which improves the computed slope values for the pixels at the edges of the San Francisco boundaries. We also use a rasterized version of our San Francisco boundaries as the custom extent for restricting the computed area. After running <kbd>ST_Slope()</kbd>, we clip the slope raster just to San Francisco.</p>
<p>We can reuse the <kbd>ST_Slope()</kbd> query and substitute <kbd>ST_HillShade()</kbd> for <kbd>ST_Slope()</kbd> to create a hillshade raster, showing how the sun would illuminate the terrain of the SRTM raster:</p>
<pre><strong>WITH r AS ( -- union of filtered tiles 
  SELECT ST_Transform(ST_Union(srtm.rast), 3310) AS rast 
  FROM chp05.srtm 
  JOIN chp05.sfpoly sf ON ST_DWithin(ST_Transform(srtm.rast::geometry,  
    3310), ST_Transform(sf.geom, 3310), 1000)), </strong><br/><strong>  cx AS ( -- custom extent 
    SELECT ST_AsRaster(ST_Transform(sf.geom, 3310), r.rast) AS rast FROM chp05.sfpoly sf CROSS JOIN r) 
SELECT ST_Clip(ST_HillShade(r.rast, 1, cx.rast),ST_Transform(sf.geom, 3310)) AS rast FROM r 
CROSS JOIN cx 
CROSS JOIN chp05.sfpoly sf;</strong> </pre>
<p>In this case, <kbd>ST_HillShade()</kbd> is a drop-in replacement for <kbd>ST_Slope()</kbd> because we do not specify any special input parameters for either function. If we need to specify additional arguments for <kbd>ST_Slope()</kbd> or <kbd>ST_HillShade()</kbd>, all changes are confined to just one line.</p>
<p>The following images show the SRTM raster before and after processing it with <kbd>ST_Slope()</kbd> and <kbd>ST_HillShade()</kbd>:</p>
<div><img src="img/593ad00d-446f-4464-b5a6-2d1efe0d96ea.png" style="width:39.08em;height:25.25em;"/></div>
<p>As you can see in the screenshot, the slope and hillshade rasters help us better understand the terrain of San Francisco.</p>
<p>If PostGIS 2.0 is available, we can still use 2.0's <kbd>ST_Slope()</kbd> and <kbd>ST_HillShade()</kbd> to create slope and hillshade rasters. But there are several differences you need to be aware of, which are as follows:</p>
<ul>
<li><kbd>ST_Slope()</kbd> and <kbd>ST_Aspect()</kbd> return a raster with values in radians instead of degrees</li>
<li>Some input parameters of <kbd>ST_HillShade()</kbd> are expressed in radians instead of degrees</li>
<li>The computed raster from <kbd>ST_Slope()</kbd>, <kbd>ST_Aspect()</kbd>, or <kbd>ST_HillShade()</kbd> has an empty 1-pixel border on all four sides</li>
</ul>
<p>We can adapt our <kbd>ST_Slope()</kbd> query from the beginning of this recipe by removing the creation and application of the custom extent. Since the custom extent constrained the computation to just a specific area, the inability to specify such a constraint means PostGIS 2.0's <kbd>ST_Slope()</kbd> will perform slower:</p>
<pre><strong>WITH r AS ( -- union of filtered tiles 
  SELECT ST_Transform(ST_Union(srtm.rast), 3310) AS rast FROM srtm 
  JOIN sfpoly sf ON ST_DWithin(ST_Transform(srtm.rast::geometry, 3310),</strong><br/><strong>    ST_Transform(sf.geom, 3310), 1000) 
) 
SELECT ST_Clip(ST_Slope(r.rast, 1), ST_Transform(sf.geom, 3310)) AS rast 
FROM r CROSS JOIN sfpoly sf;</strong> </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The DEM functions in PostGIS allowed us to quickly analyze our SRTM raster. In the basic use cases, we were able to swap one function for another without any issues.</p>
<p>What is impressive about these DEM functions is that they are all wrappers around <kbd>ST_MapAlgebra()</kbd>. The power of <kbd>ST_MapAlgebra()</kbd> is in its adaptability to different problems.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Sharing and visualizing rasters through SQL</h1>
                
            
            
                
<p>In <a href="68182eea-7041-4488-9f05-188b0a493ba5.xhtml">Chapter 4</a>, <em>Working with Vector Data – Advanced Recipes</em>, we used <kbd>gdal_translate</kbd> to export PostGIS rasters to a file. This provides a method for transferring files from one user to another, or from one location to another. The only problem with this method is that you may not have access to the <kbd>gdal_translate</kbd> utility.</p>
<p>A different but equally functional approach is to use the <kbd>ST_AsGDALRaster()</kbd> family of functions available in PostGIS. In addition to <kbd>ST_AsGDALRaster()</kbd>, PostGIS provides <kbd>ST_AsTIFF()</kbd>, <kbd>ST_AsPNG()</kbd>, and <kbd>ST_AsJPEG()</kbd> to support the most common raster file formats.</p>
<p>To easily visualize raster files without the need for a GIS application, PostGIS 2.1 and later versions provide <kbd>ST_ColorMap()</kbd>. This function applies a built-in or user-specified color palette to a raster, that upon exporting with <kbd>ST_AsGDALRaster()</kbd>, can be viewed with any image viewer, such as a web browser.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>In this recipe, we will use <kbd>ST_AsTIFF()</kbd> and <kbd>ST_AsPNG()</kbd>to export rasters to GeoTIFF and PNG file formats, respectively. We will also apply the <kbd>ST_ColorMap()</kbd> so that we can see them in any image viewer.</p>
<p>To enable GDAL drivers in PostGIS, you should run the following command in <kbd>pgAdmin</kbd>:</p>
<pre><strong>SET postgis.gdal_enabled_drivers = 'ENABLE_ALL'; </strong>
<strong>SELECT short_name</strong>
<strong>FROM ST_GDALDrivers();</strong></pre>
<p>The following queries can be run in a standard SQL client, such as <strong>psql</strong> or <strong>pgAdminIII</strong>; however, we can't use the returned output because the output has escaped, and these clients do not undo the escaping. Applications with lower-level API functions can unescape the query output. Examples of this would be a PHP script, a pass-a-record element to <kbd>pg_unescape_bytea()</kbd>, or a Python script using Psycopg2's implicit decoding while fetching a record. A sample PHP script (<kbd>save_raster_to_file.php</kbd>) can be found in this chapter's <kbd>data</kbd> directory.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Let us say that a colleague asks for the monthly minimum temperature data for San Francisco during the summer months as a single raster file. This entails restricting our PRISM rasters to June, July, and August, clipping each monthly raster to San Francisco's boundaries, creating one raster with each monthly raster as a band, and then outputting the combined raster to a portable raster format. We will convert the combined raster to the GeoTIFF format:</p>
<pre><strong>WITH months AS ( -- extract monthly rasters clipped to San Francisco 
   SELECT prism.month_year, ST_Union(ST_Clip(prism.rast, 2, ST_Transform(sf.geom, 4269), TRUE)) AS rast 
  FROM chp05.prism 
  JOIN chp05.sfpoly sf ON ST_Intersects(prism.rast, ST_Transform(sf.geom, 4269)) 
  WHERE prism.month_year BETWEEN '2017-06-01'::date AND '2017-08-01'::date 
  GROUP BY prism.month_year 
  ORDER BY prism.month_year 
), summer AS ( -- new raster with each monthly raster as a band 
  SELECT ST_AddBand(NULL::raster, array_agg(rast)) AS rast FROM months) 
SELECT -- export as GeoTIFF ST_AsTIFF(rast) AS content FROM summer;</strong> </pre>
<p>To filter our PRISM rasters, we use <kbd>ST_Intersects()</kbd> to keep only those raster tiles that spatially intersect San Francisco's boundaries. We also remove all rasters whose relevant month is not June, July, or August. We then use <kbd>ST_AddBand()</kbd> to create a new raster with each summer month's new raster band. Finally, we pass the combined raster to <kbd>ST_AsTIFF()</kbd> to generate a GeoTIFF.</p>
<p>If you output the returned value from <kbd>ST_AsTIFF()</kbd> to a file, run <kbd>gdalinfo</kbd> on that file. The <kbd>gdalinfo</kbd> output shows that the GeoTIFF file has three bands, and the coordinate system of SRID 4322:</p>
<pre><strong>Driver: GTiff/GeoTIFF</strong>
<strong>Files: surface.tif</strong>
<strong>Size is 20, 7</strong>
<strong>Coordinate System is:</strong>
<strong>GEOGCS["WGS 72",</strong>
  <strong>DATUM["WGS_1972",</strong>
  <strong>SPHEROID["WGS 72",6378135,298.2600000000045, </strong><strong>AUTHORITY["EPSG","7043"]],</strong>
    <strong>       TOWGS84[0,0,4.5,0,0,0.554,0.2263],</strong><strong> AUTHORITY["EPSG","6322"]],</strong>
    <strong>       PRIMEM["Greenwich",0],</strong> <strong>UNIT["degree",0.0174532925199433],</strong>
    <strong>       AUTHORITY["EPSG","4322"]]</strong>
  <strong>Origin = (-123.145833333333314,37.937500000000114)</strong>
  <strong>Pixel Size = (0.041666666666667,-0.041666666666667)</strong>
  <strong>Metadata:</strong>
    <strong>AREA_OR_POINT=Area</strong>
  <strong>Image Structure Metadata:</strong>
    <strong>INTERLEAVE=PIXEL</strong>
<strong>Corner Coordinates:</strong>
  <strong>Upper Left  (-123.1458333,  37.9375000) (123d 8'45.00"W, 3</strong><strong>7d56'15.00"N)</strong>
  <strong>Lower Left  (-123.1458333,  37.6458333) (123d 8'45.00"W, 3</strong><strong>7d38'45.00"N)</strong>
  <strong>Upper Right (-122.3125000,  37.9375000) (122d18'45.00"W, 3</strong><strong>7d56'15.00"N)</strong>
  <strong>Lower Right (-122.3125000,  37.6458333) (122d18'45.00"W, 3</strong><strong>7d38'45.00"N)</strong>
  <strong>Center      (-122.7291667,  37.7916667) (122d43'45.00"W, 3</strong><strong>7d47'30.00"N)</strong>
<strong>Band 1 Block=20x7 Type=Float32, ColorInterp=Gray</strong>
  <strong>NoData Value=-9999</strong>
<strong>Band 2 Block=20x7 Type=Float32, ColorInterp=Undefined</strong>
  <strong>NoData Value=-9999</strong>
<strong>Band 3 Block=20x7 Type=Float32, ColorInterp=Undefined</strong>
  <strong>NoData Value=-9999</strong></pre>
<p>The problem with the GeoTIFF raster is that we generally can't view it in a standard image viewer. If we use <kbd>ST_AsPNG()</kbd> or <kbd>ST_AsJPEG()</kbd>, the image generated is much more readily viewable. But PNG and JPEG images are limited by the supported pixel types 8BUI and 16BUI (PNG only). Both formats are also limited to, at the most, three bands (four, if there is an alpha band).</p>
<p>To help get around various file format limitations, we can use <kbd>ST_MapAlgebra()</kbd>, <kbd>ST_Reclass()</kbd> , or <kbd>ST_ColorMap()</kbd>, for this recipe. The <kbd>ST_ColorMap()</kbd> function converts a raster band of any pixel type to a set of up to four 8BUI bands. This facilitates creating a grayscale, RGB, or RGBA image that is then passed to <kbd>ST_AsPNG()</kbd>, or <kbd>ST_AsJPEG()</kbd>.</p>
<p>Taking our query for computing a slope raster of San Francisco from our SRTM raster in a prior recipe, we can apply one of <kbd>ST_ColorMap()</kbd> function's built-in colormaps, and then pass the resulting raster to <kbd>ST_AsPNG()</kbd> to create a PNG image:</p>
<pre><strong>WITH r AS (SELECT ST_Transform(ST_Union(srtm.rast), 3310) AS rast 
  FROM chp05.srtm 
  JOIN chp05.sfpoly sf ON ST_DWithin(ST_Transform(srtm.rast::geometry, 3310),</strong><br/><strong>  ST_Transform(sf.geom, 3310), 1000) 
), cx AS ( 
  SELECT ST_AsRaster(ST_Transform(sf.geom, 3310), r.rast) AS rast 
  FROM sfpoly sf CROSS JOIN r 
) 
SELECT ST_AsPNG(ST_ColorMap(ST_Clip(ST_Slope(r.rast, 1, cx.rast), ST_Transform(sf.geom, 3310) ), 'bluered')) AS rast 
FROM r 
CROSS JOIN cx 
CROSS JOIN chp05.sfpoly sf;</strong> </pre>
<p>The bluered colormap sets the minimum, median, and maximum pixel values to dark blue, pale white, and bright red, respectively. Pixel values between the minimum, median, and maximum values are assigned colors that are linearly interpolated from the minimum to median or median to maximum range. The resulting image readily shows where the steepest slopes in San Francisco are.</p>
<p>The following is a PNG image generated by applying the bluered colormap with <kbd>ST_ColorMap()</kbd> and <kbd>ST_AsPNG()</kbd>. The pixels in red represent the steepest slopes:</p>
<div><img src="img/1026d40c-71fb-443c-aa7e-30b278a7f344.png" style="width:40.75em;height:34.00em;"/></div>
<p>In our use of <kbd>ST_AsTIFF()</kbd> and <kbd>ST_AsPNG()</kbd>, we passed the raster to be converted as the sole argument. Both of these functions have additional parameters to customize the output TIFF or PNG file. These additional parameters include various compression and data organization settings.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Using <kbd>ST_AsTIFF()</kbd> and <kbd>ST_AsPNG()</kbd>, we exported rasters from PostGIS to GeoTIFF and PNG. The <kbd>ST_ColorMap()</kbd> function helped generate images that can be opened in any image viewer. If we needed to export these images to a different format supported by GDAL, we would use <kbd>ST_AsGDALRaster()</kbd>.</p>


            

            
        
    </body></html>