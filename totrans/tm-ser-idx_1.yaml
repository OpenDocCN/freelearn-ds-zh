- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: An Introduction to Time Series and the Required Python Knowledge
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间序列与所需 Python 知识简介
- en: This is the first chapter of the book that you are reading. Although first chapters
    usually contain basic information that you might want to skip, this is not such
    a chapter. It teaches you the basics of time series and indexing, as well as how
    to set up a proper Python environment, which is going to be used during the development
    of the code of this book. You might need to refer to it while you are reading
    other chapters, which is a good thing! So, let us get started!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您正在阅读的本书的第一章。尽管通常第一章节包含您可能想要跳过的基本信息，但这章并非如此。它教授您时间序列和索引的基础知识，以及如何设置适当的 Python
    环境，该环境将用于本书代码的开发。您在阅读其他章节时可能需要参考它，这是一件好事！所以，让我们开始吧！
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding time series
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解时间序列
- en: What is an index and why do we need indexing?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是索引以及为什么我们需要索引？
- en: The Python knowledge that we are going to need
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将要需要的 Python 知识
- en: Reading time series from disk
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从磁盘读取时间序列
- en: Visualizing time series
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视化时间序列
- en: Working with the Matrix Profile
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用矩阵轮廓
- en: Exploring the MPdist distance
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 MPdist 距离
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In order to follow this chapter, which is the foundation of the entire book,
    you need to have a recent Python 3 version installed on your computer and be able
    to install any other required software on your own. We are not going to teach
    you how to install a Python 3 package, but we are going to tell you which packages
    you should install and the commands that we have used to do so. Similarly, we
    are not going to explain the process of installing new software on your machines,
    but we are going to tell you the command or commands we have used to install a
    given software on our machines.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本章，这是整本书的基础，您需要在您的计算机上安装最新的 Python 3 版本，并且能够自行安装任何其他所需的软件。我们不会教您如何安装 Python
    3 包，但我们会告诉您应该安装哪些包以及我们用来安装这些包的命令。同样，我们不会解释在您的机器上安装新软件的过程，但我们会告诉您我们用来在我们的机器上安装给定软件的命令。
- en: The GitHub repository of the book can be found at [https://github.com/PacktPublishing/Time-Series-Indexing](https://github.com/PacktPublishing/Time-Series-Indexing).
    The code for each chapter is in its own directory. Therefore, the code for [*Chapter
    1*](B14769_01.xhtml#_idTextAnchor015) can be found inside the `ch01` folder. You
    can download the entire repository on your computer using `git(1)`, or you can
    access the files via the GitHub user interface.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本书在 GitHub 上的存储库地址为 [https://github.com/PacktPublishing/Time-Series-Indexing](https://github.com/PacktPublishing/Time-Series-Indexing)。每个章节的代码都在其自己的目录中。因此，[第
    1 章](B14769_01.xhtml#_idTextAnchor015) 的代码可以在 `ch01` 文件夹中找到。您可以使用 `git(1)` 在您的计算机上下载整个存储库，或者您可以通过
    GitHub 用户界面访问这些文件。
- en: 'You can download the entire code of this book, including the code in the `ch01`
    folder, using `git(1)` as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下方式使用 `git(1)` 下载本书的完整代码，包括 `ch01` 文件夹中的代码：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As the repository name is long and the local directory is named after the repository
    name, you can execute the previous command as follows to shorten the folder name:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存储库名称较长，而本地目录以存储库名称命名，您可以通过以下方式执行前面的命令来缩短文件夹名称：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is going to put the contents of the repository in a directory named `tsi`.
    Both ways are valid – do what is best for you.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把存储库的内容放入一个名为 `tsi` 的目录中。两种方式都是有效的——做最适合您的事情。
- en: The code of the book is now on your local machine. However, you are going to
    need to have some Python packages installed for most of the code to run – we are
    going to discuss the required Python packages later on in this chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本书代码现在已存在于您的本地机器上。然而，为了运行大部分代码，您需要安装一些 Python 包——我们将在本章后面讨论所需的 Python 包。
- en: Disclaimer
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 免责声明
- en: This code of the book was written and tested on Arch Linux and macOS Ventura
    machines. Even though the book is Unix-oriented, there exist similar commands
    that can be executed on a Microsoft Windows machine that should not be so difficult
    to find and execute. What is important is the presented code, understanding the
    code and the logic behind it, and being able to execute and make changes to it
    on your own. If this information helps you, I am mainly using Microsoft Visual
    Studio Code to write code on both macOS and Linux.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的代码是在Arch Linux和macOS Ventura机器上编写和测试的。尽管本书以Unix为中心，但在Microsoft Windows机器上也存在类似的命令可以执行，这些命令应该不难找到和执行。重要的是所展示的代码、理解代码及其背后的逻辑，以及能够自己执行和修改它。如果这些信息对您有所帮助，我主要使用Microsoft
    Visual Studio Code在macOS和Linux上编写代码。
- en: Understanding time series
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解时间序列
- en: A time series is a set of data. Keep in mind that a time series does not have
    to contain time or date data in it – time and date data usually come in the form
    of *timestamps*. So, a time series might contain timestamps, but usually, it does
    not. In fact, most of the time series in this book do not contain timestamps.
    In practice, what we really need is ordered data – this is what makes a bunch
    of values a time series.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列是一组数据。请记住，时间序列不一定包含时间或日期数据——时间和日期数据通常以*时间戳*的形式出现。因此，时间序列可能包含时间戳，但通常不包含。实际上，本书中的大多数时间序列都不包含时间戳。在实践中，我们真正需要的是有序数据——这就是使一系列值成为时间序列的原因。
- en: 'Strictly speaking, a time series (*T*) of size *n* is an ordered list of data
    points: T = { t 0, t 1, t 2, … t n−1}. Data points can be timestamped and store
    a single value, a set of values, or a list of values. The index of a time series
    might begin with 1 instead of 0 – in this case, T = { t 1, t 2, t 3, … t n}. What
    is truly important here is that the length of the time series is *n* in both cases.
    So, each element has an index value associated with it, which replaces the need
    for a timestamp. Time series in this book are going to use index values to distinguish
    their elements. The following ordered list can be considered a time series – `{1,
    -2, -3, 4, 5, 1, 2, 0.23, 4.3}`. It contains nine elements. The first element
    is `1` and the last element is `4.3`. If the index of the first element is `0`,
    then the index of the last element would be `8`, whereas if the index of the first
    element is `1`, then the index of the last element is going to be `9`. Time series
    can contain the same value multiple times.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，大小为*n*的时间序列(*T*)是一个有序的数据点列表：T = { t 0, t 1, t 2, … t n−1}。数据点可以是带时间戳的，并存储单个值、一组值或一个值列表。时间序列的索引可能从1开始而不是0——在这种情况下，T
    = { t 1, t 2, t 3, … t n}。真正重要的是，在这两种情况下，时间序列的长度都是*n*。因此，每个元素都有一个与其关联的索引值，这取代了时间戳的需求。本书中的时间序列将使用索引值来区分其元素。以下有序列表可以被视为一个时间序列——`{1,
    -2, -3, 4, 5, 1, 2, 0.23, 4.3}`。它包含九个元素。第一个元素是`1`，最后一个元素是`4.3`。如果第一个元素的索引是`0`，则最后一个元素的索引将是`8`；而如果第一个元素的索引是`1`，则最后一个元素的索引将是`9`。时间序列可以包含相同的值多次。
- en: An alternative definition of time series
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列的另一种定义
- en: A time series is a collection of observations made sequentially in time. Many
    types of observations are not true time series but can be transformed into time
    series.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列是一系列按时间顺序进行的观察结果。许多类型的观察结果并不是真正的时间序列，但可以转换成时间序列。
- en: '*Figure 1**.1* shows a graphical representation of a time series with 1,000
    elements – even with a small time series such as the one presented here, it is
    difficult to search for a specific subsequence or value. As we will discuss later
    on, this is why indexing is important.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**图1.1**.1显示了包含1,000个元素的时间序列的图形表示——即使像这里展示的这样一个小型时间序列，也难以搜索特定的子序列或值。正如我们稍后将要讨论的，这就是为什么索引很重要的原因。'
- en: '![Figure 1.1 – Visualizing a time series](img/Figure_1.1_B14769.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1 – 可视化时间序列](img/Figure_1.1_B14769.jpg)'
- en: Figure 1.1 – Visualizing a time series
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**图1.1 – 可视化时间序列**'
- en: In the *Visualizing time series* section, we will learn how to visualize a time
    series in Python.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在*可视化时间序列*部分，我们将学习如何在Python中可视化时间序列。
- en: The next subsection tells us where we can find time series data.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将告诉我们我们可以在哪里找到时间序列数据。
- en: Time series are everywhere
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间序列无处不在
- en: 'You might now ask where we can find time series. The answer is simple: time
    series are everywhere! From medical data to positional data and from software
    and hardware metrics to financial information and stock prices! Successfully using
    them allows us to find answers to questions we might have, such as which stock
    to sell or which hard disk is going to fail.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问我们可以在哪里找到时间序列。答案是简单的：时间序列无处不在！从医疗数据到位置数据，从软件和硬件指标到金融信息和股价！成功使用它们可以帮助我们找到我们可能有的问题的答案，例如卖哪只股票或哪个硬盘将要失败。
- en: Let us look at some definitions that we need to know to understand the concepts
    better.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们需要了解的一些定义，以更好地理解这些概念。
- en: Essential definitions
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 必要的定义
- en: 'In this subsection, we are going to learn some core definitions related to
    time series:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将学习一些与时间序列相关的核心定义：
- en: The *length* of a time series or a subsequence is the number of elements found
    in the time series or the subsequence.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间序列或子序列的 *长度* 是在时间序列或子序列中找到的元素数量。
- en: A *subsequence* *s* of size *w* of a time series *T* is a sublist of *T*, with
    consecutive elements of length *w*.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间序列 *T* 的大小为 *w* 的 *子序列* *s* 是 *T* 的一个子列表，其长度为 *w* 的连续元素。
- en: A *sliding window* of size *w* decomposes a time series into subsequences of
    size *w*. The sliding window separates a time series into multiple subsequences,
    with a length equal to the sliding window value. Given a time series with length
    *n* and a sliding window of size *w*, the total number of subsequences of size
    *w* is equal to *n*-*w*+*1*.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大小为 *w* 的 *滑动窗口* 将时间序列分解为大小为 *w* 的子序列。滑动窗口将时间序列分割成多个子序列，每个子序列的长度等于滑动窗口的值。给定长度为
    *n* 的时间序列和一个大小为 *w* 的滑动窗口，大小为 *w* 的子序列总数等于 *n*-*w*+*1*。
- en: 'Let us now give you an example. Imagine having the following time series, T:
    {0, 1, 2, 3, 4, 5, 6}. Given a sliding window of size *5*, *T* can be separated
    into the following subsequences:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们给你举一个例子。想象一下有一个以下时间序列，T: {0, 1, 2, 3, 4, 5, 6}。给定大小为 *5* 的滑动窗口，*T* 可以被分割成以下子序列：'
- en: '`{0, 1, 2,` `3, 4}`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{0, 1, 2,` `3, 4}`'
- en: '`{1, 2, 3,` `4, 5}`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{1, 2, 3,` `4, 5}`'
- en: '`{2, 3, 4,` `5, 6}`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{2, 3, 4,` `5, 6}`'
- en: So, we have three subsequences in total, each having a length of *5*. As this
    is a tedious process, we are going to learn how to tell a computer to do that
    for us in this chapter.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们总共有三个子序列，每个子序列的长度为 *5*。由于这是一个繁琐的过程，我们将在本章学习如何让计算机为我们完成这项工作。
- en: The next subsection briefly discusses the subject of time series data mining.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个小节将简要讨论时间序列数据挖掘的主题。
- en: Time series data mining
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间序列数据挖掘
- en: '**Data mining** is the study of collecting, cleaning up, processing, analyzing,
    and understanding data. Data mining is a large subject. In fact, data mining is
    an area of computer science with its own subtopics and areas. The most important
    areas of data mining are the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据挖掘** 是收集、清理、处理、分析和理解数据的研究。数据挖掘是一个庞大的主题。实际上，数据挖掘是计算机科学的一个领域，它有自己的子主题和领域。数据挖掘最重要的领域如下：'
- en: '**Classification**: This is the process of determining the class label of an
    element given a set of predefined class labels'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分类**：这是在给定一组预定义的类别标签的情况下确定一个元素的类别标签的过程'
- en: '**Clustering**: This is the process of grouping data into sets so that group
    members are similar to each other, based on a given criterion, which is usually
    a distance function'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚类**：这是根据给定的标准（通常是距离函数）将数据分组到集合中的过程，使得组内的成员彼此相似'
- en: '**Outlier detection**: This is the process of finding an observation that differs
    from other ones enough to raise suspicions that it was created by a different
    process'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异常检测**：这是寻找一个与其他观察值差异足够大，足以引起怀疑它是由不同过程创建的过程'
- en: '*Time series data mining*, as the term suggests*,* is the data mining of time
    series. The main difference between regular data mining and time series data mining
    is that in time series, data comes sorted by time. Therefore, you cannot arrange
    time series data on your own. Although time gives context, what is important is
    the actual value.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*时间序列数据挖掘*，正如其名称所暗示的，*是时间序列的数据挖掘。与常规数据挖掘相比，时间序列数据挖掘的主要区别在于，在时间序列中，数据是按时间排序的。因此，你不能自己安排时间序列数据。尽管时间提供了上下文，但重要的是实际值。'
- en: Apart from time, time series data can also be characterized by longitude and
    latitude values (*spatial data*). We are not going to deal with spatial data in
    this book.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 除了时间之外，时间序列数据还可以用经纬度值（*空间数据*）来表征。我们在这本书中不会处理空间数据。
- en: Having time series data is good, but it might be useless if we cannot compare
    this data. The next subsection shows some popular techniques and algorithms for
    comparing time series.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有时间序列数据是好的，但如果我们不能比较这些数据，它们可能就毫无用处。接下来的小节将展示一些比较时间序列的流行技术和算法。
- en: Comparing time series
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较时间序列
- en: To compare anything, we need a metric. We can compare numerical values because
    the values are the metrics. But how do we compare time series? This is an active
    research subject that does not have a definitive answer.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要比较任何事物，我们需要一个度量标准。我们可以比较数值，因为数值本身就是度量标准。但如何比较时间序列呢？这是一个活跃的研究课题，目前还没有明确的答案。
- en: Before you continue reading the remaining chapter, take some time and try to
    think whether you can compare time series with a different number of elements.
    Is that even possible? *Write down your thoughts* before you continue reading
    and find out the answer.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在你继续阅读剩余的章节之前，花点时间思考一下你是否可以用不同数量的元素来比较时间序列。这是否可能？在继续阅读并找到答案之前，*写下你的想法*。
- en: Well, it turns out that you can compare time series with a different number
    of elements. However, not all metric functions support that functionality.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，结果证明你可以用不同数量的元素来比较时间序列。然而，并非所有度量函数都支持该功能。
- en: Writing and reading
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 写作和阅读
- en: Reading any worthwhile book or research paper is good and allows you to learn
    new things and keep your mind active. However, to test your knowledge and organize
    your thoughts, you need to write them down! I do that all the time. After all,
    this is how this book was created!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读任何有价值的书籍或研究论文都是好的，这让你能够学习新事物并保持头脑活跃。然而，为了测试你的知识和整理你的思路，你需要把它们写下来！我一直在这样做。毕竟，这本书就是这样诞生的！
- en: The Euclidean distance
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 欧几里得距离
- en: The Euclidean distance is a way of finding out how close or how far apart a
    couple of time series are. Put simply, the Euclidean distance measures the shortest
    path between two multidimensional points. A time series or a subsequence with
    more than one element is a multidimensional point.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 欧几里得距离是一种找出两个时间序列有多接近或有多远的方法。简单来说，欧几里得距离衡量的是两个多维点之间的最短路径。一个包含多个元素的时间序列或子序列是一个多维点。
- en: The Euclidean distance **prioritizes time** – it compares data points that appear
    at the same time and ignores anything else. Therefore, if two time series only
    match at different times, they are considered dissimilar. Finally, the Euclidean
    distance works with data of many dimensions – in this book, we use data of one
    dimension only. Do not confuse **multidimensional points** with **multidimensional
    data**. Multidimensional data contains multidimensional points. The time series
    of this book contains data with one dimension only (single values). However, we
    can consider a time series or subsequence as a *multi-dimensional point*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 欧几里得距离**优先考虑时间**——它比较在相同时间出现的数据点，并忽略其他所有内容。因此，如果两个时间序列只在不同的时间匹配，它们被认为是不同的。最后，欧几里得距离与多维度数据一起工作——在这本书中，我们只使用一维数据。不要将**多维点**与**多维数据**混淆。多维数据包含多维点。这本书的时间序列只包含一维数据（单个值）。然而，我们可以将时间序列或子序列视为一个
    *多维点*。
- en: 'The formula to calculate the Euclidean distance of two multidimensional points
    can be described as follows. Given a point p = ( p 1, p 2, … , p n) and a point
    q = ( q 1, q 2, … , q n), the Euclidean distance is the square root of the sum
    of all (p i − q i) 2 values:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 计算两个多维点欧几里得距离的公式可以描述如下。给定一个点 p = ( p 1, p 2, … , p n) 和一个点 q = ( q 1, q 2, …
    , q n)，欧几里得距离是所有 (p i − q i) 2 值之和的平方根：
- en: 'Let us now present some examples by calculating the Euclidean distance of two
    subsequence pairs. The first pair is `p =` `{1, 2, 3}` and `q =` `{0, 2, 2}`.
    So, first, we find all (p i − q i) 2 values:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过计算两个子序列对的欧几里得距离来举一些例子。第一对是 `p =` `{1, 2, 3}` 和 `q =` `{0, 2, 2}`。因此，首先，我们找到所有
    (p i − q i) 2 值：
- en: '*(**1**−**0**)*2*=**1*'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*(**1**−**0**)*2*=**1**'
- en: '*(**2**−**2**)*2*=**0*'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*(**2**−**2**)*2*=**0**'
- en: '*(**3**−**2**)*2*=**1*'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*(**3**−**2**)*2*=**1**'
- en: 'Then, we add the results: 1 + 0 + 1 = 2.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将结果相加：1 + 0 + 1 = 2。
- en: Last, we find the square root of the result, which is approximately equal to
    1.414213.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们找到结果的平方根，它大约等于 1.414213。
- en: 'Now, imagine having the following two time series or subsequences – `p =` `{1,
    2, -1, -3}` and `q =` `{-3, 1, 2, -1}`. Although the time series have the same
    elements, these elements are in a different order. Their Euclidean distance can
    be calculated as before. First, we find all (p i − q i) 2 values:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下有两个以下的时间序列或子序列——`p =` `{1, 2, -1, -3}` 和 `q =` `{-3, 1, 2, -1}`。尽管时间序列具有相同的元素，但这些元素是不同顺序的。它们的欧几里得距离可以像以前一样计算。首先，我们找出所有
    (p i − q i)² 的值：
- en: '[1 − (− 3)] 2 = 4 2 = 16'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[1 − (− 3)]² = 4² = 16'
- en: (2 − 1) 2 = 1 2 = 1
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (2 − 1)² = 1² = 1
- en: ( − 1 − 2) 2 = ( − 3) 2 = 9
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ( − 1 − 2)² = ( − 3)² = 9
- en: '[( − 3) − (− 1)] 2 = ( − 2) 2 = 4'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[( − 3) − (− 1)]² = ( − 2)² = 4'
- en: Therefore, the Euclidean distance is equal to the square root of (16+1+9+4)
    = 30, which approximately is equal to 5.4472.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，欧几里得距离等于 (16+1+9+4) 的平方根 = 30，这大约等于 5.4472。
- en: A major drawback of the Euclidean distance is that it requires the two time
    series to be of the same length. Although there exist techniques to overcome that
    limitation, this is still an issue. One of the techniques involves using extrapolation
    to make the length of the smaller time series equal to the length of the bigger
    one.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 欧几里得距离的一个主要缺点是它要求两个时间序列长度相同。尽管存在克服这一局限性的技术，但这仍然是一个问题。其中一种技术涉及使用外推法使较短的时间序列长度等于较长的时间序列长度。
- en: 'Going forward, we are not going to calculate Euclidean distances manually,
    as *NumPy* offers a better way of doing so – this is illustrated in `ed.py`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的工作中，我们不会手动计算欧几里得距离，因为 *NumPy* 提供了一种更好的方法——这在 `ed.py` 中得到了说明：
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `euclidean()` function takes two NumPy arrays as input and returns their
    Euclidean distance as output, using `np.linalg.norm()`. This works because the
    Euclidean distance is the `l2` norm and the default value of the `ord` parameter
    in `numpy.linalg.norm()` is `2`, which is the reason for not specifically defining
    it. You do not need to remember that; just use the `euclidean()` function when
    needed.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`euclidean()` 函数接受两个 NumPy 数组作为输入，并使用 `np.linalg.norm()` 返回它们的欧几里得距离作为输出。这是因为欧几里得距离是
    `l2` 范数，而 `numpy.linalg.norm()` 中 `ord` 参数的默认值是 `2`，这也是为什么没有特别定义它的原因。你不需要记住这一点；只需在需要时使用
    `euclidean()` 函数即可。'
- en: 'The two time series are hardcoded in the script. Running `ed.py` generates
    the following output:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 两个时间序列硬编码在脚本中。运行 `ed.py` 生成以下输出：
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The Chebyshev distance
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切比雪夫距离
- en: The Chebyshev distance has a totally different logic than the Euclidean distance.
    This does not make it superior or inferior to the Euclidean distance, just different.
    If you do not know what to use, go with the Euclidean distance.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 切比雪夫距离的逻辑与欧几里得距离完全不同。这并不意味着它优于或劣于欧几里得距离，只是不同。如果你不知道该使用什么，就使用欧几里得距离。
- en: So, the Chebyshev distance between two multidimensional points is equal to the
    greatest distance of all |p i − q i| values. The || symbol is the *absolute value*
    of a quantity. Put simply, the *absolute value* of a quantity is equal to the
    value without the plus or minus sign.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，两个多维点之间的切比雪夫距离等于所有 |p i − q i| 值中的最大距离。|| 符号是一个量的 *绝对值*。简单来说，一个量的 *绝对值* 等于不带正负号的值。
- en: 'Let us now present some examples by calculating the Chebyshev distance of two
    subsequence pairs. The first pair is `{1, 2, 3}` and `{0, 2, 2}`. Now, let us
    find the distances between the pairs:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过计算两个子序列对的切比雪夫距离来展示一些示例。第一对是 `{1, 2, 3}` 和 `{0, 2, 2}`。现在，让我们找出这两对之间的距离：
- en: '*|1 – 0| = 1*'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*|1 – 0| = 1*'
- en: '*|2 – 2| = 0*'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*|2 – 2| = 0*'
- en: '*|3 – 2| = 1*'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*|3 – 2| = 1*'
- en: So, the maximum of 1, 0, and 1 is equal to 1, which is the Chebyshev distance.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，1、0 和 1 的最大值等于 1，这就是切比雪夫距离。
- en: 'The second pair is `{1, 2, -1, -3}` and `{-3, 1, 2, -1}`. As before, we find
    the distances between the pairs of the points at the same position (same index):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第二对是 `{1, 2, -1, -3}` 和 `{-3, 1, 2, -1}`。和之前一样，我们找出相同位置（相同索引）的点对之间的距离：
- en: '*|1 – (–3)| = 4*'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*|1 – (–3)| = 4*'
- en: '*|2 – 1| = 1*'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*|2 – 1| = 1*'
- en: '*|(–1) – 2| = 3*'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*|(–1) – 2| = 3*'
- en: '*|(–3) – (–1)| = 2*'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*|(–3) – (–1)| = 2*'
- en: So, the maximum of 4, 1, 3, and 2 is equal to 4, which is the Chebyshev distance
    of the aforementioned pair.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，4、1、3 和 2 的最大值等于 4，这就是上述对之间的切比雪夫距离。
- en: Later in this chapter, we are going to learn about a more sophisticated distance
    function, which is called *MPdist*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将学习一个更复杂的距离函数，称为 *MPdist*。
- en: Now that we know how to compare time series and subsequences, it is time to
    discuss indexes and indexing. Keep in mind that we cannot create an index without
    being able to compare its data, which includes time series data.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何比较时间序列和子序列，是时候讨论索引和索引化了。请记住，如果我们不能比较其数据，包括时间序列数据，我们就无法创建索引。
- en: What is an index and why do we need indexing?
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引是什么？为什么我们需要索引？
- en: Can you imagine searching for a surname in an unsorted list of names? Can you
    imagine looking for a book in a library that does not sort its books based on
    book subject (the Dewey system) and then book title and author surname? I cannot!
    Both examples showcase a naïve but efficient indexing scheme. The more complex
    the data, the more sophisticated the index should be in order to perform quick
    searches and maybe updates on the data.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想象在一个未排序的名字列表中搜索姓氏吗？你能想象在一个不按书籍主题（杜威分类法）排序书籍，然后按书名和作者姓氏排序的图书馆中寻找一本书吗？我不能！这两个例子展示了简单但有效的索引方案。数据越复杂，索引应该越复杂，以便进行快速搜索，也许还能更新数据。
- en: '*Figure 1**.2* shows the visualization of a really small **iSAX** index – in
    reality, as a time series can be really huge, iSAX indexes tend to be much bigger
    and more complex.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1.2* 显示了一个非常小的 **iSAX** 索引的可视化——实际上，由于时间序列可能非常大，iSAX 索引往往更大且更复杂。'
- en: '![Figure 1.2 – A small iSAX index](img/Figure_1.2_B14769.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – 一个小的 iSAX 索引](img/Figure_1.2_B14769.jpg)'
- en: Figure 1.2 – A small iSAX index
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 一个小的 iSAX 索引
- en: Do not try to understand the iSAX index or the titles of the nodes at this point.
    Everything is going to become clearer in [*Chapter 2*](B14769_02_MA.xhtml#_idTextAnchor053)
    and [*Chapter 3*](B14769_03.xhtml#_idTextAnchor081). For now, keep in mind that
    the titles of the nodes are *SAX words* and that there exist two kinds of nodes
    on an iSAX index – *internal nodes* and *terminal nodes* (leaf nodes). Everything
    about the iSAX index and its connection with SAX words will become clear in [*Chapter
    3*](B14769_03.xhtml#_idTextAnchor081).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，不要试图理解 iSAX 索引或节点的标题。一切都会在 [*第 2 章*](B14769_02_MA.xhtml#_idTextAnchor053)
    和 [*第 3 章*](B14769_03.xhtml#_idTextAnchor081) 中变得清晰。现在，请记住节点的标题是 *SAX 词*，并且在一个
    iSAX 索引上存在两种类型的节点 – *内部节点* 和 *终端节点*（叶节点）。关于 iSAX 索引及其与 SAX 词的关系将在 [*第 3 章*](B14769_03.xhtml#_idTextAnchor081)
    中变得清晰。
- en: In the next section, we will begin working with Python and set up our environment.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将开始使用 Python 并设置我们的环境。
- en: The Python knowledge that we are going to need
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们将要需要的 Python 知识
- en: All the presented code in this book is written in Python. Therefore, in this
    section, we are going to present the required Python knowledge for you to follow
    this book better. However, do not expect to learn the basics of Python here –
    more appropriate books exist for that purpose.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中所展示的所有代码都是用 Python 编写的。因此，在本节中，我们将向您展示所需的 Python 知识，以便您更好地跟随本书。然而，不要期望在这里学习
    Python 的基础知识——存在更多适合此目的的书籍。
- en: What about other programming languages?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 关于其他编程语言呢？
- en: Once you learn and understand the presented theory, the Python code of this
    book can be easily translated into any other modern programming language, such
    as Swift, Java, C, C++, Ruby, Kotlin, Go, Rust, or JavaScript.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你学习和理解了所展示的理论，本书中的 Python 代码可以轻松地翻译成任何其他现代编程语言，例如 Swift、Java、C、C++、Ruby、Kotlin、Go、Rust
    或 JavaScript。
- en: You might have compatibility issues with the used Python packages if you keep
    updating them for no particular reason. As a rule of thumb, I would suggest that
    throughout this book, you should use the same package versions, provided that
    they work well with each other. There exist two main ways to achieve that. You
    can stop upgrading your Python installation once you find the versions that work,
    or you can use a Python package manager such as Anaconda or `pyenv`. In this book,
    we are going to use Anaconda.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有特定原因地不断更新所使用的 Python 包，你可能会遇到兼容性问题。作为一个经验法则，我建议在本书中，你应该使用相同的包版本，只要它们彼此兼容。存在两种主要的方法来实现这一点。你可以在找到兼容的版本后停止升级你的
    Python 安装，或者你可以使用 Python 包管理器，如 Anaconda 或 `pyenv`。在本书中，我们将使用 Anaconda。
- en: It does not matter what you use, as long as you know how to operate your tools
    and have a stable and reliable Python environment to work with.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用什么，只要你知道如何操作你的工具，并且有一个稳定可靠的 Python 环境来工作，那就没问题。
- en: I hope we all agree that the most important property of any code is correctness.
    However, after we have working code, we might need to optimize it, but we cannot
    optimize code if we do not know whether it runs slowly or not. So, the next section
    shows you how to calculate the time it takes Python code to execute.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望我们都同意，任何代码最重要的属性是正确性。然而，在我们有了工作的代码之后，我们可能需要对其进行优化，但如果我们不知道它是否运行得慢，我们就无法优化代码。所以，下一节将向您展示如何计算
    Python 代码执行所需的时间。
- en: Timing Python code
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计时 Python 代码
- en: There are times when we need to know how slow or how fast our code is being
    executed because some operations might take hours or even days. This section presents
    a simple technique to calculate the time it takes a block of code to run.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们需要知道我们的代码执行得多慢或多快，因为某些操作可能需要数小时甚至数天。本节介绍了一种计算代码块运行所需时间的简单技术。
- en: 'The `timing.py` script shows a technique to time Python code – this might come
    in really handy when you want to learn how much time it takes for a process to
    finish. The source code of `timing.py` is the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`timing.py` 脚本展示了一种计时 Python 代码的技术——当你想知道一个过程需要多少时间完成时，这可能会非常有用。`timing.py`
    的源代码如下：'
- en: '[PRE4]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We use `time.time()` to initiate the beginning of the timing and the same statement
    to declare the end of the timing. The difference between these two statements
    is the desired result. You can also keep that difference in a separate variable.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `time.time()` 来启动计时，并使用相同的语句来声明计时的结束。这两个语句之间的差异是期望的结果。你还可以将这个差异保存在一个单独的变量中。
- en: 'The program executes `time.sleep(1)` five times, which means the total time
    should be pretty close to 5 seconds. Running `timing.py` generates the following
    kind of output:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 程序执行 `time.sleep(1)` 五次，这意味着总时间应该非常接近 5 秒。运行 `timing.py` 生成以下类型的输出：
- en: '[PRE5]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: About the Python scripts
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Python 脚本
- en: In this book, we are mostly going to show you the Python scripts in full without
    omitting any statements. Although this adds some extra lines, it helps you understand
    the functionality of the Python scripts by looking at their `import` statements
    before reading the actual Python code.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将主要向您展示完整的 Python 脚本，而不会省略任何语句。尽管这增加了额外的行，但它通过查看它们的 `import` 语句来帮助你理解
    Python 脚本的功能，在阅读实际的 Python 代码之前。
- en: The next subsection is about the Anaconda software, which is used to create
    Python environments.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节是关于 Anaconda 软件，它用于创建 Python 环境。
- en: An introduction to Anaconda
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Anaconda 简介
- en: Anaconda is a product for package, dependency, and environment management. Although
    Anaconda is a commercial product, there exists an Individual Edition for solo
    practitioners, students, and researchers. What Anaconda does is create a controlled
    environment where you can define the version of Python as well as the versions
    of the packages you want to use. Additionally, you can create multiple environments
    and switch between them.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Anaconda 是一个用于包、依赖和环境管理的软件产品。尽管 Anaconda 是一个商业产品，但存在一个针对个人从业者、学生和研究人员的个人版。Anaconda
    所做的是创建一个受控环境，在那里你可以定义 Python 的版本以及你想要使用的包的版本。此外，你可以创建多个环境并在它们之间切换。
- en: You do not have to use Anaconda if you do not want to – however, if you are
    using Python 3 and you do not want to become overwhelmed by the details of Python
    3 package versions, incompatibilities, and dependencies, then you should give
    Anaconda a try. The reason for needing package and environment management software
    is because some Python packages are very picky about the Python version used.
    Put simply, Anaconda makes sure that your Python 3 environment is not going to
    change and gives you the capability to transfer your Python 3 environments to
    multiple machines. The Anaconda command line tool is called `conda`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想使用 Anaconda，那也行——然而，如果你正在使用 Python 3 并且不想被 Python 3 包版本、不兼容性和依赖关系的细节所困扰，那么你应该尝试一下
    Anaconda。需要包和环境管理软件的原因是，一些 Python 包对使用的 Python 版本非常挑剔。简单来说，Anaconda 确保你的 Python
    3 环境不会改变，并赋予你将 Python 3 环境转移到多台机器的能力。Anaconda 的命令行工具被称为 `conda`。
- en: Installing Anaconda
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 Anaconda
- en: Anaconda is a huge piece of software, as it contains lots of packages and utilities.
    There exist multiple ways to install Anaconda, which mainly depend on your development
    environment.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Anaconda 是一个庞大的软件，因为它包含了许多包和实用工具。存在多种安装 Anaconda 的方法，这主要取决于你的开发环境。
- en: 'On a macOS Ventura machine, we can install Anaconda using Homebrew as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS Ventura 机器上，我们可以使用 Homebrew 如下安装 Anaconda：
- en: '[PRE6]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'On an Arch Linux machine, Anaconda can be installed as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在Arch Linux机器上，Anaconda可以按照以下方式安装：
- en: '[PRE7]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We will not discuss the Anaconda installation in any more detail. The installation
    process is straightforward and contains lots of information. The single most important
    task to do is to include the Anaconda utilities on your `PATH` environment variable,
    in order for them to be accessible from everywhere on your UNIX shell. This also
    depends on the UNIX shell you are using – I use `zsh` with the Oh My Zsh extensions
    on both my Linux and macOS machines, but your environment might most likely vary.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不会进一步讨论Anaconda的安装细节。安装过程简单直接，包含大量信息。最重要的任务是将Anaconda实用工具添加到你的`PATH`环境变量中，以便在UNIX
    shell的任何地方都可以访问它们。这也取决于你使用的UNIX shell——我在Linux和macOS机器上都使用带有Oh My Zsh扩展的`zsh`，但你的环境可能有所不同。
- en: If you choose to use Anaconda to work with this book, please make sure that
    you can access the `conda` binary and that you can enable and disable Anaconda
    on your machine at will – you might not need to use Anaconda all the time.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择使用Anaconda来处理这本书，请确保你可以访问`conda`二进制文件，并且可以在你的机器上随意启用和禁用Anaconda——你可能并不总是需要使用Anaconda。
- en: 'On my macOS Ventura machine, I can disable Anaconda as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的macOS Ventura机器上，我可以这样禁用Anaconda：
- en: '[PRE8]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'I can also enable Anaconda as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我也可以这样启用Anaconda：
- en: '[PRE9]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You should replace `base` with the desired Anaconda environment.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该将`base`替换为你想要的Anaconda环境。
- en: 'The previous command depends on the path where Anaconda was installed. Therefore,
    on my Arch Linux machine, I should execute the following command instead:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令依赖于Anaconda安装的路径。因此，在我的Arch Linux机器上，我应该执行以下命令：
- en: '[PRE10]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You should modify the previous command to fit your Anaconda installation.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该修改之前的命令以适应你的Anaconda安装。
- en: 'When a new Anaconda version is available, you can update to the latest version
    by executing the next command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当有新的Anaconda版本可用时，你可以通过执行以下命令来更新到最新版本：
- en: '[PRE11]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Creating a new Anaconda environment
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建新的Anaconda环境
- en: 'The single most important thing to decide when creating a new Anaconda environment
    is the selection of the Python 3 version. In order to create a new Anaconda environment
    named `TSI` that uses Python 3.8.5, you should run the following command:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新的Anaconda环境时，最重要的决定是选择Python 3版本。为了创建一个名为`TSI`的新Anaconda环境，并使用Python 3.8.5，你应该运行以下命令：
- en: '[PRE12]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In order to activate this environment, run `conda activate TSI`. The `python3
    --version` command shows the Python version included in a given Anaconda environment.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了激活此环境，运行`conda activate TSI`。`python3 --version`命令显示了给定Anaconda环境中的Python版本。
- en: 'You can list all existing Anaconda environments using the `conda info --envs`
    command (the `*` character shows the active one):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`conda info --envs`命令列出所有现有的Anaconda环境（`*`字符表示活动环境）：
- en: '[PRE13]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Changing to a different environment
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 切换到不同的环境
- en: This subsection presents the `conda` command used to change from one environment
    to another. Changing to a different environment is as simple as activating a different
    environment using `conda` `activate environment_name`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节介绍了用于在不同环境之间切换的`conda`命令。切换到不同的环境就像使用`conda activate environment_name`激活不同的环境一样简单。
- en: Installing a Python package
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装Python包
- en: Although you can still use `pip3` to install Python packages, the best way to
    install a Python package in an Anaconda environment is with the `conda install`
    command. Keep in mind that the `conda install` command cannot install all packages
    – in this case, use `pip3` instead.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你仍然可以使用`pip3`来安装Python包，但在Anaconda环境中安装Python包的最佳方式是使用`conda install`命令。请注意，`conda
    install`命令不能安装所有包——在这种情况下，请使用`pip3`。
- en: Listing all installed packages
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列出所有已安装的包
- en: 'The `conda list` command gives you a full list of installed Python packages
    under a given Anaconda environment. As the list is pretty long, we will show you
    just a part of it:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`conda list`命令会给出给定Anaconda环境中所有已安装Python包的完整列表。由于列表相当长，我们只展示其中的一部分：'
- en: '[PRE14]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Deleting an existing environment
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除现有的环境
- en: 'You can delete an existing Anaconda environment *that is not active* using
    the `conda env remove --name ENVIRONMENT` command. Its execution is illustrated
    in the following output when deleting an environment named `mtsouk`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`conda env remove --name ENVIRONMENT`命令删除一个不活动的现有Anaconda环境。以下是在删除名为`mtsouk`的环境时的输出示例：
- en: '[PRE15]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This discussion of Python environments, package versions, and package incompatibilities
    culminates here. From now on, let us assume that we have a stable Python environment
    where we can use existing Python packages, develop new Python packages, and run
    Python scripts without any issues. The next subsection lists the Python packages
    that we need to install.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Python环境、包版本和包不兼容性的讨论在此达到高潮。从现在开始，让我们假设我们有一个稳定的Python环境，我们可以使用现有的Python包，开发新的Python包，并且可以无任何问题地运行Python脚本。下一小节将列出我们需要安装的Python包。
- en: The required Python packages
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 所需的Python包
- en: 'Here is a list of the required Python packages along with an explanation of
    the use of each one of them:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个所需Python包列表，以及每个包用途的说明：
- en: '`NumPy`: This is the standard Python package for array computing.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NumPy`：这是Python进行数组计算的标准化包。'
- en: '`Pandas`: This package offers data structures for data analysis, time series,
    and statistics, including functions to read data files from disk.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pandas`：此包提供数据分析、时间序列和统计学的数据结构，包括从磁盘读取数据文件的函数。'
- en: '`SciPy`: This package offers fundamental functions for scientific computing
    in Python.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SciPy`：此包为Python科学计算提供基本函数。'
- en: '`Matplotlib`: This is the most popular Python package for scientific plotting.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Matplotlib`：这是最受欢迎的Python科学绘图包。'
- en: '`Stumpy`: This is a powerful package for time series analysis and time series
    data mining. You do not have to install it right away, as it is not needed for
    the development of the iSAX index.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stumpy`：这是一个强大的时间序列分析和时间序列数据挖掘包。您无需立即安装它，因为它对于iSAX索引的开发不是必需的。'
- en: These are the basic packages that you need to install in a fresh Python environment.
    Python will automatically install any package dependencies.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是在一个全新的Python环境中您需要安装的基本包。Python将自动安装任何包依赖项。
- en: Setting up our environment
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置我们的环境
- en: 'In this subsection, we are going to set up our Anaconda environment. As explained
    earlier, this is not required to follow this book, but it will save you from Python
    package incompatibilities that might come up when upgrading Python and Python
    packages. We will execute the following commands in the `TSI` Anaconda environment,
    and then we are done:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将设置我们的Anaconda环境。如前所述，这不是遵循本书所必需的，但它将帮助您避免在升级Python和Python包时可能出现的Python包不兼容问题。我们将在`TSI`
    Anaconda环境中执行以下命令，然后我们就完成了：
- en: '[PRE16]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Printing package versions
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打印包版本
- en: In this subsection, we present a Python script that just loads the desired packages
    and prints their versions on screen.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将展示一个Python脚本，该脚本仅加载所需的包并在屏幕上打印它们的版本。
- en: 'The code of `load_packages.py` is the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`load_packages.py`的代码如下：'
- en: '[PRE17]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Running `load_packages.py` on one of my UNIX machines prints the following
    information:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的UNIX机器上运行`load_packages.py`会打印以下信息：
- en: '[PRE18]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first command is needed to make the Python script executable and is required
    for all Python scripts presented in this book, provided that they begin with the
    `#!/usr/bin/env python3` statement. If they do not begin with that statement,
    you can execute them using `python3 <script_name>` without the need to change
    their permissions. You can learn more about the `chmod(1)` command by running
    `man chmod`. From now on, we will assume that you know this information and will
    not present any more `chmod` commands and instructions. Your output might be a
    little different, but that is OK, as packages get updated.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令是使Python脚本可执行所必需的，并且对于本书中所有以`#!/usr/bin/env python3`语句开始的Python脚本都是必需的。如果它们不以该语句开始，您可以使用`python3
    <script_name>`来执行它们，而无需更改它们的权限。您可以通过运行`man chmod`来了解更多关于`chmod(1)`命令的信息。从现在开始，我们将假设您知道这些信息，并且不会展示更多的`chmod`命令和说明。您的输出可能略有不同，但这是正常的，因为包会更新。
- en: Creating sample data
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建样本数据
- en: The official name of sample data created by a program is **synthetic data**.
    This subsection is going to present a Python script that creates synthetic data
    based on given parameters. The logic of the program is based on randomly generated
    numbers – as most of you might know, randomly generated numbers are not that random.
    This makes them good for testing the performance of a program but not the actual
    use of it. However, for the purposes of this book, synthetic data generated with
    the help of random numbers is fine!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 程序创建的样本数据的官方名称是**合成数据**。本节将展示一个基于给定参数创建合成数据的Python脚本。程序的逻辑基于随机生成的数字——正如你们大多数人可能知道的，随机生成的数字并不那么随机。这使得它们适合测试程序的性能，但不适合实际使用。然而，为了本书的目的，使用随机数生成的合成数据是可以接受的！
- en: 'The code of the `synthetic_data.py` Python script is as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`synthetic_data.py` Python脚本的代码如下：'
- en: '[PRE19]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The script accepts three parameters, which are the *number of floating-point
    values* to create the minimum value and the maximum value. Running the script
    generates the following kind of output:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本接受三个参数，即创建最小值和最大值所需的浮点数值数量。运行脚本会生成以下类型的输出：
- en: '[PRE20]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As floating-point values can have any precision you want, the `precision` variable
    holds the number of digits after the decimal point that will be printed.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 由于浮点值可以具有任何所需的精度，`precision`变量保存了小数点后要打印的数字位数。
- en: Creating your own time series is not the only way to get data. Publicly available
    time series data also exists. Let us check this out next.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自己的时间序列并不是获取数据的唯一方式。公开可用的时序数据也存在。让我们接下来看看这个。
- en: Publicly available time series data
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 公开可用的时序数据
- en: Websites exist that offer samples of time series data, allowing everyone to
    process real-world time series data. Another important aspect of publicly available
    time series data is that people can compare the performance of their techniques,
    using the same datasets, with others. This is a huge issue in academia, where
    people have to prove that their techniques and algorithms are faster or more efficient
    in a variety of aspects compared to others.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 存在提供时间序列数据样本的网站，允许每个人处理真实世界的时间序列数据。公开可用的时序数据的另一个重要方面是，人们可以使用相同的数据集与其他人比较他们的技术性能。这在学术界是一个大问题，因为人们必须证明他们的技术和算法在多个方面比其他人更快或更有效率。
- en: A very popular set of publicly available time series data files can be found
    at [https://www.cs.ucr.edu/~eamonn/time_series_data_2018/](https://www.cs.ucr.edu/~eamonn/time_series_data_2018/)
    (the UCR Time Series Classification Archive).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一组非常流行的公开可用的时序数据文件可以在[https://www.cs.ucr.edu/~eamonn/time_series_data_2018/](https://www.cs.ucr.edu/~eamonn/time_series_data_2018/)（UCR时间序列分类存档）找到。
- en: How time series are processed
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何处理时间序列
- en: 'Time series processing in Python usually follows these steps:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中进行时间序列处理通常遵循以下步骤：
- en: '**Importing to Python**: In this step, we import the time series into Python.
    There exist multiple ways to do that, including reading from a local file, a database
    server, or an Internet location. In this book, we include all used time series
    in the GitHub repository as plain text files, which are compressed to save disk
    space.'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**导入到Python**：在这个步骤中，我们将时间序列导入到Python中。有多种方法可以实现这一点，包括从本地文件、数据库服务器或互联网位置读取。在这本书中，我们将所有使用的时间序列包含在GitHub仓库中，作为纯文本文件，这些文件被压缩以节省磁盘空间。'
- en: '**Converting it into a time series**: In this step, we convert the data we
    read in the previous step into a valid time series format. This mainly depends
    on the Python package used to store the time series data.'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将其转换为时间序列**：在这个步骤中，我们将之前读取的数据转换为有效的时间序列格式。这主要取决于存储时间序列数据的Python包。'
- en: '**Dealing with missing values**: In this step, we look for missing values and
    ways to deal with them. We are not going to deal with missing values in this book.
    All presented time series are complete.'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理缺失值**：在这个步骤中，我们寻找缺失值以及处理它们的方法。在这本书中，我们不会处理缺失值。所有展示的时间序列都是完整的。'
- en: '**Processing time series**: This last step involves processing a time series
    in order to perform the desired task or tasks.'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理时间序列**：这一最后步骤涉及处理时间序列以执行所需的任务或任务。'
- en: Reading time series from disk
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从磁盘读取时间序列
- en: 'After storing a time series in a file, we need to write the necessary Python
    code to read it and put it in a Python variable of some type. This section will
    teach you exactly that. The `read_ts.py` script contains the following code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在将时间序列存储在文件中之后，我们需要编写必要的 Python 代码来读取它并将其放入某种类型的 Python 变量中。本节将向您展示如何做到这一点。`read_ts.py`
    脚本包含以下代码：
- en: '[PRE21]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After reading the time series, `read_ts.py` prints the number of elements in
    the time series:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取时间序列后，`read_ts.py` 打印时间序列中的元素数量：
- en: '[PRE22]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `pd.read_csv()` function reads a plain text file that uses the CSV format
    – in our case, each value is on its own line, so there should be no issues with
    separating values that reside on the same line. The `pd.read_csv()` function is
    able to detect issues in the input file. The return value of `pd.read_csv()` is
    a *DataFrame* or *TextParser*. In our case, it is a *DataFrame*.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`pd.read_csv()` 函数读取一个使用 CSV 格式的纯文本文件——在我们的案例中，每个值都在其自己的行上，因此应该没有问题，可以分隔同一行上的值。`pd.read_csv()`
    函数能够检测输入文件中的问题。`pd.read_csv()` 的返回值是一个 *DataFrame* 或 *TextParser*。在我们的案例中，它是一个
    *DataFrame*。'
- en: Putting `.astype(np.float64)` at the end of the `pd.read_csv()` statement is
    going to ensure that all values are read as floating-point values, even when the
    entire time series contains integer values only. Additionally, `header = None`
    ensures that the input does not contain a header line with text or data different
    from the actual data.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `pd.read_csv()` 语句的末尾放置 `.astype(np.float64)` 将确保所有值都被读取为浮点值，即使整个时间序列只包含整数值。此外，`header
    = None` 确保输入不包含包含文本或与实际数据不同的标题行的行。
- en: The `ts1Temp.to_numpy()` call converts a *DataFrame* into a NumPy array. So,
    the return value of `ts1Temp.to_numpy()` is a NumPy array. This is needed because
    we will work with NumPy arrays.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`ts1Temp.to_numpy()` 调用将一个 *DataFrame* 转换为 NumPy 数组。因此，`ts1Temp.to_numpy()`
    的返回值是一个 NumPy 数组。这是必需的，因为我们将会使用 NumPy 数组。'
- en: The `ta.reshape(len(ta))` call gives a new shape to an existing NumPy array
    without changing the data. This is needed for processing the time series data
    using the correct shape.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`ta.reshape(len(ta))` 调用在不改变数据的情况下给现有的 NumPy 数组赋予一个新的形状。这是为了使用正确的形状处理时间序列数据。'
- en: As files with time series can be pretty big, it is a good idea to compress them
    and use them in compressed format. Fortunately, Pandas can read compressed files
    with the help of a parameter. This is illustrated in the `read_ts_gz.py` script.
    The statement that does the job is `pd.read_csv(filename, compression='gzip',
    header = None).astype(np.float64)`. Here, you also see `.astype(np.float64)` in
    action.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 由于时间序列文件可能相当大，因此压缩它们并以压缩格式使用是一个好主意。幸运的是，Pandas 可以通过一个参数读取压缩文件。这可以在 `read_ts_gz.py`
    脚本中看到。执行任务的语句是 `pd.read_csv(filename, compression='gzip', header = None).astype(np.float64)`。在这里，您也可以看到
    `.astype(np.float64)` 的实际应用。
- en: How to store time series
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如何存储时间序列
- en: This book uses plain text files to store time series. In these files, each value
    is in a separate line. More ways exist to store a time series, including the CSV
    format and the JSON format.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用纯文本文件来存储时间序列。在这些文件中，每个值都在单独的一行上。存储时间序列的方法还有很多，包括 CSV 格式和 JSON 格式。
- en: Is all data numeric?
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 所有数据都是数值的吗？
- en: Not all data is numeric, but in time series, almost all data is numeric. The
    presented script reads a plain text file and makes sure that all data is numeric
    – note that the `isNumeric.py` script does not currently support compressed files,
    as it uses the `open()` call to read the input file and it expects a single value
    per line.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有数据都是数值的，但在时间序列中，几乎所有的数据都是数值的。所提供的脚本读取一个纯文本文件并确保所有数据都是数值的——请注意，`isNumeric.py`
    脚本目前不支持压缩文件，因为它使用 `open()` 调用来读取输入文件，并期望每行只有一个值。
- en: 'The code of `isNumeric.py` is as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`isNumeric.py` 的代码如下：'
- en: '[PRE23]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `try` and `except` block is where we try to convert the current string value
    into a floating-point value using `float()`. If this fails, we know that we are
    not dealing with a valid numerical value.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`try` 和 `except` 块是我们尝试使用 `float()` 将当前字符串值转换为浮点值的地方。如果这失败了，我们知道我们处理的不是有效的数值。'
- en: 'Running `isNumeric.py` produces the following kind of output:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `isNumeric.py` 会产生以下类型的输出：
- en: '[PRE24]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As we have three erroneous lines, the result is correct.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有三个错误行，结果才是正确的。
- en: Do all lines have the same amount of data?
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 所有行都有相同数量的数据吗？
- en: In this subsection, we present a script that counts the number of words in each
    line, checks that each word is a valid float value, and checks that each line
    has the same number of values. If not, it states the expected and found number
    of fields. Additionally, it considers the first line read as the correct one,
    so all the following lines should have the same amount of data fields. Values
    are separated by whitespace characters.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本子节中，我们提供了一个脚本，该脚本计算每行的单词数，检查每个单词是否是有效的浮点值，并检查每行是否有相同数量的值。如果不是，它将说明预期的和找到的字段数。此外，它将读取的第一行视为正确的，因此所有后续行应该有相同数量的数据字段。值由空白字符分隔。
- en: 'The code of `floats_per_line.py` is the following:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`floats_per_line.py` 的代码如下：'
- en: '[PRE25]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If `String.split()` is executed without any arguments, it splits the string
    using all the whitespace characters as delimiters, which is what we do here to
    separate the fields of each input line. If your data is in a different format,
    you might need to modify the `String.split()` statement to match your needs.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有参数执行 `String.split()`，它将使用所有空白字符作为分隔符来分割字符串，这正是我们在这里用来分隔每行输入字段的方式。如果你的数据格式不同，你可能需要修改
    `String.split()` 语句以匹配你的需求。
- en: 'Running `floats_per_line.py` produces the following kind of output:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `floats_per_line.py` 产生以下类型的输出：
- en: '[PRE26]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The next subsection shows how to process time series based on the sliding window
    size.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将展示如何根据滑动窗口大小处理时间序列。
- en: Creating subsequences
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建子序列
- en: Although we read a time series as an entity from a plain text file, we process
    it as a large list of subsequences. In this subsection, you are going to learn
    how to process a time series as a list of subsequences, based on a given sliding
    window size.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们从一个纯文本文件中读取时间序列作为一个整体，但我们将其处理为一系列子序列。在本子节中，你将学习如何根据给定的滑动窗口大小将时间序列处理为子序列列表。
- en: 'The name of the Python script is `subsequences.py`. We are going to present
    it in two parts. Among other things, the first part contains the Python structure
    used to keep the subsequences:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Python 脚本的名称是 `subsequences.py`。我们将分两部分介绍它。其中之一是用于存储子序列的 Python 结构：
- en: '[PRE27]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `TS` class has two members, one to hold the actual data (the `ts` variable)
    and the other to keep the index (index variable) number of the subsequence. The
    chapters that follow are going to enrich the `TS` class to fit our growing needs.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`TS` 类有两个成员，一个用于存储实际数据（`ts` 变量）和一个用于存储子序列的索引（索引变量）。接下来的章节将丰富 `TS` 类以适应我们不断增长的需求。'
- en: 'The rest of the script is the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的其余部分如下：
- en: '[PRE28]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `argparse` package helps us put the command-line arguments in order. In
    this case, we expect two parameters: first, the sliding window size (`-w`), and
    second, the filename that holds the time series. The `for` loop is used to split
    the time series into subsequences and generate multiple `TS` class members.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`argparse` 包帮助我们整理命令行参数。在这种情况下，我们期望两个参数：首先，滑动窗口大小（`-w`），其次，包含时间序列的文件名。`for`
    循环用于将时间序列分割成子序列并生成多个 `TS` 类成员。'
- en: The previous code is not something difficult to read or understand or make changes
    to. Expect to see this sort of code in most of the Python scripts in this book!
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码并不难阅读、理解或修改。预期在本书中大多数 Python 脚本中都会看到这种类型的代码！
- en: In its current form, `subsequences.py` generates no output. You will only get
    error messages if something is wrong with the provided filename or its data.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前形式下，`subsequences.py` 不会生成任何输出。如果提供的文件名或其数据有问题，你将只会收到错误信息。
- en: Visualizing time series
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化时间序列
- en: Most of the time, having a high-level overview of your data is an excellent
    way to get to know your data. The best way to get an overview of a time series
    is by visualizing it.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，对数据有一个高级概述是了解数据的一个很好的方法。获取时间序列概述的最佳方式是通过可视化它。
- en: There are multiple ways to visualize a time series, including tools such as
    R or Matlab, or using a large amount of existing JavaScript packages. In this
    section, we are going to use a Python package called Matplotlib for visualizing
    the data. Additionally, we will save the output to a PNG file. A viable alternative
    to this is to use a Jupyter notebook – Jupyter comes with Anaconda – and display
    the graphical output on your favorite web browser.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化时间序列有多种方式，包括 R 或 Matlab 等工具，或者使用大量现有的 JavaScript 包。在本节中，我们将使用一个名为 Matplotlib
    的 Python 包来可视化数据。此外，我们还将输出保存到 PNG 文件中。这个可行的替代方案是使用 Jupyter notebook – Jupyter
    随 Anaconda 一起提供 – 并在你的首选网页浏览器上显示图形输出。
- en: 'The `visualize.py` script reads a plain text file with values – a time series
    – and creates a plot. The Python code of `visualize.py` is as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`visualize.py`脚本读取包含值的纯文本文件（时间序列）并创建一个图表。`visualize.py`的Python代码如下：'
- en: '[PRE29]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You must be familiar with most of the presented code, as you already saw some
    of it earlier in this chapter. The `plt.plot()` statement plots the data, whereas
    the `plt.savefig()` function saves the output in the file instead of displaying
    it on screen.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须熟悉大多数展示的代码，因为你已经在本章前面看到一些了。`plt.plot()`语句用于绘制数据，而`plt.savefig()`函数则将输出保存到文件中，而不是在屏幕上显示。
- en: 'The output from the `./visualize.py ts1.gz` command can be seen in *Figure
    1**.3*:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`./visualize.py ts1.gz`命令的输出可以在*图1.3*中看到：
- en: '![Figure 1.3 – Visualizing a time series](img/Figure_1.3_B14769.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3 – 可视化时间序列](img/Figure_1.3_B14769.jpg)'
- en: Figure 1.3 – Visualizing a time series
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 – 可视化时间序列
- en: Now that we understand how to work with time series and subsequences, it is
    time to present an advanced technique called the **Matrix Profile**, which shows
    the tasks that we might need to compute when working with time series and how
    time-consuming these tasks might be.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何处理时间序列和子序列，是时候介绍一个高级技术，称为**矩阵轮廓**，它展示了在处理时间序列时可能需要计算的任务，以及这些任务可能多么耗时。
- en: Working with the Matrix Profile
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用矩阵轮廓
- en: In this section, as well as the next one, we will work with the `stumpy` Python
    package. This package is not related to iSAX but offers lots of advanced functionality
    related to time series. With the help of `stumpy`, we can calculate the *Matrix
    Profile*.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节以及下一节中，我们将使用`stumpy` Python包。这个包与iSAX无关，但提供了许多与时间序列相关的先进功能。借助`stumpy`，我们可以计算**矩阵轮廓**。
- en: 'The Matrix Profile is two things:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵轮廓是两件事：
- en: A vector of distances that shows the distance of each subsequence in a time
    series to its nearest neighbor
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个距离向量，显示了时间序列中每个子序列与其最近邻的距离
- en: A vector of indexes that shows the index of the nearest neighbor of each subsequence
    in a time series
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个索引向量，显示了时间序列中每个子序列最近邻的索引
- en: The Matrix Profile can be used in many time series mining tasks. The main reason
    for presenting it is to understand that working with time series can be slow,
    so we need structures and techniques to improve the performance of time series-related
    tasks.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵轮廓可用于许多时间序列挖掘任务。展示它的主要原因是为了理解处理时间序列可能会很慢，因此我们需要结构和技巧来提高与时间序列相关的任务性能。
- en: 'To get a better idea of the use of the Matrix Profile and the time it takes
    `stumpy` to calculate the Matrix Profile, here is the Python code of `matrix_profile.py`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地了解矩阵轮廓的使用以及`stumpy`计算矩阵轮廓所需的时间，以下是`matrix_profile.py`的Python代码：
- en: '[PRE30]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `stumpy.stump()` function calculates the Matrix Profile of a given time
    series.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`stumpy.stump()`函数计算给定时间序列的矩阵轮廓。'
- en: We are going to execute `matrix_profile.py` two times. The first time using
    a time series with 100,000 elements and the second time using a time series with
    300,000 elements. As with almost all the Python scripts in this book that read
    a time series, `matrix_profile.py` expects to read compressed plain text files.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将执行`matrix_profile.py`两次。第一次使用包含100,000个元素的时间序列，第二次使用包含300,000个元素的时间序列。与本书中几乎所有的读取时间序列的Python脚本一样，`matrix_profile.py`期望读取压缩的纯文本文件。
- en: The taskset(1) command
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`taskset(1)`命令'
- en: The `taskset(1)` command is used to assign the desired number of cores to a
    given process and is currently available on Linux machines. The reason for using
    it is to limit the number of available cores when executing `matrix_profile.py`
    and `mpdistance.py`, which, by default, use all available cores due to the use
    of the Numba Python package. As a rule of thumb, when testing the performance
    of an algorithm or comparing one to another, it is better to use a single core.
    There is no similar utility on macOS.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`taskset(1)`命令用于将所需数量的核心分配给指定的进程，目前仅在Linux机器上可用。使用它的原因是在执行`matrix_profile.py`和`mpdistance.py`时限制可用的核心数量，因为默认情况下，由于使用了Numba
    Python包，它们会使用所有可用的核心。一般来说，在测试算法性能或比较不同算法时，使用单个核心更好。在macOS上没有类似的实用工具。'
- en: 'Running `matrix_profile.py` with the smaller time series produces the following
    output:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 使用较短的时间序列运行`matrix_profile.py`会产生以下输出：
- en: '[PRE31]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: So, it took `stumpy.stump()` around `120.44 seconds` to process a time series
    with 100,000 elements.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`stumpy.stump()`处理包含100,000个元素的时间序列大约需要`120.44秒`。
- en: 'Running `matrix_profile.py` with the bigger time series produces the following
    output:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `matrix_profile.py` 并使用更大的时间序列会产生以下输出：
- en: '[PRE32]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, it took `stumpy.stump()` around `922 seconds` to process a time series
    with 300,000 elements on a single CPU core. Now, imagine doing the same with a
    time series that has more than 1,000,000 elements!
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`stumpy.stump()` 在单个CPU核心上处理包含300,000个元素的时间序列大约需要`922秒`。现在，想象一下处理包含超过1,000,000个元素的时间序列会是什么样子！
- en: You are going to learn all about the Matrix Profile and understand why it is
    so slow in [*Chapter 7*](B14769_07.xhtml#_idTextAnchor160).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在[第7章](B14769_07.xhtml#_idTextAnchor160)中了解所有关于矩阵轮廓的内容，并理解为什么它如此缓慢。
- en: The next section discusses a distance function named **MPdist** that internally
    uses the Matrix Profile for its computation.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将讨论一个名为**MPdist**的距离函数，该函数在内部使用矩阵轮廓进行计算。
- en: Exploring the MPdist distance
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 MPdist 距离
- en: MPdist offers a way to calculate the distance between two time series. Strictly
    speaking, the *MPdist* distance is a distance measure that is based on the Matrix
    Profile. It is much slower to compute than the Euclidean distance, but it does
    not require the time series to have the same size.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: MPdist提供了一种计算两个时间序列之间距离的方法。严格来说，*MPdist*距离是一种基于矩阵轮廓的距离度量，其计算速度比欧几里得距离慢得多，但它不需要时间序列具有相同的大小。
- en: 'As you might expect, it must offer many advantages when compared to the Euclidean
    distance, as well as other existing distance metrics. The main advantages of MPdist,
    according to the people that created it, are the following:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所料，与欧几里得距离以及其他现有的距离度量相比，它必须提供许多优势。根据创建它的人的说法，MPdist的主要优势如下：
- en: It is more flexible regarding the way it compares data than most existing distance
    functions.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与大多数现有的距离函数相比，它在比较数据的方式上更加灵活。
- en: It considers similarities of data that may not take place at the same time,
    where time means at the same index.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它考虑了可能不在同一时间发生的数据相似性，其中时间指的是相同的索引。
- en: MPdist is considered more robust in specific analytics scenarios due to the
    way it is computed. More specifically, MPdist is more robust to spikes and missing
    values.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于其计算方式，MPdist在特定分析场景中被认为更稳健。更具体地说，MPdist对尖峰和缺失值更稳健。
- en: As MPdist is based on the Matrix Profile, calculating the MPdist distance can
    be extremely slow, especially when working with large time series.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 由于MPdist基于矩阵轮廓，计算MPdist距离可能非常缓慢，尤其是在处理大型时间序列时。
- en: 'First, let us have a look at the Python code of `mpdistance.py`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看`mpdistance.py`的Python代码：
- en: '[PRE33]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This program uses command-line arguments with the help of `sys` to read the
    required data, instead of the `argparse` package.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序使用`sys`模块的命令行参数来读取所需数据，而不是使用`argparse`包。
- en: All of this is done by the call to `stumpy.mpdist()`, which requires three parameters
    – the two time series and the sliding window size.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些操作都是通过调用`stumpy.mpdist()`完成的，它需要三个参数——两个时间序列和滑动窗口大小。
- en: 'As `mpdistance.py` calculates the distance between two time series, it expects
    to read two files. Running `mpdistance.py` with two synthetic data sets with 100,000
    elements each generates the following output:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`mpdistance.py`计算两个时间序列之间的距离，它期望读取两个文件。使用包含10万个元素的两个合成数据集运行`mpdistance.py`会生成以下输出：
- en: '[PRE34]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: So, on a Linux machine with an Intel i7 CPU, it took `mpdistance.py` `349.81955`
    `seconds` to execute when *using a single CPU core*. The value of the MPdist distance
    is `28.3882`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在配备Intel i7 CPU的Linux机器上，当使用单个CPU核心时，`mpdistance.py`执行需要`349.81955`秒。MPdist距离的值为`28.3882`。
- en: 'If we use two datasets with half a million elements each (500,000 elements),
    the output and the time it takes to execute `mpdistance.py` should be similar
    to the following:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用两个包含五十万个元素的数据集（500,000个元素），`mpdistance.py`的输出和执行所需的时间应该与以下类似：
- en: '[PRE35]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: So, on a Linux machine with an Intel i7 CPU, it took `mpdistance.py` `4102.92`
    seconds to execute when *using a single CPU core*. The value of the MPdist distance
    is `38.2851`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在配备Intel i7 CPU的Linux机器上，当使用单个CPU核心时，`mpdistance.py`执行需要`4102.92`秒。MPdist距离的值为`38.2851`。
- en: You will learn all the details about MPdist in [*Chapter 7*](B14769_07.xhtml#_idTextAnchor160).
    For now, what you should keep in mind is that MPdist is a distance function that
    has some performance issues.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在[第7章](B14769_07.xhtml#_idTextAnchor160)中了解MPdist的所有细节。现在，你应该记住的是，MPdist是一个存在一些性能问题的距离函数。
- en: Experiment and stay humble
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 实验并保持谦逊
- en: If I can give you just one piece of advice to remember from this book, it would
    be to experiment and try things. Experiment as much as possible with what you
    read, question it, think in new ways, try new things, and keep learning. At the
    same time, stay humble, and do not forget that lots of people have worked to lay
    the foundation for us to be here today talking about time series and indexing.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我能给你一条要记住的建议，那就是实验和尝试。尽可能多地实验你所阅读的内容，质疑它，以新的方式思考，尝试新事物，并持续学习。同时，保持谦逊，不要忘记很多人为我们今天讨论时间序列和索引奠定了基础。
- en: Summary
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned the basics of time series, indexing, and distance
    functions. Although the theoretical knowledge included in this chapter remains
    valid and relevant no matter what programming language is used, alternative ways
    and packages to achieve the presented tasks in Python exist, as well as other
    programming languages. What remains unchanged is the validity of the approach
    – you must read a text file from disk in order to use its data, no matter the
    programming language – and the logical steps needed to perform a task, such as
    the visualization of a time series. This means that if you know an alternative
    way to load a text file from disk in Python, feel free to use it if it allows
    you to perform the next task at hand. If you are an amateur Python developer,
    I would suggest that you follow the book’s suggestions until you become more competent
    with Python. After all, the used Python packages are the most popular ones in
    the Python community.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了时间序列、索引和距离函数的基础知识。尽管本章包含的理论知识无论使用何种编程语言都是有效和相关的，但在 Python 以及其他编程语言中存在实现所展示任务的替代方法和包。不变的是方法的正确性——无论使用何种编程语言，你都必须从磁盘读取文本文件才能使用其数据，以及执行任务所需的逻辑步骤，例如时间序列的可视化。这意味着如果你知道在
    Python 中从磁盘加载文本文件的替代方法，并且它允许你执行下一个任务，那么请自由使用它。如果你是 Python 开发初学者，我建议你遵循书中的建议，直到你对
    Python 更加熟练。毕竟，所使用的 Python 包是 Python 社区中最受欢迎的。
- en: Before you continue reading this book, please make sure that you understand
    the knowledge presented in this chapter, as it is the foundation for the rest
    of the book, especially if you are new to time series and indexing.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续阅读本书之前，请确保你理解本章所呈现的知识，因为它是本书其余部分的基础，尤其是如果你是时间序列和索引的新手。
- en: The next chapter is about the SAX representation, which is an integral part
    of the iSAX index.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍 SAX 表示法，它是 iSAX 索引的一个组成部分。
- en: Resources and useful links
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源和有用链接
- en: 'The Stumpy Python package: [https://pypi.org/project/stumpy/](https://pypi.org/project/stumpy/).'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Stumpy Python 包：[https://pypi.org/project/stumpy/](https://pypi.org/project/stumpy/).
- en: 'The NumPy Python package: [https://numpy.org/](https://numpy.org/).'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy Python 包：[https://numpy.org/](https://numpy.org/).
- en: 'The SciPy Python package: [https://pypi.org/project/scipy/](https://pypi.org/project/scipy/)
    and [https://scipy.org/](https://scipy.org/).'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SciPy Python 包：[https://pypi.org/project/scipy/](https://pypi.org/project/scipy/)
    和 [https://scipy.org/](https://scipy.org/).
- en: 'Anaconda documentation: [https://docs.anaconda.com/](https://docs.anaconda.com/).'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Anaconda 文档：[https://docs.anaconda.com/](https://docs.anaconda.com/).
- en: 'Anaconda distribution: [https://www.anaconda.com/products/distribution](https://www.anaconda.com/products/distribution).'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Anaconda 发行版：[https://www.anaconda.com/products/distribution](https://www.anaconda.com/products/distribution).
- en: 'Jupyter Notebooks: [https://jupyter.org/](https://jupyter.org/).'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jupyter 笔记本：[https://jupyter.org/](https://jupyter.org/).
- en: 'Matplotlib: [https://pypi.org/project/matplotlib/](https://pypi.org/project/matplotlib/)
    and [https://matplotlib.org/](https://matplotlib.org/).'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Matplotlib：[https://pypi.org/project/matplotlib/](https://pypi.org/project/matplotlib/)
    和 [https://matplotlib.org/](https://matplotlib.org/).
- en: 'The Z Shell: [https://www.zsh.org/](https://www.zsh.org/).'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Z Shell：[https://www.zsh.org/](https://www.zsh.org/).
- en: 'Oh My Zsh: [https://github.com/ohmyzsh/ohmyzsh](https://github.com/ohmyzsh/ohmyzsh).'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oh My Zsh：[https://github.com/ohmyzsh/ohmyzsh](https://github.com/ohmyzsh/ohmyzsh).
- en: 'The Pandas Python package: [https://pypi.org/project/pandas/](https://pypi.org/project/pandas/).'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pandas Python 包：[https://pypi.org/project/pandas/](https://pypi.org/project/pandas/).
- en: 'The Dewey Decimal Classification system: [https://en.wikipedia.org/wiki/Dewey_Decimal_Classification](https://en.wikipedia.org/wiki/Dewey_Decimal_Classification).'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 杜威十进制分类系统：[https://en.wikipedia.org/wiki/Dewey_Decimal_Classification](https://en.wikipedia.org/wiki/Dewey_Decimal_Classification).
- en: 'The Numba Python package: [https://pypi.org/project/numba/](https://pypi.org/project/numba/).'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Numba Python 包：[https://pypi.org/project/numba/](https://pypi.org/project/numba/).
- en: 'The Matrix Profile is defined in a research paper called *Matrix Profile I:
    All Pairs Similarity Joins for Time Series: A Unifying View That Includes Motifs,
    Discords and Shapelets*. The authors of the paper are Chin-Chia Michael Yeh, Yan
    Zhu, Liudmila Ulanova, Nurjahan Begum, Yifei Ding, Hoang Anh Dau, Diego Furtado
    Silva, Abdullah Mueen, and Eamonn J. Keogh.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '矩阵轮廓在名为 *Matrix Profile I: All Pairs Similarity Joins for Time Series: A Unifying
    View That Includes Motifs, Discords and Shapelets* 的研究论文中定义。该论文的作者是 Chin-Chia
    Michael Yeh, Yan Zhu, Liudmila Ulanova, Nurjahan Begum, Yifei Ding, Hoang Anh
    Dau, Diego Furtado Silva, Abdullah Mueen 和 Eamonn J. Keogh。'
- en: 'The MPdist distance is defined in a research paper called *Matrix Profile XII:
    MPdist: A novel time series distance measure to allow data mining in more challenging
    scenarios*. The authors of the paper are S. Gharghabi, S. Imani, A. Bagnall, A.
    Darvishzadeh, and E. Keogh.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'MPdist 距离在名为 *Matrix Profile XII: MPdist: A novel time series distance measure
    to allow data mining in more challenging scenarios* 的研究论文中定义。该论文的作者是 S. Gharghabi,
    S. Imani, A. Bagnall, A. Darvishzadeh 和 E. Keogh。'
- en: You can find more information about `numpy.linalg.norm()` at [https://numpy.org/doc/stable/reference/generated/numpy.linalg.norm.xhtml](https://numpy.org/doc/stable/reference/generated/numpy.linalg.norm.xhtml).
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在 [https://numpy.org/doc/stable/reference/generated/numpy.linalg.norm.xhtml](https://numpy.org/doc/stable/reference/generated/numpy.linalg.norm.xhtml)
    找到更多关于 `numpy.linalg.norm()` 的信息。
- en: 'The Homebrew macOS package manager: [https://brew.sh/](https://brew.sh/).'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Homebrew macOS 软件包管理器：[https://brew.sh/](https://brew.sh/)。
- en: Exercises
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Try to do the following exercises:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下练习：
- en: Create a new Anaconda environment.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的 Anaconda 环境。
- en: List the installed packages of an Anaconda environment.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出 Anaconda 环境中安装的包。
- en: Delete an existing Anaconda environment.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除现有的 Anaconda 环境。
- en: Create a new synthetic dataset with 1,000 values from -10 to +10.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的包含 1,000 个值（从 -10 到 +10）的合成数据集。
- en: Create a new synthetic dataset with 100,000 values from 0 to +10.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的包含 100,000 个值（从 0 到 +10）的合成数据集。
- en: Write a Python script that reads a plain text file line by line.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个 Python 脚本，逐行读取一个纯文本文件。
- en: Write a Python script that reads a plain text file and prints it word by word.
    Why is this more difficult than printing a file line by line?
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个 Python 脚本，逐字读取一个纯文本文件并打印出来。为什么逐字打印比逐行打印文件更困难？
- en: Write a Python script that reads the same plain text file multiple times, and
    time that operation. The number of times the file is read as well as the file
    path should be given as command-line arguments.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个 Python 脚本，多次读取相同的纯文本文件，并计时该操作。文件读取的次数以及文件路径应作为命令行参数提供。
- en: Modify `synthetic_data.py` to generate integer values instead of floating-point
    values.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改 `synthetic_data.py` 以生成整数值而不是浮点值。
- en: Create a time series with 500,000 elements with `synthetic_data.py`, and execute
    `matrix_profile.py` on the generated time series. Do not forget to compress the
    plain text file.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `synthetic_data.py` 创建一个包含 500,000 个元素的时间序列，并在生成的时间序列上执行 `matrix_profile.py`。不要忘记压缩纯文本文件。
- en: Modify `mpdistance.py` to use `argparse` to read its parameters.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改 `mpdistance.py` 以使用 `argparse` 读取其参数。
- en: Experiment with `visualize.py` to plot your own time series. What happens when
    you plot big time series? How easy it is to find what you are looking for?
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试使用 `visualize.py` 来绘制你自己的时间序列图。当你绘制大时间序列时会发生什么？找到你想要的东西有多容易？
- en: In the iSAX index in *Figure 1**.2* a binary tree? Is it a balanced tree? Why?
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *图 1**.2* 中的 iSAX 索引是一个二叉树吗？它是一个平衡树吗？为什么？
- en: Modify `ed.py` to read the time series from compressed plain text files.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改 `ed.py` 以从压缩的纯文本文件中读取时间序列。
