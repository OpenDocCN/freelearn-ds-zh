- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An Introduction to Time Series and the Required Python Knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the first chapter of the book that you are reading. Although first chapters
    usually contain basic information that you might want to skip, this is not such
    a chapter. It teaches you the basics of time series and indexing, as well as how
    to set up a proper Python environment, which is going to be used during the development
    of the code of this book. You might need to refer to it while you are reading
    other chapters, which is a good thing! So, let us get started!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding time series
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is an index and why do we need indexing?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Python knowledge that we are going to need
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading time series from disk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizing time series
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the Matrix Profile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the MPdist distance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to follow this chapter, which is the foundation of the entire book,
    you need to have a recent Python 3 version installed on your computer and be able
    to install any other required software on your own. We are not going to teach
    you how to install a Python 3 package, but we are going to tell you which packages
    you should install and the commands that we have used to do so. Similarly, we
    are not going to explain the process of installing new software on your machines,
    but we are going to tell you the command or commands we have used to install a
    given software on our machines.
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub repository of the book can be found at [https://github.com/PacktPublishing/Time-Series-Indexing](https://github.com/PacktPublishing/Time-Series-Indexing).
    The code for each chapter is in its own directory. Therefore, the code for [*Chapter
    1*](B14769_01.xhtml#_idTextAnchor015) can be found inside the `ch01` folder. You
    can download the entire repository on your computer using `git(1)`, or you can
    access the files via the GitHub user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the entire code of this book, including the code in the `ch01`
    folder, using `git(1)` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As the repository name is long and the local directory is named after the repository
    name, you can execute the previous command as follows to shorten the folder name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is going to put the contents of the repository in a directory named `tsi`.
    Both ways are valid – do what is best for you.
  prefs: []
  type: TYPE_NORMAL
- en: The code of the book is now on your local machine. However, you are going to
    need to have some Python packages installed for most of the code to run – we are
    going to discuss the required Python packages later on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Disclaimer
  prefs: []
  type: TYPE_NORMAL
- en: This code of the book was written and tested on Arch Linux and macOS Ventura
    machines. Even though the book is Unix-oriented, there exist similar commands
    that can be executed on a Microsoft Windows machine that should not be so difficult
    to find and execute. What is important is the presented code, understanding the
    code and the logic behind it, and being able to execute and make changes to it
    on your own. If this information helps you, I am mainly using Microsoft Visual
    Studio Code to write code on both macOS and Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding time series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A time series is a set of data. Keep in mind that a time series does not have
    to contain time or date data in it – time and date data usually come in the form
    of *timestamps*. So, a time series might contain timestamps, but usually, it does
    not. In fact, most of the time series in this book do not contain timestamps.
    In practice, what we really need is ordered data – this is what makes a bunch
    of values a time series.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strictly speaking, a time series (*T*) of size *n* is an ordered list of data
    points: T = { t 0, t 1, t 2, … t n−1}. Data points can be timestamped and store
    a single value, a set of values, or a list of values. The index of a time series
    might begin with 1 instead of 0 – in this case, T = { t 1, t 2, t 3, … t n}. What
    is truly important here is that the length of the time series is *n* in both cases.
    So, each element has an index value associated with it, which replaces the need
    for a timestamp. Time series in this book are going to use index values to distinguish
    their elements. The following ordered list can be considered a time series – `{1,
    -2, -3, 4, 5, 1, 2, 0.23, 4.3}`. It contains nine elements. The first element
    is `1` and the last element is `4.3`. If the index of the first element is `0`,
    then the index of the last element would be `8`, whereas if the index of the first
    element is `1`, then the index of the last element is going to be `9`. Time series
    can contain the same value multiple times.'
  prefs: []
  type: TYPE_NORMAL
- en: An alternative definition of time series
  prefs: []
  type: TYPE_NORMAL
- en: A time series is a collection of observations made sequentially in time. Many
    types of observations are not true time series but can be transformed into time
    series.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 1**.1* shows a graphical representation of a time series with 1,000
    elements – even with a small time series such as the one presented here, it is
    difficult to search for a specific subsequence or value. As we will discuss later
    on, this is why indexing is important.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – Visualizing a time series](img/Figure_1.1_B14769.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – Visualizing a time series
  prefs: []
  type: TYPE_NORMAL
- en: In the *Visualizing time series* section, we will learn how to visualize a time
    series in Python.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection tells us where we can find time series data.
  prefs: []
  type: TYPE_NORMAL
- en: Time series are everywhere
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You might now ask where we can find time series. The answer is simple: time
    series are everywhere! From medical data to positional data and from software
    and hardware metrics to financial information and stock prices! Successfully using
    them allows us to find answers to questions we might have, such as which stock
    to sell or which hard disk is going to fail.'
  prefs: []
  type: TYPE_NORMAL
- en: Let us look at some definitions that we need to know to understand the concepts
    better.
  prefs: []
  type: TYPE_NORMAL
- en: Essential definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this subsection, we are going to learn some core definitions related to
    time series:'
  prefs: []
  type: TYPE_NORMAL
- en: The *length* of a time series or a subsequence is the number of elements found
    in the time series or the subsequence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *subsequence* *s* of size *w* of a time series *T* is a sublist of *T*, with
    consecutive elements of length *w*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *sliding window* of size *w* decomposes a time series into subsequences of
    size *w*. The sliding window separates a time series into multiple subsequences,
    with a length equal to the sliding window value. Given a time series with length
    *n* and a sliding window of size *w*, the total number of subsequences of size
    *w* is equal to *n*-*w*+*1*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us now give you an example. Imagine having the following time series, T:
    {0, 1, 2, 3, 4, 5, 6}. Given a sliding window of size *5*, *T* can be separated
    into the following subsequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{0, 1, 2,` `3, 4}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{1, 2, 3,` `4, 5}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{2, 3, 4,` `5, 6}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, we have three subsequences in total, each having a length of *5*. As this
    is a tedious process, we are going to learn how to tell a computer to do that
    for us in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection briefly discusses the subject of time series data mining.
  prefs: []
  type: TYPE_NORMAL
- en: Time series data mining
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Data mining** is the study of collecting, cleaning up, processing, analyzing,
    and understanding data. Data mining is a large subject. In fact, data mining is
    an area of computer science with its own subtopics and areas. The most important
    areas of data mining are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Classification**: This is the process of determining the class label of an
    element given a set of predefined class labels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clustering**: This is the process of grouping data into sets so that group
    members are similar to each other, based on a given criterion, which is usually
    a distance function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Outlier detection**: This is the process of finding an observation that differs
    from other ones enough to raise suspicions that it was created by a different
    process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Time series data mining*, as the term suggests*,* is the data mining of time
    series. The main difference between regular data mining and time series data mining
    is that in time series, data comes sorted by time. Therefore, you cannot arrange
    time series data on your own. Although time gives context, what is important is
    the actual value.'
  prefs: []
  type: TYPE_NORMAL
- en: Apart from time, time series data can also be characterized by longitude and
    latitude values (*spatial data*). We are not going to deal with spatial data in
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: Having time series data is good, but it might be useless if we cannot compare
    this data. The next subsection shows some popular techniques and algorithms for
    comparing time series.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing time series
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To compare anything, we need a metric. We can compare numerical values because
    the values are the metrics. But how do we compare time series? This is an active
    research subject that does not have a definitive answer.
  prefs: []
  type: TYPE_NORMAL
- en: Before you continue reading the remaining chapter, take some time and try to
    think whether you can compare time series with a different number of elements.
    Is that even possible? *Write down your thoughts* before you continue reading
    and find out the answer.
  prefs: []
  type: TYPE_NORMAL
- en: Well, it turns out that you can compare time series with a different number
    of elements. However, not all metric functions support that functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Writing and reading
  prefs: []
  type: TYPE_NORMAL
- en: Reading any worthwhile book or research paper is good and allows you to learn
    new things and keep your mind active. However, to test your knowledge and organize
    your thoughts, you need to write them down! I do that all the time. After all,
    this is how this book was created!
  prefs: []
  type: TYPE_NORMAL
- en: The Euclidean distance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Euclidean distance is a way of finding out how close or how far apart a
    couple of time series are. Put simply, the Euclidean distance measures the shortest
    path between two multidimensional points. A time series or a subsequence with
    more than one element is a multidimensional point.
  prefs: []
  type: TYPE_NORMAL
- en: The Euclidean distance **prioritizes time** – it compares data points that appear
    at the same time and ignores anything else. Therefore, if two time series only
    match at different times, they are considered dissimilar. Finally, the Euclidean
    distance works with data of many dimensions – in this book, we use data of one
    dimension only. Do not confuse **multidimensional points** with **multidimensional
    data**. Multidimensional data contains multidimensional points. The time series
    of this book contains data with one dimension only (single values). However, we
    can consider a time series or subsequence as a *multi-dimensional point*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The formula to calculate the Euclidean distance of two multidimensional points
    can be described as follows. Given a point p = ( p 1, p 2, … , p n) and a point
    q = ( q 1, q 2, … , q n), the Euclidean distance is the square root of the sum
    of all (p i − q i) 2 values:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now present some examples by calculating the Euclidean distance of two
    subsequence pairs. The first pair is `p =` `{1, 2, 3}` and `q =` `{0, 2, 2}`.
    So, first, we find all (p i − q i) 2 values:'
  prefs: []
  type: TYPE_NORMAL
- en: '*(**1**−**0**)*2*=**1*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*(**2**−**2**)*2*=**0*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*(**3**−**2**)*2*=**1*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, we add the results: 1 + 0 + 1 = 2.'
  prefs: []
  type: TYPE_NORMAL
- en: Last, we find the square root of the result, which is approximately equal to
    1.414213.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, imagine having the following two time series or subsequences – `p =` `{1,
    2, -1, -3}` and `q =` `{-3, 1, 2, -1}`. Although the time series have the same
    elements, these elements are in a different order. Their Euclidean distance can
    be calculated as before. First, we find all (p i − q i) 2 values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[1 − (− 3)] 2 = 4 2 = 16'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (2 − 1) 2 = 1 2 = 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ( − 1 − 2) 2 = ( − 3) 2 = 9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[( − 3) − (− 1)] 2 = ( − 2) 2 = 4'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, the Euclidean distance is equal to the square root of (16+1+9+4)
    = 30, which approximately is equal to 5.4472.
  prefs: []
  type: TYPE_NORMAL
- en: A major drawback of the Euclidean distance is that it requires the two time
    series to be of the same length. Although there exist techniques to overcome that
    limitation, this is still an issue. One of the techniques involves using extrapolation
    to make the length of the smaller time series equal to the length of the bigger
    one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going forward, we are not going to calculate Euclidean distances manually,
    as *NumPy* offers a better way of doing so – this is illustrated in `ed.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `euclidean()` function takes two NumPy arrays as input and returns their
    Euclidean distance as output, using `np.linalg.norm()`. This works because the
    Euclidean distance is the `l2` norm and the default value of the `ord` parameter
    in `numpy.linalg.norm()` is `2`, which is the reason for not specifically defining
    it. You do not need to remember that; just use the `euclidean()` function when
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two time series are hardcoded in the script. Running `ed.py` generates
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The Chebyshev distance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Chebyshev distance has a totally different logic than the Euclidean distance.
    This does not make it superior or inferior to the Euclidean distance, just different.
    If you do not know what to use, go with the Euclidean distance.
  prefs: []
  type: TYPE_NORMAL
- en: So, the Chebyshev distance between two multidimensional points is equal to the
    greatest distance of all |p i − q i| values. The || symbol is the *absolute value*
    of a quantity. Put simply, the *absolute value* of a quantity is equal to the
    value without the plus or minus sign.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now present some examples by calculating the Chebyshev distance of two
    subsequence pairs. The first pair is `{1, 2, 3}` and `{0, 2, 2}`. Now, let us
    find the distances between the pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '*|1 – 0| = 1*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*|2 – 2| = 0*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*|3 – 2| = 1*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, the maximum of 1, 0, and 1 is equal to 1, which is the Chebyshev distance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second pair is `{1, 2, -1, -3}` and `{-3, 1, 2, -1}`. As before, we find
    the distances between the pairs of the points at the same position (same index):'
  prefs: []
  type: TYPE_NORMAL
- en: '*|1 – (–3)| = 4*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*|2 – 1| = 1*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*|(–1) – 2| = 3*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*|(–3) – (–1)| = 2*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, the maximum of 4, 1, 3, and 2 is equal to 4, which is the Chebyshev distance
    of the aforementioned pair.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, we are going to learn about a more sophisticated distance
    function, which is called *MPdist*.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to compare time series and subsequences, it is time to
    discuss indexes and indexing. Keep in mind that we cannot create an index without
    being able to compare its data, which includes time series data.
  prefs: []
  type: TYPE_NORMAL
- en: What is an index and why do we need indexing?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Can you imagine searching for a surname in an unsorted list of names? Can you
    imagine looking for a book in a library that does not sort its books based on
    book subject (the Dewey system) and then book title and author surname? I cannot!
    Both examples showcase a naïve but efficient indexing scheme. The more complex
    the data, the more sophisticated the index should be in order to perform quick
    searches and maybe updates on the data.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 1**.2* shows the visualization of a really small **iSAX** index – in
    reality, as a time series can be really huge, iSAX indexes tend to be much bigger
    and more complex.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – A small iSAX index](img/Figure_1.2_B14769.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – A small iSAX index
  prefs: []
  type: TYPE_NORMAL
- en: Do not try to understand the iSAX index or the titles of the nodes at this point.
    Everything is going to become clearer in [*Chapter 2*](B14769_02_MA.xhtml#_idTextAnchor053)
    and [*Chapter 3*](B14769_03.xhtml#_idTextAnchor081). For now, keep in mind that
    the titles of the nodes are *SAX words* and that there exist two kinds of nodes
    on an iSAX index – *internal nodes* and *terminal nodes* (leaf nodes). Everything
    about the iSAX index and its connection with SAX words will become clear in [*Chapter
    3*](B14769_03.xhtml#_idTextAnchor081).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will begin working with Python and set up our environment.
  prefs: []
  type: TYPE_NORMAL
- en: The Python knowledge that we are going to need
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the presented code in this book is written in Python. Therefore, in this
    section, we are going to present the required Python knowledge for you to follow
    this book better. However, do not expect to learn the basics of Python here –
    more appropriate books exist for that purpose.
  prefs: []
  type: TYPE_NORMAL
- en: What about other programming languages?
  prefs: []
  type: TYPE_NORMAL
- en: Once you learn and understand the presented theory, the Python code of this
    book can be easily translated into any other modern programming language, such
    as Swift, Java, C, C++, Ruby, Kotlin, Go, Rust, or JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: You might have compatibility issues with the used Python packages if you keep
    updating them for no particular reason. As a rule of thumb, I would suggest that
    throughout this book, you should use the same package versions, provided that
    they work well with each other. There exist two main ways to achieve that. You
    can stop upgrading your Python installation once you find the versions that work,
    or you can use a Python package manager such as Anaconda or `pyenv`. In this book,
    we are going to use Anaconda.
  prefs: []
  type: TYPE_NORMAL
- en: It does not matter what you use, as long as you know how to operate your tools
    and have a stable and reliable Python environment to work with.
  prefs: []
  type: TYPE_NORMAL
- en: I hope we all agree that the most important property of any code is correctness.
    However, after we have working code, we might need to optimize it, but we cannot
    optimize code if we do not know whether it runs slowly or not. So, the next section
    shows you how to calculate the time it takes Python code to execute.
  prefs: []
  type: TYPE_NORMAL
- en: Timing Python code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are times when we need to know how slow or how fast our code is being
    executed because some operations might take hours or even days. This section presents
    a simple technique to calculate the time it takes a block of code to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `timing.py` script shows a technique to time Python code – this might come
    in really handy when you want to learn how much time it takes for a process to
    finish. The source code of `timing.py` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We use `time.time()` to initiate the beginning of the timing and the same statement
    to declare the end of the timing. The difference between these two statements
    is the desired result. You can also keep that difference in a separate variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program executes `time.sleep(1)` five times, which means the total time
    should be pretty close to 5 seconds. Running `timing.py` generates the following
    kind of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: About the Python scripts
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we are mostly going to show you the Python scripts in full without
    omitting any statements. Although this adds some extra lines, it helps you understand
    the functionality of the Python scripts by looking at their `import` statements
    before reading the actual Python code.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection is about the Anaconda software, which is used to create
    Python environments.
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to Anaconda
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Anaconda is a product for package, dependency, and environment management. Although
    Anaconda is a commercial product, there exists an Individual Edition for solo
    practitioners, students, and researchers. What Anaconda does is create a controlled
    environment where you can define the version of Python as well as the versions
    of the packages you want to use. Additionally, you can create multiple environments
    and switch between them.
  prefs: []
  type: TYPE_NORMAL
- en: You do not have to use Anaconda if you do not want to – however, if you are
    using Python 3 and you do not want to become overwhelmed by the details of Python
    3 package versions, incompatibilities, and dependencies, then you should give
    Anaconda a try. The reason for needing package and environment management software
    is because some Python packages are very picky about the Python version used.
    Put simply, Anaconda makes sure that your Python 3 environment is not going to
    change and gives you the capability to transfer your Python 3 environments to
    multiple machines. The Anaconda command line tool is called `conda`.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Anaconda
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Anaconda is a huge piece of software, as it contains lots of packages and utilities.
    There exist multiple ways to install Anaconda, which mainly depend on your development
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'On a macOS Ventura machine, we can install Anaconda using Homebrew as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'On an Arch Linux machine, Anaconda can be installed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We will not discuss the Anaconda installation in any more detail. The installation
    process is straightforward and contains lots of information. The single most important
    task to do is to include the Anaconda utilities on your `PATH` environment variable,
    in order for them to be accessible from everywhere on your UNIX shell. This also
    depends on the UNIX shell you are using – I use `zsh` with the Oh My Zsh extensions
    on both my Linux and macOS machines, but your environment might most likely vary.
  prefs: []
  type: TYPE_NORMAL
- en: If you choose to use Anaconda to work with this book, please make sure that
    you can access the `conda` binary and that you can enable and disable Anaconda
    on your machine at will – you might not need to use Anaconda all the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'On my macOS Ventura machine, I can disable Anaconda as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'I can also enable Anaconda as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You should replace `base` with the desired Anaconda environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous command depends on the path where Anaconda was installed. Therefore,
    on my Arch Linux machine, I should execute the following command instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You should modify the previous command to fit your Anaconda installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a new Anaconda version is available, you can update to the latest version
    by executing the next command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Creating a new Anaconda environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The single most important thing to decide when creating a new Anaconda environment
    is the selection of the Python 3 version. In order to create a new Anaconda environment
    named `TSI` that uses Python 3.8.5, you should run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In order to activate this environment, run `conda activate TSI`. The `python3
    --version` command shows the Python version included in a given Anaconda environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can list all existing Anaconda environments using the `conda info --envs`
    command (the `*` character shows the active one):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Changing to a different environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This subsection presents the `conda` command used to change from one environment
    to another. Changing to a different environment is as simple as activating a different
    environment using `conda` `activate environment_name`.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a Python package
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although you can still use `pip3` to install Python packages, the best way to
    install a Python package in an Anaconda environment is with the `conda install`
    command. Keep in mind that the `conda install` command cannot install all packages
    – in this case, use `pip3` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Listing all installed packages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `conda list` command gives you a full list of installed Python packages
    under a given Anaconda environment. As the list is pretty long, we will show you
    just a part of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Deleting an existing environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can delete an existing Anaconda environment *that is not active* using
    the `conda env remove --name ENVIRONMENT` command. Its execution is illustrated
    in the following output when deleting an environment named `mtsouk`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This discussion of Python environments, package versions, and package incompatibilities
    culminates here. From now on, let us assume that we have a stable Python environment
    where we can use existing Python packages, develop new Python packages, and run
    Python scripts without any issues. The next subsection lists the Python packages
    that we need to install.
  prefs: []
  type: TYPE_NORMAL
- en: The required Python packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is a list of the required Python packages along with an explanation of
    the use of each one of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NumPy`: This is the standard Python package for array computing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pandas`: This package offers data structures for data analysis, time series,
    and statistics, including functions to read data files from disk.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SciPy`: This package offers fundamental functions for scientific computing
    in Python.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Matplotlib`: This is the most popular Python package for scientific plotting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stumpy`: This is a powerful package for time series analysis and time series
    data mining. You do not have to install it right away, as it is not needed for
    the development of the iSAX index.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are the basic packages that you need to install in a fresh Python environment.
    Python will automatically install any package dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this subsection, we are going to set up our Anaconda environment. As explained
    earlier, this is not required to follow this book, but it will save you from Python
    package incompatibilities that might come up when upgrading Python and Python
    packages. We will execute the following commands in the `TSI` Anaconda environment,
    and then we are done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Printing package versions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this subsection, we present a Python script that just loads the desired packages
    and prints their versions on screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code of `load_packages.py` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `load_packages.py` on one of my UNIX machines prints the following
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The first command is needed to make the Python script executable and is required
    for all Python scripts presented in this book, provided that they begin with the
    `#!/usr/bin/env python3` statement. If they do not begin with that statement,
    you can execute them using `python3 <script_name>` without the need to change
    their permissions. You can learn more about the `chmod(1)` command by running
    `man chmod`. From now on, we will assume that you know this information and will
    not present any more `chmod` commands and instructions. Your output might be a
    little different, but that is OK, as packages get updated.
  prefs: []
  type: TYPE_NORMAL
- en: Creating sample data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The official name of sample data created by a program is **synthetic data**.
    This subsection is going to present a Python script that creates synthetic data
    based on given parameters. The logic of the program is based on randomly generated
    numbers – as most of you might know, randomly generated numbers are not that random.
    This makes them good for testing the performance of a program but not the actual
    use of it. However, for the purposes of this book, synthetic data generated with
    the help of random numbers is fine!
  prefs: []
  type: TYPE_NORMAL
- en: 'The code of the `synthetic_data.py` Python script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The script accepts three parameters, which are the *number of floating-point
    values* to create the minimum value and the maximum value. Running the script
    generates the following kind of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As floating-point values can have any precision you want, the `precision` variable
    holds the number of digits after the decimal point that will be printed.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own time series is not the only way to get data. Publicly available
    time series data also exists. Let us check this out next.
  prefs: []
  type: TYPE_NORMAL
- en: Publicly available time series data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Websites exist that offer samples of time series data, allowing everyone to
    process real-world time series data. Another important aspect of publicly available
    time series data is that people can compare the performance of their techniques,
    using the same datasets, with others. This is a huge issue in academia, where
    people have to prove that their techniques and algorithms are faster or more efficient
    in a variety of aspects compared to others.
  prefs: []
  type: TYPE_NORMAL
- en: A very popular set of publicly available time series data files can be found
    at [https://www.cs.ucr.edu/~eamonn/time_series_data_2018/](https://www.cs.ucr.edu/~eamonn/time_series_data_2018/)
    (the UCR Time Series Classification Archive).
  prefs: []
  type: TYPE_NORMAL
- en: How time series are processed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Time series processing in Python usually follows these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Importing to Python**: In this step, we import the time series into Python.
    There exist multiple ways to do that, including reading from a local file, a database
    server, or an Internet location. In this book, we include all used time series
    in the GitHub repository as plain text files, which are compressed to save disk
    space.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Converting it into a time series**: In this step, we convert the data we
    read in the previous step into a valid time series format. This mainly depends
    on the Python package used to store the time series data.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Dealing with missing values**: In this step, we look for missing values and
    ways to deal with them. We are not going to deal with missing values in this book.
    All presented time series are complete.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Processing time series**: This last step involves processing a time series
    in order to perform the desired task or tasks.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reading time series from disk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After storing a time series in a file, we need to write the necessary Python
    code to read it and put it in a Python variable of some type. This section will
    teach you exactly that. The `read_ts.py` script contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'After reading the time series, `read_ts.py` prints the number of elements in
    the time series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `pd.read_csv()` function reads a plain text file that uses the CSV format
    – in our case, each value is on its own line, so there should be no issues with
    separating values that reside on the same line. The `pd.read_csv()` function is
    able to detect issues in the input file. The return value of `pd.read_csv()` is
    a *DataFrame* or *TextParser*. In our case, it is a *DataFrame*.
  prefs: []
  type: TYPE_NORMAL
- en: Putting `.astype(np.float64)` at the end of the `pd.read_csv()` statement is
    going to ensure that all values are read as floating-point values, even when the
    entire time series contains integer values only. Additionally, `header = None`
    ensures that the input does not contain a header line with text or data different
    from the actual data.
  prefs: []
  type: TYPE_NORMAL
- en: The `ts1Temp.to_numpy()` call converts a *DataFrame* into a NumPy array. So,
    the return value of `ts1Temp.to_numpy()` is a NumPy array. This is needed because
    we will work with NumPy arrays.
  prefs: []
  type: TYPE_NORMAL
- en: The `ta.reshape(len(ta))` call gives a new shape to an existing NumPy array
    without changing the data. This is needed for processing the time series data
    using the correct shape.
  prefs: []
  type: TYPE_NORMAL
- en: As files with time series can be pretty big, it is a good idea to compress them
    and use them in compressed format. Fortunately, Pandas can read compressed files
    with the help of a parameter. This is illustrated in the `read_ts_gz.py` script.
    The statement that does the job is `pd.read_csv(filename, compression='gzip',
    header = None).astype(np.float64)`. Here, you also see `.astype(np.float64)` in
    action.
  prefs: []
  type: TYPE_NORMAL
- en: How to store time series
  prefs: []
  type: TYPE_NORMAL
- en: This book uses plain text files to store time series. In these files, each value
    is in a separate line. More ways exist to store a time series, including the CSV
    format and the JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: Is all data numeric?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not all data is numeric, but in time series, almost all data is numeric. The
    presented script reads a plain text file and makes sure that all data is numeric
    – note that the `isNumeric.py` script does not currently support compressed files,
    as it uses the `open()` call to read the input file and it expects a single value
    per line.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code of `isNumeric.py` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `try` and `except` block is where we try to convert the current string value
    into a floating-point value using `float()`. If this fails, we know that we are
    not dealing with a valid numerical value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `isNumeric.py` produces the following kind of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As we have three erroneous lines, the result is correct.
  prefs: []
  type: TYPE_NORMAL
- en: Do all lines have the same amount of data?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this subsection, we present a script that counts the number of words in each
    line, checks that each word is a valid float value, and checks that each line
    has the same number of values. If not, it states the expected and found number
    of fields. Additionally, it considers the first line read as the correct one,
    so all the following lines should have the same amount of data fields. Values
    are separated by whitespace characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code of `floats_per_line.py` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If `String.split()` is executed without any arguments, it splits the string
    using all the whitespace characters as delimiters, which is what we do here to
    separate the fields of each input line. If your data is in a different format,
    you might need to modify the `String.split()` statement to match your needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `floats_per_line.py` produces the following kind of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The next subsection shows how to process time series based on the sliding window
    size.
  prefs: []
  type: TYPE_NORMAL
- en: Creating subsequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although we read a time series as an entity from a plain text file, we process
    it as a large list of subsequences. In this subsection, you are going to learn
    how to process a time series as a list of subsequences, based on a given sliding
    window size.
  prefs: []
  type: TYPE_NORMAL
- en: 'The name of the Python script is `subsequences.py`. We are going to present
    it in two parts. Among other things, the first part contains the Python structure
    used to keep the subsequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `TS` class has two members, one to hold the actual data (the `ts` variable)
    and the other to keep the index (index variable) number of the subsequence. The
    chapters that follow are going to enrich the `TS` class to fit our growing needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the script is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `argparse` package helps us put the command-line arguments in order. In
    this case, we expect two parameters: first, the sliding window size (`-w`), and
    second, the filename that holds the time series. The `for` loop is used to split
    the time series into subsequences and generate multiple `TS` class members.'
  prefs: []
  type: TYPE_NORMAL
- en: The previous code is not something difficult to read or understand or make changes
    to. Expect to see this sort of code in most of the Python scripts in this book!
  prefs: []
  type: TYPE_NORMAL
- en: In its current form, `subsequences.py` generates no output. You will only get
    error messages if something is wrong with the provided filename or its data.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing time series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the time, having a high-level overview of your data is an excellent
    way to get to know your data. The best way to get an overview of a time series
    is by visualizing it.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple ways to visualize a time series, including tools such as
    R or Matlab, or using a large amount of existing JavaScript packages. In this
    section, we are going to use a Python package called Matplotlib for visualizing
    the data. Additionally, we will save the output to a PNG file. A viable alternative
    to this is to use a Jupyter notebook – Jupyter comes with Anaconda – and display
    the graphical output on your favorite web browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `visualize.py` script reads a plain text file with values – a time series
    – and creates a plot. The Python code of `visualize.py` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You must be familiar with most of the presented code, as you already saw some
    of it earlier in this chapter. The `plt.plot()` statement plots the data, whereas
    the `plt.savefig()` function saves the output in the file instead of displaying
    it on screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output from the `./visualize.py ts1.gz` command can be seen in *Figure
    1**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3 – Visualizing a time series](img/Figure_1.3_B14769.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.3 – Visualizing a time series
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how to work with time series and subsequences, it is
    time to present an advanced technique called the **Matrix Profile**, which shows
    the tasks that we might need to compute when working with time series and how
    time-consuming these tasks might be.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the Matrix Profile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, as well as the next one, we will work with the `stumpy` Python
    package. This package is not related to iSAX but offers lots of advanced functionality
    related to time series. With the help of `stumpy`, we can calculate the *Matrix
    Profile*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Matrix Profile is two things:'
  prefs: []
  type: TYPE_NORMAL
- en: A vector of distances that shows the distance of each subsequence in a time
    series to its nearest neighbor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A vector of indexes that shows the index of the nearest neighbor of each subsequence
    in a time series
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Matrix Profile can be used in many time series mining tasks. The main reason
    for presenting it is to understand that working with time series can be slow,
    so we need structures and techniques to improve the performance of time series-related
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a better idea of the use of the Matrix Profile and the time it takes
    `stumpy` to calculate the Matrix Profile, here is the Python code of `matrix_profile.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `stumpy.stump()` function calculates the Matrix Profile of a given time
    series.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to execute `matrix_profile.py` two times. The first time using
    a time series with 100,000 elements and the second time using a time series with
    300,000 elements. As with almost all the Python scripts in this book that read
    a time series, `matrix_profile.py` expects to read compressed plain text files.
  prefs: []
  type: TYPE_NORMAL
- en: The taskset(1) command
  prefs: []
  type: TYPE_NORMAL
- en: The `taskset(1)` command is used to assign the desired number of cores to a
    given process and is currently available on Linux machines. The reason for using
    it is to limit the number of available cores when executing `matrix_profile.py`
    and `mpdistance.py`, which, by default, use all available cores due to the use
    of the Numba Python package. As a rule of thumb, when testing the performance
    of an algorithm or comparing one to another, it is better to use a single core.
    There is no similar utility on macOS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `matrix_profile.py` with the smaller time series produces the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: So, it took `stumpy.stump()` around `120.44 seconds` to process a time series
    with 100,000 elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `matrix_profile.py` with the bigger time series produces the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, it took `stumpy.stump()` around `922 seconds` to process a time series
    with 300,000 elements on a single CPU core. Now, imagine doing the same with a
    time series that has more than 1,000,000 elements!
  prefs: []
  type: TYPE_NORMAL
- en: You are going to learn all about the Matrix Profile and understand why it is
    so slow in [*Chapter 7*](B14769_07.xhtml#_idTextAnchor160).
  prefs: []
  type: TYPE_NORMAL
- en: The next section discusses a distance function named **MPdist** that internally
    uses the Matrix Profile for its computation.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the MPdist distance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MPdist offers a way to calculate the distance between two time series. Strictly
    speaking, the *MPdist* distance is a distance measure that is based on the Matrix
    Profile. It is much slower to compute than the Euclidean distance, but it does
    not require the time series to have the same size.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you might expect, it must offer many advantages when compared to the Euclidean
    distance, as well as other existing distance metrics. The main advantages of MPdist,
    according to the people that created it, are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It is more flexible regarding the way it compares data than most existing distance
    functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It considers similarities of data that may not take place at the same time,
    where time means at the same index.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MPdist is considered more robust in specific analytics scenarios due to the
    way it is computed. More specifically, MPdist is more robust to spikes and missing
    values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As MPdist is based on the Matrix Profile, calculating the MPdist distance can
    be extremely slow, especially when working with large time series.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let us have a look at the Python code of `mpdistance.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This program uses command-line arguments with the help of `sys` to read the
    required data, instead of the `argparse` package.
  prefs: []
  type: TYPE_NORMAL
- en: All of this is done by the call to `stumpy.mpdist()`, which requires three parameters
    – the two time series and the sliding window size.
  prefs: []
  type: TYPE_NORMAL
- en: 'As `mpdistance.py` calculates the distance between two time series, it expects
    to read two files. Running `mpdistance.py` with two synthetic data sets with 100,000
    elements each generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: So, on a Linux machine with an Intel i7 CPU, it took `mpdistance.py` `349.81955`
    `seconds` to execute when *using a single CPU core*. The value of the MPdist distance
    is `28.3882`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use two datasets with half a million elements each (500,000 elements),
    the output and the time it takes to execute `mpdistance.py` should be similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: So, on a Linux machine with an Intel i7 CPU, it took `mpdistance.py` `4102.92`
    seconds to execute when *using a single CPU core*. The value of the MPdist distance
    is `38.2851`.
  prefs: []
  type: TYPE_NORMAL
- en: You will learn all the details about MPdist in [*Chapter 7*](B14769_07.xhtml#_idTextAnchor160).
    For now, what you should keep in mind is that MPdist is a distance function that
    has some performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: Experiment and stay humble
  prefs: []
  type: TYPE_NORMAL
- en: If I can give you just one piece of advice to remember from this book, it would
    be to experiment and try things. Experiment as much as possible with what you
    read, question it, think in new ways, try new things, and keep learning. At the
    same time, stay humble, and do not forget that lots of people have worked to lay
    the foundation for us to be here today talking about time series and indexing.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned the basics of time series, indexing, and distance
    functions. Although the theoretical knowledge included in this chapter remains
    valid and relevant no matter what programming language is used, alternative ways
    and packages to achieve the presented tasks in Python exist, as well as other
    programming languages. What remains unchanged is the validity of the approach
    – you must read a text file from disk in order to use its data, no matter the
    programming language – and the logical steps needed to perform a task, such as
    the visualization of a time series. This means that if you know an alternative
    way to load a text file from disk in Python, feel free to use it if it allows
    you to perform the next task at hand. If you are an amateur Python developer,
    I would suggest that you follow the book’s suggestions until you become more competent
    with Python. After all, the used Python packages are the most popular ones in
    the Python community.
  prefs: []
  type: TYPE_NORMAL
- en: Before you continue reading this book, please make sure that you understand
    the knowledge presented in this chapter, as it is the foundation for the rest
    of the book, especially if you are new to time series and indexing.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is about the SAX representation, which is an integral part
    of the iSAX index.
  prefs: []
  type: TYPE_NORMAL
- en: Resources and useful links
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Stumpy Python package: [https://pypi.org/project/stumpy/](https://pypi.org/project/stumpy/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The NumPy Python package: [https://numpy.org/](https://numpy.org/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The SciPy Python package: [https://pypi.org/project/scipy/](https://pypi.org/project/scipy/)
    and [https://scipy.org/](https://scipy.org/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Anaconda documentation: [https://docs.anaconda.com/](https://docs.anaconda.com/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Anaconda distribution: [https://www.anaconda.com/products/distribution](https://www.anaconda.com/products/distribution).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Jupyter Notebooks: [https://jupyter.org/](https://jupyter.org/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Matplotlib: [https://pypi.org/project/matplotlib/](https://pypi.org/project/matplotlib/)
    and [https://matplotlib.org/](https://matplotlib.org/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Z Shell: [https://www.zsh.org/](https://www.zsh.org/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Oh My Zsh: [https://github.com/ohmyzsh/ohmyzsh](https://github.com/ohmyzsh/ohmyzsh).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Pandas Python package: [https://pypi.org/project/pandas/](https://pypi.org/project/pandas/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Dewey Decimal Classification system: [https://en.wikipedia.org/wiki/Dewey_Decimal_Classification](https://en.wikipedia.org/wiki/Dewey_Decimal_Classification).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Numba Python package: [https://pypi.org/project/numba/](https://pypi.org/project/numba/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Matrix Profile is defined in a research paper called *Matrix Profile I:
    All Pairs Similarity Joins for Time Series: A Unifying View That Includes Motifs,
    Discords and Shapelets*. The authors of the paper are Chin-Chia Michael Yeh, Yan
    Zhu, Liudmila Ulanova, Nurjahan Begum, Yifei Ding, Hoang Anh Dau, Diego Furtado
    Silva, Abdullah Mueen, and Eamonn J. Keogh.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The MPdist distance is defined in a research paper called *Matrix Profile XII:
    MPdist: A novel time series distance measure to allow data mining in more challenging
    scenarios*. The authors of the paper are S. Gharghabi, S. Imani, A. Bagnall, A.
    Darvishzadeh, and E. Keogh.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find more information about `numpy.linalg.norm()` at [https://numpy.org/doc/stable/reference/generated/numpy.linalg.norm.xhtml](https://numpy.org/doc/stable/reference/generated/numpy.linalg.norm.xhtml).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Homebrew macOS package manager: [https://brew.sh/](https://brew.sh/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Try to do the following exercises:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Anaconda environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List the installed packages of an Anaconda environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete an existing Anaconda environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a new synthetic dataset with 1,000 values from -10 to +10.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a new synthetic dataset with 100,000 values from 0 to +10.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a Python script that reads a plain text file line by line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a Python script that reads a plain text file and prints it word by word.
    Why is this more difficult than printing a file line by line?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a Python script that reads the same plain text file multiple times, and
    time that operation. The number of times the file is read as well as the file
    path should be given as command-line arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify `synthetic_data.py` to generate integer values instead of floating-point
    values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a time series with 500,000 elements with `synthetic_data.py`, and execute
    `matrix_profile.py` on the generated time series. Do not forget to compress the
    plain text file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify `mpdistance.py` to use `argparse` to read its parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Experiment with `visualize.py` to plot your own time series. What happens when
    you plot big time series? How easy it is to find what you are looking for?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the iSAX index in *Figure 1**.2* a binary tree? Is it a balanced tree? Why?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify `ed.py` to read the time series from compressed plain text files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
