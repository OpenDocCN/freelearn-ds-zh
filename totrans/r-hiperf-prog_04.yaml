- en: Chapter 4. Using Compiled Code for Greater Speed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have looked at how to optimize the computational performance of an
    R code. What if, after optimizing the code, it still runs too slowly? In this
    chapter, we will look at how to overcome the performance limitations caused by
    on-the-fly interpretation of an R code using a compiled code. Many CRAN packages
    use compiled code to offer optimum performance, so a simple way to take advantage
    of a compiled code is to use these packages. Sometimes, however, a specific task
    needs to be performed for which no package exists. It is useful to know how to
    write a compiled code for R in order to make R programs run faster.
  prefs: []
  type: TYPE_NORMAL
- en: We will first see how to compile R code before its execution, then we will explore
    how to integrate compiled languages like C/C++ into R so that we can run R programs
    at native CPU speed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Compiling an R code before execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using compiled languages in R
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling R code before execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html "Chapter 1. Understanding R's Performance – Why Are
    R Programs Sometimes Slow?"), *Understanding R's Performance – Why Are R Programs
    Sometimes Slow?* we saw how R, being an interpreted language, has to parse and
    evaluate code every time an R program is run. This takes a lot of CPU time and
    slows down the execution of R programs. R provides the `compiler` package to somewhat
    reduce this issue. The functions in this package allow us to compile R code beforehand
    and save R a step or two when we execute the code. Let's see how this works.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s define a `mov.avg()` function that calculates the moving average of
    a numeric series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Given a numeric vector `x` and period `n`, we first calculate the `n` element's
    window sum of the elements of `x`. For example, if `x` is `[1, 2, 1, 3, 5]` and
    `n` is `2`, then we calculate `total` as `[1+2, 2+1, 1+3, 3+5] = [3, 3, 4, 8]`.
    We do this by looping `n` times over `x`, selecting a moving window of the elements
    of `x`, and adding those elements to `total`. Finally, we compute the moving average
    by dividing `total` by `n`.
  prefs: []
  type: TYPE_NORMAL
- en: To compile the function, we will use the `cmpfun()` function in the `compiler`
    package. The compilation functions provided by the `compiler` package operate
    on four different levels of optimization, numbered 0 to 3; the higher the number,
    the more the compiled code is optimized for performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s compile `mov.avg()` at different levels to see the differences in execution
    time. Here, we create four copies of the `mov.avg()` function compiled at different
    levels of optimization by passing the `optimize` argument to `cmpfun()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we benchmark the performance of the original `mov.avg()` function and
    the four compiled versions by computing the 20-period moving average of a numeric
    vector with `100` elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the median execution times, the original function took 41.4 μs. The
    compiled functions at optimization levels 0 and 1 took about the same time, coming
    in at 42.0 μs and 41.1 μs respectively. However those at optimization levels 2
    and 3 performed well, at 28.3 μs and 27.8 μs. They reduced the execution time
    by 32 percent and 33 percent respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The minimum lower quartile and upper quartile statistics shows a similar pattern
    with `mov.avg.compiled2()` and `mov.avg.compiled3()` executing in less time than
    `mov.avg()`, `mov.avg.compiled0()`, and `mov.avg.compiled1()`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We should not rely on the maximum statistics because it can be unstable, producing
    a wide range of values every time we run `microbenchmark()`. This is due to the
    outliers when R's garbage collection takes place, or when the execution of the
    functions are slowed down by other processes competing for CPU time.
  prefs: []
  type: TYPE_NORMAL
- en: The following chart shows the distributions of the benchmarking results in an
    intuitive visual form.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Generate an intuitive visualization of the benchmarking results by using the
    `autoplot()` function. The `ggplot2` package is needed for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![Compiling functions](img/9263OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Autoplot of microbenchmark() results for moving average functions
  prefs: []
  type: TYPE_NORMAL
- en: The performance gain when R code is compiled depends on what kinds of R expressions
    are contained in the code. In our example, we achieved modest performance gains
    because the `for` loop and the arithmetic operations in the `mov.avg()` function
    could be optimized. However, compiling code that mostly calls other functions
    that have already been optimized for performance (such as `sum()`) would not result
    in significant performance gains.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `compiler` package provides different functions to compile different types
    of R code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cmpfun()` compiles an R function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compile()` compiles an R expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmpfile()` compiles an R expression stored in a file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just-in-time (JIT) compilation of R code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: R also supports **just-in-time** (**JIT**) **compilation**. When JIT compilation
    is enabled, R will automatically compile any code that is executed without explicitly
    having called one of the `compile` functions. This is convenient, as any existing
    R code can enjoy the performance gains of code compilation without any modification.
  prefs: []
  type: TYPE_NORMAL
- en: 'To activate JIT compilation, use the `enableJIT()` function in the `compiler`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `level` argument tells R how much code to compile before execution. Valid
    values for `level` are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0`: It disables JIT.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1`: It compiles functions before their first use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2`: In addition, it compiles functions before they are duplicated. This is
    useful for some packages like lattice that store functions in lists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3`: It compiles loops before they are executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s benchmark the (uncompiled) `mov.avg()` function with the JIT compilation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The JIT compilation reduced the median execution time of `mov.avg()` from 41.4
    μs to 24.5 μs—a 41 percent improvement!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JIT compilation can also be enabled by setting the `R_ENABLE_JIT` environment
    in the operating system before starting R. The value of `R_ENABLE_JIT` should
    be set to the value of the `level` argument.
  prefs: []
  type: TYPE_NORMAL
- en: Using compiled languages in R
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code compilation can provide modest gains in computational performance, but
    there are limits to these gains because the compiled code still needs to be evaluated
    by R in a dynamic fashion. For example, we explained in [Chapter 3](ch03.html
    "Chapter 3. Simple Tweaks to Make R Run Faster"), *Simple Tweaks to Make R Run
    Faster*, how R, being a **dynamically typed** language, needs to check the type
    of an object before applying any operations. In the case of `mov.avg()`, every
    time R encounters the `+` operator, it needs to check that `x` is a numeric vector,
    as it could have been modified between each iteration of the `for` loop. In contrast,
    a **statically typed** language performs these checks at compile time, resulting
    in much faster run time performance.
  prefs: []
  type: TYPE_NORMAL
- en: For this and many other reasons, R's dynamic nature poses barriers to computational
    performance. The only way to break through these barriers is to turn to compiled
    languages such as C and use them from within R. This section assumes that you
    have some basic knowledge of compiled languages such as C/C++, including pointers
    and arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to compile the examples in this chapter, a set of development tools,
    including a C/C++ compiler are needed.
  prefs: []
  type: TYPE_NORMAL
- en: Windows users should download and install `Rtools` from [http://cran.r-project.org/bin/windows/Rtools/](http://cran.r-project.org/bin/windows/Rtools/).
    Pick the version of `Rtools` that corresponds to your version of R. Be sure to
    select the **Package authoring installation** and **Edit the system PATH** options
    in the installation wizard.
  prefs: []
  type: TYPE_NORMAL
- en: On Mac OS X, download and install the *Xcode Command Line Tools*. If you are
    using Mac OS X 10.9 Mavericks or a later version, simply run `xcode-select –install`
    in terminal. For earlier versions of Mac OS X, create a developer account at [http://developer.apple.com/](http://developer.apple.com/).
    Then sign in, go to [https://developer.apple.com/downloads/index.action](https://developer.apple.com/downloads/index.action)
    and search for command-line tools for Xcode for your OS version.
  prefs: []
  type: TYPE_NORMAL
- en: Most Linux distributions offer an easy way to install the standard development
    tools; consult the documentation of your distribution for instructions. If you
    are using Debian or Ubuntu, you can just install `r-base-dev` to get all the tools
    you need.
  prefs: []
  type: TYPE_NORMAL
- en: Including compiled code inline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `inline` CRAN package allows us to embed C, C++, Objective-C, Objective-C++,
    and Fortran code within R. This is handy for speeding up small R functions with
    a bit of compiled code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how to implement `mov.avg()`in C using the `inline` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We load the `inline` package and define `mov.avg.inline()` using `cfunction()`.
    A number of arguments are taken by `cfunction()`(look up the documentation for
    more details), but we need only three here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sig=signature(x="numeric", n="integer")`: This defines the signature of the
    function. In this case, it will look like `mov.avg.inline(x, n)`, where `x` has
    the numeric class and the n has integer class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`body`: The `body` argument contains the code for the function''s body in the
    programming language of your choice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`language="C"`: This specifies the programming language of the code in body.
    Valid values are `C,` `C++`, `Fortran`, `F95`, `ObjectiveC`, and `ObjectiveC++`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first step of the function is to make sure that the arguments supplied to
    the function are of the correct type by calling `coerceVector()`. This function
    returns an `SEXP` (s-expression) pointer, which is how all R objects are represented
    in C and C++. These pointers point to `SEXPREC` (s-expression) record structures
    that store the data along with some header information. The first two lines of
    code define two new `SEXP` variables, `x2` and `n2`, that store pointers to new
    R objects created by coercing the function arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Because `coerceVector()` creates new data structures in memory to store the
    data in the specified types, we wrap the calls to `coerceVector()` in the macro
    function `PROTECT()`, which protects the newly created data structures from R's
    garbage collection mechanisms. This is necessary because R does not know when
    variables are no longer needed in C, and might be overzealous in freeing memory
    for objects that are still needed. `PROTECT()` needs to be called every time memory
    is allocated for a new R object.
  prefs: []
  type: TYPE_NORMAL
- en: Now `x2` and `n2` contain `SEXP` pointers of R objects that represent the coerced
    arguments. Because `x2` and `n2` point to `SEXPREC` structures, we still do not
    have direct access to the C arrays that store the data. There are a couple of
    ways to get access to the data. In `double *x_p = REAL(x2);`, the `REAL()` macro
    returns a `double*` pointing to the first element of the double array. The `int
    n_val = asInteger(n2);` declaration takes a different approach by calling the
    `asInteger()` convenience function to return the first integer value in the array
    pointed to by `n2`. Notice the difference here; `x_p` is a pointer to a double
    array while `n_val` is an integer containing the actual value of the argument.
    Both styles of access to the R data can be used depending on which is more convenient.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we compute the length `res_len` of the numeric vector in which we will
    store the results, and create the vector using `allocVector()`. Again, this is
    wrapped in `PROTECT()` because memory is being allocated for a new object. The
    result of this expression is a `SEXP` pointing to the new R numeric vector. `REAL(res)`
    provides access to the underlying C double array, as before.
  prefs: []
  type: TYPE_NORMAL
- en: The next pair of nested `for` loops computes the window sum with the `n_val`
    period. Then, the moving average is computed by dividing each element of the results
    array by `n_val`.
  prefs: []
  type: TYPE_NORMAL
- en: Before returning the results, there is some housekeeping that is required. `UNPROTECT(3)`
    tells R that the three objects for which memory was allocated in C, do not need
    protection from garbage collection anymore. The argument to `UNPROTECT()` must
    match the number of calls to `PROTECT()` in the function. In this case, it is
    likely that the the garbage collector will free the memory for `x2` and `n2`.
    The `res` object, however, is passed back to R, where the normal garbage collection
    mechanisms apply.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do a simple test to ensure that our code works correctly by calling
    the original `mov.avg()` function alongside `mov.avg.inline()` and ensuring that
    the values match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'How much quicker will the C code run than the original uncompiled R function?
    This is shown, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The C code took an average of just 1.55 μs compared with 34.8 μs for the R
    code—a 96 percent reduction in execution time! Even the maximum execution time
    in C (14.2 μs) is less than half of the minimum execution time in R (32.9 μs).
    These savings of a few microseconds might not seem like much, but the difference
    becomes significant when we have to process larger datasets or compute moving
    averages with larger periods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When the data contains 10 million numbers, the difference is more pronounced;
    over 2 seconds in R and only 0.28 seconds in C. In some business contexts, every
    millisecond counts, and a latency of 2 seconds is not acceptable. In such situations,
    writing key pieces of data processing code in a compiled language like C or Fortran
    and embedding them into R using `inline` will give a huge boost to computational
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: Calling external compiled code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen how to use a compiled language to define functions in R. When we
    want to implement more complex functionality using compiled code, such as creating
    entire R packages or linking to external libraries, it might be easier to develop
    the code externally and to call it from R.
  prefs: []
  type: TYPE_NORMAL
- en: 'R provides a few interfaces to call the external compiled code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.C()`: This calls C or C++ code with a maximum of 65 arguments. Type checking
    and coercion must be done in R before calling the C function. Functions called
    by `.C()` should not return any values; instead, when the function is called,
    the results stored by data structures should be supplied to the function. For
    example, if we were to implement `mov.avg()` using the `.C()` interface, the function
    call might look like `.C("mov_avg_C", as.numeric(x), as.integer(n), numeric(length(x)
    - n + 1))`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.Fortran()`: This is similar to `.C()` except it calls `Fortran` code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.Call()`: This also calls C or C++ code with a maximum of 65 arguments. Type
    checking and coercion can be done in R or in C/C++ (as in the `mov.avg.inline()`
    example). Functions called by `.Call()` can return an R object. If multiple return
    values are needed, an R list can be returned. For example, `ma <- .Call("mov_avg_C",
    x, n)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.External()`: This is similar to `.Call()` except all arguments are passed
    in a single `SEXP`. As a result, functions called with `.External()` can accept
    a variable number of arguments and a practically unlimited number of arguments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The functions provided by the `inline` package are actually wrappers for some
    of the lower-level interfaces that make it easier for developers to embed a compiled
    code in R.
  prefs: []
  type: TYPE_NORMAL
- en: It is beyond the scope of this book to explain in detail how to use these interfaces.
    To learn more, read the *System and foreign language interfaces* and *The R API*
    sections of the *Writing R Extensions* manual (for more information visit [http://cran.r-project.org/doc/manuals/r-release/R-exts.html](http://cran.r-project.org/doc/manuals/r-release/R-exts.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For Java programmers, the `rJava` package on CRAN provides an interface to Java
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we would like to introduce the `Rcpp` package that provides a convenient,
    higher-level API to the `.Call()` interface for C++ code. Here is the moving average
    function implemented using `Rcpp`. Save this code in the `mov_avg_Rcpp.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The first line `#include <Rcpp.h>` imports the headers required to use `Rcpp`
    classes and functions. The comment `// [[Rcpp::export]]` is an `Rcpp` attribute.
    It tells `Rcpp` that the following function should be exported to R.
  prefs: []
  type: TYPE_NORMAL
- en: '`SEXP` pointers are not used in `mov_avg_Rcpp()`. Instead, `Rcpp` provides
    classes that represent the standard R classes. We can even specify that `n` is
    a single integer and not an integer vector. Whenever `mov_avg_Rcpp()` is called
    from R, `Rcpp` will automatically check that the supplied arguments are of the
    correct type.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that there are no calls to `PROTECT()` or `UNPROTECT()` here. When `Rcpp::NumericVector
    res(res_len);` creates a new numeric vector for the results, `Rcpp` takes care
    of the memory allocation and protection from garbage collection. It even initializes
    the values of the new vector to zeroes.
  prefs: []
  type: TYPE_NORMAL
- en: '`Rcpp` also provides direct access to the data in the `x` argument and the
    results vector `res` without having to ask for pointers to the data.'
  prefs: []
  type: TYPE_NORMAL
- en: Using `Rcpp`, we can write more succinct and readable code than possible using
    the native `.C()` or `.Call()` interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now see how to call this function from within R. Besides loading the
    `Rcpp` library, the only other thing to do is to call `sourceCpp()`, which will
    compile the C++ code and export the function to R:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can call `mov_avg_Rcpp()` and benchmark it against our previous versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `Rcpp` version runs a little slower than the inline version, but it is still
    much faster than our pure R code. It provides a good level of performance with
    a much simpler API than the other interfaces provided by R.
  prefs: []
  type: TYPE_NORMAL
- en: '`Rcpp` provides many more features than we can cover in this book such as package
    authoring tools, the `sugar` functions for common operations such as vector operations,
    and more. For more details, code examples, and resources, look up the `Rcpp` website
    at [http://www.rcpp.org/](http://www.rcpp.org/). One of the creators of `Rcpp`,
    Dirk Eddelbuettel, has also written the *Seamless R and C++ Integration with Rcpp
    (use R!)* book that provides a comprehensive guide.'
  prefs: []
  type: TYPE_NORMAL
- en: Considerations for using compiled code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few things to bear in mind while using compiled code in R. We will
    explain the common ones here; the *Writing R Extensions* manual provides a comprehensive
    treatment of these topics.
  prefs: []
  type: TYPE_NORMAL
- en: R APIs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The C functions and macros used so far are from the header file `Rinternals.h`,
    found in `R_INCLUDE_DIR` which defaults to `R_HOME/include` in any standard R
    installation. This file, together with `R.h` and other header files in `R_INCLUDE_DIR`,
    provides various APIs for C/C++ code to interface with R. Together they provide
    a rich set of functions for:'
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating R objects (for example, sorting vectors)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing memory allocation and deallocation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Math (for example, trigonometric functions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mathematical constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Random number generation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statistical distributions (for example, `rnorm` and `punif`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BLAS, LAPACK, and LINPACK linear algebra routines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And much more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is worthwhile to explore these files in order to see which functionality
    is available for C/C++ code. Some of these can be called from Fortran as well.
    The *Organization of header files* section of *Writing R Extensions* describes
    each header file.
  prefs: []
  type: TYPE_NORMAL
- en: R data types versus native data types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While working in compiled languages, it is useful to know how R types map to
    different native data types, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| R storage mode | C type | Fortran type |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `logical` | `int *` | `INTEGER` |'
  prefs: []
  type: TYPE_TB
- en: '| `integer` | `int *` | `INTEGER` |'
  prefs: []
  type: TYPE_TB
- en: '| `double` | `double *` | `DOUBLE PRECISION` |'
  prefs: []
  type: TYPE_TB
- en: '| `complex` | `Rcomplex *` | `DOUBLE COMPLEX` |'
  prefs: []
  type: TYPE_TB
- en: '| `character` | `char **` | `CHARACTER*255` |'
  prefs: []
  type: TYPE_TB
- en: '| `raw` | `unsigned char *` | `none` |'
  prefs: []
  type: TYPE_TB
- en: 'When dealing with `SEXP` pointers in C/C++ or type classes in `Rcpp`, here
    are the most commonly used types (look up the documentation for R or `Rcpp` for
    a complete list):'
  prefs: []
  type: TYPE_NORMAL
- en: '| R type | SEXP Type | Rcpp type |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `numeric` | `REALSXP` | `NumericVector / NumericMatrix` |'
  prefs: []
  type: TYPE_TB
- en: '| `integer` | `INTSXP` | `IntegerVector / IntegerMatrix` |'
  prefs: []
  type: TYPE_TB
- en: '| `complex` | `CPLXSXP` | `ComplexVector / ComplexMatrix` |'
  prefs: []
  type: TYPE_TB
- en: '| `logical` | `LGLSXP` | `LogicalVector / LogicalMatrix` |'
  prefs: []
  type: TYPE_TB
- en: '| `character` | `STRSXP` | `CharacterVector / CharacterMatrix` |'
  prefs: []
  type: TYPE_TB
- en: '| `list` | `VECSXP` | `List` |'
  prefs: []
  type: TYPE_TB
- en: '| `data.frame` | `none` | `DataFrame` |'
  prefs: []
  type: TYPE_TB
- en: Creating R objects and garbage collection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have seen how R objects can be created and memory can be allocated for them
    by calling `allocVector()` and `coerceVector()`. `Rinternals.h` defines other
    memory allocation functions as well, such as `allocList()` and `allocArray()`.
    Any call to the `alloc*()` functions or `coerceVector()` needs to be wrapped in
    `PROTECT()`.
  prefs: []
  type: TYPE_NORMAL
- en: In the `mov.avg.inline()` example, `UNPROTECT()` is used to remove garbage collection
    protection right before returning the results. `UNPROTECT()` can also be called
    at any point in a function to allow the garbage collector to release R objects
    that are no longer needed. The protection mechanism is stack-based, so `UNPROTECT(n)`
    removes the protection from the last `n` objects that were protected. Alternatively,
    `UNPROTECT_PTR(p)` can be used to unprotect the specific object that `SEXP` `p`
    points to, even if it is not at the top of the stack.
  prefs: []
  type: TYPE_NORMAL
- en: In complex C/C++ code that creates many R objects, it is good practice to unprotect
    them once they are not needed, so that the garbage collector can do its job efficiently.
    However, it is the programmer's responsibility to make sure that those unprotected
    objects are never used again in the code, to prevent any memory errors.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, always remember to match the number of the `PROTECT()` calls with the
    total number of objects unprotected by `UNPROTECT()` or `UNPROTECT_PTR()`.
  prefs: []
  type: TYPE_NORMAL
- en: Allocating memory for non-R objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, memory is needed to store the results of intermediate computations
    that do not need to be accessed from R. R provides two ways of allocating memory
    like this in C/C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first method, **transient storage allocation**, allows you to allocate
    memory that is automatically reclaimed by R at the end of the call to `.C()`,
    `.Call()` or `.External()`. To do this, use the `char *R_alloc(size_t n, int size)`
    function, which allocates `n` units of `size` bytes each and returns a pointer
    to the allocated memory. A typical usage might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There is no need to free the allocated memory within the C/C++ function, as
    R will take care of that when the function execution ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **user-controlled memory** mechanism provides more control over the allocation
    and freeing of memory. This allows memory to be freed between different parts
    of C/C++ code. For example, in an iterative algorithm where each stage of computation
    produces large amounts of intermediate data, memory from previous iterations can
    be freed to ensure that there is sufficient free memory to complete future iterations.
    There are three functions in this interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '`type* Calloc(size_t n, type)`: This allocates memory of the specified size
    and type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type* Realloc(any *p, size_t n, type)`: This changes the size of the memory
    allocated at `*p` to the specified size and type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void Free(any *p)`: This frees the memory at `*p`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These functions are analogous to the C functions `calloc()`, `realloc()`, and
    `free()`, with additional error handling by R. If they return, then the memory
    has been successfully allocated or freed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered a variety of techniques to leverage code in compiled
    languages for a near-native CPU performance. While the examples focused on C and
    C++, similar approaches can be used with Fortran or Java.
  prefs: []
  type: TYPE_NORMAL
- en: We first saw how compiling an R code before its execution by using the `compile`
    package can provide modest performance gains, especially for code with many loops
    and basic operations. JIT compilation does the same automatically for executing
    any R code. There is a limit, however, to how much an R code can be optimized
    because R is a dynamic language at its core.
  prefs: []
  type: TYPE_NORMAL
- en: Looking beyond R, we used C and C++ to achieve dramatic performance improvements.
    We learned how to define a C function from within R, using the `inline` package,
    and how to use `Rcpp` to call an external C++ function from R.
  prefs: []
  type: TYPE_NORMAL
- en: In the process, we learned about how R represents different types of data in
    C/C++ using `SEXP` pointers and `SEXPREC` record structures, and how to manipulate
    R objects using these constructs. We also learned about the intricacies of allocating
    memory, freeing memory, and garbage collection while working in C/C++.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we took a quick tour of the R APIs that provide rich R functionality
    from within C, C++, or Fortran.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covered advanced techniques to achieve optimized computational
    performance in R, using compiled languages. These techniques allow R programmers
    to tap into the power and speed of compiled languages while enjoying the simplicity
    and flexibility of R as a data processing environment. The huge performance gains
    from using compiled languages come with an equally huge responsibility to understand
    in detail how these techniques work, so that they can be used safely and effectively.
    Whole books could be written on this topic; we encourage you to look up other
    resources including the *Writing R Extensions* manual for a deeper and more comprehensive
    treatment.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how to leverage the computing power of
    **Graphics Processing Units** (**GPUs**) for certain types of computations.
  prefs: []
  type: TYPE_NORMAL
