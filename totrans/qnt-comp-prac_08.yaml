- en: '*Chapter 8*: Cleaning Up Your Quantum Act with Ignis'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have explored running our quantum programs on idealized Qiskit Aer simulators
    and gotten our hands dirty with the actual IBM Quantum machines. We understand
    that real qubits are noisy and that we cannot expect quantum computers to solve
    actual real-world problems of any significant magnitude (yet). On the path to
    this future application lies ﬁghting and mitigating noise and errors, and on that
    path lies Qiskit Ignis.
  prefs: []
  type: TYPE_NORMAL
- en: Qiskit® includes a lot of automation, such as the optimization of the assigned
    qubits according to connectivity and performance; but this automation is, to an
    extent, limited by the physical layout of a quantum chip, which controls how the
    qubits can communicate with each other. By studying the qubit performance and
    specifying which actual physical qubits you want to use with your quantum programs,
    you can optimize your circuits for optimal entanglement and decoherence, to name
    a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore how running your programs on different sets
    of qubits on the same backend might cause you to end up with different results.
    We will also use the Qiskit Ignis methods to do readout correction on our simpler
    algorithms on simulated and existing hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will take a look at quantum error correction using the Shor code,
    seeing how you can create a single logical qubit by using several physical qubits
    for quantum error correction.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring your qubits to understand T1, T2, errors, and gates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing the qubits on a chip
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Estimating the number of gates you have time for
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Correcting the expected with readout correction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mitigating the unexpected with quantum error correction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The quantum programs that we''ll discuss in this chapter can be found here:
    [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter08](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter08).'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring your qubits to understand T1, T2, errors, and gates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start off with a quick overview of some things that can go wrong when
    you send your perfectly working and simulator-verified quantum program to an actual,
    physical quantum computer. As we have seen, as soon as we step away from our perfect
    simulated qubits and start using physical qubits that work quantum-mechanically,
    we also have to contend with another physical feature of reality: noise.'
  prefs: []
  type: TYPE_NORMAL
- en: In a quantum computer, the noise differs between backends, between qubits on
    a backend, between different types of gates, and between the readouts of each
    qubit. Building and programming quantum computers really is a complex task.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The file required for this recipe can be downloaded from here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r1_gates_data.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r1_gates_data.py).'
  prefs: []
  type: TYPE_NORMAL
- en: This recipe builds on the work we did in [*Chapter 5*](B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128),
    *Touring the IBM Quantum® Hardware with Qiskit® Tools*, but this time we are specifically
    looking at the qubit properties that hint at the many ways that things can go
    wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using the `backend.properties()` Qiskit® method to pull out the
    following properties for qubits:'
  prefs: []
  type: TYPE_NORMAL
- en: '`t1()`: The T1 or relaxation time for the given qubit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`t2()`: The T2 or dephasing time for the given qubit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readout_error()`: The risk of misreading the qubit during measurement'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gate_length()`: The duration of the gate in units of seconds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gate_error()`: The gate error estimate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sample code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we import the class that we need and load our account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We use `select_backend()` here to load and display the data for the available
    backends, and then prompt to select one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `display_information(backend)` function retrieves the backend information
    such as the number of qubits and the qubit coupling map, and then uses that to
    cycle through the backend's qubits to retrieve the T1, T1, readout error, and
    gate information. The function comprises two parts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we gather the qubit information:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we print out the basic qubit information and the qubit-specific information
    for each gate:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The main function calls the `select_backend()` and `display_information(backend)`
    functions to help you see all the qubit information for a selected backend:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To explore the qubit properties of a specific backend, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In your Python environment, run `ch8_r1_gates_data.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The script loads Qiskit® and grabs and displays a list of the available backends
    as shown here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Select a backend to investigate'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_8.1_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.1 – Select a backend to investigate
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When prompted, enter the name of the IBM Quantum® backend that you want to
    take a look at:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We now pull in `backend.properties()` for the selected backend, and from these,
    sift through and display the following parameters: qubit readout error, T1 and
    T2 decoherence times, gate length, and error for all the basis gates for the backend.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Qubit data for the ibmq_vigo 5-qubit backend'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_8.2_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.2 – Qubit data for the ibmq_vigo 5-qubit backend
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: That is a fair bit of data, but it only represents a small piece of the data
    that can be collected for a specific backend. For a refresher, see the *Exploring
    a selected backend using Qiskit®* recipe in [*Chapter 5*](B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128),
    *Touring the IBM Quantum® Hardware with Qiskit® Tools*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first pieces of data that we will touch on are the **T1** and **T2** times
    and the **readout error**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Data for qubit 0'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.3_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.3 – Data for qubit 0
  prefs: []
  type: TYPE_NORMAL
- en: 'This first set of data represents the physical reasons that you might not get
    the results that you expect when you run your quantum code on the backend:'
  prefs: []
  type: TYPE_NORMAL
- en: '**T1**, **or relaxation** **time**: The T1 value, displayed as ![](img/Formula_008_100.png)
    in *Figure 8.3,* is a statistical value of how long it takes for the qubit to
    spontaneously relax from the "excited" state ![](img/Formula_008_001.png) to the
    ground state ![](img/Formula_008_002.png). In essence, T1 is an estimate of the
    time that you have at your disposal to perform high-quality actions on the qubit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**T2**, **or** **dephasing** **time:** Similar to T1, the T2 value, displayed
    as *ms* in *Figure 8.3,* is a measure of how phase information is lost for a qubit.
    An example of phase change is when the state ![](img/Formula_008_003.png) spontaneously
    changes to ![](img/Formula_008_004.png). Again, if the running time for your circuit
    starts to approach the T2 time, the quality of your readout data will suffer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now for the rest of the data that we pulled in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Data for qubit 0'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.4_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.4 – Data for qubit 0
  prefs: []
  type: TYPE_NORMAL
- en: '`readout_error`, `gate_length`, and `gate_error` represent the quality of the
    gates that you can run on each qubit.'
  prefs: []
  type: TYPE_NORMAL
- en: '`readout_error`: The readout error rate, displayed as a percentage in *Figure
    8.4*, is simply the probability that you will get the incorrect value when reading
    the qubit. For example, a qubit in state ![](img/Formula_06_0221.png) will be
    read as ![](img/Formula_06_023.png) and vice versa. This really has nothing to
    do with any other qubit manipulations but is simply the error rate for the final
    readout of the collapsed qubit. It is possible to get a statistical picture of
    each qubit and mitigate these readout errors. We will do that in the *Correct
    the expected with readout correction* recipe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gate_length`: The gate length, displayed as *![](img/Formula_008_100.png)*
    in *Figure 8.4*, represents the time it takes to make the adjustment to the qubit
    that corresponds to the gate. If you look at the data returned, you see that the
    gate length for a U3 gate might be in the order of a twentieth of a microsecond
    or so, whereas the T1/T2 times might be much longer than that. This, however,
    doesn''t mean that you can just add hundreds or thousands of these gates within
    that time span and expect the results to be great. This is where gate errors come
    in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gate_error`: The gate error, displayed as a percentage in *Figure 8.4*, is
    a statistical value for how accurate the gate is at executing the expected results.
    As you can see, the errors range from 0.05% to a few percent. For short circuits
    of just a few gates, we can run the circuit many times and statistically derive
    the correct values even with gate errors popping up. For longer circuits, of hundreds
    or thousands of gates, even these small gate errors start to make an impact. In
    [*Chapter 9*](B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246), *Grover''s Search
    Algorithm*, you will build quantum circuits with hundreds of gates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Remember from the *What are the IBM Quantum® machines?* recipe in [*Chapter
    5*](B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128), *Touring the IBM Quantum®
    Hardware with Qiskit®*, that the gates are not physical things like the bundles
    of transistors that make up the gates in classical computing. Instead, quantum
    gate logic constitutes a series of microwave pulses that are sent down to and
    interact with the cryogenically chilled qubits. The quality of gates thus hinges
    on quite a few things: the physical properties of the **Josephson junction** and
    resonator circuit that constitute the physical qubit, the accuracy of the carrier
    wave and gate-coded wave package, the microwave resonators, the cryostats, and
    much more.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can also get to the backend qubit data from IBM Quantum Experience®.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to IBM Quantum Experience® at [https://quantum-computing.ibm.com](https://quantum-computing.ibm.com).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Welcome** page, on the right side, you'll see a list of the available
    backends:![Figure 8.5 – The IBM Quantum Experience® home page
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_3.1_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.5 – The IBM Quantum Experience® home page
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the backend that you are interested in, for example, `ibmq_vigo`, to
    see the chip layout and additional information:![Figure 8.6 – Details of the ibmq_vigo
    backend
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.6_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.6 – Details of the ibmq_vigo backend
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Click **Download Calibrations** for a CSV file with the qubit information.
    The downloaded calibration data looks as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.7 – Downloaded calibration data from IBM Quantum Experience®'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.7_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.7 – Downloaded calibration data from IBM Quantum Experience®
  prefs: []
  type: TYPE_NORMAL
- en: You can now bring the data into your favorite spreadsheet software for further
    processing as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing the qubits on a chip
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we looked at some of the pieces of information that
    you can glean about the IBM Quantum® hardware, illustrating the nature of today's
    NISQ machines. In this recipe, we will show a real comparison between the different
    qubits of a selected IBM backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will run the same Bell state quantum program on three different setups:
    an ideal quantum computer (`qasm_simulator`), the best qubit pair, and the worst
    qubit pair on a 5-qubit, least busy IBM Quantum® machine.'
  prefs: []
  type: TYPE_NORMAL
- en: We will print and plot the end result to compare the ideal result (![](img/Formula_008_007.png)
    and ![](img/Formula_008_008.png) at 50%) with the real results (a probabilistic
    mix of ![](img/Formula_008_009.png)) to illustrate how today's quantum computers
    still have a little way to go.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The file required in the following recipe can be downloaded from here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r2_compare_qubits.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r2_compare_qubits.py)'
  prefs: []
  type: TYPE_NORMAL
- en: The sample code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we import the classes and methods that we need and load our account.
    In this recipe, we combine a lot of important concepts from earlier in the book,
    such as simulators and noise models:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `select_backend()` function lets you select an available backend. You can
    also have the system pick the least busy one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Pull out the best and worst CX gate performance information, then cycle through
    the CX gate couplings to find the best and worst performing connection, before
    returning this information as a `cx_best_worst` list for later usage. We can now
    take a look at the best and worst performing CX gate information that we stored.
    To verify that we have collected the correct information, we can display the error
    map for the backend, and check that the CX connectors really do represent the
    best and worst:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create two quantum circuits sized for the selected backend. With the qubit
    information gathered, we can create a quantum program that specifies CX gates
    for the best and worst qubit pairs. Here is where we use that qubits variable
    we pulled earlier. First, we build two circuits (`qc_best` and `qc_worst`) that
    have the correct number of qubits depending on the selected backend. That information
    is gathered using the `backend.configuration().n_qubits` method. We use the `cx_best_worst`
    list that we created earlier to place the H and CX gates on the correct qubits
    and then print the circuits:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the best and worst circuits on the backend. With all pieces assembled, we
    can now run the best circuit, followed by the worst. Of course, we also want a
    benchmark job on the perfect `qasm_simulator` using the same number of qubits
    as when we ran on the actual backend. Create and run a benchmark circuit on a
    local simulator. Print the results for the best, worst, and baseline qubit pair
    and plot the results in a diagram. We can also use the Qiskit® histogram feature
    to display the results in diagram form for clarity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We start by displaying the best and worst CX-pair circuits, and running these
    on the selected backend:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we build a generic CX circuit (Bell circuit), and run this one on the
    local `qasm_simulator` to get a baseline result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we collect the best, worst, and baseline job results. We then print
    them and display them together in a diagram for comparison:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And finally, the `main` function pulls it all together:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The IBM Quantum® backends are actual physical semiconductor circuits, each with
    slightly different behavior. In addition, the qubits are physically connected
    to make it possible to directly entangle them the way that you specify in your
    quantum programs. This type of qubit communication can only take place directly
    as specified by the coupling map that we looked at in the *Visualizing the backends*
    recipe in [*Chapter 5*](B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128), *Touring
    the IBM Quantum® Hardware with Qiskit®*.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we extract the error rate for 2-qubit communication from our
    selected backend. We then pick the best and the worst qubit pairs and run the
    same quantum program on each pair to see how the outcome of the program differs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how it is done:'
  prefs: []
  type: TYPE_NORMAL
- en: In your Python environment, run `ch8_r3_time.py`. The script loads Qiskit® and
    grabs and displays a list of the available backends:![Figure 8.8 – First, we select
    a backend to test on, such as ibmq_santiago
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.8_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.8 – First, we select a backend to test on, such as ibmq_santiago
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Enter the name of a backend that you want to test on or enter `LB` to have the
    system pick the least busy system for you.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The best and worst CX gate performance information is displayed as a list and
    as an error map:![Figure 8.9 – The various CX gate errors for the qubit combinations
    of ibmq_santiago
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.9_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.9 – The various CX gate errors for the qubit combinations of ibmq_santiago
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To verify that we have collected the correct information, we display the error
    map for the backend.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Take a look at the CNOT error rate legend in *Figure 8.10* and verify that
    the CX connectors that we have selected really are the best [1,2] and worst [3,4]:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.10 – Error map showing the best [1,2] and worst [3,4] CX connectors
    for ibmq_santiago](img/Figure_8.10_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 8.10 – Error map showing the best [1,2] and worst [3,4] CX connectors
    for ibmq_santiago
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Two quantum circuits sized for the selected backend are created and displayed.
    These circuits represent the best and the worst CX connections for the backend.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The best Bell circuit for the backend is shown in the next figure:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.11 – A Bell-state circuit for the best performing CX gate'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_8.11_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result of the preceding code will be something like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.13 – A transpiled Bell-state circuit for the best performing CX
    gate'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_8.13_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.13 – A transpiled Bell-state circuit for the best performing CX gate
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As you can see, when we follow the qubit coupling map, our transpiled CX circuit
    looks exactly like the original circuit.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We now run the best and worst circuits on the backend together with a baseline
    execution of the same circuit on the Aer simulator:![Figure 8.14 – The results
    of the best, worst, and benchmark CX gate pairs
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.14_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.14 – The results of the best, worst, and benchmark CX gate pairs
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'And finally, we plot the results in a diagram for comparison:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.15 – The benchmark, best, and worst results on the 5-qubit ibmq_santiago
    backend'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.15_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.15 – The benchmark, best, and worst results on the 5-qubit ibmq_santiago
    backend
  prefs: []
  type: TYPE_NORMAL
- en: You now have a visual view, as well as numerical evidence that the qubits and
    gates on a chip differ in performance.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the results here. We expect the simulated baseline (blue bars)
    to return perfect results for ![](img/Formula_008_007.png) and ![](img/Formula_008_008.png)
    only at the expected 50/50 spread. Note how there are no blue ![](img/Formula_008_012.png)
    and ![](img/Formula_008_013.png) results for the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: On a real machine, the results are affected by qubit errors, as can be seen
    in the red (worst) and green (best) bars, with the IBM backends to return noisy
    results for all combinations ![](img/Formula_008_014.png), with the best qubit
    pair slightly less noisy than the worst pair.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Keep in mind that the results that you see are not just based on the CNOT coupling
    error, but also on qubit errors and read and write errors for your qubits. To
    completely understand the results of runs like these, you need to consider error
    mitigation.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Qiskit Backend Specifications for OpenQASM and OpenPulse Experiments:* [https://arxiv.org/pdf/1809.03452.pdf](https://arxiv.org/pdf/1809.03452.pdf).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Estimating the number of gates you have time for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to the gate errors that we have explored in the first two recipes,
    the end result of your recipes depends on another physical aspect of the qubits
    that we run on: the T1 and T2 times. We first discussed these in the *Explore
    your qubits to understand T1, T2, and errors* recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '**T1**, or **relaxation time**: The T1 value is a statistical value of how
    long it takes for the qubit to spontaneously relax from the "excited" state ![](img/Formula_008_015.png)
    to the ground state ![](img/Formula_008_016.png). In essence, T1 is the upper
    limit, in microseconds, that you have at your disposal to perform high-quality
    actions on the qubit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**T2**, or **dephasing time**: Similar to T1, the T2 value is a statistical
    measure of how phase information is lost for a qubit. An example of phase change
    is when the state ![](img/Formula_008_003.png) spontaneously changes to ![](img/Formula_008_018.png).
    Again, if the running time for your circuit starts to approach the T2 time, the
    quality of your readout data will suffer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this data, we can make a rough estimate of how the size of our programs
    might affect the end result. Not only do we have to take into account the error
    rates for the individual gates but we have to also understand how the T1/T2 times
    limit the number of gates that can actually be run. How many gates can we squeeze
    into our programs before they just return garbage? Let's take a look.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The file required in the following recipe can be downloaded from here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r3_time.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r3_time.py).'
  prefs: []
  type: TYPE_NORMAL
- en: The sample code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we import the class that we need and load our account. In this recipe,
    we combine a lot of important concepts from earlier in the book, such as simulators
    and noise models:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `select_backend()` function lets you select an available backend:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When passed an IBM Quantum® backend name, the `display_information(backend,n_id,ttype)`
    function pulls the T1, T2, readout error, and length of an `id` gate for qubit
    0 of that backend:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `build_circuit(ttype,n_id)` function takes a number and builds a basic circuit
    that includes that amount of Id gates. It starts the circuit with an X gate to
    place the qubit in the ![](img/Formula_008_015.png), or excited state. The purpose
    of the circuit is to wait for a period of time and then measure the qubit, and
    the Id gate is perfect for the job; it doesn't perform any qubit manipulation,
    but still takes a certain amount of time to execute. If we have waited long enough,
    the qubit will spontaneously relax down to the ground state, or ![](img/Formula_008_016.png).
    This will require more or less gates depending on the T1 value for the qubit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Depending on the value of the `ttype` parameter, we will build one of the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`T1`: Set up a simple circuit that puts the qubit in state ![](img/Formula_008_021.png),
    then add a number of Id gates to make time pass, and finally perform the measurement
    of the outcome at different circuit lengths.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`T2`: Similarly, set up a simple circuit that puts the qubit in state ![](img/Formula_008_015.png),
    then in superposition ![](img/Formula_008_003.png) with phase ![](img/Formula_008_024.png).
    Then add a number of Id gates to make time pass, and finally apply another H gate
    and measure. If the qubit is still in ![](img/Formula_008_003.png), it will now
    measure as ![](img/Formula_008_015.png), but if it has spontaneously changed phase,
    approaching ![](img/Formula_008_018.png), it will read as ![](img/Formula_008_016.png)
    with a certain probability:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we run the circuit on a simulator, we use the `build_noisemodel(backend)`
    function to build a noise model for the selected backend. We then use the noise
    model in `execute_circuit()` to simulate running the circuit on the actual backend:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the `execute_circuit(backend, circuit,noise_model, n_id)` function, we
    run the circuit on a simulated version of the selected backend by using the noise
    model we created in `build_noisemodel()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `main` function can be broken up into a set of processes, starting with
    the input and information section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With all input, noise model, and initial circuit creation taken care of, we
    can now run the circuit on a pure simulator and then on the selected backend,
    either simulated or on IBM Quantum®. We store our results in an `entry` dictionary,
    and the lengths of the executed circuits in a `legend` array, then use them to
    present the results:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we merge the results from the results dictionary into a `results_array`
    array, matching the lengths from the `legend` array, then display all the results
    in a combined diagram:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To explore how a qubit relaxes from the excited ![](img/Formula_06_023.png)
    state to the ground state ![](img/Formula_06_0221.png), follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In your Python environment, run `ch8_r3_time.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The script loads Qiskit® and grabs and displays a list of the available backends.
    Enter the name of a backend that you want to test on, then enter `S` to run on
    a noise-simulated version of the backend. Finally, enter the number of Id gates
    that you want to include in your circuit, for example, `1024`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.16 – Select a backend, whether to run on the actual backend, and
    enter a number of Id gates'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_8.16_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.16 – Select a backend, whether to run on the actual backend, and enter
    a number of Id gates
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Various pieces of data for the first qubit of the selected backend are displayed.
    We are particularly interested in the T1 value and the Id gate length. From these,
    we can estimate how long our circuit will take to run, and the percentage of the
    T1 time that will be consumed. We are not particularly concerned about gate errors;
    the Id gate does not do any qubit manipulation but is really only a delay gate:![Figure
    8.17 – The backend data
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.17_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.17 – The backend data
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We also display a representative sample circuit with five Id gates. Your actual
    circuit will be much, much bigger, but with the same architecture; a long string
    of barriers and Id gates:![Figure 8.18 – Sample Id-circuit
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.18_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.18 – Sample Id-circuit
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The circuit now runs, first on the build in the Qiskit Aer `qasm_simulator`
    for a clean result, then on the simulated or actual backend. It starts with a
    circuit with the selected number of Id gates, and then runs successively shorter
    circuits until it reaches a circuit with just one Id gate:![Figure 8.19 – Raw
    T1 results on the simulated ibmq_valencia backend
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.19_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.19 – Raw T1 results on the simulated ibmq_valencia backend
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, it collects and displays the results of all the runs in one diagram:![Figure
    8.20 – T1 results on the simulated ibmq_valencia backend
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.20_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.20 – T1 results on the simulated ibmq_valencia backend
  prefs: []
  type: TYPE_NORMAL
- en: Alright, so what do these results mean? Let's take a look…
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the probability of getting the result ![](img/Formula_06_023.png)
    gets lower and lower as the number of gates increases. At 1,024 gates, we are
    down to roughly 70%, which is pretty close to just noise. Try doubling the number
    of gates to 2,048 and see if the curve lands you somewhere close to 50% or so.
    So, where do you need to be to have a stab at actually getting good results from
    your circuits? Take a look at *Figure 8.20* again – this time, at the 1 Id gate
    circuit end. The probability of getting the result ![](img/Formula_06_139.png)
    hovers around 93-95%, and a bit of the uncertainty here comes from the readout
    error, which in our case was around 3.5%. This hints at a max circuit length of
    around 64 Id gates before things start to go wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Also remember that this measurement only takes into account the T1 relaxation
    time, and only really measures the performance of the qubit at various circuit
    lengths, only using Id gates, which are not really useful for building actual
    quantum circuits.
  prefs: []
  type: TYPE_NORMAL
- en: For actual, useful circuits, we also need to take into account other factors
    such as gate errors, transpiling architecture, and more. This means that you cannot
    just extrapolate the circuit count you deem OK quality-wise from this experiment
    and set that as your gate limit for a backend. Take a look back at the *Comparing
    the Qiskit Aer simulator with an IBM quantum computer* recipe in [*Chapter 7*](B14436_07_Final_PG_ePub.xhtml#_idTextAnchor197),
    *Simulating Quantum Computers with Aer*, for a rudimentary example of what gate
    errors can do in long circuits.
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After this first run-through, you can test a couple of other scenarios, as discussed
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing backends
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Try running identical circuits on different backends to see how the results
    differ. IBM Quantum® is hard at work—developing better and better qubits and control
    circuitry and you can see how progressively newer backends generally have longer
    T1/T2 times, and better performing qubits. You can estimate how old a backend
    is by looking at the **online since** dates in *Figure 8.21*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, for example, are the results of the 1,024 Id gate circuit on the `ibmqx2`
    backend, which came online in January 2017\. Compare these to the `ibmq_valencia`
    results that we just obtained. That backend has been online since July 2019:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.21 – Results on ibmqx2, an older backend with a shorter T1'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.21_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.21 – Results on ibmqx2, an older backend with a shorter T1
  prefs: []
  type: TYPE_NORMAL
- en: By comparing the data in *Figure 8.20* (`ibmq_valencia`) with the data in *Figure
    8.21* (`ibmqx2`), you can see that the T1 time is more than twice as long for
    the newer `ibmq_valencia` backend and that the probability of getting the correct
    result after 1,024 Id gates is much higher (70% versus 46%).
  prefs: []
  type: TYPE_NORMAL
- en: Running on an IBM Quantum® backend
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, test running the same test on the actual backend by running the sample
    script `ch8_r3_time.py` again and entering `Q` when prompted.
  prefs: []
  type: TYPE_NORMAL
- en: Pick a suitable backend
  prefs: []
  type: TYPE_NORMAL
- en: As we will be running about half a dozen individual jobs or so, the complete
    run might take some time depending on the number of users that are running jobs
    on the backend. Before you pick a backend to run on, check the **pending jobs**
    number for the backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'When running on the actual backend, the job monitor provides information about
    your place in the queue. For the backend `ibmq_valencia`, this might give the
    following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.22 – Raw T1 results on the ibmq_valencia backend'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.22_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.22 – Raw T1 results on the ibmq_valencia backend
  prefs: []
  type: TYPE_NORMAL
- en: 'Plotted side by side, you get a visual comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.23 – T1 results on the ibmq_valencia backend'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.23_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.23 – T1 results on the ibmq_valencia backend
  prefs: []
  type: TYPE_NORMAL
- en: See how the qubit relaxes from ![](img/Formula_008_033.png) as the number of
    Id gates increases, and thus the *wait* time gets longer. Note how the actual
    backend results match the simulated results pretty well.
  prefs: []
  type: TYPE_NORMAL
- en: Testing T2 dephasing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also test the T2 value – how your qubit dephases – by changing the
    type parameter from `"T1"` to `"T2"` in the sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'How is the sample circuit different in this case? As the T2 time measures dephasing,
    we must first set up our qubit to actually have phase information. We start off
    our circuit with an X gate, putting our qubit in the ![](img/Formula_06_023.png)
    state. We then add an H gate, which brings the qubit to the ![](img/Formula_008_035.png)
    state, which is the same as the ![](img/Formula_008_036.png) state phase-shifted
    by ![](img/Formula_008_037.png) radians:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.24 – The T2 circuit includes H gates to place our qubit in the  state,
    with a  phase](img/Figure_8.24_B14436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.24 – The T2 circuit includes H gates to place our qubit in the ![](img/Formula_008_035.png)
    state, with a ![](img/Formula_008_039.png) phase
  prefs: []
  type: TYPE_NORMAL
- en: 'We then let time pass, giving the qubit the opportunity to dephase a bit from
    the initial ![](img/Formula_008_040.png) phase, before adding another H gate to
    bring us back to the computational basis so that we can measure the qubit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.25 – T2 results on the ibmqx2 backend'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.25_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.25 – T2 results on the ibmqx2 backend
  prefs: []
  type: TYPE_NORMAL
- en: By looking at *Figure 8.25* and *Figure 8.21*, you can now get a complete picture
    of the T1 and T2 impact on your qubit. Try running with even more Id gates to
    see how the behavior changes.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a much more detailed description of T1 and T2 and how to measure it, take
    a look at *Learn Quantum Computing with Python and IBM Quantum Experience*, *Chapter
    11*, *Mitigating Quantum Errors Using Ignis*, by Robert Loredo, Packt, 2020.
  prefs: []
  type: TYPE_NORMAL
- en: Correcting for the expected with readout correction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have some knowledge about what might go wrong when we use our qubits
    for quantum calculations, is there anything that we can do about it? There are
    essentially two approaches here, at least for the small quantum backends that
    we have at our disposal.
  prefs: []
  type: TYPE_NORMAL
- en: First, we can make sure that the quantum programs that we run have a fighting
    chance of completing before the qubits get lost due to decoherence, the T1 and
    T2 times that we explored. This means that we make the programs short.
  prefs: []
  type: TYPE_NORMAL
- en: Second, we can take a good look at various readout errors and see if we can
    mitigate those. If you remember in [*Chapter 7*](B14436_07_Final_PG_ePub.xhtml#_idTextAnchor197),
    *Simulating Quantum Computers with Aer*, we could pull in actual backend qubit
    data to `qasm_simulator` and have it behave like an NISQ backend. We can do the
    same in reverse, analyze the measurement errors for a backend, and use that data
    to create a mitigation map to counteract erroneous measurements.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The sample code for this recipe can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r4_ignis.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r4_ignis.py).'
  prefs: []
  type: TYPE_NORMAL
- en: The sample code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To handle the creation and running of the readout correction, we build a number
    of functions in the `ch8_r4_ignis.py` script:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import the classes and methods that we need. You can import Qiskit®
    and load the account by running the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using `select_backend()`, we load and display the data for the available backends,
    and then prompt to select one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using `create_circuit()`, we create a basic GHZ-state circuit for which we
    know the expected outcomes – ![](img/Formula_008_041.png):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`simulator_results(circuit)` runs the provided circuit on the local Qiskit
    Aer simulator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`noisy_results(circuit,backend)` runs the provided circuit on the provided
    backend:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This `mitigated_results(backend,circuit,results)` function is the main function
    we build to run error mitigation on the provided results, based on backend measurement
    error data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And finally, the `main()` function helps in wrapping up the function flow and
    final data presentation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In your local Qiskit® environment, run the `ch8_r4_ignis.py` sample, then select
    one of the available backends to test on:![Figure 8.26 – Select an available backend
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.26_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.26 – Select an available backend
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We'll now build the GHZ-state circuit that we will be testing with. We know
    that the expected outcomes are ![](img/Formula_008_043.png), and can use that
    information to validate how well our circuit runs on the selected backend, and
    how well we can error correct:![Figure 8.27 – The GHZ-state circuit that we will
    test with
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.27_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.27 – The GHZ-state circuit that we will test with
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The script now runs the circuit on a local simulator and on the selected backend:![Figure
    8.28 – Results on the local qasm_simulator and on the ibmqx2 backend
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.28_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.28 – Results on the local qasm_simulator and on the ibmqx2 backend
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the results of the circuit when run on the backend, we can
    pull in the actual qubit and gate data from the backend and build a noise model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The model includes statistics on the measurement behavior for the backend''s
    qubits:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.29 – Calibration matrix with the expected results and the statistical
    measurement errors'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_8.29_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.29 – Calibration matrix with the expected results and the statistical
    measurement errors
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In *Figure 8.29*, you can see the expected results in the diagonal, and the
    statistical measurement errors as gray shading away from the diagonal. The darker
    the shading, the higher the probability of getting that result.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can use this data to rerun the circuit on the local simulator, with the
    measurement calibration data as input. We can then run the original results through
    a measurement filter and get the mitigated results as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.30 – The mitigated results for ibmq_16_melbourne'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_8.30_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.30 – The mitigated results for ibmq_16_melbourne
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we can plot the simulator results, the original backend results, and
    the mitigated results for comparison:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.31 – A comparison of results for simulator, backend, and mitigated
    backend'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.31_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.31 – A comparison of results for simulator, backend, and mitigated
    backend
  prefs: []
  type: TYPE_NORMAL
- en: From the final chart, you can see that the expected results for a GHZ-state
    circuit, ![](img/Formula_008_042.png) with roughly a 50/50 chance, is not what
    we get on the backend. There are a large number of noisy bars between the expected
    results. With the error mitigation, we shrink these bars and bring the results
    closer to the expected.
  prefs: []
  type: TYPE_NORMAL
- en: Mitigating the unexpected with quantum error correction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in the previous recipe, it is good to understand how your measurements
    behave, to statistically be able to correct incorrect readouts. But in the end,
    a measurement is just a measurement, and a measurement of a qubit will result
    in either 0 or 1\. If the state of the qubit that you measure turns out to be
    ![](img/Formula_06_058.png) instead of the expected ![](img/Formula_008_045.png),
    it doesn't matter that you statistically corrected for measurement mistakes; your
    qubit is off by 100%.
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of things that can perturb our qubits, from gate errors to just
    plain physics that causes the qubit to decohere and dephase (remember the T1 and
    T2 times). In the classical computing world, we can periodically check in on our
    bits, and apply error correction coding to make sure that they behave. Digital
    error correction is one of the reasons that digital communication works and that
    you can play digital media, CDs, DVDs, and Blu-ray disks and actually hear or
    see what you expect.
  prefs: []
  type: TYPE_NORMAL
- en: One way of performing classical error correction is to duplicate one bit that
    you want to transfer into three bits, and at the end compare the bit with its
    duplicated brethren. If they are different, then at least one of the bits has
    been *errored*. Very simply put, you can then take a majority vote and flip the
    offending bit, and thus get the original back.
  prefs: []
  type: TYPE_NORMAL
- en: For qubits, it is not so simple. For one, you cannot make copies of qubits like
    you can for classical bits. Instead, we have to make use of **superposition**
    and **entanglement**.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed superposition at length in the *Comparing a bit and a qubit* recipe
    of [*Chapter 2*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045), *Quantum Computing
    and Qubits with Python*, and entanglement in the *Quantum-cheating in a coin toss?
    – Introducing the Bell State* recipe of [*Chapter 4*](B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081),
    *Starting at the Ground Level with Terra*. Feel free to go back for a refresher.
  prefs: []
  type: TYPE_NORMAL
- en: Let's use these tools to explore further... Read on!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The sample code for this recipe can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r5_shor.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r5_shor.py).'
  prefs: []
  type: TYPE_NORMAL
- en: The sample code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To handle the creation and running of the Shor code algorithm, we will build
    a number of functions in the `ch8_r5_shor.py` script:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import the methods that we need and set the backend:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `get_psi(qc)` function is an old friend that we are reusing to return the
    state vector of the circuit, to display Bloch spheres and Q-spheres:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Instead of expecting the first qubit errors to occur naturally, we use the
    `add_error(error, circuit,ry_error, rz_error)` function to create four different
    types of errors – **Bit flip**, **Bit flip + phase flip**, **Theta + phi shift**,
    and **Random**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `not_corrected(error, ry_error, rz_error)` function creates a simple 1-qubit
    circuit and introduces the error that we select in the main process, then displays
    the results as a Bloch sphere and a Q-sphere. We also run the circuit on the Qiskit
    Aer `qasm_simulator` to see the results of our contaminated qubit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now it is time to add the quantum correction code that Peter Shor developed.
    We are building the same circuit as before, but with 8 `add_error()` function.
    This simulates real-world perturbance of the qubit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**The end of the bit-flip correction**: After the errors have been introduced,
    we now start collecting our qubits again, starting with wrapping up the bit-flip
    correction and adjusting each of the phase-shift qubits if needed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**The end of the phase-flip correction**: And similar to the bit flip wrapping
    up, we now close the phase-flip correction, applying any necessary correction
    to the first qubit:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Measure and print**: We can now measure the qubit and print the result:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The program prompts for a numeric input to select the error to introduce, and
    then runs the `not_corrected()` and `shor_corrected()` functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code we have built here can now be run, simulating the quantum error correction
    of any phase and the bit perturbation of the qubit.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take the Shor code for a spin:'
  prefs: []
  type: TYPE_NORMAL
- en: In your Python environment, run `ch8_r5_shor.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When prompted, enter the error type for a bit flip: `1`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The error-free qubit is displayed:![Figure 8.32 – The qubit with no error, in
    state
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.32_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.32 – The qubit with no error, in state ![](img/Formula_008_052.png)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, the selected error is added, and the results are displayed. The qubit
    has now flipped from ![](img/Formula_008_053.png):![Figure 8.33 – The qubit with
    the selected bit-flip error, turning the qubit from
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.33_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.33 – The qubit with the selected bit-flip error, turning the qubit
    from ![](img/Formula_008_054.png)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, press *Enter* to create a new circuit and display the undisturbed qubit
    with its 8 ancilla qubits. The Q-sphere displays the possible outcomes of this
    new unperturbed circuit, all 9 qubits in ![](img/Formula_06_057.png):![Figure
    8.34 – Undisturbed qubit with 8 ancilla qubits
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.34_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.34 – Undisturbed qubit with 8 ancilla qubits
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We now start the Shor code creation and add the simulated error. The Q-sphere
    now shows a number of possible outcomes as qubits 0, 3, and 6 are now in a superposition,
    giving a probabilistic outcome for those qubits, and for their entangled counterparts.
    Notice that qubit 0 can now appear as both ![](img/Formula_008_056.png):![Figure
    8.35 – Qubit with added bit-flip error, turning the qubit from
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.35_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.35 – Qubit with added bit-flip error, turning the qubit from ![](img/Formula_008_0541.png)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we complete the Shor code, display the expected outcomes for the circuit,
    and then run it on the Aer `qasm_simulator`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.36 – Result of the error-corrected qubit, back at  again](img/Figure_8.36_B14436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.36 – Result of the error-corrected qubit, back at ![](img/Formula_008_052.png)
    again
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the Q-sphere and the results count. The state vector has safely
    put our qubit back at ![](img/Formula_008_059.png) again; note how the least-significant
    bit that represents the first qubit is now ![](img/Formula_008_060.png). The result
    also points to our qubit being safely error-corrected, with a 100% chance of 0.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s a short explanation of how qubit error correction works. We first create
    what is called a **syndrome** by entangling our qubit with two other ancilla qubits.
    The entangled qubits now walk through life as one entity, indistinguishable from
    each other with one exception: errors to the qubits are not entangled, but unique
    to each qubit.'
  prefs: []
  type: TYPE_NORMAL
- en: Before using our qubit for anything, we first disentangle it from the other
    2 qubits; it is now a standalone qubit again. Now it is time to use the **syndrome**
    to correct any errors.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we set up a Toffoli (**CCX**) gate from our two syndrome qubits
    to our qubit of interest. If the syndrome qubits differ from our original qubit,
    that is, our qubit has been disturbed, the CCX flips the qubit right again.
  prefs: []
  type: TYPE_NORMAL
- en: That's it. Simple, eh? Well, let's take a closer look.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two methods we can use, for two different qubit errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bit-flip correction**: Correcting flipped qubits, from ![](img/Formula_008_061.png)
    and vice versa'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Phase-flip**: Correcting flipped phases, from ![](img/Formula_008_062.png)
    and vice versa'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bit-flip correction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the bit correction method, we set up a GHZ-state entangled circuit, using
    the first qubit as the controller for a CXX gate (or two CX gates in this case),
    where two additional ancilla qubits are used as the error correction syndrome
    only and are not used in the final measurement:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the first qubit is ![](img/Formula_008_063.png), we now have the following
    state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Formula_008_064.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: If it is ![](img/Formula_008_065.png), we now have ![](img/Formula_008_066.png)
    – nothing new there.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After setting up the initial qubit and its ancillas, we let the world act on
    the first qubit, potentially introducing bit-flip errors, sending our ![](img/Formula_008_067.png),
    for example, to ![](img/Formula_008_068.png).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the diagram that follows, this is represented by the two barriers between
    the two sets of CX gates.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Our 3 qubits might now be in the following two states:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Formula_008_069.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'We then run a second GHZ-entanglement to disentangle the first qubit, and end
    up with the following states:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Formula_008_070.png), nothing changes as the first qubit is now ![](img/Formula_008_071.png),
    and ![](img/Formula_008_072.png) if the first qubit is ![](img/Formula_008_073.png).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At this point, we add a supremely clever piece of coding by adding a Toffoli
    gate, with the two syndrome qubits as controllers, and the first qubit as the
    controlled qubit. What happens?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Formula_008_074.png) turns into ![](img/Formula_008_075.png), and ![](img/Formula_008_076.png)
    into ![](img/Formula_008_074.png), and like magic, our first qubit has returned
    to its original state of ![](img/Formula_008_078.png):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.37 – The bit-flip quantum correction circuit](img/Figure_8.37_B14436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.37 – The bit-flip quantum correction circuit
  prefs: []
  type: TYPE_NORMAL
- en: Phase-flip correction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'But a qubit also differs from a classical bit by one critical aspect: in addition
    to 0 and 1, a qubit can also have a phase value, and thus also phase errors. Can
    we error correct for that? Turns out that we can, with basically the same method,
    with yet another clever twist:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Like before, we start out with our 3 qubits, and our GHZ-state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Formula_008_079.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The next step is to transform our measurement basis state into a state where
    we can work with phase information, by adding a Hadamard gate to each qubit. We
    now have the following two states instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Formula_008_080.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Again, we let nature act on the first qubit, potentially ending up with a phase-shifted
    first qubit, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Formula_008_081.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: In the diagram that follows, the error occurs between the two barriers between
    the H gates.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Like in the bit-flip example, we now apply the Hadamard gate and the GHZ-creating
    CXX gates again, and now end up with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Formula_008_082.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![](img/Formula_008_083.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'And finally, the Toffoli (CCX) gate turns the qubit trio into the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Formula_008_084.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Again, our first qubit has returned to its original state of ![](img/Formula_008_085.png)
    and ![](img/Formula_008_086.png):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.38 – The phase-flip quantum correction circuit'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.38_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.38 – The phase-flip quantum correction circuit
  prefs: []
  type: TYPE_NORMAL
- en: Shor code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'That is all great; we can tackle bit-flip errors as well as phase-flip errors.
    But what if both types of errors occur? After all, qubits are physical entities,
    and who really knows how they will behave? It turns out that we can do that as
    well. Peter Shor, of Shor''s algorithm fame (see [*Chapter 10*](B14436_10_Final_PG_ePub.xhtml#_idTextAnchor271),
    *Getting to Know Algorithms with Aqua*) invented the Shor code, which is a combination
    of the phase-flip and bit-flip methods using 9 qubits in total. The first qubit
    is the one we want to do quantum error correction on, and the eight following
    are the ancillas, only used for working the correction magic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.39 – The Shor code circuit'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.39_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.39 – The Shor code circuit
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a quick description, but do take a look at *Figure 8.39*:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up the first half of the phase-flip circuit using qubits 0, 3, and 6.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the first half of three bit-flip circuits for qubits 0, 3, and 6.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave some room for nature and the error to happen to qubit 0\. The two barriers
    between the triplicate CX gate sets below.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the second half of three bit-flip circuits for qubits 0, 3, and 6, effectively
    correcting any bit flips on these 3 qubits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the second half of the phase-flip circuit for qubits 0, 3, and 6, correcting
    any phase shifts for these three qubits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Measure qubit 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now the math turns somewhat complicated, with Ket-representations for 9 qubits
    looking like this, for example: |011000101![](img/Formula_008_090.png). Not to
    mention what unitary matrices for 9-qubit circuits look like.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first example that we ran, a simple bit-flip error, didn't really make use
    of the full power of the Shor code. Try some of the other options to simulate
    any type of conceivable error that might occur, from the simple to the very complex.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following options are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bit flip**: This error flips the bit upside-down, from ![](img/Formula_008_087.png).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bit flip plus phase flip**: A combined bit and phase flip.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Theta plus phi shift**: Create your own error by entering the theta ![](img/Formula_008_088.png)
    and phi ![](img/Formula_008_089.png) angles to point your state vector at any
    point on the Bloch sphere. If you need a reminder about what these two angles
    represent, take a quick look at the *Visualizing a qubit in Python* recipe in
    [*Chapter 2*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045), *Quantum Computing
    and Qubits with Python*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Random**: A random error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Quantum Error Correction for Beginners*, Simon J. Devitt, William J. Munro,
    and Kae Nemoto, June 24, 2013, [https://arxiv.org/pdf/0905.2794.pdf](https://arxiv.org/pdf/0905.2794.pdf
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Quantum Computation and Quantum Information* by Isaac L. Chuang; Michael A.
    Nielsen, Cambridge University Press, 2010, Chapter 10.2 Shor code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
