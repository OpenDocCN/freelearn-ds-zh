- en: '*Chapter 8*: Cleaning Up Your Quantum Act with Ignis'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*: 使用Ignis清理你的量子行为'
- en: We have explored running our quantum programs on idealized Qiskit Aer simulators
    and gotten our hands dirty with the actual IBM Quantum machines. We understand
    that real qubits are noisy and that we cannot expect quantum computers to solve
    actual real-world problems of any significant magnitude (yet). On the path to
    this future application lies ﬁghting and mitigating noise and errors, and on that
    path lies Qiskit Ignis.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探索了在理想化的Qiskit Aer模拟器上运行我们的量子程序，并且在实际的IBM Quantum机器上亲自动手。我们明白真实的量子位是有噪声的，我们无法期望量子计算机能够解决任何具有重大实际意义的现实世界问题（至少目前还不能）。通往这一未来应用的途径在于对抗和减轻噪声和错误，而Qiskit
    Ignis就在这条道路上。
- en: Qiskit® includes a lot of automation, such as the optimization of the assigned
    qubits according to connectivity and performance; but this automation is, to an
    extent, limited by the physical layout of a quantum chip, which controls how the
    qubits can communicate with each other. By studying the qubit performance and
    specifying which actual physical qubits you want to use with your quantum programs,
    you can optimize your circuits for optimal entanglement and decoherence, to name
    a few examples.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Qiskit® 包含了许多自动化功能，例如根据连接性和性能优化分配的量子位；但这种自动化在一定程度上受到量子芯片物理布局的限制，这决定了量子位如何相互通信。通过研究量子位性能并指定你想要与你的量子程序一起使用的实际物理量子位，你可以优化你的电路以实现最佳纠缠和去相干，仅举几个例子。
- en: In this chapter, we will explore how running your programs on different sets
    of qubits on the same backend might cause you to end up with different results.
    We will also use the Qiskit Ignis methods to do readout correction on our simpler
    algorithms on simulated and existing hardware.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨在相同后端的不同量子位集上运行你的程序可能会如何导致你得到不同的结果。我们还将使用Qiskit Ignis方法对我们的简单算法在模拟和现有硬件上进行读出校正。
- en: Finally, we will take a look at quantum error correction using the Shor code,
    seeing how you can create a single logical qubit by using several physical qubits
    for quantum error correction.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将探讨使用Shor码进行量子纠错，看看你如何可以通过使用多个物理量子位进行量子纠错来创建一个单独的逻辑量子位。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Exploring your qubits to understand T1, T2, errors, and gates
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索你的量子位以了解T1、T2、错误和门
- en: Comparing the qubits on a chip
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较芯片上的量子位
- en: Estimating the number of gates you have time for
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 估算你有多少时间可以用于门操作
- en: Correcting the expected with readout correction
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用读出校正来纠正预期结果
- en: Mitigating the unexpected with quantum error correction
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用量子纠错来减轻意外情况
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The quantum programs that we''ll discuss in this chapter can be found here:
    [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter08](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter08).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将讨论的量子程序可以在这里找到：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter08](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter08).
- en: Exploring your qubits to understand T1, T2, errors, and gates
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索你的量子位以了解T1、T2、错误和门
- en: 'Let''s start off with a quick overview of some things that can go wrong when
    you send your perfectly working and simulator-verified quantum program to an actual,
    physical quantum computer. As we have seen, as soon as we step away from our perfect
    simulated qubits and start using physical qubits that work quantum-mechanically,
    we also have to contend with another physical feature of reality: noise.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些快速概述开始，这些概述了当你将完美工作且经过模拟器验证的量子程序发送到实际的物理量子计算机时可能会出错的事情。正如我们所见，当我们离开完美的模拟量子位并开始使用在量子力学上工作的物理量子位时，我们也必须应对现实世界的另一个物理特性：噪声。
- en: In a quantum computer, the noise differs between backends, between qubits on
    a backend, between different types of gates, and between the readouts of each
    qubit. Building and programming quantum computers really is a complex task.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在量子计算机中，噪声在各个后端之间、后端上的量子位之间、不同类型的门之间以及每个量子位的读出之间都存在差异。构建和编程量子计算机确实是一项复杂的任务。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The file required for this recipe can be downloaded from here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r1_gates_data.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r1_gates_data.py).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: This recipe builds on the work we did in [*Chapter 5*](B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128),
    *Touring the IBM Quantum® Hardware with Qiskit® Tools*, but this time we are specifically
    looking at the qubit properties that hint at the many ways that things can go
    wrong.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using the `backend.properties()` Qiskit® method to pull out the
    following properties for qubits:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '`t1()`: The T1 or relaxation time for the given qubit'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`t2()`: The T2 or dephasing time for the given qubit'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readout_error()`: The risk of misreading the qubit during measurement'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gate_length()`: The duration of the gate in units of seconds'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gate_error()`: The gate error estimate'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sample code
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we import the class that we need and load our account:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We use `select_backend()` here to load and display the data for the available
    backends, and then prompt to select one:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `display_information(backend)` function retrieves the backend information
    such as the number of qubits and the qubit coupling map, and then uses that to
    cycle through the backend's qubits to retrieve the T1, T1, readout error, and
    gate information. The function comprises two parts.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we gather the qubit information:'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, we print out the basic qubit information and the qubit-specific information
    for each gate:'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The main function calls the `select_backend()` and `display_information(backend)`
    functions to help you see all the qubit information for a selected backend:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How to do it...
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To explore the qubit properties of a specific backend, follow these steps:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: In your Python environment, run `ch8_r1_gates_data.py`.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The script loads Qiskit® and grabs and displays a list of the available backends
    as shown here:'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Select a backend to investigate'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_8.1_B14436.jpg)'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.1 – Select a backend to investigate
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When prompted, enter the name of the IBM Quantum® backend that you want to
    take a look at:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We now pull in `backend.properties()` for the selected backend, and from these,
    sift through and display the following parameters: qubit readout error, T1 and
    T2 decoherence times, gate length, and error for all the basis gates for the backend.'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Qubit data for the ibmq_vigo 5-qubit backend'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_8.2_B14436.jpg)'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.2 – Qubit data for the ibmq_vigo 5-qubit backend
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: That is a fair bit of data, but it only represents a small piece of the data
    that can be collected for a specific backend. For a refresher, see the *Exploring
    a selected backend using Qiskit®* recipe in [*Chapter 5*](B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128),
    *Touring the IBM Quantum® Hardware with Qiskit® Tools*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'The first pieces of data that we will touch on are the **T1** and **T2** times
    and the **readout error**:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的第一部分数据是 **T1** 和 **T2** 时间以及 **读取错误**：
- en: '![Figure 8.3 – Data for qubit 0'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.3 – qubit 0 的数据'
- en: '](img/Figure_8.3_B14436.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.3_B14436.jpg)'
- en: Figure 8.3 – Data for qubit 0
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – qubit 0 的数据
- en: 'This first set of data represents the physical reasons that you might not get
    the results that you expect when you run your quantum code on the backend:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这组数据首先代表了当你在后端运行量子代码时，可能得不到预期结果的一些物理原因：
- en: '**T1**, **or relaxation** **time**: The T1 value, displayed as ![](img/Formula_008_100.png)
    in *Figure 8.3,* is a statistical value of how long it takes for the qubit to
    spontaneously relax from the "excited" state ![](img/Formula_008_001.png) to the
    ground state ![](img/Formula_008_002.png). In essence, T1 is an estimate of the
    time that you have at your disposal to perform high-quality actions on the qubit.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**T1**，或**弛豫** **时间**：T1 值，如图 8.3 中所示，以 ![](img/Formula_008_100.png) 形式展示，是量子位从“激发”状态
    ![](img/Formula_008_001.png) 自发弛豫到基态 ![](img/Formula_008_002.png) 所需时间的统计值。本质上，T1
    是对你在量子位上执行高质量操作可利用时间的估计。'
- en: '**T2**, **or** **dephasing** **time:** Similar to T1, the T2 value, displayed
    as *ms* in *Figure 8.3,* is a measure of how phase information is lost for a qubit.
    An example of phase change is when the state ![](img/Formula_008_003.png) spontaneously
    changes to ![](img/Formula_008_004.png). Again, if the running time for your circuit
    starts to approach the T2 time, the quality of your readout data will suffer.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**T2**，或**去相位** **时间**：与 T1 类似，T2 值，如图 8.3 中以 *ms* 形式展示，是量子位相位信息丢失的度量。相位变化的一个例子是当状态
    ![](img/Formula_008_003.png) 自发变为 ![](img/Formula_008_004.png)。同样，如果你的电路运行时间开始接近
    T2 时间，你的读取数据质量将受到影响。'
- en: 'Now for the rest of the data that we pulled in:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下我们收集到的其他数据：
- en: '![Figure 8.4 – Data for qubit 0'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.4 – qubit 0 的数据'
- en: '](img/Figure_8.4_B14436.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.4_B14436.jpg)'
- en: Figure 8.4 – Data for qubit 0
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – qubit 0 的数据
- en: '`readout_error`, `gate_length`, and `gate_error` represent the quality of the
    gates that you can run on each qubit.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`readout_error`、`gate_length` 和 `gate_error` 代表了你可以运行在每个量子位上的门的质量。'
- en: '`readout_error`: The readout error rate, displayed as a percentage in *Figure
    8.4*, is simply the probability that you will get the incorrect value when reading
    the qubit. For example, a qubit in state ![](img/Formula_06_0221.png) will be
    read as ![](img/Formula_06_023.png) and vice versa. This really has nothing to
    do with any other qubit manipulations but is simply the error rate for the final
    readout of the collapsed qubit. It is possible to get a statistical picture of
    each qubit and mitigate these readout errors. We will do that in the *Correct
    the expected with readout correction* recipe.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readout_error`：读取错误率，如图 8.4 中以百分比形式展示，是你在读取量子位时得到错误值的概率。例如，处于状态 ![](img/Formula_06_0221.png)
    的量子位将被读取为 ![](img/Formula_06_023.png)，反之亦然。这实际上与任何其他量子位操作无关，只是最终读取坍缩量子位的错误率。我们可以对每个量子位得到一个统计图像，并减轻这些读取错误。我们将在“使用读取校正修正预期”菜谱中这样做。'
- en: '`gate_length`: The gate length, displayed as *![](img/Formula_008_100.png)*
    in *Figure 8.4*, represents the time it takes to make the adjustment to the qubit
    that corresponds to the gate. If you look at the data returned, you see that the
    gate length for a U3 gate might be in the order of a twentieth of a microsecond
    or so, whereas the T1/T2 times might be much longer than that. This, however,
    doesn''t mean that you can just add hundreds or thousands of these gates within
    that time span and expect the results to be great. This is where gate errors come
    in.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gate_length`：门长度，如图 8.4 中以 *![](img/Formula_008_100.png)* 形式展示，代表调整与门相对应的量子位所需的时间。如果你查看返回的数据，你会看到
    U3 门的长度的量级可能是一个微秒的二十分之一左右，而 T1/T2 时间可能比这长得多。然而，这并不意味着你可以在那个时间段内添加数百或数千个这样的门并期望结果会很好。这就是门错误出现的地方。'
- en: '`gate_error`: The gate error, displayed as a percentage in *Figure 8.4*, is
    a statistical value for how accurate the gate is at executing the expected results.
    As you can see, the errors range from 0.05% to a few percent. For short circuits
    of just a few gates, we can run the circuit many times and statistically derive
    the correct values even with gate errors popping up. For longer circuits, of hundreds
    or thousands of gates, even these small gate errors start to make an impact. In
    [*Chapter 9*](B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246), *Grover''s Search
    Algorithm*, you will build quantum circuits with hundreds of gates.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Remember from the *What are the IBM Quantum® machines?* recipe in [*Chapter
    5*](B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128), *Touring the IBM Quantum®
    Hardware with Qiskit®*, that the gates are not physical things like the bundles
    of transistors that make up the gates in classical computing. Instead, quantum
    gate logic constitutes a series of microwave pulses that are sent down to and
    interact with the cryogenically chilled qubits. The quality of gates thus hinges
    on quite a few things: the physical properties of the **Josephson junction** and
    resonator circuit that constitute the physical qubit, the accuracy of the carrier
    wave and gate-coded wave package, the microwave resonators, the cryostats, and
    much more.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can also get to the backend qubit data from IBM Quantum Experience®.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Log in to IBM Quantum Experience® at [https://quantum-computing.ibm.com](https://quantum-computing.ibm.com).
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Welcome** page, on the right side, you'll see a list of the available
    backends:![Figure 8.5 – The IBM Quantum Experience® home page
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_3.1_B14436.jpg)'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.5 – The IBM Quantum Experience® home page
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the backend that you are interested in, for example, `ibmq_vigo`, to
    see the chip layout and additional information:![Figure 8.6 – Details of the ibmq_vigo
    backend
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.6_B14436.jpg)'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.6 – Details of the ibmq_vigo backend
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Click **Download Calibrations** for a CSV file with the qubit information.
    The downloaded calibration data looks as shown in the following screenshot:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.7 – Downloaded calibration data from IBM Quantum Experience®'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.7_B14436.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.7 – Downloaded calibration data from IBM Quantum Experience®
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: You can now bring the data into your favorite spreadsheet software for further
    processing as needed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Comparing the qubits on a chip
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we looked at some of the pieces of information that
    you can glean about the IBM Quantum® hardware, illustrating the nature of today's
    NISQ machines. In this recipe, we will show a real comparison between the different
    qubits of a selected IBM backend.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'We will run the same Bell state quantum program on three different setups:
    an ideal quantum computer (`qasm_simulator`), the best qubit pair, and the worst
    qubit pair on a 5-qubit, least busy IBM Quantum® machine.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: We will print and plot the end result to compare the ideal result (![](img/Formula_008_007.png)
    and ![](img/Formula_008_008.png) at 50%) with the real results (a probabilistic
    mix of ![](img/Formula_008_009.png)) to illustrate how today's quantum computers
    still have a little way to go.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The file required in the following recipe can be downloaded from here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r2_compare_qubits.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r2_compare_qubits.py)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: The sample code
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we import the classes and methods that we need and load our account.
    In this recipe, we combine a lot of important concepts from earlier in the book,
    such as simulators and noise models:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `select_backend()` function lets you select an available backend. You can
    also have the system pick the least busy one:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Pull out the best and worst CX gate performance information, then cycle through
    the CX gate couplings to find the best and worst performing connection, before
    returning this information as a `cx_best_worst` list for later usage. We can now
    take a look at the best and worst performing CX gate information that we stored.
    To verify that we have collected the correct information, we can display the error
    map for the backend, and check that the CX connectors really do represent the
    best and worst:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create two quantum circuits sized for the selected backend. With the qubit
    information gathered, we can create a quantum program that specifies CX gates
    for the best and worst qubit pairs. Here is where we use that qubits variable
    we pulled earlier. First, we build two circuits (`qc_best` and `qc_worst`) that
    have the correct number of qubits depending on the selected backend. That information
    is gathered using the `backend.configuration().n_qubits` method. We use the `cx_best_worst`
    list that we created earlier to place the H and CX gates on the correct qubits
    and then print the circuits:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Run the best and worst circuits on the backend. With all pieces assembled, we
    can now run the best circuit, followed by the worst. Of course, we also want a
    benchmark job on the perfect `qasm_simulator` using the same number of qubits
    as when we ran on the actual backend. Create and run a benchmark circuit on a
    local simulator. Print the results for the best, worst, and baseline qubit pair
    and plot the results in a diagram. We can also use the Qiskit® histogram feature
    to display the results in diagram form for clarity.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We start by displaying the best and worst CX-pair circuits, and running these
    on the selected backend:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then we build a generic CX circuit (Bell circuit), and run this one on the
    local `qasm_simulator` to get a baseline result:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, we collect the best, worst, and baseline job results. We then print
    them and display them together in a diagram for comparison:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And finally, the `main` function pulls it all together:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The IBM Quantum® backends are actual physical semiconductor circuits, each with
    slightly different behavior. In addition, the qubits are physically connected
    to make it possible to directly entangle them the way that you specify in your
    quantum programs. This type of qubit communication can only take place directly
    as specified by the coupling map that we looked at in the *Visualizing the backends*
    recipe in [*Chapter 5*](B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128), *Touring
    the IBM Quantum® Hardware with Qiskit®*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we extract the error rate for 2-qubit communication from our
    selected backend. We then pick the best and the worst qubit pairs and run the
    same quantum program on each pair to see how the outcome of the program differs.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how it is done:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: In your Python environment, run `ch8_r3_time.py`. The script loads Qiskit® and
    grabs and displays a list of the available backends:![Figure 8.8 – First, we select
    a backend to test on, such as ibmq_santiago
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.8_B14436.jpg)'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.8 – First, we select a backend to test on, such as ibmq_santiago
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Enter the name of a backend that you want to test on or enter `LB` to have the
    system pick the least busy system for you.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The best and worst CX gate performance information is displayed as a list and
    as an error map:![Figure 8.9 – The various CX gate errors for the qubit combinations
    of ibmq_santiago
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.9_B14436.jpg)'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.9 – The various CX gate errors for the qubit combinations of ibmq_santiago
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To verify that we have collected the correct information, we display the error
    map for the backend.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Take a look at the CNOT error rate legend in *Figure 8.10* and verify that
    the CX connectors that we have selected really are the best [1,2] and worst [3,4]:'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.10 – Error map showing the best [1,2] and worst [3,4] CX connectors
    for ibmq_santiago](img/Figure_8.10_B14436.jpg)'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 8.10 – Error map showing the best [1,2] and worst [3,4] CX connectors
    for ibmq_santiago
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Two quantum circuits sized for the selected backend are created and displayed.
    These circuits represent the best and the worst CX connections for the backend.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The best Bell circuit for the backend is shown in the next figure:'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.11 – A Bell-state circuit for the best performing CX gate'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_8.11_B14436.jpg)'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The result of the preceding code will be something like this:'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.13 – A transpiled Bell-state circuit for the best performing CX
    gate'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_8.13_B14436.jpg)'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.13 – A transpiled Bell-state circuit for the best performing CX gate
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As you can see, when we follow the qubit coupling map, our transpiled CX circuit
    looks exactly like the original circuit.
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We now run the best and worst circuits on the backend together with a baseline
    execution of the same circuit on the Aer simulator:![Figure 8.14 – The results
    of the best, worst, and benchmark CX gate pairs
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.14_B14436.jpg)'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.14 – The results of the best, worst, and benchmark CX gate pairs
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.14 – 最佳、最差和基准CX门对的结果
- en: 'And finally, we plot the results in a diagram for comparison:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将结果绘制成图表进行比较：
- en: '![Figure 8.15 – The benchmark, best, and worst results on the 5-qubit ibmq_santiago
    backend'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.15 – 5量子比特ibmq_santiago后端的基准、最佳和最差结果'
- en: '](img/Figure_8.15_B14436.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.15_B14436.jpg)'
- en: Figure 8.15 – The benchmark, best, and worst results on the 5-qubit ibmq_santiago
    backend
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15 – 5量子比特ibmq_santiago后端的基准、最佳和最差结果
- en: You now have a visual view, as well as numerical evidence that the qubits and
    gates on a chip differ in performance.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在有了直观的视图，以及数值证据，表明芯片上的量子比特和门在性能上有所不同。
- en: Take a look at the results here. We expect the simulated baseline (blue bars)
    to return perfect results for ![](img/Formula_008_007.png) and ![](img/Formula_008_008.png)
    only at the expected 50/50 spread. Note how there are no blue ![](img/Formula_008_012.png)
    and ![](img/Formula_008_013.png) results for the simulator.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这里的结果。我们预计模拟的基线（蓝色条形）只在预期的50/50分布下返回完美的结果 ![](img/Formula_008_007.png) 和 ![](img/Formula_008_008.png)。注意模拟器没有蓝色
    ![](img/Formula_008_012.png) 和 ![](img/Formula_008_013.png) 结果。
- en: On a real machine, the results are affected by qubit errors, as can be seen
    in the red (worst) and green (best) bars, with the IBM backends to return noisy
    results for all combinations ![](img/Formula_008_014.png), with the best qubit
    pair slightly less noisy than the worst pair.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际机器上，结果会受到量子比特错误的影响，如红色（最差）和绿色（最佳）条形所示，IBM 后端对所有组合 ![](img/Formula_008_014.png)
    返回有噪声的结果，最佳量子比特对略低于最差对。
- en: There's more...
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Keep in mind that the results that you see are not just based on the CNOT coupling
    error, but also on qubit errors and read and write errors for your qubits. To
    completely understand the results of runs like these, you need to consider error
    mitigation.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，你看到的结果不仅基于CNOT耦合错误，还基于量子比特错误以及你的量子比特的读写错误。要完全理解这类运行的结果，你需要考虑错误缓解。
- en: See also
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Qiskit Backend Specifications for OpenQASM and OpenPulse Experiments:* [https://arxiv.org/pdf/1809.03452.pdf](https://arxiv.org/pdf/1809.03452.pdf).'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Qiskit 后端规格说明，适用于 OpenQASM 和 OpenPulse 实验:* [https://arxiv.org/pdf/1809.03452.pdf](https://arxiv.org/pdf/1809.03452.pdf)。'
- en: Estimating the number of gates you have time for
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 估算你可以用的时间进行门操作的数量
- en: 'In addition to the gate errors that we have explored in the first two recipes,
    the end result of your recipes depends on another physical aspect of the qubits
    that we run on: the T1 and T2 times. We first discussed these in the *Explore
    your qubits to understand T1, T2, and errors* recipe:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在前两个菜谱中探讨的门错误之外，你的菜谱的最终结果还取决于我们在运行的量子比特的另一个物理方面：T1和T2时间。我们首先在 *探索你的量子比特以了解T1、T2和错误*
    菜谱中讨论了这些：
- en: '**T1**, or **relaxation time**: The T1 value is a statistical value of how
    long it takes for the qubit to spontaneously relax from the "excited" state ![](img/Formula_008_015.png)
    to the ground state ![](img/Formula_008_016.png). In essence, T1 is the upper
    limit, in microseconds, that you have at your disposal to perform high-quality
    actions on the qubit.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**T1**，或**弛豫时间**：T1值是量子比特从“激发”状态 ![](img/Formula_008_015.png) 到基态 ![](img/Formula_008_016.png)
    自发弛豫所需时间的统计值。本质上，T1是你可用于对量子比特执行高质量操作的微秒级上限。'
- en: '**T2**, or **dephasing time**: Similar to T1, the T2 value is a statistical
    measure of how phase information is lost for a qubit. An example of phase change
    is when the state ![](img/Formula_008_003.png) spontaneously changes to ![](img/Formula_008_018.png).
    Again, if the running time for your circuit starts to approach the T2 time, the
    quality of your readout data will suffer.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**T2**，或**去相位时间**：与T1类似，T2值是量子比特相位信息丢失的统计度量。相位变化的一个例子是当状态 ![](img/Formula_008_003.png)
    自发变为 ![](img/Formula_008_018.png)。再次强调，如果你的电路运行时间开始接近T2时间，你的读出数据质量将受到影响。'
- en: With this data, we can make a rough estimate of how the size of our programs
    might affect the end result. Not only do we have to take into account the error
    rates for the individual gates but we have to also understand how the T1/T2 times
    limit the number of gates that can actually be run. How many gates can we squeeze
    into our programs before they just return garbage? Let's take a look.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些数据，我们可以粗略估计我们的程序大小可能如何影响最终结果。我们不仅要考虑单个门的错误率，还要理解T1/T2时间如何限制可以实际运行的门数量。在我们程序返回垃圾之前，我们能塞入多少门？让我们看看。
- en: Getting ready
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The file required in the following recipe can be downloaded from here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r3_time.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r3_time.py).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的食谱中所需的文件可以从这里下载：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r3_time.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r3_time.py)。
- en: The sample code
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例代码
- en: 'First, we import the class that we need and load our account. In this recipe,
    we combine a lot of important concepts from earlier in the book, such as simulators
    and noise models:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入所需的类并加载我们的账户。在这个食谱中，我们结合了书中早期的一些重要概念，例如模拟器和噪声模型：
- en: '[PRE14]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `select_backend()` function lets you select an available backend:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`select_backend()` 函数允许您选择一个可用的后端：'
- en: '[PRE15]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When passed an IBM Quantum® backend name, the `display_information(backend,n_id,ttype)`
    function pulls the T1, T2, readout error, and length of an `id` gate for qubit
    0 of that backend:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当传递一个 IBM Quantum® 后端名称时，`display_information(backend,n_id,ttype)` 函数会提取该后端量子位
    0 的 T1、T2、读出错误和 `id` 门长度：
- en: '[PRE16]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `build_circuit(ttype,n_id)` function takes a number and builds a basic circuit
    that includes that amount of Id gates. It starts the circuit with an X gate to
    place the qubit in the ![](img/Formula_008_015.png), or excited state. The purpose
    of the circuit is to wait for a period of time and then measure the qubit, and
    the Id gate is perfect for the job; it doesn't perform any qubit manipulation,
    but still takes a certain amount of time to execute. If we have waited long enough,
    the qubit will spontaneously relax down to the ground state, or ![](img/Formula_008_016.png).
    This will require more or less gates depending on the T1 value for the qubit.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`build_circuit(ttype,n_id)` 函数接受一个数字并构建一个包含该数量 Id 门的基电路。电路以一个 X 门开始，将量子位置于
    ![](img/Formula_008_015.png) 或激发态。电路的目的是等待一段时间然后测量量子位，而 Id 门非常适合这项工作；它不执行任何量子位操作，但仍然需要一定的时间来执行。如果我们等待足够长的时间，量子位将自发地松弛到基态，或
    ![](img/Formula_008_016.png)。这将根据量子位的 T1 值需要更多或更少的门。'
- en: 'Depending on the value of the `ttype` parameter, we will build one of the following:'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据 `ttype` 参数的值，我们将构建以下之一：
- en: '`T1`: Set up a simple circuit that puts the qubit in state ![](img/Formula_008_021.png),
    then add a number of Id gates to make time pass, and finally perform the measurement
    of the outcome at different circuit lengths.'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`T1`：设置一个简单的电路，将量子位置于状态 ![](img/Formula_008_021.png)，然后添加多个 Id 门以使时间流逝，并最终在不同电路长度下测量结果。'
- en: '`T2`: Similarly, set up a simple circuit that puts the qubit in state ![](img/Formula_008_015.png),
    then in superposition ![](img/Formula_008_003.png) with phase ![](img/Formula_008_024.png).
    Then add a number of Id gates to make time pass, and finally apply another H gate
    and measure. If the qubit is still in ![](img/Formula_008_003.png), it will now
    measure as ![](img/Formula_008_015.png), but if it has spontaneously changed phase,
    approaching ![](img/Formula_008_018.png), it will read as ![](img/Formula_008_016.png)
    with a certain probability:'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`T2`：同样，设置一个简单的电路，将量子位置于状态 ![](img/Formula_008_015.png)，然后处于叠加态 ![](img/Formula_008_003.png)
    并具有相 ![](img/Formula_008_024.png)。然后添加多个 Id 门以使时间流逝，最后应用另一个 H 门并测量。如果量子位仍然处于 ![](img/Formula_008_003.png)
    状态，它现在将测量为 ![](img/Formula_008_015.png)，但如果它自发地改变了相位，接近 ![](img/Formula_008_018.png)，它将以一定的概率读取为
    ![](img/Formula_008_016.png)：'
- en: '[PRE17]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If we run the circuit on a simulator, we use the `build_noisemodel(backend)`
    function to build a noise model for the selected backend. We then use the noise
    model in `execute_circuit()` to simulate running the circuit on the actual backend:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们在模拟器上运行电路，我们使用 `build_noisemodel(backend)` 函数为所选后端构建一个噪声模型。然后我们在 `execute_circuit()`
    中使用该噪声模型来模拟在真实后端上运行电路：
- en: '[PRE18]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With the `execute_circuit(backend, circuit,noise_model, n_id)` function, we
    run the circuit on a simulated version of the selected backend by using the noise
    model we created in `build_noisemodel()`:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `execute_circuit(backend, circuit,noise_model, n_id)` 函数，我们通过使用在 `build_noisemodel()`
    中创建的噪声模型，在所选后端的模拟版本上运行电路：
- en: '[PRE19]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `main` function can be broken up into a set of processes, starting with
    the input and information section:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`main` 函数可以被分解成一系列过程，从输入和信息部分开始：'
- en: '[PRE20]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With all input, noise model, and initial circuit creation taken care of, we
    can now run the circuit on a pure simulator and then on the selected backend,
    either simulated or on IBM Quantum®. We store our results in an `entry` dictionary,
    and the lengths of the executed circuits in a `legend` array, then use them to
    present the results:'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, we merge the results from the results dictionary into a `results_array`
    array, matching the lengths from the `legend` array, then display all the results
    in a combined diagram:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How to do it...
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To explore how a qubit relaxes from the excited ![](img/Formula_06_023.png)
    state to the ground state ![](img/Formula_06_0221.png), follow these steps:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: In your Python environment, run `ch8_r3_time.py`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The script loads Qiskit® and grabs and displays a list of the available backends.
    Enter the name of a backend that you want to test on, then enter `S` to run on
    a noise-simulated version of the backend. Finally, enter the number of Id gates
    that you want to include in your circuit, for example, `1024`:'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.16 – Select a backend, whether to run on the actual backend, and
    enter a number of Id gates'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_8.16_B14436.jpg)'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.16 – Select a backend, whether to run on the actual backend, and enter
    a number of Id gates
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Various pieces of data for the first qubit of the selected backend are displayed.
    We are particularly interested in the T1 value and the Id gate length. From these,
    we can estimate how long our circuit will take to run, and the percentage of the
    T1 time that will be consumed. We are not particularly concerned about gate errors;
    the Id gate does not do any qubit manipulation but is really only a delay gate:![Figure
    8.17 – The backend data
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.17_B14436.jpg)'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.17 – The backend data
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We also display a representative sample circuit with five Id gates. Your actual
    circuit will be much, much bigger, but with the same architecture; a long string
    of barriers and Id gates:![Figure 8.18 – Sample Id-circuit
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.18_B14436.jpg)'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.18 – Sample Id-circuit
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The circuit now runs, first on the build in the Qiskit Aer `qasm_simulator`
    for a clean result, then on the simulated or actual backend. It starts with a
    circuit with the selected number of Id gates, and then runs successively shorter
    circuits until it reaches a circuit with just one Id gate:![Figure 8.19 – Raw
    T1 results on the simulated ibmq_valencia backend
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.19_B14436.jpg)'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.19 – Raw T1 results on the simulated ibmq_valencia backend
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, it collects and displays the results of all the runs in one diagram:![Figure
    8.20 – T1 results on the simulated ibmq_valencia backend
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.20_B14436.jpg)'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.20 – T1 results on the simulated ibmq_valencia backend
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Alright, so what do these results mean? Let's take a look…
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the probability of getting the result ![](img/Formula_06_023.png)
    gets lower and lower as the number of gates increases. At 1,024 gates, we are
    down to roughly 70%, which is pretty close to just noise. Try doubling the number
    of gates to 2,048 and see if the curve lands you somewhere close to 50% or so.
    So, where do you need to be to have a stab at actually getting good results from
    your circuits? Take a look at *Figure 8.20* again – this time, at the 1 Id gate
    circuit end. The probability of getting the result ![](img/Formula_06_139.png)
    hovers around 93-95%, and a bit of the uncertainty here comes from the readout
    error, which in our case was around 3.5%. This hints at a max circuit length of
    around 64 Id gates before things start to go wrong.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，随着门数的增加，得到结果 ![](img/Formula_06_023.png) 的概率越来越低。在1,024个门时，我们下降到大约70%，这几乎接近噪声。尝试将门数加倍到2,048，看看曲线是否接近50%左右。所以，你需要达到什么水平才能从你的电路中获得好的结果？再次查看
    *图8.20* – 这次，查看1个Id门电路的末端。得到结果 ![](img/Formula_06_139.png) 的概率在93-95%之间徘徊，这里的不确定性部分来自读出错误，在我们的案例中约为3.5%。这暗示了在事情开始出错之前，最大电路长度约为64个Id门。
- en: Also remember that this measurement only takes into account the T1 relaxation
    time, and only really measures the performance of the qubit at various circuit
    lengths, only using Id gates, which are not really useful for building actual
    quantum circuits.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住，这个测量只考虑了T1弛豫时间，并且实际上只测量了在各个电路长度下量子比特的性能，只使用了Id门，这些门实际上对构建实际的量子电路并不真正有用。
- en: For actual, useful circuits, we also need to take into account other factors
    such as gate errors, transpiling architecture, and more. This means that you cannot
    just extrapolate the circuit count you deem OK quality-wise from this experiment
    and set that as your gate limit for a backend. Take a look back at the *Comparing
    the Qiskit Aer simulator with an IBM quantum computer* recipe in [*Chapter 7*](B14436_07_Final_PG_ePub.xhtml#_idTextAnchor197),
    *Simulating Quantum Computers with Aer*, for a rudimentary example of what gate
    errors can do in long circuits.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实际且有用的电路，我们还需要考虑其他因素，例如门错误、架构重编译等。这意味着你不能仅仅从这次实验中推断出你认为质量上可接受的电路数量，并将其设置为后端的门限制。回顾一下
    [*第7章*](B14436_07_Final_PG_ePub.xhtml#_idTextAnchor197) 中的 *Comparing the Qiskit
    Aer simulator with an IBM quantum computer* 菜单，*使用Aer模拟量子计算机*，以了解门错误在长电路中可能产生的影响的初步示例。
- en: There's more
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容
- en: After this first run-through, you can test a couple of other scenarios, as discussed
    next.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次运行之后，你可以测试一些其他场景，如接下来将要讨论的。
- en: Comparing backends
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较后端
- en: Try running identical circuits on different backends to see how the results
    differ. IBM Quantum® is hard at work—developing better and better qubits and control
    circuitry and you can see how progressively newer backends generally have longer
    T1/T2 times, and better performing qubits. You can estimate how old a backend
    is by looking at the **online since** dates in *Figure 8.21*.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在不同的后端上运行相同的电路，以查看结果如何不同。IBM Quantum® 正在努力工作——开发更好的量子比特和控制电路，你可以看到较新的后端通常具有更长的T1/T2时间，并且量子比特的性能更好。你可以通过查看
    *图8.21* 中的 **online since** 日期来估计后端有多旧。
- en: 'Here, for example, are the results of the 1,024 Id gate circuit on the `ibmqx2`
    backend, which came online in January 2017\. Compare these to the `ibmq_valencia`
    results that we just obtained. That backend has been online since July 2019:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是 `ibmqx2` 后端上1,024个Id门电路的结果，该后端于2017年1月上线。将这些结果与我们刚刚获得的 `ibmq_valencia`
    结果进行比较。该后端自2019年7月上线：
- en: '![Figure 8.21 – Results on ibmqx2, an older backend with a shorter T1'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.21 – 在较旧的、T1较短的ibmqx2后端上的结果'
- en: '](img/Figure_8.21_B14436.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.21_B14436.jpg)'
- en: Figure 8.21 – Results on ibmqx2, an older backend with a shorter T1
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.21 – 在较旧的、T1较短的ibmqx2后端上的结果
- en: By comparing the data in *Figure 8.20* (`ibmq_valencia`) with the data in *Figure
    8.21* (`ibmqx2`), you can see that the T1 time is more than twice as long for
    the newer `ibmq_valencia` backend and that the probability of getting the correct
    result after 1,024 Id gates is much higher (70% versus 46%).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 通过比较 *图8.20* (`ibmq_valencia`) 中的数据与 *图8.21* (`ibmqx2`) 中的数据，你可以看到对于较新的 `ibmq_valencia`
    后端，T1 时间是旧后端的两倍以上，并且在经过1,024个Id门之后得到正确结果的可能性要高得多（70% 对比 46%）。
- en: Running on an IBM Quantum® backend
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在IBM Quantum® 后端上运行
- en: Now, test running the same test on the actual backend by running the sample
    script `ch8_r3_time.py` again and entering `Q` when prompted.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过再次运行示例脚本 `ch8_r3_time.py` 并在提示时输入 `Q`，来在实际后端上测试运行相同的测试。
- en: Pick a suitable backend
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 选择合适的后端
- en: As we will be running about half a dozen individual jobs or so, the complete
    run might take some time depending on the number of users that are running jobs
    on the backend. Before you pick a backend to run on, check the **pending jobs**
    number for the backend.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'When running on the actual backend, the job monitor provides information about
    your place in the queue. For the backend `ibmq_valencia`, this might give the
    following result:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.22 – Raw T1 results on the ibmq_valencia backend'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.22_B14436.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.22 – Raw T1 results on the ibmq_valencia backend
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'Plotted side by side, you get a visual comparison:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.23 – T1 results on the ibmq_valencia backend'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.23_B14436.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.23 – T1 results on the ibmq_valencia backend
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: See how the qubit relaxes from ![](img/Formula_008_033.png) as the number of
    Id gates increases, and thus the *wait* time gets longer. Note how the actual
    backend results match the simulated results pretty well.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Testing T2 dephasing
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also test the T2 value – how your qubit dephases – by changing the
    type parameter from `"T1"` to `"T2"` in the sample code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'How is the sample circuit different in this case? As the T2 time measures dephasing,
    we must first set up our qubit to actually have phase information. We start off
    our circuit with an X gate, putting our qubit in the ![](img/Formula_06_023.png)
    state. We then add an H gate, which brings the qubit to the ![](img/Formula_008_035.png)
    state, which is the same as the ![](img/Formula_008_036.png) state phase-shifted
    by ![](img/Formula_008_037.png) radians:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.24 – The T2 circuit includes H gates to place our qubit in the  state,
    with a  phase](img/Figure_8.24_B14436.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
- en: Figure 8.24 – The T2 circuit includes H gates to place our qubit in the ![](img/Formula_008_035.png)
    state, with a ![](img/Formula_008_039.png) phase
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'We then let time pass, giving the qubit the opportunity to dephase a bit from
    the initial ![](img/Formula_008_040.png) phase, before adding another H gate to
    bring us back to the computational basis so that we can measure the qubit:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.25 – T2 results on the ibmqx2 backend'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.25_B14436.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.25 – T2 results on the ibmqx2 backend
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: By looking at *Figure 8.25* and *Figure 8.21*, you can now get a complete picture
    of the T1 and T2 impact on your qubit. Try running with even more Id gates to
    see how the behavior changes.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a much more detailed description of T1 and T2 and how to measure it, take
    a look at *Learn Quantum Computing with Python and IBM Quantum Experience*, *Chapter
    11*, *Mitigating Quantum Errors Using Ignis*, by Robert Loredo, Packt, 2020.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Correcting for the expected with readout correction
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have some knowledge about what might go wrong when we use our qubits
    for quantum calculations, is there anything that we can do about it? There are
    essentially two approaches here, at least for the small quantum backends that
    we have at our disposal.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: First, we can make sure that the quantum programs that we run have a fighting
    chance of completing before the qubits get lost due to decoherence, the T1 and
    T2 times that we explored. This means that we make the programs short.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Second, we can take a good look at various readout errors and see if we can
    mitigate those. If you remember in [*Chapter 7*](B14436_07_Final_PG_ePub.xhtml#_idTextAnchor197),
    *Simulating Quantum Computers with Aer*, we could pull in actual backend qubit
    data to `qasm_simulator` and have it behave like an NISQ backend. We can do the
    same in reverse, analyze the measurement errors for a backend, and use that data
    to create a mitigation map to counteract erroneous measurements.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The sample code for this recipe can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r4_ignis.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r4_ignis.py).'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: The sample code
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To handle the creation and running of the readout correction, we build a number
    of functions in the `ch8_r4_ignis.py` script:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import the classes and methods that we need. You can import Qiskit®
    and load the account by running the following code:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Using `select_backend()`, we load and display the data for the available backends,
    and then prompt to select one:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Using `create_circuit()`, we create a basic GHZ-state circuit for which we
    know the expected outcomes – ![](img/Formula_008_041.png):'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`simulator_results(circuit)` runs the provided circuit on the local Qiskit
    Aer simulator:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`noisy_results(circuit,backend)` runs the provided circuit on the provided
    backend:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This `mitigated_results(backend,circuit,results)` function is the main function
    we build to run error mitigation on the provided results, based on backend measurement
    error data:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And finally, the `main()` function helps in wrapping up the function flow and
    final data presentation:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How to do it…
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In your local Qiskit® environment, run the `ch8_r4_ignis.py` sample, then select
    one of the available backends to test on:![Figure 8.26 – Select an available backend
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.26_B14436.jpg)'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.26 – Select an available backend
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We'll now build the GHZ-state circuit that we will be testing with. We know
    that the expected outcomes are ![](img/Formula_008_043.png), and can use that
    information to validate how well our circuit runs on the selected backend, and
    how well we can error correct:![Figure 8.27 – The GHZ-state circuit that we will
    test with
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.27_B14436.jpg)'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.27 – The GHZ-state circuit that we will test with
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The script now runs the circuit on a local simulator and on the selected backend:![Figure
    8.28 – Results on the local qasm_simulator and on the ibmqx2 backend
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.28_B14436.jpg)'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.28 – Results on the local qasm_simulator and on the ibmqx2 backend
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the results of the circuit when run on the backend, we can
    pull in the actual qubit and gate data from the backend and build a noise model.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经得到了在后端运行电路的结果，我们可以从后端拉取实际的量子比特和门数据，并构建一个噪声模型。
- en: 'The model includes statistics on the measurement behavior for the backend''s
    qubits:'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该模型包括后端量子比特的测量行为统计：
- en: '![Figure 8.29 – Calibration matrix with the expected results and the statistical
    measurement errors'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 8.29 – 包含预期结果和统计测量误差的校准矩阵'
- en: '](img/Figure_8.29_B14436.jpg)'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/Figure_8.29_B14436.jpg](img/Figure_8.29_B14436.jpg)'
- en: Figure 8.29 – Calibration matrix with the expected results and the statistical
    measurement errors
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.29 – 包含预期结果和统计测量误差的校准矩阵
- en: In *Figure 8.29*, you can see the expected results in the diagonal, and the
    statistical measurement errors as gray shading away from the diagonal. The darker
    the shading, the higher the probability of getting that result.
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在*图8.29*中，你可以看到对角线上的预期结果，以及从对角线远离的灰色阴影表示的统计测量误差。阴影越深，得到该结果的可能性越高。
- en: 'We can use this data to rerun the circuit on the local simulator, with the
    measurement calibration data as input. We can then run the original results through
    a measurement filter and get the mitigated results as follows:'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以使用这些数据在本地模拟器上重新运行电路，将测量校准数据作为输入。然后，我们可以将原始结果通过测量滤波器运行，得到以下缓解结果：
- en: '![Figure 8.30 – The mitigated results for ibmq_16_melbourne'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 8.30 – ibmq_16_melbourne的缓解结果'
- en: '](img/Figure_8.30_B14436.jpg)'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/Figure_8.30_B14436.jpg](img/Figure_8.30_B14436.jpg)'
- en: Figure 8.30 – The mitigated results for ibmq_16_melbourne
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.30 – ibmq_16_melbourne的缓解结果
- en: 'Finally, we can plot the simulator results, the original backend results, and
    the mitigated results for comparison:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以绘制模拟器结果、原始后端结果和缓解结果以进行比较：
- en: '![Figure 8.31 – A comparison of results for simulator, backend, and mitigated
    backend'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.31 – 模拟器、后端和缓解后端的比较结果'
- en: '](img/Figure_8.31_B14436.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_8.31_B14436.jpg](img/Figure_8.31_B14436.jpg)'
- en: Figure 8.31 – A comparison of results for simulator, backend, and mitigated
    backend
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.31 – 模拟器、后端和缓解后端的比较结果
- en: From the final chart, you can see that the expected results for a GHZ-state
    circuit, ![](img/Formula_008_042.png) with roughly a 50/50 chance, is not what
    we get on the backend. There are a large number of noisy bars between the expected
    results. With the error mitigation, we shrink these bars and bring the results
    closer to the expected.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 从最终的图表中，你可以看到对于GHZ态电路的预期结果![img/Formula_008_042.png](img/Formula_008_042.png)，大约有50/50的机会，并不是我们在后端得到的结果。在预期结果之间有许多噪声条。通过错误缓解，我们缩小了这些条，并将结果更接近预期。
- en: Mitigating the unexpected with quantum error correction
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用量子错误纠正缓解意外情况
- en: As we saw in the previous recipe, it is good to understand how your measurements
    behave, to statistically be able to correct incorrect readouts. But in the end,
    a measurement is just a measurement, and a measurement of a qubit will result
    in either 0 or 1\. If the state of the qubit that you measure turns out to be
    ![](img/Formula_06_058.png) instead of the expected ![](img/Formula_008_045.png),
    it doesn't matter that you statistically corrected for measurement mistakes; your
    qubit is off by 100%.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个示例中所示，了解你的测量行为是很有好处的，以便在统计上能够纠正错误的读数。但最终，一个测量只是一个测量，对一个量子比特的测量将导致0或1。如果你测量的量子比特状态最终是![img/Formula_06_058.png](img/Formula_06_058.png)而不是预期的![img/Formula_008_045.png](img/Formula_008_045.png)，即使你统计上纠正了测量错误，你的量子比特也有100%的错误。
- en: There are a lot of things that can perturb our qubits, from gate errors to just
    plain physics that causes the qubit to decohere and dephase (remember the T1 and
    T2 times). In the classical computing world, we can periodically check in on our
    bits, and apply error correction coding to make sure that they behave. Digital
    error correction is one of the reasons that digital communication works and that
    you can play digital media, CDs, DVDs, and Blu-ray disks and actually hear or
    see what you expect.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多因素可能会干扰我们的量子比特，从门错误到简单的物理因素，这些因素会导致量子比特去相干和去相位（记住T1和T2时间）。在经典计算世界中，我们可以定期检查我们的比特，并应用错误纠正编码来确保它们的行为。数字错误纠正是数字通信能够工作以及你可以播放数字媒体（如CD、DVD和蓝光光盘）并真正听到或看到你所期望的原因之一。
- en: One way of performing classical error correction is to duplicate one bit that
    you want to transfer into three bits, and at the end compare the bit with its
    duplicated brethren. If they are different, then at least one of the bits has
    been *errored*. Very simply put, you can then take a majority vote and flip the
    offending bit, and thus get the original back.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: For qubits, it is not so simple. For one, you cannot make copies of qubits like
    you can for classical bits. Instead, we have to make use of **superposition**
    and **entanglement**.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: We discussed superposition at length in the *Comparing a bit and a qubit* recipe
    of [*Chapter 2*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045), *Quantum Computing
    and Qubits with Python*, and entanglement in the *Quantum-cheating in a coin toss?
    – Introducing the Bell State* recipe of [*Chapter 4*](B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081),
    *Starting at the Ground Level with Terra*. Feel free to go back for a refresher.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Let's use these tools to explore further... Read on!
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The sample code for this recipe can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r5_shor.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r5_shor.py).'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: The sample code
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To handle the creation and running of the Shor code algorithm, we will build
    a number of functions in the `ch8_r5_shor.py` script:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import the methods that we need and set the backend:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `get_psi(qc)` function is an old friend that we are reusing to return the
    state vector of the circuit, to display Bloch spheres and Q-spheres:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Instead of expecting the first qubit errors to occur naturally, we use the
    `add_error(error, circuit,ry_error, rz_error)` function to create four different
    types of errors – **Bit flip**, **Bit flip + phase flip**, **Theta + phi shift**,
    and **Random**:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `not_corrected(error, ry_error, rz_error)` function creates a simple 1-qubit
    circuit and introduces the error that we select in the main process, then displays
    the results as a Bloch sphere and a Q-sphere. We also run the circuit on the Qiskit
    Aer `qasm_simulator` to see the results of our contaminated qubit:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now it is time to add the quantum correction code that Peter Shor developed.
    We are building the same circuit as before, but with 8 `add_error()` function.
    This simulates real-world perturbance of the qubit:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**The end of the bit-flip correction**: After the errors have been introduced,
    we now start collecting our qubits again, starting with wrapping up the bit-flip
    correction and adjusting each of the phase-shift qubits if needed:'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '**The end of the phase-flip correction**: And similar to the bit flip wrapping
    up, we now close the phase-flip correction, applying any necessary correction
    to the first qubit:'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**Measure and print**: We can now measure the qubit and print the result:'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The program prompts for a numeric input to select the error to introduce, and
    then runs the `not_corrected()` and `shor_corrected()` functions:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The code we have built here can now be run, simulating the quantum error correction
    of any phase and the bit perturbation of the qubit.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take the Shor code for a spin:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: In your Python environment, run `ch8_r5_shor.py`.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When prompted, enter the error type for a bit flip: `1`.'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The error-free qubit is displayed:![Figure 8.32 – The qubit with no error, in
    state
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.32_B14436.jpg)'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.32 – The qubit with no error, in state ![](img/Formula_008_052.png)
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, the selected error is added, and the results are displayed. The qubit
    has now flipped from ![](img/Formula_008_053.png):![Figure 8.33 – The qubit with
    the selected bit-flip error, turning the qubit from
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.33_B14436.jpg)'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.33 – The qubit with the selected bit-flip error, turning the qubit
    from ![](img/Formula_008_054.png)
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, press *Enter* to create a new circuit and display the undisturbed qubit
    with its 8 ancilla qubits. The Q-sphere displays the possible outcomes of this
    new unperturbed circuit, all 9 qubits in ![](img/Formula_06_057.png):![Figure
    8.34 – Undisturbed qubit with 8 ancilla qubits
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.34_B14436.jpg)'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.34 – Undisturbed qubit with 8 ancilla qubits
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We now start the Shor code creation and add the simulated error. The Q-sphere
    now shows a number of possible outcomes as qubits 0, 3, and 6 are now in a superposition,
    giving a probabilistic outcome for those qubits, and for their entangled counterparts.
    Notice that qubit 0 can now appear as both ![](img/Formula_008_056.png):![Figure
    8.35 – Qubit with added bit-flip error, turning the qubit from
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_8.35_B14436.jpg)'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.35 – Qubit with added bit-flip error, turning the qubit from ![](img/Formula_008_0541.png)
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we complete the Shor code, display the expected outcomes for the circuit,
    and then run it on the Aer `qasm_simulator`:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.36 – Result of the error-corrected qubit, back at  again](img/Figure_8.36_B14436.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
- en: Figure 8.36 – Result of the error-corrected qubit, back at ![](img/Formula_008_052.png)
    again
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the Q-sphere and the results count. The state vector has safely
    put our qubit back at ![](img/Formula_008_059.png) again; note how the least-significant
    bit that represents the first qubit is now ![](img/Formula_008_060.png). The result
    also points to our qubit being safely error-corrected, with a 100% chance of 0.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s a short explanation of how qubit error correction works. We first create
    what is called a **syndrome** by entangling our qubit with two other ancilla qubits.
    The entangled qubits now walk through life as one entity, indistinguishable from
    each other with one exception: errors to the qubits are not entangled, but unique
    to each qubit.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Before using our qubit for anything, we first disentangle it from the other
    2 qubits; it is now a standalone qubit again. Now it is time to use the **syndrome**
    to correct any errors.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we set up a Toffoli (**CCX**) gate from our two syndrome qubits
    to our qubit of interest. If the syndrome qubits differ from our original qubit,
    that is, our qubit has been disturbed, the CCX flips the qubit right again.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: That's it. Simple, eh? Well, let's take a closer look.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two methods we can use, for two different qubit errors:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '**Bit-flip correction**: Correcting flipped qubits, from ![](img/Formula_008_061.png)
    and vice versa'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Phase-flip**: Correcting flipped phases, from ![](img/Formula_008_062.png)
    and vice versa'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bit-flip correction
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the bit correction method, we set up a GHZ-state entangled circuit, using
    the first qubit as the controller for a CXX gate (or two CX gates in this case),
    where two additional ancilla qubits are used as the error correction syndrome
    only and are not used in the final measurement:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: 'If the first qubit is ![](img/Formula_008_063.png), we now have the following
    state:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Formula_008_064.png)'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: If it is ![](img/Formula_008_065.png), we now have ![](img/Formula_008_066.png)
    – nothing new there.
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After setting up the initial qubit and its ancillas, we let the world act on
    the first qubit, potentially introducing bit-flip errors, sending our ![](img/Formula_008_067.png),
    for example, to ![](img/Formula_008_068.png).
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the diagram that follows, this is represented by the two barriers between
    the two sets of CX gates.
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Our 3 qubits might now be in the following two states:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Formula_008_069.png)'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'We then run a second GHZ-entanglement to disentangle the first qubit, and end
    up with the following states:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Formula_008_070.png), nothing changes as the first qubit is now ![](img/Formula_008_071.png),
    and ![](img/Formula_008_072.png) if the first qubit is ![](img/Formula_008_073.png).'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At this point, we add a supremely clever piece of coding by adding a Toffoli
    gate, with the two syndrome qubits as controllers, and the first qubit as the
    controlled qubit. What happens?
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Formula_008_074.png) turns into ![](img/Formula_008_075.png), and ![](img/Formula_008_076.png)
    into ![](img/Formula_008_074.png), and like magic, our first qubit has returned
    to its original state of ![](img/Formula_008_078.png):'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.37 – The bit-flip quantum correction circuit](img/Figure_8.37_B14436.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
- en: Figure 8.37 – The bit-flip quantum correction circuit
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Phase-flip correction
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'But a qubit also differs from a classical bit by one critical aspect: in addition
    to 0 and 1, a qubit can also have a phase value, and thus also phase errors. Can
    we error correct for that? Turns out that we can, with basically the same method,
    with yet another clever twist:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: 'Like before, we start out with our 3 qubits, and our GHZ-state:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Formula_008_079.png)'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The next step is to transform our measurement basis state into a state where
    we can work with phase information, by adding a Hadamard gate to each qubit. We
    now have the following two states instead:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Formula_008_080.png)'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Again, we let nature act on the first qubit, potentially ending up with a phase-shifted
    first qubit, like this:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Formula_008_081.png)'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: In the diagram that follows, the error occurs between the two barriers between
    the H gates.
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Like in the bit-flip example, we now apply the Hadamard gate and the GHZ-creating
    CXX gates again, and now end up with the following:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Formula_008_082.png)'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![](img/Formula_008_083.png)'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'And finally, the Toffoli (CCX) gate turns the qubit trio into the following:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Formula_008_084.png)'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Again, our first qubit has returned to its original state of ![](img/Formula_008_085.png)
    and ![](img/Formula_008_086.png):'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.38 – The phase-flip quantum correction circuit'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.38_B14436.jpg)'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.38 – The phase-flip quantum correction circuit
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Shor code
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'That is all great; we can tackle bit-flip errors as well as phase-flip errors.
    But what if both types of errors occur? After all, qubits are physical entities,
    and who really knows how they will behave? It turns out that we can do that as
    well. Peter Shor, of Shor''s algorithm fame (see [*Chapter 10*](B14436_10_Final_PG_ePub.xhtml#_idTextAnchor271),
    *Getting to Know Algorithms with Aqua*) invented the Shor code, which is a combination
    of the phase-flip and bit-flip methods using 9 qubits in total. The first qubit
    is the one we want to do quantum error correction on, and the eight following
    are the ancillas, only used for working the correction magic:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.39 – The Shor code circuit'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.39_B14436.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.39 – The Shor code circuit
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a quick description, but do take a look at *Figure 8.39*:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Set up the first half of the phase-flip circuit using qubits 0, 3, and 6.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the first half of three bit-flip circuits for qubits 0, 3, and 6.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave some room for nature and the error to happen to qubit 0\. The two barriers
    between the triplicate CX gate sets below.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the second half of three bit-flip circuits for qubits 0, 3, and 6, effectively
    correcting any bit flips on these 3 qubits.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the second half of the phase-flip circuit for qubits 0, 3, and 6, correcting
    any phase shifts for these three qubits.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Measure qubit 0.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now the math turns somewhat complicated, with Ket-representations for 9 qubits
    looking like this, for example: |011000101![](img/Formula_008_090.png). Not to
    mention what unitary matrices for 9-qubit circuits look like.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first example that we ran, a simple bit-flip error, didn't really make use
    of the full power of the Shor code. Try some of the other options to simulate
    any type of conceivable error that might occur, from the simple to the very complex.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: 'The following options are available:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '**Bit flip**: This error flips the bit upside-down, from ![](img/Formula_008_087.png).'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bit flip**: 这种错误将比特翻转过来，从 ![](img/Formula_008_087.png)。'
- en: '**Bit flip plus phase flip**: A combined bit and phase flip.'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bit flip plus phase flip**: 比特翻转和相位翻转的组合。'
- en: '**Theta plus phi shift**: Create your own error by entering the theta ![](img/Formula_008_088.png)
    and phi ![](img/Formula_008_089.png) angles to point your state vector at any
    point on the Bloch sphere. If you need a reminder about what these two angles
    represent, take a quick look at the *Visualizing a qubit in Python* recipe in
    [*Chapter 2*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045), *Quantum Computing
    and Qubits with Python*.'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Theta plus phi shift**: 通过输入 theta ![](img/Formula_008_088.png) 和 phi ![](img/Formula_008_089.png)
    角度来创建自己的错误，使你的状态向量指向 Bloch 球上的任意一点。如果你需要提醒这两个角度代表什么，请快速查看 [*第二章*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045)
    中的 *Visualizing a qubit in Python* 菜谱，*Python 量子计算与量子比特*。'
- en: '**Random**: A random error.'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Random**: 随机错误。'
- en: See also
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Quantum Error Correction for Beginners*, Simon J. Devitt, William J. Munro,
    and Kae Nemoto, June 24, 2013, [https://arxiv.org/pdf/0905.2794.pdf](https://arxiv.org/pdf/0905.2794.pdf
    )'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Quantum Error Correction for Beginners*，Simon J. Devitt, William J. Munro,
    和 Kae Nemoto，2013年6月24日，[https://arxiv.org/pdf/0905.2794.pdf](https://arxiv.org/pdf/0905.2794.pdf)'
- en: '*Quantum Computation and Quantum Information* by Isaac L. Chuang; Michael A.
    Nielsen, Cambridge University Press, 2010, Chapter 10.2 Shor code'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Quantum Computation and Quantum Information*，作者 Isaac L. Chuang 和 Michael
    A. Nielsen，剑桥大学出版社，2010年，第10.2节 Shor 代码'
