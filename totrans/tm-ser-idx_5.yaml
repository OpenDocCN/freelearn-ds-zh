- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Joining and Comparing iSAX Indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we developed a Python package called `isax` that creates
    iSAX indexes for indexing the subsequences of a time series given a sliding window.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to experiment with how the sliding window size
    affects the number of splits and the number of accesses to subsequences while
    creating an iSAX index.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we are going to use the iSAX indexes created by the `isax` package and
    try to join and compare them. By *comparing*, we aim to understand the efficiency
    of an iSAX index, and by *joining*, we mean being able to find similar nodes in
    two iSAX indexes based on SAX representations.
  prefs: []
  type: TYPE_NORMAL
- en: The last part of this chapter is going to briefly discuss Python testing before
    developing simple tests for the `isax` package. *Testing is a serious part of
    the development process and should not be overlooked*. The time spent writing
    tests is time well spent!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How the sliding window size affects the iSAX construction speed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking the search speed of iSAX indexes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Joining iSAX indexes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the joining of iSAX indexes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining the Python code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Python code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing Python tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The GitHub repository for this book can be found at [https://github.com/PacktPublishing/Time-Series-Indexing](https://github.com/PacktPublishing/Time-Series-Indexing).
    The code for each chapter is in its own directory. Therefore, the code for this
    chapter can be found in the `ch05` folder. You can download the entire repository
    on your computer using `git(1)` or you can access the desired files via the GitHub
    user interface.
  prefs: []
  type: TYPE_NORMAL
- en: How the sliding window size affects the iSAX construction speed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to continue working with the `accessSplit.py`
    utility we developed in the previous chapter to find out whether the sliding window
    size affects the construction speed of an iSAX index, provided that the remaining
    iSAX parameters stay the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Put simply, we will use different methods to find out more about the quality
    of iSAX indexes and whether the sliding window size affects the construction speed.
    We are going to perform our experiments using the following sliding window sizes:
    `16`, `256`, `1024`, `4096`, and `16384`. We are going to experiment using the
    `500k.gz` time series from [*Chapter 4*](B14769_04.xhtml#_idTextAnchor102), 8
    segments, a maximum cardinality value of `32`, and a threshold value of `500`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the window size of `16`, the results are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For the sliding window size of `256`, the results are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Compared to the sliding window size of `16`, the iSAX index created using a
    sliding window size of `256` had more than three times the number of splits and
    four times the number of subsequence accesses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, for the window size of `1024`, the results are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As before, we have more splits than the `16` and `256` sliding window sizes
    and more subsequence accesses. Put simply, it took more CPU time for this iSAX
    index to be constructed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, for the window size of `4096`, the results are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this case, it is not only slower to construct the iSAX index but we also
    have an `500.gz` time series are not going to fit into an iSAX index with these
    parameters and we are going to need to use different iSAX parameters for the iSAX
    index to work.
  prefs: []
  type: TYPE_NORMAL
- en: Do overflows have an impact on the construction of iSAX indexes?
  prefs: []
  type: TYPE_NORMAL
- en: When we have one or multiple overflows on an iSAX index, it means that the full
    cardinality has been used on all SAX words—recall that the number of SAX words
    is defined by the number of segments. Therefore, we have multiple splits on terminal
    nodes that are fully based on the current threshold value, which means that we
    have many more subsequence accesses than usual. Therefore, overflows have a great
    impact on the construction time of iSAX indexes. Additionally, as if this were
    not bad enough, we have to find new iSAX parameters that prevent the overflow
    from happening while keeping the iSAX operation efficient. Keep in mind that the
    number of splits is also a naïve indication of how close we are to an overflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, for the biggest window size (`16384`), the results are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we have an overflow situation with the sliding window size of `16384`,
    this time on a different SAX representation. We are going to leave both overflows
    as they are and create some plots of the results. The resolution of the overflows
    is left as an exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5**.1* shows the number of splits per sliding window size where we
    can see that the bigger the sliding window size, the larger the number of splits
    that take place for that particular time series.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1– Splits per sliding window size plot](img/Figure_5.1_B14769.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1– Splits per sliding window size plot
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5**.2* shows the number of subsequence accesses per sliding window
    size. In this case, instead of plotting the absolute number of subsequence accesses,
    we divide the number of total subsequence accesses by the total number of subsequences
    to display a fraction. This is a fair calculation as bigger time series have a
    larger number of subsequences.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Subsequence accesses percentage per sliding window size plot](img/Figure_5.2_B14769.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Subsequence accesses percentage per sliding window size plot
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 5**.2*, we can see that the bigger the sliding window size, the bigger
    the number of subsequence accesses. For the smallest sliding window (`16`), we
    have about eight times fewer accesses to the subsequence of the time series compared
    to the largest sliding window (`16384`).
  prefs: []
  type: TYPE_NORMAL
- en: The construction speed of an iSAX index is one important factor. However, it
    is not the only criterion for the quality of iSAX indexes. The next section investigates
    the search speed of iSAX indexes.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the search speed of iSAX indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section presents a utility that takes two time series, named `TS1` and
    `TS2`, which ideally have similar lengths, creates two iSAX indexes, named `D1`
    and `D2`, and performs the following searches:'
  prefs: []
  type: TYPE_NORMAL
- en: Searches `D1` for all the subsequences of `TS2`. In this case, we are not sure
    whether a subsequence from `TS2` is in `D1` or not. In most cases, *we are not
    going to be able to find the subsequences of TS2 in TS1*. This is the main reason
    that a *join* based on the SAX representations of the iSAX nodes might be more
    appropriate when looking for similarities between subsequences.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searches `D2` for all the subsequences of `TS1`. In this case, we are not sure
    whether a subsequence from `TS1` is in `D2` or not. As before, in most cases,
    we are not going to be able to find the subsequences of `TS1` in `TS2` and therefore,
    in the iSAX index created from `TS2` (`D2`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searches `D1` for all the subsequences of `TS1`, which means that all subsequences
    of `TS1` are in `D1`. With that test, we just want to discover more about the
    speed of an iSAX index when performing search operations. This search operation
    mainly depends on the threshold size because a bigger threshold value means more
    subsequences to look for once we come to the appropriate terminal node.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searches `D2` for all the subsequences of `TS2`, which means that all subsequences
    of `TS2` are in `D2` and are going to be found.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these searches are implemented in a Python script named `speed.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The core functionality of `speed.py` is implemented in functions. The first
    function contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `createISAX()` function creates an iSAX index and returns a link to an `isax.ISAX()`
    class as well as a NumPy array with all the elements of the time series.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second function is implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first part of `query()`, we construct the SAX representation of a potential
    child of the root node of the iSAX index using `tools.lowerCardinality()` and
    `segs`. From that, we construct the `lower_cardinality_str` string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the second part of `query()`, we check whether the `lower_cardinality_str`
    key can be found in the iSAX index.
  prefs: []
  type: TYPE_NORMAL
- en: If it can be found, then we follow that subtree, which begins with a child of
    the root node of the iSAX index, until we find the appropriate terminal node.
    If it cannot be found, then we have a miss, and the process terminates.
  prefs: []
  type: TYPE_NORMAL
- en: The `query()` function returns `True` if the subsequence is found and `False`
    otherwise. Its second return value is the number of subsequence accesses that
    took place while trying to find that query subsequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the code of `speed.py` is placed in the `main()` function and is
    going to be presented in three parts – the first part being the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this first part, we construct the two iSAX indexes and store the number of
    splits and accesses to subsequences.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of `speed.py` contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this part of the program, we query the first iSAX index. In the first `for`
    block, we search iSAX for all the subsequences of the first time series. As this
    iSAX indexes the first time series, all subsequences are going to be found in
    the iSAX index. While doing that, we store the number of accesses to subsequences,
    which is returned by the `query()` function. In the second `for` block, we do
    the same but this time, for the second time series. Therefore, there is a small
    possibility of finding the subsequences of the second time series (`TS2`) in the
    iSAX index of the first time series (`TS1`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `speed.py` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This last part of `main()`is similar to the previous code. The only difference
    is that this time, we query the second iSAX index instead of the first one. Once
    again, we store the number of accesses to subsequences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before running `speed.py`, we need to create another time series, which is
    going to be stored in `506k.gz`. In this case, the second time series was created
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Although the two time series do not need to have the same length, we have decided
    to make them pretty close in length.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `speed.py` generates the following kind of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that the previous command took *more than three hours* on a MacBook
    Pro machine! The speed will depend on your CPU.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we used different SAX parameters, the output would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Although the first run of `speed.py` required 1,106 splits and the second one
    2,034 splits, both results were close as far as the total number of subsequence
    accesses is concerned.
  prefs: []
  type: TYPE_NORMAL
- en: As expected, the number of total queries is the same in both cases because we
    are dealing with the same time series and, therefore, the same number of subsequences.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to perform lookups and searches on iSAX indexes, it is
    time to learn about another important operation, which is the joining of iSAX
    indexes.
  prefs: []
  type: TYPE_NORMAL
- en: Joining iSAX indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we have iSAX indexes that we want to use to perform basic time
    series data mining tasks. One of them is **finding similar subsequences** between
    two or more time series. In our case, we are working with two time series, but
    the method can be extended to more time series with small changes.
  prefs: []
  type: TYPE_NORMAL
- en: How to join iSAX indexes
  prefs: []
  type: TYPE_NORMAL
- en: Given two or more iSAX indexes, it is up to us to decide how and why we are
    going to join them. We can even join them using SAX representations with a cardinality
    value of `2`. However, using the SAX representations of the nodes as our keys
    for the join is the most logical choice.In our case, we are going to use the iSAX
    indexes and the SAX representations of the nodes to look for similar subsequences.
    This is because we have the intuition that subsequences in nodes with the same
    SAX representation are *close* to each other. The term *close* is defined relative
    to a **distance metric**. For the purposes of this chapter, we are going to use
    the Euclidean distance to compare subsequences of the same size.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us rephrase that in a more precise way. A **join** of two iSAX indexes
    that is based on the SAX representation is a way of finding the most similar node
    (based on the SAX representation) for each of the nodes of the first iSAX index
    when searching the nodes of the second iSAX index, which was constructed using
    the same parameters. This way, we save time because we only have to compare subsequences
    of similar terminal nodes. Is similarity based on SAX representation perfect?
    No, it is not. But we are using a time series index to make things faster.
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind this join came after reading the *Scalable Hybrid Similarity
    Join over Geolocated Time Series* paper, which was written by Georgios Chatzigeorgakidis,
    Kostas Patroumpas, Dimitrios Skoutas, Spiros Athanasiou, and Spiros Skiadopoulos.
  prefs: []
  type: TYPE_NORMAL
- en: The next section is going to show how to implement the joining of iSAX indexes
    based on the SAX representations of their nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the joining of iSAX indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the implementation of the iSAX index join, we are going to assume that we
    have two iSAX indexes ready to be used saved in two separate Python variables,
    and continue from there. We are going to need a Python function that accepts two
    iSAX indexes and returns a list of Euclidean distances, which are the nearest
    neighbors of all subsequences in both time series. Keep in mind that if a node
    from one of the iSAX indexes does not match the other iSAX index, then that node,
    and as a consequence its subsequences, is not going to get processed. Therefore,
    the list of Euclidean distances might be a little shorter than expected. That
    is the main reason why we must not use unnecessarily big iSAX parameters. Put
    simply, do not use 16 segments when 4 segments can do the job.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, keep in mind that the real nearest neighbor of a subsequence might
    not be located in the terminal node with the same SAX representation – this is
    the price we pay for the extra speed and avoiding the quadratic processing cost
    (comparing every subsequence of the first time series with all subsequences of
    the second time series, and vice versa).
  prefs: []
  type: TYPE_NORMAL
- en: So, we need to implement the previous functionality for the `isax` package based
    on the current implementation and representation of the iSAX index.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, we are going to put that functionality inside the `isax` package,
    using a separate file named `iSAXjoin.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from that file, we added a function for calculating the Euclidean distance
    between two subsequences in `isax/tools.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If you recall from [*Chapter 1*](B14769_01.xhtml#_idTextAnchor015), in the `ch01/ed.py`
    script, `euclidean()` uses the magic of NumPy to calculate Euclidean distances
    between two subsequences. Do not forget that we always compare **normalized subsequences**
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we added the following variable to `isax/variables.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `ED` global variable is a Python list used to hold the result of the join
    between two iSAX indexes, which is a list of Euclidean distances.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now present and explain the code of `isax/iSAXjoin.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the Python code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code in `iSAXjoin.py` is going to be presented in five parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `Join()` function is the entry point to the join of the two iSAX indexes.
    However, that function has a single purpose, which is creating all the combinations
    between the children of the two iSAX root nodes in order to pass control to `_Join()`.
    As the order of the arguments in `_Join()` is significant, `_Join()` is called
    two times. The first time, a root child node from the first iSAX index is the
    first parameter, and the second time, a root child node from the second iSAX index
    is the first parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of `iSAXjoin.py` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: When we are dealing with inner nodes from both iSAX indexes, we just combine
    all their children – remember that each inner node has two children – and recursion
    takes care of the rest.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If we are dealing with an inner node and a terminal node, we expand the inner
    node, and recursion takes care of the rest.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth part of `iSAXjoin.py` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As before, when dealing with an inner node and a terminal node, we expand the
    inner node, and recursion takes care of the rest.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part comes with the following Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This last part is where the recursive calling to `_Join()` stops because we
    are dealing with two terminal nodes. This means that we are able to calculate
    the Euclidean distances of their subsequences. The fact that we are not normalizing
    the subsequences before calling `tools.euclidean()` means that we expect to have
    the subsequences in all terminal nodes in a normalized form. Notice that we store
    the results in the `variables.ED` list.
  prefs: []
  type: TYPE_NORMAL
- en: That is all regarding the implementation of the joining of two iSAX indexes.
    The next section covers how to use the (similarity) join code.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Python code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to use the similarity join code we have developed
    to start joining iSAX indexes. The source code of `join.py` is presented in three
    parts. The first part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Nothing new here – we just have to import the necessary external packages, including
    `isax.iSAXjoin`, and develop a function that creates an iSAX index given a time
    series file and a sliding window size. The function returns the root node of the
    iSAX index. However, please note that *subsequences are stored in their normalized
    form* inside all `TS()` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part is the beginning of the `main()` function and comes with the
    following Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As we are joining two iSAX indexes, we need two separate command-line arguments
    (`TS1` and `TS2`) to define the paths of the compressed plain text files with
    the time series data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `join.py` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create the two iSAX indexes by calling `buildISAX()` two times and
    then join them using `Join()`, which returns no values. In order to look at the
    list of computed values, we need to access `variables.ED`. We print the length
    of the list of Euclidean distances as well as the theoretical maximum length of
    it, which is equal to `time_series_length – sliding_window_size + 1`, to have
    a better idea of the number of subsequences without a match. In the output, we
    also print the time it took to create each iSAX index as extra information about
    the process.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we are ready to use `join.py`. This means that we should provide
    it with the necessary parameters and input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `join.py` produces the following kind of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: So, it took `170.94` seconds to create the first index and `179.80` seconds
    to create the second iSAX index. The list of Euclidean distances has `970603`
    elements, whereas the maximum number of elements is `1006188`, which means that
    we missed some terminal nodes because their SAX representation did not have a
    match in the other iSAX index. This is not unusual and we should expect it most
    of the time as time series and their iSAX indexes differ.
  prefs: []
  type: TYPE_NORMAL
- en: We have a long list of Euclidean distances, so what?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You might be asking, “What do we do with that list of Euclidean distances?”
    Put simply, what is the main purpose of creating such a list of distances? There
    are many uses, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Finding out how close two time series are by finding the minimum Euclidean distance
    in the list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding out the list of Euclidean distances that are in a given numeric range.
    This is another way of comparing the similarity of two time series.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding subsequences that are more different than others based on a distance
    measure. In data mining terminology, these subsequences are called **outliers**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I think you get the idea of why we perform the join computation – we need to
    be able to better understand the connection between the two time series involved
    in the join. The reason for using the SAX representation is to prune nodes and
    subsequences and save CPU time.
  prefs: []
  type: TYPE_NORMAL
- en: As the joining operation can be slow, the next subsection presents a handy technique
    for saving the list of Euclidean distances on disk and loading the list from disk
    in order to use it without having to carry out the entire process from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Saving the output
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The joining of iSAX indexes can take time. Is there a way to make that process
    less painful? Yes, we can save the contents of the similarity join, which is a
    list, into a file, which saves us from having to recreate that list from scratch
    each time we need it. Keep in mind that for this to work, the two iSAX indexes
    must be created with the same parameters for the exact same time series.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `saveLoadList.py` script demonstrates the idea in the `main()` function
    – you can see the implementation of `buildISAX()` in `join.py`. The first part
    of `main()` is as follows. Some code is omitted for brevity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we put the similarity join data into `variables.ED` by
    calling `Join()` from `isax.iSAXjoin` and printing its length. After that, we
    computed the filename of the output file that is saved in the `filename` variable,
    which is based on the parameters of the program. This is a handy way of creating
    `variables.ED` into that file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of `main()` contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we tried to read the filename that we used for storing
    the contents of `variables.ED` and put the contents of the plain text file into
    the `PQ` variable. Lastly, we printed the length of `PQ` in order to compare it
    with the length of `variables.ED` and make sure that everything worked as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the `saveLoadList.py` script generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: From the previous output, we understand that the list contains `970603` elements.
    Additionally, the filename where we saved the contents of the list is `List_500k.gz_506k.gz_32_8_16.txt`.
    The only information missing from the filename is the threshold value.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection presents a utility that finds the nodes of an iSAX index
    that do not have a match in another iSAX index, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Finding iSAX nodes without a match
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this subsection, we specify the nodes of an iSAX index that do not have a
    match in another iSAX index, and vice versa. In reality, we are going to print
    the SAX representations of the terminal nodes of each iSAX index that do not have
    a match to a terminal node on the other iSAX.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `noMatch.py` script implements the idea using the following code – we assume
    that we have already created two iSAX indexes for the two time series so that
    we do not have to repeat the code for creating iSAX indexes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The previous code visits all the nodes of the first iSAX index looking for terminal
    nodes. Once a terminal node is found, we get its SAX representation and look in
    the other iSAX index for a terminal node with the same SAX representation. If
    such a node cannot be found, we print the SAX representation of the terminal node
    of the first iSAX index that does not have a match.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should now use the same process for the second time series and the second
    iSAX index. The code presented here is similar to the previous one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: So, right after examining the second iSAX index, we print the total number of
    terminal nodes without a match.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `noMatch.py` generates the following kind of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As we are using the same promotion strategy for both iSAX indexes, the output
    shows that the two iSAX indexes have a different structure, hence the dissimilarities
    in the list of SAX representations without a match on the second iSAX index. Additionally,
    we can see that the maximum cardinality in the printed SAX representations is
    just `8` and that most SAX words have a cardinality of `4`, which means that there
    were not so many splits.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, keep in mind that, in general, the smaller the number of segments in
    a SAX representation, the smaller the number of nodes without a match is going
    to be. Additionally, the larger the threshold value, the smaller the number of
    nodes without a match is going to be, because large threshold values minimize
    splits. In general, *the smaller the number of possible SAX representations is,
    the smaller the number of nodes without a match is going* *to be*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be seen in the following output, where we have reduced the number
    of segments to `4` and increased the cardinality to `64`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we have fewer terminal nodes without a match.
  prefs: []
  type: TYPE_NORMAL
- en: The next section briefly touches on the topic of testing Python code by writing
    three basic Python tests for the `isax` package.
  prefs: []
  type: TYPE_NORMAL
- en: Writing Python tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this last section of this chapter, we are going to learn about Python testing
    and write three tests for our code with the help of the `pytest` package.
  prefs: []
  type: TYPE_NORMAL
- en: As the `pytest` package is not installed by default, the first task you should
    carry out is installing it using your favorite method. Part of the `pytest` package
    is the `pytest` command-line utility, which is used for running the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are writing unit tests, which are usually functions that
    we write to make sure that our code works as expected. The result of a unit test
    is either `PASS` or `FAIL`. The more extensive the unit testing is, the more useful
    it is.
  prefs: []
  type: TYPE_NORMAL
- en: 'After a successful installation, if you execute the `pytest` command on a directory
    that does not contain any valid tests, you are going to get information about
    your system and your Python installation. On a macOS machine, the output is the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As far as testing functions are concerned, there is a simple rule that you have
    to keep in mind. A testing function when using the `pytest` package is any Python
    function that is prefixed with `test_` in a file where its filename is also prefixed
    by `test_`.
  prefs: []
  type: TYPE_NORMAL
- en: There are many tests that could be written. Usually, we want to test as much
    as possible, starting from the most critical parts of the code and moving to the
    less critical ones. For the purposes of this chapter, we have decided to test
    the core logic of the implementation by writing three tests.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection talks about the three tests that we are going to implement
    in this chapter in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: What are we going to test?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing to define is what we are going to test and why. For this chapter,
    we are going to write the following three tests:'
  prefs: []
  type: TYPE_NORMAL
- en: We are going to count the number of subsequences in an iSAX index and make sure
    that the iSAX index holds all the subsequences.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to test the number of node splits of an iSAX construction – this
    time, the correct number of splits is going to be stored in a global variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, we are going to join the same time series with itself. This means that
    we should get a list of Euclidean distances where all values are equal to 0\.
    Keep in mind that as we are talking about floating-point numbers, the Euclidean
    distances might be very close to 0 but not exactly 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list of tests is far from complete, but it is a good way to illustrate the
    use and usefulness of tests.
  prefs: []
  type: TYPE_NORMAL
- en: The filenames of the time series and the iSAX parameters, as well as the number
    of splits and subsequences, are going to be given as global variables in the source
    code file that holds the testing code for reasons of simplicity. If you want to
    dynamically pass parameters to `pytest` tests, visit the *Basic patterns and examples
    of pytest* link in the *Useful links* section at the end of the chapter for more
    information.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing the number of subsequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this test, we compare the number of subsequences in an iSAX index to the
    theoretical number of subsequences based on the sliding window size and the time
    series length.
  prefs: []
  type: TYPE_NORMAL
- en: 'The relevant code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: First, we appropriately set the global variables in `./isax/variables.py` based
    on the global values found in the preamble of `test_isax.py`.
  prefs: []
  type: TYPE_NORMAL
- en: The `createISAX()` helper function is used to create iSAX indexes for testing.
    You have seen that function before in the `speed.py` utility.
  prefs: []
  type: TYPE_NORMAL
- en: What is important and closely related to the test is the use of the `assert`
    keyword. `assert` checks the trueness of the statement that follows. If the statement
    is `True`, then the `assert` statement passes. Otherwise, it throws an exception,
    and as a result, the test function fails. The `assert` keyword is used in all
    our test functions.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to discuss the test that checks the number of node splits.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the number of node splits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the purposes of this test, we assume that we have a different program in
    any programming language that we consider correct that gives us the actual number
    of node splits. This number of node splits is stored in a global variable (`splits`)
    and read by the test function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The relevant Python code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we first appropriately set the global variables in `./isax/variables.py`
    based on the global values found in `test_isax.py`. Do not forget to reset `variables.nSplits`
    and select the correct promotion strategy (`variables.defaultPromotion`) in your
    test function.
  prefs: []
  type: TYPE_NORMAL
- en: The last test function computes the join of a time series with itself, which
    means that all Euclidean distances after the join should be equal to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: All Euclidean distances are 0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this test, we are going to create the iSAX index of a time series and join
    it with itself. As we are comparing a time series with itself, the list of Euclidean
    distances should only *contain zeros*. Therefore, with this unit test, we examine
    the logical correctness of our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The relevant Python test function is implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: First, we appropriately set the global variables in `./isax/variables.py` based
    on the global values found in `test_isax.py`. After that, we call `createISAX()`
    to construct the iSAX index and then call the `Join()` function to populate the
    list of Euclidean distances.
  prefs: []
  type: TYPE_NORMAL
- en: The NumPy `zeros()` function creates a NumPy array with all zeros. Its parameter
    defines the length of the NumPy array that is going to be returned. The NumPy
    `allclose()` function returns `True` if its two NumPy array arguments are equal
    within a tolerance. This is mainly the case because when using floating-point
    values, there might be small differences due to rounding.
  prefs: []
  type: TYPE_NORMAL
- en: In the next subsection, we are going to run the tests and see the results.
  prefs: []
  type: TYPE_NORMAL
- en: Running the tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to run the tests and see their results. All the
    previous code can be found in the `./``ch05/test_isax.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The results of the tests, which are all successful, are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case that there were one or more failed tests, the output would look
    like the following (in this case, only one test failed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The good thing is that the output shows the reason that one or more tests have
    failed and includes the relevant code. In this case, it is the `assert variables.nSplits
    == splits` statement that failed.
  prefs: []
  type: TYPE_NORMAL
- en: This is the last section of this chapter, yet the most important one, as testing
    can save you lots of time during development. The main purpose of our tests is
    to test the logic and the correctness of the code, which is very important.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen code for testing the speed of an iSAX index and
    joining two iSAX indexes based on the SAX representations of their nodes. Then,
    we briefly discussed the subject of testing Python code and implemented three
    tests for the `isax` package.
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed the joining of iSAX indexes, which is based on the node types.
    Additionally, the tests we carried out made sure that the core logic of our code
    is correct.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn how to visualize iSAX indexes to
    better understand their structure and performance.
  prefs: []
  type: TYPE_NORMAL
- en: Before you start reading and working through [*Chapter 6*](B14769_06.xhtml#_idTextAnchor145),
    experiment with the command-line utilities that we have developed in this chapter
    and try to create your own.
  prefs: []
  type: TYPE_NORMAL
- en: Useful links
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `pytest` package: https://pypi.org/project/pytest/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Official `pytest` documentation: [https://docs.pytest.org/](https://docs.pytest.org/%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Practices of the Python Pro*, written by Dane Hillard'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mastering Python, 2nd Edition*, written by Rick van Hattem'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Robust Python: Write Clean and Maintainable Code*, written by Patrick Viafore'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Python Testing with pytest, 2nd Edition*, written by Brian Okken'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Basic patterns and examples of `pytest`: [https://docs.pytest.org/en/latest/example/simple.xhtml](https://docs.pytest.org/en/latest/example/simple.xhtml%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Try to work through the following exercises:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `accessSplit.py` to learn how the sliding window size affects the construction
    speed of the `2M.gz` time series from [*Chapter 4*](B14769_04.xhtml#_idTextAnchor102).
    Perform your experiments for the following sliding window sizes: `16`, `256`,
    `1024`, `4096`, `16384`, and `32786`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can you resolve the overflow situations with `accessSplit.py` and the `500.gz`
    time series we came across at the beginning of the chapter?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try reducing the threshold values in the `speed.py` examples presented in the
    *Checking the search speed of iSAX indexes* section and see what happens.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create two time series with 250,000 elements each and use `speed.py` to understand
    their behavior when the number of segments is in the 20 to 40 range. Do not forget
    to use an appropriate sliding window size.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Experiment with `speed.py` but this time, change the threshold value instead
    of the number of segments. Is the threshold value more important than the number
    of segments in the search speed of an iSAX index?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify `speed.py` to display the number of misses in subsequence queries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify `join.py` to print the time it took to perform the join.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify `saveLoadList.py` to include the threshold value in the filename where
    we save the contents of the list with the Euclidean distances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the `pytest` command on your own machines and see the output that you get.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
