- en: Adding Interactivity with Dashboards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shiny enables you to write powerful interactive web applications entirely in
    R. Using R, you can create a user interface and server, and Shiny will compiler
    your R code into the HTML, CSS, and JavaScript code needed to display your application
    on the web. What makes a Shiny application particularly powerful is that it can
    execute R code on the backend, so your application can perform any R calculation
    you can run on your desktop. You may want your application to process some data
    based on user inputs and provide some interactivity to make data analysis more
    intuitive.  In this chapter, we will show you how to accomplish this.
  prefs: []
  type: TYPE_NORMAL
- en: Shiny implements the *functional reactive programming* paradigm that powers
    many of today's most modern web applications. We will explain what it is and how
    it works within Shiny. We will show how to work with streams of events coming
    from application users and how to react to them accordingly. To do so, we will
    work through an example that receives inputs from users and provides data and
    graphs in return. By the end of the chapter, you'll realize how easy it can be
    to create powerful web applications that take your R skills to the next level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the important topics covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The Shiny web applications architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The functional reactive programming paradigm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How reactivity is implemented within Shiny
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receiving inputs from users interactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending outputs in responses to the web browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding interactions to Shiny applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Required packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already worked with the first two packages, namely `ggplot2` and `lubridate.`
    The `shiny` package is used to build web applications directly from R, while the
    `shinythemes` and `ggthemr` packages are used to apply themes to style our web
    application. For more information, take a look at [Appendix](part0296.html#8Q96G0-f494c932c729429fb734ce52cafce730),
    *Required Packages*. Required packages for this chapter are shown in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Package** | **Reason** |'
  prefs: []
  type: TYPE_TB
- en: '| `ggplot2` | High-quality graphs |'
  prefs: []
  type: TYPE_TB
- en: '| `lubridate` | Easily transform dates |'
  prefs: []
  type: TYPE_TB
- en: '| `shiny` | Create modern web applications |'
  prefs: []
  type: TYPE_TB
- en: '| `ggthemr` | Apply themes to `ggplot2` plots |'
  prefs: []
  type: TYPE_TB
- en: '| `shinythemes` | Apply themes to Shiny applications |'
  prefs: []
  type: TYPE_TB
- en: Introducing the Shiny application architecture and reactivity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In its simplest form, a Shiny application requires a server and a **user interface** (**UI**).
    These components form the basic architecture behind all Shiny applications. The
    `ui` object controls the layout and appearance of your application, and the `server` function
    contains the logic needed by the application. If you know how web applications
    work, you can think of them as the *frontend* and the *backend,* respectively.
    The `shinyApp()` function creates and launches a Shiny application from an explicit
    UI/server pair. It will compile R code into web-friendly languages HTML, JavaScript,
    and CSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Below we have the simplest possible Shiny application, which has an empty server
    and a UI with a basic message. If you are in an interactive R session, your web
    browser should launch and show the application. If it doesn''t, you can navigate
    to the URL yourself, which is in the form `http://127.0.0.1:6924/`, where `127.0.0.1`
    is the IP of your own computer and `6924` is the port Shiny is using to listen
    for connections. As you can see in your web browser, it is nothing amazing, but
    it''s a functioning web application created only using R:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Having a fixed port, instead of a randomly assigned port, which changes on every
    `shinyApp()` call, makes development easier. To use a fixed port, change the function
    call to `shinyApp(ui, server, options = list(port = 6924))` with a port of your
    preference.
  prefs: []
  type: TYPE_NORMAL
- en: Note that your R session will be busy while the application is active, so you
    will not be able to run any R commands. R is monitoring the application and executing
    the application's reactions. To get your R session back, press *Ctrl* + *C*, or
    if you are using RStudio, click on the stop sign icon.
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity, we're creating our Shiny applications in a single file. However,
    with bigger applications, you will likely split the components into `ui.R` and
    `server.R` files (which are the standard files used for Shiny applications).
  prefs: []
  type: TYPE_NORMAL
- en: As we will see throughout the chapter, Shiny provides a great paradigm for developing
    web applications which is used in many cutting-edge systems nowadays. It's known
    as *functional reactive programming*. It's not a simple concept to grasp, but
    it's very powerful, and we will learn to use its fundamentals in this chapter.
    However, before we do, I will try to provide a simple explanation of what it is
    and how it works within Shiny.
  prefs: []
  type: TYPE_NORMAL
- en: What is functional reactive programming and why is it useful?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with the reactive programming part. **Reactive programming** is
    programming with *asynchronous data streams*. We start by defining these terms
    at a general level.
  prefs: []
  type: TYPE_NORMAL
- en: A *stream* is a sequence of ongoing events ordered in time. In reality, almost
    anything can be thought of as a stream, but simple examples are balls bouncing,
    where an *event* is considered every time a ball hits the floor. It can happen
    repeatedly many times, without specific patterns, stop for a while, then continue,
    and then stop again. Users clicking in a website is also a *stream*, where each
    click is an *event*. As you can imagine, there are *streams* everywhere around
    us.
  prefs: []
  type: TYPE_NORMAL
- en: The other term that needs to be defined is *asynchronous,* which literally means
    *without syncronization.* Normally, *synchronous* functions wait at the line of
    a function call until the function being called is finished executing, possibly
    returning a value. This is the way we have been programming so far. However, *asynchronous*
    functions don't necessarily wait for the functions they call to be finished. This
    means that our functions need to *react* to it whenever it arrives.
  prefs: []
  type: TYPE_NORMAL
- en: If we join these two terms, we can understand that programming with *asynchronous
    data streams* works by writing code that is able to react to *events* as they
    happen, continuously and randomly. In the case of this chapter, these *events*
    will be user interactions (clicks or keystrokes) with our application, which means
    that our R code will be responding directly to these clicks and keystrokes as
    they happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'If it is still hard to get a grasp on the idea, think about it as a spreadsheet
    with formulas. When you change a value that other cells depend on or are listening
    to (analogous to receiving some input from a user in our application), then other
    cells react accordingly and present the newly computed value (which will be output
    change we show to the user). It''s really that simple. The *listening* to the
    stream is called **subscribing.** The functions we are defining are *observers*,
    and the stream is the *observable* being *observed*. This is precisely the *Observer
    Design Pattern*. Take a look at Gamma, Helm, Johnson, and Vlissides''s book *Design
    Patterns: Elements of Reusable Object-Oriented Software, by Addison-Wesley, 1994*.'
  prefs: []
  type: TYPE_NORMAL
- en: On top of that, you are given a great set of tools that allows you to create,
    filter, and combine any of these *streams.* That's where the *functional programming*
    magic kicks in. Functional programing allows for composition, and that's exactly
    what we will use it for, to *compose streams*. A *stream* can be used as an input
    to another one. Even multiple *streams* can be used as inputs to many others.
    Furthermore, you may use any of these raw or transformed streams anywhere in your
    code. That's really what makes Shiny such a great tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**Functional Reactive programming** raises the level of abstraction of your
    code, so you can focus on the interdependence of events that define your application''s
    logic, rather than having to constantly fiddle with a large amount of implementation
    details. *Functional-reactive* code is also likely to be more concise.'
  prefs: []
  type: TYPE_NORMAL
- en: The benefit is more evident in modern applications that are highly interactive.
    Applications nowadays have an abundance of real-time events that enable a highly
    interactive experiences, and *functional reactive programming* is a great tool
    for that.
  prefs: []
  type: TYPE_NORMAL
- en: How is functional reactivity handled within Shiny?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactivity is what makes your Shiny applications responsive. It seems like the
    application instantly updates itself whenever the user makes a change. However,
    in reality, Shiny is rerunning your R expressions in a carefully scheduled way
    every couple of microseconds, which creates the illusion of responsiveness. You
    don't need to know how reactivity occurs to use it, but understanding reactivity
    will make you a better Shiny programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that when we executed our very simple Shiny application in a previous
    section, the R console stopped being interactive? Well, that was happening because
    executing the `shinyApp()` function makes R busy by constantly monitoring and
    updating expressions as necessary, which is what creates the responsive experience
    for users.
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine you have a complex application with lots of interactivity, then
    running every expression every couple of microseconds would completely saturate
    your processor, and your users would have a terrible user experience. That's why
    Shiny needs to be smart enough to only update those expressions that require it.
    Whenever a user submits an action (*event*), expressions that handle such events
    become *invalidated,* effectively marking themselves as being in need of an *update,*
    and this behavior is propagated among all expressions that depend on them. When
    a few microseconds have passed, R will check which expressions are marked for
    being updated, and only update those.
  prefs: []
  type: TYPE_NORMAL
- en: The mechanism just described can reduce the number of expressions that are recomputed
    from thousands to none, in case there has not been any user action, and to a few
    at most, since it's very hard for a user to accomplish a lot in a few microseconds
    which in turn would result in a few required updates, instead of a full application
    update each time. This mechanism allows R to handle complex Shiny applications,
    and it's the key to reactivity. It allows the application to be updated as fast
    as possible, making input/output coordination almost instantly.
  prefs: []
  type: TYPE_NORMAL
- en: The building blocks for reactivity in Shiny
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The building blocks of reactivity in Shiny are built around three types of
    functions: input, output, and rendering functions. Input functions most of the
    time end with the `Input` string (not always) and I will refer to them as `Input()`
    functions. Output functions always end with the `Output` string and I will refer
    to them as `Output()` functions. Finally, rendering functions begin with the `render`
    string and similarly I will refer to them as `render*()` functions.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Input*()` functions are used within the `ui` object and they generate *reactive
    values*, which are values received from an interaction through a web browser,
    and are passed through the `input` parameter in the `server` function. The `render*()`
    functions are used within the `server` function and make use of *reactive values*
    to produce *observables* that go back into the `ui` object, through the `server`
    function''s `output` parameter. Finally, `*Output()` functions are used in the
    `ui` object to show the content of these observables in the web browser.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Reactive values* are received in the `server()` function through the `input`
    parameter, which is a list whose elements contain elements that are *linked* with
    the `ui` object through strings that act as unique identifiers. The `output` parameter
    in the `server` function is also a list, but it''s used to receive observables
    that will be sent to the web browser.'
  prefs: []
  type: TYPE_NORMAL
- en: Functions that know how to deal with *reactive values* are known as *reactive
    functions*. Not every R function is a reactive function, and they need special
    construction mechanisms provided by Shiny, and if you try to use a *reactive value*
    in a *non-reactive function*, you will get an error (this is an easy mistake when
    starting to use Shiny). The `render*()` functions are used to create reactive
    functions. Another way of doing so is with the `reactive()` function we will explain
    later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive functions are commonly used to generate observables that may be used
    by other reactive functions or by `render*()` functions. However, reactive functions
    can also produce side effects (for example, writing to a database). If reactive
    functions have `return` values, they are *cached* so that the function is not
    required to be re-executed if its corresponding *reactive values* have not changed.
  prefs: []
  type: TYPE_NORMAL
- en: The input, output, and rendering functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each `*Input()` function requires several arguments. The first one is a string
    with the name for the widget, which will only be used by you. The second one is
    a label which will be shown to the user in your application. The remaining arguments
    for each `*Input()` function vary depending on its functionality. They include
    things like initial values, ranges, and increments. You can find the exact arguments
    needed by a widget on the widget function''s help page, (for example, `? selectInput`).
    The following table shows all available `*Input()` functions with an indication
    of what they are used for:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **The** `Input*()` **function** | **Use** |'
  prefs: []
  type: TYPE_TB
- en: '| `actionButton()` | Action button |'
  prefs: []
  type: TYPE_TB
- en: '| `checkboxGroupInput()` | Group of checkboxes |'
  prefs: []
  type: TYPE_TB
- en: '| `checkboxInput()` | Single checkbox |'
  prefs: []
  type: TYPE_TB
- en: '| `dateInput()` | Date selection |'
  prefs: []
  type: TYPE_TB
- en: '| `dateRangeInput()` | Date range selection |'
  prefs: []
  type: TYPE_TB
- en: '| `fileInput()` | File upload |'
  prefs: []
  type: TYPE_TB
- en: '| `helpText()` | Help text for input forms |'
  prefs: []
  type: TYPE_TB
- en: '| `numericInput()` | Numeric input field |'
  prefs: []
  type: TYPE_TB
- en: '| `radioButtons()` | Set of options in radio buttons |'
  prefs: []
  type: TYPE_TB
- en: '| `selectInput()` | Set of options in drop-down |'
  prefs: []
  type: TYPE_TB
- en: '| `sliderInput()` | Numeric input slide bar |'
  prefs: []
  type: TYPE_TB
- en: '| `submitButton()` | Submit button |'
  prefs: []
  type: TYPE_TB
- en: '| `textInput()` | Text input field |'
  prefs: []
  type: TYPE_TB
- en: 'Each of the `*Output()` functions requires a single argument, which is a character
    string that Shiny will use to identify the corresponding *observer* from the `output`
    parameter in the `server` function. Users will not see this name, it will only
    be used by you. The following table shows the list of all the available `*Output()`
    functions with an indication of what they are used for. You may find more information
    about them using their corresponding help pages (for example, `? tableOutput`):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **The `*Output()` function** | **Use** |'
  prefs: []
  type: TYPE_TB
- en: '| `dataTableOutput()` | Data table |'
  prefs: []
  type: TYPE_TB
- en: '| `htmlOutput()` | Raw HTML |'
  prefs: []
  type: TYPE_TB
- en: '| `imageOutput()` | Images |'
  prefs: []
  type: TYPE_TB
- en: '| `plotOutput()` | Graphs |'
  prefs: []
  type: TYPE_TB
- en: '| `tableOutput()` | Tables |'
  prefs: []
  type: TYPE_TB
- en: '| `textOutput()` | Text |'
  prefs: []
  type: TYPE_TB
- en: '| `uiOutput()` | Raw HTML |'
  prefs: []
  type: TYPE_TB
- en: '| `verbatimTextOutput()` | Verbatim text |'
  prefs: []
  type: TYPE_TB
- en: 'Finally, each `render*()` function takes a single argument, an R expression
    surrounded by braces (`{}`). These expressions can contain one simple line of
    text or they can involve many lines of code and function calls. The following
    table shows the list of all `render*()` functions with an indication of what they
    are used for. You guessed it, you may find more information about them using their
    corresponding help pages (for example, ? `renderText`):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **The `render*()` function** | **Use** |'
  prefs: []
  type: TYPE_TB
- en: '| `renderDataTable()` | Data table |'
  prefs: []
  type: TYPE_TB
- en: '| `renderImage()` | Image |'
  prefs: []
  type: TYPE_TB
- en: '| `renderPlot()` | Graph |'
  prefs: []
  type: TYPE_TB
- en: '| `renderPrint()` | Any printed output |'
  prefs: []
  type: TYPE_TB
- en: '| `renderTable()` | Data frame, matrix, or other table-like structure |'
  prefs: []
  type: TYPE_TB
- en: '| `renderText()` | String |'
  prefs: []
  type: TYPE_TB
- en: '| `renderUI()` | Shiny tag object or HTML |'
  prefs: []
  type: TYPE_TB
- en: Shiny applications combine the `*Input()`, `*Output()`, and `render*()` functions
    to produce powerful web applications. The simplest applications will be composed
    of only reactive values and observers, without too much logic between them. However,
    it's also possible to place as many expressions as we want between them, which
    allows for more complex applications.
  prefs: []
  type: TYPE_NORMAL
- en: There are many more ways to work with reactivity in Shiny. A very friendly introduction
    video can be found at RStudio's *Learn Shiny* video tutorials ([https://shiny.rstudio.com/tutorial/](https://shiny.rstudio.com/tutorial/)).
  prefs: []
  type: TYPE_NORMAL
- en: Designing our high-level application structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That's enough theory, let's get to action building our own application. The
    application we will build will make use of the previous chapter, so if you haven't
    read that one, please do. The dashboard we will build will make more sense if
    you do. This dashboard will show graphs with the price data points from the previous
    chapter's data simulation, as well as the SMA calculations we developed. Furthermore,
    it will allow us to explore the price data using a dynamic table.. By *dynamic*,
    we mean that responds to user input.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a two-column distribution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The layout you choose to use for your application depends on its objectives.
    In this case, a two-column layout will suffice. To accomplish this, we use the
    `fluidPage()` function and assign it to the `ui` object. This function adjusts
    content according to the web browser''s dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00067.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Inside the `fluidPage()`, we use the `titlePanel()` function to provide a title
    for our application and the `sidebarLayout()` function to create a two-column
    layout. This last function requires two other functions to be called inside it
    to create the corresponding content for each column. These two functions are called
    `sidebarPanel()` and `mainPanel()`, and they receive the content we want to create
    inside of them as parameters. The column on the left will be used to display available
    options for users and the one on the right to show actual content as a result
    of the user inputs, so we use some strings as placeholders that describe exactly
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `fluidPage` simply generates HTML, which is sent to the web browser. You
    may print the `ui` object in the R console as we progress along the chapter to
    see the HTML it created.
  prefs: []
  type: TYPE_NORMAL
- en: This code will create a very basic structure as the one shown in the next image.
    As we move along, we will make the application more and more complex, but we need
    to start somewhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, nesting function calls will be a common pattern in the `ui`
    object to structure the application. This can be tricky, and if for some reason,
    you miss a comma (",") somewhere, you may find a cryptic message as the one shown
    . If that''s the case, making sure your commas are correctly placed is a good
    start for fixing this error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Introducing sections with panels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To show a section for graphs and a separate one for data tables, we will use
    the `tabsPanel()` function in conjunction with the `tabPanel()` function. The
    `tabsPanel()` function receives and arranges one or more `tablePanel()` function
    calls, where each of them receives the name for a tab and its actual content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we created two tabs with the titles, *Simple Moving Averages* and *Data
    Overview*, respectively, that''s what we see as the tab names. If you are running
    the application yourself at this point, you may click on them and you will see
    the `Content 1` or `Content 2` strings, depending on which one you click on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00068.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note that the `tabsetPanel()` function took the place of the `"Content"` string we
    previously had in its place. This will be a common pattern. As we start introducing
    more and more elements to the application, they will replace previous placeholders.
    Once you get used to Shiny, you may completely avoid the creation of placeholders.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting a dynamic data table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we will add a dynamic table with the data we simulated in the previous
    chapter, so first of all, we need to bring that data into the application, and
    we do so with the line shown below. You should place this data-loading line above
    the `ui` object in your app. This way, it will only be run once, when starting
    up the Shiny application, as any code that would normally be run when executing
    an R script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we need to introduce the `DT` package. It provides an easy way
    to create dynamic tables for Shiny applications. Since we will reference it through
    its package name, we don't need to load it with `library(DT)`. Referencing it
    by its package name helps us separate the native Shiny functions from those that
    come from external packages.
  prefs: []
  type: TYPE_NORMAL
- en: To implement this, we need to modify the `server` function we had not touched
    up to this point. We need to introduce some logic into it that will allow us to
    move data from R into the web interface. To accomplish this, we assign it to the
    `table` element in its `output` parameter, which will function as an observer.
    The element name we assign to it can be any valid list element we wish, but it's
    a good idea to just use names that describe the contents of the observer. Keep
    in mind that these names must be unique as Shiny will use them to identify what
    objects to pass back and forth between the `ui` object and the `server` function.
    The observer is created with the `renderDataTable()` function from the `DT` package.
    This function works as any other `render*()` function, it receives a single parameter,
    which is an expression that returns a value which will be the content of the observer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the data table created with the `datatable()` function, again
    from the `DT` package. To create this data table, we are simply passing the `ORIGINAL_DATA` object
    we loaded previously. Now that the server-side adjustment is finished, we add
    a `fluidRow()` instead of `"Content 2"` in the `ui` object to introduce a row
    that will adjust its length according to the web browser''s dimensions, and inside
    of it, we call the `dataTableOutput()` function from the `DT` package. Note that
    the string sent as the only parameter to this function is the name of the element
    we assigned to the `output` parameter in the `server` function. This is the mechanism
    that Shiny uses to move data from the `server` to the `ui`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now that our code is ready, we should see a table appear in the Data Overview tab.
    This table is dynamic in the sense that you may order its columns by clicking
    on the column titles, as well as change the number of observations shown, and
    search through its contents. Also note that a pagination mechanism was automatically
    added for us along with an observation counter. These tables are very easy to
    create, yet very useful, and we will see later in this chapter how to expand their
    functionality even more.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00069.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Introducing interactivity with user input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The interactivity we saw previously with the dynamic data table works within
    the web browser itself using JavaScript, and it does not need to go through the
    `server` function to provide the interactivity, only to pass the table itself.
    However, many interesting interactivity features need to go through the `server`
    so that we can provide custom responses for them. In this section, we show how
    to add various types of inputs to our application.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up static user inputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we will show how to filter the timestamps in the data to only show observations
    that fall within a range defined by the user. To do this, we need to first define
    four timestamps: the minimum, the initial left limit, the initial right limit,
    and the maximum. These four values will be used by our date range widget to define
    the allowed range for the user (the minimum and maximum values are used for this),
    as well as the initial date range (the initial left and right limits are used
    for this), which may be different from the limits of the allowed range.'
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we need to extract such values, and we do so by making use of the
    `TimeStamp` class we created in [Chapter 8](part0178.html#59O440-f494c932c729429fb734ce52cafce730),
    *Object-Oriented System to Track Cryptocurrencies*. Note that we use the `days()` function
    from the `lubridate` package (you should add the  `library(lubridate)` line at
    the top of your file), just as we did in the mentioned chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we only need to create these objects once, they should go just below the
    code that is used to load the `ORIGINAL_DATA`, before the `ui` object definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `timestamp_to_date_string()` function in the `TimeStamp` class had not
    been created and we added it for this chapter. It is very simple and is shown
    in the following code. Its objective is to simply get the first 10 characters
    of a `TimeStamp`, which correspond to the format YYYY-MM-DD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have created these objects, we may use the following code to expand
    the `ui` object. What we did was replace the `"Options"` string with a function
    call to `dateRangeInput()`, which is the function used to create a date range,
    as the name implies. It receives as parameters the unique identifier that will
    be used to retrieve its *reactive values* within the `server` through the `input`
    parameter, the `label` shown to the user, the `start`, `end`, `min`, and `max`
    values mentioned earlier, the `separator` we want to use among the web browser
    input boxes, the date `format` we want to use, and what day of the week it is
    considered to start on (`0` for Sunday, `1` for Monday, and so on):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: On the server side, we will add more logic within the *reactive experssion*
    passed as a parameter to the `datatable()` function. Instead of simply sending
    the raw `ORIGINAL_DATA` dataframe, we will filter it before we send it. To do
    so, we first assign a copy of it to the `data` object and extract the two date
    values from the widget we created in the `ui` object, using their references within
    the `input` parameter. Then, we check whether any of these is different from their
    initial values. In case they are, we update the `data` object with only those
    observations that are within the range specified, which we accomplish with a standard
    dataframe selection. Finally, we sent this filtered `data` to the `datatable()`
    function, and proceed as we did earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of these changes to the `ui` and `server` is that we can now filter
    the dates allowed in the dynamic table shown in the Data Overview tab, which is
    something we could not do before. The date range widget in action is shown in
    the following screenshot. Try to change its dates and see how the dynamic table
    updates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00070.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Setting up dynamic options in a drop-down
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we will see how to add a drop-down input whose entries adapt to the tab
    the user is currently viewing. Specifically, we will add the possibility for the
    user to select which asset they want to use to filter the data. If you looked
    carefully, you may have noticed that the dynamic data table contains observations
    for both Bitcoin and Litecoin, which may be fine when we're just looking at the
    table, but it will be a problem when we attempt to show a price time-series because
    we will have data for more than one asset. We want to provide a mechanism to select
    only one of them, but we want to keep the option of looking at all of them together
    in the dynamic data table, just as we are doing now.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by creating the object that contains the unique asset names we currently
    have in the data. This is much better than hardcoding their names directly into
    code, since they will be automatically updated when our data changes, which would
    not be the case if we hardcoded them. This line should go just below the previous
    *global* objects, which only needs to be created once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the input widget in this case has dynamic logic, we can''t just create
    inside the `ui` object, we need to create it in the `server` function and pass
    it along to the `ui` object. The way to do it is by introducing a new observer
    into the `output` parameter, named `select_asset` in this case, which is created
    with the `renderUI()` function since it will contain a Shiny `*Input()` function.
    As we did with the `data` in the previous section, we will assign the *default*
    asset names, and only in the case that the user is the second tab which is the
    Data Overview tab (more on where this comes from below), will it also add the
    `All` option to the drop-down. Otherwise, it will just keep the asset names without
    the `All` option, which is what we want for the SMA graphs we will create later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: To actually provide a mechanism for the `server` to understand what tab the
    user is currently viewing, the `ui` object needs to be adjusted so that the `tabsetPanel()`
    function receives an `id` parameter with the name of the object that contains
    the current tab number, `tab_selected` in this case (which is the name used to
    check in the `server` function). Also, each tab within must have a value assigned
    with the `value` parameter, as is shown. This way we make sure that the Data Overview tab
    is identified with the `2` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also note that we added the `htmlOutput()` function call within the just introduced
    `wellPanel()` function call in the `sidePanel()` function. The `wellPanel()` visually
    groups panels to provide more intuitive interfaces for users, and the `htmlOutput()`
    function uses the name of an observer to know what to show in the web browser,
    the `select_asset` element of the `output` object in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Having performed these changes, now we can see that our application shows an
    asset name drop-down with options `Bitcoin` and `Litecoin` when the user is in
    the Simple Moving Averagestab, and which also includes the `All` option when they
    are in the Data Overview tab, just as we wanted and as can be seen in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00071.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Setting up dynamic input panels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final two inputs we will introduce will be used for the SMA graphs later
    on. The first one is used to select which SMA implementation the user wants to
    use. The options are the `sma_efficient_1()`, `sma_efficient_2()`, `sma_delegated_fortran()`,
    and `sma_delegated_cpp()` functions we created in the previous chapter. The second
    one is used to define the period used for the SMA calculation, and which is used
    as input in one of the previous functions.
  prefs: []
  type: TYPE_NORMAL
- en: Since code can start being too repetitive and taking too much space, and since
    you have most likely understood the nesting patterns used in the creation of the
    `ui`, I will avoid repeating the full `ui` object declaration, and simply point
    where changes need to be made.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we want to add the following code after the `wellPanel()` function
    has ended and before the `sidebarPanel()` function ends. The following code will
    be the second parameter to `sidebarPanel()`, so don't forget to add a comma (",")
    after the `wellPanel()` function finishes, otherwise you will get an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `conditionalPanel()` function checks for a JavaScript condition, specified
    using a string, to decide whether or not a panel should be showed to the user.
    Since the `input` object is sent to the web browser through a JavaScript object
    conveniently named `input`, we can use that to get the value we''re looking for,
    which is whether or not the user is looking at the first tab, `"Simple Moving
    Averages"`. If she is, then we will show the panel:'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript uses the dot (".") notation to access elements instead of the `money`
    (`$`) notation used in R.
  prefs: []
  type: TYPE_NORMAL
- en: 'The panel shown is `wellPanel()` with two input objects inside: `radioButtons()` and
    `sliderInput()`. The first one receives the available options for the user in
    a list sent through the `choices` parameter (each element''s name is what is shown
    to the user, while each element''s value is used internally in R which are the
    SMA implementation names in this case), as well as the `selected` one by default.
    The second one receives the `min`, `max`, and default `value` for the numeric
    slider. Both receive the unique identifier and label as the first two arguments,
    as every other `*Input()` function does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We will leave the actual graphs creations for later, so we don''t need to change
    anything on the `server` side. At this point, the *reactive values* coming out
    of `input$sma_implementation` and `input$sma_period` will not be used. A screenshot
    showing how these inputs is shown as following. If you navigate to the Simple
    Moving Averages tab, they should be shown, but if you navigate to the Data Overview tab,
    they should be hidden:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00072.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, allowing users to interact with the application is not too hard,
    and is accomplished by using the `*Input()` functions in the `ui` object, whose
    *reactive values* in turn may be used in the `server` function.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a summary table with shared data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we will add a summary table on top of our dynamic data table. This summary
    table should be updated according to the assets selected (note the plural since
    we allow for the `All` case in this tab). Take a moment to try to think how you
    would implement this yourself? If you tried to replicate the pattern shown previously
    for the `data` object we showed before, you would have a correct but inefficient
    solution. The reason is that the logic to filter the data would be duplicated,
    which is unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this pitfall we show next how to share streams among different *reactive
    functions* using the `reactive()` function, which is a function that used to prepare
    *reactive values* for other *reactive functions*. In this case, we move all the
    logic we had created before into the expression sent as a parameter to this function
    and assign it to the `data` object, which is now a *reactive function* itself.
    Note that we also added a bit of code to check whether the current asset selection
    is different from `All` and if it is, then use that value to filter the data,
    similarly to how we filter it using dates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have done that, we can replace the logic we had inside the `datatable()`
    function with a simple call to the `data()` reactive function, which will provide
    the expected dataframe. And now that we have extracted this logic, we can reuse
    the `data()` call in an other place, as we do in the `output$summary_table` observer
    created with the `renderTable()` function. As you can see, it''s being passed
    a dataframe created with statistics for the minimum, median, mean, and maximum
    of the dataframe returned by the `data()` function. In this case, we can guarantee
    that the data used in the `output$table()` and `output$summary_table()` functions
    is the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Be careful if you're using stochastic data (for example, random numbers) if
    you're duplicating data logic instead of using a `reactive()` function, since
    you will probably not end up with the same data in both places.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to introduce the corresponding function call in the `ui` object,
    which we place in the corresponding `tabPanel()`. To place in this the dataframe
    we just created, we use the `tableOutput()` function with the corresponding `summary_table` string
    as parameter. The code is as follows (note that I omit the `ui` code around this
    snippet):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: After implementing these changes, you should see a summary table with the mentioned
    statistics on top of the dynamic data table, and they should update as different
    values are sent as inputs for dates and asset selection.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00073.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Adding a simple moving average graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we will create our first **simple moving average** (**SMA**) graph. This
    graph will be created with the   package, and will show two lines. The black line
    will be the actual price data, and the blue line will be SMA.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we begin, and since `ggplot2` graphs which make use of dates are better
    created with actual dates instead of timestamp strings, we add the `time` column
    to the `ORIGINAL_DATA` dataframe with the corresponding dates. This should be
    placed immediately after having loaded the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Next we show how our `sma_graph()` function is implemented. As can be seen,
    it will receive two parameters, the `data` dataframe and the `sma` vector coming
    out of one of the SMA implementations mentioned before. The function is very simple,
    it creates a graph with `time` on the *x* axis and `price_usd` on the *y* axis,
    adds points and lines for such data, and then adds a second blue line with the
    values from the `sma` vector. The `group = 1` parameter is used to avoid any errors
    by telling the `ggplot()` function that there's a single group in that data, and
    the `size = 1` parameter is just to make the line stand out a little bit more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we return the graph object. Finally, you should keep in mind that
    using the `geom_line()` function introduces interpolation into the example, which
    may misrepresent the discrete data we have for prices, but it can also be helpful
    to understand the price dynamics, and that''s why we use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now, to follow good practices, we place the SMA calculation in a `reactive()`
    function of its own (just below the `data` *reactive function* we created before).
    Note that it's a *reactive function* that depends on another *reactive function*,
    `data()` to be precise.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code (which omits the rest of the `server` function), shows that
    this `sma` definition makes use of the `do.call()` function to execute the implementation
    name we receive as a *reactive value* from the `input$sma_implementation` widget.
    The `do.call()` also receives a list as the second parameter, and this list contains
    the parameters that will be sent to the actual function we want to call. In this
    case, it''s the `input$sma_period`, the `symbol` (which in this case will be a
    single one because we restricted data for this tab to have a single asset), and
    the actual data through the call to the `data()` *reactive function*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Having implemented this `sma()` reactive function, we can implement the observer
    `output$graph_top()` as follows (again, we omitted some code around):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to update our `ui` object to replace the `"Content 1"` placeholder
    with a `fluidRow()` and a `ploutOutput()` inside. We send the `"graph_top"` unique
    identifier to the observer we are interested in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This was simple enough, wasn''t it? Now we can run our application, and it
    should show us a graph for the first two days in the data, with a blue SMA(30)
    on top as the one shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00074.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note that you can change the options and the graph will update accordingly.
    For example, if we chose only the first day in the data and decide to graph only
    an SMA(5) on top of it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00075.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, if your computer can handle it, you may decide to show the full data
    (which is quite a bit of observations, so do be careful). In that case, the SMA
    would not be visible, but it will still be plotted for us. The result is shown
    in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00076.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Adding interactivity with a secondary zoom-in graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, we are going to add some interactivity to our graph by implementing
    another similar graph, which will exhibit a *zoom-in* effect on the one we created
    before. The idea is that we can select an area of the graph we just created and
    the one we will place below it will update to only show the specific area we have
    selected. Seems interesting, doesn't it?
  prefs: []
  type: TYPE_NORMAL
- en: 'To accomplish this, we need to modify the `plotOutput()` we inserted at the
    end of the previous section to include a `brush` parameter with a call to the
    `brushOpts()` function, which in turn receives the name of the unique identifier
    for the brush input we are creating. This parameter is used to create a special
    type of input, which retrieves a selected area from the graph shown in the web
    browser. We also add another `fluidRow()` with another `plotOutput()` just below
    it to contain the graph that will provide the *zoom-in* effect. The code is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now the `input$graph_brush` reactive value will contain a list with four elements
    inside `xmin`, `xmax`, `ymin`, and `ymax`, which are the coordinates that conform
    the area selected in the top graph. Our `ranges()` reactive function will use
    them to send the appropriate values as limits to the bottom graph. The way it
    works is that it will check whether `input$graph_brush` is `NULL`, and if it's
    not, meaning that an area is selected, then it will return a list with two elements,
    `x` and `y`, where each of these elements contains the appropriate coordinates.
    If `input$graph_brush` is `NULL`, then the `x` and `y` elements of the returned
    list will be `NULL`, which signals the `coord_cartesian()` function, which we
    will use on top of the `sma_graph()`, to avoid placing any constraints in the
    axes for the graph. The actual function is shown in the following code, and as
    other functions created with `reactive()`, it should be placed inside the `server` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also note that we need to make a small transformation to the values for the
    *x* axis because they are returned as integers, and not dates which is the type
    of object being used by `ggplot()` for that axis. We simply use the `as.POSIXct()` function
    to transform such integers into valid dates, using the `oring = "1970-01-01"`,
    which is what `ggplot()` uses by default. If we don''t make the transformation,
    we will get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are able to create the `output$bottom_graph` observer just as we created
    the previous graph, but in this case we will add the `coord_cartesian()` function
    on top of the graph object returned by `sma_graph()` to limit the axes values.
    Note that we use the `expand = FALSE` to enforce the limits coming from the `ranges()`
    reactive function, we just created in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Having implemented these changes, we should have the desired effect. To test
    it, we can open the application and see the two identical plots one on top of
    the other, like the following screenshot shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00077.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: However, if we select an area on the top graph, then the graph on the bottom
    should update showing only that specific part of the graph. Pretty cool, isn't
    it?
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00078.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, you should know that another way to introduce interactive graphics
    is to use well known JavaScript like `Plot.ly` (which we used in [Chapter 5](part0110.html#38STS0-f494c932c729429fb734ce52cafce730),
    *Communicating Sales With Visualizations*). Shiny creates websites that use JavaScript
    in the background so this technique is a natural fit. However, this is an advanced
    technique and its use is more involved than what we have shown here, so we won't
    show it but you should know it's possible in case you want to pursue it yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Styling our application with themes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, we have been using the theme provided by default by Shiny,
    but now that our application is finished, we want to stylize it with some tech-looking colors.
    In that case, we can use the `shinythemes` and `ggthemr` packages, which provide
    us with an easy way to apply themes to Shiny applications and `ggplot2` graphs,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need to do to apply the themes is to tell the `ggplot2` framework to
    apply the *flat dark* theme provided by the `ggthemr` package, and to make sure
    that the *outer* side of the graph is also stylized we use the `type = outer` parameter,
    as is shown here. The code should be placed wherever we placed our `ggplot2` code
    for cohesiveness, which is in the `functions.R` file for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To stylize the Shiny application itself, we send the `theme` parameter, using
    the `shinytheme()` function, to the `fluidPage()` function just before our `titlePanel()`
    function call, as is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We also change the SMA line in the graphs to white, which you already know
    how to do, and with these changes, now our application looks pretty high tech.
    The following shows the Simple Moving Average tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00079.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'And here you can see a screenshot of the Data Overview tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00080.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To find other themes you can look at the `shinythemes` repository ([http://rstudio.github.io/shinythemes/](http://rstudio.github.io/shinythemes/))
    and the `ggthemr` repository ([https://github.com/cttobin/ggthemr](https://github.com/cttobin/ggthemr)). To
    make sure the readers realize what the full code looks like at once, I place here
    the full code for the application as well as the function used for graphs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Other topics of interest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with Shiny there are common tasks that can be used to customize
    your web applications. Some of these tasks are adding static images, HTML, and
    CSS. In the following sections we will briefly look into how these can be accomplished
    with Shiny. Finally, we will also mention some options you have to share your
    application with others, without having to setup your own web server, so that
    they can use it in their web browser, through an internet connection.
  prefs: []
  type: TYPE_NORMAL
- en: Adding static images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Images can enhance the appearance of your application and help your users understand
    the content. Shiny looks for the `img()` function to place image files in your
    application. To insert an image, simply call with the `src` specifying the images
    location. You can also include other HTML friendly parameters such as height and
    width (they will be passed as *pixel values*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `image.png` file must be in a folder named `www` in the same directory as
    the `app.R` script. Shiny will share any file placed here with your user's web
    browser, which makes `www` a great place to put images, style sheets, and other
    things the browser will need to build the wap components of your Shiny application.
  prefs: []
  type: TYPE_NORMAL
- en: Adding HTML to your web application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's easy to add HTML elements to your Shiny application using HTML tags. There
    are many elements you can add to your page using syntax like `tags$h1()` or `tags$p()` for
    a first-level heading and a paragraph, respectively. In the following piece of
    code, you can see how these would be used to create a page with one first-level heading,
    followed by a paragraph, a second-level heading, and then another paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: 'The full list of HTML tags can be found in the Shiny HTML Tags Glossary ([https://shiny.rstudio.com/articles/tag-glossary.html](https://shiny.rstudio.com/articles/tag-glossary.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, however, you may need more control on the HTML you want to use.
    In that case you can actually specify HTML directly into your application by using
    the `HTML()` function. In this case, Shiny will not perform any escaping on your
    behalf, and you will have full HTML powers, you simply need to pass it raw HTML
    as is shown here. Note that this raw HTML may be included in other tags, as is
    the case here, where it''s wrapped by a `div` HTML tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Adding custom CSS styling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shiny uses the Bootstrap framework for structure and styling. If you're new
    to CSS **Cascading Style Sheets** (**CSS**) or are not familiar with Bootstrap,
    it would be a good idea to read the *Getting Started* guide ([https://getbootstrap.com/docs/3.3/getting-started/](https://getbootstrap.com/docs/3.3/getting-started/))
    before attempting to apply your own styling.
  prefs: []
  type: TYPE_NORMAL
- en: To include your own CSS, you have a couple of options, but we will only show
    how to use the `includeCSS()` function and how to apply styles directly into HTML
    tags. The `includeCSS()` function is provided by Shiny and can be used to include
    a CSS file directly from the `www` directory mentioned in the previous section.
    Its usage is fairly simply.
  prefs: []
  type: TYPE_NORMAL
- en: Even though it's usually not a great idea because it's hard to find your styles
    and it's even harder to be consistent, sometimes it's useful to apply a style
    directly into a HTML tag. If you want to do so, you can send a `style` parameter
    to a specific tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that you have a file called `style.css` in the `www` directory
    that provides all the styles you want, except the green color you want to apply
    to the *first-level* heading. Then, you may use the following code which includes
    both techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Sharing your newly created application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although Shiny applications end up as HTML files you can't simply copy them
    to your server. They require a Shiny server, just like the one we have been working
    with through this chapter. There are two ways to run Shiny applications (as any
    other application), locally or remotely. Locally means that you fire up an R installation
    with Shiny and the required dependencies, and run it just as we have been doing
    during this chapter. Remotely means that you can access it through a website,
    which can be very cool and convenient at times.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run locally you need to have the files for the application in the computer
    that will execute them. There are many ways to do so, but the most common one
    is to upload them to a Git repository, download them from there, and follow the
    steps you already know. Furthermore, if your files are in a Git repository hosted
    in GitHub ([https://www.github.com](https://www.github.com)), you may use the
    `runGitHub()` function with the name of the repository and the username of the
    account that holds the repository. In that case, the downloading, unpacking, and
    execution will be done for you. For example, to run the application we developed
    through this chapter, you may use the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to provide remote access to your application, you have many options,
    but the main ones are three: ShinyApps, RStudio Connect, and Shiny Server. **ShinyApps**
    ([https://www.shinyapps.io](https://www.shinyapps.io)) offers this service for
    free for small applications with limited visits and can scale up in paid versions.
    **RStudio Connect** ([https://www.rstudio.com/products/connect/](https://www.rstudio.com/products/connect/))
    is a publishing platform for Shiny applications and R Markdown reports. With it,
    you can publish directly from RStudio. Finally, **Shiny Server** ([https://www.rstudio.com/products/shiny/shiny-server/](https://www.rstudio.com/products/shiny/shiny-server/))
    is an open source version of the Shiny server you''ve been using in this chapter,
    with the added benefit that you can run it in the Linux servers you control (of
    course, this includes servers from cloud providers). RStudio also sells a yearly
    subscription to Shiny Server Pro, which provides security, administration, and
    other enhancements when compared to the open source version.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw throughout the chapter, using the *functional reactive programming*
    paradigm to create powerful web applications using Shiny is not necessarily difficult.
    It only requires good concept understanding and a bit of exploration.
  prefs: []
  type: TYPE_NORMAL
- en: We showed how to provide inputs for users to be able to send *reactive values*
    to the backend, that is, the `server`, and have it respond adequately to such
    streams of events. We also showed how to add more sophisticated interactions such
    as the the two graphs with the zoom-in effect.
  prefs: []
  type: TYPE_NORMAL
- en: This is the final chapter for the book, and you saw how to use many of the tools
    provided by Shiny to create interactive applications. However, we have just scratched
    the surface of what is possible with Shiny and R in general. I hope you take what
    you have learned in this book and create amazing applications. Thank you for making
    it this far! I wish you the best of luck.
  prefs: []
  type: TYPE_NORMAL
