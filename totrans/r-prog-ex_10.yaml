- en: Adding Interactivity with Dashboards
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用仪表板添加交互性
- en: Shiny enables you to write powerful interactive web applications entirely in
    R. Using R, you can create a user interface and server, and Shiny will compiler
    your R code into the HTML, CSS, and JavaScript code needed to display your application
    on the web. What makes a Shiny application particularly powerful is that it can
    execute R code on the backend, so your application can perform any R calculation
    you can run on your desktop. You may want your application to process some data
    based on user inputs and provide some interactivity to make data analysis more
    intuitive.  In this chapter, we will show you how to accomplish this.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Shiny 允许您完全使用 R 编写强大的交互式网络应用程序。使用 R，您可以创建用户界面和服务器，Shiny 将您的 R 代码编译成显示在网页上所需的
    HTML、CSS 和 JavaScript 代码。使 Shiny 应用程序特别强大的是，它可以在后端执行 R 代码，因此您的应用程序可以执行您在桌面上可以运行的任何
    R 计算。您可能希望应用程序根据用户输入处理一些数据，并提供一些交互性，使数据分析更加直观。在本章中，我们将向您展示如何实现这一点。
- en: Shiny implements the *functional reactive programming* paradigm that powers
    many of today's most modern web applications. We will explain what it is and how
    it works within Shiny. We will show how to work with streams of events coming
    from application users and how to react to them accordingly. To do so, we will
    work through an example that receives inputs from users and provides data and
    graphs in return. By the end of the chapter, you'll realize how easy it can be
    to create powerful web applications that take your R skills to the next level.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Shiny 实现了推动许多当今最现代网络应用程序的 *函数式响应式编程* 范式。我们将解释它是什么以及它在 Shiny 中的工作方式。我们将展示如何处理来自应用程序用户的流式事件以及如何相应地做出反应。为此，我们将通过一个示例来演示，该示例接收用户输入并提供数据和图表。到本章结束时，您将意识到创建强大的网络应用程序是多么容易，这些应用程序可以将您的
    R 技能提升到新的水平。
- en: 'Some of the important topics covered in this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的一些重要主题如下：
- en: The Shiny web applications architecture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shiny 网络应用程序架构
- en: The functional reactive programming paradigm
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式响应式编程范式
- en: How reactivity is implemented within Shiny
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shiny 中如何实现响应性
- en: Receiving inputs from users interactions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从用户交互中接收输入
- en: Sending outputs in responses to the web browser
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向网络浏览器发送响应输出
- en: Adding interactions to Shiny applications
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向 Shiny 应用程序添加交互性
- en: Required packages
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 必需的包
- en: 'We have already worked with the first two packages, namely `ggplot2` and `lubridate.`
    The `shiny` package is used to build web applications directly from R, while the
    `shinythemes` and `ggthemr` packages are used to apply themes to style our web
    application. For more information, take a look at [Appendix](part0296.html#8Q96G0-f494c932c729429fb734ce52cafce730),
    *Required Packages*. Required packages for this chapter are shown in the following
    table:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用过前两个包，即 `ggplot2` 和 `lubridate`。`shiny` 包用于直接从 R 构建网络应用程序，而 `shinythemes`
    和 `ggthemr` 包用于将主题应用于我们的网络应用程序。有关更多信息，请参阅 [附录](part0296.html#8Q96G0-f494c932c729429fb734ce52cafce730)，*必需的包*。本章所需的必需包如下表所示：
- en: '| **Package** | **Reason** |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| **包** | **原因** |'
- en: '| `ggplot2` | High-quality graphs |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `ggplot2` | 高质量图表 |'
- en: '| `lubridate` | Easily transform dates |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `lubridate` | 轻松转换日期 |'
- en: '| `shiny` | Create modern web applications |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `shiny` | 创建现代网络应用程序 |'
- en: '| `ggthemr` | Apply themes to `ggplot2` plots |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `ggthemr` | 将主题应用于 `ggplot2` 图表 |'
- en: '| `shinythemes` | Apply themes to Shiny applications |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `shinythemes` | 将主题应用于 Shiny 应用程序 |'
- en: Introducing the Shiny application architecture and reactivity
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Shiny 应用程序架构和响应性
- en: In its simplest form, a Shiny application requires a server and a **user interface** (**UI**).
    These components form the basic architecture behind all Shiny applications. The
    `ui` object controls the layout and appearance of your application, and the `server` function
    contains the logic needed by the application. If you know how web applications
    work, you can think of them as the *frontend* and the *backend,* respectively.
    The `shinyApp()` function creates and launches a Shiny application from an explicit
    UI/server pair. It will compile R code into web-friendly languages HTML, JavaScript,
    and CSS.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单形式中，Shiny 应用程序需要一个服务器和一个 **用户界面**（**UI**）。这些组件构成了所有 Shiny 应用程序背后的基本架构。`ui`
    对象控制着应用程序的布局和外观，而 `server` 函数包含应用程序所需的逻辑。如果您了解网络应用程序的工作原理，您可以将其视为分别的 *前端* 和 *后端*。`shinyApp()`
    函数从显式的 UI/server 对创建并启动一个 Shiny 应用程序。它将 R 代码编译成网络友好的语言 HTML、JavaScript 和 CSS。
- en: 'Below we have the simplest possible Shiny application, which has an empty server
    and a UI with a basic message. If you are in an interactive R session, your web
    browser should launch and show the application. If it doesn''t, you can navigate
    to the URL yourself, which is in the form `http://127.0.0.1:6924/`, where `127.0.0.1`
    is the IP of your own computer and `6924` is the port Shiny is using to listen
    for connections. As you can see in your web browser, it is nothing amazing, but
    it''s a functioning web application created only using R:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们能想到的最简单的Shiny应用程序，它有一个空的服务器和带有基本信息的UI。如果您在一个交互式的R会话中，您的网络浏览器应该会启动并显示该应用程序。如果它没有这样做，您可以自己导航到URL，其形式为`http://127.0.0.1:6924/`，其中`127.0.0.1`是您自己计算机的IP地址，而`6924`是Shiny用于监听连接的端口。正如您在浏览器中看到的那样，它并不令人惊叹，但它是一个仅使用R创建的运行中的网络应用程序：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Having a fixed port, instead of a randomly assigned port, which changes on every
    `shinyApp()` call, makes development easier. To use a fixed port, change the function
    call to `shinyApp(ui, server, options = list(port = 6924))` with a port of your
    preference.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用固定的端口，而不是在每次`shinyApp()`调用时随机分配的端口，可以简化开发。要使用固定端口，将函数调用更改为`shinyApp(ui, server,
    options = list(port = 6924))`，并使用您偏好的端口。
- en: Note that your R session will be busy while the application is active, so you
    will not be able to run any R commands. R is monitoring the application and executing
    the application's reactions. To get your R session back, press *Ctrl* + *C*, or
    if you are using RStudio, click on the stop sign icon.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当应用程序处于活动状态时，您的R会话将会忙碌，因此您将无法运行任何R命令。R正在监控应用程序并执行应用程序的反应。要恢复您的R会话，请按*Ctrl*
    + *C*，或者如果您正在使用RStudio，请点击停止标志图标。
- en: For simplicity, we're creating our Shiny applications in a single file. However,
    with bigger applications, you will likely split the components into `ui.R` and
    `server.R` files (which are the standard files used for Shiny applications).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们将在单个文件中创建我们的Shiny应用程序。然而，对于更大的应用程序，您可能会将组件拆分为`ui.R`和`server.R`文件（这些是Shiny应用程序的标准文件）。
- en: As we will see throughout the chapter, Shiny provides a great paradigm for developing
    web applications which is used in many cutting-edge systems nowadays. It's known
    as *functional reactive programming*. It's not a simple concept to grasp, but
    it's very powerful, and we will learn to use its fundamentals in this chapter.
    However, before we do, I will try to provide a simple explanation of what it is
    and how it works within Shiny.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章所述，Shiny提供了一个极好的范例，用于开发当今许多尖端系统所使用的网络应用程序。它被称为*函数式响应式编程*。这是一个不易掌握的概念，但它非常强大，我们将在本章中学习如何使用其基本原理。然而，在我们这样做之前，我将尝试提供一个简单的解释，说明它是什么以及如何在Shiny中工作。
- en: What is functional reactive programming and why is it useful?
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式响应式编程是什么，为什么它有用？
- en: Let's start with the reactive programming part. **Reactive programming** is
    programming with *asynchronous data streams*. We start by defining these terms
    at a general level.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从响应式编程部分开始。**响应式编程**是与*异步数据流*进行编程。我们首先在一般层面上定义这些术语。
- en: A *stream* is a sequence of ongoing events ordered in time. In reality, almost
    anything can be thought of as a stream, but simple examples are balls bouncing,
    where an *event* is considered every time a ball hits the floor. It can happen
    repeatedly many times, without specific patterns, stop for a while, then continue,
    and then stop again. Users clicking in a website is also a *stream*, where each
    click is an *event*. As you can imagine, there are *streams* everywhere around
    us.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*流*是一系列按时间顺序排列的持续事件。在现实中，几乎所有东西都可以被视为一个流，但简单的例子是球弹跳，其中每次球击中地面都被视为一个*事件*。它可以反复多次发生，没有特定的模式，暂停一会儿，然后继续，然后再次停止。用户在网站上点击也是一个*流*，其中每次点击都是一个*事件*。正如您所想象的那样，我们周围到处都是*流*。
- en: The other term that needs to be defined is *asynchronous,* which literally means
    *without syncronization.* Normally, *synchronous* functions wait at the line of
    a function call until the function being called is finished executing, possibly
    returning a value. This is the way we have been programming so far. However, *asynchronous*
    functions don't necessarily wait for the functions they call to be finished. This
    means that our functions need to *react* to it whenever it arrives.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 需要定义的另一个术语是*异步*，字面上意味着*没有同步*。通常，*同步*函数在函数调用行等待，直到被调用的函数执行完成，可能返回一个值。这是我们迄今为止编程的方式。然而，*异步*函数不一定会等待它们调用的函数完成。这意味着我们的函数需要*响应*它，无论何时它到达。
- en: If we join these two terms, we can understand that programming with *asynchronous
    data streams* works by writing code that is able to react to *events* as they
    happen, continuously and randomly. In the case of this chapter, these *events*
    will be user interactions (clicks or keystrokes) with our application, which means
    that our R code will be responding directly to these clicks and keystrokes as
    they happen.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这两个术语结合起来，我们可以理解，使用**异步数据流**进行编程是通过编写能够对发生的事件做出反应的代码来实现的，这些反应是持续和随机的。在本章的情况下，这些**事件**将是与我们的应用程序交互的用户操作（点击或按键），这意味着我们的R代码将直接对这些点击和按键做出反应。
- en: 'If it is still hard to get a grasp on the idea, think about it as a spreadsheet
    with formulas. When you change a value that other cells depend on or are listening
    to (analogous to receiving some input from a user in our application), then other
    cells react accordingly and present the newly computed value (which will be output
    change we show to the user). It''s really that simple. The *listening* to the
    stream is called **subscribing.** The functions we are defining are *observers*,
    and the stream is the *observable* being *observed*. This is precisely the *Observer
    Design Pattern*. Take a look at Gamma, Helm, Johnson, and Vlissides''s book *Design
    Patterns: Elements of Reusable Object-Oriented Software, by Addison-Wesley, 1994*.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个概念仍然难以理解，可以将其想象成一个带有公式的电子表格。当你改变一个其他单元格依赖或监听的值（在我们的应用程序中相当于从用户那里接收一些输入），那么其他单元格会相应地做出反应，并展示新的计算值（这将是展示给用户的输出变化）。这真的很简单。对流的**监听**被称为**订阅**。我们定义的函数是**观察者**，而流是被**观察**的**可观察对象**。这正是**观察者设计模式**。看看Gamma、Helm、Johnson和Vlissides合著的书籍《设计模式：可重用面向对象软件元素》，由Addison-Wesley出版社，1994年出版。
- en: On top of that, you are given a great set of tools that allows you to create,
    filter, and combine any of these *streams.* That's where the *functional programming*
    magic kicks in. Functional programing allows for composition, and that's exactly
    what we will use it for, to *compose streams*. A *stream* can be used as an input
    to another one. Even multiple *streams* can be used as inputs to many others.
    Furthermore, you may use any of these raw or transformed streams anywhere in your
    code. That's really what makes Shiny such a great tool.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你有一套强大的工具，允许你创建、过滤和组合这些**流**中的任何一个。这就是**函数式编程**魔法开始发挥作用的地方。函数式编程允许进行组合，这正是我们将要使用的，来**组合流**。一个**流**可以用作另一个流的输入。甚至多个**流**也可以作为多个其他流的输入。此外，你可以在代码的任何地方使用这些原始或转换后的流。这正是Shiny成为一个如此伟大工具的原因。
- en: '**Functional Reactive programming** raises the level of abstraction of your
    code, so you can focus on the interdependence of events that define your application''s
    logic, rather than having to constantly fiddle with a large amount of implementation
    details. *Functional-reactive* code is also likely to be more concise.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数式反应编程**提高了你代码的抽象级别，因此你可以专注于定义应用程序逻辑的事件之间的相互依赖性，而不是不断调整大量实现细节。**函数式反应**代码也可能更加简洁。'
- en: The benefit is more evident in modern applications that are highly interactive.
    Applications nowadays have an abundance of real-time events that enable a highly
    interactive experiences, and *functional reactive programming* is a great tool
    for that.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在高度交互的现代应用程序中，这种好处更为明显。如今的应用程序拥有大量的实时事件，这些事件能够提供高度交互的体验，而**函数式反应编程**是处理这种需求的绝佳工具。
- en: How is functional reactivity handled within Shiny?
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Shiny中如何处理功能反应性？
- en: Reactivity is what makes your Shiny applications responsive. It seems like the
    application instantly updates itself whenever the user makes a change. However,
    in reality, Shiny is rerunning your R expressions in a carefully scheduled way
    every couple of microseconds, which creates the illusion of responsiveness. You
    don't need to know how reactivity occurs to use it, but understanding reactivity
    will make you a better Shiny programmer.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 反应性是使你的Shiny应用程序响应的关键。看起来应用程序似乎在用户做出更改时立即更新自己。然而，实际上，Shiny每隔几微秒就会以精心安排的方式重新运行你的R表达式，从而创造出响应性的错觉。你不需要了解反应性是如何发生的就可以使用它，但了解反应性会使你成为一个更好的Shiny程序员。
- en: Remember that when we executed our very simple Shiny application in a previous
    section, the R console stopped being interactive? Well, that was happening because
    executing the `shinyApp()` function makes R busy by constantly monitoring and
    updating expressions as necessary, which is what creates the responsive experience
    for users.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在我们之前章节中执行非常简单的Shiny应用程序时，R控制台停止了交互吗？嗯，那是因为执行`shinyApp()`函数会让R忙碌，不断地监控和根据需要更新表达式，这就是为用户创建响应式体验的原因。
- en: Now, imagine you have a complex application with lots of interactivity, then
    running every expression every couple of microseconds would completely saturate
    your processor, and your users would have a terrible user experience. That's why
    Shiny needs to be smart enough to only update those expressions that require it.
    Whenever a user submits an action (*event*), expressions that handle such events
    become *invalidated,* effectively marking themselves as being in need of an *update,*
    and this behavior is propagated among all expressions that depend on them. When
    a few microseconds have passed, R will check which expressions are marked for
    being updated, and only update those.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下你有一个复杂的应用程序，其中包含大量的交互性，那么每两微秒运行每一个表达式将会完全饱和你的处理器，并且你的用户将会有一个糟糕的用户体验。这就是为什么Shiny需要足够智能，只更新那些需要更新的表达式。每当用户提交一个动作（*事件*）时，处理此类事件的表达式会变得*无效*，实际上标记自己需要*更新*，并且这种行为会在所有依赖于它们的表达式之间传播。当过去了几微秒之后，R会检查哪些表达式被标记为需要更新，并且只更新那些。
- en: The mechanism just described can reduce the number of expressions that are recomputed
    from thousands to none, in case there has not been any user action, and to a few
    at most, since it's very hard for a user to accomplish a lot in a few microseconds
    which in turn would result in a few required updates, instead of a full application
    update each time. This mechanism allows R to handle complex Shiny applications,
    and it's the key to reactivity. It allows the application to be updated as fast
    as possible, making input/output coordination almost instantly.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如刚才描述的机制可以减少需要重新计算的表达式的数量，从数千个减少到零，如果没有用户动作，并且最多只有几个，因为用户在几微秒内完成很多事情是非常困难的，这反过来又会导致几个所需的更新，而不是每次都进行完整的应用程序更新。这种机制允许R处理复杂的Shiny应用程序，并且它是响应性的关键。它允许应用程序尽可能快地更新，使输入/输出协调几乎瞬间完成。
- en: The building blocks for reactivity in Shiny
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shiny中响应性的构建块
- en: 'The building blocks of reactivity in Shiny are built around three types of
    functions: input, output, and rendering functions. Input functions most of the
    time end with the `Input` string (not always) and I will refer to them as `Input()`
    functions. Output functions always end with the `Output` string and I will refer
    to them as `Output()` functions. Finally, rendering functions begin with the `render`
    string and similarly I will refer to them as `render*()` functions.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Shiny中响应性的构建块围绕三种类型的函数构建：输入、输出和渲染函数。输入函数大多数情况下以`Input`字符串结尾（不总是），我将它们称为`Input()`函数。输出函数总是以`Output`字符串结尾，我将它们称为`Output()`函数。最后，渲染函数以`render`字符串开头，我将类似地称它们为`render*()`函数。
- en: '`Input*()` functions are used within the `ui` object and they generate *reactive
    values*, which are values received from an interaction through a web browser,
    and are passed through the `input` parameter in the `server` function. The `render*()`
    functions are used within the `server` function and make use of *reactive values*
    to produce *observables* that go back into the `ui` object, through the `server`
    function''s `output` parameter. Finally, `*Output()` functions are used in the
    `ui` object to show the content of these observables in the web browser.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`Input*()`函数在`ui`对象中使用，并生成*响应式值*，这些值是通过网络浏览器与交互接收到的，并通过`server`函数中的`input`参数传递。`render*()`函数在`server`函数中使用，并利用*响应式值*生成*可观察值*，这些值通过`server`函数的`output`参数返回到`ui`对象。最后，`*Output()`函数在`ui`对象中使用，以在网页浏览器中显示这些可观察值的内容。'
- en: '*Reactive values* are received in the `server()` function through the `input`
    parameter, which is a list whose elements contain elements that are *linked* with
    the `ui` object through strings that act as unique identifiers. The `output` parameter
    in the `server` function is also a list, but it''s used to receive observables
    that will be sent to the web browser.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*响应式值*通过`server()`函数中的`input`参数接收，该参数是一个列表，其元素通过作为唯一标识符的字符串与`ui`对象相关联。`server`函数中的`output`参数也是一个列表，但它用于接收将被发送到网页浏览器的可观察对象。'
- en: Functions that know how to deal with *reactive values* are known as *reactive
    functions*. Not every R function is a reactive function, and they need special
    construction mechanisms provided by Shiny, and if you try to use a *reactive value*
    in a *non-reactive function*, you will get an error (this is an easy mistake when
    starting to use Shiny). The `render*()` functions are used to create reactive
    functions. Another way of doing so is with the `reactive()` function we will explain
    later in the chapter.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 知道如何处理*响应式值*的函数被称为*响应式函数*。并非每个R函数都是响应式函数，它们需要Shiny提供的特殊构建机制，如果你尝试在一个*非响应式函数*中使用*响应式值*，你会得到一个错误（这是开始使用Shiny时的一个常见错误）。`render*()`函数用于创建响应式函数。另一种方法是使用本章后面将要解释的`reactive()`函数。
- en: Reactive functions are commonly used to generate observables that may be used
    by other reactive functions or by `render*()` functions. However, reactive functions
    can also produce side effects (for example, writing to a database). If reactive
    functions have `return` values, they are *cached* so that the function is not
    required to be re-executed if its corresponding *reactive values* have not changed.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式函数通常用于生成其他响应式函数或`render*()`函数可能使用的可观察对象。然而，响应式函数也可以产生副作用（例如，写入数据库）。如果响应式函数有`return`值，它们将被*缓存*，这样如果相应的*响应式值*没有改变，就不需要重新执行该函数。
- en: The input, output, and rendering functions
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入、输出和渲染函数
- en: 'Each `*Input()` function requires several arguments. The first one is a string
    with the name for the widget, which will only be used by you. The second one is
    a label which will be shown to the user in your application. The remaining arguments
    for each `*Input()` function vary depending on its functionality. They include
    things like initial values, ranges, and increments. You can find the exact arguments
    needed by a widget on the widget function''s help page, (for example, `? selectInput`).
    The following table shows all available `*Input()` functions with an indication
    of what they are used for:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`*Input*()`函数都需要几个参数。第一个是一个字符串，包含小部件的名称，这只会被你使用。第二个是一个标签，它将在你的应用程序中显示给用户。每个`*Input*()`函数的其余参数根据其功能而变化。它们包括初始值、范围和增量等。你可以在小部件函数的帮助页面上找到所需的小部件的确切参数（例如，`?
    selectInput`）。以下表格显示了所有可用的`*Input*()`函数及其用途的说明：
- en: '| **The** `Input*()` **function** | **Use** |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| **输入**`*Input*()`**函数** | **用途** |'
- en: '| `actionButton()` | Action button |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `actionButton()` | 操作按钮 |'
- en: '| `checkboxGroupInput()` | Group of checkboxes |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `checkboxGroupInput()` | 复选框组 |'
- en: '| `checkboxInput()` | Single checkbox |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `checkboxInput()` | 单个复选框 |'
- en: '| `dateInput()` | Date selection |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `dateInput()` | 日期选择 |'
- en: '| `dateRangeInput()` | Date range selection |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `dateRangeInput()` | 日期范围选择 |'
- en: '| `fileInput()` | File upload |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `fileInput()` | 文件上传 |'
- en: '| `helpText()` | Help text for input forms |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `helpText()` | 输入表单的帮助文本 |'
- en: '| `numericInput()` | Numeric input field |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `numericInput()` | 数字输入字段 |'
- en: '| `radioButtons()` | Set of options in radio buttons |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `radioButtons()` | 单选按钮中的选项集 |'
- en: '| `selectInput()` | Set of options in drop-down |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `selectInput()` | 下拉菜单中的选项集 |'
- en: '| `sliderInput()` | Numeric input slide bar |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `sliderInput()` | 数字输入滑动条 |'
- en: '| `submitButton()` | Submit button |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `submitButton()` | 提交按钮 |'
- en: '| `textInput()` | Text input field |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `textInput()` | 文本输入字段 |'
- en: 'Each of the `*Output()` functions requires a single argument, which is a character
    string that Shiny will use to identify the corresponding *observer* from the `output`
    parameter in the `server` function. Users will not see this name, it will only
    be used by you. The following table shows the list of all the available `*Output()`
    functions with an indication of what they are used for. You may find more information
    about them using their corresponding help pages (for example, `? tableOutput`):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `*Output()` 函数需要一个单一参数，这是一个字符字符串，Shiny 将使用它从 `server` 函数中的 `output` 参数识别相应的
    *observer*。用户将看不到这个名称，它只供您使用。以下表格显示了所有可用的 `*Output()` 函数列表，以及它们的使用说明。您可以通过它们对应的使用帮助页面了解更多信息（例如，`?
    tableOutput`）：
- en: '| **The `*Output()` function** | **Use** |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **`*Output()` 函数** | **用途** |'
- en: '| `dataTableOutput()` | Data table |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `dataTableOutput()` | 数据表 |'
- en: '| `htmlOutput()` | Raw HTML |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `htmlOutput()` | 原始HTML |'
- en: '| `imageOutput()` | Images |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `imageOutput()` | 图片 |'
- en: '| `plotOutput()` | Graphs |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `plotOutput()` | 图表 |'
- en: '| `tableOutput()` | Tables |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `tableOutput()` | 表格 |'
- en: '| `textOutput()` | Text |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `textOutput()` | 文本 |'
- en: '| `uiOutput()` | Raw HTML |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `uiOutput()` | 原始HTML |'
- en: '| `verbatimTextOutput()` | Verbatim text |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `verbatimTextOutput()` | 纯文本 |'
- en: 'Finally, each `render*()` function takes a single argument, an R expression
    surrounded by braces (`{}`). These expressions can contain one simple line of
    text or they can involve many lines of code and function calls. The following
    table shows the list of all `render*()` functions with an indication of what they
    are used for. You guessed it, you may find more information about them using their
    corresponding help pages (for example, ? `renderText`):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，每个 `render*()` 函数接受一个单一参数，一个由大括号 `{}` 包围的R表达式。这些表达式可以包含一行简单的文本，也可以包含多行代码和函数调用。以下表格显示了所有
    `render*()` 函数列表，以及它们的使用说明。正如你所猜到的，你可以通过它们对应的使用帮助页面了解更多信息（例如，? `renderText`）： '
- en: '| **The `render*()` function** | **Use** |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| **`render*()` 函数** | **用途** |'
- en: '| `renderDataTable()` | Data table |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `renderDataTable()` | 数据表 |'
- en: '| `renderImage()` | Image |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `renderImage()` | 图片 |'
- en: '| `renderPlot()` | Graph |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `renderPlot()` | 图 |'
- en: '| `renderPrint()` | Any printed output |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `renderPrint()` | 任何打印输出 |'
- en: '| `renderTable()` | Data frame, matrix, or other table-like structure |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `renderTable()` | 数据框、矩阵或其他类似表格的结构 |'
- en: '| `renderText()` | String |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `renderText()` | 字符串 |'
- en: '| `renderUI()` | Shiny tag object or HTML |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `renderUI()` | Shiny标签对象或HTML |'
- en: Shiny applications combine the `*Input()`, `*Output()`, and `render*()` functions
    to produce powerful web applications. The simplest applications will be composed
    of only reactive values and observers, without too much logic between them. However,
    it's also possible to place as many expressions as we want between them, which
    allows for more complex applications.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Shiny应用程序结合了 `*Input()`、`*Output()` 和 `render*()` 函数来生成强大的网络应用程序。最简单的应用程序将只由响应值和观察者组成，它们之间没有太多的逻辑。然而，我们也可以在它们之间放置尽可能多的表达式，这允许构建更复杂的应用程序。
- en: There are many more ways to work with reactivity in Shiny. A very friendly introduction
    video can be found at RStudio's *Learn Shiny* video tutorials ([https://shiny.rstudio.com/tutorial/](https://shiny.rstudio.com/tutorial/)).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在Shiny中处理响应性有许多方法。一个非常友好的介绍视频可以在RStudio的 *Learn Shiny* 视频教程中找到（[https://shiny.rstudio.com/tutorial/](https://shiny.rstudio.com/tutorial/)）。
- en: Designing our high-level application structure
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计我们的高级应用程序结构
- en: That's enough theory, let's get to action building our own application. The
    application we will build will make use of the previous chapter, so if you haven't
    read that one, please do. The dashboard we will build will make more sense if
    you do. This dashboard will show graphs with the price data points from the previous
    chapter's data simulation, as well as the SMA calculations we developed. Furthermore,
    it will allow us to explore the price data using a dynamic table.. By *dynamic*,
    we mean that responds to user input.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 理论就到这里，让我们动手构建自己的应用程序。我们将构建的应用程序将利用前一章的内容，所以如果你还没有阅读那一章，请务必阅读。我们将构建的仪表板将更有意义，如果你已经阅读了。这个仪表板将显示来自前一章数据模拟的价格数据点图表以及我们开发的SMA计算。此外，它将允许我们使用动态表格来探索价格数据。这里的“动态”意味着它会对用户输入做出响应。
- en: Setting up a two-column distribution
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置两列分布
- en: 'The layout you choose to use for your application depends on its objectives.
    In this case, a two-column layout will suffice. To accomplish this, we use the
    `fluidPage()` function and assign it to the `ui` object. This function adjusts
    content according to the web browser''s dimensions:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你为应用程序选择使用的布局取决于其目标。在这种情况下，两列布局就足够了。为了实现这一点，我们使用`fluidPage()`函数并将其分配给`ui`对象。此函数根据网页浏览器的尺寸调整内容：
- en: '![](img/00067.gif)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00067.gif)'
- en: 'Inside the `fluidPage()`, we use the `titlePanel()` function to provide a title
    for our application and the `sidebarLayout()` function to create a two-column
    layout. This last function requires two other functions to be called inside it
    to create the corresponding content for each column. These two functions are called
    `sidebarPanel()` and `mainPanel()`, and they receive the content we want to create
    inside of them as parameters. The column on the left will be used to display available
    options for users and the one on the right to show actual content as a result
    of the user inputs, so we use some strings as placeholders that describe exactly
    that:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在`fluidPage()`内部，我们使用`titlePanel()`函数为我们的应用程序提供标题，并使用`sidebarLayout()`函数创建两列布局。这个最后的函数需要在其中调用另外两个函数来创建每个列的对应内容。这两个函数分别称为`sidebarPanel()`和`mainPanel()`，它们接收我们想要在它们内部创建的内容作为参数。左侧的列将用于显示用户可用的选项，右侧的列将显示用户输入的结果内容，因此我们使用一些字符串作为占位符，精确描述了这一点：
- en: '[PRE1]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `fluidPage` simply generates HTML, which is sent to the web browser. You
    may print the `ui` object in the R console as we progress along the chapter to
    see the HTML it created.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`fluidPage`简单地生成HTML，并将其发送到网页浏览器。随着我们沿着本章的进展，你可以在R控制台中打印`ui`对象，以查看它创建的HTML。'
- en: This code will create a very basic structure as the one shown in the next image.
    As we move along, we will make the application more and more complex, but we need
    to start somewhere.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将创建一个非常基本的结构，就像下一张图片中所示的那样。随着我们的进展，我们将使应用程序越来越复杂，但我们需要从某个地方开始。
- en: 'As you can see, nesting function calls will be a common pattern in the `ui`
    object to structure the application. This can be tricky, and if for some reason,
    you miss a comma (",") somewhere, you may find a cryptic message as the one shown
    . If that''s the case, making sure your commas are correctly placed is a good
    start for fixing this error:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在`ui`对象中嵌套函数调用将是一个常见模式来构建应用程序。这可能会很棘手，如果由于某种原因，你在某个地方遗漏了一个逗号（`,`），你可能会看到一个像下面这样的神秘信息。如果是这种情况，确保你的逗号放置正确是修复这个错误的好开始：
- en: '[PRE2]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Introducing sections with panels
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍带有面板的分区
- en: 'To show a section for graphs and a separate one for data tables, we will use
    the `tabsPanel()` function in conjunction with the `tabPanel()` function. The
    `tabsPanel()` function receives and arranges one or more `tablePanel()` function
    calls, where each of them receives the name for a tab and its actual content:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示一个用于图表的分区和一个用于数据表的单独分区，我们将使用`tabsPanel()`函数与`tabPanel()`函数结合。`tabsPanel()`函数接收并排列一个或多个`tablePanel()`函数调用，其中每个调用接收一个标签的名称及其实际内容：
- en: '[PRE3]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Since we created two tabs with the titles, *Simple Moving Averages* and *Data
    Overview*, respectively, that''s what we see as the tab names. If you are running
    the application yourself at this point, you may click on them and you will see
    the `Content 1` or `Content 2` strings, depending on which one you click on:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们创建了两个带有标题的标签页，分别是*简单移动平均*和*数据概览*，所以我们看到的就是这些标签页的名称。如果你现在自己运行这个应用程序，你可以点击它们，你会看到`Content
    1`或`Content 2`字符串，具体取决于你点击的是哪一个：
- en: '![](img/00068.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00068.jpeg)'
- en: Note that the `tabsetPanel()` function took the place of the `"Content"` string we
    previously had in its place. This will be a common pattern. As we start introducing
    more and more elements to the application, they will replace previous placeholders.
    Once you get used to Shiny, you may completely avoid the creation of placeholders.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`tabsetPanel()`函数取代了我们之前在其位置上的`"Content"`字符串。这将成为一个常见模式。随着我们开始向应用程序中引入越来越多的元素，它们将替换之前的占位符。一旦你习惯了Shiny，你可能完全避免创建占位符。
- en: Inserting a dynamic data table
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入一个动态数据表
- en: 'Now we will add a dynamic table with the data we simulated in the previous
    chapter, so first of all, we need to bring that data into the application, and
    we do so with the line shown below. You should place this data-loading line above
    the `ui` object in your app. This way, it will only be run once, when starting
    up the Shiny application, as any code that would normally be run when executing
    an R script:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加一个动态表格，其中包含我们在上一章中模拟的数据，因此首先，我们需要将那些数据带入应用程序，我们通过下面的行来实现。你应该将此数据加载行放在你的应用程序中的
    `ui` 对象之上。这样，它只会在启动 Shiny 应用程序时运行一次，就像执行 R 脚本时通常会运行的任何代码一样：
- en: '[PRE4]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: At this point, we need to introduce the `DT` package. It provides an easy way
    to create dynamic tables for Shiny applications. Since we will reference it through
    its package name, we don't need to load it with `library(DT)`. Referencing it
    by its package name helps us separate the native Shiny functions from those that
    come from external packages.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要引入 `DT` 包。它为 Shiny 应用程序提供了一个创建动态表格的简单方法。由于我们将通过其包名引用它，所以我们不需要使用 `library(DT)`
    来加载它。通过包名引用它有助于我们区分原生 Shiny 函数和来自外部包的函数。
- en: To implement this, we need to modify the `server` function we had not touched
    up to this point. We need to introduce some logic into it that will allow us to
    move data from R into the web interface. To accomplish this, we assign it to the
    `table` element in its `output` parameter, which will function as an observer.
    The element name we assign to it can be any valid list element we wish, but it's
    a good idea to just use names that describe the contents of the observer. Keep
    in mind that these names must be unique as Shiny will use them to identify what
    objects to pass back and forth between the `ui` object and the `server` function.
    The observer is created with the `renderDataTable()` function from the `DT` package.
    This function works as any other `render*()` function, it receives a single parameter,
    which is an expression that returns a value which will be the content of the observer.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，我们需要修改我们之前未曾触及的 `server` 函数。我们需要在其中引入一些逻辑，以便能够将数据从 R 移动到网页界面。为此，我们将它分配给其
    `output` 参数中的 `table` 元素，该元素将充当观察者。我们分配给它的元素名称可以是任何我们希望的有效列表元素，但使用描述观察者内容的名称是个好主意。请记住，这些名称必须是唯一的，因为
    Shiny 将使用它们来识别在 `ui` 对象和 `server` 函数之间传递和接收的对象。观察者是通过 `DT` 包中的 `renderDataTable()`
    函数创建的。这个函数就像任何其他的 `render*()` 函数一样工作，它接收一个参数，该参数是一个返回值的表达式，该值将是观察者的内容。
- en: 'In this case, the data table created with the `datatable()` function, again
    from the `DT` package. To create this data table, we are simply passing the `ORIGINAL_DATA` object
    we loaded previously. Now that the server-side adjustment is finished, we add
    a `fluidRow()` instead of `"Content 2"` in the `ui` object to introduce a row
    that will adjust its length according to the web browser''s dimensions, and inside
    of it, we call the `dataTableOutput()` function from the `DT` package. Note that
    the string sent as the only parameter to this function is the name of the element
    we assigned to the `output` parameter in the `server` function. This is the mechanism
    that Shiny uses to move data from the `server` to the `ui`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用 `DT` 包中的 `datatable()` 函数创建的数据表。为了创建这个数据表，我们只是传递之前加载的 `ORIGINAL_DATA`
    对象。现在服务器端调整完成后，我们在 `ui` 对象中添加一个 `fluidRow()` 而不是 `"Content 2"`，以引入一个根据网页浏览器尺寸调整其长度的行，并在其中调用
    `DT` 包中的 `dataTableOutput()` 函数。请注意，作为此函数唯一参数发送的字符串是我们在 `server` 函数中分配给 `output`
    参数的元素名称。这是 Shiny 用于从 `server` 向 `ui` 传递数据的机制：
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that our code is ready, we should see a table appear in the Data Overview tab.
    This table is dynamic in the sense that you may order its columns by clicking
    on the column titles, as well as change the number of observations shown, and
    search through its contents. Also note that a pagination mechanism was automatically
    added for us along with an observation counter. These tables are very easy to
    create, yet very useful, and we will see later in this chapter how to expand their
    functionality even more.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们代码已经准备好了，我们应该在“数据概览”标签页中看到一个表格出现。这个表格是动态的，这意味着你可以通过点击列标题来对列进行排序，以及更改显示的观测数，并搜索其内容。此外，请注意，自动为我们添加了分页机制和观测计数器。这些表格非常容易创建，但非常有用，我们将在本章后面看到如何进一步扩展它们的功能。
- en: '![](img/00069.jpeg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00069.jpeg)'
- en: Introducing interactivity with user input
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过用户输入引入交互性
- en: The interactivity we saw previously with the dynamic data table works within
    the web browser itself using JavaScript, and it does not need to go through the
    `server` function to provide the interactivity, only to pass the table itself.
    However, many interesting interactivity features need to go through the `server`
    so that we can provide custom responses for them. In this section, we show how
    to add various types of inputs to our application.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到的与动态数据表交互的交互性是在网页浏览器本身内使用JavaScript实现的，它不需要通过`server`函数提供交互性，只需传递表格本身即可。然而，许多有趣的交互功能需要通过`server`来实现，这样我们就可以为它们提供定制的响应。在本节中，我们展示如何将各种类型的输入添加到我们的应用程序中。
- en: Setting up static user inputs
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置静态用户输入
- en: 'First, we will show how to filter the timestamps in the data to only show observations
    that fall within a range defined by the user. To do this, we need to first define
    four timestamps: the minimum, the initial left limit, the initial right limit,
    and the maximum. These four values will be used by our date range widget to define
    the allowed range for the user (the minimum and maximum values are used for this),
    as well as the initial date range (the initial left and right limits are used
    for this), which may be different from the limits of the allowed range.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将展示如何过滤数据中的时间戳，只显示用户定义范围内的观测值。为此，我们首先需要定义四个时间戳：最小值、初始左边界、初始右边界和最大值。这四个值将由我们的日期范围小部件用于定义用户允许的范围（最小值和最大值用于此目的），以及初始日期范围（初始左边界和右边界用于此），这些可能不同于允许范围的限制。
- en: Therefore, we need to extract such values, and we do so by making use of the
    `TimeStamp` class we created in [Chapter 8](part0178.html#59O440-f494c932c729429fb734ce52cafce730),
    *Object-Oriented System to Track Cryptocurrencies*. Note that we use the `days()` function
    from the `lubridate` package (you should add the  `library(lubridate)` line at
    the top of your file), just as we did in the mentioned chapter.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要提取这样的值，我们通过使用我们在[第8章](part0178.html#59O440-f494c932c729429fb734ce52cafce730)中创建的`TimeStamp`类来实现，该章节是*面向对象的加密货币跟踪系统*。请注意，我们使用`lubridate`包中的`days()`函数（你应在文件顶部添加`library(lubridate)`行），就像在提到的章节中做的那样。
- en: 'Since we only need to create these objects once, they should go just below the
    code that is used to load the `ORIGINAL_DATA`, before the `ui` object definition:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只需要创建这些对象一次，因此它们应该位于用于加载`ORIGINAL_DATA`的代码下方，在`ui`对象定义之前：
- en: '[PRE6]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `timestamp_to_date_string()` function in the `TimeStamp` class had not
    been created and we added it for this chapter. It is very simple and is shown
    in the following code. Its objective is to simply get the first 10 characters
    of a `TimeStamp`, which correspond to the format YYYY-MM-DD:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`TimeStamp`类中的`timestamp_to_date_string()`函数尚未创建，我们为此章节添加了它。它非常简单，如下面的代码所示。其目的是简单地获取`TimeStamp`的前10个字符，这对应于格式YYYY-MM-DD：'
- en: '[PRE7]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that we have created these objects, we may use the following code to expand
    the `ui` object. What we did was replace the `"Options"` string with a function
    call to `dateRangeInput()`, which is the function used to create a date range,
    as the name implies. It receives as parameters the unique identifier that will
    be used to retrieve its *reactive values* within the `server` through the `input`
    parameter, the `label` shown to the user, the `start`, `end`, `min`, and `max`
    values mentioned earlier, the `separator` we want to use among the web browser
    input boxes, the date `format` we want to use, and what day of the week it is
    considered to start on (`0` for Sunday, `1` for Monday, and so on):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了这些对象，我们可以使用以下代码来扩展`ui`对象。我们所做的是将`"Options"`字符串替换为对`dateRangeInput()`函数的调用，该函数用于创建日期范围，正如其名称所暗示的。它接收作为参数的唯一标识符，该标识符将通过`input`参数在`server`中检索其*反应值*，用户看到的`label`，前面提到的`start`、`end`、`min`和`max`值，我们希望在网页浏览器输入框之间使用的`separator`，我们想要使用的日期`format`，以及一周中哪一天被认为是开始日（`0`代表星期日，`1`代表星期一，依此类推）：
- en: '[PRE8]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: On the server side, we will add more logic within the *reactive experssion*
    passed as a parameter to the `datatable()` function. Instead of simply sending
    the raw `ORIGINAL_DATA` dataframe, we will filter it before we send it. To do
    so, we first assign a copy of it to the `data` object and extract the two date
    values from the widget we created in the `ui` object, using their references within
    the `input` parameter. Then, we check whether any of these is different from their
    initial values. In case they are, we update the `data` object with only those
    observations that are within the range specified, which we accomplish with a standard
    dataframe selection. Finally, we sent this filtered `data` to the `datatable()`
    function, and proceed as we did earlier.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，我们将在传递给 `datatable()` 函数的 *reactive expression* 中添加更多逻辑。我们不会简单地发送原始的 `ORIGINAL_DATA`
    数据框，而是在发送之前对其进行过滤。为此，我们首先将其副本分配给 `data` 对象，并从 `ui` 对象中创建的小部件中提取两个日期值，使用它们在 `input`
    参数中的引用。然后，我们检查这些值中的任何一个是否与它们的初始值不同。如果它们不同，我们将只使用那些在指定范围内观察到的 `data` 对象更新，这是通过标准的
    dataframe 选择来完成的。最后，我们将这个过滤后的 `data` 发送到 `datatable()` 函数，并继续我们之前所做的工作。
- en: 'The result of these changes to the `ui` and `server` is that we can now filter
    the dates allowed in the dynamic table shown in the Data Overview tab, which is
    something we could not do before. The date range widget in action is shown in
    the following screenshot. Try to change its dates and see how the dynamic table
    updates:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对 `ui` 和 `server` 的更改的结果是，我们现在可以过滤在数据概览选项卡中显示的动态表中的日期，这是我们之前无法做到的。以下截图显示了正在运行的日期范围小部件。尝试更改其日期，看看动态表是如何更新的：
- en: '![](img/00070.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00070.jpeg)'
- en: Setting up dynamic options in a drop-down
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在下拉列表中设置动态选项
- en: Now we will see how to add a drop-down input whose entries adapt to the tab
    the user is currently viewing. Specifically, we will add the possibility for the
    user to select which asset they want to use to filter the data. If you looked
    carefully, you may have noticed that the dynamic data table contains observations
    for both Bitcoin and Litecoin, which may be fine when we're just looking at the
    table, but it will be a problem when we attempt to show a price time-series because
    we will have data for more than one asset. We want to provide a mechanism to select
    only one of them, but we want to keep the option of looking at all of them together
    in the dynamic data table, just as we are doing now.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看到如何添加一个下拉输入，其条目会根据用户当前查看的选项卡进行调整。具体来说，我们将添加用户可以选择他们想要用于过滤数据的资产的可能性。如果您仔细观察，您可能会注意到动态数据表包含比特币和莱特币的观察结果，当我们只是查看表格时这可能没问题，但当我们尝试显示价格时间序列时，将会有多个资产的数据，这将成为一个问题。我们希望提供一个机制来选择其中之一，但我们还想保留在动态数据表中一起查看所有选项的能力，就像我们现在所做的那样。
- en: 'We start by creating the object that contains the unique asset names we currently
    have in the data. This is much better than hardcoding their names directly into
    code, since they will be automatically updated when our data changes, which would
    not be the case if we hardcoded them. This line should go just below the previous
    *global* objects, which only needs to be created once:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个包含当前数据中独特资产名称的对象。这比直接将它们的名称硬编码到代码中要好得多，因为当我们的数据发生变化时，它们将自动更新，而如果我们硬编码它们，则不会是这样。这一行应该位于之前的
    *global* 对象下方，这些对象只需要创建一次：
- en: '[PRE9]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Since the input widget in this case has dynamic logic, we can''t just create
    inside the `ui` object, we need to create it in the `server` function and pass
    it along to the `ui` object. The way to do it is by introducing a new observer
    into the `output` parameter, named `select_asset` in this case, which is created
    with the `renderUI()` function since it will contain a Shiny `*Input()` function.
    As we did with the `data` in the previous section, we will assign the *default*
    asset names, and only in the case that the user is the second tab which is the
    Data Overview tab (more on where this comes from below), will it also add the
    `All` option to the drop-down. Otherwise, it will just keep the asset names without
    the `All` option, which is what we want for the SMA graphs we will create later:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在此情况下输入小部件具有动态逻辑，我们无法直接在`ui`对象内部创建它，我们需要在`server`函数中创建它，并将其传递给`ui`对象。这样做的方法是引入一个新的观察者到`output`参数中，命名为`select_asset`，它通过`renderUI()`函数创建，因为它将包含一个Shiny
    `*Input()`函数。正如我们在上一节中对`data`所做的那样，我们将分配*默认*资产名称，只有在用户处于第二个标签页，即数据概览标签页的情况下（更多关于这个来源的信息见下文），它还会将`All`选项添加到下拉菜单中。否则，它将只保留资产名称，不包含`All`选项，这正是我们将在稍后创建的SMA图表所希望的：
- en: '[PRE10]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To actually provide a mechanism for the `server` to understand what tab the
    user is currently viewing, the `ui` object needs to be adjusted so that the `tabsetPanel()`
    function receives an `id` parameter with the name of the object that contains
    the current tab number, `tab_selected` in this case (which is the name used to
    check in the `server` function). Also, each tab within must have a value assigned
    with the `value` parameter, as is shown. This way we make sure that the Data Overview tab
    is identified with the `2` value.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实际上提供一个机制，让`server`理解用户当前查看的是哪个标签页，`ui`对象需要调整，以便`tabsetPanel()`函数接收一个带有包含当前标签页编号的对象名称的`id`参数，在这个例子中是`tab_selected`（这是在`server`函数中用来检查的名称）。此外，每个标签页内部都必须使用`value`参数分配一个值，正如所示。这样我们确保数据概览标签页与`2`值相关联。
- en: 'Also note that we added the `htmlOutput()` function call within the just introduced
    `wellPanel()` function call in the `sidePanel()` function. The `wellPanel()` visually
    groups panels to provide more intuitive interfaces for users, and the `htmlOutput()`
    function uses the name of an observer to know what to show in the web browser,
    the `select_asset` element of the `output` object in this case:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 还请注意，我们在`sidePanel()`函数中刚刚引入的`wellPanel()`函数调用内添加了`htmlOutput()`函数调用。`wellPanel()`函数在视觉上将面板分组，为用户提供更直观的界面，而`htmlOutput()`函数使用观察者的名称来确定在网页浏览器中显示什么，在这个例子中是`output`对象的`select_asset`元素：
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Having performed these changes, now we can see that our application shows an
    asset name drop-down with options `Bitcoin` and `Litecoin` when the user is in
    the Simple Moving Averagestab, and which also includes the `All` option when they
    are in the Data Overview tab, just as we wanted and as can be seen in the following
    screenshot:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些更改后，我们可以看到，当用户处于简单移动平均（Simple Moving Average）标签页时，我们的应用程序显示了一个资产名称下拉菜单，其中包括`Bitcoin`和`Litecoin`选项，并且当他们在数据概览（Data
    Overview）标签页时，还包括了`All`选项，正如我们想要的，也如以下截图所示：
- en: '![](img/00071.jpeg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/00071.jpeg)'
- en: Setting up dynamic input panels
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置动态输入面板
- en: The final two inputs we will introduce will be used for the SMA graphs later
    on. The first one is used to select which SMA implementation the user wants to
    use. The options are the `sma_efficient_1()`, `sma_efficient_2()`, `sma_delegated_fortran()`,
    and `sma_delegated_cpp()` functions we created in the previous chapter. The second
    one is used to define the period used for the SMA calculation, and which is used
    as input in one of the previous functions.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要引入的最后两个输入将用于稍后使用的SMA图表。第一个用于选择用户想要使用的SMA实现。选项包括我们在上一章中创建的`sma_efficient_1()`、`sma_efficient_2()`、`sma_delegated_fortran()`和`sma_delegated_cpp()`函数。第二个用于定义用于SMA计算的周期，并作为之前某个函数的输入。
- en: Since code can start being too repetitive and taking too much space, and since
    you have most likely understood the nesting patterns used in the creation of the
    `ui`, I will avoid repeating the full `ui` object declaration, and simply point
    where changes need to be made.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于代码可能会变得过于重复且占用太多空间，并且您很可能已经理解了在创建`ui`时使用的嵌套模式，我将避免重复完整的`ui`对象声明，而只是指出需要做出更改的地方。
- en: In this case, we want to add the following code after the `wellPanel()` function
    has ended and before the `sidebarPanel()` function ends. The following code will
    be the second parameter to `sidebarPanel()`, so don't forget to add a comma (",")
    after the `wellPanel()` function finishes, otherwise you will get an error.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在此情况下，我们想在 `wellPanel()` 函数结束后和 `sidebarPanel()` 函数结束前添加以下代码。以下代码将是 `sidebarPanel()`
    的第二个参数，所以别忘了在 `wellPanel()` 函数完成后添加一个逗号（","），否则您将得到一个错误。
- en: 'The `conditionalPanel()` function checks for a JavaScript condition, specified
    using a string, to decide whether or not a panel should be showed to the user.
    Since the `input` object is sent to the web browser through a JavaScript object
    conveniently named `input`, we can use that to get the value we''re looking for,
    which is whether or not the user is looking at the first tab, `"Simple Moving
    Averages"`. If she is, then we will show the panel:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`conditionalPanel()` 函数检查一个使用字符串指定的 JavaScript 条件，以决定是否向用户显示面板。由于 `input` 对象通过一个方便命名为
    `input` 的 JavaScript 对象发送到网页浏览器，我们可以使用它来获取我们想要的值，即用户是否正在查看第一个标签，“简单移动平均”。如果是的话，我们将显示面板：'
- en: JavaScript uses the dot (".") notation to access elements instead of the `money`
    (`$`) notation used in R.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 使用点（"."）表示法来访问元素，而不是 R 中使用的 `money` (`$`) 表示法。
- en: 'The panel shown is `wellPanel()` with two input objects inside: `radioButtons()` and
    `sliderInput()`. The first one receives the available options for the user in
    a list sent through the `choices` parameter (each element''s name is what is shown
    to the user, while each element''s value is used internally in R which are the
    SMA implementation names in this case), as well as the `selected` one by default.
    The second one receives the `min`, `max`, and default `value` for the numeric
    slider. Both receive the unique identifier and label as the first two arguments,
    as every other `*Input()` function does:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 展示的面板是 `wellPanel()`，其中包含两个输入对象：`radioButtons()` 和 `sliderInput()`。第一个接收用户可用的选项列表，通过
    `choices` 参数发送（每个元素的名称是显示给用户的，而每个元素的值在 R 中内部使用，在本例中是 SMA 实现名称），以及默认的 `selected`
    选项。第二个接收数字滑块的 `min`、`max` 和默认 `value`。两者都接收唯一标识符和标签作为前两个参数，就像其他每个 `*Input()` 函数一样：
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will leave the actual graphs creations for later, so we don''t need to change
    anything on the `server` side. At this point, the *reactive values* coming out
    of `input$sma_implementation` and `input$sma_period` will not be used. A screenshot
    showing how these inputs is shown as following. If you navigate to the Simple
    Moving Averages tab, they should be shown, but if you navigate to the Data Overview tab,
    they should be hidden:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把实际的图形创建留到以后，所以不需要在 `server` 端做任何改变。到目前为止，从 `input$sma_implementation` 和
    `input$sma_period` 出来的 `reactive values` 不会被使用。以下是一个截图，展示了这些输入是如何显示的。如果您导航到“简单移动平均”标签，它们应该会显示，但如果您导航到“数据概览”标签，它们应该被隐藏：
- en: '![](img/00072.jpeg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00072.jpeg)'
- en: As you can see, allowing users to interact with the application is not too hard,
    and is accomplished by using the `*Input()` functions in the `ui` object, whose
    *reactive values* in turn may be used in the `server` function.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，允许用户与应用程序交互并不太难，这是通过在 `ui` 对象中使用 `*Input()` 函数来实现的，其 `reactive values`
    可以在 `server` 函数中使用。
- en: Adding a summary table with shared data
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加包含共享数据的摘要表
- en: Now we will add a summary table on top of our dynamic data table. This summary
    table should be updated according to the assets selected (note the plural since
    we allow for the `All` case in this tab). Take a moment to try to think how you
    would implement this yourself? If you tried to replicate the pattern shown previously
    for the `data` object we showed before, you would have a correct but inefficient
    solution. The reason is that the logic to filter the data would be duplicated,
    which is unnecessary.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在我们的动态数据表顶部添加一个摘要表。这个摘要表应该根据所选资产更新（注意复数形式，因为我们允许在此标签中包含“所有”情况）。花点时间想想您会如何自己实现这个功能？如果您试图复制我们之前展示的
    `data` 对象的模式，您将得到一个正确但效率不高的解决方案。原因是过滤数据的逻辑会被重复，这是不必要的。
- en: To avoid this pitfall we show next how to share streams among different *reactive
    functions* using the `reactive()` function, which is a function that used to prepare
    *reactive values* for other *reactive functions*. In this case, we move all the
    logic we had created before into the expression sent as a parameter to this function
    and assign it to the `data` object, which is now a *reactive function* itself.
    Note that we also added a bit of code to check whether the current asset selection
    is different from `All` and if it is, then use that value to filter the data,
    similarly to how we filter it using dates.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个陷阱，我们接下来将展示如何使用`reactive()`函数在不同**反应函数**之间共享流，`reactive()`函数是一个用于为其他**反应函数**准备**反应值**的函数。在这种情况下，我们将之前创建的所有逻辑移动到作为参数发送给这个函数的表达式中，并将其分配给`data`对象，现在它本身就是一个**反应函数**。请注意，我们还添加了一些代码来检查当前资产选择是否不同于`All`，如果是，则使用该值来过滤数据，类似于我们使用日期过滤数据的方式。
- en: 'Once we have done that, we can replace the logic we had inside the `datatable()`
    function with a simple call to the `data()` reactive function, which will provide
    the expected dataframe. And now that we have extracted this logic, we can reuse
    the `data()` call in an other place, as we do in the `output$summary_table` observer
    created with the `renderTable()` function. As you can see, it''s being passed
    a dataframe created with statistics for the minimum, median, mean, and maximum
    of the dataframe returned by the `data()` function. In this case, we can guarantee
    that the data used in the `output$table()` and `output$summary_table()` functions
    is the same:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了这个操作，我们可以用对`data()`反应函数的简单调用替换`datatable()`函数内部的逻辑，这个反应函数将提供预期的数据框。现在我们已经提取了这部分逻辑，我们可以在使用`renderTable()`函数创建的`output$summary_table`观察者中重用`data()`调用。正如你所见，它传递了一个使用`data()`函数返回的数据框的统计数据创建的数据框。在这种情况下，我们可以保证在`output$table()`和`output$summary_table()`函数中使用的数据是相同的：
- en: '[PRE13]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Be careful if you're using stochastic data (for example, random numbers) if
    you're duplicating data logic instead of using a `reactive()` function, since
    you will probably not end up with the same data in both places.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在使用随机数据（例如，随机数）且没有使用`reactive()`函数而是复制数据逻辑，请务必小心，因为你可能无法在这两个地方得到相同的数据。
- en: 'We also need to introduce the corresponding function call in the `ui` object,
    which we place in the corresponding `tabPanel()`. To place in this the dataframe
    we just created, we use the `tableOutput()` function with the corresponding `summary_table` string
    as parameter. The code is as follows (note that I omit the `ui` code around this
    snippet):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在`ui`对象中引入相应的函数调用，我们将它放在相应的`tabPanel()`中。为了将我们刚刚创建的数据框放入其中，我们使用带有相应`summary_table`字符串参数的`tableOutput()`函数。代码如下（注意，我省略了这段代码周围的`ui`代码）：
- en: '[PRE14]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After implementing these changes, you should see a summary table with the mentioned
    statistics on top of the dynamic data table, and they should update as different
    values are sent as inputs for dates and asset selection.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 实施这些更改后，你应该会看到一个包含所提统计数据的摘要表，位于动态数据表顶部，并且当作为日期和资产选择的输入发送不同值时，它们应该会更新。
- en: '![](img/00073.jpeg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00073.jpeg)'
- en: Adding a simple moving average graph
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加简单移动平均图表
- en: Now we will create our first **simple moving average** (**SMA**) graph. This
    graph will be created with the   package, and will show two lines. The black line
    will be the actual price data, and the blue line will be SMA.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建我们的第一个**简单移动平均**（**SMA**）图表。这个图表将通过`package`创建，并显示两条线。黑色线将是实际的价格数据，蓝色线将是SMA。
- en: 'Before we begin, and since `ggplot2` graphs which make use of dates are better
    created with actual dates instead of timestamp strings, we add the `time` column
    to the `ORIGINAL_DATA` dataframe with the corresponding dates. This should be
    placed immediately after having loaded the data:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，由于使用日期的`ggplot2`图表比使用时间戳字符串创建得更好，我们在`ORIGINAL_DATA`数据框中添加了相应的日期的`time`列。这应该放在加载数据后立即进行：
- en: '[PRE15]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Next we show how our `sma_graph()` function is implemented. As can be seen,
    it will receive two parameters, the `data` dataframe and the `sma` vector coming
    out of one of the SMA implementations mentioned before. The function is very simple,
    it creates a graph with `time` on the *x* axis and `price_usd` on the *y* axis,
    adds points and lines for such data, and then adds a second blue line with the
    values from the `sma` vector. The `group = 1` parameter is used to avoid any errors
    by telling the `ggplot()` function that there's a single group in that data, and
    the `size = 1` parameter is just to make the line stand out a little bit more.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们展示如何实现我们的 `sma_graph()` 函数。如所见，它将接收两个参数，即 `data` 数据框和从前述 SMA 实现中出来的 `sma`
    向量。该函数非常简单，它创建一个以 `time` 为 *x* 轴和 `price_usd` 为 *y* 轴的图，为这些数据添加点和线，然后添加一个来自 `sma`
    向量的第二个蓝色线。`group = 1` 参数用于避免任何错误，告诉 `ggplot()` 函数该数据中只有一个组，而 `size = 1` 参数只是为了使线条更加突出。
- en: 'Note that we return the graph object. Finally, you should keep in mind that
    using the `geom_line()` function introduces interpolation into the example, which
    may misrepresent the discrete data we have for prices, but it can also be helpful
    to understand the price dynamics, and that''s why we use it:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们返回的是图对象。最后，你应该记住，使用 `geom_line()` 函数将插值引入到示例中，这可能会错误地表示我们为价格所拥有的离散数据，但它也有助于理解价格动态，这就是我们使用它的原因：
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, to follow good practices, we place the SMA calculation in a `reactive()`
    function of its own (just below the `data` *reactive function* we created before).
    Note that it's a *reactive function* that depends on another *reactive function*,
    `data()` to be precise.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了遵循良好的实践，我们将 SMA 计算放在一个自己的 `reactive()` 函数中（就在我们之前创建的 `data` *reactive function*
    下方）。请注意，这是一个依赖于另一个 *reactive function* 的 *reactive function*，即 `data()` 函数。
- en: 'The following code (which omits the rest of the `server` function), shows that
    this `sma` definition makes use of the `do.call()` function to execute the implementation
    name we receive as a *reactive value* from the `input$sma_implementation` widget.
    The `do.call()` also receives a list as the second parameter, and this list contains
    the parameters that will be sent to the actual function we want to call. In this
    case, it''s the `input$sma_period`, the `symbol` (which in this case will be a
    single one because we restricted data for this tab to have a single asset), and
    the actual data through the call to the `data()` *reactive function*:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码（省略了 `server` 函数的其余部分）显示，这个 `sma` 定义使用了 `do.call()` 函数来执行我们从 `input$sma_implementation`
    小部件接收到的作为 *reactive value* 的实现名称。`do.call()` 还接收一个列表作为第二个参数，这个列表包含将发送到我们想要调用的实际函数的参数。在这种情况下，它是
    `input$sma_period`，`symbol`（在这种情况下将是一个单一值，因为我们限制了这个标签页的数据只有一个资产），以及通过调用 `data()`
    *reactive function* 的实际数据：
- en: '[PRE17]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Having implemented this `sma()` reactive function, we can implement the observer
    `output$graph_top()` as follows (again, we omitted some code around):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现了这个 `sma()` *reactive function* 之后，我们可以按照以下方式实现观察者 `output$graph_top()`（再次省略了一些代码）：
- en: '[PRE18]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, we need to update our `ui` object to replace the `"Content 1"` placeholder
    with a `fluidRow()` and a `ploutOutput()` inside. We send the `"graph_top"` unique
    identifier to the observer we are interested in:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要更新我们的 `ui` 对象，用 `fluidRow()` 和 `ploutOutput()` 替换 `"Content 1"` 占位符。我们发送
    `"graph_top"` 唯一标识符到我们感兴趣的观察者：
- en: '[PRE19]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This was simple enough, wasn''t it? Now we can run our application, and it
    should show us a graph for the first two days in the data, with a blue SMA(30)
    on top as the one shown in the following screenshot:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，不是吗？现在我们可以运行我们的应用程序，它应该显示数据的前两天，上面有一个蓝色 SMA(30) 如下截图所示：
- en: '![](img/00074.jpeg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00074.jpeg)'
- en: Note that you can change the options and the graph will update accordingly.
    For example, if we chose only the first day in the data and decide to graph only
    an SMA(5) on top of it.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你可以更改选项，并且图表将相应更新。例如，如果我们只选择了数据中的第一天，并决定在上面绘制 SMA(5)。
- en: '![](img/00075.jpeg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00075.jpeg)'
- en: 'Finally, if your computer can handle it, you may decide to show the full data
    (which is quite a bit of observations, so do be careful). In that case, the SMA
    would not be visible, but it will still be plotted for us. The result is shown
    in the following image:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你的电脑可以处理，你可能会决定显示完整的数据（这有很多观察值，所以请小心）。在这种情况下，SMA 将不可见，但它仍然会被绘制出来。结果如图所示：
- en: '![](img/00076.jpeg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00076.jpeg)'
- en: Adding interactivity with a secondary zoom-in graph
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过添加一个二级缩放图来增加交互性
- en: Finally, we are going to add some interactivity to our graph by implementing
    another similar graph, which will exhibit a *zoom-in* effect on the one we created
    before. The idea is that we can select an area of the graph we just created and
    the one we will place below it will update to only show the specific area we have
    selected. Seems interesting, doesn't it?
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将通过实现另一个类似的图表来为我们的图形添加一些交互性，该图表将对之前创建的图表产生*放大*效果。想法是，我们可以选择图形中我们刚刚创建的区域，下面放置的图形将只显示我们选择的特定区域。这听起来很有趣，不是吗？
- en: 'To accomplish this, we need to modify the `plotOutput()` we inserted at the
    end of the previous section to include a `brush` parameter with a call to the
    `brushOpts()` function, which in turn receives the name of the unique identifier
    for the brush input we are creating. This parameter is used to create a special
    type of input, which retrieves a selected area from the graph shown in the web
    browser. We also add another `fluidRow()` with another `plotOutput()` just below
    it to contain the graph that will provide the *zoom-in* effect. The code is as
    follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个任务，我们需要修改之前章节末尾插入的`plotOutput()`，以包括一个带有对`brushOpts()`函数调用的`brush`参数，该函数接收我们创建的刷输入的唯一标识符。此参数用于创建一种特殊类型的输入，它从在网页浏览器中显示的图形中检索所选区域。我们还添加了另一个`fluidRow()`，其中包含另一个`plotOutput()`，位于其下方以包含将提供*放大*效果的图形。代码如下：
- en: '[PRE20]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now the `input$graph_brush` reactive value will contain a list with four elements
    inside `xmin`, `xmax`, `ymin`, and `ymax`, which are the coordinates that conform
    the area selected in the top graph. Our `ranges()` reactive function will use
    them to send the appropriate values as limits to the bottom graph. The way it
    works is that it will check whether `input$graph_brush` is `NULL`, and if it's
    not, meaning that an area is selected, then it will return a list with two elements,
    `x` and `y`, where each of these elements contains the appropriate coordinates.
    If `input$graph_brush` is `NULL`, then the `x` and `y` elements of the returned
    list will be `NULL`, which signals the `coord_cartesian()` function, which we
    will use on top of the `sma_graph()`, to avoid placing any constraints in the
    axes for the graph. The actual function is shown in the following code, and as
    other functions created with `reactive()`, it should be placed inside the `server` function.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`input$graph_brush`反应值将包含一个包含四个元素的列表`xmin`、`xmax`、`ymin`和`ymax`，这些坐标构成了顶部图形中选定的区域。我们的`ranges()`反应函数将使用它们将适当的值作为限制发送到底部图形。它的工作方式是检查`input$graph_brush`是否为`NULL`，如果不是，意味着已选择一个区域，那么它将返回一个包含两个元素的列表，`x`和`y`，其中每个元素都包含适当的坐标。如果`input$graph_brush`是`NULL`，那么返回列表的`x`和`y`元素将是`NULL`，这会向我们将要用于`sma_graph()`顶部的`coord_cartesian()`函数发出信号，以避免在轴上放置任何约束。实际函数如下所示，并且与其他使用`reactive()`创建的函数一样，它应该放在`server`函数内部。
- en: 'Also note that we need to make a small transformation to the values for the
    *x* axis because they are returned as integers, and not dates which is the type
    of object being used by `ggplot()` for that axis. We simply use the `as.POSIXct()` function
    to transform such integers into valid dates, using the `oring = "1970-01-01"`,
    which is what `ggplot()` uses by default. If we don''t make the transformation,
    we will get an error:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我们需要对*x*轴的值进行一些小的转换，因为它们作为整数返回，而不是`ggplot()`用于该轴的对象类型——日期。我们简单地使用`as.POSIXct()`函数将这样的整数转换为有效的日期，使用`oring
    = "1970-01-01"`，这是`ggplot()`默认使用的。如果我们不进行转换，我们将得到一个错误：
- en: '[PRE21]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now we are able to create the `output$bottom_graph` observer just as we created
    the previous graph, but in this case we will add the `coord_cartesian()` function
    on top of the graph object returned by `sma_graph()` to limit the axes values.
    Note that we use the `expand = FALSE` to enforce the limits coming from the `ranges()`
    reactive function, we just created in the preceding code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们能够创建`output$bottom_graph`观察者，就像我们创建之前的图表一样，但在这个情况下，我们将在`sma_graph()`返回的图形对象上添加`coord_cartesian()`函数来限制轴的值。请注意，我们使用`expand
    = FALSE`来强制使用`ranges()`反应函数提供的限制，这是我们之前代码中刚刚创建的：
- en: '[PRE22]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Having implemented these changes, we should have the desired effect. To test
    it, we can open the application and see the two identical plots one on top of
    the other, like the following screenshot shows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 实施了这些更改后，我们应该会得到期望的效果。为了测试它，我们可以打开应用程序，查看两个重叠的相同图表，如下面的截图所示：
- en: '![](img/00077.jpeg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00077.jpeg)'
- en: However, if we select an area on the top graph, then the graph on the bottom
    should update showing only that specific part of the graph. Pretty cool, isn't
    it?
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们选择顶部图表上的某个区域，那么底部图表应该更新，只显示该特定部分的图表。这很酷，不是吗？
- en: '![](img/00078.jpeg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00078.jpeg)'
- en: Finally, you should know that another way to introduce interactive graphics
    is to use well known JavaScript like `Plot.ly` (which we used in [Chapter 5](part0110.html#38STS0-f494c932c729429fb734ce52cafce730),
    *Communicating Sales With Visualizations*). Shiny creates websites that use JavaScript
    in the background so this technique is a natural fit. However, this is an advanced
    technique and its use is more involved than what we have shown here, so we won't
    show it but you should know it's possible in case you want to pursue it yourself.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您应该知道，引入交互式图形的另一种方法是使用众所周知的JavaScript，如`Plot.ly`（我们在第5章[part0110.html#38STS0-f494c932c729429fb734ce52cafce730]，*通过可视化沟通销售*中使用过）。Shiny创建的网站在后台使用JavaScript，因此这种技术是一个自然的选择。然而，这是一个高级技术，其使用比我们在这里展示的要复杂得多，所以我们不会展示它，但您应该知道这是可能的，以防您想自己尝试。
- en: Styling our application with themes
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用主题美化我们的应用
- en: Up to this point, we have been using the theme provided by default by Shiny,
    but now that our application is finished, we want to stylize it with some tech-looking colors.
    In that case, we can use the `shinythemes` and `ggthemr` packages, which provide
    us with an easy way to apply themes to Shiny applications and `ggplot2` graphs,
    respectively.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用Shiny默认提供的主题，但现在我们的应用已经完成，我们希望用一些看起来像科技感的颜色来美化它。在这种情况下，我们可以使用`shinythemes`和`ggthemr`包，它们为我们提供了将主题应用于Shiny应用和`ggplot2`图表的简单方法。
- en: 'All we need to do to apply the themes is to tell the `ggplot2` framework to
    apply the *flat dark* theme provided by the `ggthemr` package, and to make sure
    that the *outer* side of the graph is also stylized we use the `type = outer` parameter,
    as is shown here. The code should be placed wherever we placed our `ggplot2` code
    for cohesiveness, which is in the `functions.R` file for this chapter:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要应用主题所做的全部事情就是告诉`ggplot2`框架应用由`ggthemr`包提供的*扁平暗色*主题，并且为了确保图表的*外部*部分也被美化，我们使用`type
    = outer`参数，如下所示。代码应该放在我们放置`ggplot2`代码的地方，以确保连贯性，对于本章来说是在`functions.R`文件中：
- en: '[PRE23]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To stylize the Shiny application itself, we send the `theme` parameter, using
    the `shinytheme()` function, to the `fluidPage()` function just before our `titlePanel()`
    function call, as is shown here:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要美化Shiny应用本身，我们通过`shinytheme()`函数将`theme`参数发送到`fluidPage()`函数，就在调用`titlePanel()`函数之前，如下所示：
- en: '[PRE24]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We also change the SMA line in the graphs to white, which you already know
    how to do, and with these changes, now our application looks pretty high tech.
    The following shows the Simple Moving Average tab:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将图表中的SMA线改为白色，这个操作您已经知道如何做了，并且通过这些改动，现在我们的应用看起来相当高科技。以下展示了简单移动平均（Simple Moving
    Average）标签页：
- en: '![](img/00079.jpeg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00079.jpeg)'
- en: 'And here you can see a screenshot of the Data Overview tab:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这里您可以看到数据概览标签页的截图：
- en: '![](img/00080.jpeg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00080.jpeg)'
- en: 'To find other themes you can look at the `shinythemes` repository ([http://rstudio.github.io/shinythemes/](http://rstudio.github.io/shinythemes/))
    and the `ggthemr` repository ([https://github.com/cttobin/ggthemr](https://github.com/cttobin/ggthemr)). To
    make sure the readers realize what the full code looks like at once, I place here
    the full code for the application as well as the function used for graphs:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找其他主题，您可以查看`shinythemes`仓库（[http://rstudio.github.io/shinythemes/](http://rstudio.github.io/shinythemes/））和`ggthemr`仓库（[https://github.com/cttobin/ggthemr](https://github.com/cttobin/ggthemr)）。为了确保读者能够立即意识到完整的代码是什么样的，我在这里也放置了应用的完整代码以及用于图表的函数：
- en: '[PRE25]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Other topics of interest
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他感兴趣的话题
- en: When working with Shiny there are common tasks that can be used to customize
    your web applications. Some of these tasks are adding static images, HTML, and
    CSS. In the following sections we will briefly look into how these can be accomplished
    with Shiny. Finally, we will also mention some options you have to share your
    application with others, without having to setup your own web server, so that
    they can use it in their web browser, through an internet connection.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Shiny时，有一些常见的任务可以用来自定义您的Web应用。其中一些任务包括添加静态图片、HTML和CSS。在接下来的章节中，我们将简要介绍如何使用Shiny实现这些功能。最后，我们还将提到一些选项，您可以使用这些选项与他人共享您的应用，而无需设置自己的Web服务器，这样他们就可以通过互联网连接在他们的Web浏览器中使用它。
- en: Adding static images
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加静态图片
- en: 'Images can enhance the appearance of your application and help your users understand
    the content. Shiny looks for the `img()` function to place image files in your
    application. To insert an image, simply call with the `src` specifying the images
    location. You can also include other HTML friendly parameters such as height and
    width (they will be passed as *pixel values*):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图片可以增强你应用程序的外观，并帮助用户理解内容。Shiny会查找`img()`函数来在你的应用程序中放置图片文件。要插入图片，只需使用`src`指定图片的位置。你还可以包含其他HTML友好参数，如高度和宽度（它们将以*像素值*传递）：
- en: '[PRE26]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `image.png` file must be in a folder named `www` in the same directory as
    the `app.R` script. Shiny will share any file placed here with your user's web
    browser, which makes `www` a great place to put images, style sheets, and other
    things the browser will need to build the wap components of your Shiny application.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`image.png`文件必须在与`app.R`脚本相同的目录中名为`www`的文件夹内。Shiny会将这里放置的任何文件与用户的网络浏览器共享，这使得`www`成为放置图片、样式表和其他浏览器需要构建你的Shiny应用程序Web组件的绝佳位置。'
- en: Adding HTML to your web application
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在你的Web应用程序中添加HTML
- en: It's easy to add HTML elements to your Shiny application using HTML tags. There
    are many elements you can add to your page using syntax like `tags$h1()` or `tags$p()` for
    a first-level heading and a paragraph, respectively. In the following piece of
    code, you can see how these would be used to create a page with one first-level heading,
    followed by a paragraph, a second-level heading, and then another paragraph.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HTML标签很容易将HTML元素添加到你的Shiny应用程序中。你可以使用诸如`tags$h1()`或`tags$p()`之类的语法添加许多元素到你的页面中，分别用于一级标题和段落。在下面的代码片段中，你可以看到这些是如何被用来创建一个包含一个一级标题、随后是一个段落、一个二级标题，然后是另一个段落的页面的。
- en: 'The full list of HTML tags can be found in the Shiny HTML Tags Glossary ([https://shiny.rstudio.com/articles/tag-glossary.html](https://shiny.rstudio.com/articles/tag-glossary.html)):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: HTML标签的完整列表可以在Shiny HTML标签术语表（[https://shiny.rstudio.com/articles/tag-glossary.html](https://shiny.rstudio.com/articles/tag-glossary.html)）中找到：
- en: '[PRE27]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Sometimes, however, you may need more control on the HTML you want to use.
    In that case you can actually specify HTML directly into your application by using
    the `HTML()` function. In this case, Shiny will not perform any escaping on your
    behalf, and you will have full HTML powers, you simply need to pass it raw HTML
    as is shown here. Note that this raw HTML may be included in other tags, as is
    the case here, where it''s wrapped by a `div` HTML tag:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时你可能需要对你想要使用的HTML有更多的控制。在这种情况下，你可以通过使用`HTML()`函数直接在你的应用程序中指定HTML。在这种情况下，Shiny不会为你执行任何转义，你将拥有完整的HTML功能，你只需传递如这里所示的原生HTML即可。请注意，这个原生HTML可以包含在其他标签中，就像这里一样，它被`div`HTML标签包裹：
- en: '[PRE28]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Adding custom CSS styling
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加自定义CSS样式
- en: Shiny uses the Bootstrap framework for structure and styling. If you're new
    to CSS **Cascading Style Sheets** (**CSS**) or are not familiar with Bootstrap,
    it would be a good idea to read the *Getting Started* guide ([https://getbootstrap.com/docs/3.3/getting-started/](https://getbootstrap.com/docs/3.3/getting-started/))
    before attempting to apply your own styling.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Shiny使用Bootstrap框架进行结构和样式设计。如果你是CSS **层叠样式表**（**CSS**）的新手或者不熟悉Bootstrap，在尝试应用自己的样式之前，阅读*入门指南*（[https://getbootstrap.com/docs/3.3/getting-started/](https://getbootstrap.com/docs/3.3/getting-started/))是个不错的选择。
- en: To include your own CSS, you have a couple of options, but we will only show
    how to use the `includeCSS()` function and how to apply styles directly into HTML
    tags. The `includeCSS()` function is provided by Shiny and can be used to include
    a CSS file directly from the `www` directory mentioned in the previous section.
    Its usage is fairly simply.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要包含你自己的CSS，你有几个选择，但我们只会展示如何使用`includeCSS()`函数以及如何直接将样式应用到HTML标签中。`includeCSS()`函数由Shiny提供，可以用来直接从上一节中提到的`www`目录包含CSS文件。其用法相当简单。
- en: Even though it's usually not a great idea because it's hard to find your styles
    and it's even harder to be consistent, sometimes it's useful to apply a style
    directly into a HTML tag. If you want to do so, you can send a `style` parameter
    to a specific tag.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管通常这不是一个好主意，因为很难找到你的样式，而且保持一致性更难，但有时直接将样式应用到HTML标签中是有用的。如果你想这样做，你可以向特定标签发送一个`style`参数。
- en: 'Let''s assume that you have a file called `style.css` in the `www` directory
    that provides all the styles you want, except the green color you want to apply
    to the *first-level* heading. Then, you may use the following code which includes
    both techniques:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个名为`style.css`的文件位于`www`目录中，它提供了你想要的所有样式，除了你想要应用到*一级标题*上的绿色颜色。然后，你可以使用以下代码，它包含了这两种技术：
- en: '[PRE29]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Sharing your newly created application
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分享你新创建的应用程序
- en: Although Shiny applications end up as HTML files you can't simply copy them
    to your server. They require a Shiny server, just like the one we have been working
    with through this chapter. There are two ways to run Shiny applications (as any
    other application), locally or remotely. Locally means that you fire up an R installation
    with Shiny and the required dependencies, and run it just as we have been doing
    during this chapter. Remotely means that you can access it through a website,
    which can be very cool and convenient at times.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Shiny应用程序最终以HTML文件的形式呈现，但你不能简单地将其复制到你的服务器上。它们需要一个Shiny服务器，就像我们在本章中一直在使用的那样。运行Shiny应用程序（就像其他任何应用程序一样）有两种方式：本地或远程。本地意味着你需要启动一个带有Shiny和所需依赖项的R安装程序，并像我们在本章中做的那样运行它。远程意味着你可以通过一个网站访问它，这在某些时候可能会非常酷和方便。
- en: 'To run locally you need to have the files for the application in the computer
    that will execute them. There are many ways to do so, but the most common one
    is to upload them to a Git repository, download them from there, and follow the
    steps you already know. Furthermore, if your files are in a Git repository hosted
    in GitHub ([https://www.github.com](https://www.github.com)), you may use the
    `runGitHub()` function with the name of the repository and the username of the
    account that holds the repository. In that case, the downloading, unpacking, and
    execution will be done for you. For example, to run the application we developed
    through this chapter, you may use the following line:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要本地运行，你需要将应用程序的文件放在将要执行它们的计算机上。有许多方法可以做到这一点，但最常见的一种是将它们上传到Git仓库，从那里下载，然后遵循你已知的步骤。此外，如果你的文件存储在GitHub（[https://www.github.com](https://www.github.com)）上托管的Git仓库中，你可以使用带有存储库名称和拥有存储库的账户用户名的`runGitHub()`函数。在这种情况下，下载、解包和执行将由你完成。例如，要运行本章中开发的应用程序，你可以使用以下行：
- en: '[PRE30]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you want to provide remote access to your application, you have many options,
    but the main ones are three: ShinyApps, RStudio Connect, and Shiny Server. **ShinyApps**
    ([https://www.shinyapps.io](https://www.shinyapps.io)) offers this service for
    free for small applications with limited visits and can scale up in paid versions.
    **RStudio Connect** ([https://www.rstudio.com/products/connect/](https://www.rstudio.com/products/connect/))
    is a publishing platform for Shiny applications and R Markdown reports. With it,
    you can publish directly from RStudio. Finally, **Shiny Server** ([https://www.rstudio.com/products/shiny/shiny-server/](https://www.rstudio.com/products/shiny/shiny-server/))
    is an open source version of the Shiny server you''ve been using in this chapter,
    with the added benefit that you can run it in the Linux servers you control (of
    course, this includes servers from cloud providers). RStudio also sells a yearly
    subscription to Shiny Server Pro, which provides security, administration, and
    other enhancements when compared to the open source version.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要提供对应用程序的远程访问，你有许多选择，但主要的有三个：ShinyApps、RStudio Connect和Shiny Server。**ShinyApps**
    ([https://www.shinyapps.io](https://www.shinyapps.io))为小型应用程序提供免费服务，访问量有限，并且可以通过付费版本进行扩展。**RStudio
    Connect** ([https://www.rstudio.com/products/connect/](https://www.rstudio.com/products/connect/))是一个Shiny应用程序和R
    Markdown报告的发布平台。使用它，你可以直接从RStudio发布。最后，**Shiny Server** ([https://www.rstudio.com/products/shiny/shiny-server/](https://www.rstudio.com/products/shiny/shiny-server/))是本章中使用的Shiny服务器的开源版本，额外的好处是你可以在你控制的Linux服务器上运行它（当然，这包括云服务提供商的服务器）。与开源版本相比，RStudio还出售Shiny
    Server Pro的年度订阅，它提供了安全、管理和其他增强功能。
- en: Summary
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As we saw throughout the chapter, using the *functional reactive programming*
    paradigm to create powerful web applications using Shiny is not necessarily difficult.
    It only requires good concept understanding and a bit of exploration.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章中看到的那样，使用*函数式响应式编程*范式通过Shiny创建强大的Web应用程序并不一定困难。这只需要良好的概念理解和一点探索。
- en: We showed how to provide inputs for users to be able to send *reactive values*
    to the backend, that is, the `server`, and have it respond adequately to such
    streams of events. We also showed how to add more sophisticated interactions such
    as the the two graphs with the zoom-in effect.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了如何为用户提供输入，使他们能够向后端发送*反应性值*，即向`服务器`发送，并使其能够适当地响应这些事件流。我们还展示了如何添加更复杂的交互，例如带有缩放效果的两个图表。
- en: This is the final chapter for the book, and you saw how to use many of the tools
    provided by Shiny to create interactive applications. However, we have just scratched
    the surface of what is possible with Shiny and R in general. I hope you take what
    you have learned in this book and create amazing applications. Thank you for making
    it this far! I wish you the best of luck.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书的最后一章，您看到了如何使用Shiny提供的许多工具来创建交互式应用程序。然而，我们只是触及了Shiny和R在一般情况下的可能性的一小部分。希望您能将本书中学到的知识应用到创建令人惊叹的应用程序中。感谢您走到这一步！祝您好运！
