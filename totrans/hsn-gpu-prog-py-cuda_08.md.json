["```py\n__device__ void curand_init ( unsigned long long seed, unsigned long long sequence, unsigned long long offset, curandState_t *state)\n```", "```py\nimport pycuda.autoinit\nimport pycuda.driver as drv\nfrom pycuda import gpuarray\nfrom pycuda.compiler import SourceModule\nimport numpy as np\nfrom sympy import Rational\n```", "```py\nker = SourceModule(no_extern_c=True, source='''\n#include <curand_kernel.h>\n```", "```py\n#define _PYTHAG(a,b) (a*a + b*b)\n#define ULL unsigned long long\n```", "```py\nextern \"C\" {\n```", "```py\n__global__ void estimate_pi(ULL iters, ULL * hits)\n{\n    curandState cr_state;\n```", "```py\nint tid = blockIdx.x * blockDim.x + threadIdx.x;\n```", "```py\ncurand_init( (ULL) clock() + (ULL) tid, (ULL) 0, (ULL) 0, &cr_state);\n```", "```py\nfloat x, y;\n```", "```py\nfor(ULL i=0; i < iters; i++)\n {\n     x = curand_uniform(&cr_state);\n     y = curand_uniform(&cr_state);\n\n     if(_PYTHAG(x,y) <= 1.0f)\n         hits[tid]++;\n }\n```", "```py\nreturn;\n}\n}\n''')\n```", "```py\npi_ker = ker.get_function(\"estimate_pi\")\nthreads_per_block = 32\nblocks_per_grid = 512\ntotal_threads = threads_per_block * blocks_per_grid\nhits_d = gpuarray.zeros((total_threads,),dtype=np.uint64)\n```", "```py\niters = 2**24\n```", "```py\npi_ker(np.uint64(iters), hits_d, grid=(blocks_per_grid,1,1), block=(threads_per_block,1,1))\n```", "```py\ntotal_hits = np.sum( hits_d.get() )\ntotal = np.uint64(total_threads) * np.uint64(iters)\n```", "```py\nest_pi_symbolic =  Rational(4)*Rational(int(total_hits), int(total) )\n```", "```py\nest_pi = np.float(est_pi_symbolic.evalf())\n```", "```py\nprint \"Our Monte Carlo estimate of Pi is : %s\" % est_pi\nprint \"NumPy's Pi constant is: %s \" % np.pi\nprint \"Our estimate passes NumPy's 'allclose' : %s\" % np.allclose(est_pi, np.pi)\n```", "```py\nimport pycuda.autoinit\nimport pycuda.driver as drv\nfrom pycuda import gpuarray\nfrom pycuda.compiler import SourceModule\nimport numpy as np\n```", "```py\nMonteCarloKernelTemplate = '''\n#include <curand_kernel.h>\n```", "```py\n#define ULL unsigned long long\n#define _R(z) ( 1.0f / (z) )\n#define _P2(z) ( (z) * (z) )\n```", "```py\n__device__ inline %(p)s f(%(p)s x)\n{\n    %(p)s y;\n    %(math_function)s;\n    return y;\n}\n```", "```py\nextern \"C\" {\n__global__ void monte_carlo(int iters, %(p)s lo, %(p)s hi, %(p)s * ys_out)\n{\n```", "```py\ncurandState cr_state;\nint tid = blockIdx.x * blockDim.x + threadIdx.x;\nint num_threads = blockDim.x * gridDim.x;\n```", "```py\n%(p)s t_width = (hi - lo) / ( %(p)s ) num_threads;\n```", "```py\n%(p)s density = ( ( %(p)s ) iters ) / t_width;\n```", "```py\n%(p)s t_lo = t_width*tid + lo;\n %(p)s t_hi = t_lo + t_width;\n```", "```py\ncurand_init( (ULL)  clock() + (ULL) tid, (ULL) 0, (ULL) 0, &cr_state);\n```", "```py\n%(p)s y, y_sum = 0.0f;\n%(p)s rand_val, x;\n```", "```py\nfor (int i=0; i < iters; i++)\n{\n    rand_val = curand_uniform%(p_curand)s(&cr_state);\n    x = t_lo + t_width * rand_val;\n    y_sum += f(x);\n}\n```", "```py\ny = y_sum / density;\n```", "```py\nys_out[tid] = y;\n}\n}\n'''\n```", "```py\ndef __init__(self, math_function='y = sin(x)', precision='d', lo=0, hi=np.pi, samples_per_thread=10**5, num_blocks=100):\n\n        self.math_function = math_function\n```", "```py\n         if precision in [None, 's', 'S', 'single', np.float32]:\n             self.precision = 'float'\n             self.numpy_precision = np.float32\n             self.p_curand = ''\n         elif precision in ['d','D', 'double', np.float64]:\n             self.precision = 'double'\n             self.numpy_precision = np.float64\n             self.p_curand = '_double'\n         else:\n             raise Exception('precision is invalid datatype!')\n\n     if (hi - lo <= 0):\n         raise Exception('hi - lo <= 0!')\n     else:\n         self.hi = hi\n         self.lo = lo\n```", "```py\nMonteCarloDict = {'p' : self.precision, 'p_curand' : self.p_curand, 'math_function' : self.math_function}\n```", "```py\nself.MonteCarloCode = MonteCarloKernelTemplate % MonteCarloDict\n\nself.ker = SourceModule(no_extern_c=True , options=['-w'], source=self.MonteCarloCode)\n```", "```py\nself.f = self.ker.get_function('monte_carlo')\nself.num_blocks = num_blocks\nself.samples_per_thread = samples_per_thread\n```", "```py\ndef definite_integral(self, lo=None, hi=None, samples_per_thread=None, num_blocks=None):\n    if lo is None or hi is None:\n        lo = self.lo\n        hi = self.hi\n    if samples_per_thread is None:\n        samples_per_thread = self.samples_per_thread\n    if num_blocks is None:\n        num_blocks = self.num_blocks\n        grid = (num_blocks,1,1)\n    else:\n        grid = (num_blocks,1,1)\n\n    block = (32,1,1)\n    num_threads = 32*num_blocks\n```", "```py\nself.ys = gpuarray.empty((num_threads,) , dtype=self.numpy_precision)\n\nself.f(np.int32(samples_per_thread), self.numpy_precision(lo), self.numpy_precision(hi), self.ys, block=block, grid=grid)\n\nself.nintegral = np.sum(self.ys.get() )\n\nreturn np.sum(self.nintegral)\n```", "```py\n'y = _R( 1 + sinh(2*x)*_P2(log(x)) )' \n```", "```py\nif __name__ == '__main__':\n\n    integral_tests = [('y =log(x)*_P2(sin(x))', 11.733 , 18.472, 8.9999), ('y = _R( 1 + sinh(2*x)*_P2(log(x)) )', .9, 4, .584977), ('y = (cosh(x)*sin(x))/ sqrt( pow(x,3) + _P2(sin(x)))', 1.85, 4.81, -3.34553) ]\n```", "```py\nfor f, lo, hi, expected in integral_tests:\n    mci = MonteCarloIntegrator(math_function=f, precision='d', lo=lo, hi=hi)\n    print 'The Monte Carlo numerical integration of the function\\n \\t f: x -> %s \\n \\t from x = %s to x = %s is : %s ' % (f, lo, hi, mci.definite_integral())\n    print 'where the expected value is : %s\\n' % expected\n```", "```py\n#include <thrust/host_vector.h>\n#include <thrust/device_vector.h>\n#include <iostream>\n```", "```py\nusing namespace std;\n```", "```py\nint main(void)\n{\n thrust::host_vector<int> v;\n```", "```py\nv.push_back(1);\nv.push_back(2);\nv.push_back(3);\nv.push_back(4);\n```", "```py\nfor (int i = 0; i < v.size(); i++)\n    cout << \"v[\" << i << \"] == \" << v[i] << endl;\n```", "```py\nthrust::device_vector<int> v_gpu = v;\n```", "```py\nv_gpu.push_back(5);\n```", "```py\nfor (int i = 0; i < v_gpu.size(); i++)\n    std::cout << \"v_gpu[\" << i << \"] == \" << v_gpu[i] << std::endl;\n```", "```py\n    return 0;\n}\n```", "```py\n#include <thrust/host_vector.h>\n#include <thrust/device_vector.h>\n#include <iostream>\nusing namespace std;\n```", "```py\nstruct multiply_functor {\n float w;\n multiply_functor(float _w = 1) : w(_w) {}\n```", "```py\n    __device__ float operator() (const float & x, const float & y) { \n        return w * x * y;\n     }\n};\n```", "```py\nfloat dot_product(thrust::device_vector<float> &v, thrust::device_vector<float> &w ), thrust::device_vector<float> &z)\n{\n thrust::device_vector<float> z(v.size());\n```", "```py\nthrust::transform(v.begin(), v.end(), w.begin(), z.begin(), multiply_functor());\n```", "```py\nreturn thrust::reduce(z.begin(), z.end());\n}\n```", "```py\nint main(void)\n{\n    thrust::device_vector<float> v;\n    v.push_back(1.0f);\n    v.push_back(2.0f);\n    v.push_back(3.0f);\n```", "```py\nthrust::device_vector<float> w(3);\nthrust::fill(w.begin(), w.end(), 1.0f);\n```", "```py\nfor (int i = 0; i < v.size(); i++)\n cout << \"v[\" << i << \"] == \" << v[i] << endl;\n\nfor (int i = 0; i < w.size(); i++)\n cout << \"w[\" << i << \"] == \" << w[i] << endl;\n```", "```py\ncout << \"dot_product(v , w) == \" << dot_product(v,w) << endl;\nreturn 0;\n}\n```"]