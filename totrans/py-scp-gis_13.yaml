- en: Geospatial REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Publishing data for consumption on the web is a major component of modern GIS.
    To transfer data from remote servers to remote clients, most geospatial publishing
    software stacks use **Representational State Transfer** (**REST**) web services.
    In response to web requests for specific data resources, REST services return
    **JavaScript Object Notation** (**JSON**)-encoded data to the requesting client
    machine. The web services are combined in an application programming interface,
    or API, which will contain the endpoints that represent each data resource available
    for querying.
  prefs: []
  type: TYPE_NORMAL
- en: By combining a Python web framework with **object-relational mapping** (**ORM**)
    and a PostGIS backend, we can create a custom REST API that will respond to web
    requests with JSON. For this exercise, we will use the Flask web framework and
    the SQLAlchemy module with GeoAlchemy2 providing spatial ORM capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: REST API components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON response formatting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to process `GET`, `POST`, `PUT`, and `DELETE` request methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing geospatial operations using the API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to deploy a Flask website using IIS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a REST API in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand the components of a REST API with JSON response, we will utilize
    the Flask web framework, a PostgreSQL/PostGIS database, and SQLAlchemy and GeoAlchemy2
    for ORM queries. Flask will be used to create the URL endpoints for the API. PostGIS
    will store the data in tables defined by SQLAlchemy models, which define the column
    types for all columns except the geometry columns, which are defined by GeoAlchemy2
    column types.
  prefs: []
  type: TYPE_NORMAL
- en: REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'REST is a standard for web services, designed to accept requests and parameters
    and return a representation of that data, usually in a JSON format but sometimes
    in XML or HTML format. APIs that use REST architecture must meet these architectural
    constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: Client-server interactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statelessness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cacheablitity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uniform interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layered system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client (a web browser or a remote computer) will send a request to a server
    at a designated URL endpoint. The request can include parameters that limit the
    data objects returned, much like conditionals in an SQL statement. It is stateless,
    meaning that each request must contain the request parameters and cannot refer
    to the results of another request. The data returned must be explicitly marked
    as cacheable or non-cacheable, to allow clients to decide if the data can be stored,
    or must be requested when required. When data is requested, all available API
    endpoints relating to the data (including links for adding or deleting data, if
    available) are returned as links along with the data representation. The underlying
    architecture of the server is not revealed by the API and can be manipulated (machines
    added or removed) without any change in the API structure.
  prefs: []
  type: TYPE_NORMAL
- en: JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSON is designed to be understood by humans and machines alike. JavaScript data
    objects are easily generated from Python dictionaries, as they use the same key
    value structure and curly bracket notation. Python contains a built-in library
    for generating JSON (the `json` module), and web frameworks such as Flask also
    include code for generating JSON responses.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple JSON standards exist for geospatial data, including GeoJSON and Esri
    JSON. Within this chapter, the REST API will use the GeoJSON format to respond
    to requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Read more about GeoJSON here: [http://geojson.org/](http://geojson.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: Python for REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is a fantastic language for writing a REST API. It has modules that allow
    for database queries and others that process the HTTP web requests into the URL
    and parameter components. Using these modules, the requested resource is retrieved
    from the database and returns the data as JSON using modules that convert between
    Python dictionaries and JSON objects.
  prefs: []
  type: TYPE_NORMAL
- en: While a Python-based API can be built using the standard library, using a web
    framework to build the API will speed up the development time and enable component
    modules to be added as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Flask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flask is a good choice for a Python web framework for a REST API. Partnered
    with SQLAlchemy and GeoAlchemy2 (see [Chapter 11](e483966e-f5c7-47dd-a40c-9b8b6f807107.xhtml), *Flask
    and GeoAlchemy2*, for more information on both), it allows the REST URL endpoints
    to be paired with a view (a Python function) that will process the request in
    different ways depending on the request method (such as `GET` and  `POST`, to
    name two examples) and return JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: REST modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As Flask is built to be extensible, there are many add-on modules that are
    designed to ease the creation of REST APIs. These include:'
  prefs: []
  type: TYPE_NORMAL
- en: Flask-RESTful ([https://flask-restful.readthedocs.io/en/latest/](https://flask-restful.readthedocs.io/en/latest/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eve ([http://python-eve.org/](http://python-eve.org/)), which is built on top
    of Flask and Cerberus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flask-REST-JSONAPI ([https://github.com/miLibris/flask-rest-jsonapi](https://github.com/miLibris/flask-rest-jsonapi))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will use vanilla Flask capabilities, along with SQLAlchemy and
    GeoAlchemy2 for database queries, to illustrate the basics of API creation.
  prefs: []
  type: TYPE_NORMAL
- en: Other frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django and GeoDjango (covered in [Chapter 12](a91ad85f-494d-4cc3-952f-d39a8933758e.xhtml),
    *GeoDjango*) are used extensively for REST API creation. With its batteries-included
    design motto, Django allows for easy API development. The Django REST framework
    adds easy API publication to the code base.
  prefs: []
  type: TYPE_NORMAL
- en: 'Explore the Django REST Framework here: [http://www.django-rest-framework.org/](http://www.django-rest-framework.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: Variables in Flask URLs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using Flask for URL processing, it is useful to understand how to add variables
    into URLs, as each resource may be requested using an ID or string identifier
    (for example, a state name). Flask URLs use placeholders to pass data into function
    parameters and utilize it as variables within the view for each endpoint. Using
    a converter, numerical data can be assigned a type within the placeholder; the
    default is a string type.
  prefs: []
  type: TYPE_NORMAL
- en: Number converters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, a placeholder with a converter for an integer ID is added
    at the end of the URL. By adding `int:` before the placeholder variable (`arena_id`),
    the ID can be used to query the `Arena` model/database table using the `get(id)`
    method of `session.query`, which expects an integer. If the datatype converter
    is not specified in the placeholder, the `arena_id` variable will contain a string
    character and won''t be used by the `get(id)` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With the parameter datatype specified, the requested `arena` object is returned
    by the ORM query and can be processed for a response.
  prefs: []
  type: TYPE_NORMAL
- en: Other data converters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Besides integers, which use the converter `int`, floating point data can be
    converted using `float`, and URL data can be converted using `path`. Strings,
    which use the converter `string`, are the default.  In this case, a `float` value
    is captured and used to compare against `county` geometry areas. As the SRID for
    this data is in WKID, the area is in an odd format, but this query will work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the value captured from the URL variable is compared to the
    `county` geometry using the `ST_Area` function, which borrows from PostGIS spatial
    SQL.
  prefs: []
  type: TYPE_NORMAL
- en: Read more about GeoAlchemy2 spatial functionality, and its use of spatial SQL,
    here: [http://geoalchemy-2.readthedocs.io/en/latest/spatial_functions.html](http://geoalchemy-2.readthedocs.io/en/latest/spatial_functions.html).
  prefs: []
  type: TYPE_NORMAL
- en: Request methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using a REST API, multiple HTTP request methods can be utilized. The `GET`
    method is used to request data, the `POST` method is used to add new data, the `PUT` method
    is used to update data, and the `DELETE` method is used to remove data from the
    database.
  prefs: []
  type: TYPE_NORMAL
- en: GET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For Flask URL endpoints, `GET` requests are specified using the method `GET`.
    Data can be passed as an argument and accessed using `request.args`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The response data, processed into a list of Python dictionaries using a list
    comprehension, is added to another Python dictionary, and then converted to JSON
    using `jsonify` from Flask.
  prefs: []
  type: TYPE_NORMAL
- en: POST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `POST` requests carry data that can be processed to add to a database.
    To differentiate a `POST` request, the Flask requests object has the `method`
    property, which can be checked to see if the request method was `GET` or `POST`.
    If we create a `form` (called `AddForm`) to add new `arenas` to the `Arenas` table,
    we could process the data submitted as a `POST` request and add it the database
    using the session manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As this method will accept both `GET` and `POST` requests, it sends a different
    response based on each request method.
  prefs: []
  type: TYPE_NORMAL
- en: Other available request methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While `GET` and `POST` are the main request methods, others are available for
    processing data. For the example API, we will only use `GET`, and `POST`, and
    `DELETE`.
  prefs: []
  type: TYPE_NORMAL
- en: PUT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to a `POST` request, a `PUT` request will carry data to update or add
    to a database. It will attempt to update the data multiple times to ensure complete
    transmission of the update.
  prefs: []
  type: TYPE_NORMAL
- en: DELETE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `DELETE` method will remove a resource from the specified endpoint, for
    example, deleting an `arena` from the `Arenas` table. It requires a record identifier
    to specify the resource to be removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The REST API application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To enable access to a database of NBA Arenas, US States, US Counties, and US
    Congressional Districts, we will build a REST API. The API will allow for queries
    about tables and about specific table resources, that is, rows of data. It will
    also allow for geospatial queries.
  prefs: []
  type: TYPE_NORMAL
- en: Application components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The components of this application include:'
  prefs: []
  type: TYPE_NORMAL
- en: The database, created in [Chapter 11](e483966e-f5c7-47dd-a40c-9b8b6f807107.xhtml), 
    *Flask and GeoAlchemy2*, which contains the tables for NBA Arenas, US States,
    US Counties, and US Congressional Districts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `app.py` file, which initiates the application when called by a Python executable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `application` folder, which contains the application code and folders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `__init__.py` file, which makes the `application` folder into a module,
    defines the Flask object and connects to the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `views.py` file, which defines the API endpoints, the view functions, and
    the return responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `models.py` file, which defines the database table models as Python classes
    that subclass from SQLAlchemy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `forms.py` file, which defines the HTML forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `static` and `templates` folders, which contain templates and data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application folder and file structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The example REST API requires specific files and folders to be created. The
    outer folder, called `arenaapp`, will contain the `app.py` file and the folder
    called `application`. Create the folder called `arenaapp`. Inside of it, create
    a folder called `application`. Inside of `application`, create the folders `static` and `templates`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ac1faae-182b-48c2-8d4b-36df91aa8089.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The other files, `views.py`, `models.py`, and `forms.py`, will be located inside
    of `application`. Two folders, `static` and `templates`, will store application
    data and HTML forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c2891c3-592b-4374-8a1d-c5a6e57bc6ed.png)'
  prefs: []
  type: TYPE_IMG
- en: app.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using an IDE or text editor, create a file inside `arenaapp` called `app.py`. Open
    this file and add the following lines; this file will be run by the Python executable
    to initiate the REST API application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `__init__.py` file allows the `application` folder to be imported by `app.py`,
    allowing the Flask object `app ` and its `app.run()` method to be called.
  prefs: []
  type: TYPE_NORMAL
- en: __init__.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Within the `application` folder, create a file called `__init__.py`. Inside
    of the file, add the following code (while adjusting the username and password
    to your specific database credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Within this file, the Flask object, `app`, is created and configured. To connect
    to the database, a connection string is used and stored in the `app.config` dictionary
    as the `'SQLALCHEMY_DATABASE_URI'`. Remember to add the username and password
    into the connection string.
  prefs: []
  type: TYPE_NORMAL
- en: The database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This will connect to the database created in [Chapter 11](e483966e-f5c7-47dd-a40c-9b8b6f807107.xhtml),
    *Flask and GeoAlchemy2*.  It is generated from shapefiles that have been imported
    and structured to match the models described as we proceed. To ensure that the
    application will work, be sure that the database has been created and that the
    shapefiles were imported.
  prefs: []
  type: TYPE_NORMAL
- en: models.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within `models.py`, the SQLAlchemy and GeoAlchemy2 modules are imported and
    the database session is initiated. The database models have their schemas defined
    as Python classes, allowing for queries and data updates.
  prefs: []
  type: TYPE_NORMAL
- en: Importing required modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These modules enable the application to define the models and connect to the
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Declaring the session
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From the `app.config` dictionary, the database connection string is passed
    to the `create_engine` function. Once `engine` is bound to the `sessionmaker`,
    a `session` can be initiated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: A Python class called `Base` is created from the `declarative_base()` function.
    The `Base` class is then used to subclass all application classes.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring the models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the models, all of the field types (for example, `Integer`, `String`, and `Float`)
    are defined using SQLAlchemy ORM-column classes, except for the geometry columns,
    which use the GeoAlchemy2  `Geometry` class. The `Geometry` class requires a geometry
    type and SRID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `County` class has a primary key field and a `name` field, as well as fields
    that define the many-to-one relationship with the `State` class. Instead of a
    `POINT` geometry type, it uses `MULTIPOLYGON`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `District` class represents US Congressional Districts. Stored with a `MULTIPOLYGON`
    geometry type and an SRID of `4326`, it has a many-to-one relationship with the
    `State` class. Each `district` stored is linked to the state in which it resides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `State` class has one-to-many relationships with the `County` and `District`
    classes respectively, defined using the `relationship` function. It also has a
    `MULTIPOLYGON` geometry column with an SRID of `4326`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With the fields and relationships defined, the next step is to create the REST
    API endpoints and write the views that will query the database and return GeoJSON
    responses.
  prefs: []
  type: TYPE_NORMAL
- en: forms.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To capture data from the user, such as a new `arena`, a form will be used.
    Create a file called `forms.py` inside the `application` folder, and add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This code will add the fields to a template, which will be discussed in the
    section on using `POST` methods. It will allow for code to be entered from an
    HTML template and passed to the server to add a new `arena`.
  prefs: []
  type: TYPE_NORMAL
- en: views.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The API endpoints and processing are contained within `views.py`. The views
    are imported within `__init__.py` to make them available to the `app` object.
    Open an IDE and save a file called `views.py` inside the `application` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Importing modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To enable the processing of web requests, we need to import functionality from
    Flask, GeoAlchemy2, and Shapely, a Python module for creating and processing geospatial
    data. We will also `import` the models and forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Base URL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each API pattern can be different, but should generally include a base URL
    that indicates the API version and should link to the other endpoints available
    within the API. This application will use a base URL pattern of `nba`*/*`api`*/*`v0.1`.
    In this case, the home URL (`''/''`) will `redirect` to the base URL of the API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The endpoints for each of the following sections are available from the base
    URL. Each resource URL can be constructed by adding the resource-specific endpoint
    to the base URL.
  prefs: []
  type: TYPE_NORMAL
- en: Arenas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To request data from the `Arenas` table, we will define API endpoints and use
    view functions to query the `Arenas` model. Each response will be a package as
    GeoJSON. This endpoint (`'/arena'`) will return a GeoJSON response, which will
    vary based on the presence of variables added to the URL. These variables include
    arena ID and name.
  prefs: []
  type: TYPE_NORMAL
- en: Getting all arenas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To generate a response containing a representation of all `arenas`, a query
    is made using the SQLAlchemy ORM. To convert the query results into GeoJSON, a list
    comprehension is used to generate a list of dictionaries that describe each `arena`
    returned from the ORM query. The resulting list (`data`) is then added to a dictionary,
    which is converted from a Python dictionary to a JSON object using the `jsonify`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `name` and `id` field is returned, as well as the `longitude` and `latitude`.
    To limit the amount of data transmitted, the `latitude` and `longitude` are rounded
    to `6` decimals.  The low amount of precision required to describe the location
    of an `arena` makes this a reasonable limitation. While point data types are easier
    to return given that they consist of only two points, producing less data, polygon
    and polyline data are much larger and require more precision.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compared to loops, list comprehensions decrease the processing time required
    for iterating over lists. Learn more about list comprehensions here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions. ](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions)'
  prefs: []
  type: TYPE_NORMAL
- en: Getting arenas by ID
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By adding a numeric ID to the `arena` endpoint, the specific `arena` will be
    located and returned. The `session.query` method `get` is used to retrieve the
    requested `arena` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The selected `arena` is added to a dictionary inside a list, which is then added
    to a dictionary and returned as JSON `data`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting arenas by name
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An `arena` can be requested by `name` at this endpoint. By utilizing a query
    condition, known as a `filter`, an `arena` matching the `name` provided will be
    retrieved. To add flexibility, a `like` operator is used (along with a `"%"` wildcard
    operator) to make it possible for the `arena` `name` entered to be complete. Instead,
    the string entered will be used to `filter` the query and return only `arena`
    objects whose names start with the string entered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'A list comprehension is used to generate the `arena` dictionaries. Here is
    an example of a response to a string query to the `arena` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c9a2ed6-0822-4ca2-a9a5-336bedb5c3c5.png)'
  prefs: []
  type: TYPE_IMG
- en: A geospatial query
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By adding one more URL component, the API is spatially enabled. Passing an
    `arena` ID and adding `"/intersect"` will use spatial queries to find data describing
    the requested NBA Arena. In this view function, the `County` and `District` tables
    are queried using an `intersect` `filter` (that is, the `county` containing the
    `arena` is identified using a point in polygon function). The underlying state
    is retrieved using a table relation between the `county` and the `state`. All
    of the geometry and the selected fields are returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: To ensure that the function is valid, the `if` conditional checks if the `arena`
    is inside a US `county`; if not, the `county`, `district`, and `state` objects
    are not used. Instead, the request is redirected to the non-geospatial query view
    function.
  prefs: []
  type: TYPE_NORMAL
- en: States
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The US States data can be large, due to the many vertices that make up each
    `state`. Within the endpoint for the `states`, we will add some URL parameters
    that will enable us to decide the geometry of each requested `state` should be
    returned.
  prefs: []
  type: TYPE_NORMAL
- en: Getting all states
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By checking for a URL argument in the `request.args` dictionary, and then checking
    if the argument evaluates as true, we can determine if all of the `state` geometries
    should be returned. The GeoJSON response is generated from the state''s geometry
    by using the `to_shape` function and the `shapely.geometry.geo.mapping` (shortened
    to `smapping`) function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If the `geometry` argument or parameter is not included, the geometry will be
    represented as truncated.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a state by ID
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get a specific `state` using the primary key ID of the `state`, we can add
    a URL variable that will check for an integer ID. It is returned with the `geometry`
    as a `geojson`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Getting a state by name
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using a `filter` will allow for a URL variable to be used as a `query` `filter`.
    The string variable will be checked against the state `name` field in the database
    table, and uses a `like` operator to do a fuzzy comparison (that is, it will get
    all `states` that start with `''M''` if the `state_name` variable is `''M''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This function has no URL parameters and will return the specified fields and
    `geometry` of the selected states.
  prefs: []
  type: TYPE_NORMAL
- en: Getting arenas by state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This function uses spatial analysis to find all `arenas` that are contained
    by the `state`. The `state` is identified by the ID, and the URL component within
    which it will select all `arenas` whose `geometry` is within the `state` `geometry`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The data returned will include the state `data` and `data` for all `arenas`,
    as GeoJSON allows for multiple datatypes to be packaged as a feature collection.
  prefs: []
  type: TYPE_NORMAL
- en: Counties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to the `State` database table, this will retrieve all of the `county`
    data. It accepts a `geometry` parameter to decide if it will return the `geometry`
    of each `county`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Getting a county by ID
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After retrieving all counties using the `get_counties` function, the ID of
    a specific `county` can be passed to this function. Using `session.query.(County).get(county_id)`
    allows for the retrieval of the `county` of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Getting a county by name
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Again, we can use a URL variable to collect a string, and use the string supplied
    for a query filter. If `Wash` is used as the URL variable `county_name`, the query
    will find all `counties` with names that start with `Wash`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `filter` method can be used on spatial fields as well as non-spatial fields.
  prefs: []
  type: TYPE_NORMAL
- en: Districts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Districts can be similarly added to the API. In this case, we will add a geometry
    parameter to decide if the geometry should be returned. This allows for the requesting
    machine or browser to get all of the districts and their IDs, which can be used
    to get the individual district in the next section, or to get all of the data
    at once, as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Getting all districts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This endpoint, (`''/district''`), will query against the `District` model using
    `session.query(District).all()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Getting a district by ID
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Passing the integer `district` ID will return only the requested representation
    of the `district`. The `geometry` is converted to GeoJSON format using `shapely`
    and the `to_shape` method from `geoalchemy2.shape`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Getting a district by name
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this case, the `name` of the district is the congressional `district` number.
    There is a `name` field, but it contains the name of the elected representative
    from that `district`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: All of these methods can be adjusted to include more parameters. Try adding
    in conditionals that check for fields to return, or another conditional. All URL
    parameter arguments are added after a question mark (`'?'`) in the query.
  prefs: []
  type: TYPE_NORMAL
- en: API POST endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Adding an `arena` can be accomplished using both JSON data and using an HTML
    form. In this section, we''ll create an HTML template, use the `AddForm` from
    `forms.py`, and use it to collect data from the `Leaflet.js` map included in [Chapter
    12](a91ad85f-494d-4cc3-952f-d39a8933758e.xhtml), *GeoDjango*, code bundle. It
    also uses the library jQuery to allow the user to click on the map at any location,
    thus updating the `longitude` and `latitude` data from the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d47507c-fec2-4274-b8c2-21b86bfeff40.png)'
  prefs: []
  type: TYPE_IMG
- en: New arenas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To add new arenas to the database `Arena` table, a view function for processing
    and a Jinja2 HTML template will be created and used. The function will determine
    the request method and will send the appropriate response to the request. If it
    is a `GET` request, it will send an HTML template with the `AddForm` form. From
    the HTML template, filling in the data and pushing the button will submit a `POST`
    request, which will go to the same view function, and will use the submitted data
    to add a new row to the `Arena` table.
  prefs: []
  type: TYPE_NORMAL
- en: The view function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The view function that will process the request accepts both `GET` and `POST`
    request methods. The endpoint `''/add''` is used in this case, though it could
    have been anything that differentiated it from the `arena` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Once the button is pushed, the data is submitted. The view function will determine
    what to do based on the request method—if it is a `POST` request, the data submitted
    in the `form` will be used to create a new `arena` object, and the session manager
    will save the object, adding it to the database.
  prefs: []
  type: TYPE_NORMAL
- en: The addarena.html head
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, let''s create the template called `addarena.html`, which will be added
    to the `templates` folder inside the `application` folder. At the top of the HTML
    file, in the head section, add the CSS, JavaScript, and jQuery libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The addarena.html script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the map `<div>` section and add the JavaScript that will enable map
    interactivity. If the map is clicked on, the JavaScript function `showMapClick`
    (which accepts an event `*e*`  as a parameter) will move the marker. Within the
    function, jQuery is used to set the value of the `latitude` and `longitude` `form`
    elements, getting the values from the event argument''s `e.latlng` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The addarena.html form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `form` data will be submitted with the `POST` method. Once the Add Arena
    button is pushed, the data inside the entry forms are submitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Clicking on the button will submit the data to the view function. The data
    will be processed, and a success JSON message returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b9892c1f-af5c-4d01-9343-aef4bc325fc3.png)'
  prefs: []
  type: TYPE_IMG
- en: Sending a POST request using the requests library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A new arena can be added using a web request, avoiding the need to use the
    HTML template. Here is a demonstration of a request using the `requests` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The POST request is sent to the `'/add'` endpoint, along with the required `form`
    parameters, as a Python dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting an arena
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Deleting an `arena` (or another resource) can also be done using a view function
    and a specific endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To delete an `arena`, send a request using the `delete` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Running the REST API locally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run this API application locally, the `app.py` script is passed to the Python
    executable. This will start the built-in web server on the local machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Once the server is running, navigate to the API endpoint to get responses from
    the view functions. If the application is complete, however, the local server
    won't be powerful enough to handle the API requests. Instead, deployment on a
    production web server is required.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying Flask to IIS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To deploy the new API application on a Microsoft Server with **Internet Information
    Services** (**IIS**) installed, we have to download some Python code, and an IIS
    module called **FastCGI**. Once configured, the application will respond to web
    requests from any allowed machine.
  prefs: []
  type: TYPE_NORMAL
- en: Flask and web servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While Flask includes a local web server for testing purposes, it is not designed
    for production deployments. Flask works best with web servers like Apache or IIS.
    While there is a lot of literature on how to deploy Flask with Apache, it is less
    common to find good instructions on how to deploy it using IIS. As most GIS professionals
    work with Windows servers or have access to them, these instructions will focus
    on deployment with IIS 7.
  prefs: []
  type: TYPE_NORMAL
- en: WSGI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Web Server Gateway Interface** (**WSGI**) is a Python specification that
    allows for a Python executable to be used to respond to web requests. WSGI is
    built into Python web frameworks such as Flask and Django.
  prefs: []
  type: TYPE_NORMAL
- en: To enable the use of the Flask web framework to serve web pages, some configuration
    of IIS is required, including the installation of an IIS **Common Gateway Interface**
    (**CGI**) module called FastCGI, and the installation of a Python module called
    **WFastCGI**. With these two additions, the IIS web server will connect to the
    code behind the API application.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the WFastCGI module and FastCGI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use the Web Platform Installer, available here: [http://www.microsoft.com/web/downloads/platform.aspx](http://www.microsoft.com/web/downloads/platform.aspx)
    (if it''s not already installed). Use the search bar in the top-right, and enter
    `WFastCGI`. The search results will appear and will list available WFastCGI versions
    for both Python 2.x and Python 3.x. Select the version for Python 3.6 and run
    the installer.'
  prefs: []
  type: TYPE_NORMAL
- en: This installation adds two important components to the required tech stack.
    The FastCGI module is added to IIS, and the WFastCGI Python code is added to a
    new Python installation. This new installation will be added at `C:\Python36`,
    unless there is an existing version in that location (not counting Python versions
    within an ArcGIS10.X Python installation).
  prefs: []
  type: TYPE_NORMAL
- en: Within this new installation, a file called `wfastcgi.py` is added in the `C:\Python36\Scripts`
    (or equivalent) folder. This file should be copied into the site folder, next
    to the `app.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring FastCGI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open IIS, and click on the Default Web Site. Within the features view of the
    Content Pane, select the Handler Mappings icon. Double-click to open it. Select
    Add Module Mapping from the right pane. When the Add Module Mapping interface
    appears, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add an asterisk (`*`) to the request path entry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select the FastCGI module from the Module Selection List.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you copied the `wfastcgi.py` file into the code path and the code is at `C:\website`,
    enter this into the executable entry: `C:\Python36\python.exe|C:\website\wfastcgi.py`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optionally, the `wfastcgi.py` file in the `Scripts` folder can be used. Here
    is the setup: `C:\Python36\python.exe|C:\Python36\Scripts\wfastcgi.py`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Click on Request Restrictions and uncheck the Invoke handler only if request
    is mapped to: if it is checked. Click OK.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click OK on the Add Module Mapping interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click Yes on the confirmation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Root server settings and Environment Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go to the `root` server settings and click on the FastCGI Settings icon. Double-click
    on the argument that matches the path added in the previous section. The Edit
    FastCGI Application interface will open.
  prefs: []
  type: TYPE_NORMAL
- en: Click on the EnvironmentVariables (Collection) entry. An ellipsis (...) will
    appear. Double-click on the ellipsis to edit the environment variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click the Add button to add a new variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add `PYTHONPATH` to the Name entry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the path to the site code (for example `C:\website\`) to the value entry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click the Add button to add a second variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add `WSGI_HANDLER` to the Name entry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the site is controlled by a file called `app.py`, add `app.app` to the value
    entry (replacing `.py` with `.app`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the variables have been added, push OK. Push OK in the Edit FastCGI Application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The site should now be live. Navigate to a REST endpoint using a browser to
    confirm that the site loads as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating an API with REST specifications is easy with Python web frameworks.
    Flask makes it simple to coordinate the URL endpoints with request methods and
    response types. With built-in JSON capabilities, and with the use of the SQLAlchemy
    and GeoAlchemy2 ORMs, Flask is a perfect framework for creating a geospatial REST
    API.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover the use of the CARTOframes module for cloud
    visualization of geospatial data.
  prefs: []
  type: TYPE_NORMAL
