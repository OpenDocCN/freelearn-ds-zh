<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Working with Basic Objects"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Working with Basic Objects</h1></div></div></div><p>In the previous chapters, you learned how to create several basic types of objects, including atomic vectors, lists, and data frames to store data. You learned how to create functions to store logic. Given these building blocks of R script, you learned about different types of expressions to control the flow of logic involving basic objects. Now, we are getting familiar with the basic grammar and syntax of the R programming language. It's time to build a vocabulary of R using built-in functions to work with basic objects.</p><p>The real power of R lies in the enormous amount of functions it provides. Getting to know a variety of basic functions is extremely useful, and it will save you time and boost your productivity.</p><p>Although R is mainly a statistical computing environment, many basic functions are not related to any statistics but to more fundamental tasks such as inspecting the environment, converting texts to numbers, and performing logical operations.</p><p>In this chapter, you will get to know a wide range of basic yet most useful functions in R, including:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Object functions</li><li class="listitem" style="list-style-type: disc">Logical functions</li><li class="listitem" style="list-style-type: disc">Math functions</li><li class="listitem" style="list-style-type: disc">Numeric methods</li><li class="listitem" style="list-style-type: disc">Statistical functions</li><li class="listitem" style="list-style-type: disc">Apply-family functions</li></ul></div><div class="section" title="Using object functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec29"/>Using object functions</h1></div></div></div><p>In the previous chapter, you learned about some functions that work with the environment and packages. In this section, we will get to know some basic functions that deal with objects in general. More specifically, I will introduce you to more functions to access the type and dimensions of a data object. You will get an impression of how these concepts can be combined and how they work together.</p><div class="section" title="Testing object types"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec68"/>Testing object types</h2></div></div></div><p>Although everything in R is an object, objects have different types.</p><p>Suppose the object we are dealing with is user-defined. We will create a function that behaves in different ways according to the type of the input object. For example, we need to create a function named <code class="literal">take_it</code> that returns the first element if the input object as an atomic vector (for example, numeric vector, character vector, or logical vector), but returns a user-defined element if the input object is a list of data and index.</p><p>For example, if the input is a numeric vector such as <code class="literal">c(1, 2, 3)</code>, then the function should return its first element <code class="literal">1</code>. If the input is a character vector such as <code class="literal">c("a", "b", "c")</code>, then the function should return <code class="literal">a</code>. However, if the input is a list <code class="literal">list(data = c("a", "b", "c"), index = 3)</code>, then the function should return the third element <code class="literal">(index = 3)</code> of <code class="literal">data</code>, that is, <code class="literal">c</code>.</p><p>To create such a function, we can imagine the functions and logic flow that might appear in it. First, as the output of the function depends on the type of input, we need to use one of the <code class="literal">is.*</code> functions to tell whether the input is of a certain type. Second, as the function behaves differently due to the type of input, we need to use conditional expressions such as <code class="literal">if else</code> to branch the logic. Finally, if the function basically takes out an element from the input, we need to use an element-extraction operator. Now, the implementation of the function becomes pretty clear:</p><pre class="programlisting">take_it &lt;- function(x) {&#13;
  if (is.atomic(x)) {&#13;
    x[[1]]&#13;
  } else if (is.list(x)) {&#13;
    x$data[[x$index]]&#13;
  } else {&#13;
    stop("Not supported input type")&#13;
  }&#13;
} &#13;
</pre><p>The preceding function behaves differently as <code class="literal">x</code> takes different types. When <code class="literal">x</code> takes an atomic vector (for example, a numeric vector), the function extracts its first element. When <code class="literal">x</code> takes a list of <code class="literal">data</code> and <code class="literal">index</code>, the function extracts the element with the index of <code class="literal">index</code> from <code class="literal">x$data</code>:</p><pre class="programlisting">take_it(c(1, 2, 3))&#13;
## [1] 1&#13;
take_it(list(data = c("a", "b", "c"), index = 3))&#13;
## [1] "c" &#13;
</pre><p>For unsupported input types, the function is supposed to stop with an error message rather than return any value. For example, <code class="literal">take_it</code> cannot handle the <code class="literal">function</code> input. Note that we can pass any function around to other functions as an argument, just like any other object. However, in this case, if <code class="literal">mean</code> as a function is passed to it, then it will turn to the <code class="literal">else</code> condition and stop:</p><pre class="programlisting">take_it(mean)&#13;
## Error in take_it(mean): Not supported input type &#13;
</pre><p>What if the input is indeed a list but does not contain any of the expected elements, <code class="literal">data</code> and <code class="literal">index</code>? Just do an experiment with a list of <code class="literal">input</code> (instead of <code class="literal">data</code>), without any <code class="literal">index</code> element:</p><pre class="programlisting">take_it(list(input = c("a", "b", "c")))&#13;
## NULL &#13;
</pre><p>It might surprise you that the function does not produce an error. The output is <code class="literal">NULL</code> because <code class="literal">x$data</code> is <code class="literal">NULL</code> and extracting any value from <code class="literal">NULL</code> is also <code class="literal">NULL</code>:</p><pre class="programlisting">NULL[[1]]&#13;
## NULL&#13;
NULL[[NULL]]&#13;
## NULL &#13;
</pre><p>However, if the list only contains <code class="literal">data</code> but misses <code class="literal">index</code>, the function will end up in an error:</p><pre class="programlisting">take_it(list(data = c("a", "b", "c")))&#13;
## Error in x$data[[x$index]]: attempt to select less than one element &#13;
</pre><p>The error occurs because <code class="literal">x$index</code> turns out to be <code class="literal">NULL</code>, and extracting value from a vector by <code class="literal">NULL</code> produces an error:</p><pre class="programlisting">c("a", "b", "c")[[NULL]]&#13;
## Error in c("a", "b", "c")[[NULL]]: attempt to select less than one element &#13;
</pre><p>The third possibility is a bit similar to the first case in which <code class="literal">NULL[[2]]</code> returns <code class="literal">NULL</code>:</p><pre class="programlisting">take_it(list(index = 2))&#13;
## NULL &#13;
</pre><p>From the earlier exceptions, it is normal to see that the error message is not so informative if you are not very familiar with these edge cases in which <code class="literal">NULL</code> is involved in the computation. For more complicated cases, if those errors do happen, you probably won't be able to find out the exact causes in a short period of time. One good solution is to check the input yourself in the implementation of the function and reflect the assumptions made to the arguments.</p><p>To handle the preceding cases of misuse, the following implementation takes into account whether the type of each argument is desired:</p><pre class="programlisting">take_it2 &lt;- function(x) {&#13;
  if (is.atomic(x)) {&#13;
    x[[1]]&#13;
  } else if (is.list(x)) {&#13;
    if (!is.null(x$data) &amp;&amp; is.atomic(x$data)) {&#13;
      if (is.numeric(x$index) &amp;&amp; length(x) == 1) {&#13;
        x$data[[x$index]]&#13;
      } else {&#13;
        stop("Invalid index")&#13;
      }&#13;
    } else {&#13;
      stop("Invalid data")&#13;
    }&#13;
  } else {&#13;
    stop("Not supported input type")&#13;
  }&#13;
} &#13;
</pre><p>For the case where <code class="literal">x</code> is a list, we check whether <code class="literal">x$data</code> is not null and is an atomic vector. If so, then we check if <code class="literal">x$index</code> is properly specified as a single-element numeric vector, or a scalar. If any of the conditions is violated, the function stops with an informative error message telling the user what is wrong with the input.</p><p>There are also quirky behaviors of the built-in checker functions. For example, <code class="literal">is.atomic(NULL)</code> returns <code class="literal">TRUE</code>. Therefore, if list <code class="literal">x</code> does not contain an element called <code class="literal">data</code>, the positive branch of <code class="literal">if (is.atomic(x$data))</code> can still be triggered, which also leads to <code class="literal">NULL</code>. With some argument checking, the code is now more robust and can produce more informative error messages when the assumptions are violated:</p><pre class="programlisting">take_it2(list(data = c("a", "b", "c")))&#13;
## Error in take_it2(list(data = c("a", "b", "c"))): Invalid index&#13;
take_it2(list(index = 2))&#13;
## Error in take_it2(list(index = 2)): Invalid data &#13;
</pre><p>Another possible implementation of this function is using the S3 dispatch, which will be covered in a later chapter on object-oriented programming.</p><div class="section" title="Accessing object classes and types"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec16"/>Accessing object classes and types</h3></div></div></div><p>Apart from using <code class="literal">is.*</code> functions, we can also use <code class="literal">class()</code> or <code class="literal">typeof()</code> to implement this function. Before directly accessing the type of an object, it is useful to know how these two functions differ from each other.</p><p>The following examples demonstrate the difference between the output of <code class="literal">class()</code> and <code class="literal">typeof()</code> when they are called upon different types of objects.</p><p>For each object <code class="literal">x</code>, <code class="literal">class()</code> and <code class="literal">typeof()</code> are called and then <code class="literal">str()</code> is called to show its structure.</p><p>For a numeric vector:</p><pre class="programlisting">x &lt;- c(1, 2, 3)&#13;
class(x)&#13;
## [1] "numeric"&#13;
typeof(x)&#13;
## [1] "double"&#13;
str(x)&#13;
##  num [1:3] 1 2 3 &#13;
</pre><p>For an integer vector:</p><pre class="programlisting">x &lt;- 1:3&#13;
class(x)&#13;
## [1] "integer"&#13;
typeof(x)&#13;
## [1] "integer"&#13;
str(x)&#13;
##  int [1:3] 1 2 3 &#13;
</pre><p>For a character vector:</p><pre class="programlisting">x &lt;- c("a", "b", "c")&#13;
class(x)&#13;
## [1] "character"&#13;
typeof(x)&#13;
## [1] "character"&#13;
str(x)&#13;
##  chr [1:3] "a" "b" "c" &#13;
</pre><p>For a list:</p><pre class="programlisting">x &lt;- list(a = c(1, 2), b = c(TRUE, FALSE))&#13;
class(x)&#13;
## [1] "list"&#13;
typeof(x)&#13;
## [1] "list"&#13;
str(x)&#13;
## List of 2&#13;
## $ a: num [1:2] 1 2&#13;
##  $ b: logi [1:2] TRUE FALSE &#13;
</pre><p>For a data frame:</p><pre class="programlisting">x &lt;- data.frame(a = c(1, 2), b = c(TRUE, FALSE))&#13;
class(x)&#13;
## [1] "data.frame"&#13;
typeof(x)&#13;
## [1] "list"&#13;
str(x)&#13;
## 'data.frame': 2 obs. of 2 variables:&#13;
## $ a: num 1 2&#13;
##  $ b: logi  TRUE FALSE &#13;
</pre><p>We can see that <code class="literal">typeof()</code> returns the low-level internal type of an object, while <code class="literal">class()</code> returns the high-level class of an object. One contrast we have mentioned before is that <code class="literal">data.frame</code> is in essence a <code class="literal">list</code> with equal-length list elements. Therefore, a data frame has the class of <code class="literal">data.frame</code> for data frame related functions to recognize, but <code class="literal">typeof()</code> still tells it is a <code class="literal">list</code> internally.</p><p>The topic is related to the S3 object-oriented programming mechanism and will be covered in detail in a later chapter. However, it is still useful to mention the difference between <code class="literal">class()</code> and <code class="literal">typeof()</code> here.</p><p>From the preceding output, it is also clear that <code class="literal">str()</code>, which we introduced in the previous chapter, shows the structure of an object. For vectors in the object, it usually shows their internal type (<code class="literal">typeof()</code>).</p></div></div><div class="section" title="Accessing data dimensions"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec69"/>Accessing data dimensions</h2></div></div></div><p>Matrices, arrays, and data frames have the property of dimensions in addition to classes and types.</p><div class="section" title="Getting data dimensions"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec17"/>Getting data dimensions</h3></div></div></div><p>In R, a vector is by construction a one-dimensional data structure:</p><pre class="programlisting">vec &lt;- c(1, 2, 3, 2, 3, 4, 3, 4, 5, 4, 5, 6)&#13;
class(vec)&#13;
## [1] "numeric"&#13;
typeof(vec)&#13;
## [1] "double" &#13;
</pre><p>The same underlying data can be represented with more dimensions, which can be accessed via <code class="literal">dim()</code>, <code class="literal">nrow()</code>, or <code class="literal">ncol()</code>:</p><pre class="programlisting">sample_matrix &lt;- matrix(vec, ncol = 4)&#13;
sample_matrix&#13;
## [,1] [,2] [,3] [,4]&#13;
## [1,] 1 2 3 4&#13;
## [2,] 2 3 4 5&#13;
## [3,] 3 4 5 6&#13;
class(sample_matrix)&#13;
## [1] "matrix"&#13;
typeof(sample_matrix)&#13;
## [1] "double"&#13;
dim(sample_matrix)&#13;
## [1] 3 4&#13;
nrow(sample_matrix)&#13;
## [1] 3&#13;
ncol(sample_matrix)&#13;
## [1] 4 &#13;
</pre><p>The first preceding expression creates a four-column matrix from numeric vector <code class="literal">vec</code>. The matrix has the class of <code class="literal">matrix</code>, while <code class="literal">typoef()</code> preserves <code class="literal">double</code> from <code class="literal">vec</code>. Since a matrix is a dimensional data structure, <code class="literal">dim()</code> shows its dimensions in vector form. The <code class="literal">nrow()</code> and <code class="literal">ncol()</code> functions are shortcuts to access its number of rows and columns. If you read the source code of these two shortcuts, you will find that they are nothing special, but they return the first and second elements of <code class="literal">dim()</code> of the same input, respectively.</p><p>Higher dimensional data is usually represented by an array. For example, the same data <code class="literal">vec</code> can also be represented in three dimensions, that is, to access one element, you need to specify three positions in the three dimensions in turn:</p><pre class="programlisting">sample_array &lt;- array(vec, dim = c(2, 3, 2))&#13;
sample_array&#13;
## , , 1&#13;
##&#13;
## [,1] [,2] [,3]&#13;
## [1,] 1 3 3&#13;
## [2,] 2 2 4&#13;
##&#13;
## , , 2&#13;
##&#13;
## [,1] [,2] [,3]&#13;
## [1,] 3 5 5&#13;
## [2,] 4 4 6&#13;
class(sample_array)&#13;
## [1] "array"&#13;
typeof(sample_array)&#13;
## [1] "double"&#13;
dim(sample_array)&#13;
## [1] 2 3 2&#13;
nrow(sample_array)&#13;
## [1] 2&#13;
ncol(sample_array)&#13;
## [1] 3 &#13;
</pre><p>Similar to <code class="literal">matrix</code>, an array has a class of <code class="literal">array</code> but still preserves the type of the underlying data. The length of the output of <code class="literal">dim()</code> is the number of dimensions needed to represent the data.</p><p>Another data structure that has a notion of dimensions is a data frame. However, a data frame is fundamentally different from a matrix. A matrix is derived from a vector but adds a dimensional property. On the other hand, a data frame is derived from a list but adds a constraint that each list element must have the same length:</p><pre class="programlisting">sample_data_frame &lt;- data.frame(a = c(1, 2, 3), b = c(2, 3, 4))&#13;
class(sample_data_frame)&#13;
## [1] "data.frame"&#13;
typeof(sample_data_frame)&#13;
## [1] "list"&#13;
dim(sample_data_frame)&#13;
## [1] 3 2&#13;
nrow(sample_data_frame)&#13;
## [1] 3&#13;
ncol(sample_data_frame)&#13;
## [1] 2 &#13;
</pre><p>However, <code class="literal">dim()</code>, <code class="literal">nrow()</code>, and <code class="literal">ncol()</code> are still useful for data frames.</p></div><div class="section" title="Reshaping data structures"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec18"/>Reshaping data structures</h3></div></div></div><p>The syntax of <code class="literal">dim(x) &lt;- y</code> means change the value of dimensions of <code class="literal">x</code> to <code class="literal">y</code>.</p><p>For a plain vector, the expression converts the vector to a matrix with the specified dimensions:</p><pre class="programlisting">sample_data &lt;- vec&#13;
dim(sample_data) &lt;- c(3, 4)&#13;
sample_data&#13;
## [,1] [,2] [,3] [,4]&#13;
## [1,] 1 2 3 4&#13;
## [2,] 2 3 4 5&#13;
## [3,] 3 4 5 6&#13;
class(sample_data)&#13;
## [1] "matrix"&#13;
typeof(sample_data)&#13;
## [1] "double" &#13;
</pre><p>You can see that the class of the object changes from <code class="literal">numeric</code> to <code class="literal">matrix</code>, and the type of the object remains unchanged.</p><p>For a matrix, the expression reshapes the matrix:</p><pre class="programlisting">dim(sample_data) &lt;- c(4, 3)&#13;
sample_data&#13;
## [,1] [,2] [,3]&#13;
## [1,] 1 3 5&#13;
## [2,] 2 4 4&#13;
## [3,] 3 3 5&#13;
## [4,]    2    4    6 &#13;
</pre><p>It is useful to understand that changing the dimension of a vector, matrix, or array only alters the representation and accessing methods of the object and does not change the underlying data stored in memory. Therefore, it should be no surprise that a matrix is reshaped to an array as follows:</p><pre class="programlisting">dim(sample_data) &lt;- c(3, 2, 2)&#13;
sample_data&#13;
## , , 1&#13;
##&#13;
## [,1] [,2]&#13;
## [1,] 1 2&#13;
## [2,] 2 3&#13;
## [3,] 3 4&#13;
##&#13;
## , , 2&#13;
##&#13;
## [,1] [,2]&#13;
## [1,] 3 4&#13;
## [2,] 4 5&#13;
## [3,] 5 6&#13;
class(sample_data)&#13;
## [1] "array" &#13;
</pre><p>It should be obvious that <code class="literal">dim(x) &lt;- y</code> works only if <code class="literal">prod(y)</code> equals <code class="literal">length(x)</code>, that is, the product of all dimensions must be equal to the length of the data elements. Otherwise, an error will occur:</p><pre class="programlisting">dim(sample_data) &lt;- c(2, 3, 4)&#13;
## Error in dim(sample_data) &lt;- c(2, 3, 4): dims [product 24] do not match the length of object [12] &#13;
</pre></div><div class="section" title="Iterating over one dimension"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec19"/>Iterating over one dimension</h3></div></div></div><p>A data frame is often a collection of records, and each row represents a record. It is common to iterate over all records stored in a data frame. Let's look at the following data frame:</p><pre class="programlisting">sample_data_frame&#13;
## a b&#13;
## 1 1 2&#13;
## 2 2 3&#13;
## 3 3 4 &#13;
</pre><p>For this data frame, we can iterate over the rows by printing the values of the variables using a <code class="literal">for</code> loop over <code class="literal">1:nrow(x)</code>:</p><pre class="programlisting">for (i in 1:nrow(sample_data_frame)) {&#13;
  # sample text:&#13;
  # row #1, a: 1, b: 2&#13;
  cat("row #", i, ", ",&#13;
    "a: ", sample_data_frame[i, "a"],&#13;
    ", b: ", sample_data_frame[i, "b"],&#13;
    "\n", sep = "")&#13;
}&#13;
## row #1, a: 1, b: 2&#13;
## row #2, a: 2, b: 3&#13;
## row #3, a: 3, b: 4 &#13;
</pre></div></div></div></div>
<div class="section" title="Using logical functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec30"/>Using logical functions</h1></div></div></div><p>A logical vector only takes <code class="literal">TRUE</code> or <code class="literal">FALSE</code> and is mostly used to filter data. In practice, it is common to create joint conditions by multiple logical vectors where a number of logical operators and functions may involve.</p><div class="section" title="Logical operators"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec70"/>Logical operators</h2></div></div></div><p>Like many other programming languages, R enables a few operators to do basic logical calculations. The following table demonstrates what they do:</p><div class="informaltable"><table border="1"><colgroup><col/><col/><col/><col/></colgroup><tbody><tr><td>
<p><span class="strong"><strong>Symbol</strong></span></p>
</td><td>
<p><span class="strong"><strong>Description</strong></span></p>
</td><td>
<p><span class="strong"><strong>Example</strong></span></p>
</td><td>
<p><span class="strong"><strong>Result</strong></span></p>
</td></tr><tr><td>
<p><code class="literal">&amp;</code></p>
</td><td>
<p>Vectorized AND</p>
</td><td>
<p><code class="literal">c(T, T) &amp; c(T, F)</code></p>
</td><td>
<p><code class="literal">c(TRUE, FALSE)</code></p>
</td></tr><tr><td>
<p><code class="literal">|</code></p>
</td><td>
<p>Vectorized OR</p>
</td><td>
<p><code class="literal">c(T, T) | c(T, F)</code></p>
</td><td>
<p><code class="literal">c(TRUE, TRUE)</code></p>
</td></tr><tr><td>
<p><code class="literal">&amp;&amp;</code></p>
</td><td>
<p>Univariate AND</p>
</td><td>
<p><code class="literal">c(T, T) &amp;&amp; c(F, T)</code></p>
</td><td>
<p><code class="literal">FALSE</code></p>
</td></tr><tr><td>
<p><code class="literal">||</code></p>
</td><td>
<p>Univariate OR</p>
</td><td>
<p><code class="literal">c(T, T) || c(F, T)</code></p>
</td><td>
<p><code class="literal">TRUE</code></p>
</td></tr><tr><td>
<p><code class="literal">!</code></p>
</td><td>
<p>Vectorized NOT</p>
</td><td>
<p><code class="literal">!c(T, F)</code></p>
</td><td>
<p><code class="literal">c(FALSE, TRUE)</code></p>
</td></tr><tr><td>
<p><code class="literal">%in%</code></p>
</td><td>
<p>Vectorized IN</p>
</td><td>
<p>c<code class="literal">(1, 2) %in% c(1, 3, 4, 5)</code></p>
</td><td>
<p><code class="literal">c(TRUE, FALSE)</code></p>
</td></tr></tbody></table></div><p>Note that in an <code class="literal">if</code> expression, <code class="literal">&amp;&amp;</code> and <code class="literal">||</code> are often used to perform logical calculations that are only needed to yield a single-element logical vector. However, the potential risk of using <code class="literal">&amp;&amp;</code> is that if it is made to work with multi-element vectors, it will silently ignore all but the first element of the vectors on both sides. The following example demonstrates the difference in behavior of using either <code class="literal">&amp;&amp;</code> or <code class="literal">&amp;</code> in conditional statements.</p><p>The following code creates a <code class="literal">test_direction</code> function that tells the monotonicity of supplied argument values. We'll build on this example through the next section. If the values of <code class="literal">x</code>, <code class="literal">y</code>, and <code class="literal">z</code> are monotonically increasing, the function returns <code class="literal">1</code>; if they are monotonically decreasing, the function returns <code class="literal">-1</code>. Otherwise, it returns <code class="literal">0</code>. Note that the function uses <code class="literal">&amp;</code> to perform a vectorized AND operation:</p><pre class="programlisting">test_direction &lt;- function(x, y, z) {&#13;
  if (x &lt; y &amp; y &lt; z) 1&#13;
  else if (x &gt; y &amp; y &gt; z) -1&#13;
  else 0&#13;
} &#13;
</pre><p>If the arguments are supplied scalar numbers, the function works perfectly:</p><pre class="programlisting">test_direction(1, 2, 3)&#13;
## [1] 1 &#13;
</pre><p>Note that <code class="literal">&amp;</code> performs a vectorized calculation and thus returns a multi-element vector if one argument has more than one element. However, <code class="literal">if</code> only works with a single-value logical vector; otherwise, it would produce a warning:</p><pre class="programlisting">test_direction(c(1, 2), c(2, 3), c(3, 4))&#13;
## Warning in if (x &lt; y &amp; y &lt; z) 1 else if (x &gt; y &amp; y &gt; z)&#13;
## -1 else 0: the condition has length &gt; 1 and only the first&#13;
## element will be used&#13;
## [1] 1 &#13;
</pre><p>If we replace both <code class="literal">&amp;</code> operators present in <code class="literal">test_direction2</code> with <code class="literal">&amp;&amp;</code> and create a new function <code class="literal">test_direction2</code>, the function would look as follows:</p><pre class="programlisting">test_direction2 &lt;- function(x, y, z) {&#13;
  if (x &lt; y &amp;&amp; y &lt; z) 1&#13;
  else if (x &gt; y &amp;&amp; y &gt; z) -1&#13;
  else 0&#13;
} &#13;
</pre><p>Then, the two example test cases may have different behaviors. For scalar input, the behavior of the two versions are exactly the same:</p><pre class="programlisting">test_direction2(1, 2, 3)&#13;
## [1] 1 &#13;
</pre><p>However, for multi-element input, <code class="literal">test_direction2</code> silently ignores the second element of each input vector and thus does not produce any warnings:</p><pre class="programlisting">test_direction2(c(1, 2), c(2, 3), c(3, 4))&#13;
## [1] 1 &#13;
</pre><p>Finally, which is the correct use, <code class="literal">&amp;</code> or <code class="literal">&amp;&amp;</code>? It all depends on your demand. What behavior do you expect under all circumstances? What do you expect if the input is scalar values or multi-element vectors? If you expect the function to tell you whether all elements in the same position of each input vector have monotonicity, then both uses are incorrect in part and require the use of logical aggregation functions, to be introduced in the next section.</p></div><div class="section" title="Logical functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec71"/>Logical functions</h2></div></div></div><p>In this section, we will look at aggregating logical vectors and finding the true elements.</p><div class="section" title="Aggregating logical vectors"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec20"/>Aggregating logical vectors</h3></div></div></div><p>In addition to the binary logical operators, a few logical aggregation functions are very useful, as we mentioned earlier.</p><p>The most commonly used two logical aggregation functions are <code class="literal">any()</code> and <code class="literal">all()</code>. The <code class="literal">any()</code> function returns <code class="literal">TRUE</code> if any (for example, at least one) element of the given logical vector is <code class="literal">TRUE</code>; otherwise, it will return <code class="literal">FALSE</code>. The <code class="literal">all()</code> function returns <code class="literal">TRUE</code> if all elements of the given logical vector are <code class="literal">TRUE</code>; otherwise, it will return <code class="literal">FALSE</code>:</p><pre class="programlisting">x &lt;- c(-2, -3, 2, 3, 1, 0, 0, 1, 2)&#13;
any(x &gt; 1)&#13;
## [1] TRUE&#13;
all(x &lt;= 1)&#13;
## [1] FALSE &#13;
</pre><p>One common point of the two functions is that they only return a single <code class="literal">TRUE</code> or <code class="literal">FALSE</code> value and never return a multi-element logical vector. Therefore, to implement a function that meets the demand in the previous section, use <code class="literal">all()</code> and <code class="literal">&amp;</code> together in the <code class="literal">if</code> conditions:</p><pre class="programlisting">test_all_direction &lt;- function(x, y, z) {&#13;
  if (all(x &lt; y &amp; y &lt; z)) 1&#13;
  else if (all(x &gt; y &amp; y &gt; z)) -1&#13;
  else 0&#13;
} &#13;
</pre><p>For scalar input, <code class="literal">test_all_direction()</code> behaves exactly the same with the <code class="literal">test_direction()</code> and <code class="literal">test_direction2()</code> functions:</p><pre class="programlisting">test_all_direction(1, 2, 3)&#13;
## [1] 1 &#13;
</pre><p>For vector input, the function tests whether <code class="literal">c(1, 2, 3)</code> and <code class="literal">c(2, 3, 4)</code> have (the same) monotonicity:</p><pre class="programlisting">test_all_direction(c(1, 2), c(2, 3), c(3, 4))&#13;
## [1] 1 &#13;
</pre><p>The following code is a counterexample in which the elements at position <code class="literal">2</code>, that is, <code class="literal">c(2, 4, 4)</code>, have no monotonicity:</p><pre class="programlisting">test_all_direction(c(1, 2), c(2, 4), c(3, 4))&#13;
## [1] 0 &#13;
</pre><p>The value returned by the function is thus meaningful because it correctly implements the demand of testing whether all elements at each position in the three input vectors have monotonicity.</p><p>The function has several possible variations that instead uses <code class="literal">any()</code> or <code class="literal">&amp;&amp;</code>. You may try to figure out the underlying demand (what are these functions trying to do?) of each of the following versions:</p><pre class="programlisting">test_any_direction &lt;- function(x, y, z) {&#13;
  if (any(x &lt; y &amp; y &lt; z)) 1&#13;
  else if (any(x &gt; y &amp; y &gt; z)) -1&#13;
  else 0&#13;
}&#13;
test_all_direction2 &lt;- function(x, y, z) {&#13;
  if (all(x &lt; y) &amp;&amp; all(y &lt; z)) 1&#13;
  else if (all(x &gt; y) &amp;&amp; all(y &gt; z)) -1&#13;
  else 0&#13;
}&#13;
test_any_direction2 &lt;- function(x, y, z) {&#13;
  if (any(x &lt; y) &amp;&amp; any(y &lt; z)) 1&#13;
  else if (any(x &gt; y) &amp;&amp; any(y &gt; z)) -1&#13;
  else 0&#13;
} &#13;
</pre></div><div class="section" title="Asking which elements are TRUE"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec21"/>Asking which elements are TRUE</h3></div></div></div><p>The logical operations we introduced earlier usually return a logical vector to indicate whether a certain condition is <code class="literal">TRUE</code> or <code class="literal">FALSE</code>. It is also useful to know which elements satisfy those conditions. The <code class="literal">which()</code> function returns the positions (or indices) of <code class="literal">TRUE</code> elements in a logical vector:</p><pre class="programlisting">x&#13;
## [1] -2 -3 2 3 1 0 0 1 2&#13;
abs(x) &gt;= 1.5&#13;
## [1] TRUE TRUE TRUE TRUE FALSE FALSE FALSE FALSE TRUE&#13;
which(abs(x) &gt;= 1.5)&#13;
## [1] 1 2 3 4 9 &#13;
</pre><p>If we take a closer look at what happens, it should be clear that at first, <code class="literal">abs(x) &gt;= 1.5</code> is evaluated to be a logical vector, and then, <code class="literal">which()</code> returns the positions of those <code class="literal">TRUE</code> elements in that logical vector.</p><p>The mechanism is quite similar when we use a logical condition to filter elements from a vector or list:</p><pre class="programlisting">x[x &gt;= 1.5]&#13;
## [1] 2 3 2 &#13;
</pre><p>In the preceding example, <code class="literal">x &gt;= 1.5</code> is evaluated to be a logical vector. Then, it is used to select elements in <code class="literal">x</code> corresponding to <code class="literal">TRUE</code> values.</p><p>A special case is that we can even use a logical vector with all <code class="literal">FALsE</code> values. A zero-length numeric vector is returned since the logical vector only contains <code class="literal">FALSE</code> values, and thus, no element in <code class="literal">x</code> is singled out:</p><pre class="programlisting">x[x &gt;= 100]&#13;
## numeric(0) &#13;
</pre></div></div><div class="section" title="Dealing with missing values"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec72"/>Dealing with missing values</h2></div></div></div><p>Real-world data often contains missing values represented by <code class="literal">NA</code>. The following numeric vector is a simple example:</p><pre class="programlisting">x &lt;- c(-2, -3, NA, 2, 3, 1, NA, 0, 1, NA, 2) &#13;
</pre><p>Arithmetic calculations with missing values also produce missing values:</p><pre class="programlisting">x + 2&#13;
##  [1]  0 -1 NA  4  5  3 NA  2  3 NA  4 &#13;
</pre><p>To take this into account, a logical vector has to accept not only <code class="literal">TRUE</code> and <code class="literal">FALSE</code> values but also <code class="literal">NA</code> values to represent unknown truthfulness:</p><pre class="programlisting">x &gt; 2&#13;
## [1] FALSE FALSE NA FALSE TRUE FALSE NA FALSE FALSE&#13;
## [10]    NA FALSE &#13;
</pre><p>As a consequence, logical aggregation functions such as <code class="literal">any()</code> and <code class="literal">all()</code> have to deal with missing values too:</p><pre class="programlisting">x&#13;
## [1] -2 -3 NA 2 3 1 NA 0 1 NA 2&#13;
any(x &gt; 2)&#13;
## [1] TRUE&#13;
any(x &lt; -2)&#13;
## [1] TRUE&#13;
any(x &lt; -3)&#13;
## [1] NA &#13;
</pre><p>The preceding output demonstrates the default behavior of <code class="literal">any()</code> when it deals with a logical vector that contains missing values. More specifically, if any element in the input vector is <code class="literal">TRUE</code>, then the function will return <code class="literal">TRUE</code>. If no element in the input vector is <code class="literal">TRUE</code> in which any missing value is present, then the function will return <code class="literal">NA</code>. Otherwise, if the input vector contains only <code class="literal">FALSE</code>, then the function will return <code class="literal">FALSE</code>. To verify the preceding logic, just run the following code:</p><pre class="programlisting">any(c(TRUE, FALSE, NA))&#13;
## [1] TRUE&#13;
any(c(FALSE, FALSE, NA))&#13;
## [1] NA&#13;
any(c(FALSE, FALSE))&#13;
## [1] FALSE &#13;
</pre><p>To directly ignore all missing values, just specify <code class="literal">na.rm = TRUE</code> in the call:</p><pre class="programlisting">any(x &lt; -3, na.rm = TRUE)&#13;
## [1] FALSE &#13;
</pre><p>A similar but somehow opposite logic applies to <code class="literal">all()</code>:</p><pre class="programlisting">x&#13;
## [1] -2 -3 NA 2 3 1 NA 0 1 NA 2&#13;
all(x &gt; -3)&#13;
## [1] FALSE&#13;
all(x &gt;= -3)&#13;
## [1] NA&#13;
all(x &lt; 4)&#13;
## [1] NA &#13;
</pre><p>If any element in the input vector is <code class="literal">FALSE</code>, then the function will return <code class="literal">FALSE</code>. If no element in the input vector is <code class="literal">FALSE</code> in which any missing value is present, then the function will return <code class="literal">NA</code>. Otherwise, if the input vector contains only <code class="literal">TRUE</code>, then it will return <code class="literal">TRUE</code>. To verify the logic, just run the following code:</p><pre class="programlisting">all(c(TRUE, FALSE, NA))&#13;
## [1] FALSE&#13;
all(c(TRUE, TRUE, NA))&#13;
## [1] NA&#13;
all(c(TRUE, TRUE))&#13;
## [1] TRUE &#13;
</pre><p>Similarly, <code class="literal">na.rm = TRUE</code> forces the function to directly ignore all missing values:</p><pre class="programlisting">all(x &gt;= -3, na.rm = TRUE)&#13;
## [1] TRUE &#13;
</pre><p>Apart from logical aggregation functions, data filtering also behaves differently when missing values involve. For example, the following code will preserve the missing values at corresponding positions of the logical vector produced by <code class="literal">x &gt;= 0</code>:</p><pre class="programlisting">x&#13;
## [1] -2 -3 NA 2 3 1 NA 0 1 NA 2&#13;
x[x &gt;= 0]&#13;
## [1] NA  2  3  1 NA  0  1 NA  2 &#13;
</pre><p>By contrast, <code class="literal">which()</code> does not preserve the missing values present in the input logical vector:</p><pre class="programlisting">which(x &gt;= 0)&#13;
## [1]  4  5  6  8  9 11 &#13;
</pre><p>Therefore, the vector subsetted by the indices does not contain missing values in the following case:</p><pre class="programlisting">x[which(x &gt;= 0)]&#13;
## [1] 2 3 1 0 1 2 &#13;
</pre></div><div class="section" title="Logical coercion"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec73"/>Logical coercion</h2></div></div></div><p>Some functions that are supposed to take logical input also accept non-logical vectors such as numeric vectors. However, the behavior of the function may not be different from what they do with logical vectors. This is because the non-logical vectors are coerced to logical values.</p><p>For example, if we put a numeric vector in the <code class="literal">if</code> condition, it will be coerced:</p><pre class="programlisting">if (2) 3&#13;
## [1] 3&#13;
if (0) 0 else 1&#13;
## [1] 1 &#13;
</pre><p>In R, all non-zero values in a numeric vector or integer vector can be coerced to <code class="literal">TRUE</code>, only zero values will be coerced to <code class="literal">FALSE</code>, and string values cannot be coerced to logical values:</p><pre class="programlisting">if ("a") 1 else 2&#13;
## Error in if ("a") 1 else 2: argument is not interpretable as logical &#13;
</pre></div></div>
<div class="section" title="Using math functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec31"/>Using math functions</h1></div></div></div><p>Mathematical functions are an essential part in all computing environments. R provides several groups of basic math functions.</p><div class="section" title="Basic functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec74"/>Basic functions</h2></div></div></div><p>The basic functions include square root, and exponential and logarithm functions as the following table shows:</p><div class="mediaobject"><img src="graphics/B05263_05_07.jpg" alt="Basic functions"/></div><p>Note that <code class="literal">sqrt()</code> only works with real numbers. If a negative number is supplied, <code class="literal">NaN</code> will be produced:</p><pre class="programlisting">sqrt(-1)&#13;
## Warning in sqrt(-1): NaNs produced&#13;
## [1] NaN &#13;
</pre><p>In R, numeric values can be finite, infinite (<code class="literal">Inf</code> and <code class="literal">-Inf</code>), and <code class="literal">NaN</code> values. The following code will produce infinite values.</p><p>First, produce a positively infinite value:</p><pre class="programlisting">1 / 0&#13;
## [1] Inf &#13;
</pre><p>Then, produce a negatively infinite value:</p><pre class="programlisting">log(0)&#13;
## [1] -Inf &#13;
</pre><p>There are several test functions to check whether a numeric value is finite, infinite, or <code class="literal">NaN</code>:</p><pre class="programlisting">is.finite(1 / 0)&#13;
## [1] FALSE&#13;
is.infinite(log(0))&#13;
## [1] TRUE &#13;
</pre><p>Using <code class="literal">is.infinite()</code>, how can we check whether a numeric value is <code class="literal">-Inf</code>? Inequality still works with infinite values in R:</p><pre class="programlisting">1 / 0 &lt; 0&#13;
## [1] FALSE&#13;
1 / 0 &gt; 0&#13;
## [1] TRUE&#13;
log(0) &lt; 0&#13;
## [1] TRUE&#13;
log(0) &gt; 0&#13;
## [1] FALSE &#13;
</pre><p>Therefore, we can test the number with <code class="literal">is.infinite()</code> and compare the elements to 0 at the same time:</p><pre class="programlisting">is.pos.infinite &lt;- function(x) {&#13;
  is.infinite(x) &amp; x &gt; 0&#13;
}&#13;
is.neg.infinite &lt;- function(x) {&#13;
  is.infinite(x) &amp; x &lt; 0&#13;
}&#13;
is.pos.infinite(1/0)&#13;
## [1] TRUE&#13;
is.neg.infinite(log(0))&#13;
## [1] TRUE &#13;
</pre><p>Like <code class="literal">sqrt()</code>, if the input value goes beyond the domain of <code class="literal">log</code> function, that is, <code class="literal">x &gt; 0</code>, then the function returns <code class="literal">NaN</code> with a warning:</p><pre class="programlisting">log(-1)&#13;
## Warning in log(-1): NaNs produced&#13;
## [1] NaN &#13;
</pre></div><div class="section" title="Number rounding functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec75"/>Number rounding functions</h2></div></div></div><p>The following functions are used to round numbers in different ways:</p><div class="informaltable"><table border="1"><colgroup><col/><col/><col/></colgroup><tbody><tr><td>
<p><span class="strong"><strong>Symbol</strong></span></p>
</td><td>
<p><span class="strong"><strong>Example</strong></span></p>
</td><td>
<p><span class="strong"><strong>Value</strong></span></p>
</td></tr><tr><td>
<p>[x] log</p>
</td><td>
<p><code class="literal">ceiling(10.6)</code></p>
</td><td>
<p>11</p>
</td></tr><tr><td>
<p>[x] log</p>
</td><td>
<p><code class="literal">floor(9.5)</code></p>
</td><td>
<p>9</p>
</td></tr><tr><td>
<p>truncate</p>
</td><td>
<p><code class="literal">trunc(1.5)</code></p>
</td><td>
<p>1</p>
</td></tr><tr><td>
<p>round</p>
</td><td>
<p><code class="literal">round(pi,3)</code></p>
</td><td>
<p>3.142</p>
</td></tr><tr><td>
<p>significant numbers</p>
</td><td>
<p><code class="literal">signif(pi, 3)</code></p>
</td><td>
<p>3.14</p>
</td></tr></tbody></table></div><p>Previously, we showed that using <code class="literal">options(digits =)</code> can modify the number of digits to display, but this does not change the actual number of digits to remember. The preceding functions round the numbers and may cause potential loss of information.</p><p>For example, if the input number <code class="literal">1.50021</code> is already precise, then rounding it to <code class="literal">1</code> digit will result in <code class="literal">1.5</code> and the other digits (information) are lost. Therefore, you should make sure if the digits to drop are indeed ignorable due to imprecision or noise before performing any rounding.</p></div><div class="section" title="Trigonometric functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec76"/>Trigonometric functions</h2></div></div></div><p>The following table lists the most commonly used trigonometric functions:</p><div class="informaltable"><table border="1"><colgroup><col/><col/><col/></colgroup><tbody><tr><td>
<p><span class="strong"><strong>Symbol</strong></span></p>
</td><td>
<p><span class="strong"><strong>Example</strong></span></p>
</td><td>
<p><span class="strong"><strong>Value</strong></span></p>
</td></tr><tr><td>
<p><code class="literal">sin (x)</code></p>
</td><td>
<p><code class="literal">sin(0)</code></p>
</td><td>
<p>0</p>
</td></tr><tr><td>
<p><code class="literal">cos (x)</code></p>
</td><td>
<p><code class="literal">cos(0)</code></p>
</td><td>
<p>1</p>
</td></tr><tr><td>
<p><code class="literal">tan (x)</code></p>
</td><td>
<p><code class="literal">tan(0)</code></p>
</td><td>
<p>0</p>
</td></tr><tr><td>
<p><code class="literal">arcsin (x)</code></p>
</td><td>
<p><code class="literal">asin(1)</code></p>
</td><td>
<p>1.5707963</p>
</td></tr><tr><td>
<p><code class="literal">arcos (x)</code></p>
</td><td>
<p><code class="literal">acos(1)</code></p>
</td><td>
<p>0</p>
</td></tr><tr><td>
<p><code class="literal">arctan (x)</code></p>
</td><td>
<p><code class="literal">atan(1)</code></p>
</td><td>
<p>0.7853982</p>
</td></tr></tbody></table></div><p>R also provides a numeric version of <code class="literal">π</code>:</p><pre class="programlisting">pi&#13;
## [1] 3.141593 &#13;
</pre><p>In maths, equation <span class="emphasis"><em>sin (π) = 0 </em></span>strictly holds. However, the same formula does not lead to 0 in R or any other typical numeric computing software due to some precision issues of floating numbers:</p><pre class="programlisting">sin(pi)&#13;
## [1] 1.224606e-16 &#13;
</pre><p>To compare numbers with near equality, use <code class="literal">all.equal()</code> instead. While <code class="literal">sin(pi) == 0</code> returns <code class="literal">FALSE</code>, <code class="literal">all.equal(sin(pi), 0)</code> returns <code class="literal">TRUE</code> with the default tolerance of <code class="literal">1.5e-8</code>.</p><p>Another three functions are provided to make it precise when the input is a multiple of <code class="literal">π</code>:</p><div class="informaltable"><table border="1"><colgroup><col/><col/><col/></colgroup><tbody><tr><td>
<p><span class="strong"><strong>Symbol</strong></span></p>
</td><td>
<p><span class="strong"><strong>Example</strong></span></p>
</td><td>
<p><span class="strong"><strong>Value</strong></span></p>
</td></tr><tr><td>
<p><code class="literal">sin (πx)</code></p>
</td><td>
<p><code class="literal">sinpi(1)</code></p>
</td><td>
<p>0</p>
</td></tr><tr><td>
<p><code class="literal">cos (πx)</code></p>
</td><td>
<p><code class="literal">cospi(0)</code></p>
</td><td>
<p>1</p>
</td></tr><tr><td>
<p><code class="literal">tan (πx)</code></p>
</td><td>
<p><code class="literal">tanpi(1)</code></p>
</td><td>
<p>0</p>
</td></tr></tbody></table></div></div><div class="section" title="Hyperbolic functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec77"/>Hyperbolic functions</h2></div></div></div><p>Similar to other computing software, hyperbolic functions are provided as shown in the following table:</p><div class="informaltable"><table border="1"><colgroup><col/><col/><col/></colgroup><tbody><tr><td>
<p><span class="strong"><strong>Symbol</strong></span></p>
</td><td>
<p><span class="strong"><strong>Example</strong></span></p>
</td><td>
<p><span class="strong"><strong>Value</strong></span></p>
</td></tr><tr><td>
<p><code class="literal">sinh (x)</code></p>
</td><td>
<p><code class="literal">sinh(1)</code></p>
</td><td>
<p>1.1752012</p>
</td></tr><tr><td>
<p><code class="literal">cosh (x)</code></p>
</td><td>
<p><code class="literal">cosh(1)</code></p>
</td><td>
<p>1.5430806</p>
</td></tr><tr><td>
<p><code class="literal">tanh (x)</code></p>
</td><td>
<p><code class="literal">tanh(1)</code></p>
</td><td>
<p>0.7615942</p>
</td></tr><tr><td>
<p><code class="literal">arcsinh (x)</code></p>
</td><td>
<p><code class="literal">asinh(1)</code></p>
</td><td>
<p>0.8813736</p>
</td></tr><tr><td>
<p><code class="literal">arccosh (x)</code></p>
</td><td>
<p><code class="literal">acosh(1)</code></p>
</td><td>
<p>0</p>
</td></tr><tr><td>
<p><code class="literal">arctanh (x)</code></p>
</td><td>
<p><code class="literal">atanh(0)</code></p>
</td><td>
<p>0</p>
</td></tr></tbody></table></div></div><div class="section" title="Extreme functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec78"/>Extreme functions</h2></div></div></div><p>It is common to calculate the maximum or minimum values of some numbers. The following table lists and demonstrates the simple use of <code class="literal">max()</code> and <code class="literal">min()</code>:</p><div class="informaltable"><table border="1"><colgroup><col/><col/><col/></colgroup><tbody><tr><td>
<p><span class="strong"><strong>Symbol</strong></span></p>
</td><td>
<p><span class="strong"><strong>Example</strong></span></p>
</td><td>
<p><span class="strong"><strong>Value</strong></span></p>
</td></tr><tr><td>
<p><code class="literal">max(...)</code></p>
</td><td>
<p><code class="literal">max(1, 2, 3)</code></p>
</td><td>
<p>3</p>
</td></tr><tr><td>
<p><code class="literal">min(...)</code></p>
</td><td>
<p><code class="literal">min(1, 2, 3)</code></p>
</td><td>
<p>1</p>
</td></tr></tbody></table></div><p>These two functions work not only with multiple scalar arguments but also with a vector input:</p><pre class="programlisting">max(c(1, 2, 3))&#13;
## [1] 3 &#13;
</pre><p>Also, they work with multiple vector input:</p><pre class="programlisting">max(c(1, 2, 3),&#13;
    c(2, 1, 2),&#13;
    c(1, 3, 4))&#13;
## [1] 4&#13;
min(c(1, 2, 3),&#13;
    c(2, 1, 2),&#13;
    c(1, 3, 4))&#13;
## [1] 1 &#13;
</pre><p>The output demonstrates that <code class="literal">max()</code> returns the maximal value among all values of all input vectors and <code class="literal">min()</code> returns vice versa.</p><p>What if we want to obtain maximal or minimal values of each position among all vectors? Look at the following lines of code:</p><pre class="programlisting">pmax(c(1, 2, 3),&#13;
    c(2, 1, 2),&#13;
    c(1, 3, 4))&#13;
## [1] 2 3 4 &#13;
</pre><p>This basically finds the maximal value among all numbers at position 1, then at position 2, and so on, which has the same output as the following code:</p><pre class="programlisting">x &lt;- list(c(1, 2, 3),&#13;
          c(2, 1, 2),&#13;
          c(1, 3, 4))&#13;
c(max(x[[1]][[1]], x[[2]][[1]], x[[3]][[1]]),&#13;
  max(x[[1]][[2]], x[[2]][[2]], x[[3]][[2]]),&#13;
  max(x[[1]][[3]], x[[2]][[3]], x[[3]][[3]]))&#13;
## [1] 2 3 4 &#13;
</pre><p>This is called the <span class="strong"><strong>parallel maxima</strong></span>. The twin function <code class="literal">pmin()</code> works to find the <span class="strong"><strong>parallel minima</strong></span>:</p><pre class="programlisting">pmin(c(1, 2, 3),&#13;
     c(2, 1, 2),&#13;
     c(1, 3, 4))&#13;
## [1] 1 1 2 &#13;
</pre><p>These two functions can be very useful to quickly compose a vectorized function with specific functions as floor and/or ceiling. For example, suppose <code class="literal">spread()</code> is a piecewise function. If the input is less than <code class="literal">-5</code>, the value is <code class="literal">-5</code>. If the input is between <code class="literal">-5</code> to <code class="literal">5</code>, the value is input. If the input is greater than <code class="literal">5</code>, then the value is <code class="literal">5</code>.</p><p>A naive implementation uses <code class="literal">if</code> to branch the pieces:</p><pre class="programlisting">spread &lt;- function(x) {&#13;
  if (x &lt; -5) -5&#13;
  else if (x &gt; 5) 5&#13;
  else x&#13;
} &#13;
</pre><p>The function works with scalar input, but it is not automatically vectorized:</p><pre class="programlisting">spread(1)&#13;
## [1] 1&#13;
spread(seq(-8, 8))&#13;
## Warning in if (x &lt; -5) -5 else if (x &gt; 5) 5 else x: the&#13;
## condition has length &gt; 1 and only the first element will be&#13;
## used&#13;
## [1] -5 &#13;
</pre><p>One method is to use <code class="literal">pmin()</code> and <code class="literal">pmax()</code>, and the function will be automatically vectorized:</p><pre class="programlisting">spread2 &lt;- function(x) {&#13;
  pmin(5, pmax(-5, x))&#13;
}&#13;
spread2(seq(-8, 8))&#13;
##  [1] -5 -5 -5 -5 -4 -3 -2 -1  0  1  2  3  4  5  5  5  5 &#13;
</pre><p>Another method is to use <code class="literal">ifelse()</code>:</p><pre class="programlisting">spread3 &lt;- function(x) {&#13;
  ifelse(x &lt; -5, -5, ifelse(x &gt; 5, 5, x))&#13;
}&#13;
spread3(seq(-8, 8))&#13;
##  [1] -5 -5 -5 -5 -4 -3 -2 -1  0  1  2  3  4  5  5  5  5 &#13;
</pre><p>The previous two functions, <code class="literal">spread2()</code> and <code class="literal">spread3()</code>, both have the same graphics:</p><div class="mediaobject"><img src="graphics/image_05_048.jpg" alt="Extreme functions"/></div></div></div>
<div class="section" title="Applying numeric methods"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec32"/>Applying numeric methods</h1></div></div></div><p>In the previous sections, you learned about a number of functions that range from inspecting data structures to math and logical operations. These functions are fundamental to solving problems such as root finding and doing calculus. As a computing environment, R already implements various tools of good performance so that users do not have to reinvent the wheel. In the following sections, you will learn the built-in functions designed for root finding and calculus.</p><div class="section" title="Root finding"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec79"/>Root finding</h2></div></div></div><p>Root finding is a commonly encountered task. Suppose we want to find the roots of the following equation:</p><p><span class="emphasis"><em>x2 + x - 2= 0</em></span></p><p>To manually find the roots, we can transform the preceding equation in product terms:</p><p><span class="emphasis"><em>(x+2)(x-1)= 0</em></span></p><p>Therefore, the roots of the equation are <span class="emphasis"><em>x1= -2</em></span> and <span class="emphasis"><em>x<sub>2</sub>= 1</em></span>.</p><p>In R, <code class="literal">polyroot()</code> can find roots of a polynomial equation in the form of:</p><div class="mediaobject"><img src="graphics/image_05_056.jpg" alt="Root finding"/></div><p>For the preceding problem, we need to specify the polynomial coefficient vector from zero order to the term of the highest order present in the equation. In this case, the vector is <code class="literal">c(-2, 1, 1)</code> to represent the coefficients in the increasing order of power:</p><pre class="programlisting">polyroot(c(-2, 1, 1))&#13;
## [1]  1-0i -2+0i &#13;
</pre><p>The function always returns a complex vector in which each element is a complex number in the form of <code class="literal">a + bi</code>. On the one hand, if the function surely has only real roots, you can use <code class="literal">Re()</code> to extract the real parts of the complex roots:</p><pre class="programlisting">Re(polyroot(c(-2, 1, 1)))&#13;
## [1]  1 -2 &#13;
</pre><p>On the other hand, the type of output implies that <code class="literal">polyroot()</code> has the capability to find complex roots of a polynomial equation. The simplest one is as follows:</p><div class="mediaobject"><img src="graphics/image_05_058.jpg" alt="Root finding"/></div><p>To find its complex roots, just specify a polynomial coefficient vector:</p><pre class="programlisting">polyroot(c(1, 0, 1))&#13;
## [1] 0+1i 0-1i &#13;
</pre><p>A slightly more complex example is to find the roots of the following equation:</p><div class="mediaobject"><img src="graphics/image_05_060.jpg" alt="Root finding"/></div><pre class="programlisting">r &lt;- polyroot(c(-1, -2, -1, 1))&#13;
r&#13;
## [1] -0.5739495+0.3689894i -0.5739495-0.3689894i&#13;
## [3]  2.1478990-0.0000000i &#13;
</pre><p>Note that all complex roots are found. To verify, just replace <code class="literal">x</code> with <code class="literal">r</code>:</p><pre class="programlisting">r ^ 3 - r ^ 2 - 2 * r - 1&#13;
## [1] 8.881784e-16+1.110223e-16i 8.881784e-16+2.220446e-16i&#13;
## [3] 8.881784e-16-4.188101e-16i &#13;
</pre><p>Due to some numeric computing issues, the preceding expression does not strictly go to zero, but it gets extremely near. If you only care about 8 digits of the error, use the <code class="literal">round()</code> function, and you will find that the roots are valid:</p><pre class="programlisting">round(r ^ 3 - r ^ 2 - 2 * r - 1, 8)&#13;
## [1] 0+0i 0+0i 0+0i &#13;
</pre><p>As for general numeric root finding for equation <span class="emphasis"><em>f(x)=0</em></span>, the <code class="literal">uniroot()</code> function, as its name suggests, can be useful to find one root. A simple example is to find the root of the following equation:</p><div class="mediaobject"><img src="graphics/image_05_064.jpg" alt="Root finding"/></div><p>Within the following range:</p><p> </p><div class="mediaobject"><img src="graphics/image_05_065.jpg" alt="Root finding"/></div><p>.</p><p>The plot generated is as shown:</p><div class="mediaobject"><img src="graphics/image_05_068.jpg" alt="Root finding"/></div><p>The curve of the function shows that the root lies in <span class="strong"><strong>[-1.0,0.5]</strong></span>. Using <code class="literal">uniroot()</code> with the function and interval will return a list containing the approximate root, the function value at that point, the number of iteration it takes, and the estimated precision of the root:</p><pre class="programlisting">uniroot(function(x) x ^ 2 - exp(x), c(-2, 1))&#13;
## $root&#13;
## [1] -0.7034583&#13;
##&#13;
## $f.root&#13;
## [1] -1.738305e-05&#13;
##&#13;
## $iter&#13;
## [1] 6&#13;
##&#13;
## $init.it&#13;
## [1] NA&#13;
##&#13;
## $estim.prec&#13;
## [1] 6.103516e-05 &#13;
</pre><p>A more complex example is to find a root of the following equation:</p><div class="mediaobject"><img src="graphics/image_05_072.jpg" alt="Root finding"/></div><p>Within the following range: </p><div class="mediaobject"><img src="graphics/image_05_073.jpg" alt="Root finding"/></div><p>.</p><p>The plot generated is as shown:</p><div class="mediaobject"><img src="graphics/image_05_076.jpg" alt="Root finding"/></div><p>It is obvious that the equation has two roots from <span class="strong"><strong>-2</strong></span> to <span class="strong"><strong>2</strong></span>. However, <code class="literal">uniroot()</code> is only capable of finding one root at a time, and it's best that the function is monotonic in the interval to search. If we directly let it find a root in the <span class="strong"><strong>[-2,2] </strong></span>interval, the function produces an error:</p><pre class="programlisting">f &lt;- function(x) exp(x) - 3 * exp(-x ^ 2 + x) + 1&#13;
uniroot(f, c(-2, 2))&#13;
## Error in uniroot(f, c(-2, 2)): f() values at end points not of opposite sign &#13;
</pre><p>We have to make sure that the function values of both ends of the interval have opposite signs. We can separate the interval into two smaller ones and find roots in a separate manner:</p><pre class="programlisting">uniroot(f, c(-2, 0))$root&#13;
## [1] -0.4180424&#13;
uniroot(f, c(0, 2))$root&#13;
## [1] 0.8643009 &#13;
</pre><p>An even more complex equation is as follows:</p><div class="mediaobject"><img src="graphics/image_05_080.jpg" alt="Root finding"/></div><p>Within the following range:</p><div class="mediaobject"><img src="graphics/image_05_081.jpg" alt="Root finding"/></div><p>.</p><p>The plot generated is as shown:</p><div class="mediaobject"><img src="graphics/image_05_084.jpg" alt="Root finding"/></div><p>The curve shows that the equation has even more roots. The following code only finds one in the <span class="strong"><strong>[0,1]</strong></span> interval:</p><pre class="programlisting">uniroot(function(x) x ^ 2 - 2 * x + 4 * cos(x ^ 2) - 3, c(0, 1))$root&#13;
## [1] 0.5593558 &#13;
</pre><p>In some of the preceding root-finding function calls, we directly pass a function to <code class="literal">uniroot()</code> without giving the function a name. They are called <span class="strong"><strong>anonymous functions</strong></span>. We will cover this concept in detail in later chapters.</p></div><div class="section" title="Calculus"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec80"/>Calculus</h2></div></div></div><p>In addition to root finding, numeric methods in base R also include computing basic calculus.</p><div class="section" title="Derivatives"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec22"/>Derivatives</h3></div></div></div><p><code class="literal">D()</code> computes the derivative of a function symbolically with respect to given variables.</p><p>For example, derive <span class="emphasis"><em>dx<sup>2</sup>/dx</em></span>:</p><pre class="programlisting">D(quote (x ^ 2), "x")&#13;
## 2 * x &#13;
</pre><p>Derive <span class="emphasis"><em>dsin(x)cos(xy)/dx</em></span>:</p><pre class="programlisting">D(quote(sin(x) * cos(x * y)), "x")&#13;
## cos(x) * cos(x * y) - sin(x) * (sin(x * y) * y) &#13;
</pre><p>Thanks to the <code class="literal">quote()</code> function, it keeps the expression unevaluated so that the symbols are directly accessible as they are written.</p><p>Since the derivative is also an unevaluated expression, we can evaluate it, given all necessary symbols by calling <code class="literal">eval()</code>:</p><pre class="programlisting">z &lt;- D(quote(sin(x) * cos(x * y)), "x")&#13;
z&#13;
## cos(x) * cos(x * y) - sin(x) * (sin(x * y) * y)&#13;
eval(z, list(x = 1, y = 2))&#13;
## [1] -1.75514 &#13;
</pre><p>In the preceding example, <code class="literal">quote()</code> creates an expression object and <code class="literal">eval()</code> evaluates a given expression with specified symbols. Expression object gives R the power of meta programming. We will cover this topic in <a class="link" href="ch09.html" title="Chapter 9.  Metaprogramming">Chapter 9</a>, <span class="emphasis"><em>Metaprogramming</em></span>.</p></div><div class="section" title="Integration"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec23"/>Integration</h3></div></div></div><p>R also supports numeric integration. Here, we do not have to write the expression but provide a function since it is not symbolic computation. For instance, the following formula is a problem of definite integral. It basically calculates the area below the sine curve from <span class="emphasis"><em>0</em></span> to <span class="emphasis"><em>pi/2</em></span>. R provides built-in function, <code class="literal">integrate()</code>, to solve such problems with great flexibility as long as the mathematical function can be represented by an R function:</p><div class="mediaobject"><img src="graphics/image_05_094.jpg" alt="Integration"/></div><pre class="programlisting">result &lt;- integrate(function(x) sin(x), 0, pi / 2)&#13;
result&#13;
## 1 with absolute error &lt; 1.1e-14 &#13;
</pre><p>The result looks like a numeric value, but it seems to take some other information. In fact, it is a list:</p><pre class="programlisting">str(result)&#13;
## List of 5&#13;
## $ value : num 1&#13;
## $ abs.error : num 1.11e-14&#13;
## $ subdivisions: int 1&#13;
## $ message : chr "OK"&#13;
## $ call : language integrate(f = function(x) sin(x), lower = 0, upper = pi/2)&#13;
##  - attr(*, "class")= chr "integrate" &#13;
</pre><p>Since it is a numerical computation, it inherits all the pros and cons of such computing techniques.</p></div></div></div>
<div class="section" title="Using statistical functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec33"/>Using statistical functions</h1></div></div></div><p>R is highly productive in doing statistical computing and modeling since it provides a good variety of functions ranging from random sampling to statistical testing. The functions in the same category share a common interface. In this section, I will demonstrate a number of examples so that you can draw inferences about the usage of other similar functions.</p><div class="section" title="Sampling from a vector"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec81"/>Sampling from a vector</h2></div></div></div><p>In statistics, the study of a population often begins with a random sample of it. The <code class="literal">sample()</code> function is designed for drawing a random sample from a given vector or list. In default, <code class="literal">sample()</code> draws a sample without replacement. For example, the following code draws a sample of five from a numeric vector without replacement:</p><pre class="programlisting">sample(1:6, size = 5)&#13;
## [1] 2 6 3 1 4 &#13;
</pre><p>With <code class="literal">replace = TRUE</code>, the sampling is done with replacement:</p><pre class="programlisting">sample(1:6, size = 5, replace = TRUE)&#13;
## [1] 3 5 3 4 2 &#13;
</pre><p>Although <code class="literal">sample()</code> is often used to draw samples from a numeric vector, it also works with other types of vectors:</p><pre class="programlisting">sample(letters, size = 3)&#13;
## [1] "q" "w" "g" &#13;
</pre><p>It even works with lists:</p><pre class="programlisting">sample(list(a = 1, b = c(2, 3), c = c(3, 4, 5)), size = 2)&#13;
## $b&#13;
## [1] 2 3&#13;
##&#13;
## $c&#13;
## [1] 3 4 5 &#13;
</pre><p>In fact, <code class="literal">sample()</code> is capable of sampling from any object that supports subsetting with brackets (<code class="literal">[]</code>). In addition, it supports weighted sampling, that is, you can specify a probability for each element:</p><pre class="programlisting">grades &lt;- sample(c("A", "B", "C"), size = 20, replace = TRUE,&#13;
prob = c(0.25, 0.5, 0.25))&#13;
grades&#13;
## [1] "C" "B" "B" "B" "C" "C" "C" "C" "C" "B" "B" "A" "A" "C"&#13;
## [15] "B" "B" "A" "B" "A" "C" &#13;
</pre><p>We can use <code class="literal">table()</code> to see the number of occurrences of each value:</p><pre class="programlisting">table(grades)&#13;
## grades&#13;
## A B C&#13;
## 4 8 8 &#13;
</pre></div><div class="section" title="Working with random distributions"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec82"/>Working with random distributions</h2></div></div></div><p>In numeric simulations, it is more often the case that we need to draw samples from a random distribution rather than from a given vector. R provides a good variety of built-in functions to work with popular probability distributions. In this section, we will see how R provides basic statistical tools to work with R objects that represent sample data. These tools can be used to work mainly with numeric vectors.</p><p>In R, it is very easy to generate random numbers following a statistical distribution. The most commonly used two distributions are uniform distribution and normal distribution.</p><p>In a statistical sense, it is equally probable to draw any value from a uniform distribution within a given range. We can call <code class="literal">runif(n)</code> to generate <code class="literal">n</code> random numbers from a uniform distribution over <span class="strong"><strong>[0,1]</strong></span>:</p><pre class="programlisting">runif(5)&#13;
## [1] 0.8894535 0.1804072 0.6293909 0.9895641 0.1302889 &#13;
</pre><p>To generate random numbers within a non-default interval, specify <code class="literal">min</code> and <code class="literal">max</code>:</p><pre class="programlisting">runif(5, min = -1, max = 1)&#13;
## [1] -0.3386789  0.7302411  0.5551689  0.6546069  0.2066487 &#13;
</pre><p>If we generate 1000 random numbers using <code class="literal">runif(1000)</code> and draw the points, we will get a scatter plot (a plot to show X-Y points) as follows:</p><div class="mediaobject"><img src="graphics/image_05_097.jpg" alt="Working with random distributions"/></div><p>The histogram shows that the random numbers we generated distribute almost evenly across each interval from 0 to 1, which is consistent with uniform distribution.</p><p>Another distribution that is most commonly seen in the real world is the normal distribution. Similar to <code class="literal">runif()</code>, we can use <code class="literal">rnorm()</code> to generate random numbers following a standard normal distribution:</p><pre class="programlisting">rnorm(5)&#13;
## [1]  0.7857579  1.1820321 -0.9558760 -1.0316165  0.4336838 &#13;
</pre><p>You may notice that the random generator functions share the same interface. The first argument of both <code class="literal">runif()</code> and <code class="literal">rnorm()</code> is <code class="literal">n</code>, the number of values to generate, and the rest of the arguments are the parameters of the random distribution itself. As for a normal distribution, its parameters are <code class="literal">mean</code> and standard deviation (<code class="literal">sd</code>):</p><pre class="programlisting">rnorm(5, mean = 2, sd = 0.5)&#13;
## [1] 1.597106 1.971534 2.374846 3.023233 2.033357 &#13;
</pre><p>The plot generated is as shown:</p><div class="mediaobject"><img src="graphics/image_05_098.jpg" alt="Working with random distributions"/></div><p>From the preceding graphics, it is obvious that the points are not evenly distributed but concentrate on the mean instead. As we know, statistical distributions can be described by certain formulas. To access these formulas in theory, R provides a family of functions for each built-in random distribution. More specifically, for uniform distribution, R provides its probability density function <code class="literal">dunif()</code>, cumulative density function <code class="literal">punif()</code>, quantile function <code class="literal">qunif()</code>, and random generator <code class="literal">runif()</code>. For normal distribution, the corresponding names are <code class="literal">dnorm()</code>, <code class="literal">pnorm()</code>, and <code class="literal">qnorm()</code>. The same naming scheme of density function, cumulative density function, quantile function, as well as random generator also applies to other distributions R supports.</p><p>In addition to these two most commonly used statistical distributions, R also provides functions for discrete distributions, such as binomial distribution, and continuous distributions, such as exponential distribution. You can run <code class="literal">?Distributions</code> to see a full list of supported distributions. The features of those distributions are beyond the scope of this book. If you are not familiar with them but are interested in the features of these distributions, you may read any textbook
 on probability theory or visit Wikipedia (<a class="ulink" href="https://en.wikipedia.org/wiki/Probability_distribution">https://en.wikipedia.org/wiki/Probability_distribution</a>) for more details.</p><p>R supports many distributions, and each of them has corresponding functions. Fortunately we don't need to remember a lot of different function names because they all follow the same naming convention.</p></div><div class="section" title="Computing summary statistics"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec83"/>Computing summary statistics</h2></div></div></div><p>For a given dataset, we often need some summary statistics to get an initial impression on it. R provides a set of functions to compute summary statistics for a numeric vector, including mean, median, standard deviation, variance, maximum, minimum, range, and quantiles. For multiple numeric vectors, we can compute the covariance matrix and correlation matrix.</p><p>The following examples show how we use the built-in functions to compute these summary statistics. First, we generate a random numeric vector of length 50 from standard normal distribution:</p><pre class="programlisting">x &lt;- rnorm(50) &#13;
</pre><p>To compute the arithmetic sample mean value of <code class="literal">x</code>, we call <code class="literal">mean()</code>:</p><pre class="programlisting">mean(x)&#13;
## [1] -0.1051295 &#13;
</pre><p>This is equivalent to:</p><pre class="programlisting">sum(x) / length(x)&#13;
## [1] -0.1051295 &#13;
</pre><p>However, <code class="literal">mean()</code> supports trimming a fraction of observations from each end of the input data:</p><pre class="programlisting">mean(x, trim = 0.05)&#13;
## [1] -0.141455 &#13;
</pre><p>If <code class="literal">x</code> contains a few outliers far from other values, the mean value obtained from the preceding equation should be more robust since the outliers are omitted from the input.</p><p>An alternative measure of the representative location of a sample data is the sample median. For a given sample, half of the observations are higher than the median, and the other half are lower than the median. The median can be a robust measure if there are a few extreme values in the data. For <code class="literal">x</code>, the sample median is:</p><pre class="programlisting">median(x)&#13;
## [1] -0.2312157 &#13;
</pre><p>In addition to location measures such as mean and median, variation measures are important too. To compute the standard deviation of a numeric vector, we use <code class="literal">sd()</code>:</p><pre class="programlisting">sd(x)&#13;
## [1] 0.8477752 &#13;
</pre><p>To compute the variance, we use <code class="literal">var()</code>:</p><pre class="programlisting">var(x)&#13;
## [1] 0.7187228 &#13;
</pre><p>To simply get the extreme values in the data, we use <code class="literal">min()</code> and <code class="literal">max()</code>:</p><pre class="programlisting">c(min = min(x), max = max(x))&#13;
## min max&#13;
## -1.753655  2.587579 &#13;
</pre><p>Alternatively, you can use <code class="literal">range()</code> to directly get both:</p><pre class="programlisting">range(x)&#13;
## [1] -1.753655  2.587579 &#13;
</pre><p>Sometimes, the data is not regularly distributed. In this case, the location measures and variation measures suffer from such irregularity and may produce misleading results. Here, we should probably take a look at the values at critical quantiles of the data:</p><pre class="programlisting">quantile(x)&#13;
## 0% 25% 50% 75% 100%&#13;
## -1.7536547 -0.6774037 -0.2312157  0.2974412  2.5875789 &#13;
</pre><p>To see more quantiles, specify more values for the <code class="literal">probs</code> argument:</p><pre class="programlisting">quantile(x, probs = seq(0, 1, 0.1))&#13;
## 0% 10% 20% 30%&#13;
## -1.753654706 -1.116231750 -0.891186551 -0.504630513&#13;
## 40% 50% 60% 70%&#13;
## -0.412239924 -0.231215699 0.009806393 0.177344522&#13;
## 80% 90% 100%&#13;
##  0.550510144  0.968607716  2.587578887 &#13;
</pre><p>If the data is not regularly distributed, the gap of values between two quantiles can be very large or small, compared to others. A shortcut for this is to use <code class="literal">summary()</code>, which directly gives the most commonly used summary statistics, including four quantiles, median, and mean:</p><pre class="programlisting">summary(x)&#13;
## Min. 1st Qu. Median Mean 3rd Qu. Max.&#13;
## -1.7540 -0.6774 -0.2312 -0.1051  0.2974  2.5880 &#13;
</pre><p>Note that the minimum values and the maximum values are the 0 percent quantile and 100 percent quantile, respectively.</p><p>In fact, <code class="literal">summary()</code> is a generic function that works for many types of objects and has different behaviors. For example, <code class="literal">summary()</code> works with data frames too:</p><pre class="programlisting">df &lt;- data.frame(score = round(rnorm(100, 80, 10)),&#13;
grade = sample(letters[1:3], 100, replace = TRUE))&#13;
summary(df)&#13;
## score grade&#13;
## Min. : 60.00 a:34&#13;
## 1st Qu.: 73.00 b:38&#13;
## Median : 79.00 c:28&#13;
## Mean : 79.65&#13;
## 3rd Qu.: 86.00&#13;
##  Max.   :107.00 &#13;
</pre><p>It can be seen that for a numeric column, <code class="literal">summary()</code> shows the summary statistics. For columns of other types, it may just simply show a table of value occurrences.</p><div class="section" title="Computing covariance and correlation matrix"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec24"/>Computing covariance and correlation matrix</h3></div></div></div><p>The preceding examples introduced the most commonly used summary statistics for one vector. For two or more vectors, we can compute the covariance matrix and the correlation matrix.</p><p>The following code generates another vector that is correlated with <code class="literal">x</code>:</p><pre class="programlisting">y &lt;- 2 * x + 0.5 * rnorm(length(x)) &#13;
</pre><p>We can compute the covariance between <code class="literal">x</code> and <code class="literal">y</code>:</p><pre class="programlisting">cov(x, y)&#13;
## [1] 1.419859 &#13;
</pre><p>We can also compute the correlation coefficient:</p><pre class="programlisting">cor(x, y)&#13;
## [1] 0.9625964 &#13;
</pre><p>These two functions also work with more than two vectors. If we need to compute the covariance and correlation matrix of more than two vectors, we need to input a matrix or a data frame. In the following example, we generate another random vector <code class="literal">z</code> of the same length of <code class="literal">x</code>. This time, <code class="literal">z</code> follows a uniform distribution and does not depend on either <code class="literal">x</code> or <code class="literal">y</code>. We use <code class="literal">cbind()</code> to create a three-column matrix and compute the covariance matrix of them:</p><pre class="programlisting">z &lt;- runif(length(x))&#13;
m1 &lt;- cbind(x, y, z)&#13;
cov(m1)&#13;
##           x          y          z&#13;
## x 0.7187228 1.41985899 0.04229950&#13;
## y 1.4198590 3.02719645 0.07299981&#13;
## z 0.0422995 0.07299981 0.08005535 &#13;
</pre><p>Similarly, we can call <code class="literal">cor()</code> directly with the matrix to compute the correlation matrix.</p><pre class="programlisting">cor(m1)&#13;
##           x         y         z&#13;
## x 1.0000000 0.9625964 0.1763434&#13;
## y 0.9625964 1.0000000 0.1482881&#13;
## z 0.1763434 0.1482881 1.0000000 &#13;
</pre><p>Since <code class="literal">y</code> is generated by a linear relationship with <code class="literal">x</code>, plus some noise, we should expect that <code class="literal">x</code> and <code class="literal">y</code> are highly correlated, but the same thing should not happen with <code class="literal">z</code>. The correlation matrix looks consistent with our expectation. To draw such a conclusion in a statistical sense, we need to perform rigorous statistical tests, which is beyond the scope of this book.</p></div></div></div>
<div class="section" title="Using apply-family functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec34"/>Using apply-family functions</h1></div></div></div><p>Previously, we talked about using a <code class="literal">for</code> loop to repeat evaluating an expression with an iterator on a vector or list. In practice, however, the <code class="literal">for</code> loop is almost the last choice because an alternative way is much cleaner and easier to write and read when each iteration is independent of each other.</p><p>For example, the following code uses <code class="literal">for</code> to create a list of three independent, normally distributed random vectors whose length is specified by vector <code class="literal">len</code>:</p><pre class="programlisting">len &lt;- c(3, 4, 5)&#13;
# first, create a list in the environment.&#13;
x &lt;- list()&#13;
# then use `for` to generate the random vector for each length&#13;
for (i in 1:3) {&#13;
  x[[i]] &lt;- rnorm(len[i])&#13;
}&#13;
x&#13;
## [[1]]&#13;
## [1] 1.4572245 0.1434679 -0.4228897&#13;
##&#13;
## [[2]]&#13;
## [1] -1.4202269 -0.7162066 -1.6006179 -1.2985130&#13;
##&#13;
## [[3]]&#13;
## [1] -0.6318412  1.6784430  0.1155478  0.2905479 -0.7363817 &#13;
</pre><p>The preceding example is simple, but the code is quite redundant compared to the implementation with <code class="literal">lapply</code>:</p><pre class="programlisting">lapply(len, rnorm)&#13;
## [[1]]&#13;
## [1] -0.3258354 -1.4658116 -0.1461097&#13;
##&#13;
## [[2]]&#13;
## [1] -0.1715198 0.5215857 -0.3178271 -0.3967798&#13;
##&#13;
## [[3]]&#13;
## [1] -0.2047106 -1.2009772  1.4859955  0.1940920  0.3758798 &#13;
</pre><p>The <code class="literal">lapply</code> version is much simpler. It applies <code class="literal">rnorm()</code> on each element in <code class="literal">len</code> and puts each result into a list.</p><p>From the preceding example, we should realize that it is only possible if R allows us to pass functions as ordinary objects. Fortunately, it is true. Functions in R are treated just like objects and can be passed around as arguments, just as we showed in the section on numeric methods. This feature largely boosts the flexibility of coding.</p><p>Each apply-family function is a so-called <span class="strong"><strong>higher-order function</strong></span> that accepts a function as an argument. We will introduce this concept in detail later.</p><div class="section" title="lapply"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec84"/>lapply</h2></div></div></div><p>The <code class="literal">lapply()</code> function, as we previously demonstrated, takes a vector and a function as its arguments. It simply applies the function to each element in the given vector and finally returns a list that contains all the results.</p><p>This function is useful when each iteration is independent of the other. In this case, we don't have to explicitly create an iterator.</p><p>It works not only with vectors but also with lists. Suppose we have a list of students:</p><pre class="programlisting">students &lt;- list(&#13;
  a1 = list(name = "James", age = 25,&#13;
    gender = "M", interest = c("reading", "writing")),&#13;
  a2 = list(name = "Jenny", age = 23,&#13;
    gender = "F", interest = c("cooking")),&#13;
  a3 = list(name = "David", age = 24,&#13;
    gender = "M", interest = c("running", "basketball"))) &#13;
</pre><p>Now, we need to create a character vector in which each element is formatted as follows:</p><pre class="programlisting">James, 25 year-old man, loves reading, writing. &#13;
</pre><p>Note that <code class="literal">sprintf()</code> is useful to format text by replacing the placeholders (for example, <code class="literal">%s</code> for string, <code class="literal">%d</code> for integer) with corresponding input arguments. Here is an example:</p><pre class="programlisting">sprintf("Hello, %s! Your number is %d.", "Tom", 3)&#13;
## [1] "Hello, Tom! Your number is 3." &#13;
</pre><p>Now, first, we are sure that an iteration is working on <code class="literal">students</code>, and each is independent. In other words, the computation for James has nothing to do with that for Jenny, and so on. Therefore, we can use <code class="literal">lapply</code> to do the work:</p><pre class="programlisting">lapply(students, function(s) {&#13;
  type &lt;- switch(s$gender, "M" = "man", "F" = "woman")&#13;
  interest &lt;- paste(s$interest, collapse = ", ")&#13;
  sprintf("%s, %d year-old %s, loves %s.", s$name, s$age, type, interest)&#13;
})&#13;
## $a1&#13;
## [1] "James, 25 year-old man, loves reading, writing."&#13;
##&#13;
## $a2&#13;
## [1] "Jenny, 23 year-old woman, loves cooking."&#13;
##&#13;
## $a3&#13;
## [1] "David, 24 year-old man, loves running, basketball." &#13;
</pre><p>The preceding code uses an anonymous function which is a function that is not assigned to a symbol. In other words, the function is only temporal and has no name. Of course, we can explicitly bind the function to a symbol, that is, give it a name, and use that name in <code class="literal">lapply</code>.</p><p>Despite this, the code is quite straightforward. For each element <code class="literal">s</code> in <code class="literal">students</code>, the function decides the type of the student and pastes their interests together, separated by commas. It then puts the information in a format we want.</p><p>Fortunately, a major part of how we use <code class="literal">lapply</code> also works with other apply-family functions, but their iterating mechanism or the type of results may be different.</p></div><div class="section" title="sapply"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec85"/>sapply</h2></div></div></div><p>List is not always a favorable container for the results. Sometimes, we want them to be put in a simple vector or a matrix. The <code class="literal">sapply</code> function simplifies the result according to its structure.</p><p>Suppose we apply a square on each element of <code class="literal">1:10</code>. If we do it with <code class="literal">lapply</code>, we will have a list of squared numbers. This result looks a bit heavy and redundant because the resulted list is actually a list of single-valued numeric vectors. However, we might want to keep the results still as a vector:</p><pre class="programlisting">sapply(1:10, function(i) i ^ 2)&#13;
##  [1]   1   4   9  16  25  36  49  64  81 100 &#13;
</pre><p>If the applying function returns a multi-element vector each time, <code class="literal">sapply</code> will put the results into a matrix in which each returned vector occupies a column:</p><pre class="programlisting">sapply(1:10, function(i) c(i, i ^ 2))&#13;
## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]&#13;
## [1,] 1 2 3 4 5 6 7 8 9 10&#13;
## [2,]    1    4    9   16   25   36   49   64   81   100 &#13;
</pre></div><div class="section" title="vapply"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec86"/>vapply</h2></div></div></div><p>Although <code class="literal">sapply</code> is very handy and smart, the smartness may sometimes become a risk. Suppose we have a list of input numbers:</p><pre class="programlisting">x &lt;- list(c(1, 2), c(2, 3), c(1, 3)) &#13;
</pre><p>If we want to get a numeric vector of the squared numbers for each number in <code class="literal">x</code>, <code class="literal">sapply</code> can be easy to use because it automatically tries to simplify the data structure of the result:</p><pre class="programlisting">sapply(x, function(x) x ^ 2)&#13;
## [,1] [,2] [,3]&#13;
## [1,] 1 4 1&#13;
## [2,] 4 9 9 &#13;
</pre><p>However, if the input data has some mistakes or corruption, <code class="literal">sapply()</code> will silently accept the input and may return an unexpected value. For example, let's assume that the third element of <code class="literal">x</code> has mistakenly got an additional element:</p><pre class="programlisting">x1 &lt;- list(c(1, 2), c(2, 3), c(1, 3, 3)) &#13;
</pre><p>Then, <code class="literal">sapply()</code> finds that it can no longer be simplified to a matrix and thus returns a list:</p><pre class="programlisting">sapply(x1, function(x) x ^ 2)&#13;
## [[1]]&#13;
## [1] 1 4&#13;
##&#13;
## [[2]]&#13;
## [1] 4 9&#13;
##&#13;
## [[3]]&#13;
## [1] 1 9 9 &#13;
</pre><p>If we use <code class="literal">vapply()</code> in the first place, the mistake will be spotted very soon. The <code class="literal">vapply()</code> function has an additional argument that specifies the template of the returned value from each iteration. In the following code, the template is <code class="literal">numeric(2)</code>, which means each iteration should return a numeric vector of two elements. If the template is violated, the function will end up in an error:</p><pre class="programlisting">vapply(x1, function(x) x ^ 2, numeric(2))&#13;
## Error in vapply(x1, function(x) x^2, numeric(2)): values must be length 2,&#13;
##  but FUN(X[[3]]) result is length 3 &#13;
</pre><p>For the original and correct input, <code class="literal">vapply()</code> returns exactly the same matrix as <code class="literal">sapply()</code> did:</p><pre class="programlisting">vapply(x, function(x) x ^ 2, numeric(2))&#13;
## [,1] [,2] [,3]&#13;
## [1,] 1 4 1&#13;
## [2,] 4 9 9 &#13;
</pre><p>In conclusion, <code class="literal">vapply</code> is the safer version of <code class="literal">sapply</code> as it performs additional template checking. In practical use, if the template can be determined, it is better to use <code class="literal">vapply()</code> than <code class="literal">sapply()</code>.</p></div><div class="section" title="mapply"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec87"/>mapply</h2></div></div></div><p>While <code class="literal">lappy()</code> and <code class="literal">sapply()</code> both iterate over one vector, <code class="literal">mapply()</code> iterates over multiple vectors. In other words, <code class="literal">mapply</code> is a multivariate version of <code class="literal">sapply</code>:</p><pre class="programlisting">mapply(function(a, b, c) a * b + b * c + a * c,&#13;
a = c(1, 2, 3), b = c(5, 6, 7), c = c(-1, -2, -3))&#13;
## [1] -1 -4 -9 &#13;
</pre><p>The iterating function is allowed to return not only scalar values but multi-element vectors. Then, <code class="literal">mapply()</code> will simplify the result, just like <code class="literal">sapply()</code> does:</p><pre class="programlisting">df &lt;- data.frame(x = c(1, 2, 3), y = c(3, 4, 5))&#13;
df&#13;
## x y&#13;
## 1 1 3&#13;
## 2 2 4&#13;
## 3 3 5&#13;
mapply(function(xi, yi) c(xi, yi, xi + yi), df$x, df$y)&#13;
## [,1] [,2] [,3]&#13;
## [1,] 1 2 3&#13;
## [2,] 3 4 5&#13;
## [3,]    4    6    8 &#13;
</pre><p><code class="literal">Map</code> is the multivariate version of <code class="literal">lapply</code> and hence, always returns a list:</p><pre class="programlisting">Map(function(xi, yi) c(xi, yi, xi + yi), df$x, df$y)&#13;
## [[1]]&#13;
## [1] 1 3 4&#13;
##&#13;
## [[2]]&#13;
## [1] 2 4 6&#13;
##&#13;
## [[3]]&#13;
## [1] 3 5 8 &#13;
</pre></div><div class="section" title="apply"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec88"/>apply</h2></div></div></div><p>The <code class="literal">apply</code> function applies a function on a given margin or dimension of a given matrix or array. For example, to calculate the sum of each row, which is the first dimension, we need to specify <code class="literal">MARGIN = 1</code> so that <code class="literal">sum</code> is applied to a row (numeric vector) sliced from the matrix in each iteration:</p><pre class="programlisting">mat &lt;- matrix(c(1, 2, 3, 4), nrow = 2)&#13;
mat&#13;
## [,1] [,2]&#13;
## [1,] 1 3&#13;
## [2,] 2 4&#13;
apply(mat, 1, sum)&#13;
## [1] 4 6 &#13;
</pre><p>To calculate the sum of each column, which is the second dimension, we need to specify <code class="literal">MARGIN=2</code> so that <code class="literal">sum</code> is applied to a column sliced from <code class="literal">mat</code> in each iteration:</p><pre class="programlisting">apply(mat, 2, sum)&#13;
## [1] 3 7 &#13;
</pre><p>The <code class="literal">apply</code> function also supports array input and matrix output:</p><pre class="programlisting">mat2 &lt;- matrix(1:16, nrow = 4)&#13;
mat2&#13;
## [,1] [,2] [,3] [,4]&#13;
## [1,] 1 5 9 13&#13;
## [2,] 2 6 10 14&#13;
## [3,] 3 7 11 15&#13;
## [4,] 4 8 12 16 &#13;
</pre><p>To build a matrix that shows the max and min value for each column, run the following code:</p><pre class="programlisting">apply(mat2, 2, function(col) c(min = min(col), max = max(col)))&#13;
## [,1] [,2] [,3] [,4]&#13;
## min 1 5 9 13&#13;
## max 4 8 12 16 &#13;
</pre><p>To build a matrix that shows the max and min value for each row, run the following code:</p><pre class="programlisting">apply(mat2, 1, function(col) c(min = min(col), max = max(col)))&#13;
## [,1] [,2] [,3] [,4]&#13;
## min 1 2 3 4&#13;
## max 13 14 15 16</pre></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec35"/>Summary</h1></div></div></div><p>In this chapter, you learned how to work basic objects by demonstrating the use of built-in functions. They are the vocabulary of R in practice. You learned some basic functions to test and get object types and to access and reshape data dimensions. You learned about a number of logical operators and functions to filter data.</p><p>To work with numeric data structures, you learned basic math functions, built-in numeric methods to find roots and do calculus, and some statistical functions to perform random sampling and make summaries of data. You also understood the apply-family functions that make it easier to iterate and collect results.</p><p>Another important category of data is string, which is represented by character vectors. In the next chapter, you will learn string-manipulation techniques to facilitate text analysis.</p></div></body></html>