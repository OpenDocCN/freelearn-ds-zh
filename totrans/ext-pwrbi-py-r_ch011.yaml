- en: 10 Calculating Columns Using Complex Algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用复杂算法计算10个列
- en: The data ingestion phase allows you to gather all the information you need for
    your analysis from any data source. Once the various datasets have been imported,
    it may be that some of this information, taken as it is, isn’t useful in describing
    a phenomenon from an analytical point of view. It is often necessary to apply
    non-trivial algorithms to the data you have in order to get measures or indicators
    that will do the trick and Power BI often doesn’t have the tools to calculate
    them. Fortunately, thanks to R and Python, we have everything we need to calculate
    our measures.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数据摄入阶段允许你从任何数据源收集你分析所需的所有信息。一旦各种数据集被导入，可能的情况是，这些信息中的一些，未经处理，在从分析的角度描述现象时可能并不有用。通常需要应用非平凡算法来处理你拥有的数据，以便得到能够解决问题的度量或指标，而Power
    BI通常没有计算它们的工具。幸运的是，多亏了R和Python，我们拥有了计算度量所需的一切。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: The distance between two geographic locations
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个地理位置之间的距离
- en: Implementing distances using Python
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python实现距离计算
- en: Implementing distances using R
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用R实现距离计算
- en: The basics of linear programming
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性规划的基本原理
- en: Definition of the LP problem to solve
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要解决的LP问题的定义
- en: Handling optimization problems with Python
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python处理优化问题
- en: Solving LP problems with R
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用R解决LP问题
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires you to have a working internet connection and **Power
    BI Desktop** already installed on your machine. You must have properly configured
    the R and Python engines and IDEs as outlined in *Chapter 2*, *Configuring R with
    Power BI*, and *Chapter 3*, *Configuring Python with Power BI*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章要求你拥有一个工作的互联网连接，并且**Power BI桌面版**已经安装在你的机器上。你必须已经按照*第2章*、*配置Power BI中的R*和*第3章*、*配置Power
    BI中的Python*中概述的方式正确配置了R和Python引擎以及IDE。
- en: The distance between two geographic locations
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 两个地理位置之间的距离
- en: It often happens that you have in your dataset coordinates expressed in longitude
    and latitude that identify points on the globe. Depending on the purpose of the
    analysis you need to complete, you can leverage these coordinates to calculate
    measures that best help to describe the scenario you want to deal with. For example,
    assuming you have the geographic coordinates of some hotels in a dataset, it might
    make sense to calculate the distance of each of them to the nearest airport if
    you want to give an additional value of interest to a visitor. Let’s start by
    figuring out what types of distances to consider for our case.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，你的数据集中会有用经纬度表示的坐标，这些坐标标识了地球上的点。根据你需要完成的分析的用途，你可以利用这些坐标来计算最能帮助你描述你想要处理的场景的度量。例如，假设你有一个数据集中包含一些酒店的地理坐标，如果你想要给游客提供额外的有价值的信息，那么计算每个酒店到最近机场的距离可能是有意义的。让我们先确定我们案例中需要考虑的距离类型。
- en: Spherical trigonometry
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 球面三角学
- en: The study of how to measure triangles (**trigonometry**) has been of great interest
    in the past. The ancient Egyptians and Babylonians had already addressed the issues
    between the relationships between sides, although they did not yet have the notion
    of an angle. It is thanks to **Hellenistic mathematics** that the concepts of
    trigonometric functions as we know them now began to spread around the world,
    even reaching India and China.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如何测量三角形（**三角学**）的研究在过去一直非常有趣。古埃及人和巴比伦人已经处理了边之间的关系问题，尽管他们还没有角度的概念。多亏了**希腊数学**，我们现在所知的三角函数的概念开始在世界范围内传播，甚至达到了印度和中国。
- en: It was the ancient Greeks who, once they had explored all the properties associated
    with a triangle drawn on a plane, came up with the idea of imagining a triangle
    drawn on a sphere. The importance of measuring distances between points on a sphere
    was immediately shown to be of interest in later centuries for navigation and
    astronomy. Therefore, several minds devoted themselves eagerly to the discovery
    of important properties that today can be collected under the name of **spherical
    trigonometry**.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 是古希腊人，在探索了在平面上绘制的三角形的所有相关属性之后，提出了在球面上绘制三角形的想法。测量球面上点之间距离的重要性很快就被证明在后来的几个世纪中对于导航和天文学具有兴趣。因此，几个头脑热切地致力于发现今天可以收集在球面三角学名称下的重要属性。
- en: 'If you draw a spherical triangle, you will immediately notice the differences
    from a flat triangle:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你画一个球面三角形，你将立即注意到它与平面三角形的区别：
- en: '![Figure 10.1 – A spherical triangle](img/file235.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 球面三角形](img/file235.png)'
- en: Figure 10.1 – A spherical triangle
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 球面三角形
- en: 'The main difference with planar triangles is that the sides of spherical triangles
    are arcs of **great circles** or **geodesics** (circumferences that always divide
    the sphere in half), and since the central angles (near the center, *O*) are proportional
    to the lengths of their respective arcs (*length = π x angle*), the sides *a*,
    *b*, and *c* are measured with *angle units* rather than linear units. If you
    want a visualization of the fact that the sides of the spherical triangle belong
    to three great circles, *Figure 10.2* can help you:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 与平面三角形的主要区别在于，球面三角形的边是**大圆**或**测地线**（总是将球体分成两半的圆周），由于中心角（靠近中心，*O*）与它们各自弧的长度成比例（*长度
    = π x 角度*），因此边*a*、*b*和*c*是以*角度单位*而不是线性单位来测量的。如果你想可视化球面三角形的边属于三个大圆的事实，*图10.2*可以帮到你：
- en: '![Figure 10.2 – The great circles that generate a spherical triangle](img/file236.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – 生成球面三角形的球大圆](img/file236.png)'
- en: Figure 10.2 – The great circles that generate a spherical triangle
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 生成球面三角形的球大圆
- en: The mathematics describing spherical trigonometry makes it possible to define
    all the distances between two points on the sphere so far highlighted by great
    mathematicians of the past.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 描述球面三角学的数学使得能够定义过去被伟大的数学家所强调的球面上两点之间的所有距离。
- en: As for the distances between two geographical points, the reference coordinate
    system will be the one that makes use of **latitude** and **longitude**. Obviously,
    we will not go into the mathematical detail of the proofs of distances that we
    will propose shortly (also because some of them would be very complex indeed).
    We did, however, want to provide an introduction that would lay the groundwork
    that can be found in the most frequently used concepts of geographic distances.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 至于两个地理点之间的距离，参考坐标系将是使用**纬度**和**经度**的那个。显然，我们不会深入探讨我们即将提出的距离证明的数学细节（也因为我们中的一些确实非常复杂）。然而，我们确实想提供一个介绍，为地理距离最常用的概念奠定基础。
- en: Let’s now explore the most straightforward distance between two points, the
    law of Cosines distance.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来探讨两点之间最直接的距离，即余弦定理距离。
- en: The law of Cosines distance
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 余弦定理距离
- en: 'The **law of Cosines distance** (also called the **great circle distance**)
    is the shortest distance between two points on the surface of a sphere, measured
    along the surface of the sphere. Given two points, *P* and *Q*, a unique great
    circle passes through them. The two points separate the great circle into two
    distinct arcs. The length of the shorter arc is the distance of the great circle
    between the points:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**余弦定理距离**（也称为**大圆距离**）是在球面上两点之间的最短距离，沿着球面测量。给定两个点，*P*和*Q*，一个唯一的大圆穿过它们。这两个点将大圆分成两个不同的弧。较短弧的长度是两点之间大圆的距离：'
- en: '![Figure 10.3 – The great circle distance between the points P and Q](img/file237.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – 点P和点Q之间的大圆距离](img/file237.png)'
- en: Figure 10.3 – The great circle distance between the points P and Q
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 点P和点Q之间的大圆距离
- en: Observe that if the two points of which to calculate the distance are at the
    antipodes of the sphere (the **antipodal points** *u* and *v*), then the great
    circles that pass through them are infinite and the distance between these two
    points is calculated very easily, as it measures exactly half the circumference
    of the sphere.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果计算距离的两个点位于球体的对径点（**对径点** *u* 和 *v*），那么穿过它们的大圆是无限的，这两点之间的距离很容易计算，因为它正好测量了球体周长的一半。
- en: 'When, on the other hand, the points are not antipodal, it is possible to derive
    the preceding distance thanks to the **spherical law of Cosines** (see *References*
    at the end of this chapter) that governs spherical trigonometry (that’s why we
    also call it the law of Cosines distance). Without tediously going through the
    mathematical steps, the formula that calculates the law of Cosines (or great circle)
    distance between two points on a sphere is as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当点不是对称点时，可以通过控制球面三角学的 **球面余弦定律**（见本章末尾的 *参考文献*）推导出前面的距离。不经过繁琐的数学步骤，计算球面上两点之间余弦（或大圆）距离的公式如下：
- en: '![Figure 10.4 – The formula of the law of Cosines distance between two points](img/file238.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – 两点之间余弦距离定律的公式](img/file238.png)'
- en: Figure 10.4 – The formula of the law of Cosines distance between two points
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 两点之间余弦距离定律的公式
- en: Looking at it, it’s not the simplest, cleanest formula you’ve ever seen, right?
    Despite this, having a handy calculator available today, the preceding calculation
    remains feasible. Now imagine the ancient navigators who used to apply the great
    circle distance between various points on the globe. How could they have used
    the preceding formula, even though they had sine and cosine tables that would
    have facilitated some calculations? It would have been a very complex activity
    and subject to errors that could have cost the sailors their lives.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来，这并不是你见过的最简单、最干净的公式，对吧？尽管如此，今天有了方便的计算器，前面的计算仍然可行。现在想象一下古代的航海家，他们曾经使用地球上的各个点之间的大圆距离。即使他们有正弦和余弦表可以简化一些计算，他们又如何能使用前面的公式呢？这将是一项非常复杂的活动，可能会出现导致水手丧生的错误。
- en: '**Important Note**'
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: ''
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If the two points are close together (for example, a few kilometers apart on
    the sphere) and you don’t have a calculator with accurate precision, you might
    get inaccurate results.
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果两个点很近（例如，在球面上相隔几公里）并且你没有精确度高的计算器，你可能会得到不准确的结果。
- en: For these reasons, mathematicians of the age introduced the new trigonometric
    `haversin` function (or `hav`), which allows you to transform and smooth out the
    great circle distance formula, also avoiding the previously mentioned error for
    small distances. Let’s see how it does this.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，那个时代的数学家引入了新的三角函数 `haversin`（或 `hav`），它允许你转换和平滑大圆距离公式，同时也避免了之前提到的小距离误差。让我们看看它是如何做到这一点的。
- en: The law of Haversines distance
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Haversine距离定律
- en: 'The function called `haversine` (from *half-versed sine*) is defined as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为 `haversine`（来自 *half-versed sine*）的函数定义如下：
- en: '![Figure 10.5 – Definition of the haversine function](img/file239.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5 – haversine函数的定义](img/file239.png)'
- en: Figure 10.5 – Definition of the haversine function
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 – haversine函数的定义
- en: 'Thanks to this new function, it is possible to rewrite the law of Cosines distance
    as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了这个新函数，可以将余弦距离定律重写如下：
- en: '![Figure 10.6 – Definition of the law of Haversines distance](img/file240.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6 – Haversine距离定律的定义](img/file240.png)'
- en: Figure 10.6 – Definition of the law of Haversines distance
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 – Haversine距离定律的定义
- en: This new distance formulation is known as the **law of Haversines distance**.
    Its undoubted usefulness to navigators of the time becomes clear when you consider
    that, along with the tables of sines and cosines, tables of Haversines were also
    published. Therefore, the calculation of the distance between two points became
    immediate.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这种新的距离公式被称为 **Haversine距离定律**。当你考虑到，除了正弦和余弦表，还出版了Haversine表时，它对当时航海者的无疑有用性就变得明显了。因此，两点之间的距离计算变得即时。
- en: '**Important Note**'
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: ''
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Even this formula suffers from rounding errors due to the special (and somewhat
    unusual) case of antipodal points.
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 即使这个公式也受到特殊（并且有些不寻常）的对称点情况下的舍入误差的影响。
- en: To get a distance formula that has better accuracy than the Haversines one,
    you have to use Vincenty’s formula. Let’s see what this is all about.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要得到比Haversine公式更精确的距离公式，你必须使用Vincenty公式。让我们看看这是怎么回事。
- en: Vincenty’s distance
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Vincenty的距离
- en: 'The winning assumption that led the geodesist Vincenty to a more precise formula
    of the distance between two points was to consider the Earth as not a sphere but
    an ellipsoid slightly flattened at the poles (the difference is only about 21
    km):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 地球测量学家Vincenty得出两点之间距离更精确公式的获胜假设是将地球视为不是球体，而是一个在两极略微扁平的椭球体（差异仅为约21公里）：
- en: '![Figure 10.7 – An ellipsoid representation](img/file241.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图10.7 – 椭球体表示](img/file241.png)'
- en: Figure 10.7 – An ellipsoid representation
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 – 椭球体表示
- en: Unlike the Haversines method for calculating a distance on a sphere, **Vincenty’s
    formulas** describe a method that needs to converge to a solution through several
    iterations. In detail, a sequence of equations is calculated whose output is fed
    back into the same sequence of equations with the goal of minimizing the calculated
    value after a certain number of iterations. For this reason, Vincenty’s formulas
    are computationally more demanding.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与计算球面上距离的Haversine方法不同，**Vincenty的公式**描述了一种需要通过多次迭代收敛到解的方法。具体来说，计算一系列方程，其输出被反馈到同一序列的方程中，目的是在经过一定次数的迭代后最小化计算值。因此，Vincenty的公式在计算上要求更高。
- en: 'Vincenty’s formulas are related to two problems:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Vincenty的公式与两个问题相关：
- en: '**Direct problem**: Find the endpoint, *(Φ2, L2)*, and azimuth, *α2*, given
    an initial point, *(Φ1, L1)*, and initial azimuth, *α1*, and a distance, *s*.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**直接问题**：给定初始点，*(Φ1, L1)*，初始方位角，*α1*，和距离，*s*，找到终点，*(Φ2, L2)*，和方位角，*α2*。'
- en: '**Inverse problem**: Find the azimuths *α1*, *α2* and the ellipsoidal distance,
    *s*, given the coordinates of the two points, *(Φ1, L1)* and *(Φ2, L2)*.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反向问题**：给定两点的坐标，*(Φ1, L1)*和*(Φ2, L2)*，找到方位角*α1*，*α2*和椭球体距离，*s*。'
- en: The reverse problem is what we are interested in as we need to calculate the
    distance. To get an idea of the complexity of the formulas, take a look at the
    *References* section at the end of the chapter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感兴趣的反向问题是计算距离。为了了解公式的复杂性，请查看本章末尾的*参考文献*部分。
- en: Vincenty’s formulas are widely used in projects where there is a need for high
    precision in measurements because they are accurate to within 0.5 mm (0.020 in)
    of the Earth’s ellipsoid.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Vincenty的公式在需要高精度测量的项目中广泛使用，因为它们在地球椭球体上的精度在0.5毫米（0.020英寸）以内。
- en: '**Important Note**'
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: ''
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If the points are nearly antipodal, the algorithm fails to converge and the
    error is much larger or converges slowly.
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果点几乎是对抗的，算法无法收敛，误差会很大或收敛缓慢。
- en: In 2013, Karney used Newton’s method to give rapid convergence for all pairs
    of input points without any error.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 2013年，Karney使用牛顿法为所有输入点对提供了快速收敛，没有任何误差。
- en: At this point, the question that arises is what kind of distance is best to
    use and when. Let’s try to understand that in the following section.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，出现的问题是使用哪种距离最好以及何时使用。让我们在下一节中尝试理解这一点。
- en: What kind of distance to use and when
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用哪种距离以及何时使用
- en: 'Considering the strong limitation that the law of Cosines distance has for
    short distances between two points, the most used methods today in common applications
    are the law of Haversines (for short, Haversine) and Vincenty’s formulas (for
    short, Vincenty). Here are our suggestions about which distance to use in particular
    scenarios:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到余弦定理距离法在两点之间短距离的强烈限制，今天在常见应用中最常用的方法是Haversine定律（简称Haversine）和Vincenty的公式（简称Vincenty）。以下是我们在特定场景下关于使用哪种距离的建议：
- en: For *points located close to each other* (think short-range flights), the approximation
    of the Earth to a sphere is very likely. Therefore, methods based on the spherical
    Earth model, such as Haversine, which are computationally simpler (hence faster),
    will be quite adequate.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于*彼此靠近的点*（想想短程飞行），地球近似为一个球体的可能性非常大。因此，基于球体地球模型的方法，如Haversine，由于计算上更简单（因此更快），将非常合适。
- en: For *points located far away* (such as long-range flights, especially connecting
    opposite hemispheres), the spherical Earth model starts to be less tight and inaccurate.
    In these cases, Vincenty’s inverse formula for ellipsoids, which is substantially
    more computationally complex (hence generally slower), will give a better result.
    If you have computational limitations, you need to consider whether the faster
    models give sufficiently accurate results for your purposes.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 *远离地点*（例如长途飞行，尤其是连接相反半球的情况），球形地球模型开始变得不那么精确。在这些情况下，Vincenty 的椭球体逆公式，它计算上更为复杂（因此通常更慢），将给出更好的结果。如果您有计算限制，您需要考虑更快的模型是否足够精确以满足您的需求。
- en: Now that you’ve become well versed in the theory, let’s move on to implementing
    these algorithms in Python and R.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 既然您已经对理论有了深入的了解，让我们继续在 Python 和 R 中实现这些算法。
- en: Implementing distances using Python
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Python 实现距离
- en: The scenario on which we will implement the distance algorithms just described
    involves a dataset of US hotels, containing the latitude and longitude of each.
    The goal is to enrich the dataset by adding the distances to the nearest airports.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的距离算法的场景涉及一个包含美国酒店经纬度的数据集。目标是增加距离最近机场的距离。
- en: 'The hotel data is publicly available on *Back4App* ([https://bit.ly/data-hotels-usa](https://bit.ly/data-hotels-usa)).
    For convenience, we extracted only 100 hotels from New York City and we will calculate
    for each of them the distances from the LaGuardia and John F. Kennedy airports
    (you can find the airport data here: [https://datahub.io/core/airport-codes](https://datahub.io/core/airport-codes))
    using the Haversine (spherical model) and Karney (ellipsoidal model) methods.
    You can find the already extracted datasets for your convenience in the `Chapter10`
    folder of the GitHub repository. In detail, you will find the hotel data in the
    `hotels-ny.xlsx` file and the airport data in the `airport-codes.csv` file.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 酒店数据在 *Back4App* 上公开可用（[https://bit.ly/data-hotels-usa](https://bit.ly/data-hotels-usa)）。为了方便，我们只从纽约市提取了
    100 家酒店，我们将使用 Haversine（球形模型）和 Karney（椭球模型）方法计算每家酒店与拉瓜迪亚机场和约翰·肯尼迪机场的距离（您可以在以下位置找到机场数据：[https://datahub.io/core/airport-codes](https://datahub.io/core/airport-codes)）。您可以在
    GitHub 仓库的 `Chapter10` 文件夹中找到方便的已提取数据集。具体来说，您将在 `hotels-ny.xlsx` 文件中找到酒店数据，在 `airport-codes.csv`
    文件中找到机场数据。
- en: Calculating distances with Python
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Python 计算距离
- en: As we mentioned earlier, we are not those that like to reinvent the wheel, especially
    when there is a risk of running into complexities related to the domain of the
    problem to be solved. Fortunately, Python has a very active community of programmers
    with expertise in specific scientific domains who share their artifacts publicly.
    This is the case of the `PyGeodesy` package ([https://github.com/mrJean1/PyGeodesy](https://github.com/mrJean1/PyGeodesy)),
    created by Jean M. Brouwers, which implements in pure Python various computational
    tools for spherical and ellipsoidal models of the Earth that Chris Veness has
    made available for Java and Charles Karney himself has made available in C++.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，我们并不是喜欢重新发明轮子的人，尤其是在解决特定问题领域可能遇到复杂性的风险时。幸运的是，Python 拥有一个非常活跃的程序员社区，他们在特定的科学领域拥有专业知识，并且公开分享他们的成果。这就是
    Jean M. Brouwers 创建的 `PyGeodesy` 包（[https://github.com/mrJean1/PyGeodesy](https://github.com/mrJean1/PyGeodesy)）的例子，它由
    Jean M. Brouwers 创建，纯 Python 实现了各种用于地球的球形和椭球模型的各种计算工具，这些工具由 Chris Veness 为 Java
    制作，Charles Karney 本人为 C++ 制作。
- en: 'To be able to use this module, you must obviously install it in your environment
    and, since we intend to use the distance formulas optimized by Karney, we must
    also install the `geographiclib` package, directly maintained by him. Therefore,
    proceed as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此模块，您显然必须在您的环境中安装它，并且由于我们打算使用 Karney 优化的距离公式，我们还必须安装 `geographiclib` 包，该包由他直接维护。因此，按照以下步骤操作：
- en: Open Anaconda Prompt.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Anaconda Prompt。
- en: Switch to the `pbi_powerquery_env` environment, entering the `conda activate
    pbi_powerquery_env` command, and then press *Enter*.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到 `pbi_powerquery_env` 环境，输入 `conda activate pbi_powerquery_env` 命令，然后按 *Enter*。
- en: Install the `PyGeodesy` package, entering `pip install PyGeodesy`, and then
    press *Enter*.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 `PyGeodesy` 包，输入 `pip install PyGeodesy`，然后按 *Enter*。
- en: Install the `geographiclib` package, entering `pip install geographiclib`, and
    then press *Enter*.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 `geographiclib` 包，输入 `pip install geographiclib`，然后按 *Enter*。
- en: If you have not already done so, also install the `openpyxl` package by entering
    `pip install openpyxl`, and then press *Enter*.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，也可以通过输入`pip install openpyxl`来安装`openpyxl`包，然后按*Enter*键。
- en: 'At this point, you can proceed with the Python code. First, note that `PyGeodesy`
    package contains a form with basic geodesic functions, called `formy`. In this
    module, there are functions that directly calculate distances according to the
    Haversine''s and Vincenty formulas, but it doesn’t contain the variant of Karney’s
    formulas. Therefore, in addition to the standard pandas and NumPy modules, the
    following must be imported:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，你可以继续进行Python代码。首先，请注意`PyGeodesy`包包含一个具有基本大地测量函数的表单，称为`formy`。在这个模块中，有直接根据Haversine和Vincenty公式计算距离的函数，但它不包含Karney公式的变体。因此，除了标准的pandas和NumPy模块外，还必须导入以下内容：
- en: '[PRE0]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To calculate the distance according to Karney, you must use the objects provided
    by the `ellipsoidalKarney` module. Basically, you have to create the two points
    on the ellipsoid using the `LatLon` method of this model, and then calculate the
    distance. This is summarized in the following `karney` user-defined function:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要根据Karney计算距离，必须使用`ellipsoidalKarney`模块提供的对象。基本上，你必须使用该模型的`LatLon`方法在这两个椭球体上创建两个点，然后计算距离。这总结在以下`karney`用户定义函数中：
- en: '[PRE1]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After that, a second user-defined function is created for convenience as a
    wrapper for the calls to the calculation of the various distances:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，为了方便起见，创建了一个用户定义的第二个函数作为调用各种距离计算的包装器：
- en: '[PRE2]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, the hotels data is imported into the `hotel_df` dataframe and the airports
    data into the `airports_df` one. Since the airports dataframe has the `coordinates`
    column, which contains a string with longitude and latitude separated by a comma,
    these two values are split into two separate columns using the `split()` function
    and then appended to the same source dataframe without the `coordinates` column,
    now useless:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将酒店数据导入到`hotel_df`数据框中，将机场数据导入到`airports_df`数据框中。由于机场数据框包含一个`coordinates`列，其中包含用逗号分隔的经纬度字符串，因此这两个值使用`split()`函数分割成两个单独的列，然后追加到没有`coordinates`列的相同源数据框中，现在这个列已经没有用了：
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In order to conveniently access the latitude and longitude values of a specific
    airport, the user-defined `airportLatLongList()` function has been created, which
    accepts as parameters both a dataframe containing the airport data with the `iata_code`,
    `latitude` and `longitude` columns and the specific **IATA code** of the airport
    of interest. Remember that the IATA airport code is a three-letter code that identifies
    many airports and metropolitan areas around the world, defined by the **International
    Air Transport Association** (**IATA**). Therefore, John F. Kennedy International
    Airport is identified by the IATA code `JFK` and LaGuardia Airport by the code
    `LGA`. So, in order to get the coordinates of those airports, you can use the
    following code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便地访问特定机场的纬度和经度值，创建了一个用户定义的`airportLatLongList()`函数，它接受一个包含机场数据的数据框作为参数，该数据框具有`iata_code`、`latitude`和`longitude`列，以及感兴趣的机场的特定**IATA代码**。记住，IATA机场代码是一个三字母代码，用于识别世界上许多机场和都市地区，由**国际航空运输协会**(**IATA**)定义。因此，约翰·F·肯尼迪国际机场由IATA代码`JFK`识别，拉瓜迪亚机场由代码`LGA`识别。因此，为了获取这些机场的坐标，你可以使用以下代码：
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'That said, thanks to the `geodistance()` function, it is enough to have the
    geographical coordinates of two points in order to calculate the distance between
    them. For example, if you want to calculate the haversine distance between point
    `A(lat1,lng1)` and point `B(lat2,lng2)`, you just have to use this code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，多亏了`geodistance()`函数，只需要两个点的地理坐标就可以计算它们之间的距离。例如，如果你想计算点`A(lat1,lng1)`和点`B(lat2,lng2)`之间的haversine距离，你只需使用以下代码：
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To be able to calculate the Karney distance between them instead, you can take
    advantage of the `karney()` function and use this code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够计算它们之间的Karney距离，可以利用`karney()`函数并使用以下代码：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'However, how should you proceed if you no longer want to apply the `geodistance()`
    function to two single points, but to a series of points contained in a dataframe
    column and a second fixed point? Since the preceding function needs five input
    parameters, we could have used the `apply()` method of the pandas dataframe (as
    shown here: [http://bit.ly/pandas-apply-lambda](http://bit.ly/pandas-apply-lambda)).
    Instead, we introduced a convenient way to evaluate a function over successive
    tuples of the input Series. In order to vectorize a function, you must invoke
    the `np.vectorize()` method and pass as a parameter the function to be applied
    to the geographic coordinate Series. Then, you also have to pass the parameters
    of the input function as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The distances (in meters) resulting from the previous calculation are stored
    into the new `haversineDistanceFromJFK` column of the `hotels_df` dataframe. Similarly,
    the Karney distance can be calculated by simply referencing the `karney` function
    in the code chunk.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '**Important Note**'
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A **vectorized function** is not the same as a function used with `np.vectorize()`.
    A vectorized function is a function built into NumPy and executed in the underlying
    compiled code (C or Fortran) so that special processor registers are used to operate
    on several items at once. As you can imagine, vectorization is much more performant
    and preferable to `for` loops. For more details, check out the *References* section.
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you run the code for the `01-distances-from-airports-in-python.py` file
    in the `Python` folder, you’ll get something like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Haversine and Karney distances from hotels to JFK and LGA airports
    added](img/file242.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 – Haversine and Karney distances from hotels to JFK and LGA airports
    added
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Amazing! You were able to calculate both the Haversine and Karney distances
    in meters between all hotels and both airports using Python. At this point, it
    is straightforward to use similar code to calculate distances in Power BI. Let’s
    see how to do it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Calculating distances in Power BI with Python
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It’s time to implement what you’ve learned in Power BI. So, launch Power BI
    Desktop and let’s get going:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Make sure Power BI Desktop is referencing your latest environment in **Options**.
    After that, click on **Excel** to import the `hotels-ny.xlsx` file, which you
    can find in the `Chapter10` folder. Select it and click **Open**.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the **Sheet 1** table from the **Navigator** window:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.9 – Selecting the Sheet 1 table](img/file243.png)'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 10.9 – Selecting the Sheet 1 table
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, click on **Transform data**.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the **Transform** menu and then click on **Run Python Script**.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the script from the `02-distances-from-airports-in-power-bi-with-python.py`
    file from the `Chapter10\Python` folder into the Python script editor and click
    **OK**.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may be prompted to align the permissions in the Excel file with those you
    initially selected for the scripts (in our case, **Organizational**). In this
    case, you already know how to proceed based on what you’ve seen in *Chapter 5*,
    *Using Regular Expressions in Power BI*.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能会被提示将Excel文件中的权限与为脚本最初选择的权限（在我们的案例中，**组织**）对齐。在这种情况下，你根据在*第5章*中看到的，*在Power
    BI中使用正则表达式*，已经知道如何进行操作。
- en: We are only interested in the data in `dataset`. So, click on its **Table**
    value.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只对`dataset`中的数据感兴趣。因此，点击其**表**值。
- en: 'Power Query will transform your data by adding the distances from each hotel
    to the two airports, `JFK` and `LGA`, for the two methodologies of Haversines
    and Karney:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Power Query将通过添加Haversines和Karney两种方法计算每个酒店到两个机场（JFK和LGA）的距离来转换你的数据：
- en: '![Figure 10.10 – The result of the Python script transformation](img/file244.png)'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图10.10 – Python脚本转换的结果](img/file244.png)'
- en: Figure 10.10 – The result of the Python script transformation
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.10 – Python脚本转换的结果
- en: You can then click **Close & Apply** in the **Home** tab.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你可以在**主页**选项卡中点击**关闭并应用**。
- en: Great! You just enriched your data by adding the distances between two geographical
    points in Power BI using Python. Let’s see how to do that in R.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！你刚刚通过在Power BI中使用Python添加了两个地理点之间的距离，丰富了你的数据。让我们看看如何在R中做到这一点。
- en: Implementing distances using R
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用R实现距离
- en: The scenario will be the same as the one already described in the previous section.
    We will therefore enrich the data relating to some hotels in New York City with
    the distances separating them from the two major airports of New York, namely
    John F. Kennedy and LaGuardia.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 情景将与前一个章节中描述的相同。因此，我们将用将纽约市的一些酒店与纽约的两个主要机场——约翰·肯尼迪机场和拉瓜迪亚机场——之间的距离来丰富与这些酒店相关的数据。
- en: The files containing the data to be processed can be found in the `Chapter10`
    folder of the GitHub repository. In detail, you will find the hotels data in the
    `hotels-ny.xlsx` file and the airports data in the `airport-codes.csv` file.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理的数据文件可以在GitHub仓库的`Chapter10`文件夹中找到。具体来说，你将在`hotels-ny.xlsx`文件中找到酒店数据，在`airport-codes.csv`文件中找到机场数据。
- en: Calculating distances with R
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用R计算距离
- en: The R community is also fortunate to have a freely available package that implements
    spherical trigonometry functions for geographic applications. The package is called
    `geosphere` ([https://cran.r-project.org/web/packages/geosphere/](https://cran.r-project.org/web/packages/geosphere/))
    and, like the Python `PyGeodesy` package, it is inspired by the code that Chris
    Veness and Charles Karney have made publicly available.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: R社区也很幸运，有一个免费提供的包，该包实现了地理应用中的球面三角函数。这个包叫做`geosphere` ([https://cran.r-project.org/web/packages/geosphere/](https://cran.r-project.org/web/packages/geosphere/))，就像Python的`PyGeodesy`包一样，它受到了Chris
    Veness和Charles Karney公开提供的代码的启发。
- en: 'First, you need to install this new package:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要安装这个新包：
- en: Open RStudio and make sure it is referencing your latest CRAN R (version 4.0.2
    in our case).
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开RStudio并确保它引用的是你最新的CRAN R（在我们的案例中是版本4.0.2）。
- en: 'Click on the **Console** window and enter this command: `install.packages(‘geosphere’)`.
    Then, press *Enter*.'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**控制台**窗口，输入此命令：`install.packages('geosphere')`。然后，按*Enter*键。
- en: You are now ready to develop your code in R. Apart from the usual packages that
    allow you to read CSV and Excel files (`readr` and `readxl`) and facilitate data
    transformation operations (`dplyr` and `purrr`), you must, of course, load the
    package you just installed.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已准备好在R中编写代码。除了允许你读取CSV和Excel文件（`readr`和`readxl`）并简化数据转换操作（`dplyr`和`purrr`）的常用包之外，你当然必须加载你刚刚安装的包。
- en: 'You can easily import hotel data into the `hotels_tbl` tibble using the `read_xlsx()`
    function and airport data into the `airport_tbl` tibble using the `read_csv()`
    function. At this point, the first operation to do is to split the contents of
    the `coordinates` column of `airports_tbl` in the two new columns, `longitude`
    and `latitude`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`read_xlsx()`函数轻松地将酒店数据导入`hotels_tbl` tibble，使用`read_csv()`函数将机场数据导入`airport_tbl`
    tibble。在此阶段，要做的第一个操作是将`airports_tbl`中的`coordinates`列的内容拆分到两个新列，`longitude`和`latitude`：
- en: '[PRE8]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Note the simplicity of using the `separate` function from the `tidyr` package:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用`tidyr`包中的`separate`函数的简单性：
- en: The pipe passes the `airports_tbl` tibble as the first parameter for the function.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 管道将`airports_tbl` tibble作为函数的第一个参数传递。
- en: Declare the column to be split (`col = coordinates`).
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明要拆分的列（`col = coordinates`）。
- en: Declare the two new target columns (`into = c(‘longitude’, ‘latitude’)`).
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明两个新的目标列（`into = c('longitude', 'latitude')`）。
- en: Declare the separator found in the values of the column to be split (`sep =
    ‘, ‘`).
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明要拆分的列值中找到的分隔符（`sep = ', '`）。
- en: Remove the column to be split when the transformation is complete (`remove =
    TRUE`).
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转换完成后，删除要拆分的列（`remove = TRUE`）。
- en: Let the data type of the target columns convert automatically if they are numeric
    columns (`convert = TRUE`).
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果目标列是数值列，则自动转换数据类型（`convert = TRUE`）。
- en: All this in one operation with maximum clarity. That’s one of the reasons data
    analysts love R!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些操作都在一个操作中完成，并且非常清晰。这也是数据分析员喜欢R的原因之一！
- en: 'Again, we make use of a function to conveniently access the longitude and latitude
    values of a specific airport. It is the `airportLongLatVec()` function and it
    accepts as parameters both a dataframe containing the airport data with the `iata_code`,
    `latitude`, and `longitude` columns, and the specific **IATA code** of the airport
    of interest:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们使用一个函数来方便地访问特定机场的经纬度值。这个函数是`airportLongLatVec()`，它接受两个参数：一个包含机场数据的dataframe，其中包含`iata_code`、`latitude`和`longitude`列，以及感兴趣的机场的特定**IATA代码**：
- en: '[PRE9]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output is a named vector. So, the coordinates of the two airports can be
    easily found in this way:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是一个命名向量。因此，可以通过这种方式轻松找到两个机场的坐标：
- en: '[PRE10]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You are pretty much ready to transform the data. From the `geosphere` package,
    you will use the `distHaversine()` and `distGeo()` functions. The former is self-explanatory
    from the name itself. The `distGeo()` function calculates the shortest distance
    between two points on an ellipsoid according to Karney’s formulas. Both functions
    accept two pairs of coordinates (in the order longitude and latitude) in vector
    form. To get the same results as Python, the `distHaversine()` function must accept
    as a parameter the same mean radius of the Earth sphere model used by default
    by PyGeodesy. The radius in question is **R1** (mean radius) defined by the **International
    Union of Geodesy and Geophysics** (**IUGG**), which is 6,371,008.771415 meters.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你基本上已经准备好转换数据了。从`geosphere`包中，你将使用`distHaversine()`和`distGeo()`函数。前者的名称本身就说明了其功能。`distGeo()`函数根据Karney的公式计算椭球面上两点之间的最短距离。这两个函数都接受两对坐标（按经度和纬度的顺序）以向量形式。为了得到与Python相同的结果，`distHaversine()`函数必须接受与PyGeodesy默认使用的地球球面模型相同的平均半径作为参数。这个半径是**国际大地测量和地球物理学联合会**（**IUGG**）定义的**R1**（平均半径），其值为6,371,008.771415米。
- en: 'At this point, the enrichment operation of the `hotels_tbl` tibble can be done
    using the already seen family of `map()` functions of the `purrr` package. In
    the first step, we create a new column, `p1`, containing the longitude and latitude
    pairs in a vector using the `map2()` function. In the second step, we apply the
    `distHaversine()` and `distGeo()` functions to the newly created point, `p1`,
    and to the fixed points identifying the airports (`jfk_coordinates` and `lga_coordinates`)
    to create the new columns containing the distances. This is the code needed:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，可以使用`purrr`包中已经看到的`map()`函数族来对`hotels_tbl` tibble进行增强操作。在第一步中，我们创建一个新列`p1`，使用`map2()`函数包含经纬度对向量。在第二步中，我们将`distHaversine()`和`distGeo()`函数应用于新创建的点`p1`以及标识机场的固定点（`jfk_coordinates`和`lga_coordinates`），以创建包含距离的新列。这是所需的代码：
- en: '[PRE11]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Recall that the `map2()` function takes two vectors as input and runs them in
    parallel to pass their values to the function used after the `~` symbol (in our
    case, the `c()` function that declares a vector). The `map_dbl()` function instead
    takes as input the column `p1` (which contains the geographic coordinates in vector
    format of the hotels) and passes its elements to the function after the `~` (in
    our case, `distGeo()` with other fixed parameters) transforming the output into
    a vector of double numeric data types.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`map2()`函数接受两个向量作为输入，并将它们并行运行，将它们的值传递给`~`符号后面的函数（在我们的例子中是声明向量的`c()`函数）。而`map_dbl()`函数接受包含地理坐标（以向量格式）的列`p1`作为输入，并将它的元素传递给`~`后面的函数（在我们的例子中是带有其他固定参数的`distGeo()`），将输出转换为双精度数值数据类型的向量。
- en: 'If you run the code for the `01-distances-from-airports-in-r.R` file in the
    `R` folder, you’ll get something like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行`R`文件夹中`01-distances-from-airports-in-r.R`文件的代码，你会得到类似以下内容：
- en: '![Figure 10.11 – The enriched hotels tibble with distances](img/file245.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图10.11 – 包含距离的增强hotels tibble](img/file245.png)'
- en: Figure 10.11 – The enriched hotels tibble with distances
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11 – 增强后的包含距离的hotels tibble
- en: Wow! You were able to calculate both the Haversine and Karney distances between
    all hotels and both airports also using R. At this point, it is straightforward
    to use similar code to calculate distances in Power BI. Let’s see how to do it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！你能够使用 R 计算所有酒店和两个机场之间的 Haversine 和 Karney 距离。在这个阶段，使用类似的代码在 Power BI 中计算距离是直接的。让我们看看如何做。
- en: Calculating distances in Power BI with R
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 R 在 Power BI 中计算距离
- en: 'It’s time to implement what you’ve just learned in Power BI. So, launch Power
    BI Desktop and let’s get going:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候将你在 Power BI 中学到的知识付诸实践了。因此，启动 Power BI Desktop，让我们开始吧：
- en: Make sure Power BI Desktop is referencing your latest environment in **Options**.
    After that, click on **Excel** to import the `hotels-ny.xlsx` file, which you
    can find in the `Chapter10` folder. Select it and click **Open**.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保Power BI Desktop在**选项**中引用你的最新环境。之后，点击**Excel**导入`hotels-ny.xlsx`文件，该文件位于`Chapter10`文件夹中。选择它并点击**打开**。
- en: 'Select the **Sheet 1** table from the **Navigator** window:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**导航器**窗口中选择**Sheet 1**表：
- en: '![Figure 10.12 – Selecting the Sheet 1 table](img/file246.png)'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 10.12 – 选择 Sheet 1 表](img/file246.png)'
- en: Figure 10.12 – Selecting the Sheet 1 table
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.12 – 选择 Sheet 1 表
- en: Then, click on **Transform data**.
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，点击 **转换数据**。
- en: Click on the **Transform** menu and then click on **Run R Script**.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **转换** 菜单，然后点击 **运行 R 脚本**。
- en: Copy the script from the `02-distances-from-airports-in-power-bi-with-r.R` file
    from the `Chapter10\R` folder into the R script editor and click **OK**.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Chapter10\R`文件夹中的`02-distances-from-airports-in-power-bi-with-r.R`文件中的脚本复制到
    R 脚本编辑器中，然后点击**确定**。
- en: We are only interested in the data in `hotels_df`. So, click on its **Table**
    value.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只对 `hotels_df` 中的数据进行关注。因此，点击其 **表** 值。
- en: 'Power Query will transform your data by adding the distances from each hotel
    to the two airports, `JFK` and `LGA`, for the two methodologies of Haversines
    and Karney:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Power Query 将通过添加每个酒店到两个机场（`JFK` 和 `LGA`）的距离来转换你的数据，使用 Haversines 和 Karney 的两种方法：
- en: '![Figure 10.13 – The result of the Python script transformation](img/file247.png)'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 10.13 – Python 脚本转换的结果](img/file247.png)'
- en: Figure 10.13 – The result of the Python script transformation
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.13 – Python 脚本转换的结果
- en: You can then click **Close & Apply** in the **Home** tab.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以点击 **关闭并应用** 在 **主页** 选项卡。
- en: Great! You just enriched your data by adding distances between two geographical
    points in Power BI using R.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！你刚刚通过在 Power BI 中使用 R 添加两个地理点之间的距离来丰富了你的数据。
- en: In the next section, you will see how to enrich your dataset using linear optimization
    algorithms.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将看到如何使用线性优化算法丰富你的数据集。
- en: The basics of linear programming
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线性规划的基础
- en: '**Linear Programming** (**LP**) **algorithms** are adopted in all those areas
    where optimization, and therefore the economy of resources, is critical to the
    continuation of activities. In order to understand what this is all about, you
    need some math. In this way, let’s brush up on some of the geometric concepts
    we encountered during our youthful studies.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性规划**（**LP**）**算法**被应用于所有那些优化和因此资源经济对于活动持续至关重要的领域。为了理解这一切，你需要一些数学知识。这样，让我们回顾一下我们在年轻时学习过程中遇到的几何概念。'
- en: Linear equations and inequalities
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线性方程和不等式
- en: 'We all at least once in our lives have encountered the term linear equation.
    A **linear equation**, in its simplest sense, consists of a mathematical relationship
    between two variables, *x* and *y*, in the form *ax + by + c = 0*, which on the
    Cartesian plane identifies a **straight line**:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在生活中至少遇到过一次线性方程这个术语。在 simplest sense 中，**线性方程**由两个变量 *x* 和 *y* 之间的数学关系组成，形式为
    *ax + by + c = 0*，在笛卡尔平面上标识一条 **直线**：
- en: '![Figure 10.14 – Representation of the linear equation 2x + y = 2](img/file248.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.14 – 线性方程 2x + y = 2 的表示](img/file248.png)'
- en: Figure 10.14 – Representation of the linear equation 2x + y = 2
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.14 – 线性方程 2x + y = 2 的表示
- en: 'Evidently, the variables involved in a linear equation can be more than two.
    The representation of a linear equation is possible as long as we have three variables
    (the famous three dimensions we can see). In this case, a linear equation of three
    variables, in the form *ax + by + cz + d = 0*, represents a **plane** in the space:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，线性方程中涉及的变量可以超过两个。只要我们有三个变量（我们能够看到的著名的三维），线性方程的表示就是可能的。在这种情况下，形式为 *ax + by
    + cz + d = 0* 的三个变量的线性方程表示空间中的一个 **平面**：
- en: '![Figure 10.15 – Representation of a generic linear equation ax + by + cz +
    d = 0](img/file249.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.15 – 通用线性方程 ax + by + cz + d = 0 的表示](img/file249.png)'
- en: Figure 10.15 – Representation of a generic linear equation ax + by + cz + d
    = 0
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.15 – 通用线性方程 ax + by + cz + d = 0 的表示
- en: When you have more than three variables in a linear equation, we commonly call
    its representation no longer a plane, but a **hyperplane**.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当线性方程中有超过三个变量时，我们通常称其表示不再是平面，而是一个**超平面**。
- en: 'There are also **linear inequalities**, which are linear functions involving
    inequalities (identified by the symbols `<`, `>`, `≤`, and `≥`). Just as done
    for linear equations, in the same way, you can plot linear inequalities, either
    with two variables or with three. They represent all points on either side of
    the line in the case of two variables (that is, a region of the plane), or points
    on either side of the straight plane in the case of three variables (that is,
    a volume):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 还有**线性不等式**，它们是涉及不等式的线性函数（由符号 `<`、`>`、`≤` 和 `≥` 标识）。就像线性方程一样，同样地，你可以用两个变量或三个变量来绘制线性不等式。在两个变量的情况下，它们表示线的一侧的所有点（即平面的一个区域），在三个变量的情况下，它们表示直平面的两侧的点（即一个体积）：
- en: '![Figure 10.16 – Representation of generic linear inequalities with two or
    three variables](img/file250.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.16 – 两个或三个变量的通用线性不等式的表示](img/file250.png)'
- en: Figure 10.16 – Representation of generic linear inequalities with two or three
    variables
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.16 – 两个或三个变量的通用线性不等式的表示
- en: Observe that the regions identified by the inequalities are infinite but have
    an edge constituted by the linear equation that derives from the same inequality
    considering the `=` sign instead of the inequality sign.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到由不等式确定的区域是无限的，但有一个边缘是由来自相同不等式的线性方程构成的，考虑的是 `=` 符号而不是不等式符号。
- en: Well, very often when you think about these concepts, you just associate them
    with theoretical mathematical stuff, but that’s not the case. Simple concepts
    related to transportation, manufacturing, shipping, and so on can be traced back
    to linear equations or inequalities. Let’s see an example.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，当你思考这些概念时，你通常会联想到它们与理论数学相关，但事实并非如此。与运输、制造、运输等相关的一些简单概念可以追溯到线性方程或不等式。让我们看看一个例子。
- en: Formulating a linear optimization problem
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 公式化线性优化问题
- en: 'Imagine you work in a manufacturing company and you need to produce two products,
    P1 and P2\. To produce them, you need a machine. Specifically, producing one unit
    of product P1 takes 30 minutes of processing time on the machine, while producing
    one unit of product P2 takes 25 minutes on the same machine. In addition, the
    number of hours for which the machine, M, can remain on is 40 hours (= 40*60 minutes).
    That is, 30 minutes multiplied by the number of P1 products added to 25 minutes
    multiplied by the number of P2 products cannot exceed 40 hours of processing time.
    So, given *x* number of products P1 and *y* number of products P2 produced at
    the end of processing, the machine hours **constraint** can be summarized as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你在一个制造公司工作，需要生产两种产品，P1 和 P2。为了生产它们，你需要一台机器。具体来说，生产一个单位的 P1 产品需要机器上 30 分钟的加工时间，而生产一个单位的
    P2 产品需要同样的机器上 25 分钟。此外，机器 M 可以连续运行的小时数是 40 小时（= 40*60 分钟）。也就是说，30 分钟乘以 P1 产品数量的总和加上
    25 分钟乘以 P2 产品数量的总和不能超过 40 小时的加工时间。因此，在加工结束时，生产 *x* 个 P1 产品和 *y* 个 P2 产品的机器小时 **约束**可以总结如下：
- en: Wow! You just used a simple linear inequality to describe a constraint on a
    manufacturing process.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！你刚刚使用了一个简单的线性不等式来描述一个制造过程的约束。
- en: 'Now imagine that you have received demands for P1 and P2 products from customers.
    Specifically, adding up all the requests, you need to produce at least 45 units
    of P1 and 25 units of P2 to satisfy your customers. These demand constraints can
    be summarized as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，你已经收到了客户对 P1 和 P2 产品的需求。具体来说，将所有请求加起来，你需要至少生产 45 个单位的 P1 和 25 个单位的 P2
    来满足你的客户。这些需求约束可以总结如下：
- en: 'Awesome! You’ve added two more linear constraints to your problem. If you add
    a goal to these business constraints, for example, you want to maximize the total
    number, *z*, of units of P1 and P2, the set of constraints and goal constitute
    a linear optimization problem:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！你已经为你的问题添加了两个更多的线性约束。如果你给这些业务约束添加一个目标，例如，你想要最大化 P1 和 P2 的总单位数 *z*，那么约束集和目标就构成了一个线性优化问题：
- en: Simple as that, right? If we want to be a little more formal, LP (also called
    **linear optimization**) consists of a set of techniques useful for solving systems
    of linear equations and inequalities with the goal of maximizing or minimizing
    a linear objective function. In particular, the variables *x* and *y* are called
    **decision variables** and the objective that is set is called the **objective
    function** or **cost function**. In this example, the business case required only
    inequality constraints, but there can also be equality constraints.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，对吧？如果我们想更正式一点，线性规划（也称为**线性优化**）包括一套用于解决线性方程组和不等式系统的技术，目的是最大化或最小化线性目标函数。特别是，变量*x*和*y*被称为**决策变量**，设定的目标被称为**目标函数**或**成本函数**。在这个例子中，业务案例只需要不等式约束，但也可能有等式约束。
- en: Cool! But now that we’ve set up the problem from a mathematical standpoint,
    how do we solve it? First, we need to take all the inequalities and represent
    them on the axes (in this case you can, because they only contain two variables).
    As seen at the beginning, a linear inequality represents a portion of a plane
    bounded by the straight line considering the sign of equality in the inequality
    itself. Intersecting all these planes, we come to identify an area common to all
    the inequalities, called the **feasible region**. Basically, all points that are
    in this region satisfy all the constraints identified by the inequalities.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！但是，我们现在已经从数学角度设定了问题，那么我们该如何解决它呢？首先，我们需要将所有不等式表示在轴上（在这种情况下可以，因为它们只包含两个变量）。如开头所见，线性不等式表示一个平面的一部分，这部分由直线界定，考虑不等式本身的等号符号。相交所有这些平面，我们就能确定一个所有不等式共有的区域，称为**可行区域**。基本上，所有在这个区域内的点都满足由不等式确定的约束。
- en: 'If you want to draw the feasible region associated with the constraints of
    the example we have just illustrated, there is no need to go over all the geometry
    studied in secondary school, but just use **WolframAlpha** ([https://www.wolframalpha.com/](https://www.wolframalpha.com/)).
    Enter the following string in the search engine: `plot 30x+25y<=2400 and x>=45
    and y>=25`. All constraints must be satisfied simultaneously, hence the use of
    the `and` operator. Press *Enter* and you will see this result:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想绘制与我们所展示的示例约束相关的可行区域，无需复习所有在中学学习的几何知识，只需使用**WolframAlpha** ([https://www.wolframalpha.com/](https://www.wolframalpha.com/))即可。在搜索引擎中输入以下字符串：`plot
    30x+25y<=2400 and x>=45 and y>=25`。所有约束必须同时满足，因此使用了`and`运算符。按下*Enter*键，你将看到以下结果：
- en: '![Figure 10.17 – The feasible region drawn by WolframAlpha](img/file251.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图10.17 – WolframAlpha绘制的可行区域](img/file251.png)'
- en: Figure 10.17 – The feasible region drawn by WolframAlpha
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.17 – WolframAlpha绘制的可行区域
- en: To the WolframAlpha result, we have added the values of the vertices of the
    feasible region, which is a triangle.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在WolframAlpha的结果中添加了可行区域顶点的值，这是一个三角形。
- en: '**Important Note**'
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: ''
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It is shown that if the optimization problem is solvable, the solution that
    maximizes or minimizes the objective function lies precisely at one of the vertices
    of the feasible region.
  id: totrans-197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 已证明，如果优化问题是可解的，那么最大化或最小化目标函数的解恰好位于可行区域的某个顶点上。
- en: 'As you can see in *Figure 10.17*, the *x* value of vertex C is `59.1`. Clearly,
    it is not possible to have a fractional part of the product P1 since it is not
    possible to produce only a fraction of one unit. The nearest integer value should
    then be considered, which is 59\. If, therefore, the business problem imposes
    to have **integer values** for the decision variables, then the problem becomes
    one of **Mixed-Integer Linear Programming** (**MILP**). In our case, then, we
    consider vertices *A*, *B*, and *C**=(59,25) as possible solutions to our problem
    and substitute their coordinates into the objective function, *z = x + y*:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在*图10.17*中看到的，顶点C的*x*值为`59.1`。显然，由于无法只生产一个单位的分数部分，因此不可能有分数部分的产品P1。因此，应该考虑最近的整数值，即59。如果业务问题要求决策变量必须为**整数**，那么问题就变成了**混合整数线性规划**（**MILP**）的问题。因此，在我们的例子中，我们考虑顶点*A*、*B*和*C**=(59,25)作为我们问题的可能解，并将它们的坐标代入目标函数*z
    = x + y*：
- en: '*A*: *z = 45 + 25 = 70*'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*A*：*z = 45 + 25 = 70*'
- en: '*B*: *z = 45 + 42 = 87*'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*B*：*z = 45 + 42 = 87*'
- en: '*C**: *z = 59 + 25 = 84*'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C*：*z = 59 + 25 = 84*'
- en: We infer that the solution to our problem is given by the vertex *B* with a
    maximum value of 87 units, namely *P1 = 45* and *P2 = 42*.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们推断出我们问题的解是顶点*B*，最大值为87单位，即*P1 = 45*和*P2 = 42*。
- en: '**Note**'
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意**'
- en: ''
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In summary, producing 45 units of product P1 and 42 units of product P2 satisfies
    the machine’s hourly production constraint and the customer demand constraints,
    while maximizing total production.
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 总结来说，生产45个产品P1和42个产品P2满足机器的每小时生产约束和客户需求约束，同时最大化总生产量。
- en: Did you ever think you could solve a linear optimization problem before today?
    Well, you’ve done it! Clearly, it is possible to solve these problems by hand
    when they are this simple. But when the number of decision variables grows, it
    is no longer possible to draw the feasible region and therefore it becomes impossible
    to locate the vertices in a multidimensional space by eye. In these cases, it
    is mathematics and, above all, the packages made available by the community for
    Python and R that allow us to find the solution to the problem. Let’s first look
    at a slightly more complex case of an LP problem.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你以前想过你今天之前能解决一个线性优化问题吗？好吧，你已经做到了！显然，当这些问题如此简单时，用手解决这些问题是可能的。但是当决策变量的数量增加时，就不再可能绘制可行区域，因此也就无法通过肉眼在多维空间中定位顶点。在这些情况下，是数学，尤其是社区为Python和R提供的包，使我们能够找到问题的解决方案。让我们首先看看一个稍微复杂一点的线性规划问题案例。
- en: Definition of the LP problem to solve
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 要解决的线性规划问题的定义
- en: 'Now imagine that you are working for a company that needs to ship a product
    from different warehouses around the world to different countries. You have to
    hand the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，你正在为一家公司工作，该公司需要从全球不同仓库向不同国家运输产品。你必须提供以下内容：
- en: 'The quantities of product available in warehouses:'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仓库中可用的产品数量：
- en: '![Figure 10.18 – Quantities of product available in warehouses](img/file252.png)'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图10.18 – 仓库中可用的产品数量](img/file252.png)'
- en: Figure 10.18 – Quantities of product available in warehouses
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.18 – 仓库中可用的产品数量
- en: 'The quantities of product required by countries:'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 国家所需的产品数量：
- en: '![Figure 10.19 – Quantities of product required by countries](img/file253.png)'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图10.19 – 国家所需的产品数量](img/file253.png)'
- en: Figure 10.19 – Quantities of product required by countries
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.19 – 国家所需的产品数量
- en: 'The shipping costs from each of the warehouses to all requesting countries:'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从每个仓库到所有请求国家的运输成本：
- en: '![Figure 10.20 – Costs from warehouses to countries](img/file254.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图10.20 – 从仓库到国家的成本](img/file254.png)'
- en: Figure 10.20 – Costs from warehouses to countries
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.20 – 从仓库到国家的成本
- en: Your goal is to minimize your company’s costs by meeting all customer demands
    from different countries.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你的目标是通过满足来自不同国家的所有客户需求来最小化你公司的成本。
- en: Formulating the LP problem
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表述线性规划问题
- en: 'As seen in the previous section, you must first formulate the problem mathematically.
    Let’s use a couple of numerical indexes, *i* and *j*, to identify the quantities
    sent and costs. In detail, consider the quantity *x[ij]* of product that is shipped
    from *Warehouse i* to *Country j* according to this matrix that defines the decision
    variables and costs:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你必须首先用数学方法表述问题。让我们使用几个数值索引，*i* 和 *j*，来识别发送的数量和成本。具体来说，考虑从 *Warehouse i*
    发送到 *Country j* 的产品数量 *x[ij]*，根据这个定义决策变量和成本的矩阵：
- en: '![Figure 10.21 – Definition matrix of the quantity of products sent and costs](img/file255.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图10.21 – 发送产品和成本的数量定义矩阵](img/file255.png)'
- en: Figure 10.21 – Definition matrix of the quantity of products sent and costs
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.21 – 发送产品和成本的数量定义矩阵
- en: The quantity *x[ij]* is an integer and non-negative ().
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 量 *x[ij]* 是一个整数且非负（）。
- en: 'Given the preceding definitions, the target of the problem is to minimize the
    objective function, which can be written as the sum of the product between the
    cost of shipping from *Warehouse i* to *Country j* (*Cij*) and the quantity of
    product shipped from *Warehouse i* to *Country j* (*xij*):'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的定义，问题的目标是使目标函数最小化，该函数可以写成从 *Warehouse i* 到 *Country j* 的运输成本 (*Cij*) 与从
    *Warehouse i* 到 *Country j* 发送的产品数量 (*xij*) 之间的乘积之和：
- en: 'Written in full and organizing it by warehouses for reading convenience, taking
    the cost amounts from *Figure 10.21*, the previous objective function can be rewritten
    as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 将其完整写出，并按仓库组织以方便阅读，从 *图10.21* 中的成本金额来看，前面的目标函数可以重写如下：
- en: 'To this point, you must formalize the constraints, which are of two types:
    the *warehouse supply constraints* and the *customer demand constraints*:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你必须正式化约束条件，它们有两种类型：*仓库供应约束*和*客户需求约束*：
- en: '**Warehouse supply constraints**: Once a warehouse has been fixed (for example,
    the *Warehouse ITA*, for which *i = 1*), the sum of the products shipped from
    that warehouse to all countries (sum of *x[1j]*) cannot exceed the maximum quantity
    of products contained in that warehouse (for *Warehouse ITA*, 50,000 products;
    see *Figure 10.18*). That is, for all six countries, we have the following:You
    will, therefore, have a similar constraint for each warehouse (four constraints
    in all).'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仓库供应约束**：一旦确定了仓库（例如，*Warehouse ITA*，其中 *i = 1*），从这个仓库向所有国家（*x[1j]*的总和）发送的产品总和不能超过该仓库包含的产品最大数量（对于*Warehouse
    ITA*，50,000个产品；见 *图10.18*）。也就是说，对于所有六个国家，我们有以下结果：因此，您将为每个仓库有一个类似的约束（总共四个约束）。'
- en: '**Customer demand constraints**: Regardless of which warehouse the goods come
    from, you have to meet the demand for each country’s products. Therefore, the
    sum of the products sent from all the warehouses toward a given country (for example,
    *France*, for which *j = 2*) must be at least equal to the demand of that country
    (France demands at least 15,000 products; see *Figure 10.19*). And, therefore,
    considering all four warehouses, we have the following:You will, therefore, have
    a similar constraint for each country (six constraints in all).'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户需求约束**：无论货物来自哪个仓库，您都必须满足每个国家产品的需求。因此，从所有仓库向给定国家（例如，*法国*，其中 *j = 2*）发送的产品总和必须至少等于该国家的需求（法国至少需要15,000个产品；见
    *图10.19*）。因此，考虑到所有四个仓库，我们得到以下结果：因此，您将为每个国家有一个类似的约束（总共六个约束）。'
- en: 'Therefore, the final linear optimization problem can be formulated as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最终的线性优化问题可以表述如下：
- en: Awesome! You managed to formulate a non-trivial business problem in mathematical
    terms. Let’s now see how to solve it with Python.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！您成功地用数学术语表述了一个非平凡的业务问题。现在让我们看看如何用Python来解决它。
- en: Handling optimization problems with Python
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Python处理优化问题
- en: As you’ve probably already figured out, the large community that develops Python
    packages never stands still. Even in this case, it provided a module that helps
    us solve linear optimization problems. Its name is **PuLP** ([https://github.com/coin-or/pulp](https://github.com/coin-or/pulp))
    and it is an LP modeler written in Python. It interfaces with the most common
    free and not-free engines that solve LP, **Mixed Integer Programming** (**MIP**),
    and other related problems, such as **GNU Linear Programming Kit** (**GLPK**),
    **Coin-or Branch and Cut** (**CBC**), which is the default one, and **IBM ILOG
    CPLEX**. Its use is quite straightforward. Let’s put it into practice right away
    with the problem from the previous section.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经猜到的，开发Python包的大型社区永远不会停滞不前。在这种情况下，它提供了一个帮助我们解决线性优化问题的模块。它的名字是**PuLP**
    ([https://github.com/coin-or/pulp](https://github.com/coin-or/pulp))，它是一个用Python编写的LP模型器。它与解决LP、**混合整数规划**（**MIP**）和其他相关问题的最常见免费和非免费引擎进行接口，例如**GNU线性规划工具包**（**GLPK**）、**Coin-or分支和剪枝**（**CBC**），这是默认的，以及**IBM
    ILOG CPLEX**。它的使用非常直接。让我们立即用上一节的问题来实践一下。
- en: Solving the LP problem in Python
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Python中解决LP问题
- en: The code that will be explained to you in this section can be found in the `03-linear-optimizaiont-in-python.py`
    file in the `Chapter10\Python` folder of the repository.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将解释的代码可以在存储库的`Chapter10\Python`文件夹中的`03-linear-optimizaiont-in-python.py`文件中找到。
- en: 'First, you have to install the `PuLP` module in your environment:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您必须在您的环境中安装`PuLP`模块：
- en: Open Anaconda Prompt.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Anaconda Prompt。
- en: Enter the `conda activate pbi_powerquery_env` command.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`conda activate pbi_powerquery_env`命令。
- en: Enter the `pip install pulp` command.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`pip install pulp`命令。
- en: 'After that, you can then define the values that will make up the constraints
    and costs using NumPy vectors and matrices:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您可以使用NumPy向量和矩阵定义将构成约束和成本的值：
- en: '[PRE12]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the script file, you will also find the code to import the values directly
    from the `RetailData.xlsx` file in the `Chapter10` folder.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本文件中，您还会找到直接从`Chapter10`文件夹中的`RetailData.xlsx`文件导入值的代码。
- en: 'It is possible then to define an `LpProblem` object, giving it a name and the
    type of optimization you want to apply to the objective function (minimize or
    maximize):'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以定义一个`LpProblem`对象，给它一个名称，并指定要应用于目标函数的优化类型（最小化或最大化）：
- en: '[PRE13]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To this empty object, you can add an objective function and constraints later.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以稍后向这个空对象添加目标函数和约束。
- en: 'In order to construct the objective function, we must first define the decision
    variables (*x[ij]*) via the `LpVariable` function, which accepts the variable
    name, the full list of strings representing the variable indices, the category
    of the variable (continuous, integer, or binary), and any upper- or lower-bound
    values. The index list is simply constructed with a nested **list comprehension**
    ([http://bit.ly/nested-list-comprehensions](http://bit.ly/nested-list-comprehensions)):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建目标函数，我们首先必须通过`LpVariable`函数定义决策变量(*x[ij]*)，该函数接受变量名称、表示变量索引的字符串完整列表、变量的类别（连续、整数或二进制）以及任何上界或下界值。索引列表只是通过嵌套**列表推导**([http://bit.ly/nested-list-comprehensions](http://bit.ly/nested-list-comprehensions))构建的：
- en: '[PRE14]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is the output as an example:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例输出：
- en: '[PRE15]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It is now possible to easily define the decision variables as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以轻松地定义决策变量如下：
- en: '[PRE16]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Since the decision variables are to be multiplied by the *C[ij]* costs defined
    earlier in `cost_matrix`, it is appropriate to format the `decision_vars` list
    in the same shape as the cost matrix in order to be able to perform element-wise
    multiplication, also known as the **Hadamard product**:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 由于决策变量需要乘以之前在`cost_matrix`中定义的*C[ij]*成本，因此将`decision_vars`列表格式化为与成本矩阵相同的形状，以便能够执行元素级乘法，也称为**Hadamard乘积**：
- en: '[PRE17]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It returns the following output:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回以下输出：
- en: '[PRE18]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The objective function is then defined as the sum of the element-wise product
    of cost and shipping matrices:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 目标函数随后定义为成本矩阵和运输矩阵元素级乘积的总和：
- en: '[PRE19]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output is the following one:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE20]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you remember correctly, this expression coincides with the objective function
    written in full that you saw in the previous section.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得正确，这个表达式与你在上一节中看到的完整目标函数是一致的。
- en: 'You can then add the objective function to the model, as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以将目标函数添加到模型中，如下所示：
- en: '[PRE21]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Constraint inequalities are also added in the same way:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 约束不等式也是以相同的方式添加的：
- en: '[PRE22]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, we can move on to solving the problem by running this simple script:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过运行这个简单的脚本来解决问题：
- en: '[PRE23]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The first thing to do is to check the state of the solution, which can take
    the values `Optimal`, `Not Solved`, `Infeasible`, `Unbounded`, and `Undefined`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的事情是检查解的状态，它可以取`Optimal`、`Not Solved`、`Infeasible`、`Unbounded`和`Undefined`等值：
- en: '[PRE24]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In our case, the state is `Optimal`, therefore an optimal solution has been
    found for the problem. So, let’s see what value the objective function takes on
    against the solution found:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，状态是`Optimal`，因此已经找到了问题的最优解。那么，让我们看看目标函数在找到的解上的值：
- en: '[PRE25]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The value is equal to 2,270,000 euros, which corresponds to the lowest possible
    cost while satisfying all imposed constraints. If you want to see the solution
    values of the variables that make up the shipping matrix in a very readable way,
    you’d better transform them into a pandas dataframe:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 该值等于2,270,000欧元，这对应于满足所有施加约束条件下的最低可能成本。如果你想以非常可读的方式查看组成运输矩阵的变量的解值，你最好将它们转换成pandas数据框：
- en: '[PRE26]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The result that comes up is as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 出现的结果如下：
- en: '![Figure 10.22 – Quantities shipped according to the solution found](img/file256.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![图10.22 – 根据找到的解决方案发送的数量](img/file256.png)'
- en: Figure 10.22 – Quantities shipped according to the solution found
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.22 – 根据找到的解决方案发送的数量
- en: It is easy to read, for example, that French customers must receive 10,000 units
    from the German warehouse and 5,000 units from the US warehouse to meet their
    demand.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，很容易看出，法国客户必须从德国仓库接收10,000个单位，从美国仓库接收5,000个单位以满足他们的需求。
- en: 'If instead you want to check the total quantities shipped from each warehouse,
    you can run this code:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要检查每个仓库发送的总数量，你可以运行以下代码：
- en: '[PRE27]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You will get this result:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下结果：
- en: '![Figure 10.23 – Total quantities shipped from each warehouse](img/file257.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![图10.23 – 从每个仓库发送的总数量](img/file257.png)'
- en: Figure 10.23 – Total quantities shipped from each warehouse
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.23 – 从每个仓库发送的总数量
- en: Impressive! You’ve managed to solve a non-simple linear optimization problem
    with just a few lines of Python code. Would you have guessed it? Let’s now look
    at how to apply what you learned in Power BI.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！你只用几行Python代码就解决了非简单线性优化问题。你能猜到吗？现在让我们看看如何将你在Power BI中学到的知识应用到实践中。
- en: Solving the LP problem in Power BI with Python
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Python在Power BI中解决LP问题
- en: 'Applying what we have just seen in Power BI is not as straightforward as in
    the other cases we have encountered in the last few chapters. To start, we have
    to have already loaded the data of country demand, warehouse supply, and shipping
    costs in the data model, which could arrive from any data source. In our case,
    we have them ready in Excel, so we will proceed to load them in Power BI Desktop:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Power BI 中应用我们刚刚看到的方法并不像在上一章中遇到的其它情况那样直接。首先，我们必须已经在数据模型中加载了国家需求、仓库供应和运输成本的数据，这些数据可能来自任何数据源。在我们的案例中，它们已经在
    Excel 中准备好了，所以我们将继续在 Power BI Desktop 中加载它们：
- en: Click **Excel Workbook** on the ribbon (or **Import data from Excel** in the
    main canvas), select the `RetailData.xlsx` file in the `Chapter10` folder, and
    click **Open**.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击功能区上的**Excel 工作簿**（或在主画布上的**从 Excel 导入数据**），在 `Chapter10` 文件夹中选择 `RetailData.xlsx`
    文件，然后点击**打开**。
- en: 'Select the **CountryDemand**, **ShippingCost**, and **WarehouseSupply** tables
    (the ones with the blue header) and then click **Transform data**:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**CountryDemand**、**ShippingCost**和**WarehouseSupply**表（带有蓝色标题的表），然后点击**转换数据**：
- en: '![Figure 10.24 – Selecting the three tables from Excel](img/file258.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.24 – 从 Excel 选择三个表](img/file258.png)'
- en: Figure 10.24 – Selecting the three tables from Excel
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.24 – 从 Excel 选择三个表
- en: 'You are now in the situation described previously. At this point, each of the
    three queries in Power Query has its own stack of steps that generated it:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你处于之前描述的情况。在此阶段，Power Query 中的每个查询都有自己的步骤堆栈，这些步骤生成了它：
- en: '![Figure 10.25 – The CountryDemand query with its stack of applied steps](img/file259.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.25 – 带有其应用步骤堆栈的 CountryDemand 查询](img/file259.png)'
- en: Figure 10.25 – The CountryDemand query with its stack of applied steps
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.25 – 带有其应用步骤堆栈的 CountryDemand 查询
- en: 'In the previous section, you saw that in order to calculate the optimal allocations,
    *you need to be able to use all three datasets in one Python script*. If you add
    a Python script as a step in one of the three queries listed previously, you can
    only interact with the data from that single query in the script. How can you
    then create a script that can use all the data available? You have to resort to
    the following stratagem:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你看到为了计算最优分配，*你需要能够在单个 Python 脚本中使用所有三个数据集*。如果你将 Python 脚本作为之前列出的三个查询之一中的步骤添加，你只能在脚本中与该单个查询的数据进行交互。那么你如何创建一个可以使用所有可用数据的脚本呢？你必须求助于以下策略：
- en: In order to use data belonging to more than one query in a Python script, you
    must first serialize each data structure derived from each of the three queries
    into a pickle file. Then, create a new query resulting from the merge of the three
    queries via joins (it is not necessary that the dataset resulting from the joins
    makes sense, since it will not be used). At this point, add a Python script step
    for this merge query, in which you deserialize all three previously serialized
    objects in each query. You will finally have the objects from three different
    data sources in one script.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 Python 脚本中使用属于多个查询的数据，你必须首先将每个查询导出的每个数据结构序列化到一个 pickle 文件中。然后，通过连接创建一个新的查询，该查询由三个查询合并而成（连接后的数据集是否有意义并不重要，因为它将不会被使用）。此时，为这个合并查询添加一个
    Python 脚本步骤，在这个步骤中反序列化每个查询中之前序列化的所有三个对象。你最终将在一个脚本中拥有来自三个不同数据源的对象。
- en: This way, you make sure that the Python scripts that serialize the objects of
    the three datasets are executed first, and then the script that deserializes them
    is executed in order to solve the linear optimization problem.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你可以确保首先执行序列化三个数据集对象的 Python 脚本，然后按照顺序执行反序列化脚本来解决线性优化问题。
- en: 'Let’s see in detail how to accomplish what is described in the previous paragraphs:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看如何完成上一段中描述的任务：
- en: Select the **CountryDemand** query on the left, click on the **Transform** tab
    on the ribbon, and then click on **Run Python Script**.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧选择**CountryDemand**查询，点击功能区上的**转换**选项卡，然后点击**运行 Python 脚本**。
- en: 'Enter the following Python code in the script editor, then click **OK**:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本编辑器中输入以下 Python 代码，然后点击**确定**：
- en: '[PRE28]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Click on **Table** under **Value** corresponding to **dataset**. You will always
    see the country demand data, but behind the scenes, a NumPy vector has been serialized
    with the name `country_demands.pkl` in the `Chapter10/Python` folder.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**值**下对应的**数据集**的**表**。你将始终看到国家需求数据，但在幕后，一个名为 `country_demands.pkl` 的 NumPy
    向量已经被序列化，存储在 `Chapter10/Python` 文件夹中。
- en: Select the **ShippingCost** query on the left, click on the **Transform** tab
    on the ribbon, and then click on **Run Python Script**.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧选择**ShippingCost**查询，点击功能区上的**转换**选项卡，然后点击**运行Python脚本**。
- en: 'Enter the following Python code in the script editor, then click **OK**:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本编辑器中输入以下Python代码，然后点击**确定**：
- en: '[PRE29]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Click on **Table** under **Value** corresponding to **dataset**. You will always
    see the cost matrix data, but behind the scenes, a NumPy vector has been serialized
    with the name `cost_matrix.pkl` in the `Chapter10/Python` folder.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**值**下对应的**dataset**的**表**。你将始终看到成本矩阵数据，但幕后，一个名为`cost_matrix.pkl`的NumPy向量已在`Chapter10/Python`文件夹中序列化。
- en: Select the **WarehouseSupply** query on the left, click on the **Transform**
    tab on the ribbon, and then click on **Run Python Script**.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧选择**WarehouseSupply**查询，点击功能区上的**转换**选项卡，然后点击**运行Python脚本**。
- en: 'Enter the following Python code in the script editor, then click **OK**:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本编辑器中输入以下Python代码，然后点击**确定**：
- en: '[PRE30]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Click on **Table** under **Value** corresponding to **dataset**. You will always
    see the warehouse supply data, but behind the scenes, a NumPy vector has been
    serialized with the name `warehouse_supply.pkl` in the `Chapter10/Python` folder.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**值**下对应的**dataset**的**表**。你将始终看到仓库供应数据，但幕后，一个名为`warehouse_supply.pkl`的NumPy向量已在`Chapter10/Python`文件夹中序列化。
- en: Right-click on the query panel on the left, select **New Query**, then **Combine**,
    then **Merge Queries as New**.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧的查询面板上右键单击，选择**新建查询**，然后选择**组合**，然后选择**合并查询为新**。
- en: On the **Merge** window, select the **CountryDemand** and **ShippingCost** tables,
    click on the `country_name` column for both of them, and click **OK**.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**合并**窗口中，选择**CountryDemand**和**ShippingCost**表，点击两个表中的`country_name`列，然后点击**确定**。
- en: The new **Merge1** query will appear. Click on it, expand the content of the
    **ShippingCost** column, and click **OK**.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将出现新的**Merge1**查询。点击它，展开**ShippingCost**列的内容，然后点击**确定**。
- en: 'Go to the **Home** tab, make sure that the **Merge1** query is selected, and
    click on **Merge Queries** in order to also merge **WarehouseSupply** too:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到**主页**选项卡，确保已选择**Merge1**查询，然后点击**合并查询**以合并**WarehouseSupply**：
- en: '![Figure 10.26 – Merging another query to Merge1](img/file260.png)'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图10.26 – 将另一个查询合并到Merge1](img/file260.png)'
- en: Figure 10.26 – Merging another query to Merge1
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.26 – 将另一个查询合并到Merge1
- en: Select the **WarehouseSupply** table on the **Merge** window and click the `ShippingCost.warehouse_name`
    and `warehouse_name` columns on both of the tables, then click **OK**.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**合并**窗口上选择**WarehouseSupply**表，然后点击两个表中的`ShippingCost.warehouse_name`和`warehouse_name`列，然后点击**确定**。
- en: Expand the **WarehouseSupply** column, keep all selected, and click **OK**.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开**WarehouseSupply**列，保留所有选中项，然后点击**确定**。
- en: Click on the **Transform** tab on the ribbon, click on **Run Python Script**,
    and enter the script you can find into the `04-linear-optimization-in-power-bi-with-python.py`
    file in the `Chapter10\Python` folder.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击功能区上的**转换**选项卡，点击**运行Python脚本**，并将脚本输入到`Chapter10\Python`文件夹中的`04-linear-optimization-in-power-bi-with-python.py`文件中。
- en: 'You will get the following error: **Formula.Firewall: Query ‘Merge1’ (step
    ‘Run Python script’) references other queries or steps, so it may not directly
    access a data source. Please rebuild this data combination**.'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '你将得到以下错误：**Formula.Firewall: 查询‘Merge1’（步骤‘Run Python script’）引用了其他查询或步骤，因此它可能无法直接访问数据源。请重新构建此数据组合**。'
- en: 'Go to **File** and click **Options and settings** and then **Options**. On
    the **Options** window, select the **Privacy** tab and click on **Always ignore
    Privacy Level settings**:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**文件**，点击**选项和设置**，然后点击**选项**。在**选项**窗口中，选择**隐私**选项卡，然后点击**始终忽略隐私级别设置**：
- en: '![Figure 10.27 – Options in Privacy levels settings](img/file261.png)'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图10.27 – 隐私级别设置选项](img/file261.png)'
- en: Figure 10.27 – Options in Privacy levels settings
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.27 – 隐私级别设置选项
- en: You can do this safely because you are sure that you have set the permissions
    of all data sources to **Organizational**.
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以安全地这样做，因为你确信你已经将所有数据源的权限设置为**组织**。
- en: 'Go to the **Home** tab and click on **Refresh Preview**. After a few seconds,
    click on **Table** for the `result_df` dataframe:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到**主页**选项卡，点击**刷新预览**。几秒钟后，点击`result_df`数据框的**表**：
- en: '![Figure 10.28 – Selecting the result_df table](img/file262.png)'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图10.28 – 选择result_df表](img/file262.png)'
- en: Figure 10.28 – Selecting the result_df table
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.28 – 选择result_df表
- en: 'You will see the contents of the following table, which shows the values of
    shipped quantities provided by the solution of the linear optimization problem
    for each combination of warehouse and country, and the corresponding cost:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将看到以下表格的内容，该表格显示了针对每个仓库和国家的组合，线性优化问题的解提供的运输数量以及相应的成本：
- en: '![Figure 10.29 – Selecting the result_df table](img/file263.png)'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 10.29 – 选择 result_df 表](img/file263.png)'
- en: Figure 10.29 – Selecting the result_df table
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.29 – 选择 result_df 表
- en: Click on **Close & Apply**.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **关闭并应用**。
- en: Remember that control over source privacy levels is disabled. You should turn
    it back on to *combine data according to each file’s privacy level settings* at
    the end of this project to be warned in case of possible data leaks due to query
    folding mechanisms (for more details, see the *References* section).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，对源隐私级别的控制已被禁用。你应该在项目结束时将其重新启用，以便根据每个文件的隐私级别设置*组合数据*，以防因查询折叠机制而导致可能的数据泄露（更多详情，请参阅
    *参考文献* 部分）。
- en: '**Important Note**'
  id: totrans-329
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: ''
  id: totrans-330
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Also remember that if you want to publish your report to the Power BI service,
    the privacy level of all data sources must be set to **Public**.
  id: totrans-331
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 还要记住，如果你想将报告发布到 Power BI 服务，所有数据源的隐私级别必须设置为 **公共**。
- en: Did you know that everything you’ve seen about LP problems can also be implemented
    in R? Let’s see how to do it.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道吗？你看到的所有关于 LP 问题的内容也可以在 R 中实现？让我们看看如何实现它。
- en: Solving LP problems with R
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 R 解决 LP 问题
- en: If the Python community is very active, certainly the R community is not standing
    still! In fact, the **Optimization Modeling Package** (**OMPR**) is available
    ([https://dirkschumacher.github.io/ompr/](https://dirkschumacher.github.io/ompr/)),
    which is a domain-specific language created to model and solve LP problems in
    R.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Python 社区非常活跃，那么 R 社区当然也不会停滞不前！实际上，**优化建模包**（**OMPR**）是可用的（[https://dirkschumacher.github.io/ompr/](https://dirkschumacher.github.io/ompr/)），这是一个为在
    R 中建模和解决 LP 问题而创建的领域特定语言。
- en: In general, all other packages developed in R that serve the same purpose are
    mostly matrix-oriented, forcing you to transform all objects into matrices and
    vectors before passing them to the solver. This task may seem simple enough at
    first glance, but when the problems to be solved become complex, it may become
    difficult to write R code to solve them.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，所有其他在 R 中开发的、服务于相同目的的包大多是矩阵导向的，迫使你在将对象传递给求解器之前将所有对象转换为矩阵和向量。这项任务乍一看可能足够简单，但当要解决的问题变得复杂时，编写解决这些问题的
    R 代码可能会变得困难。
- en: The `ompr` package, on the other hand, provides enough expressive power to allow
    you to model your LP problems incrementally, thanks also to the use of the `%>%`
    pipe. Therefore, you will feel like you are writing code as if you were using
    `dplyr` functions, forgetting about matrices and vectors.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`ompr` 包提供了足够的表达能力，允许你增量地建模你的 LP 问题，这也要归功于 `%>%` 管道的使用。因此，你会感觉就像在使用 `dplyr`
    函数编写代码一样，忘记了矩阵和向量。
- en: In addition, the `ompr` package relies on another package called `ompr.roi`
    to be able to select the engine of preference for solving LP problems. This package
    uses, behind the scenes, a sophisticated framework for handling linear and non-linear
    optimization problems in R called **R Optimization Infrastructure** (**ROI**),
    provided by another package called `ROI` itself ([http://roi.r-forge.r-project.org/](http://roi.r-forge.r-project.org/)).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`ompr` 包依赖于另一个名为 `ompr.roi` 的包，以便能够选择解决 LP 问题的首选引擎。该包在幕后使用一个复杂的框架来处理 R 中的线性和非线性优化问题，这个框架被称为
    **R 优化基础设施**（**ROI**），由另一个名为 `ROI` 的包提供（[http://roi.r-forge.r-project.org/](http://roi.r-forge.r-project.org/)）。
- en: In our examples, we’ll use the **GLPK** solver added as a plugin by **ROI**.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将使用由 **ROI** 添加的插件 **GLPK** 求解器。
- en: So, let’s see how to set up the LP problem we described in the previous sections
    in R using the `ompr` package.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们看看如何使用 `ompr` 包在 R 中设置我们在上一节中描述的 LP 问题。
- en: Solving the LP problem in R
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 R 中解决 LP 问题
- en: 'First, you need to install the packages necessary for the correct functioning
    of `ompr`. Therefore, follow these steps:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要安装 `ompr` 正确运行所需的包。因此，按照以下步骤操作：
- en: Open RStudio and make sure it is referencing your latest CRAN R version (version
    4.0.2 in our case).
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 RStudio 并确保它引用的是你最新的 CRAN R 版本（在我们的例子中是版本 4.0.2）。
- en: 'Click on the **Console** window and enter this command: `install.packages(‘ompr’)`.
    Then, press *Enter*.'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **控制台** 窗口，输入以下命令：`install.packages('ompr')`。然后，按 *Enter*。
- en: 'Enter this command: `install.packages(‘ompr.roi’)`. Then, press *Enter*.'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令：`install.packages(‘ompr.roi’)`。然后，按*Enter*键。
- en: 'Enter this command: `install.packages(‘ROI.plugin.glpk’)`. Then, press *Enter*.'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令：`install.packages(‘ROI.plugin.glpk’)`。然后，按*Enter*键。
- en: You can find all the code that will be shown as follows in the `03-linear-optimization-in-r.R`
    file in the `Chapter10\R` folder.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`Chapter10\R`文件夹中的`03-linear-optimization-in-r.R`文件中找到所有将展示的代码。
- en: 'First, you need to import the needed packages and the data from the Excel `RetailData.xlsx`
    file that you find in the `Chapter10` folder:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要导入所需的包和来自`Chapter10`文件夹中的`RetailData.xlsx`文件的数据：
- en: '[PRE31]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After that, you can compute the arrays and cost matrix from the tibbles, which
    are needed to then set up the model with `ompr`:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你可以从tibbles中计算数组和成本矩阵，这些是随后使用`ompr`设置模型所需的：
- en: '[PRE32]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In order to switch from the vertical form of the cost data in the `cost_matrix_tbl`
    tibble to the horizontal form, we used the very convenient `pivot_wider()` function
    provided by the `tidyr` package.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将`cost_matrix_tbl` tibble中成本数据的垂直形式转换为水平形式，我们使用了`tidyr`包提供的非常方便的`pivot_wider()`函数。
- en: 'At this point, defining the model using the functions exposed by `ompr` is
    almost straightforward if we follow the mathematical model we showed in the *Formulating
    the LP problem* section:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，如果我们遵循*公式化LP问题*部分中展示的数学模型，使用`ompr`暴露的函数定义模型几乎是直截了当的：
- en: '[PRE33]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `sum_expr()` function may seem incomprehensible at first glance. Let’s
    take this piece of code as an example:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum_expr()`函数乍一看可能难以理解。让我们以这段代码为例：'
- en: '[PRE34]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It can be read in full as follows: *Take the decision variables x[i,j] obtained
    by substituting values ranging from 1 to n_countries (that is, 6) for j, then
    sum the resulting variables together*. In summary, you are asking to calculate
    this:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 可以完整阅读如下：*将决策变量x[i,j]替换为从1到n_countries（即6）的值，然后对结果变量求和*。总之，你要求计算如下：
- en: '[PRE35]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'At this point, once the model is defined, you can solve it using the `glpk`
    solver with this code:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，一旦定义了模型，你可以使用以下代码使用`glpk`求解器来解决问题：
- en: '[PRE36]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The results obtained coincide (obviously, since the solution is optimal) with
    those already seen using Python’s `PuLP` module:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 获得的结果（显然，因为解决方案是最优的）与之前使用Python的`PuLP`模块看到的结果一致：
- en: '[PRE37]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You will surely recognize the solution already seen before:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 你一定会认出之前已经看到的解决方案：
- en: '[PRE38]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Did you see that you were able to solve an LP problem in R as well? Nothing
    exceptionally complex, right? Very good!
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到你也能在R中解决LP问题了吗？并没有什么特别复杂的地方，对吧？非常好！
- en: Let’s now apply what we saw in Power BI.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在应用在Power BI中看到的内容。
- en: Solving the LP problem in Power BI with R
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用R在Power BI中解决LP问题
- en: 'The implementation complexities of solving our LP problem in Power BI have
    already been exposed in the *Solving the LP problem in Power BI with Python* section.
    We will therefore proceed here with the individual steps using R, without dwelling
    on the details:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在*使用Python解决Power BI中的LP问题*部分中已经暴露了解决我们的LP问题在Power BI中的实现复杂性。因此，我们将在这里使用R进行单独的步骤，而不深入细节：
- en: Open Power BI Desktop and make sure the privacy is set to **Always ignore Privacy
    Level settings** in **Options**.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Power BI Desktop，确保在**选项**中将隐私设置为**始终忽略隐私级别设置**。
- en: Click **Excel Workbook** on the ribbon (or **Import data from Excel** in the
    main canvas), select the `RetailData.xlsx` file in the `Chapter10` folder, and
    click **Open**.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击功能区上的**Excel Workbook**（或在主画布上的**从Excel导入数据**），选择`Chapter10`文件夹中的`RetailData.xlsx`文件，然后点击**打开**。
- en: 'Select the **CountryDemand**, **ShippingCost**, and **WarehouseSupply** tables
    (the ones with a blue header) and then click **Transform Data**:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**CountryDemand**、**ShippingCost**和**WarehouseSupply**表格（带有蓝色标题的表格），然后点击**Transform
    Data**：
- en: '![Figure 10.30 – Selecting the three tables from Excel](img/file264.png)'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图10.30 – 从Excel中选择三个表格](img/file264.png)'
- en: Figure 10.30 – Selecting the three tables from Excel
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.30 – 从Excel中选择三个表格
- en: Select the **CountryDemand** query on the left, click on the **Transform** tab
    on the ribbon, and then click on **Run R Script**.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧选择**CountryDemand**查询，点击功能区上的**Transform**选项卡，然后点击**Run R Script**。
- en: 'Enter the following R code in the script editor (change the path properly),
    then click **OK**:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本编辑器中输入以下R代码（正确更改路径），然后点击**OK**：
- en: '[PRE39]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You will see the country demand data, but behind the scenes, a vector has been
    serialized with the name `country_demands.rds` in the `Chapter10/R` folder.
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将看到国家需求数据，但幕后，一个名为`country_demands.rds`的向量已经被序列化，存放在`Chapter10/R`文件夹中。
- en: Select the **ShippingCost** query on the left, click on the **Transform** tab
    on the ribbon, and then click on **Run R Script**.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧选择**ShippingCost**查询，点击功能区上的**转换**选项卡，然后点击**运行R脚本**。
- en: 'Enter the following R code in the script editor, then click **OK**:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本编辑器中输入以下R代码，然后点击**确定**：
- en: '[PRE40]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You will see the cost matrix data, but behind the scenes, a matrix has been
    serialized with the name `cost_matrix.rds` in the `Chapter10/R` folder.
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将看到成本矩阵数据，但幕后，一个名为`cost_matrix.rds`的矩阵已经在`Chapter10/R`文件夹中序列化。
- en: Select the **WarehouseSupply** query on the left, click on the **Transform**
    tab on the ribbon, and then click on **Run R Script**.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧选择**WarehouseSupply**查询，点击功能区上的**转换**选项卡，然后点击**运行R脚本**。
- en: 'Enter the following R code in the script editor, then click **OK**:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本编辑器中输入以下R代码，然后点击**确定**：
- en: '[PRE41]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You will see the warehouse supply data, but behind the scenes, a vector has
    been serialized with the name `warehouse_supply.rds` in the `Chapter10/R` folder.
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将看到仓库供应数据，但幕后，一个名为`warehouse_supply.rds`的向量已经在`Chapter10/R`文件夹中序列化。
- en: Right-click on the query panel on the left, select **New Query**, then **Combine**,
    then **Merge Queries as New**.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧的查询面板上右键单击，选择**新建查询**，然后**合并**，然后**合并查询为新建**。
- en: On the **Merge** window, select the **CountryDemand** and **ShippingCost** tables,
    then select the `country_name` column for both of them and click **OK**.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**合并**窗口中，选择**CountryDemand**和**ShippingCost**表，然后选择两个表中的`country_name`列并点击**确定**。
- en: A new **Merge1** query will appear. Click on it, expand the content of the **ShippingCost**
    table, and click **OK**.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将出现一个新的**Merge1**查询。点击它，展开**ShippingCost**表的内容，然后点击**确定**。
- en: Go to the **Home** tab, make sure that the **Merge1** query is selected, and
    click on **Merge Queries** in order to also merge **WarehouseSupply** too.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到**主页**选项卡，确保已选择**Merge1**查询，然后点击功能区上的**合并查询**以合并**WarehouseSupply**。
- en: Select the **WarehouseSupply** table on the **Merge** window and click the `ShippingCost.warehouse_name`
    and `warehouse_name` columns on both of the tables, then click **OK**.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**合并**窗口中选择**WarehouseSupply**表，然后点击两个表中的`ShippingCost.warehouse_name`和`warehouse_name`列，然后点击**确定**。
- en: Expand the **WarehouseSupply** column and click **OK**.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开**WarehouseSupply**列并点击**确定**。
- en: Click on the **Transform** tab on the ribbon, click on **Run R Script**, and
    enter the script, which you can find in the `04-linear-optimization-in-power-bi-with-r.R`
    file in the `Chapter10\R` folder.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击功能区上的**转换**选项卡，点击**运行R脚本**，并输入脚本，你可以在`Chapter10\R`文件夹中的`04-linear-optimization-in-power-bi-with-r.R`文件中找到该脚本。
- en: 'You will see the contents of the following table, which shows the values of
    shipped quantities provided by the solution of the linear optimization problem
    for each combination of warehouse and country, and the corresponding cost:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将看到以下表格的内容，该表格显示了每个仓库和国家的组合提供的线性优化问题的解的发货量值以及相应的成本：
- en: '![Figure 10.31 – Contents of the WarehouseSupply table](img/file265.png)'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图10.31 – **WarehouseSupply**表的内容](img/file265.png)'
- en: Figure 10.31 – Contents of the WarehouseSupply table
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.31 – **WarehouseSupply**表的内容
- en: Click on **Close & Apply**.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**关闭并应用**。
- en: Remember that control over source privacy levels is disabled. You should turn
    it back on to *combine data according to each file’s privacy level settings* at
    the end of this project to be warned in case of possible data leaks due to query
    folding mechanisms (for more details, see the *References* section).
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，源隐私级别控制已被禁用。你应该在项目结束时将其重新启用，以便根据每个文件的隐私级别设置*合并数据*，以防因查询折叠机制可能导致的潜在数据泄露（更多详情，请参阅*参考文献*部分）。
- en: Summary
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to calculate distances between two geographic
    points according to the most commonly used definitions in spherical trigonometry
    using Python and R. You then applied this knowledge to a real-world case in Power
    BI.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用Python和R根据球面三角学中最常用的定义来计算两个地理点之间的距离。然后你将这一知识应用于Power BI中的实际案例。
- en: You also learned how to solve the simplest LP problems through some Python and
    R packages. Again, you applied what you learned to a real-world case in Power
    BI.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学习了如何通过一些Python和R包解决最简单的线性规划问题。同样，你将所学知识应用于Power BI中的实际案例。
- en: In the next chapter, you’ll see how to add some salt to your business analytics
    thanks to statistics.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将看到如何通过统计学为你的商业分析添加一些盐分。
- en: References
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'For additional reading, check out the following books and articles:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 对于额外的阅读，请参阅以下书籍和文章：
- en: '*On Spherical Trigonometry* ([http://www.robingilbert.com/blog/2017-10-01-on-spherical-trigonometry/](http://www.robingilbert.com/blog/2017-10-01-on-spherical-trigonometry/))'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*关于球面三角学* ([http://www.robingilbert.com/blog/2017-10-01-on-spherical-trigonometry/](http://www.robingilbert.com/blog/2017-10-01-on-spherical-trigonometry/))'
- en: '*Calculate the Distance Between Two GPS Points with Python (Vincenty’s Inverse
    Formula)* ([https://nathanrooy.github.io/posts/2016-12-18/vincenty-formula-with-python/](https://nathanrooy.github.io/posts/2016-12-18/vincenty-formula-with-python/))'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Python计算两个GPS点之间的距离（Vincenty逆公式）* ([https://nathanrooy.github.io/posts/2016-12-18/vincenty-formula-with-python/](https://nathanrooy.github.io/posts/2016-12-18/vincenty-formula-with-python/))'
- en: '*Vectorization and parallelization in Python with NumPy and pandas* ([https://datascience.blog.wzb.eu/2018/02/02/vectorization-and-parallelization-in-python-with-numpy-and-pandas/](https://datascience.blog.wzb.eu/2018/02/02/vectorization-and-parallelization-in-python-with-numpy-and-pandas/))'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用NumPy和pandas在Python中进行向量化和平行化* ([https://datascience.blog.wzb.eu/2018/02/02/vectorization-and-parallelization-in-python-with-numpy-and-pandas/](https://datascience.blog.wzb.eu/2018/02/02/vectorization-and-parallelization-in-python-with-numpy-and-pandas/))'
- en: '*Behind the scenes of the Data Privacy Firewall* ([https://docs.microsoft.com/en-us/power-query/dataprivacyfirewall](https://docs.microsoft.com/en-us/power-query/dataprivacyfirewall))'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据隐私防火墙背后的场景* ([https://docs.microsoft.com/en-us/power-query/dataprivacyfirewall](https://docs.microsoft.com/en-us/power-query/dataprivacyfirewall))'
