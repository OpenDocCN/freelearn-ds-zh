- en: 10 Calculating Columns Using Complex Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The data ingestion phase allows you to gather all the information you need for
    your analysis from any data source. Once the various datasets have been imported,
    it may be that some of this information, taken as it is, isn’t useful in describing
    a phenomenon from an analytical point of view. It is often necessary to apply
    non-trivial algorithms to the data you have in order to get measures or indicators
    that will do the trick and Power BI often doesn’t have the tools to calculate
    them. Fortunately, thanks to R and Python, we have everything we need to calculate
    our measures.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The distance between two geographic locations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing distances using Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing distances using R
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basics of linear programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Definition of the LP problem to solve
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling optimization problems with Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving LP problems with R
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter requires you to have a working internet connection and **Power
    BI Desktop** already installed on your machine. You must have properly configured
    the R and Python engines and IDEs as outlined in *Chapter 2*, *Configuring R with
    Power BI*, and *Chapter 3*, *Configuring Python with Power BI*.
  prefs: []
  type: TYPE_NORMAL
- en: The distance between two geographic locations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It often happens that you have in your dataset coordinates expressed in longitude
    and latitude that identify points on the globe. Depending on the purpose of the
    analysis you need to complete, you can leverage these coordinates to calculate
    measures that best help to describe the scenario you want to deal with. For example,
    assuming you have the geographic coordinates of some hotels in a dataset, it might
    make sense to calculate the distance of each of them to the nearest airport if
    you want to give an additional value of interest to a visitor. Let’s start by
    figuring out what types of distances to consider for our case.
  prefs: []
  type: TYPE_NORMAL
- en: Spherical trigonometry
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The study of how to measure triangles (**trigonometry**) has been of great interest
    in the past. The ancient Egyptians and Babylonians had already addressed the issues
    between the relationships between sides, although they did not yet have the notion
    of an angle. It is thanks to **Hellenistic mathematics** that the concepts of
    trigonometric functions as we know them now began to spread around the world,
    even reaching India and China.
  prefs: []
  type: TYPE_NORMAL
- en: It was the ancient Greeks who, once they had explored all the properties associated
    with a triangle drawn on a plane, came up with the idea of imagining a triangle
    drawn on a sphere. The importance of measuring distances between points on a sphere
    was immediately shown to be of interest in later centuries for navigation and
    astronomy. Therefore, several minds devoted themselves eagerly to the discovery
    of important properties that today can be collected under the name of **spherical
    trigonometry**.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you draw a spherical triangle, you will immediately notice the differences
    from a flat triangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – A spherical triangle](img/file235.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – A spherical triangle
  prefs: []
  type: TYPE_NORMAL
- en: 'The main difference with planar triangles is that the sides of spherical triangles
    are arcs of **great circles** or **geodesics** (circumferences that always divide
    the sphere in half), and since the central angles (near the center, *O*) are proportional
    to the lengths of their respective arcs (*length = π x angle*), the sides *a*,
    *b*, and *c* are measured with *angle units* rather than linear units. If you
    want a visualization of the fact that the sides of the spherical triangle belong
    to three great circles, *Figure 10.2* can help you:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – The great circles that generate a spherical triangle](img/file236.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – The great circles that generate a spherical triangle
  prefs: []
  type: TYPE_NORMAL
- en: The mathematics describing spherical trigonometry makes it possible to define
    all the distances between two points on the sphere so far highlighted by great
    mathematicians of the past.
  prefs: []
  type: TYPE_NORMAL
- en: As for the distances between two geographical points, the reference coordinate
    system will be the one that makes use of **latitude** and **longitude**. Obviously,
    we will not go into the mathematical detail of the proofs of distances that we
    will propose shortly (also because some of them would be very complex indeed).
    We did, however, want to provide an introduction that would lay the groundwork
    that can be found in the most frequently used concepts of geographic distances.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now explore the most straightforward distance between two points, the
    law of Cosines distance.
  prefs: []
  type: TYPE_NORMAL
- en: The law of Cosines distance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **law of Cosines distance** (also called the **great circle distance**)
    is the shortest distance between two points on the surface of a sphere, measured
    along the surface of the sphere. Given two points, *P* and *Q*, a unique great
    circle passes through them. The two points separate the great circle into two
    distinct arcs. The length of the shorter arc is the distance of the great circle
    between the points:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – The great circle distance between the points P and Q](img/file237.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – The great circle distance between the points P and Q
  prefs: []
  type: TYPE_NORMAL
- en: Observe that if the two points of which to calculate the distance are at the
    antipodes of the sphere (the **antipodal points** *u* and *v*), then the great
    circles that pass through them are infinite and the distance between these two
    points is calculated very easily, as it measures exactly half the circumference
    of the sphere.
  prefs: []
  type: TYPE_NORMAL
- en: 'When, on the other hand, the points are not antipodal, it is possible to derive
    the preceding distance thanks to the **spherical law of Cosines** (see *References*
    at the end of this chapter) that governs spherical trigonometry (that’s why we
    also call it the law of Cosines distance). Without tediously going through the
    mathematical steps, the formula that calculates the law of Cosines (or great circle)
    distance between two points on a sphere is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – The formula of the law of Cosines distance between two points](img/file238.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – The formula of the law of Cosines distance between two points
  prefs: []
  type: TYPE_NORMAL
- en: Looking at it, it’s not the simplest, cleanest formula you’ve ever seen, right?
    Despite this, having a handy calculator available today, the preceding calculation
    remains feasible. Now imagine the ancient navigators who used to apply the great
    circle distance between various points on the globe. How could they have used
    the preceding formula, even though they had sine and cosine tables that would
    have facilitated some calculations? It would have been a very complex activity
    and subject to errors that could have cost the sailors their lives.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If the two points are close together (for example, a few kilometers apart on
    the sphere) and you don’t have a calculator with accurate precision, you might
    get inaccurate results.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For these reasons, mathematicians of the age introduced the new trigonometric
    `haversin` function (or `hav`), which allows you to transform and smooth out the
    great circle distance formula, also avoiding the previously mentioned error for
    small distances. Let’s see how it does this.
  prefs: []
  type: TYPE_NORMAL
- en: The law of Haversines distance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The function called `haversine` (from *half-versed sine*) is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Definition of the haversine function](img/file239.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – Definition of the haversine function
  prefs: []
  type: TYPE_NORMAL
- en: 'Thanks to this new function, it is possible to rewrite the law of Cosines distance
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Definition of the law of Haversines distance](img/file240.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – Definition of the law of Haversines distance
  prefs: []
  type: TYPE_NORMAL
- en: This new distance formulation is known as the **law of Haversines distance**.
    Its undoubted usefulness to navigators of the time becomes clear when you consider
    that, along with the tables of sines and cosines, tables of Haversines were also
    published. Therefore, the calculation of the distance between two points became
    immediate.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Even this formula suffers from rounding errors due to the special (and somewhat
    unusual) case of antipodal points.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To get a distance formula that has better accuracy than the Haversines one,
    you have to use Vincenty’s formula. Let’s see what this is all about.
  prefs: []
  type: TYPE_NORMAL
- en: Vincenty’s distance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The winning assumption that led the geodesist Vincenty to a more precise formula
    of the distance between two points was to consider the Earth as not a sphere but
    an ellipsoid slightly flattened at the poles (the difference is only about 21
    km):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – An ellipsoid representation](img/file241.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – An ellipsoid representation
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the Haversines method for calculating a distance on a sphere, **Vincenty’s
    formulas** describe a method that needs to converge to a solution through several
    iterations. In detail, a sequence of equations is calculated whose output is fed
    back into the same sequence of equations with the goal of minimizing the calculated
    value after a certain number of iterations. For this reason, Vincenty’s formulas
    are computationally more demanding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Vincenty’s formulas are related to two problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Direct problem**: Find the endpoint, *(Φ2, L2)*, and azimuth, *α2*, given
    an initial point, *(Φ1, L1)*, and initial azimuth, *α1*, and a distance, *s*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inverse problem**: Find the azimuths *α1*, *α2* and the ellipsoidal distance,
    *s*, given the coordinates of the two points, *(Φ1, L1)* and *(Φ2, L2)*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reverse problem is what we are interested in as we need to calculate the
    distance. To get an idea of the complexity of the formulas, take a look at the
    *References* section at the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Vincenty’s formulas are widely used in projects where there is a need for high
    precision in measurements because they are accurate to within 0.5 mm (0.020 in)
    of the Earth’s ellipsoid.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If the points are nearly antipodal, the algorithm fails to converge and the
    error is much larger or converges slowly.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In 2013, Karney used Newton’s method to give rapid convergence for all pairs
    of input points without any error.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the question that arises is what kind of distance is best to
    use and when. Let’s try to understand that in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: What kind of distance to use and when
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Considering the strong limitation that the law of Cosines distance has for
    short distances between two points, the most used methods today in common applications
    are the law of Haversines (for short, Haversine) and Vincenty’s formulas (for
    short, Vincenty). Here are our suggestions about which distance to use in particular
    scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: For *points located close to each other* (think short-range flights), the approximation
    of the Earth to a sphere is very likely. Therefore, methods based on the spherical
    Earth model, such as Haversine, which are computationally simpler (hence faster),
    will be quite adequate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For *points located far away* (such as long-range flights, especially connecting
    opposite hemispheres), the spherical Earth model starts to be less tight and inaccurate.
    In these cases, Vincenty’s inverse formula for ellipsoids, which is substantially
    more computationally complex (hence generally slower), will give a better result.
    If you have computational limitations, you need to consider whether the faster
    models give sufficiently accurate results for your purposes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you’ve become well versed in the theory, let’s move on to implementing
    these algorithms in Python and R.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing distances using Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The scenario on which we will implement the distance algorithms just described
    involves a dataset of US hotels, containing the latitude and longitude of each.
    The goal is to enrich the dataset by adding the distances to the nearest airports.
  prefs: []
  type: TYPE_NORMAL
- en: 'The hotel data is publicly available on *Back4App* ([https://bit.ly/data-hotels-usa](https://bit.ly/data-hotels-usa)).
    For convenience, we extracted only 100 hotels from New York City and we will calculate
    for each of them the distances from the LaGuardia and John F. Kennedy airports
    (you can find the airport data here: [https://datahub.io/core/airport-codes](https://datahub.io/core/airport-codes))
    using the Haversine (spherical model) and Karney (ellipsoidal model) methods.
    You can find the already extracted datasets for your convenience in the `Chapter10`
    folder of the GitHub repository. In detail, you will find the hotel data in the
    `hotels-ny.xlsx` file and the airport data in the `airport-codes.csv` file.'
  prefs: []
  type: TYPE_NORMAL
- en: Calculating distances with Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we mentioned earlier, we are not those that like to reinvent the wheel, especially
    when there is a risk of running into complexities related to the domain of the
    problem to be solved. Fortunately, Python has a very active community of programmers
    with expertise in specific scientific domains who share their artifacts publicly.
    This is the case of the `PyGeodesy` package ([https://github.com/mrJean1/PyGeodesy](https://github.com/mrJean1/PyGeodesy)),
    created by Jean M. Brouwers, which implements in pure Python various computational
    tools for spherical and ellipsoidal models of the Earth that Chris Veness has
    made available for Java and Charles Karney himself has made available in C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to use this module, you must obviously install it in your environment
    and, since we intend to use the distance formulas optimized by Karney, we must
    also install the `geographiclib` package, directly maintained by him. Therefore,
    proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Anaconda Prompt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch to the `pbi_powerquery_env` environment, entering the `conda activate
    pbi_powerquery_env` command, and then press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the `PyGeodesy` package, entering `pip install PyGeodesy`, and then
    press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the `geographiclib` package, entering `pip install geographiclib`, and
    then press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you have not already done so, also install the `openpyxl` package by entering
    `pip install openpyxl`, and then press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point, you can proceed with the Python code. First, note that `PyGeodesy`
    package contains a form with basic geodesic functions, called `formy`. In this
    module, there are functions that directly calculate distances according to the
    Haversine''s and Vincenty formulas, but it doesn’t contain the variant of Karney’s
    formulas. Therefore, in addition to the standard pandas and NumPy modules, the
    following must be imported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To calculate the distance according to Karney, you must use the objects provided
    by the `ellipsoidalKarney` module. Basically, you have to create the two points
    on the ellipsoid using the `LatLon` method of this model, and then calculate the
    distance. This is summarized in the following `karney` user-defined function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, a second user-defined function is created for convenience as a
    wrapper for the calls to the calculation of the various distances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the hotels data is imported into the `hotel_df` dataframe and the airports
    data into the `airports_df` one. Since the airports dataframe has the `coordinates`
    column, which contains a string with longitude and latitude separated by a comma,
    these two values are split into two separate columns using the `split()` function
    and then appended to the same source dataframe without the `coordinates` column,
    now useless:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to conveniently access the latitude and longitude values of a specific
    airport, the user-defined `airportLatLongList()` function has been created, which
    accepts as parameters both a dataframe containing the airport data with the `iata_code`,
    `latitude` and `longitude` columns and the specific **IATA code** of the airport
    of interest. Remember that the IATA airport code is a three-letter code that identifies
    many airports and metropolitan areas around the world, defined by the **International
    Air Transport Association** (**IATA**). Therefore, John F. Kennedy International
    Airport is identified by the IATA code `JFK` and LaGuardia Airport by the code
    `LGA`. So, in order to get the coordinates of those airports, you can use the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'That said, thanks to the `geodistance()` function, it is enough to have the
    geographical coordinates of two points in order to calculate the distance between
    them. For example, if you want to calculate the haversine distance between point
    `A(lat1,lng1)` and point `B(lat2,lng2)`, you just have to use this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To be able to calculate the Karney distance between them instead, you can take
    advantage of the `karney()` function and use this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'However, how should you proceed if you no longer want to apply the `geodistance()`
    function to two single points, but to a series of points contained in a dataframe
    column and a second fixed point? Since the preceding function needs five input
    parameters, we could have used the `apply()` method of the pandas dataframe (as
    shown here: [http://bit.ly/pandas-apply-lambda](http://bit.ly/pandas-apply-lambda)).
    Instead, we introduced a convenient way to evaluate a function over successive
    tuples of the input Series. In order to vectorize a function, you must invoke
    the `np.vectorize()` method and pass as a parameter the function to be applied
    to the geographic coordinate Series. Then, you also have to pass the parameters
    of the input function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The distances (in meters) resulting from the previous calculation are stored
    into the new `haversineDistanceFromJFK` column of the `hotels_df` dataframe. Similarly,
    the Karney distance can be calculated by simply referencing the `karney` function
    in the code chunk.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A **vectorized function** is not the same as a function used with `np.vectorize()`.
    A vectorized function is a function built into NumPy and executed in the underlying
    compiled code (C or Fortran) so that special processor registers are used to operate
    on several items at once. As you can imagine, vectorization is much more performant
    and preferable to `for` loops. For more details, check out the *References* section.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you run the code for the `01-distances-from-airports-in-python.py` file
    in the `Python` folder, you’ll get something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Haversine and Karney distances from hotels to JFK and LGA airports
    added](img/file242.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 – Haversine and Karney distances from hotels to JFK and LGA airports
    added
  prefs: []
  type: TYPE_NORMAL
- en: Amazing! You were able to calculate both the Haversine and Karney distances
    in meters between all hotels and both airports using Python. At this point, it
    is straightforward to use similar code to calculate distances in Power BI. Let’s
    see how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating distances in Power BI with Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It’s time to implement what you’ve learned in Power BI. So, launch Power BI
    Desktop and let’s get going:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure Power BI Desktop is referencing your latest environment in **Options**.
    After that, click on **Excel** to import the `hotels-ny.xlsx` file, which you
    can find in the `Chapter10` folder. Select it and click **Open**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the **Sheet 1** table from the **Navigator** window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.9 – Selecting the Sheet 1 table](img/file243.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 10.9 – Selecting the Sheet 1 table
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, click on **Transform data**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the **Transform** menu and then click on **Run Python Script**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the script from the `02-distances-from-airports-in-power-bi-with-python.py`
    file from the `Chapter10\Python` folder into the Python script editor and click
    **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may be prompted to align the permissions in the Excel file with those you
    initially selected for the scripts (in our case, **Organizational**). In this
    case, you already know how to proceed based on what you’ve seen in *Chapter 5*,
    *Using Regular Expressions in Power BI*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are only interested in the data in `dataset`. So, click on its **Table**
    value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Power Query will transform your data by adding the distances from each hotel
    to the two airports, `JFK` and `LGA`, for the two methodologies of Haversines
    and Karney:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.10 – The result of the Python script transformation](img/file244.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 10.10 – The result of the Python script transformation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can then click **Close & Apply** in the **Home** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Great! You just enriched your data by adding the distances between two geographical
    points in Power BI using Python. Let’s see how to do that in R.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing distances using R
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The scenario will be the same as the one already described in the previous section.
    We will therefore enrich the data relating to some hotels in New York City with
    the distances separating them from the two major airports of New York, namely
    John F. Kennedy and LaGuardia.
  prefs: []
  type: TYPE_NORMAL
- en: The files containing the data to be processed can be found in the `Chapter10`
    folder of the GitHub repository. In detail, you will find the hotels data in the
    `hotels-ny.xlsx` file and the airports data in the `airport-codes.csv` file.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating distances with R
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The R community is also fortunate to have a freely available package that implements
    spherical trigonometry functions for geographic applications. The package is called
    `geosphere` ([https://cran.r-project.org/web/packages/geosphere/](https://cran.r-project.org/web/packages/geosphere/))
    and, like the Python `PyGeodesy` package, it is inspired by the code that Chris
    Veness and Charles Karney have made publicly available.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to install this new package:'
  prefs: []
  type: TYPE_NORMAL
- en: Open RStudio and make sure it is referencing your latest CRAN R (version 4.0.2
    in our case).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the **Console** window and enter this command: `install.packages(‘geosphere’)`.
    Then, press *Enter*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You are now ready to develop your code in R. Apart from the usual packages that
    allow you to read CSV and Excel files (`readr` and `readxl`) and facilitate data
    transformation operations (`dplyr` and `purrr`), you must, of course, load the
    package you just installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily import hotel data into the `hotels_tbl` tibble using the `read_xlsx()`
    function and airport data into the `airport_tbl` tibble using the `read_csv()`
    function. At this point, the first operation to do is to split the contents of
    the `coordinates` column of `airports_tbl` in the two new columns, `longitude`
    and `latitude`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the simplicity of using the `separate` function from the `tidyr` package:'
  prefs: []
  type: TYPE_NORMAL
- en: The pipe passes the `airports_tbl` tibble as the first parameter for the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare the column to be split (`col = coordinates`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare the two new target columns (`into = c(‘longitude’, ‘latitude’)`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare the separator found in the values of the column to be split (`sep =
    ‘, ‘`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the column to be split when the transformation is complete (`remove =
    TRUE`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let the data type of the target columns convert automatically if they are numeric
    columns (`convert = TRUE`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All this in one operation with maximum clarity. That’s one of the reasons data
    analysts love R!
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, we make use of a function to conveniently access the longitude and latitude
    values of a specific airport. It is the `airportLongLatVec()` function and it
    accepts as parameters both a dataframe containing the airport data with the `iata_code`,
    `latitude`, and `longitude` columns, and the specific **IATA code** of the airport
    of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is a named vector. So, the coordinates of the two airports can be
    easily found in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You are pretty much ready to transform the data. From the `geosphere` package,
    you will use the `distHaversine()` and `distGeo()` functions. The former is self-explanatory
    from the name itself. The `distGeo()` function calculates the shortest distance
    between two points on an ellipsoid according to Karney’s formulas. Both functions
    accept two pairs of coordinates (in the order longitude and latitude) in vector
    form. To get the same results as Python, the `distHaversine()` function must accept
    as a parameter the same mean radius of the Earth sphere model used by default
    by PyGeodesy. The radius in question is **R1** (mean radius) defined by the **International
    Union of Geodesy and Geophysics** (**IUGG**), which is 6,371,008.771415 meters.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, the enrichment operation of the `hotels_tbl` tibble can be done
    using the already seen family of `map()` functions of the `purrr` package. In
    the first step, we create a new column, `p1`, containing the longitude and latitude
    pairs in a vector using the `map2()` function. In the second step, we apply the
    `distHaversine()` and `distGeo()` functions to the newly created point, `p1`,
    and to the fixed points identifying the airports (`jfk_coordinates` and `lga_coordinates`)
    to create the new columns containing the distances. This is the code needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Recall that the `map2()` function takes two vectors as input and runs them in
    parallel to pass their values to the function used after the `~` symbol (in our
    case, the `c()` function that declares a vector). The `map_dbl()` function instead
    takes as input the column `p1` (which contains the geographic coordinates in vector
    format of the hotels) and passes its elements to the function after the `~` (in
    our case, `distGeo()` with other fixed parameters) transforming the output into
    a vector of double numeric data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the code for the `01-distances-from-airports-in-r.R` file in the
    `R` folder, you’ll get something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11 – The enriched hotels tibble with distances](img/file245.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.11 – The enriched hotels tibble with distances
  prefs: []
  type: TYPE_NORMAL
- en: Wow! You were able to calculate both the Haversine and Karney distances between
    all hotels and both airports also using R. At this point, it is straightforward
    to use similar code to calculate distances in Power BI. Let’s see how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating distances in Power BI with R
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It’s time to implement what you’ve just learned in Power BI. So, launch Power
    BI Desktop and let’s get going:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure Power BI Desktop is referencing your latest environment in **Options**.
    After that, click on **Excel** to import the `hotels-ny.xlsx` file, which you
    can find in the `Chapter10` folder. Select it and click **Open**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the **Sheet 1** table from the **Navigator** window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.12 – Selecting the Sheet 1 table](img/file246.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 10.12 – Selecting the Sheet 1 table
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, click on **Transform data**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the **Transform** menu and then click on **Run R Script**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the script from the `02-distances-from-airports-in-power-bi-with-r.R` file
    from the `Chapter10\R` folder into the R script editor and click **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are only interested in the data in `hotels_df`. So, click on its **Table**
    value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Power Query will transform your data by adding the distances from each hotel
    to the two airports, `JFK` and `LGA`, for the two methodologies of Haversines
    and Karney:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.13 – The result of the Python script transformation](img/file247.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 10.13 – The result of the Python script transformation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can then click **Close & Apply** in the **Home** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Great! You just enriched your data by adding distances between two geographical
    points in Power BI using R.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will see how to enrich your dataset using linear optimization
    algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: The basics of linear programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Linear Programming** (**LP**) **algorithms** are adopted in all those areas
    where optimization, and therefore the economy of resources, is critical to the
    continuation of activities. In order to understand what this is all about, you
    need some math. In this way, let’s brush up on some of the geometric concepts
    we encountered during our youthful studies.'
  prefs: []
  type: TYPE_NORMAL
- en: Linear equations and inequalities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We all at least once in our lives have encountered the term linear equation.
    A **linear equation**, in its simplest sense, consists of a mathematical relationship
    between two variables, *x* and *y*, in the form *ax + by + c = 0*, which on the
    Cartesian plane identifies a **straight line**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.14 – Representation of the linear equation 2x + y = 2](img/file248.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.14 – Representation of the linear equation 2x + y = 2
  prefs: []
  type: TYPE_NORMAL
- en: 'Evidently, the variables involved in a linear equation can be more than two.
    The representation of a linear equation is possible as long as we have three variables
    (the famous three dimensions we can see). In this case, a linear equation of three
    variables, in the form *ax + by + cz + d = 0*, represents a **plane** in the space:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.15 – Representation of a generic linear equation ax + by + cz +
    d = 0](img/file249.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.15 – Representation of a generic linear equation ax + by + cz + d
    = 0
  prefs: []
  type: TYPE_NORMAL
- en: When you have more than three variables in a linear equation, we commonly call
    its representation no longer a plane, but a **hyperplane**.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also **linear inequalities**, which are linear functions involving
    inequalities (identified by the symbols `<`, `>`, `≤`, and `≥`). Just as done
    for linear equations, in the same way, you can plot linear inequalities, either
    with two variables or with three. They represent all points on either side of
    the line in the case of two variables (that is, a region of the plane), or points
    on either side of the straight plane in the case of three variables (that is,
    a volume):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.16 – Representation of generic linear inequalities with two or
    three variables](img/file250.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.16 – Representation of generic linear inequalities with two or three
    variables
  prefs: []
  type: TYPE_NORMAL
- en: Observe that the regions identified by the inequalities are infinite but have
    an edge constituted by the linear equation that derives from the same inequality
    considering the `=` sign instead of the inequality sign.
  prefs: []
  type: TYPE_NORMAL
- en: Well, very often when you think about these concepts, you just associate them
    with theoretical mathematical stuff, but that’s not the case. Simple concepts
    related to transportation, manufacturing, shipping, and so on can be traced back
    to linear equations or inequalities. Let’s see an example.
  prefs: []
  type: TYPE_NORMAL
- en: Formulating a linear optimization problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Imagine you work in a manufacturing company and you need to produce two products,
    P1 and P2\. To produce them, you need a machine. Specifically, producing one unit
    of product P1 takes 30 minutes of processing time on the machine, while producing
    one unit of product P2 takes 25 minutes on the same machine. In addition, the
    number of hours for which the machine, M, can remain on is 40 hours (= 40*60 minutes).
    That is, 30 minutes multiplied by the number of P1 products added to 25 minutes
    multiplied by the number of P2 products cannot exceed 40 hours of processing time.
    So, given *x* number of products P1 and *y* number of products P2 produced at
    the end of processing, the machine hours **constraint** can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Wow! You just used a simple linear inequality to describe a constraint on a
    manufacturing process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now imagine that you have received demands for P1 and P2 products from customers.
    Specifically, adding up all the requests, you need to produce at least 45 units
    of P1 and 25 units of P2 to satisfy your customers. These demand constraints can
    be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Awesome! You’ve added two more linear constraints to your problem. If you add
    a goal to these business constraints, for example, you want to maximize the total
    number, *z*, of units of P1 and P2, the set of constraints and goal constitute
    a linear optimization problem:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple as that, right? If we want to be a little more formal, LP (also called
    **linear optimization**) consists of a set of techniques useful for solving systems
    of linear equations and inequalities with the goal of maximizing or minimizing
    a linear objective function. In particular, the variables *x* and *y* are called
    **decision variables** and the objective that is set is called the **objective
    function** or **cost function**. In this example, the business case required only
    inequality constraints, but there can also be equality constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Cool! But now that we’ve set up the problem from a mathematical standpoint,
    how do we solve it? First, we need to take all the inequalities and represent
    them on the axes (in this case you can, because they only contain two variables).
    As seen at the beginning, a linear inequality represents a portion of a plane
    bounded by the straight line considering the sign of equality in the inequality
    itself. Intersecting all these planes, we come to identify an area common to all
    the inequalities, called the **feasible region**. Basically, all points that are
    in this region satisfy all the constraints identified by the inequalities.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to draw the feasible region associated with the constraints of
    the example we have just illustrated, there is no need to go over all the geometry
    studied in secondary school, but just use **WolframAlpha** ([https://www.wolframalpha.com/](https://www.wolframalpha.com/)).
    Enter the following string in the search engine: `plot 30x+25y<=2400 and x>=45
    and y>=25`. All constraints must be satisfied simultaneously, hence the use of
    the `and` operator. Press *Enter* and you will see this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.17 – The feasible region drawn by WolframAlpha](img/file251.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.17 – The feasible region drawn by WolframAlpha
  prefs: []
  type: TYPE_NORMAL
- en: To the WolframAlpha result, we have added the values of the vertices of the
    feasible region, which is a triangle.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It is shown that if the optimization problem is solvable, the solution that
    maximizes or minimizes the objective function lies precisely at one of the vertices
    of the feasible region.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'As you can see in *Figure 10.17*, the *x* value of vertex C is `59.1`. Clearly,
    it is not possible to have a fractional part of the product P1 since it is not
    possible to produce only a fraction of one unit. The nearest integer value should
    then be considered, which is 59\. If, therefore, the business problem imposes
    to have **integer values** for the decision variables, then the problem becomes
    one of **Mixed-Integer Linear Programming** (**MILP**). In our case, then, we
    consider vertices *A*, *B*, and *C**=(59,25) as possible solutions to our problem
    and substitute their coordinates into the objective function, *z = x + y*:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A*: *z = 45 + 25 = 70*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*B*: *z = 45 + 42 = 87*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C**: *z = 59 + 25 = 84*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We infer that the solution to our problem is given by the vertex *B* with a
    maximum value of 87 units, namely *P1 = 45* and *P2 = 42*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In summary, producing 45 units of product P1 and 42 units of product P2 satisfies
    the machine’s hourly production constraint and the customer demand constraints,
    while maximizing total production.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Did you ever think you could solve a linear optimization problem before today?
    Well, you’ve done it! Clearly, it is possible to solve these problems by hand
    when they are this simple. But when the number of decision variables grows, it
    is no longer possible to draw the feasible region and therefore it becomes impossible
    to locate the vertices in a multidimensional space by eye. In these cases, it
    is mathematics and, above all, the packages made available by the community for
    Python and R that allow us to find the solution to the problem. Let’s first look
    at a slightly more complex case of an LP problem.
  prefs: []
  type: TYPE_NORMAL
- en: Definition of the LP problem to solve
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now imagine that you are working for a company that needs to ship a product
    from different warehouses around the world to different countries. You have to
    hand the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The quantities of product available in warehouses:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 10.18 – Quantities of product available in warehouses](img/file252.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 10.18 – Quantities of product available in warehouses
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The quantities of product required by countries:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 10.19 – Quantities of product required by countries](img/file253.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 10.19 – Quantities of product required by countries
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The shipping costs from each of the warehouses to all requesting countries:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 10.20 – Costs from warehouses to countries](img/file254.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.20 – Costs from warehouses to countries
  prefs: []
  type: TYPE_NORMAL
- en: Your goal is to minimize your company’s costs by meeting all customer demands
    from different countries.
  prefs: []
  type: TYPE_NORMAL
- en: Formulating the LP problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As seen in the previous section, you must first formulate the problem mathematically.
    Let’s use a couple of numerical indexes, *i* and *j*, to identify the quantities
    sent and costs. In detail, consider the quantity *x[ij]* of product that is shipped
    from *Warehouse i* to *Country j* according to this matrix that defines the decision
    variables and costs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.21 – Definition matrix of the quantity of products sent and costs](img/file255.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.21 – Definition matrix of the quantity of products sent and costs
  prefs: []
  type: TYPE_NORMAL
- en: The quantity *x[ij]* is an integer and non-negative ().
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the preceding definitions, the target of the problem is to minimize the
    objective function, which can be written as the sum of the product between the
    cost of shipping from *Warehouse i* to *Country j* (*Cij*) and the quantity of
    product shipped from *Warehouse i* to *Country j* (*xij*):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Written in full and organizing it by warehouses for reading convenience, taking
    the cost amounts from *Figure 10.21*, the previous objective function can be rewritten
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To this point, you must formalize the constraints, which are of two types:
    the *warehouse supply constraints* and the *customer demand constraints*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Warehouse supply constraints**: Once a warehouse has been fixed (for example,
    the *Warehouse ITA*, for which *i = 1*), the sum of the products shipped from
    that warehouse to all countries (sum of *x[1j]*) cannot exceed the maximum quantity
    of products contained in that warehouse (for *Warehouse ITA*, 50,000 products;
    see *Figure 10.18*). That is, for all six countries, we have the following:You
    will, therefore, have a similar constraint for each warehouse (four constraints
    in all).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Customer demand constraints**: Regardless of which warehouse the goods come
    from, you have to meet the demand for each country’s products. Therefore, the
    sum of the products sent from all the warehouses toward a given country (for example,
    *France*, for which *j = 2*) must be at least equal to the demand of that country
    (France demands at least 15,000 products; see *Figure 10.19*). And, therefore,
    considering all four warehouses, we have the following:You will, therefore, have
    a similar constraint for each country (six constraints in all).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Therefore, the final linear optimization problem can be formulated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Awesome! You managed to formulate a non-trivial business problem in mathematical
    terms. Let’s now see how to solve it with Python.
  prefs: []
  type: TYPE_NORMAL
- en: Handling optimization problems with Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you’ve probably already figured out, the large community that develops Python
    packages never stands still. Even in this case, it provided a module that helps
    us solve linear optimization problems. Its name is **PuLP** ([https://github.com/coin-or/pulp](https://github.com/coin-or/pulp))
    and it is an LP modeler written in Python. It interfaces with the most common
    free and not-free engines that solve LP, **Mixed Integer Programming** (**MIP**),
    and other related problems, such as **GNU Linear Programming Kit** (**GLPK**),
    **Coin-or Branch and Cut** (**CBC**), which is the default one, and **IBM ILOG
    CPLEX**. Its use is quite straightforward. Let’s put it into practice right away
    with the problem from the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Solving the LP problem in Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code that will be explained to you in this section can be found in the `03-linear-optimizaiont-in-python.py`
    file in the `Chapter10\Python` folder of the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you have to install the `PuLP` module in your environment:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Anaconda Prompt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the `conda activate pbi_powerquery_env` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the `pip install pulp` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After that, you can then define the values that will make up the constraints
    and costs using NumPy vectors and matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the script file, you will also find the code to import the values directly
    from the `RetailData.xlsx` file in the `Chapter10` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible then to define an `LpProblem` object, giving it a name and the
    type of optimization you want to apply to the objective function (minimize or
    maximize):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: To this empty object, you can add an objective function and constraints later.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to construct the objective function, we must first define the decision
    variables (*x[ij]*) via the `LpVariable` function, which accepts the variable
    name, the full list of strings representing the variable indices, the category
    of the variable (continuous, integer, or binary), and any upper- or lower-bound
    values. The index list is simply constructed with a nested **list comprehension**
    ([http://bit.ly/nested-list-comprehensions](http://bit.ly/nested-list-comprehensions)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'It is now possible to easily define the decision variables as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the decision variables are to be multiplied by the *C[ij]* costs defined
    earlier in `cost_matrix`, it is appropriate to format the `decision_vars` list
    in the same shape as the cost matrix in order to be able to perform element-wise
    multiplication, also known as the **Hadamard product**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'It returns the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The objective function is then defined as the sum of the element-wise product
    of cost and shipping matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If you remember correctly, this expression coincides with the objective function
    written in full that you saw in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then add the objective function to the model, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Constraint inequalities are also added in the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can move on to solving the problem by running this simple script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing to do is to check the state of the solution, which can take
    the values `Optimal`, `Not Solved`, `Infeasible`, `Unbounded`, and `Undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case, the state is `Optimal`, therefore an optimal solution has been
    found for the problem. So, let’s see what value the objective function takes on
    against the solution found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The value is equal to 2,270,000 euros, which corresponds to the lowest possible
    cost while satisfying all imposed constraints. If you want to see the solution
    values of the variables that make up the shipping matrix in a very readable way,
    you’d better transform them into a pandas dataframe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The result that comes up is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.22 – Quantities shipped according to the solution found](img/file256.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.22 – Quantities shipped according to the solution found
  prefs: []
  type: TYPE_NORMAL
- en: It is easy to read, for example, that French customers must receive 10,000 units
    from the German warehouse and 5,000 units from the US warehouse to meet their
    demand.
  prefs: []
  type: TYPE_NORMAL
- en: 'If instead you want to check the total quantities shipped from each warehouse,
    you can run this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.23 – Total quantities shipped from each warehouse](img/file257.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.23 – Total quantities shipped from each warehouse
  prefs: []
  type: TYPE_NORMAL
- en: Impressive! You’ve managed to solve a non-simple linear optimization problem
    with just a few lines of Python code. Would you have guessed it? Let’s now look
    at how to apply what you learned in Power BI.
  prefs: []
  type: TYPE_NORMAL
- en: Solving the LP problem in Power BI with Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Applying what we have just seen in Power BI is not as straightforward as in
    the other cases we have encountered in the last few chapters. To start, we have
    to have already loaded the data of country demand, warehouse supply, and shipping
    costs in the data model, which could arrive from any data source. In our case,
    we have them ready in Excel, so we will proceed to load them in Power BI Desktop:'
  prefs: []
  type: TYPE_NORMAL
- en: Click **Excel Workbook** on the ribbon (or **Import data from Excel** in the
    main canvas), select the `RetailData.xlsx` file in the `Chapter10` folder, and
    click **Open**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the **CountryDemand**, **ShippingCost**, and **WarehouseSupply** tables
    (the ones with the blue header) and then click **Transform data**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.24 – Selecting the three tables from Excel](img/file258.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.24 – Selecting the three tables from Excel
  prefs: []
  type: TYPE_NORMAL
- en: 'You are now in the situation described previously. At this point, each of the
    three queries in Power Query has its own stack of steps that generated it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.25 – The CountryDemand query with its stack of applied steps](img/file259.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.25 – The CountryDemand query with its stack of applied steps
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, you saw that in order to calculate the optimal allocations,
    *you need to be able to use all three datasets in one Python script*. If you add
    a Python script as a step in one of the three queries listed previously, you can
    only interact with the data from that single query in the script. How can you
    then create a script that can use all the data available? You have to resort to
    the following stratagem:'
  prefs: []
  type: TYPE_NORMAL
- en: In order to use data belonging to more than one query in a Python script, you
    must first serialize each data structure derived from each of the three queries
    into a pickle file. Then, create a new query resulting from the merge of the three
    queries via joins (it is not necessary that the dataset resulting from the joins
    makes sense, since it will not be used). At this point, add a Python script step
    for this merge query, in which you deserialize all three previously serialized
    objects in each query. You will finally have the objects from three different
    data sources in one script.
  prefs: []
  type: TYPE_NORMAL
- en: This way, you make sure that the Python scripts that serialize the objects of
    the three datasets are executed first, and then the script that deserializes them
    is executed in order to solve the linear optimization problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see in detail how to accomplish what is described in the previous paragraphs:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the **CountryDemand** query on the left, click on the **Transform** tab
    on the ribbon, and then click on **Run Python Script**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following Python code in the script editor, then click **OK**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Click on **Table** under **Value** corresponding to **dataset**. You will always
    see the country demand data, but behind the scenes, a NumPy vector has been serialized
    with the name `country_demands.pkl` in the `Chapter10/Python` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **ShippingCost** query on the left, click on the **Transform** tab
    on the ribbon, and then click on **Run Python Script**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following Python code in the script editor, then click **OK**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Click on **Table** under **Value** corresponding to **dataset**. You will always
    see the cost matrix data, but behind the scenes, a NumPy vector has been serialized
    with the name `cost_matrix.pkl` in the `Chapter10/Python` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **WarehouseSupply** query on the left, click on the **Transform**
    tab on the ribbon, and then click on **Run Python Script**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following Python code in the script editor, then click **OK**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Click on **Table** under **Value** corresponding to **dataset**. You will always
    see the warehouse supply data, but behind the scenes, a NumPy vector has been
    serialized with the name `warehouse_supply.pkl` in the `Chapter10/Python` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the query panel on the left, select **New Query**, then **Combine**,
    then **Merge Queries as New**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Merge** window, select the **CountryDemand** and **ShippingCost** tables,
    click on the `country_name` column for both of them, and click **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new **Merge1** query will appear. Click on it, expand the content of the
    **ShippingCost** column, and click **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to the **Home** tab, make sure that the **Merge1** query is selected, and
    click on **Merge Queries** in order to also merge **WarehouseSupply** too:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.26 – Merging another query to Merge1](img/file260.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 10.26 – Merging another query to Merge1
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select the **WarehouseSupply** table on the **Merge** window and click the `ShippingCost.warehouse_name`
    and `warehouse_name` columns on both of the tables, then click **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the **WarehouseSupply** column, keep all selected, and click **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Transform** tab on the ribbon, click on **Run Python Script**,
    and enter the script you can find into the `04-linear-optimization-in-power-bi-with-python.py`
    file in the `Chapter10\Python` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will get the following error: **Formula.Firewall: Query ‘Merge1’ (step
    ‘Run Python script’) references other queries or steps, so it may not directly
    access a data source. Please rebuild this data combination**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to **File** and click **Options and settings** and then **Options**. On
    the **Options** window, select the **Privacy** tab and click on **Always ignore
    Privacy Level settings**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.27 – Options in Privacy levels settings](img/file261.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 10.27 – Options in Privacy levels settings
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can do this safely because you are sure that you have set the permissions
    of all data sources to **Organizational**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Go to the **Home** tab and click on **Refresh Preview**. After a few seconds,
    click on **Table** for the `result_df` dataframe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.28 – Selecting the result_df table](img/file262.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 10.28 – Selecting the result_df table
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You will see the contents of the following table, which shows the values of
    shipped quantities provided by the solution of the linear optimization problem
    for each combination of warehouse and country, and the corresponding cost:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.29 – Selecting the result_df table](img/file263.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 10.29 – Selecting the result_df table
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on **Close & Apply**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remember that control over source privacy levels is disabled. You should turn
    it back on to *combine data according to each file’s privacy level settings* at
    the end of this project to be warned in case of possible data leaks due to query
    folding mechanisms (for more details, see the *References* section).
  prefs: []
  type: TYPE_NORMAL
- en: '**Important Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Also remember that if you want to publish your report to the Power BI service,
    the privacy level of all data sources must be set to **Public**.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Did you know that everything you’ve seen about LP problems can also be implemented
    in R? Let’s see how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Solving LP problems with R
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the Python community is very active, certainly the R community is not standing
    still! In fact, the **Optimization Modeling Package** (**OMPR**) is available
    ([https://dirkschumacher.github.io/ompr/](https://dirkschumacher.github.io/ompr/)),
    which is a domain-specific language created to model and solve LP problems in
    R.
  prefs: []
  type: TYPE_NORMAL
- en: In general, all other packages developed in R that serve the same purpose are
    mostly matrix-oriented, forcing you to transform all objects into matrices and
    vectors before passing them to the solver. This task may seem simple enough at
    first glance, but when the problems to be solved become complex, it may become
    difficult to write R code to solve them.
  prefs: []
  type: TYPE_NORMAL
- en: The `ompr` package, on the other hand, provides enough expressive power to allow
    you to model your LP problems incrementally, thanks also to the use of the `%>%`
    pipe. Therefore, you will feel like you are writing code as if you were using
    `dplyr` functions, forgetting about matrices and vectors.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the `ompr` package relies on another package called `ompr.roi`
    to be able to select the engine of preference for solving LP problems. This package
    uses, behind the scenes, a sophisticated framework for handling linear and non-linear
    optimization problems in R called **R Optimization Infrastructure** (**ROI**),
    provided by another package called `ROI` itself ([http://roi.r-forge.r-project.org/](http://roi.r-forge.r-project.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: In our examples, we’ll use the **GLPK** solver added as a plugin by **ROI**.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s see how to set up the LP problem we described in the previous sections
    in R using the `ompr` package.
  prefs: []
  type: TYPE_NORMAL
- en: Solving the LP problem in R
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, you need to install the packages necessary for the correct functioning
    of `ompr`. Therefore, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open RStudio and make sure it is referencing your latest CRAN R version (version
    4.0.2 in our case).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the **Console** window and enter this command: `install.packages(‘ompr’)`.
    Then, press *Enter*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter this command: `install.packages(‘ompr.roi’)`. Then, press *Enter*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter this command: `install.packages(‘ROI.plugin.glpk’)`. Then, press *Enter*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can find all the code that will be shown as follows in the `03-linear-optimization-in-r.R`
    file in the `Chapter10\R` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to import the needed packages and the data from the Excel `RetailData.xlsx`
    file that you find in the `Chapter10` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, you can compute the arrays and cost matrix from the tibbles, which
    are needed to then set up the model with `ompr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In order to switch from the vertical form of the cost data in the `cost_matrix_tbl`
    tibble to the horizontal form, we used the very convenient `pivot_wider()` function
    provided by the `tidyr` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, defining the model using the functions exposed by `ompr` is
    almost straightforward if we follow the mathematical model we showed in the *Formulating
    the LP problem* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sum_expr()` function may seem incomprehensible at first glance. Let’s
    take this piece of code as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be read in full as follows: *Take the decision variables x[i,j] obtained
    by substituting values ranging from 1 to n_countries (that is, 6) for j, then
    sum the resulting variables together*. In summary, you are asking to calculate
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, once the model is defined, you can solve it using the `glpk`
    solver with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The results obtained coincide (obviously, since the solution is optimal) with
    those already seen using Python’s `PuLP` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You will surely recognize the solution already seen before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Did you see that you were able to solve an LP problem in R as well? Nothing
    exceptionally complex, right? Very good!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now apply what we saw in Power BI.
  prefs: []
  type: TYPE_NORMAL
- en: Solving the LP problem in Power BI with R
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The implementation complexities of solving our LP problem in Power BI have
    already been exposed in the *Solving the LP problem in Power BI with Python* section.
    We will therefore proceed here with the individual steps using R, without dwelling
    on the details:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Power BI Desktop and make sure the privacy is set to **Always ignore Privacy
    Level settings** in **Options**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Excel Workbook** on the ribbon (or **Import data from Excel** in the
    main canvas), select the `RetailData.xlsx` file in the `Chapter10` folder, and
    click **Open**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the **CountryDemand**, **ShippingCost**, and **WarehouseSupply** tables
    (the ones with a blue header) and then click **Transform Data**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.30 – Selecting the three tables from Excel](img/file264.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 10.30 – Selecting the three tables from Excel
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select the **CountryDemand** query on the left, click on the **Transform** tab
    on the ribbon, and then click on **Run R Script**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following R code in the script editor (change the path properly),
    then click **OK**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will see the country demand data, but behind the scenes, a vector has been
    serialized with the name `country_demands.rds` in the `Chapter10/R` folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select the **ShippingCost** query on the left, click on the **Transform** tab
    on the ribbon, and then click on **Run R Script**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following R code in the script editor, then click **OK**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will see the cost matrix data, but behind the scenes, a matrix has been
    serialized with the name `cost_matrix.rds` in the `Chapter10/R` folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select the **WarehouseSupply** query on the left, click on the **Transform**
    tab on the ribbon, and then click on **Run R Script**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following R code in the script editor, then click **OK**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will see the warehouse supply data, but behind the scenes, a vector has
    been serialized with the name `warehouse_supply.rds` in the `Chapter10/R` folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Right-click on the query panel on the left, select **New Query**, then **Combine**,
    then **Merge Queries as New**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Merge** window, select the **CountryDemand** and **ShippingCost** tables,
    then select the `country_name` column for both of them and click **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A new **Merge1** query will appear. Click on it, expand the content of the **ShippingCost**
    table, and click **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the **Home** tab, make sure that the **Merge1** query is selected, and
    click on **Merge Queries** in order to also merge **WarehouseSupply** too.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **WarehouseSupply** table on the **Merge** window and click the `ShippingCost.warehouse_name`
    and `warehouse_name` columns on both of the tables, then click **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the **WarehouseSupply** column and click **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Transform** tab on the ribbon, click on **Run R Script**, and
    enter the script, which you can find in the `04-linear-optimization-in-power-bi-with-r.R`
    file in the `Chapter10\R` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the contents of the following table, which shows the values of
    shipped quantities provided by the solution of the linear optimization problem
    for each combination of warehouse and country, and the corresponding cost:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.31 – Contents of the WarehouseSupply table](img/file265.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 10.31 – Contents of the WarehouseSupply table
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on **Close & Apply**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remember that control over source privacy levels is disabled. You should turn
    it back on to *combine data according to each file’s privacy level settings* at
    the end of this project to be warned in case of possible data leaks due to query
    folding mechanisms (for more details, see the *References* section).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned how to calculate distances between two geographic
    points according to the most commonly used definitions in spherical trigonometry
    using Python and R. You then applied this knowledge to a real-world case in Power
    BI.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned how to solve the simplest LP problems through some Python and
    R packages. Again, you applied what you learned to a real-world case in Power
    BI.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll see how to add some salt to your business analytics
    thanks to statistics.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For additional reading, check out the following books and articles:'
  prefs: []
  type: TYPE_NORMAL
- en: '*On Spherical Trigonometry* ([http://www.robingilbert.com/blog/2017-10-01-on-spherical-trigonometry/](http://www.robingilbert.com/blog/2017-10-01-on-spherical-trigonometry/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Calculate the Distance Between Two GPS Points with Python (Vincenty’s Inverse
    Formula)* ([https://nathanrooy.github.io/posts/2016-12-18/vincenty-formula-with-python/](https://nathanrooy.github.io/posts/2016-12-18/vincenty-formula-with-python/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Vectorization and parallelization in Python with NumPy and pandas* ([https://datascience.blog.wzb.eu/2018/02/02/vectorization-and-parallelization-in-python-with-numpy-and-pandas/](https://datascience.blog.wzb.eu/2018/02/02/vectorization-and-parallelization-in-python-with-numpy-and-pandas/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Behind the scenes of the Data Privacy Firewall* ([https://docs.microsoft.com/en-us/power-query/dataprivacyfirewall](https://docs.microsoft.com/en-us/power-query/dataprivacyfirewall))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
