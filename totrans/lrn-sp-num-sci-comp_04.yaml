- en: Chapter 4. SciPy for Numerical Analysis
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章：SciPy数值分析
- en: Practically all the different areas of numerical analysis are contemplated in
    some SciPy module. For example, in order to compute values of special functions,
    we use the `scipy.special` module. The `scipy.interpolate` module takes care of
    interpolation, extrapolation, and regression. For optimization, we have the `scipy.optimize`
    module, and finally, we have the `scipy.integrate` module for numerical evaluation
    of integrals. This last module serves as the interface to perform numerical solutions
    of ordinary differential equations as well.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有数值分析的各个领域都在某些SciPy模块中得到了考虑。例如，为了计算特殊函数的值，我们使用`scipy.special`模块。`scipy.interpolate`模块负责插值、外推和回归。对于优化，我们有`scipy.optimize`模块，最后，我们还有`scipy.integrate`模块用于数值积分。这个最后的模块还作为执行常微分方程数值解的接口。
- en: Thus, in this chapter, we will first extensively explore how to use SciPy to
    numerically evaluate the special functions that are commonly found in the field
    of mathematical physics. Then, we will discuss the modules available in SciPy
    to tackle regression, interpolation, and optimization problems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将首先广泛探讨如何使用SciPy来数值评估在数学物理领域常见的特殊函数。然后，我们将讨论SciPy中可用于处理回归、插值和优化问题的模块。
- en: The chapter ends with a solution of the chaotic Lorenz system as an illustration
    of the capabilities included in SciPy to find numerical solutions of ordinary
    differential equations. The corresponding IPython Notebook will help you to try
    the functionalities of the modules involved in the computations and to modify
    each illustrative example according to your specific needs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以混沌洛伦兹系统的解为例，展示了SciPy在寻找常微分方程数值解方面的能力。相应的IPython Notebook将帮助您尝试涉及计算中的模块功能，并根据您的具体需求修改每个示例。
- en: The evaluation of special functions
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特殊函数的评估
- en: The `scipy.special` module contains numerically stable definitions of useful
    functions. Most often, the straightforward evaluation of a function at a single
    value is not very efficient. For instance, we would rather use a Horner scheme
    ([http://en.wikipedia.org/wiki/Horner%27s_method](http://en.wikipedia.org/wiki/Horner%27s_method))
    to find the value of a polynomial at a point than use the raw formula. The NumPy
    and SciPy modules ensure that this optimization is always guaranteed with the
    definition of all its functions, whether by means of Horner schemes or with more
    advanced techniques.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`scipy.special`模块包含有用函数的数值稳定定义。通常，直接在单个值上评估函数并不非常高效。例如，我们宁愿使用Horner方案（[http://en.wikipedia.org/wiki/Horner%27s_method](http://en.wikipedia.org/wiki/Horner%27s_method)）来找到多项式在一点的值，而不是使用原始公式。NumPy和SciPy模块确保通过定义所有函数始终保证这种优化，无论是通过Horner方案还是更高级的技术。'
- en: Convenience and test functions
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 便利性和测试函数
- en: All the convenience functions are designed to facilitate a computational environment
    where the user does not need to worry about relative errors. The functions seem
    to be pointless at first sight, but behind their codes, there are state-of-the-art
    ideas that offer faster and more reliable results.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 所有便利函数都是为了简化计算环境而设计的，用户不需要担心相对误差。这些函数乍一看似乎没有意义，但它们背后的代码中包含了最先进的思想，提供了更快、更可靠的结果。
- en: We have convenience functions beyond the ones defined in the NumPy libraries
    to find the solutions of trigonometric functions in degrees (`cosdg`, `sindg`,
    `tandg`, and `cotdg`); to compute angles in radians from their expressions in
    degrees, minutes, and seconds (`radian`); common powers (`exp2` for *2**x*, and
    `exp10` for *10**x*); and common functions for small values of the variable (`log1p`
    for *log(1 + x)*, `expm1` for *exp(x) - 1*, and `cosm1` for *cos(x) - 1*).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们除了在NumPy库中定义的函数之外，还有便利函数来找到以度为单位（`cosdg`、`sindg`、`tandg`和`cotdg`）的三角函数的解；从度、分、秒的表达式计算弧度（`radian`）；常见的幂（`exp2`用于*2**x*，`exp10`用于*10**x*）；以及针对变量小值的常见函数（`log1p`用于*log(1
    + x)*，`expm1`用于*exp(x) - 1*，`cosm1`用于*cos(x) - 1*）。
- en: 'For instance, in the following code snippet, `the log1p` function computes
    the natural logarithm of *1 + x*. Why not simply add 1 to the value of *x* and
    then take the logarithm instead? Let''s compare:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在下面的代码片段中，`log1p`函数计算*1 + x*的自然对数。为什么不是简单地将*1*加到*1*的值上，然后再取对数呢？让我们比较一下：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output is as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now let''s use `log1p()` on `a`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在`a`上使用`log1p()`函数：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output is as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: While the absolute error of the first computation is small, the relative error
    is 100 percent.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然第一次计算的绝对误差很小，但相对误差是100%。
- en: In the same way as Lena image is regarded as the performance test in image processing,
    we have a few functions that are used to test different algorithms in different
    scenarios.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与Lena图像被视为图像处理中的性能测试一样，我们有一些函数用于在不同的场景中测试不同的算法。
- en: 'For instance, it is customary to test minimization codes against the Rosenbrock''s
    banana function ([http://en.wikipedia.org/wiki/Rosenbrock_function](http://en.wikipedia.org/wiki/Rosenbrock_function)):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，通常我们会用Rosenbrock的香蕉函数（[http://en.wikipedia.org/wiki/Rosenbrock_function](http://en.wikipedia.org/wiki/Rosenbrock_function)）来测试最小化代码：
- en: '![Convenience and test functions](img/7702OS_04_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![便利性和测试函数](img/7702OS_04_01.jpg)'
- en: The corresponding optimization module, `scipy.optimize`, has a routine to accurately
    evaluate this function (`rosen`), its derivative (`rosen_der`), its **Hessian**
    matrix (`rosen_hess`), or the product of the latter with a vector (`rosen_hess_prod`).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的优化模块`scipy.optimize`有一个例程可以准确评估这个函数（`rosen`），其导数（`rosen_der`），其**Hessian**矩阵（`rosen_hess`），或者后者的向量乘积（`rosen_hess_prod`）。
- en: Univariate polynomials
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单变量多项式
- en: Polynomials are defined in SciPy as a NumPy class, `poly1d`. This class has
    a handful of methods associated to compute the coefficients of the polynomial
    (`coeffs` or simply `c`), to compute the roots of the polynomial (`r`), to compute
    its derivative (`deriv`), to compute the symbolic integral (`integ`), and to obtain
    the degree (`order` or simply `o`), as well as a method (`variable`) that provides
    a string holding the name of the variable we would like to use in the proper definition
    of the polynomial (see the example involving `P2`).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在SciPy中，多项式被定义为NumPy类`poly1d`。这个类有几个方法与多项式相关联，用于计算多项式的系数（`coeffs`或简单地`c`），计算多项式的根（`r`），计算其导数（`deriv`），计算其符号积分（`integ`），以及获取其度数（`order`或简单地`o`），以及一个方法（`variable`），它提供了一个字符串，表示我们希望在多项式的正确定义中使用该变量的名称（参见涉及`P2`的示例）。
- en: 'In order to define a polynomial, we must indicate either its coefficients or
    its roots:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义一个多项式，我们必须指明其系数或其根：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output is as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now let''s find roots, order, and derivative of `P1`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们找到`P1`的根、阶数和导数：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output is as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s use the `poly1d` class:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`poly1d`类：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output is as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s use the `poly1d` class with the `variable` method:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`poly1d`类和`variable`方法：
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output is as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE11]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We may evaluate polynomials by treating them either as (vectorized) functions,
    or with the `__call__ method`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将多项式视为（向量化）函数或使用`__call__方法`来评估多项式：
- en: '[PRE12]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output is as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE13]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s issue the `__call__` command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们发出`__call__`命令：
- en: '[PRE14]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output is as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE15]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'An immediate application of these ideas is to verify the computation of the
    natural logarithm of *1 + x* used in the preceding example . When *x* is close
    to zero, the natural logarithm can be approximated by the following formula:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些想法的一个直接应用是验证前一个例子中使用的*1 + x*的自然对数的计算。当*x*接近零时，自然对数可以用以下公式近似：
- en: '![Univariate polynomials](img/7702OS_04_02.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![单变量多项式](img/7702OS_04_02.jpg)'
- en: 'This expression can be entered and evaluated in Python using the ideas just
    presented, as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式可以用Python使用前面提到的想法输入并评估，如下所示：
- en: '[PRE16]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output is as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE17]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s have a look on the value stored in variable `a`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看变量`a`中存储的值：
- en: '[PRE18]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output for value stored in `a` is as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在`a`中的值的输出如下：
- en: '[PRE19]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We now use `Px` (which contains one-dimensional polynomial form) on `a` in
    the following line of code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在以下代码行中使用`Px`（包含一维多项式形式）在`a`上：
- en: '[PRE20]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output is as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE21]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The result is the same as that obtained before using the SciPy function `scipy.special.log1p`,
    which verifies the computation.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 结果与之前使用SciPy函数`scipy.special.log1p`得到的结果相同，这验证了计算的正确性。
- en: 'There are also a few routines associated with polynomials: `roots` (to compute
    zeros), `polyder` (to compute derivatives), `polyint` (to compute integrals),
    `polyadd` (to add polynomials), `polysub` (to subtract polynomials), `polymul`
    (to multiply polynomials), `polydiv` (to perform polynomial division), `polyval`
    (to evaluate polynomials), and `polyfit` (to compute the best fit polynomial of
    certain order for two given arrays of data).'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与多项式相关的一些例程包括：`roots`（计算零点），`polyder`（计算导数），`polyint`（计算积分），`polyadd`（加多项式），`polysub`（减多项式），`polymul`（乘多项式），`polydiv`（多项式除法），`polyval`（评估多项式），以及
    `polyfit`（计算两个给定数据数组的最佳拟合多项式）。
- en: 'The usual binary operators +, -, *, and / perform the corresponding operations
    with polynomials. In addition, once a polynomial is created, any list of values
    that interacts with them is immediately casted to a polynomial. Therefore, the
    following four commands are equivalent:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 常用的二元运算符 +, -, * 和 / 对多项式执行相应的操作。此外，一旦创建了一个多项式，任何与之交互的值列表都会立即转换为多项式。因此，以下四个命令是等价的：
- en: '[PRE22]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output for the preceding lines of code is as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码行的输出如下：
- en: '[PRE23]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s take a look at the following `print()` command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下面的 `print()` 命令：
- en: '[PRE24]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE25]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s take a look at the following `print()` command:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下面的 `print()` 命令：
- en: '[PRE26]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output is as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE27]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s take a look at the following `print()` command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下面的 `print()` 命令：
- en: '[PRE28]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output is as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE29]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s take a look at the following `print()` command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下面的 `print()` 命令：
- en: '[PRE30]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output is as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE31]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Note how the polynomial division offers both the quotient and reminder values,
    for example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意多项式除法提供了商和余数值，例如：
- en: '[PRE32]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output is as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE33]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This can also be written as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以写成以下形式：
- en: '![Univariate polynomials](img/7702OS_04_03.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![一元多项式](img/7702OS_04_03.jpg)'
- en: A family of polynomials is said to be orthogonal with respect to an inner product
    if for any two polynomials in the family, their inner product is zero. Sequences
    of these functions are used as the backbone of extremely fast algorithms of quadrature
    (for numerical integration of general functions). The `scipy.special` module contains
    the `poly1d` definitions and allows fast evaluation of the families of orthogonal
    polynomials, such as **Legendre** (`legendre`), **Chebyshev** (`chebyt`, `chebyu`,
    `chebyc`, and `chebys`), **Jacobi** (`jacobi`), **Laguerre** and its generalized
    version (`laguerre` and `genlaguerre`), **Hermite** and its normalized version
    (`hermite` and `hermitenorm`), and **Gegenbauer** (`gegenbauer`). There are also
    shifted versions of some of them, such as `sh_legendre`, `sh_chebyt`, and so on.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个多项式族相对于内积正交，那么该族中的任意两个多项式的内积为零。这些函数的序列被用作快速求积算法（用于一般函数的数值积分）的骨干。`scipy.special`
    模块包含了 `poly1d` 定义，并允许快速评估正交多项式族，例如**勒让德** (`legendre`)，**切比雪夫** (`chebyt`, `chebyu`,
    `chebyc`, 和 `chebys`)，**雅可比** (`jacobi`)，**拉格朗日**及其推广版本 (`laguerre` 和 `genlaguerre`)，**厄米特**及其归一化版本
    (`hermite` 和 `hermitenorm`)，以及**根式** (`gegenbauer`)。还有一些它们的平移版本，例如 `sh_legendre`，`sh_chebyt`
    等。
- en: 'The usual evaluation of polynomials can be improved for orthogonal polynomials,
    thanks to their rich mathematical structure. In such cases, we never evaluate
    them with the generic call methods presented previously. Instead, we employ the
    `eval_` syntax. For example, we use the following command for Jacobi polynomials:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于正交多项式，由于其丰富的数学结构，通常的多项式评估可以得到改进。在这种情况下，我们永远不会使用之前介绍的通用调用方法来评估它们。相反，我们使用 `eval_`
    语法。例如，我们使用以下命令来评估雅可比多项式：
- en: '[PRE34]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In order to obtain the graph of the Jacobi polynomial of order `n = 3` for
    `alpha = 0` and `beta = 1`, for a thousand values of `x` uniformly spaced from
    -1 to 1, we could issue the following commands:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得 `alpha = 0` 和 `beta = 1` 的三阶雅可比多项式在 -1 到 1 之间均匀分布的一千个 `x` 值的图形，我们可以发出以下命令：
- en: '[PRE35]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output is as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Univariate polynomials](img/7702OS_04_04.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![一元多项式](img/7702OS_04_04.jpg)'
- en: The gamma function
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 欧拉函数
- en: The gamma function is a logarithmic, convex, smooth function operating on complex
    numbers, which interpolates the factorial function for all nonnegative integers.
    It is not defined at zero or any negative integer. This is the most common special
    function and is widely used in many different applications, either by itself or
    as the main ingredient in the definition of many other functions. The gamma function
    is used in diverse fields such as quantum physics, astrophysics, statistics, and
    fluid dynamics.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 伽玛函数是一个对数、凸、光滑的复数函数，它对所有非负整数插值了阶乘函数。它在零或任何负整数处未定义。这是最常见的特殊函数，广泛应用于许多不同的应用中，要么单独使用，要么作为许多其他函数定义中的主要成分。伽玛函数在量子物理、天体物理、统计学和流体动力学等众多领域得到应用。
- en: 'The gamma function is defined by the improper integral, as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 伽玛函数由以下的不定积分定义：
- en: '![The gamma function](img/7702OS_04_05.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![伽玛函数](img/7702OS_04_05.jpg)'
- en: Evaluation of gamma at integer values gives shifted factorials, and that is
    precisely how the factorials are coded in SciPy.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在整数值处评估伽玛函数给出移位阶乘，这正是SciPy中阶乘函数编码的方式。
- en: 'The `scipy.special` module has algorithms to obtain a fast evaluation of the
    gamma function at any permissible value. It also contains routines to perform
    evaluation of the most common compositions of the gamma functions appearing in
    the literature: `gammaln` for the natural logarithm of the absolute value of gamma,
    `rgamma` for the value one over gamma, `beta` for quotients, and `betaln` for
    the natural logarithm of the latter. We also have implementations of the logarithm
    of its derivative (`psi`).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`scipy.special`模块包含算法，可以快速评估伽玛函数在任意允许值处的值。它还包含执行文献中出现的伽玛函数最常见组合的评估例程：`gammaln`用于伽玛绝对值的自然对数，`rgamma`用于伽玛的倒数，`beta`用于商，`betaln`用于后者的自然对数。我们还实现了其导数的对数（`psi`）的实现。'
- en: 'An obvious application of gamma functions is the ability to perform computations
    that are virtually impossible for a computer if approached in a direct way. For
    instance, in statistical applications we often work with ratios of factorials.
    If these factorials are too large for the precision of a computer, we resort to
    expressions involving their logarithms instead. Even then, computing *ln(a! /
    b!)* can prove to be an impossible task (try, for example, with *a = 10**15* and
    *b = a - 10**10*). An elegant solution uses the digamma function `psi` by an application
    of the mean value theorem on the `ln(gamma(x))` function. With proper estimation,
    we obtain the excellent approximation (for this case of choice of *a* and *b*):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 伽玛函数的一个明显应用是能够执行如果直接进行将几乎不可能由计算机完成的计算。例如，在统计应用中，我们经常处理阶乘的比率。如果这些阶乘对于计算机的精度来说太大，我们就求助于涉及它们的对数的表达式。即使如此，计算*ln(a!
    / b!)*也可能是一项不可能的任务（例如，用*a = 10**15*和*b = a - 10**10*尝试）。一个优雅的解决方案是使用狄利克雷函数`psi`，通过在`ln(gamma(x))`函数上应用平均值定理。通过适当的估计，我们获得了出色的近似（对于这个选择的*a*和*b*的情况）：
- en: '![The gamma function](img/7702OS_04_06.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![伽玛函数](img/7702OS_04_06.jpg)'
- en: 'Let''s take a look at the following code snippet:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下代码片段：
- en: '[PRE36]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output is as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE37]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The Riemann zeta function
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 黎曼ζ函数
- en: 'The Riemann zeta function is very important in analytic number theory and has
    applications in physics and the probability theory as well. It computes the p-series
    for any complex value *p*:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 黎曼ζ函数在解析数论中非常重要，并在物理学和概率论中也有应用。它计算任何复值*p*的p级数：
- en: '![The Riemann zeta function](img/7702OS_04_07.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![黎曼ζ函数](img/7702OS_04_07.jpg)'
- en: 'The definition coded in SciPy allows a more flexible generalization of this
    function, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy中编码的定义允许对这个函数进行更灵活的推广，如下所示：
- en: '![The Riemann zeta function](img/7702OS_04_08.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![黎曼ζ函数](img/7702OS_04_08.jpg)'
- en: Among others, this function has applications in the field of particle physics
    and in dynamical systems ([http://en.wikipedia.org/wiki/Hurwitz_zeta_function](http://en.wikipedia.org/wiki/Hurwitz_zeta_function))
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在众多应用中，此函数在粒子物理和动力系统领域（[http://en.wikipedia.org/wiki/Hurwitz_zeta_function](http://en.wikipedia.org/wiki/Hurwitz_zeta_function)）也有应用。
- en: Airy and Bairy functions
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 艾里函数和贝里函数
- en: 'These are solutions of the Stokes equation and are obtained by solving the
    following differential equation:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是斯托克斯方程的解，通过求解以下微分方程获得：
- en: '![Airy and Bairy functions](img/7702OS_04_09.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![艾里函数和贝里函数](img/7702OS_04_09.jpg)'
- en: 'This equation has two linearly independent solutions, both of them defined
    as an improper integral for real values of the independent variable. The `airy`
    command computes both functions (`Ai` and `Bi`) as well as their corresponding
    derivatives (`Aip` and `Bip`, respectively). In the following code, we take advantage
    of the `contourf` command in `matplotlib.pyplot` to present an image of the real
    part of the output of the Bairy function `Bi` for an array of 801 x 801 complex
    values uniformly spaced in the square from *-4 - 4j* to *4 + 4j*. We also offer
    this graph as a surface plot using the `mplot3d` module of `mpl_toolkits`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方程有两个线性无关的解，它们都定义为独立变量的实数值的不定积分。`airy` 命令计算这两个函数（`Ai` 和 `Bi`）以及它们相应的导数（`Aip`
    和 `Bip`，分别）。在下面的代码中，我们利用 `matplotlib.pyplot` 中的 `contourf` 命令展示了一个 801 x 801 的复数值数组在从
    *-4 - 4j* 到 *4 + 4j* 的正方形内均匀分布的 Bairy 函数 `Bi` 输出的实部图像。我们还提供这个图作为使用 `mpl_toolkits`
    的 `mplot3d` 模块的三维表面图：
- en: '[PRE38]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output is as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Airy and Bairy functions](img/7702OS_04_10.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![Airy 和 Bairy 函数](img/7702OS_04_10.jpg)'
- en: The Bessel and Struve functions
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 贝塞尔和斯特夫函数
- en: '**Bessel** functions are both of the canonical solutions to Bessel''s homogeneous
    differential equation:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**贝塞尔**函数是贝塞尔齐次微分方程的规范解：'
- en: '![The Bessel and Struve functions](img/7702OS_04_11.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![贝塞尔和斯特夫函数](img/7702OS_04_11.jpg)'
- en: 'These equations arise naturally in the solution of Laplace''s equation in cylindrical
    coordinates. The solutions of the non-homogeneous Bessel differential equation
    shown in the following diagram are called **Struve** functions:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方程在圆柱坐标系中拉普拉斯方程的解中自然出现。以下图中非齐次贝塞尔微分方程的解被称为**斯特夫**函数：
- en: '![The Bessel and Struve functions](img/7702OS_04_12.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![贝塞尔和斯特夫函数](img/7702OS_04_12.jpg)'
- en: In either case, the order of the equation is the complex number `alpha` which
    acts as a parameter. Depending on the canonical solution and the order, the Bessel
    and Struve functions are addressed (and computed) differently.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，方程的顺序是复数 `alpha`，它作为一个参数。根据规范解和顺序，贝塞尔和斯特夫函数的处理（和计算）方式不同。
- en: 'For Bessel functions, we have algorithms to produce Bessel functions of the
    first kind (`jv`) and second kind (`yn` and `yv`), Hankel functions of the first
    and second kind (`hankel1` and `hankel2`), and the modified Bessel functions of
    the first and second kind (`iv`, `kn`, and `kv`). Their syntax is similar in all
    cases: first parameter is the order and second parameter the independent variable.
    The component *n* in the definition indicates that an integer is to be used as
    the order (since they are optimally coded for that situation):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于贝塞尔函数，我们有算法来生成第一类贝塞尔函数（`jv`）和第二类贝塞尔函数（`yn` 和 `yv`），第一类和第二类汉克尔函数（`hankel1`
    和 `hankel2`），以及第一类和第二类的修正贝塞尔函数（`iv`，`kn` 和 `kv`）。它们的语法在所有情况下都是相似的：第一个参数是阶数，第二个参数是独立变量。定义中的
    *n* 组件表示要使用整数作为阶数（因为它们针对这种情况进行了优化编码）：
- en: '[PRE39]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output is as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE40]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `scipy.special` module also contains fast versions of the most common Bessel
    functions (those of orders 0 and 1): `j0(x)`, `j1(x)` (first kind `y0(x)`and second
    kind `y1(x)`), and so on. There are definitions of the spherical Bessel functions,
    such as `sph_jn(n,z)` and `sph_yn(z)`; the Riccati-Bessel functions, such as `riccati_jn(n,x)`
    and `riccati_yn(n,x)`; and derivatives of all the basic ones, such as `jvp`, `yvp`,
    `kvp`, `ivp`, `h1vp`, and `h2vp`.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`scipy.special` 模块还包含最常见的贝塞尔函数的快速版本（阶数为 0 和 1 的那些）：`j0(x)`，`j1(x)`（第一类 `y0(x)`
    和第二类 `y1(x)`），等等。有球面贝塞尔函数的定义，如 `sph_jn(n,z)` 和 `sph_yn(z)`；里卡提-贝塞尔函数，如 `riccati_jn(n,x)`
    和 `riccati_yn(n,x)`；以及所有基本函数的导数，如 `jvp`，`yvp`，`kvp`，`ivp`，`h1vp` 和 `h2vp`。'
- en: For Struve functions, we have fast algorithms to compute solutions of the differential
    equation of order *v*:(`struve(v,x)` and `modstruve(v,x)`).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于斯特夫函数，我们有快速算法来计算阶数为 *v* 的微分方程的解：（`struve(v,x)` 和 `modstruve(v,x)`）。
- en: Other special functions
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他特殊函数
- en: There are more special functions included in the `scipy.special` module that
    are of great use in many applications in both pure and applied mathematics. An
    exhaustive list would be too large for the scope of this chapter, and I encourage
    you to use the different utilities for each set of special functions. Among the
    most interesting ones, we have elliptic functions, **Gauss hypergeometric functions**,
    **parabolic cylinder functions**, **Mathieu functions**, **spheroidal wave functions**,
    and **Kelvin functions**.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`scipy.special` 模块中包含更多特殊函数，这些函数在纯数学和应用数学的许多应用中非常有用。由于篇幅限制，本章不可能列出详尽的列表，我鼓励您使用每个特殊函数集的不同实用工具。其中最有趣的一些包括椭圆函数、**高斯超几何函数**、**抛物柱面函数**、**Mathieu函数**、**球面波函数**和**Kelvin函数**。'
- en: Interpolation
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插值
- en: Interpolation is a basic method in numerical computation that is obtained from
    a discrete set of data points, intended to find an interpolation function which
    represents some higher order structure that contains the data. The best known
    example is the interpolation of a sequence of points (*x_k* and *y_k*) in a plane
    to obtain a curve that goes through all the points in the order dictated by the
    sequence.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 插值是数值计算中的一个基本方法，它从一组离散的数据点中获得，目的是找到一个插值函数，该函数代表包含数据的某些更高阶结构。最著名的例子是将平面上一系列点（*x_k*
    和 *y_k*）进行插值，以获得一条通过序列顺序指定的所有点的曲线。
- en: If the points in the previous sequence are in the right position and order,
    it is possible to find a univariate function *y = f(x)* for which *y_k = f(x_k)*.
    It is often reasonable to request this interpolating function to be a polynomial,
    or a rational function, or a more complex functional object. Interpolation is
    also possible in higher dimensions, of course. The objective of the `scipy.interpolate`
    module is to offer a complete set of optimally coded applications to address this
    problem in different settings.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前一个序列中的点位置和顺序正确，则可以找到一个单变量函数 *y = f(x)*，使得 *y_k = f(x_k)*。通常合理地要求这个插值函数是一个多项式、有理函数或更复杂的函数对象。当然，插值也可以在更高维中进行。`scipy.interpolate`
    模块的目标是提供一套完整的、最优编码的应用程序，以解决在不同设置中的这个问题。
- en: 'Let''s address the easiest way of interpolating data to obtain a polynomial:
    lagrange interpolation. Given a sequence of different *x* values of size *n* and
    a sequence of arbitrary real values *y* of the same size *n*, we seek a polynomial
    *p(x)* of the degree of *n - 1* that satisfies the *n* constraints *p(x[k]) =
    y[k]* for all k from 0 to *n - 1*. The following code illustrates how to obtain
    a polynomial of degree 9 that interpolates the 10 uniformly spaced values of sine
    in the interval (-1, 1):'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看最简单的插值数据方法：拉格朗日插值。给定一个大小为 *n* 的不同 *x* 值序列和一个同样大小的任意实值序列 *y*，我们寻求一个 *n
    - 1* 次的多项式 *p(x)*，它满足所有从 0 到 *n - 1* 的 *n* 个约束条件 *p(x[k]) = y[k]*。以下代码演示了如何获得一个9次多项式，它插值了区间
    (-1, 1) 内的正弦函数的10个均匀分布的值：
- en: '[PRE41]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We will obtain the following `plot` showing the Lagrange interpolation:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将获得以下 `plot` 展示拉格朗日插值：
- en: '![Interpolation](img/7702OS_04_13.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![插值](img/7702OS_04_13.jpg)'
- en: There are numerous issues with Lagrange interpolation. The first obvious drawback
    is that the user cannot specify the degree of the interpolation; this depends
    solely on the data. The procedure is also highly unstable numerically, especially
    for datasets with size over 20 points. This issue can be addressed by allowing
    the algorithm to depend on different properties of the dataset, rather than just
    the size and location of the points.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 拉格朗日插值存在许多问题。第一个明显的缺点是用户不能指定插值的次数；这完全取决于数据。该过程在数值上也非常不稳定，特别是对于包含超过20个点的数据集。可以通过让算法依赖于数据集的不同属性来解决此问题，而不仅仅是点的数量和位置。
- en: 'Also, it is inconvenient when we need to update the dataset by adding a few
    more instances; the procedure needs to be repeated again from the beginning. This
    proves impractical if the datasets are increasing in size and are updated frequently.
    To address this issue, `BarycentricInterpolator` has the `add_xi` and `set_yi`
    methods. For example, in the next session we start by interpolating 10 uniformly
    spaced values of the sine function between 1 and 10\. Once done, we update the
    interpolating polynomial with 10 more uniformly spaced values between 1.5 and
    10.5\. As expected, this operation reduces the (percent) relative error of an
    interpolation computed at points within the interpolating ones. The following
    commands are used:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当我们需要通过添加一些更多实例来更新数据集时，这很不方便；必须从头开始重复该过程。如果数据集的大小不断增加且频繁更新，这证明是不切实际的。为了解决这个问题，`BarycentricInterpolator`具有`add_xi`和`set_yi`方法。例如，在下一个会话中，我们首先在1到10之间插值10个均匀分布的正弦函数值。完成后，我们使用1.5到10.5之间的10个更多均匀分布的值更新插值多项式。正如预期的那样，这个操作降低了在插值点内计算的（百分比）相对误差。以下命令被使用：
- en: '[PRE42]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here is the output for `exactValues`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`exactValues`的输出：
- en: '[PRE43]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let''s find the value of `interpolatedValues` by issuing following commands:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下命令来找到`interpolatedValues`的值：
- en: '[PRE44]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The output is as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE45]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s find the value of `PercentRelativeError` by issuing following commands:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下命令来找到`PercentRelativeError`的值：
- en: '[PRE46]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The output is as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE47]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then, we find what `interpolatedValues2` holds:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们找出`interpolatedValues2`包含的内容：
- en: '[PRE48]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The output is as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE49]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Let''s find the value of `PercentRelativeError`, keeping in consideration `interpolatedValues2`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找到`PercentRelativeError`的值，同时考虑`interpolatedValues2`：
- en: '[PRE50]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The output is as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE51]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: It is possible to interpolate data not only by point location, but also with
    the derivatives at those locations. The `KroghInterpolator` command allows this
    by including repeated *x* values and indicating the location and successive derivatives
    in order on the corresponding *y* values.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅可以通过点位置进行数据插值，还可以通过这些位置处的导数进行插值。`KroghInterpolator`命令通过包含重复的*x*值并按顺序在相应的*y*值中指示位置和连续导数来实现这一点。
- en: 'For instance, if we desire to construct a polynomial that is zero at the origin,
    one at *x = 1*, two at *x = 2*, and has horizontal tangent lines at each of these
    three locations, we issue the following commands:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想要构造一个在原点为零、在*x = 1*处为一、在*x = 2*处为二，并且在每个这些三个位置处具有水平切线的一次多项式，我们将发出以下命令：
- en: '[PRE52]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This renders the following graph:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这生成了以下图表：
- en: '![Interpolation](img/7702OS_04_14.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![插值](img/7702OS_04_14.jpg)'
- en: More advanced one-dimensional interpolation is possible with piecewise polynomials
    (`PiecewisePolynomial`). This allows control over the degrees of different pieces
    as well as the derivatives at their intersections. Other interpolation options
    in the `scipy.interpolate` module are **PCHIP monotonic cubic interpolation**
    (`pchip`) or even **univariate splines** (`InterpolatedUnivariateSpline`).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分段多项式（`PiecewisePolynomial`）可以实现更高级的一维插值。这允许控制不同部分的次数以及它们交点处的导数。`scipy.interpolate`模块中的其他插值选项包括**PCHIP单调三次插值**（`pchip`）或甚至是**单变量样条**（`InterpolatedUnivariateSpline`）。
- en: 'Let''s examine an example with univariate splines. Its syntax is as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个单变量样条插值的例子来检查。其语法如下：
- en: '[PRE53]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `x` and `y` arrays contain dependent and independent data, respectively.
    The array `w` contains positive weights for spline fitting. The two-sequence `bbox`
    parameter specifies the boundary of the approximation interval. The last option
    indicates the degree of the smoothing polynomials (`k`).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`x`和`y`数组分别包含依赖数据和独立数据。数组`w`包含用于样条拟合的正权重。双序列`bbox`参数指定近似区间的边界。最后一个选项表示平滑多项式的次数（`k`）。'
- en: 'Suppose we want to interpolate five points as shown in the following example.
    These points are ordered by strictly increasing `x` values. We need to perform
    this interpolation with four cubic polynomials (one for every two consecutive
    points) in such a way that at least the first derivative of each two consecutive
    pieces agree on their intersection. We will proceed as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要插值以下示例中的五个点。这些点按严格递增的`x`值排序。我们需要以这种方式执行插值，使用四个三次多项式（每个两个连续点一个），使得每个两个连续部分的至少一阶导数在其交点上一致。我们将按以下步骤进行：
- en: '[PRE54]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This offers the following plot showing interpolation with univariate splines:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了以下展示使用单变量样条插值的图表：
- en: '![Interpolation](img/7702OS_04_15.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![插值](img/7702OS_04_15.jpg)'
- en: SciPy excels at interpolating in two-dimensional grids as well. It performs
    well with simple piecewise polynomials (`LinearNDInterpolator`), piecewise constants
    (`NearestNDInterpolator`), or more advanced splines (`BivariateSpline`). It is
    capable of carrying out spline interpolation on rectangular meshes in a plane
    (`RectBivariateSpline`) or on the surface of a sphere (`RectSphereBivariateSpline`).
    For unstructured data, besides the basic `scipy.interpolate.BivariateSpline`,
    it is capable of computing smooth approximations (`SmoothBivariateSpline`) or
    more involved weighted least-squares splines (`LSQBivariateSpline`).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy在二维网格插值方面表现出色。它与简单的分段多项式（`LinearNDInterpolator`）、分段常数（`NearestNDInterpolator`）或更高级的样条曲线（`BivariateSpline`）表现良好。它能够在平面上的矩形网格（`RectBivariateSpline`）或球面上的表面（`RectSphereBivariateSpline`）上执行样条插值。对于非结构化数据，除了基本的`scipy.interpolate.BivariateSpline`外，它还能够计算平滑近似（`SmoothBivariateSpline`）或更复杂的加权最小二乘样条曲线（`LSQBivariateSpline`）。
- en: 'The following code creates a 10 x 10 grid of uniformly spaced points in the
    square from (0, 0) to (9, 9), and evaluates the function `sin(x) * cos(y)` on
    the points. We use these points to create a `scipy.interpolate.BivariateSpline`
    and evaluate the resulting function on the square for all values:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建了一个从(0, 0)到(9, 9)的正方形内10 x 10的均匀分布点网格，并在这些点上评估函数`sin(x) * cos(y)`。我们使用这些点创建一个`scipy.interpolate.BivariateSpline`，并在正方形上对所有值评估得到的函数：
- en: '[PRE55]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The output is as follows, and it shows the interpolation of 2D data with bivariate
    splines:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下，它显示了使用二变量样条曲线对2D数据进行插值：
- en: '![Interpolation](img/7702OS_04_16.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![插值](img/7702OS_04_16.jpg)'
- en: Regression
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回归
- en: 'Regression is similar to interpolation. In this case, we assume that the data
    is imprecise, and we require an object of predetermined structure to fit the data
    as closely as possible. The most basic example is univariate polynomial regression
    to a sequence of points. We obtain that with the `polyfit` command, which we discussed
    briefly in the *Univariate polynomials* section of this chapter. For instance,
    if we want to compute the regression line in the least-squares sense for a sequence
    of 10 uniformly spaced points in the interval (0, *π*/2) and their values under
    the `sin` function, we will issue the following commands:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 回归与插值类似。在这种情况下，我们假设数据是不精确的，我们需要一个具有预定结构的对象来尽可能紧密地拟合数据。最基本的一个例子是将单变量多项式回归应用于一系列点。我们使用`polyfit`命令来获得这些，我们在本章的“单变量多项式”部分简要讨论了它。例如，如果我们想在区间(0,
    π/2)内计算10个均匀分布点的回归线，以及它们在`sin`函数下的值，我们将发出以下命令：
- en: '[PRE56]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This gives the following plot that shows linear regression with `polyfit`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了以下图表，显示了使用`polyfit`进行线性回归：
- en: '![Regression](img/7702OS_04_17.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![回归](img/7702OS_04_17.jpg)'
- en: 'Curve fitting is also possible with splines if we use the parameters wisely.
    For example, in the case of univariate spline fitting that we introduced before,
    we can play around with the weights, smoothing factor, the degree of the smoothing
    spline, and so on. If we want to fit a parabolic spline for the same data as the
    previous example, we could issue the following commands:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们明智地使用参数，曲线拟合也可以使用样条曲线。例如，在之前介绍的单变量样条曲线拟合的情况下，我们可以调整权重、平滑因子、平滑样条曲线的次数等。如果我们想为之前示例中的相同数据拟合一个抛物线样条曲线，我们可以发出以下命令：
- en: '[PRE57]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This gives the following graph that shows curve fitting with splines:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了以下图表，显示了使用样条曲线进行曲线拟合：
- en: '![Regression](img/7702OS_04_18.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![回归](img/7702OS_04_18.jpg)'
- en: 'For regression from the point of view of curve fitting, there is a generic
    routine: `curve_fit` in the `scipy.optimize` module. This routine minimizes the
    sum of squares of a set of equations using the **Levenberg-Marquardt** algorithm
    and offers a best fit from any kind of functions (not only polynomials or splines).
    The syntax is simple:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 从曲线拟合的角度来看回归，有一个通用的例程：`scipy.optimize`模块中的`curve_fit`。这个例程使用**Levenberg-Marquardt**算法最小化一组方程的平方和，并从任何类型的函数（而不仅仅是多项式或样条曲线）中提供最佳拟合。语法很简单：
- en: '[PRE58]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `f` parameter is a callable function that represents the function we seek,
    and `xdata` and `ydata` are arrays of the same length that contain the *x* and
    *y* coordinates of the points to be fit. The tuple `p0` holds an initial guess
    for the values to be found, and `sigma` is a vector of weights that could be used
    instead of the standard deviation of the data, if necessary.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`f` 参数是一个可调用的函数，代表我们寻求的函数，而 `xdata` 和 `ydata` 是相同长度的数组，包含要拟合的点 *x* 和 *y* 坐标。元组
    `p0` 包含要找到的值的初始猜测，而 `sigma` 是一个权重向量，必要时可以用作数据的标准差。'
- en: 'We will show its usage with a good example. We will start by generating some
    points on a section of a sine wave with amplitude `A=18`, angular frequency *w=3π*,
    and phase `h=0.5`. We corrupt the data in the array `y` with some small random
    noise:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一个很好的例子来展示其用法。我们首先将在正弦波的一部分生成一些点，振幅 `A=18`，角频率 *w=3π* 和相位 `h=0.5`。我们在数组
    `y` 中添加一些小的随机噪声来损坏数据：
- en: '[PRE59]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We want to estimate the values of `A`, `w`, and `h` from the corrupted data,
    hence technically finding a curve fit from the set of sine waves. We start by
    gathering the three parameters in a list and initializing them to some values,
    for example, `A = 20`, *w = 2π*, and `h = 1`. We also construct a callable expression
    of the target function (`target_function`):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望从损坏的数据中估计 `A`、`w` 和 `h` 的值，因此从正弦波集合中技术上找到一个曲线拟合。我们首先将三个参数收集到一个列表中，并将它们初始化为一些值，例如，`A
    = 20`、*w = 2π* 和 `h = 1`。我们还构建了一个目标函数的可调用表达式（`target_function`）：
- en: '[PRE60]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We feed these, together with the fitting data, to `curve_fit` in order to find
    the required values:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些内容以及拟合数据一起输入到 `curve_fit` 中，以找到所需值：
- en: '[PRE61]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'A sample of `pF` run on any of our experiments should give an accurate result
    for the three requested values:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的任何实验中运行 `pF` 的一个样本应该会给出三个请求值的准确结果：
- en: '[PRE62]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The output for the preceding command is as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 前述命令的输出如下：
- en: '[PRE63]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This means that `A` was estimated to about 18.14, `w` was estimated very close
    to 3*π*, and `h` was between 0.46 and 0.55\. The output of the initial data together
    with a computation of the sine wave is as follows, in which original data (in
    blue on the left-hand side graph), corrupted (in red in both graphs), and computed
    sine wave (in black in the right-hand side) are shown in following plots:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 `A` 的估计值约为 18.14，`w` 的估计值非常接近 3*π*，而 `h` 在 0.46 和 0.55 之间。以下是在后续图表中显示的原始数据（左侧图表左侧的蓝色）、损坏数据（两个图表中的红色）和计算的正弦波（右侧图表中的黑色）的输出，以及正弦波的计算：
- en: '![Regression](img/7702OS_04_19.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![回归](img/7702OS_04_19.jpg)'
- en: The code is too long to be included here. Instead, the full code (intermediate
    plots that are produced are not shown here) can be found in the corresponding
    electronic resource IPython Notebook for this chapter.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 代码过长，无法在此处包含。相反，完整的代码（此处未显示产生的中间图表）可以在本章对应的电子资源IPython Notebook中找到。
- en: Optimization
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化
- en: Optimization involves finding extreme values of functions or their roots. We
    have already seen the power of optimization in the curve-fitting arena, but it
    does not stop there. There are applications to virtually every single branch of
    engineering, and robust algorithms to perform these tasks are a must in every
    scientist's toolbox.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 优化涉及寻找函数的极值或其根。我们已经看到了优化在曲线拟合领域中的力量，但这并不止于此。它几乎应用于工程学的每一个分支，并且执行这些任务的鲁棒算法是每位科学家工具箱中的必备品。
- en: 'The `curve_fit` routine is actually syntactic sugar for the general algorithm
    that performs least-squares minimization, `leastsq`, with the imposing syntax:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`curve_fit` 例程实际上是执行最小二乘最小化的一般算法 `leastsq` 的语法糖，其具有如下强制的语法：'
- en: '[PRE64]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'For instance, the `curve_fit` routine could have been called with a `leastsq`
    call instead:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`curve_fit` 例程可以用 `leastsq` 调用来代替：
- en: '[PRE65]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Here, `error_function` is equal to `lambda p,x,y: target_function(x,p[0],p[1],p[2])-y`'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，`error_function` 等于 `lambda p,x,y: target_function(x,p[0],p[1],p[2])-y`'
- en: The implementation is given in the corresponding section on the IPython Notebook
    of this chapter. Most of the optimization routines in SciPy can be accessed from
    either native Python code, or as wrappers for Fortran or C classical implementations
    of their corresponding algorithms. Technically, we are still using the same packages
    we did under Fortran or C, but from within Python. For instance, the minimization
    routine that implements the truncated `Newton` method can be called with `fmin_ncg`
    (and this is purely Python) or as `fmin_tnc` (and this one is a wrap of a C implementation).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 实现细节在本书相应章节的IPython笔记本中给出。SciPy中的大多数优化例程都可以通过原生Python代码或作为相应算法的Fortran或C经典实现的包装器访问。技术上，我们仍在使用Fortran或C下使用的相同包，但现在是Python内部。例如，实现截断`Newton`方法的例程可以用`fmin_ncg`（这是纯Python）或作为`fmin_tnc`（这是一个C实现的包装器）调用。
- en: Minimization
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小化
- en: For general minimization problems, SciPy has many different algorithms. So far,
    we have covered the least-squares algorithm (`leastsq`), but we also have brute
    force (`brute`), **simulated annealing** (`anneal`), **Brent** or **Golden** methods
    for scalar functions (`brent` or `golden`), the **downhill simplex** algorithm
    (`fmin`), **Powell's** method (`fmin_powell`), **nonlinear conjugate gradient**
    or Newton's version of it (`fmin_cg`, `fmin_ncg`), and the **BFGS** algorithm
    (`fmin_bfgs`).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一般的优化问题，SciPy有许多不同的算法。到目前为止，我们已经涵盖了最小二乘算法（`leastsq`），但我们还有暴力搜索（`brute`）、**模拟退火**（`anneal`）、**Brent**或**Golden方法**（对于标量函数`brent`或`golden`）、**下降单纯形算法**（`fmin`）、**Powell方法**（`fmin_powell`）、**非线性共轭梯度**或其牛顿版本（`fmin_cg`、`fmin_ncg`），以及**BFGS算法**（`fmin_bfgs`）。
- en: Constrained minimization is also possible computationally, and SciPy has routines
    that implement the **L-BFGS-S** algorithm (`fmin_l_bfgs_s`), truncated Newton's
    algorithm (`fmin_tnc`), **COBYLA** (`fmin_cobyla`), or sequential least-squares
    programming (`fmin_slsqp`).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 约束最小化在计算上也是可能的，SciPy有实现**L-BFGS-S算法**（`fmin_l_bfgs_s`）、截断牛顿算法（`fmin_tnc`）、**COBYLA**（`fmin_cobyla`）或顺序最小二乘规划（`fmin_slsqp`）的程序。
- en: 'The following code, for example, compares the output of all different methods
    to finding a local minimum of the Rosenbrock function, `scipy.optimize.rosen`,
    near the origin using the downhill simplex algorithm:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码比较了使用下降单纯形算法在原点附近寻找Rosenbrock函数局部最小值的所有不同方法的输出：
- en: '[PRE66]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The output is as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE67]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Since the Version 0.11 of SciPy, all minimization routines can be called from
    the generic `scipy.optimize.minimize`, with the `method` parameter pointing to
    one of the strings, such as `Nelder-Mead` (for the downhill simplex), `Powell`,
    `CG`, `Newton-CG`, `BFGS`, or `anneal`. For constrained minimization, the corresponding
    strings are one of `L-BFGS-S`, `TNC` (for truncated Newton''s), `COBYLA`, or `SLSQP`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 自SciPy版本0.11以来，所有最小化例程都可以通过通用的`scipy.optimize.minimize`调用，其中`method`参数指向一个字符串，例如`Nelder-Mead`（用于下降单纯形）、`Powell`、`CG`、`Newton-CG`、`BFGS`或`anneal`。对于约束最小化，相应的字符串是`L-BFGS-S`、`TNC`（截断牛顿的）、`COBYLA`或`SLSQP`：
- en: '[PRE68]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Roots
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 根
- en: 'For most special functions included in the `scipy.specia`l module, we have
    accurate algorithms that allow us to their zeros. For instance, for the Bessel
    function of first kind with integer order, `jn_zeros`, offers as many roots as
    desired (in ascending order). We may obtain the first three roots of the Bessel
    J-function of order four by issuing the following command:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对于包含在`scipy.special`模块中的大多数特殊函数，我们有精确的算法，允许我们找到它们的零点。例如，对于整数阶的第一类贝塞尔函数，`jn_zeros`提供了所需数量的根（按升序排列）。我们可以通过以下命令获得四阶贝塞尔J函数的前三个根：
- en: '[PRE69]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The output is as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE70]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: For nonspecial scalar functions, the `scipy.optimize` module allows approximation
    to the roots through a great deal of different algorithms. For scalar functions,
    we have the **crude bisection** method (`bisect`), the **classical secant** method
    of **Newton-Raphson** (`newton`), and more accurate and faster methods such as
    **Ridders**' algorithm (`ridder`), and two versions of the Brent method (`brentq`
    and `brenth`).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非特殊标量函数，`scipy.optimize`模块允许通过大量不同的算法进行根的近似。对于标量函数，我们有**粗略的二分法**（`bisect`）、**牛顿-拉夫森的古典割线法**（`newton`），以及更精确和更快的算法，如**Ridders算法**（`ridder`）和两种Brent方法的版本（`brentq`和`brenth`）。
- en: 'Finding roots for functions of several variables is very challenging in many
    ways; the larger the dimension, the more difficult it is. The effectiveness of
    any of these algorithms depends on the problem, and it is a good idea to invest
    some time and resources in knowing them all. Since Version 0.11 of SciPy, it is
    possible to call any of the designed methods with the same routine `scipy.optimize.root`,
    which has the following syntax:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面寻找多个变量的函数的根是非常具有挑战性的；维度越大，越困难。任何这些算法的有效性都取决于问题，投入一些时间和资源去了解它们都是个好主意。自从SciPy的0.11版本以来，可以使用相同的例程`scipy.optimize.root`调用任何设计的方法，该例程的语法如下：
- en: '[PRE71]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The different methods are obtained upon changing the value of the `method` parameter
    to a method's string. We may choose from methods such as `'hybr'` for a modified
    hybrid Powell's method; `'lm'` for a modified least-squares method; `'broyden1'`
    or `'broyden2'` for Broyden's good and bad methods, respectively; `'diagbroyden'`
    for the diagonal Broyden Jacobian approximation; `'anderson'` for Anderson's extended
    mixing; `'Krylov'` for Krylov approximation of the Jacobian; `'linearmixing'`
    for scalar Jacobian approximation; and `'excitingmixing'` for a tuned diagonal
    Jacobian approximation.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 通过改变`method`参数的值到相应的方法字符串，可以得到不同的方法。我们可以选择如下方法：`'hybr'`用于改进的混合Powell方法；`'lm'`用于改进的最小二乘法；`'broyden1'`或`'broyden2'`分别用于Broyden的好方法和坏方法；`'diagbroyden'`用于对角Broyden雅可比近似；`'anderson'`用于Anderson扩展混合；`'Krylov'`用于雅可比的Krylov近似；`'linearmixing'`用于标量雅可比近似；以及`'excitingmixing'`用于调整的对角雅可比近似。
- en: For large-scale problems, both the Krylov approximation of the Jacobian or the
    Anderson extended mixing are usually the best options.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大规模问题，雅可比的Krylov近似或Anderson扩展混合通常是最佳选择。
- en: 'Let''s present an illustrative example of the power of these techniques. Consider
    the following system of differential equations:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来展示这些技术的能力。考虑以下微分方程组：
- en: '![Roots](img/7702OS_04_20.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![根](img/7702OS_04_20.jpg)'
- en: 'We use the plot routine quiver from the matplotlib.pyplot libraries to visualize
    a slope field for values of `x` and `y` between -0.5 and 2.5, and hence identify
    the location of the possible critical points in that region:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用matplotlib.pyplot库中的quiver绘图例程来可视化`x`和`y`在-0.5和2.5之间的斜率场，从而确定该区域中可能的临界点的位置：
- en: '[PRE72]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The output is as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Roots](img/7702OS_04_21.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![根](img/7702OS_04_21.jpg)'
- en: 'Note how there is a whole region of the plane in which the slopes are extremely
    small. Because of the degrees of the polynomials involved, there are at most four
    different possible critical points. In this area, we should be able to identify
    two such points (as a matter of fact there are only two noncomplex solutions).
    One of them seems to be near (0, 1) and the second one is near (2, 0). We use
    these two locations as initial guesses for our searches:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在平面上有一个区域，其斜率非常小。由于涉及的多项式的次数，最多有四个不同的可能临界点。在这个区域，我们应该能够识别出两个这样的点（实际上只有两个非复数解）。其中一个似乎在(0,
    1)附近，另一个在(2, 0)附近。我们使用这两个位置作为搜索的初始猜测：
- en: '[PRE73]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The output is as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE74]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Let''s look at second case:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看第二个案例：
- en: '[PRE75]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The output is as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE76]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: In the first case, we converged successfully to (-0.22221456, 0.99380842). In
    the second case, we converged to (1.90067673, 0.31121857). The routine gives us
    the details of the convergence and the properties of the approximation. For instance,
    `nfev` tells us about the number of function calls performed, and `fun` indicates
    the output of the function at the found location. The other items in the output
    reflect the matrices used in the procedure, such as `qtf`, `r`, and `fjac`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，我们成功收敛到(-0.22221456, 0.99380842)。在第二种情况下，我们收敛到(1.90067673, 0.31121857)。例程给出了收敛的细节和近似的性质。例如，`nfev`告诉我们执行了多少次函数调用，而`fun`表示在找到的位置的函数输出。输出中的其他项反映了在程序中使用的矩阵，如`qtf`、`r`和`fjac`。
- en: Integration
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 积分
- en: SciPy is capable of performing very robust numerical integration. Definite integrals
    of a set of special functions are evaluated accurately with routines in the `scipy.special`
    module. For other functions, there are several different algorithms to obtain
    reliable approximations in the `scipy.integrate` module.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy能够执行非常稳健的数值积分。使用`scipy.special`模块中的例程，可以准确地计算一组特殊函数的定积分。对于其他函数，`scipy.integrate`模块中有几种不同的算法可以获得可靠的近似。
- en: Exponential/logarithm integrals
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指数/对数积分
- en: 'A summary of the indefinite and definite integrals in the category of exponential/logarithm
    is presented here: the exponential integrals (`expn`, `expi`, and `exp1`), **Dawson''s**
    integral (`dawsn`), and **Gauss error functions** (`erf` and `erfc`). We also
    have **Spence''s** dilogarithm (also known as Spence''s integral). Let''s have
    a look at the following formulas:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在指数/对数类别的不定积分和定积分的总结如下：指数积分（`expn`、`expi`和`exp1`）、**道森**积分（`dawsn`）、**高斯**误差函数（`erf`和`erfc`）。我们还有**斯彭斯**双对数（也称为斯彭斯积分）。让我们看一下以下公式：
- en: '![Exponential/logarithm integrals](img/7702OS_04_22.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![指数/对数积分](img/7702OS_04_22.jpg)'
- en: Trigonometric and hyperbolic trigonometric integrals
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 三角函数和双曲三角函数积分
- en: 'In the category of trigonometric and hyperbolic trigonometric integrals, we
    have Fresnel sine and cosine integrals, as well as the sinc and hyperbolic trigonometric
    integrals. Let''s have a look at the following formulas:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在三角函数和双曲三角函数积分类别中，我们有菲涅耳正弦和余弦积分，以及 sinc 和双曲三角函数积分。让我们看一下以下公式：
- en: '![Trigonometric and hyperbolic trigonometric integrals](img/7702OS_04_23.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![三角函数和双曲三角函数积分](img/7702OS_04_23.jpg)'
- en: 'In the definitions given in the preceding list of integrals, the gamma symbol
    denotes the Euler-Mascheroni constant:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面列出的积分定义中，伽马符号表示欧拉-马斯刻若尼常数：
- en: '![Trigonometric and hyperbolic trigonometric integrals](img/7702OS_04_24.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![三角函数和双曲三角函数积分](img/7702OS_04_24.jpg)'
- en: Elliptic integrals
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 椭圆积分
- en: 'Elliptic integrals arise naturally when computing the arc length of ellipses.
    SciPy follows the argument notation for elliptic integrals: complete (one argument)
    and incomplete (two arguments). Let''s have a look at the following formulas:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算椭圆的弧长时，椭圆积分自然出现。SciPy遵循椭圆积分的参数表示法：完全（一个参数）和不完全（两个参数）。让我们看一下以下公式：
- en: '![Elliptic integrals](img/7702OS_04_25.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![椭圆积分](img/7702OS_04_25.jpg)'
- en: Gamma and beta integrals
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 伽马和贝塔积分
- en: 'In the category of gamma and beta integrals, we have one incomplete gamma function,
    one complemented incomplete gamma integral, and one incomplete beta integral.
    These are some of the most useful functions in this category. Let''s have a look
    at the following formulas:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在伽马和贝塔积分类别中，我们有一个不完全伽马函数、一个补全的不完全伽马积分和一个不完全贝塔积分。这些是这个类别中最有用的函数之一。让我们看一下以下公式：
- en: '![Gamma and beta integrals](img/7702OS_04_26.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![伽马和贝塔积分](img/7702OS_04_26.jpg)'
- en: Numerical integration
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数值积分
- en: 'For any other functions, we are content with approximating definite integrals
    with quadrature formulae, such as `quad` (adaptive quadrature), `fixed_quad` (fixed-order
    Gaussian quadrature), `quadrature` (fixed-tolerance Gaussian quadrature), and
    `romberg`, (Romberg integration). For functions with more than one variable, we
    have `dbquad` (double integral) and `tplquad` (triple integral) methods. The syntax
    in all cases is a variation of `quad`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何其他函数，我们满足于使用求积公式来近似定积分，如`quad`（自适应求积）、`fixed_quad`（固定阶数的Gauss求积）、`quadrature`（固定容差Gauss求积）和`romberg`（龙贝格积分）。对于多于一个变量的函数，我们有`dbquad`（双重积分）和`tplquad`（三重积分）方法。在所有情况下，语法都是`quad`的变体：
- en: '[PRE77]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'If we have samples instead of functions, we may use routines such as `trapz`,
    `cumtrapz` (composite trapezoidal rule and its cumulative version), `romb` (Romberg
    integration again), and `simps` (Simpson''s rule) instead. In these routines,
    the syntax is simpler and changes the order of the parameters. For example, this
    is how we call `simps`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有样本而不是函数，我们可以使用`trapz`、`cumtrapz`（复合梯形规则及其累积版本）、`romb`（再次使用龙贝格积分）和`simps`（辛普森规则）等例程。在这些例程中，语法更简单，并改变了参数的顺序。例如，这是调用`simps`的方式：
- en: '[PRE78]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Those of us familiar with the **QUADPACK** libraries will find similar syntax,
    usage, and performance.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉**QUADPACK**库的我们将会发现类似的语法、用法和性能。
- en: 'For extra information, run the `scipy.integrate.quad_explain()` command. In
    the IPython Notebook for this chapter, the alternative help command, `scipy.integrate.quad`,
    is executed and its output is displayed in the corresponding section. This explains
    with great detail all the different outputs of the quadrature integrals included
    in the module result, the estimation of absolute error and convergence, and explanation
    of the used weightings, if necessary. Let''s give at least one meaningful example
    where we integrate a special function and compare the output of a quadrature formula
    against the more accurate value of the routines given in `scipy.special`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 若需更多信息，请运行 `scipy.integrate.quad_explain()` 命令。在本章的 IPython Notebook 中，执行了替代的帮助命令
    `scipy.integrate.quad`，其输出显示在相应的部分。这以极大的详细程度解释了模块结果中包含的所有不同类型的数值积分输出，包括绝对误差的估计和收敛性，以及如果需要的话，对所使用的权重的解释。让我们至少举一个有意义的例子，其中我们积分一个特殊函数，并将求积公式的输出与
    `scipy.special` 中给出的更精确的例程值进行比较：
- en: '[PRE79]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The output is as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE80]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Let''s take a look at following `print` command:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下面的 `print` 命令：
- en: '[PRE81]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The output is as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE82]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Let''s look further into the code:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步查看代码：
- en: '[PRE83]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The output is as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE84]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'To use a routine that integrates from samples, we have the flexibility of assigning
    the frequency and length of the data. For the following problem, we could try
    with 10,000 samples in the same interval:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用从样本积分的例程，我们可以灵活地指定数据的频率和长度。对于以下问题，我们可以在相同区间尝试使用 10,000 个样本：
- en: '[PRE85]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The output is as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE86]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Ordinary differential equations
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常微分方程
- en: 'As with integration, SciPy has some extremely accurate general-purpose solvers
    for systems of ordinary differential equations of first order:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 与积分类似，SciPy 为一阶常微分方程组提供了一些非常精确的通用求解器：
- en: '![Ordinary differential equations](img/7702OS_04_27.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![常微分方程](img/7702OS_04_27.jpg)'
- en: 'For real-valued functions, we have basically two flavors: `ode` (with options
    passed with the `set_integrator` method) and `odeint` (simpler interface). The
    syntax of `ode` is as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实值函数，我们基本上有两种类型：`ode`（通过 `set_integrator` 方法传递选项）和 `odeint`（接口更简单）。`ode` 的语法如下：
- en: '[PRE87]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The first parameter, `f`, is the function to be integrated, and the second parameter,
    `jac`, refers to the matrix of partial derivatives with respect to the dependent
    variables (the Jacobian). This creates an `ode` object, with different methods
    to indicate the algorithm to solve the system (`set_integrator`), the initial
    conditions (`set_initial_value`), and different parameters to be sent to the function
    or its Jacobian.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数 `f` 是要积分的函数，第二个参数 `jac` 指的是关于依赖变量的偏导数矩阵（雅可比矩阵）。这创建了一个 `ode` 对象，具有不同的方法来指示解决系统的算法（`set_integrator`）、初始条件（`set_initial_value`）以及要发送给函数或其雅可比矩阵的不同参数。
- en: The options for integration algorithm are `'vode'` for real-valued variable
    coefficient ODE solver, with fixed-leading-coefficient implementation (it provides
    Adam's method for non-stiff problems and BDF for stiff); `'zvode'` for complex-valued
    variable coefficient ODE solver, with similar options as the preceding option;
    `'dopri5'` for a **Runge-Kutta** method of order (4)5; `'dop853'` for a Runge-Kutta
    method of order 8(5, 3).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 集成算法的选项有 `'vode'`，用于实值变量系数常微分方程求解器，具有固定领先系数实现（它为非刚性问题提供 Adam 方法，为刚性问题提供 BDF）；`'zvode'`，用于复值变量系数常微分方程求解器，具有与前一个选项类似的选择；`'dopri5'`，用于四阶（4）5
    阶的 Runge-Kutta 方法；`'dop853'`，用于八阶（5, 3）Runge-Kutta 方法。
- en: 'The next code snippet presents an example of usage of the `scipy.integrate.ode`
    to solve the initial value problem using the following formula:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段展示了使用 `scipy.integrate.ode` 解决初值问题的示例：
- en: '![Ordinary differential equations](img/7702OS_04_28.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![常微分方程](img/7702OS_04_28.jpg)'
- en: 'We compute each step sequentially and compare it with the actual solution,
    which is known. You will notice that virtually there is no difference:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按顺序计算每个步骤，并将其与已知的实际解进行比较，您将注意到实际上没有差异：
- en: '[PRE88]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Once run, the preceding code gives us the following output:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码后，我们得到以下输出：
- en: '[PRE89]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The full output is displayed on the corresponding section of the IPython Notebook
    for this chapter. For systems of differential equations of first order with complex-valued
    functions, we have a wrapper of `ode`, which we call with the `complex_ode` command.
    Syntax and usage are similar to those of `ode`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的输出显示在本章IPython笔记本的相应部分。对于具有复值函数的一阶微分方程组，我们有一个`ode`的包装器，我们用`complex_ode`命令调用它。语法和用法与`ode`类似。
- en: 'The syntax of `odeint` is much more intuitive, and more Python friendly:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`odeint`的语法更加直观，并且更符合Python风格：'
- en: '[PRE90]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The most impressive part of this routine is that one is able to indicate not
    only the Jacobian, but also whether this is banded and how many nonzero diagonals
    are under or over the main diagonal we have (with the `ml` and `mu` options).
    This speeds up computations by a huge factor. Another amazing feature of `odeint`
    is the possibility to indicate critical points for the integration (`tcrit`).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例程最令人印象深刻的部分是，不仅可以指示雅可比矩阵，还可以指示这是否是带状矩阵以及有多少非零对角线位于主对角线之下或之上（使用`ml`和`mu`选项）。这可以大幅提高计算速度。`odeint`的另一个惊人特性是能够指示积分的临界点（`tcrit`）。
- en: We will now introduce an application to analyze Lorentz attractors with the
    routines presented in this section.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将介绍一个应用，使用本节中介绍的例程来分析洛伦兹吸引子。
- en: Lorenz attractors
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 洛伦兹吸引子
- en: No book on scientific computing is complete without revisiting Lorenz attractors;
    SciPy excels both at computation of solutions and presentation of ideas based
    upon systems of differential equations, of course, and we will show how and why
    in this section.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一本关于科学计算的书籍是不回顾洛伦兹吸引子的；SciPy在计算解和基于微分方程组的想法展示方面都非常出色，我们将在本节中展示如何以及为什么。
- en: 'Consider a two-dimensional fluid cell that is heated from underneath and cooled
    from above, much like what occurs with the Earth''s atmosphere. This creates convection
    that can be modeled by a single partial differential equation, for which a decent
    approximation has the form of the following system of ordinary differential equations:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个二维流体单元，从底部加热并从顶部冷却，这与地球大气层中发生的情况非常相似。这会产生可以通过单个偏微分方程建模的对流，对于这个方程，一个合理的近似形式是以下常微分方程组：
- en: '![Lorenz attractors](img/7702OS_04_29.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![洛伦兹吸引子](img/7702OS_04_29.jpg)'
- en: The variable *x* represents the rate of convective overturning. The variables
    *y* and *z* stand for the horizontal and vertical temperature variations, respectively.
    This system depends on four physical parameters, the descriptions of which are
    far beyond the scope of this book. The important point is that we may model Earth's
    atmosphere with these equations, and in that case a good choice for the parameters
    is given by `sigma = 10.0`, and `b = 8/3.0`. For certain values of the third parameter,
    we have systems for which the solutions behave chaotically. Let's explore this
    effect with the help of SciPy.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 变量*x*代表对流翻转速率。变量*y*和*z*分别代表水平和垂直温度变化。这个系统依赖于四个物理参数，它们的描述远远超出了本书的范围。重要的是，我们可以用这些方程来模拟地球大气层，在这种情况下，参数的一个好选择是`sigma
    = 10.0`和`b = 8/3.0`。对于第三参数的某些值，我们有一些解表现出混沌行为的系统。让我们在SciPy的帮助下探索这个效应。
- en: 'In the following code snippet, we will use one of the solvers in the `scipy.integrate`
    module as well as the plotting utilities:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，我们将使用`scipy.integrate`模块中的一个求解器以及绘图工具：
- en: '[PRE91]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Let''s choose a time interval `t` large enough with a sufficiently dense partition
    and any initial condition, `y0`. Then, issue the following commands:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们选择一个足够大且足够密集的时间间隔`t`，以及任何初始条件`y0`。然后，执行以下命令：
- en: '[PRE92]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'If we want to plot a 3D rendering of the solution obtained, we can do so as
    follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要绘制所获得解的3D渲染图，可以按照以下方式操作：
- en: '[PRE93]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'This produces the following graph that shows a Lorenz attractor:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下图表，展示了洛伦兹吸引子：
- en: '![Lorenz attractors](img/7702OS_04_30.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![洛伦兹吸引子](img/7702OS_04_30.jpg)'
- en: 'This is most illustrative and shows precisely the chaotic behavior of the solutions.
    Let''s observe the fluctuations of the vertical temperature in detail, along with
    the fluctuation of horizontal temperature against vertical. Issue the following
    commands:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最具说明性的，精确地展示了解的混沌行为。让我们详细观察垂直温度的波动，以及与垂直温度相比的水平温度波动。执行以下命令：
- en: '[PRE94]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'This produces the following the plots that show vertical temperature with respect
    to time (left-hand side plot) and horizontal versus vertical temperature (right-hand
    side plot):'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生了以下图表，展示了垂直温度随时间的变化（左侧图表）以及水平与垂直温度的关系（右侧图表）：
- en: '![Lorenz attractors](img/7702OS_04_31.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![洛伦兹吸引子](img/7702OS_04_31.jpg)'
- en: Summary
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter explored special functions, integration, interpolation, and optimization
    through the corresponding modules (`special`, `integrate`, `interpolate`, and
    `optimize`), as well as discussed solutions of systems of ordinary differential
    equations.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过相应的模块（`special`、`integrate`、`interpolate`和`optimize`）探讨了特殊函数、积分、插值和优化，并讨论了常微分方程组的解法。
- en: In [Chapter 5](ch05.html "Chapter 5. SciPy for Signal Processing"), *SciPy for
    Signal Processing*, we will describe the functionality of SciPy modules to analyze
    processes involving time series and spatial signals, including how to perform
    on numerical data the discrete Fourier transform, how to construct signals, how
    to apply filters on data, and how to interpolate images.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.html "第5章。SciPy信号处理")《SciPy信号处理》中，我们将描述SciPy模块的功能，用于分析涉及时间序列和空间信号的过程，包括如何在数值数据上执行离散傅里叶变换、如何构建信号、如何对数据进行滤波以及如何插值图像。
