["```py\nimport random\nimport pyagg\nimport PIL, PIL.Image\n```", "```py\nfrom . import renderer\n```", "```py\nclass LayerGroup:\n    def __init__(self):\n        self.layers = list()\n        self.connected_maps = list()\n\n    def __iter__(self):\n        for layer in self.layers:\n            yield layer\n\n    def add_layer(self, layer):\n        self.layers.append(layer)\n\n    def move_layer(self, from_pos, to_pos):\n        layer = self.layers.pop(from_pos)\n        self.layers.insert(to_pos, layer)\n\n    def remove_layer(self, position):\n        self.layers.pop(position)\n\n    def get_position(self, layer):\n        return self.layers.index(layer)\n```", "```py\nclass MapCanvas:\n    def __init__(self, layers, width, height, background=None, *args, **kwargs):\n\n        # remember and be remembered by the layergroup\n        self.layers = layers\n        layers.connected_maps.append(self)\n\n        # create the drawer with a default unprojected lat-long coordinate system\n        self.drawer = pyagg.Canvas(width, height, background)\n        self.drawer.geographic_space() \n\n        self.img = self.drawer.get_image()\n\n    def pixel2coord(self, x, y):\n        return self.drawer.pixel2coord(x, y)\n\n    # Map canvas alterations\n\n    def offset(self, xmove, ymove):\n        self.drawer.move(xmove, ymove)\n    def resize(self, width, height):\n        self.drawer.resize(width, height, lock_ratio=True)\n        self.img = self.drawer.get_image()\n\n    # Zooming\n\n    def zoom_bbox(self, xmin, ymin, xmax, ymax):\n        self.drawer.zoom_bbox(xmin, ymin, xmax, ymax)\n\n    def zoom_factor(self, factor, center=None):\n        self.drawer.zoom_factor(factor, center=center)\n\n    def zoom_units(self, units, center=None):\n        self.drawer.zoom_units(units, center=center)\n\n    # Drawing\n\n    def render_one(self, layer):\n        if layer.visible:\n            layer.render(width=self.drawer.width,\n                         height=self.drawer.height,\n                       coordspace_bbox=self.drawer.coordspace_bbox)\n            self.update_draworder()\n\n    def render_all(self):\n        for layer in self.layers:\n            if layer.visible:\n                layer.render(width=self.drawer.width,\n                             height=self.drawer.height,\n                             coordspace_bbox=self.drawer.coordspace_bbox)\n        self.update_draworder()\n\n    def update_draworder(self):\n        self.drawer.clear()\n        for layer in self.layers:\n            if layer.visible:\n                self.drawer.paste(layer.img)\n        self.img = self.drawer.get_image()\n\n    def get_tkimage(self):\n        # Special image format needed by Tkinter to display it in the GUI\n        return self.drawer.get_tkimage() \n```", "```py\nclass VectorLayer:\n    def __init__(self, data, **options):\n\n        self.data = data\n        self.visible = True\n        self.img = None\n\n        # by default, set random style color\n        rand = random.randrange\n        randomcolor = (rand(255), rand(255), rand(255), 255)\n        self.styleoptions = {\"fillcolor\": randomcolor}\n\n        # override default if any manually specified styleoptions\n        self.styleoptions.update(options)\n\n    def render(self, width, height, coordspace_bbox):\n        drawer = pyagg.Canvas(width, height, background=None)\n        drawer.custom_space(*coordspace_bbox)\n        # get features based on spatial index, for better speeds when zooming\n        if not hasattr(self.data, \"spindex\"):\n            self.data.create_spatial_index()\n        spindex_features = self.data.quick_overlap(coordspace_bbox)\n        # draw each as geojson, using same style options for all features\n        for feat in spindex_features:\n            drawer.draw_geojson(feat.geometry, **self.styleoptions)\n        self.img = drawer.get_image() \n```", "```py\nclass RasterLayer:\n    def __init__(self, data, **options):\n        self.data = data\n        self.styleoptions = dict(**options)\n        self.visible = True\n        self.img = None\n\n    def render(self, width, height, coordspace_bbox):\n        # position in space\n        positioned,mask = self.data.positioned(width, height, coordspace_bbox)\n\n        # combine all data bands into one image for visualizing\n        if len(positioned.bands) == 1:\n            # greyscale if one band\n            band1 = positioned.bands[0]\n            img = band1.img.convert(\"RGB\")\n        else:\n            # rgb of first three bands\n            bands = [band.img for band in positioned.bands[:3] ]\n            img = PIL.Image.merge(\"RGB\", bands)\n\n        # make edge and nodata mask transparent\n        img.putalpha(mask)\n\n        # final\n        self.img = img\n```", "```py\n    def assign_layergroup(self, layergroup):\n        self.layers = layergroup\n```", "```py\n        # Assign a renderer just after startup, because only then can one know the required window size\n        def on_startup():\n            # create renderer\n            width, height = self.winfo_width(), self.winfo_height()\n            self.renderer = pg.MapCanvas(self.layers, width, height)\n            # link to self\n            self.renderer.mapview = self\n            # fill with blank image\n            self.tkimg = self.renderer.get_tkimage()\n            self.image_on_canvas = self.create_image(0, 0, anchor=\"nw\", image=self.tkimg )\n\n        self.after(10, on_startup)\n```", "```py\n    def threaded_rendering(self):\n        # perform render/zoom in separate thread\n        self.statusbar.task.start(\"Rendering layers...\")\n        pending = dispatch.request_results(self.renderer.render_all)\n\n        def finish(result):\n            if isinstance(result, Exception):\n                popup_message(self, \"Rendering error: \" + str(result) )\n            else:\n                # update renderings\n                self.coords(self.image_on_canvas, 0, 0) # always reanchor rendered image nw at 0,0 in case of panning\n                self.update_image()\n                # display zoom scale\n                self.statusbar.zoom.set_text(\"1:\"+str(self.renderer.drawer. coordspace_units) )\n            self.statusbar.task.stop()\n\n        dispatch.after_completion(self, pending, finish)\n\n    def update_image(self):\n        self.tkimg = self.renderer.get_tkimage()\n        self.itemconfig(self.image_on_canvas, image=self.tkimg )\n```", "```py\n        # Schedule resize map on window resize\n        self.last_resized = None\n        def resizing(event):\n            # record resize time\n            self.last_resized = time.time()\n            # schedule to check if finished resizing after x millisecs\n            self.after(300, process_if_finished)\n\n        def process_if_finished():\n            # only if x time since last resize event\n            if time.time() - self.last_resized > 0.3:\n                width, height = self.winfo_width(), self.winfo_height()\n                self.renderer.resize(width, height)\n                self.threaded_rendering()\n\n        self.bind(\"<Configure>\", resizing)\n```", "```py\n    def assign_layergroup(self, layergroup):\n        self.layers = layergroup\n```", "```py\n    def add_layer(self, filepath_or_loaded, name=None, **kwargs):\n\n        def from_filepath(filepath):\n            if filepath.lower().endswith((\".shp\",\".geojson\",\".json\")):\n                func = pg.vector.data.VectorData\n                args = (filepath,)\n            elif filepath.lower().endswith((\".asc\",\".ascii\",\n                                            \".tif\",\".tiff\",\".geotiff\",\n                                            \".jpg\",\".jpeg\",\n                                            \".png\",\".bmp\",\".gif\")):\n                func = pg.raster.data.RasterData\n                args = (filepath,)\n            else:\n                popup_message(self, \"Fileformat not supported\\n\\n\" + filepath )\n                return\n\n            self.statusbar.task.start(\"Loading layer from file...\")\n            pending = dispatch.request_results(func, args, kwargs)\n\n            def finish(loaded):\n                if isinstance(loaded, Exception):\n                    popup_message(self, str(loaded) + \"\\n\\n\" + filepath )\n                else:\n                    from_loaded(loaded)\n                self.statusbar.task.stop()\n\n            dispatch.after_completion(self, pending, finish)\n\n        def from_loaded(loaded):\n            # add the data as a rendering layer\n            if isinstance(loaded, pg.vector.data.VectorData):\n                renderlayer = pg.renderer.VectorLayer(loaded)\n            elif isinstance(loaded, pg.raster.data.RasterData):\n                renderlayer = pg.renderer.RasterLayer(loaded)\n            self.layers.add_layer(renderlayer)\n\n            # list a visual representation in the layerspane list\n            listlayer = LayerItem(self.layersview, renderlayer=renderlayer, name=name)\n            listlayer.namelabel.bind(\"<Button-3>\", self.layer_rightclick)\n            listlayer.pack(fill=\"x\", side=\"bottom\")\n\n            # render to and update all mapcanvases connected to the layergroup\n            for mapcanvas in self.layers.connected_maps:\n                if len(mapcanvas.layers.layers) == 1:\n                    # auto zoom to layer if it is the only layer\n                    mapcanvas.zoom_bbox(*loaded.bbox)\n\n                func = mapcanvas.render_one\n                args = [renderlayer]\n\n                self.statusbar.task.start(\"Rendering layer...\")\n                pending = dispatch.request_results(func, args)\n\n                def finish(loaded):\n                    if isinstance(loaded, Exception):\n                        popup_message(self, \"Rendering error: \" + str(loaded) )\n                    else:\n                        mapcanvas.mapview.update_image()\n                    self.statusbar.task.stop()\n\n                dispatch.after_completion(self, pending, finish)\n\n        # load from file or go straight to listing/rendering\n        if isinstance(filepath_or_loaded, (str,unicode)):\n            from_filepath(filepath_or_loaded)\n        else:\n            from_loaded(filepath_or_loaded)\n```", "```py\nclass LayerItem(tk.Frame):\n    def __init__(self, master, renderlayer, name=None, **kwargs):\n        # get theme style\n        style = style_layeritem_normal.copy()\n        style.update(kwargs)\n\n        # Make this class a subclass of tk.Frame and add to it\n        tk.Frame.__init__(self, master, **style)\n        self.layerspane = self.master.master\n        self.statusbar = self.layerspane.statusbar\n\n        # Create a frame to place main row with name etc\n        self.firstrow = tk.Frame(self, **style)\n        self.firstrow.pack(side=\"top\", fill=\"x\", expand=True)\n\n        # Create the visibility check box\n        var = tk.BooleanVar(self)\n        self.checkbutton = tk.Checkbutton(self.firstrow, variable=var, offvalue=False, onvalue=True, command=self.toggle_visibility, **style_layercheck)\n        self.checkbutton.var = var\n        self.checkbutton.pack(side=\"left\")\n        self.checkbutton.select()\n\n        # Create Delete button to the right\n        self.deletebutton = IconButton(self.firstrow, padx=2, relief=\"flat\", command=self.delete)\n        self.deletebutton.set_icon(\"delete_layer.png\")\n        self.deletebutton.pack(side=\"right\")\n\n        # Create the layername display\n        self.renderlayer = renderlayer\n        if name: layername = name\n        elif self.renderlayer.data.filepath: \n            layername = os.path.split(self.renderlayer.data.filepath)[-1]\n        else: layername = \"Unnamed layer\"\n        self.namelabel = tk.Label(self.firstrow, text=layername, **style_layername_normal)\n        self.namelabel.pack(side=\"left\", fill=\"x\", expand=True)\n\n    def toggle_visibility(self):\n        self.layerspane.toggle_layer(self)\n\n    def delete(self):\n        self.layerspane.remove_layer(self)\n\n    def ask_rename(self):\n        # place entry widget on top of namelabel\n        nameentry = tk.Entry(self)\n        nameentry.place(x=self.namelabel.winfo_x(), y=self.namelabel.winfo_y(), width=self.namelabel.winfo_width(), height=self.namelabel.winfo_height())\n        # set its text to layername and select all text\n        nameentry.insert(0, self.namelabel[\"text\"])\n        nameentry.focus()\n        nameentry.selection_range(0, tk.END)\n        # accept or cancel change via keypress events\n        def finish(event):\n            newname = nameentry.get()\n            nameentry.destroy()\n            self.namelabel[\"text\"] = newname\n        def cancel(event):\n            nameentry.destroy()\n        nameentry.bind(\"<Return>\", finish)\n        nameentry.bind(\"<Escape>\", cancel)\n```", "```py\n    def toggle_layer(self, layeritem):\n        # toggle visibility\n        if layeritem.renderlayer.visible == True:\n            layeritem.renderlayer.visible = False\n        elif layeritem.renderlayer.visible == False:\n            layeritem.renderlayer.visible = True\n        # update all mapcanvas\n        for mapcanvas in self.layers.connected_maps:\n            mapcanvas.update_draworder()\n            mapcanvas.mapview.update_image()\n\n    def remove_layer(self, layeritem):\n        # remove from rendering\n        layerpos = self.layers.get_position(layeritem.renderlayer)\n        self.layers.remove_layer(layerpos)\n        for mapcanvas in self.layers.connected_maps:\n            mapcanvas.update_draworder()\n            mapcanvas.mapview.update_image()\n        # remove from layers list\n        layeritem.destroy()\n\n    def bind_layer_rightclick(self, func):\n        self.layer_rightclick = func\n```", "```py\n        def start_drag(event):\n            self.dragging = event.widget.master.master\n            self.config(cursor=\"exchange\")\n\n        def stop_drag(event):\n\n            # find closest layerindex to release event\n            def getindex(layeritem):\n                return self.layerspane.layers.get_position(layeritem.renderlayer)\n\n            goingdown = event.y_root - (self.dragging.winfo_rooty() + self.dragging.winfo_height() / 2.0) > 0\n            if goingdown:\n                i = len(self.layerspane.layersview.winfo_children())\n                for layeritem in sorted(self.layerspane.layersview.winfo_children(), key=getindex, reverse=True):\n                    if event.y_root < layeritem.winfo_rooty() + layeritem.winfo_height() / 2.0:\n                        break\n                    i -= 1\n            else:\n                i = 0\n                for layeritem in sorted(self.layerspane.layersview.winfo_children(), key=getindex):\n                    if event.y_root > layeritem.winfo_rooty() - layeritem.winfo_height() / 2.0:\n                        break\n                    i += 1\n\n            # move layer\n            frompos = self.layerspane.layers.get_position(self.dragging.renderlayer)\n            if i != frompos:\n                self.layerspane.move_layer(frompos, i)\n\n            # clean up\n            self.dragging = None\n            self.config(cursor=\"arrow\")\n\n        self.dragging = None\n        self.namelabel.bind(\"<Button-1>\", start_drag)\n        self.namelabel.bind(\"<ButtonRelease-1>\", stop_drag)\n```", "```py\n    def move_layer(self, fromindex, toindex):\n        self.layers.move_layer(fromindex, toindex)\n        for mapcanvas in self.layers.connected_maps:\n            mapcanvas.update_draworder()\n            mapcanvas.mapview.update_image()\n        self.update_layerlist()\n```", "```py\n        # Bind interactive zoom events\n        def doubleleft(event):\n            self.zoomfactor += 1\n            canvasx,canvasy = self.canvasx(event.x),self.canvasy(event.y)\n            self.zoomcenter = self.renderer.pixel2coord(canvasx, canvasy)\n            self.zoomdir = \"in\"\n            # record zoom time\n            self.last_zoomed = time.time()\n            # schedule to check if finished zooming after x millisecs\n            self.after(300, zoom_if_finished)\n\n        def doubleright(event):\n            self.zoomfactor += 1\n            canvasx,canvasy = self.canvasx(event.x),self.canvasy(event.y)\n            self.zoomcenter = self.renderer.pixel2coord(canvasx, canvasy)\n            self.zoomdir = \"out\"\n            # record zoom time\n            self.last_zoomed = time.time()\n            # schedule to check if finished zooming after x millisecs\n            self.after(300, zoom_if_finished)\n\n        def zoom_if_finished():\n            if time.time() - self.last_zoomed >= 0.3:\n                if self.zoomdir == \"out\":\n                    self.zoomfactor *= -1\n                self.renderer.zoom_factor(self.zoomfactor, center=self.zoomcenter)\n                self.threaded_rendering()\n                # reset zoomfactor\n                self.zoomfactor = 1\n                self.last_zoomed = None\n\n        self.bind(\"<Double-Button-1>\", doubleleft)\n        self.bind(\"<Double-Button-3>\", doubleright)\n```", "```py\n        def mousepressed(event):\n            if self.last_zoomed: return\n            self.mousepressed = True\n            self.startxy = self.canvasx(event.x), self.canvasy(event.y)\n            if self.mouse_mode == \"zoom\":\n                startx,starty = self.startxy\n                self.rect = self.create_rectangle(startx, starty, startx+1, starty+1, fill=None)\n\n        def mousemoving(event):\n            if self.statusbar:\n                # mouse coords\n                mouse = self.canvasx(event.x), self.canvasy(event.y)\n                xcoord,ycoord = self.renderer.pixel2coord(*mouse)\n                self.statusbar.mouse.set_text(\"%3.8f , %3.8f\" %(xcoord,ycoord) )\n            if self.mouse_mode == \"pan\":\n                if self.mousepressed:\n                    startx,starty = self.startxy\n                    curx,cury = self.canvasx(event.x), self.canvasy(event.y)\n                    xmoved = curx - startx\n                    ymoved = cury - starty\n                    self.coords(self.image_on_canvas, xmoved, ymoved) # offset the image rendering\n            elif self.mouse_mode == \"zoom\":\n                curx,cury = self.canvasx(event.x), self.canvasy(event.y)\n                self.coords(self.zoomicon_on_canvas, curx, cury)\n                if self.mousepressed:\n                    startx,starty = self.startxy\n                    self.coords(self.rect, startx, starty, curx, cury)\n\n        def mousereleased(event):\n            if self.last_zoomed: return\n            self.mousepressed = False\n            if self.mouse_mode == \"pan\":\n                startx,starty = self.startxy\n                curx,cury = self.canvasx(event.x), self.canvasy(event.y)\n                xmoved = int(curx - startx)\n                ymoved = int(cury - starty)\n                if xmoved or ymoved:\n                    # offset image rendering\n                    self.renderer.offset(xmoved, ymoved) \n                    self.threaded_rendering()\n            elif self.mouse_mode == \"zoom\":\n                startx,starty = self.startxy\n                curx,cury = self.canvasx(event.x), self.canvasy(event.y)\n                self.coords(self.rect, startx, starty, curx, cury)\n                # disactivate rectangle selector\n                self.delete(self.rect)\n                self.event_generate(\"<Leave>\") # fake a mouseleave event to destroy icon\n                self.mouse_mode = \"pan\"\n                # make the zoom\n                startx,starty = self.renderer.drawer.pixel2coord(startx,starty)\n                curx,cury = self.renderer.drawer.pixel2coord(curx,cury)\n                bbox = [startx, starty, curx, cury]\n                self.renderer.zoom_bbox(*bbox)\n                self.threaded_rendering()\n\n        def mouseenter(event):\n            if self.mouse_mode == \"zoom\":\n                # replace mouse with zoomicon\n                self.zoomicon_tk = icons.get(\"zoom_rect.png\", width=30, height=30)\n                self.zoomicon_on_canvas = self.create_image(event.x, event.y, anchor=\"center\", image=self.zoomicon_tk )\n                self.config(cursor=\"none\")\n\n        def mouseleave(event):\n            if self.mouse_mode == \"zoom\":\n                # back to normal mouse\n                self.delete(self.zoomicon_on_canvas)\n                self.config(cursor=\"arrow\")\n\n        def cancel(event):\n            if self.mouse_mode == \"zoom\":\n                self.event_generate(\"<Leave>\") # fake a mouseleave event to destroy icon\n                self.mouse_mode = \"pan\"\n                if self.mousepressed:\n                    self.delete(self.rect)\n\n        # bind them\n        self.bind(\"<Button-1>\", mousepressed, \"+\")\n        self.bind(\"<Motion>\", mousemoving)\n        self.bind(\"<ButtonRelease-1>\", mousereleased, \"+\")\n        self.bind(\"<Enter>\", mouseenter)\n        self.bind(\"<Leave>\", mouseleave)\n        self.winfo_toplevel().bind(\"<Escape>\", cancel)\n```", "```py\nclass NavigateTB(tk.Frame):\n    def __init__(self, master, **kwargs):\n        # get theme style\n        style = style_toolbar_normal.copy()\n        style.update(kwargs)\n\n        # Make this class a subclass of tk.Frame and add to it\n        tk.Frame.__init__(self, master, **style)\n\n        # Modify some options\n        self.config(width=80, height=40)\n\n    def assign_mapview(self, mapview):\n        mapview.navigation = self\n        self.mapview = mapview\n\n        # Add buttons\n        self.global_view = IconButton(self, text=\"zoom global\", command=self.mapview.zoom_global)\n        self.global_view.set_icon(\"zoom_global.png\", width=32, height=32)\n        self.global_view.pack(side=\"left\", padx=2, pady=2)\n        self.zoom_rect = IconButton(self, text=\"zoom to rectangle\", command=self.mapview.zoom_rect)\n        self.zoom_rect.set_icon(\"zoom_rect.png\", width=32, height=32)\n        self.zoom_rect.pack(side=\"left\", padx=2, pady=2)\n```", "```py\n    def zoom_global(self):\n        layerbboxes = (layer.data.bbox for layer in self.renderer.layers)\n        xmins,ymins,xmaxs,ymaxs = zip(*layerbboxes)\n        globalbbox = [min(xmins), min(ymins), max(xmaxs), max(ymaxs)]\n        self.renderer.zoom_bbox(*globalbbox)\n        self.threaded_rendering()\n\n    def zoom_rect(self):\n        self.mouse_mode = \"zoom\"\n        self.event_generate(\"<Enter>\")\n\n    def zoom_bbox(self, bbox):\n        self.renderer.zoom_bbox(*bbox)\n        self.threaded_rendering()\n```", "```py\n        # Create a layergroup that keeps track of all the loaded data\n        # ...so that all widgets can have access to the same data\n        self.layers = pg.renderer.LayerGroup()\n\n        # Assign layergroup to layerspane and mapview\n        self.layerspane.assign_layergroup(self.layers)\n        self.mapview.assign_layergroup(self.layers)\n\n        ## Visualize tab\n        visitab = self.ribbon.add_tab(\"Visualize\")\n        ### (Output toolbar)\n        output = visitab.add_toolbar(\"Output\")\n        def save_image():\n            filepath = asksaveasfilename()\n            self.mapview.renderer.img.save(filepath)\n        output.add_button(text=\"Save Image\", icon=\"save_image.png\",\n                               command=save_image)\n\n        # Place add layer button in the header of the layerspane\n        def selectfiles():\n            filepaths = askopenfilenames()\n            for filepath in filepaths:\n                encoding = self.data_options.get(\"encoding\")\n                self.layerspane.add_layer(filepath, encoding=encoding)\n        button_addlayer = IconButton(self.layerspane.header, command=selectfiles)\n        button_addlayer.set_icon(\"add_layer.png\", width=27, height=27)\n        button_addlayer.pack(side=\"right\", anchor=\"e\", ipadx=3, padx=6, pady=3,)\n\n        # Place button for setting data options\n        self.data_options = {\"encoding\": \"utf8\"}\n        button_data_options = IconButton(self.layerspane.header)\n        button_data_options.set_icon(\"data_options.png\", width=24, height=21)\n        button_data_options.pack(side=\"right\", anchor=\"e\", ipadx=5, ipady=3, padx=6, pady=3,)\n\n        # Open options window on button click\n        def data_options_window():\n            win = popups.RunToolWindow(self)\n\n            # assign status bar\n            win.assign_statusbar(self.statusbar)\n\n            # place option input for data encoding\n            win.add_option_input(\"Vector data encoding\", valuetype=str,\n                                 argname=\"encoding\", default=self.data_options.get(\"encoding\"))\n\n            # when clicking OK, update data options\n            def change_data_options(*args, **kwargs):\n                \"\"\"\n                Customize settings for loading and saving data.\n\n                Vector data encoding: Common options include \"utf8\" or \"latin\"\n                \"\"\"\n                # update user settings\n                self.data_options.update(kwargs)\n\n            def change_data_options_complete(result):\n                # close window\n                win.destroy()\n\n            win.set_target_method(\"Changing data options\", change_data_options)\n            win.set_finished_method(change_data_options_complete)\n\n        button_data_options[\"command\"] = data_options_window\n\n        # Attach floating navigation toolbar inside mapwidget\n        self.navigation = NavigateTB(self.mapview)\n        self.navigation.place(relx=0.5, rely=0.03, anchor=\"n\")\n        self.navigation.assign_mapview(self.mapview)\n```"]