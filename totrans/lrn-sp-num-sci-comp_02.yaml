- en: Chapter 2. Working with the NumPy Array As a First Step to SciPy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the top level, SciPy is basically NumPy, since both the object creation and
    basic manipulation of these objects are performed by functions of the latter library.
    This assures much faster computations, since the memory handling is done internally
    in an optimal way. For instance, if an operation must be made on the elements
    of a big multidimensional array, a novice user might be tempted to go over columns
    and rows with as many for loops as necessary. Loops run much faster when they
    access each consecutive element in the same order in which they are stored in
    memory. We should not be bothered with considerations of this kind when coding.
    The NumPy/SciPy operations assure that this is the case. As an added advantage,
    the names of operations in NumPy/SciPy are intuitive and self explanatory. Code
    written in this fashion is extremely easy to understand and maintain, faster to
    correct or change in case of need.
  prefs: []
  type: TYPE_NORMAL
- en: Let's illustrate this point with an introductory example.
  prefs: []
  type: TYPE_NORMAL
- en: The `scipy.misc` module in the SciPy package contains a classical image called
    `lena`, used in the image processing community for testing and comparison purposes.
    This is a 512 x 512 pixel standard test image, which has been in use since 1973,
    and was originally cropped from the centerfold of the November 1972 issue of the
    Playboy magazine. It is a picture of Lena Söderberg, a Swedish model, shot by
    photographer Dwight Hooker. The image is probably the most widely used test image
    for all sorts of image processing algorithms (such as compression and noise reduction)
    and related scientific publications.
  prefs: []
  type: TYPE_NORMAL
- en: 'This image is stored as a two-dimensional array. Note that the number in the
    *n^(th)* column and *m^(th)* row of this array measures the grayscale value at
    the pixel position (*n+1*, *m+1*) of the image. In the following, we access this
    picture and store it in the `img` variable, by issuing the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The image can be displayed by issuing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![Working with the NumPy Array As a First Step to SciPy](img/7702OS_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We may take a peek at some of these values; say the 7 x 3 upper corner of the
    image (7 columns, 3 rows). Instead of issuing for loops, we could *slice* the
    corresponding portion of the image. The `img[0:3,0:7]` command gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the same strategy to populate arrays or change their values. For
    instance, let''s change all entries of the previous array to hold zeros on the
    second row between columns 2 to 6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Object essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have been introduced to NumPy''s main object—the homogeneous multidimensional
    array, also referred to as `ndarray`. All elements of the array are casted to
    the same datatype (homogeneous). We obtain the datatype by the `dtype` attribute,
    its dimension by the `shape` attribute, the total number of elements in the array
    by the `size` attribute, and elements by referring to their positions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compute the grayscale values now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Let's interpret the outputs. The elements of `img` are 64-bit integer values
    ('int64'). This may vary depending on the system, the Python installation, and
    the computer specifications. The shape of the array (note it comes as a Python
    tuple) is 512 x 512, and the number of elements 262144\. The grayscale value of
    the image in the 33^(rd) column and 68^(th) row is `87` (note that in NumPy, as
    in Python or C, all indices are zero-based).
  prefs: []
  type: TYPE_NORMAL
- en: We will now introduce the basic property and methods of NumPy/SciPy objects—datatype
    and indexing.
  prefs: []
  type: TYPE_NORMAL
- en: Using datatypes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several approaches to impose the datatype. For instance, if we want
    all entries of an already created array to be 32-bit floating point values, we
    may cast it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use an optional argument, `dtype` through the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be simplified even further with a third clever method (although this
    practice offers code that are not so easy to interpret):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The choice of datatypes for NumPy arrays is very flexible; we may choose the
    basic Python types (including `bool`, `dict`, `list`, `set`, `tuple`, `str`, and
    `unicode`), although for numerical computations we focus on `int`, `float`, `long`,
    and `complex`.
  prefs: []
  type: TYPE_NORMAL
- en: 'NumPy has its own set of datatypes optimized to use with instances of `ndarray`,
    and with the same precision as the previously given native types. We distinguish
    them with a trailing underscore (`_`). For instance, `ndarray` of strings could
    be initialized, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows (it depends on your Python version):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note two things; unlike it's purely Python counterpart, the usage of the `'str_'`
    datatype requires the name to be quoted; we could use the longer unquoted version,
    `numpy.str_`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When prompted for datatype, the system returns its C-derived equivalent: `''<U7''`
    (''`<U` for strings, and `7`'' to indicate the largest size of any of its elements).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common way to address numerical types is with the bit width nomenclature:
    `boolXX`, `intXX`, `uintXX`, `floatXX`, or `complexXX`, where `XX` indicates the
    bit size (for example, `uint32` for 32-bit unsigned integers).'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to design our own datatypes, and this is where the full
    potential of the flexibility of NumPy datatypes arise. For instance, a datatype
    to indicate the name and grades of a student could be created, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows (it depends on your Python version):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that the `dt` datatype has two parts: the first part, the `name`,
    that must be a `numpy.str_` string with 16 characters. The second part, the `grades`,
    is a subarray of dimension 2 with scores as 64-bit floating point values. A valid
    array with elements in this datatype would then look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows (it depends on your Python version):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Indexing and slicing arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two basic methods to access the data in a NumPy array; let's call
    that array for `A`. Both methods use the same syntax, `A[obj]`, where `obj` is
    a Python object that performs the selection. We are already familiar with the
    first method of accessing a single element. The second method is the subject of
    this section, namely **slicing**. This concept is exactly what makes NumPy and
    SciPy so incredibly easy to manage.
  prefs: []
  type: TYPE_NORMAL
- en: The basic slice method is a Python object of the form `slice(start,stop,step)`,
    or in a more compact notation, `start:stop:step`. Initially, the three variables,
    `start`, `stop`, and `step` are non-negative integer values, with `start` less
    than or equal to `stop`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This represents the sequence of indices *k = start + (i * step)*, where *k*
    runs from `start` to the largest integer *k_max = start + step*int((stop-start)/step)*,
    or *i* from `0` to the largest integer equal to *int((stop - start) / step)*.
    When a slice method is invoked on any of the dimensions of `ndarray`, it selects
    all elements in that dimension indexed by the corresponding sequence of indices.
    The simple example next illustrates this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If `start` is greater than `stop`, a negative value of `step` is used to traverse
    the sequence backwards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Negative values of `start` and `stop` are interpreted as `n-start` and `n-stop`
    (respectively), where `n` is the size of the corresponding dimension. The `A[0:2,-1:0:-2]`
    command gives exactly the same output as the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: The slice objects can be shortened by the absence of `start` (which implies
    a zero if `step` is positive, or the size of the dimension if `step` is negative),
    absence of `stop` (which implies the size of the corresponding dimension in case
    of positive `step`, or zero in case of negative `step`). Absence of `step` implies
    `step` is equal to 1\. The `::` object can be shortened simply as `:` for an easier
    syntax. The `A[:,::-2]` command then offers, yet again, the same output as the
    previous two.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first nonbasic method of accessing data from an array is based on the idea
    of collecting several indices and requesting the elements in the array with those
    indices. For example, from our previous array `A`, we would like to construct
    a new array with the elements on locations (0, 0), (0, 3), (1, 2), and (1, 5).
    We do so by gathering the *x* and *y* values of the indices in respective lists,
    `[0,0,1,1]` and `[0,3,2,5]`, and feeding these lists to `A` as an indexing object,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how the result loses the dimension of the primitive array, and offers
    a one-dimensional array. If we desire to capture a subarray of `A` with indices
    in the **Cartesian** product of two sets of indices, respecting the row and column
    choice and creating a new array with the dimensions of the Cartesian product,
    we use the `ix_` command. For instance, if in our previous array we would like
    to obtain the subarray of dimension 2 x 2 with indices in the Cartesian product
    of indices (0, 1) by (0,3) (these are the locations (0, 0), (0, 3), (1, 0), and
    (1, 3), we do so as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The array object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we are ready for a thorough study of all interesting attributes
    of `ndarray` for scientific computing purposes. We have already covered a few,
    such as `dtype`, `shape`, and `size`. Other useful attributes are `ndim` (to compute
    the number of dimensions in the array), `real`, and `imag` (to obtain the real
    and imaginary parts of the data, should this be formed by complex numbers) or
    `flat` (which creates a one-dimensional indexable iterator from the data).
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if we desired to add all the values of an array together, we
    could use the `flat` attribute to run over all the elements sequentially, and
    accumulate all the values in a variable. A possible code to perform this task
    should look like the following code snippet (compare this code with the `ndarray.sum()`
    method, which will be explained in object calculation ahead):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We will also explore some of the methods applied to arrays. These are tools
    used to modify objects; let it be their datatypes, their shape, or their structure
    through conversion. These methods can be classified in three big categories—**array**
    **conversion**, **shape** **selection**/**manipulation**, and **object calculation**.
  prefs: []
  type: TYPE_NORMAL
- en: Array conversions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `astype()` method returns a copy of the array converted to a specific type;
    the `copy` method returns a copy of the array. Finally, the `tofile()`, `tolist()`,
    or `tostring()` method writes the binary data of the array into a file, returns
    a hierarchical python list version of the same array, or returns a string representation
    of the array data.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, to write the contents of the `img` array to a text file making
    sure that each entry of the array is printed as an integer and that every two
    integers are separated by a white space, we can issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note how the formatting string follows the C language conventions.
  prefs: []
  type: TYPE_NORMAL
- en: Shape selection/manipulations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These are used not only when we need to rearrange (`swapaxes` and `transpose`)
    or sort (`argsort` and `sort`) an array, but also when we need to reshape (`reshape`),
    resize (`flatten`, `ravel`, `resize`, and `squeeze`), or select (`choose`, `compress`,
    `diagonal`, `nonzero`, `searchsorted`, and `take`) arrays. Note that these methods
    are very powerful when combined with slicing operations; as a matter of fact,
    many of them can replace slicing to offer more readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to say a word about the attributes `flat`, `ravel`, and `flatten`,
    which offer very similar outputs, but very different memory management. The first
    attribute, `flat`, creates an iterator over an array. Once used, it disappears
    from memory. The attribute `ravel` returns a one-dimensional flattened array of
    the input; a copy is made only if needed. Finally, `flatten` creates a one-dimensional
    array of the input, and always allocates memory for it. We use it only when we
    need to change the values of flattened arrays. We will highlight the power of
    the sorting methods in the following code snippets. When sorting an array of integers,
    what would be the order of their indices? We may obtain this information with
    the `argsort()` method. We may even impose which sorting algorithm is to be used
    (rather than coding it ourselves)—`quicksort`, `mergesort`, or `heapsort`. We
    can even sort the array in place, using the `sort()` method. Let''s take a look
    at the following set of commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we apply the `sort()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Object calculations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Array calculation methods are used to perform computations or extract information
    from our data. Python supplies a range of statistical methods to compute, for
    instance, maximum and minimum values of the data (`max` and `min`) with their
    corresponding indices (`argmax` and `argmin`) methods to compute the sum, cumulative
    sums, product, or cumulative products (`sum`, `cumsum`, `prod`, and `cumprod`),
    and to calculate the average (`mean`), point spread (`ptp`), variance (`var`),
    and standard deviation (`std`) of our data. Other methods allow us to compute
    complex conjugate of complex-valued arrays (`conj`), the trace of the array (`trace`,
    which is the sum of the elements in the diagonal), and even clipping the matrix
    (`clip`) by forcing a minimum and maximum value below and above certain thresholds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note, that most of these methods can act on the entire array and each of their
    dimension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s apply the `mean()` method with `axis=0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we perform the same command with `axis=1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also illustrate the `clip` command with an easy exercise based on the
    Lena image. Compute the maximum and minimum values of Lena (`img`), and contrast
    them with the point spread (it should be equal to the difference between those
    two values). Now, create a new array `A` by clipping Lena so that the minimum
    is maintained, but the point spread is reduced to only 100 values. Let''s illustrate
    the effect of `min()`, `max()`, and `ptp()` commands on Lena (`img`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Further, we illustrate the effect of `clip()` command on `img` in the following
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Array routines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will deal with most operations on arrays. We will classify
    them into four main categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Routines to create new arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routines to manipulate a single array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routines to combine two or more arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routines to extract information from arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reader will surely realize that some operations of this kind can be carried
    out by methods, which once again shows the flexibility of Python and NumPy.
  prefs: []
  type: TYPE_NORMAL
- en: Routines to create arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have previously seen the command to create an array and store it to a variable
    `A`. Let''s take a look at it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete syntax, however, writes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go over the options: `object` is simply the data we use to initialize
    the array. In the previous example, the object is a 2 x 2 square matrix; we may
    impose a datatype with the `dtype` option. The result is stored in the variable
    `A`. If `copy` is `True`, the returned object will be a copy of the array, if
    `False`, the returned object will only be a copy, if `dtype` is different from
    the datatype of `object`. The arrays are stored following a C-style ordering of
    rows and columns. If the user prefers to store the array following the memory
    style of FORTRAN, the `order=''Fortran''` option should be used. The `subok` option
    is very subtle; if `True`, the array may be passed as a subclass of the object,
    if `False`, then only `ndarray` arrays are passed. And finally, the `ndmin` option
    indicates the smallest dimension returned by the array. If not offered, this is
    computed from `object`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A set of special arrays can be obtained with commands such as `zeros`, `ones`,
    `empty`, `identity`, and `eye`. The names of these commands are quite informative:'
  prefs: []
  type: TYPE_NORMAL
- en: '`zeros` creates an array filled with zeros.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ones` creates an array filled with ones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`empty` returns an array of required shape without initializing its entries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`identity` creates a square matrix with dimensions indicated by a single positive
    integer *n*. The entries are filled with zeros, except the diagonal, which is
    filled with ones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `eye` command is very similar to `identity`. It also constructs diagonal
    arrays, but unlike `identity`, `eye` allows specifying diagonals offset the traditional
    centered, as it can operate on rectangular arrays as well. In the following lines
    of code, we use zeros, ones, and identity commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In the first two cases, we indicated the shape of the array (as a Python tuple
    of positive integers) and the optional datatype imposition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for `eye` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The integers, `N` and `M` indicate the shape of the array, and the integer `k`
    indicates the index of the diagonal to populate.
  prefs: []
  type: TYPE_NORMAL
- en: 'An index `k=0` (the default) points to the traditional diagonal; a positive
    index refers to upper diagonals and negative to lower diagonals. To illustrate
    this point, the following example shows how to create a 4 x 4 sparse matrix with
    nonzero elements on the first upper and subdiagonals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Using the previous four commands together with basic slicing, it is possible
    to create even more complex arrays very simply. We propose the following challenge.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use exclusively, the previous definitions of `U` and `I` together with an `eye`
    array. How would the reader create a 5 x 5 array `A` of values, type float with
    *fives* at the four entries (0, 0), (0, 1), (1, 0), and (1, 1); *sixes* along
    the remaining entries of the diagonal; and *threes* in the two other corners ?
    The solution to this question can be addressed by issuing the following set of
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The flexibility of creating an array in NumPy is even more clear using the
    `fromfunction` command. For instance, if we require a 4 x 4 array where each entry
    reflects the product of its indices, we may use the `lambda` function `(lambda
    i,j: i*j)` in the `fromfunction` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'A very important tool dealing with arrays is the concept of masking. **Masking**
    is based on the idea of selecting or masking those indices for which their corresponding
    entries satisfy a given condition. For example, in the array `B` shown in the
    previous example, we can mask all zero-valued entries with the `B==0` command,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Now, how would the reader update `B` so that all zero's would be replaced by
    the sum of the squares of their corresponding indices?
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiplying a mask by a second array of the same shape offers a new array in
    which each entry is either zero (if the corresponding entry in the mask is `False`),
    or the entry of the second array (if the corresponding entry in the mask is `True`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have created a new array filled with Boolean values as the size
    of the original array and in each step. This isn't a big deal in these toy examples,
    but when handling large datasets, allocating too much memory could seriously slow
    down our computations and exhaust the memory of our system. Among the commands
    to create arrays, there are two in particular `putmask` and `where`, which facilitate
    the management of resources internally, thus speeding up the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note, for example, when we look for all odd-valued entries in `B`, the resulting
    mask has size of 16, although the interesting entries are only eight:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The `numpy.where()` command helps us gather those entries more efficiently.
    Let''s take a look at the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'If we desire to change those entries (all odd), to, say they are *squares plus
    one*, we can use the `numpy.putmask()` command instead, and better manage the
    memory at the same time. The following is a sample code for the `numpy.putmask()`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Note how the `putmask` procedure updates the values of `B`, without the explicit
    need to make a new assignment.
  prefs: []
  type: TYPE_NORMAL
- en: There are three additional commands that create arrays in the form of meshes.
    The `arange` and `linspace` commands create uniformly spaced values between two
    numbers. In `arange`, we specify the spacing between elements; in `linspace`,
    we specify the desired number of elements in the mesh. The `logspace` command
    creates uniformly spaced values in a logarithmic scale between the logarithms
    of two numbers to the base 10\. The user could think of these outputs as the support
    of univariate functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a sample code for the `numpy.arrange()` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding lines of code is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a sample code for the `numpy.linspace()` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example for the `numpy.logspace()` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding lines of code is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Finally, `meshgrid`, `mgrid`, and `ogrid` create two two-dimensional arrays
    of dimensions *n x m*, containing the elements of two given one-dimensional arrays
    of dimensions *n* and *m*. It accomplished this by repeating the values of each
    array as necessary. The user could think of these outputs as the support of functions
    of two variables.
  prefs: []
  type: TYPE_NORMAL
- en: The first of these routines, `meshgrid`, accepts only arrays as input. The other
    two routines, `mgrid` and `ogrid`, accept only indexing objects (for example,
    slices). The difference between these last two is a matter of memory allocation;
    while `mgrid` allocates full arrays with all the data, `ogrid` only creates enough
    sets so that the corresponding `mgrid` command could be obtained by a proper Cartesian
    product.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following `meshgrid` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the following `mgrid` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the following `ogrid` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'We would like to finish the subsection on creations of arrays by showing one
    of the most useful routines for image processing and differential equations—the
    `tile` command. Its syntax is very simple, and is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This routine presents a very effective method of tiling an array `A` following
    some repetition pattern `reps` (a `tuple`, a `list`, or another `array`) to create
    larger arrays. The following checkerboards exercise shows its potential.
  prefs: []
  type: TYPE_NORMAL
- en: Start with two small binary arrays—`B=numpy.ones((3,3))` and `checker2by2=numpy.zeros((6,6))`
    and create a checkerboard using `tile` and as few operations as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform some operations using these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The output is too long to be shown here. Please refer to the *How to open IPython
    Notebooks* section in [Chapter 1](ch01.html "Chapter 1. Introduction to SciPy"),
    *Introduction to SciPy*, to run the IPython Notebook corresponding to this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Routines for the combination of two or more arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On occasion, we need to combine the data of two or more arrays together to solve
    a specific problem. The core NumPy libraries contain extremely efficient routines
    to carry out these computations, and we urge the reader to get familiar with them.
    They are constructed with state-of-the-art algorithms, and they make sure that
    usage of memory is minimum and the complexity optimal. Most relevant are the routines
    that operate on arrays as if they were matrices. These include matrix products
    (`outer`, `inner`, `dot`, `vdot`, `tensordot`, `cross`, and `kron`), array correlations
    (`correlate` and `convolve`), array stacking (`concatenate`, `vstack`, `hstack`,
    `column_stack`, `row_stack`, and `dstack`), and array comparison (`allclose`).
  prefs: []
  type: TYPE_NORMAL
- en: If you are well-versed in linear algebra, you will surely enjoy the matrix products
    included in NumPy. We will postpone their usage and analysis until we cover the
    SciPy module on linear algebra in [Chapter 3](ch03.html "Chapter 3. SciPy for
    Linear Algebra"), *SciPy for Linear Algebra*.
  prefs: []
  type: TYPE_NORMAL
- en: An excellent use for correlation of arrays is basic pattern-matching. For instance,
    the image in the following example (the `text` array) contains an image of a paragraph
    extracted from the Wikipedia page about Don Quixote, while the second array, `letterE`,
    contains an image of the letter *e*, which is actually a subarray obtained from
    the `text` array and represents the pattern to be matched.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we load the text image and performs some preprocessing on it in order
    to bring the image to the right format (as close as possible to the grayscale
    approximation) to have better performance on this naive approach of pattern matching.
    We do this by executing the following lines of code in a Python console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, the pattern for the letter *e* is identified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, a fraction of the maximum value of the correlation of both arrays offers
    the location of all the *e* letters contained in the array `text`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The positions in the image of the pattern found for `x` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The positions in the image of the found pattern for `y` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'There are 86 elements, which are in fact the total number of the occurrence
    of the letter *e* in the text image, as can be verified by counting them. Whether
    the matching has been done correctly can be verified graphically, superposing
    each pair `(x,y)` of the pattern on the text image, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for `plt.axis()` is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s move further in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for `plt.axis()` is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in the following `show()` command, we display a figure that superposes
    each pair `(x,y)` of the pattern on the text image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following screenshot (the first image is the text and the
    next is the text where all occurrences of letter *e* have been crossed out):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Routines for the combination of two or more arrays](img/7702OS_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A few words about stacking operations; we have a basic concatenation routine,
    `concatenate`, which joins a sequence of arrays together along a pre-determined
    axis. Of course, all arrays in the sequence must have the same dimensions, otherwise
    it obviously doesn't work. The rest of the stack operations are syntactic sugar
    for special cases of `concatenate`—`vstack` to glue arrays vertically, `hstack`
    to glue arrays horizontally, `dstack` to glue arrays in the third dimension, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Another impressive set of routines are set operations. They allow the user to
    handle one-dimensional arrays as if they were sets and perform the Boolean operations
    of intersection (`intersect1d`), union (`union1d`), set difference (`setdiff1d`),
    and set exclusive or (`setxor1d`). The results of these set operations return
    sorted arrays. Note that it is also possible to test whether all the elements
    in one array belong to a second array (`in1d`).
  prefs: []
  type: TYPE_NORMAL
- en: Routines for array manipulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a sequence of splitting routines, designed to break up arrays into
    smaller arrays, in any given dimension—`array_split`, `split` (both are basic
    splitting along the indicated axis), `hsplit` (horizontal split), `vsplit` (vertical
    split), and `dsplit` (in the third axis). Let''s illustrate these with a simple
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s perform the vertical split:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Applying a Python function on an array *usually* means applying the function
    to each element of the array. Note how the NumPy function `sin` works on an array,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `sin` function was computed on each element of the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'This works provided the function has been properly vectorized (which is the
    case with `numpy.sin`). Notice the behavior with non-vectorized Python functions.
    Let''s define such a function for computing, for each value of `x`, the maximum
    between `x` and 100 without using any routine from the NumPy libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to apply this function to the preceding array, the system raises
    an error, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is an error which is shown as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to explicitly indicate to the system when we desire to apply one of
    our functions to arrays, as well as scalars. We do that with the `vectorize` routine,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: For our benefit, the NumPy libraries provide a great deal of already-vectorized
    mathematical functions. Some examples are `round_`, `fix` (to round the elements
    of an array to a desired number of decimal places), and `angle` (to provide the
    angle of the elements of an array, provided they are complex numbers) and any
    basic trigonometric (`sin`, `cos`, `tan`, `sic`), exponential (`exp`, `exp2`,
    `sinh`, `cosh`), and logarithmic functions (`log`, `log10`, `log2`).
  prefs: []
  type: TYPE_NORMAL
- en: We also have mathematical functions that treat the array as an output of multidimensional
    functions, and offer relevant computations. Some useful examples are `diff` (to
    emulate differentiation along any specified dimension, by performing discrete
    differences), `gradient` (to compute the gradient of the corresponding function),
    or `cov` (for the covariance of the array).
  prefs: []
  type: TYPE_NORMAL
- en: Sorting the whole array according to the values of the first axis is also possible
    with the `msort` and `sort_complex` routines.
  prefs: []
  type: TYPE_NORMAL
- en: Routines to extract information from arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most of the routines to extract information are statistical in nature, which
    include `average` (which acts exactly as the `mean` method), `median` (to compute
    the statistical median of the array on any of its dimensions, or the array as
    a whole), and computation of histograms (`histogram`, `histogram2d`, and `histogramdd`,
    depending on the dimensions of the array). The other important set of routines
    in this category deal with the concept of bins for arrays of dimension one. This
    is more easily explained by means of examples. Take the array `A=numpy.array([5,1,1,2,1,1,2,2,10,3,3,4,5])`,
    the `unique` command finds the unique values in the array and presents them as
    sorted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'For arrays such as `A`, in which all the entries are nonnegative integers,
    we can visualize the array `A` as a sequence of eleven bins labeled with numbers
    from 0 to 10 (the maximum value in the array). Each bin with label *n* contains
    the number of *n*''s in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'For arrays where some of the elements are not numbers (`nan`), NumPy has a
    set of routines that mimic methods to extract information, but disregard the conflicting
    elements—`nanmax`, `nanmin`, `nanargmax`, `nanargmin`, `nansum`, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see the effect of `log2` on array `A`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the `sum` and `nansum` commands in the following line
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have explored in depth the creation and basic manipulation
    of the object array used by SciPy, as an overview of the NumPy libraries. In particular,
    we have seen the principles of slicing and masking, which simplify the coding
    of algorithms to the point of transforming an otherwise unreadable sequence of
    loops and primitive commands into an intuitive and self-explanatory set of object
    calls and methods. You also learned that the nonbasic modules in NumPy are replicated
    as modules in SciPy itself. The chapter roughly followed the same structure as
    the official NumPy reference (which the reader can access at the SciPy pages [http://docs.scipy.org/doc/numpy/reference/](http://docs.scipy.org/doc/numpy/reference/)).
    There are other good sources that cover NumPy with rigor, and we refer you to
    any of that material for a more detailed coverage of this topic.
  prefs: []
  type: TYPE_NORMAL
- en: In the next five chapters, we will be accessing the commands that make SciPy
    a powerful tool in numerical computing. The structure of those chapters is basically
    a reflection of the different SciPy modules structured in an order that allows
    building applications on top of each other.
  prefs: []
  type: TYPE_NORMAL
