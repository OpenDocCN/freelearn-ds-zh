- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Understanding Quantum Algorithms
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解量子算法
- en: If you’ve been reading the news about quantum computing, you will have noticed
    many articles from various companies, both large and small, all working on different
    projects related to quantum computing. The reason is largely based on the potential
    computing power that quantum systems offer when compared to classical systems.
    The potential to provide speedup, quality, and scalability are the main areas
    of interest that most companies and research institutions are looking heavily
    into now.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直在阅读有关量子计算的新闻，你会注意到来自各种公司（无论大小）的大量文章，它们都在从事与量子计算相关的不同项目。原因很大程度上是基于量子系统与经典系统相比所提供的潜在计算能力。提供加速、质量和可扩展性的潜力是大多数公司和研究机构目前重点关注的领域。
- en: By grasping the intricacies of the various quantum algorithms and learning how
    to apply them to a specific problem set or industry, researchers and developers
    can then look at extending what they learned about the small problems and apply
    them to large real-world enterprise solutions. This era of solving real-world
    problems using quantum computers that are intractable to classic computers is
    referred to as **quantum advantage**. Currently, most of the work being done centers
    on understanding and creating quantum computation algorithms, which are usually
    focused on smaller **toy problems**, as they are commonly referred to.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过掌握各种量子算法的复杂性，并学习如何将它们应用于特定的问题集或行业，研究人员和开发者可以进一步扩展他们对小问题的理解，并将它们应用于大型现实世界的企业解决方案。使用量子计算机解决经典计算机难以处理的现实世界问题这一时代被称为**量子优势**。目前，大部分工作集中在理解和创建量子计算算法上，这些算法通常集中在较小的**玩具问题**上，因为它们通常被称为。
- en: However, in 2021, IBM Quantum introduced a 127-qubit processor that broke the
    100-qubit barrier. This signifies a great move forward as it represents a barrier
    in which classical simulations may no longer mimic a quantum computer of equal
    size. Early evidence of this was found in 2023 when a 127-qubit Eagle processor
    was able to perform exact solutions to computational problems beyond classical
    brute force. Details about this can be found in the Nature article *Evidence for
    the utility of quantum computing before fault tolerance* ([https://www.nature.com/articles/s41586-023-06096-3](https://www.nature.com/articles/s41586-023-06096-3)
    ).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在2021年，IBM Quantum推出了一款127量子比特处理器，打破了100量子比特的壁垒。这标志着向前迈出了重要的一步，因为它代表了一个壁垒，在这个壁垒中，经典模拟可能再也无法模仿同等规模的量子计算机。2023年早期，这种迹象在127量子比特的Eagle处理器中得到了证实，它能够对超越经典穷举法的计算问题进行精确求解。关于这一点的详细信息可以在《自然》杂志的文章《在容错之前量子计算的有用性证据》中找到（[https://www.nature.com/articles/s41586-023-06096-3](https://www.nature.com/articles/s41586-023-06096-3)）。
- en: This brings us a step closer to the quantum advantage phase that everyone is
    racing to achieve. Of course, this will vary as some problems might require more
    quantum computational power than others, but, over time, different industries
    will eventually achieve it soon enough. To get yourselves suited up and in the
    race, you’ll need to understand some of the foundational quantum algorithms and
    how they are applied to solve general problems.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们更接近于大家都在竞相实现的量子优势阶段。当然，这会因问题而异，有些问题可能需要比其他问题更多的量子计算能力，但，随着时间的推移，不同的行业最终会很快实现这一点。为了让自己准备好并加入这场竞赛，你需要了解一些基础量子算法以及它们是如何应用于解决一般问题的。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding the meaning of outperforming classical systems
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解超越经典系统的意义
- en: Learning about the Deutsch algorithm
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Deutsch算法
- en: Understanding the Deutsch-Jozsa algorithm
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Deutsch-Jozsa算法
- en: Learning about the foundational oracle-based quantum algorithm
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解基于基础预言机量子算法
- en: In this chapter, we will review the various quantum algorithms in use today.
    One of the most difficult hurdles to overcome while learning about quantum algorithms
    is that it is not a lift and shift from classical to quantum. Simply implementing
    a classical algorithm’s steps from a classic system onto a quantum system, such
    as a simple adder, will not automatically make it a quantum speedup algorithm.
    There’s a bit more to it than that.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾目前使用的各种量子算法。在学习量子算法时，最难以克服的障碍之一是它并非是从经典到量子的一蹴而就。简单地将经典算法的步骤从经典系统转移到量子系统，例如一个简单的加法器，并不会自动使其成为量子加速算法。这比那还要复杂一些。
- en: In *Chapter 5*, *Understanding the Qubit*, we discussed how quantum states are
    manipulated, and in *Chapter 7*, *Programming with Qiskit*, we covered how to
    run a circuit on a quantum system. We will now put all those pieces together to
    learn about and create quantum algorithms and illustrate how they can outperform
    classical algorithms in this chapter. We will begin by providing an example of
    a quantum algorithm that is foundational and illustrate how quantum systems perform
    operations much faster by reviewing both the **Deutsch** and **Deutsch-Jozsa**
    algorithms. We’ll follow that up with more generalized algorithms that focus on
    solving simple problems with the **Bernstein**-**Vazirani** algorithm.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第5章*，*理解量子比特*中，我们讨论了量子状态的操控方法，而在*第7章*，*使用Qiskit编程*中，我们介绍了如何在量子系统上运行电路。现在，我们将把这些部分放在一起，学习并创建量子算法，并展示它们如何在本章中优于经典算法。我们将首先提供一个量子算法的例子，这个算法是基础性的，并通过回顾**Deutsch**和**Deutsch-Jozsa**算法来展示量子系统如何通过操作更快。接下来，我们将介绍更通用的算法，这些算法专注于使用**Bernstein**-**Vazirani**算法解决简单问题。
- en: This is by no means an exhaustive list of quantum algorithms, but this chapter
    will provide you with the early foundational algorithms that will help you understand
    the advanced algorithms and how they compare to classical algorithms. Should you
    want to see a more complete algorithm list, refer to *Appendix A,* *Resources*,
    for some links to sites that keep track of quantum algorithms and research. Of
    course, as the technology and algorithms advance, new algorithms will be discovered
    that may have different methods than the following, but in all of these, it is
    ideal to understand the basics to get you up and running without having to delve
    too deep into the physics.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝不是量子算法的详尽列表，但本章将为你提供一些早期的基础算法，这些算法将帮助你理解高级算法以及它们与经典算法的比较。如果你想看到一个更完整的算法列表，请参考*附录A*，*资源*，其中包含一些跟踪量子算法和研究的网站链接。当然，随着技术和算法的进步，可能会发现新的算法，这些算法可能具有与以下不同的方法，但在所有这些算法中，理想的情况是理解基础知识，这样你就可以快速上手，而不必深入研究物理学。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, it is expected that you have a basic understanding of linear
    algebra to understand the equations of each algorithm. You should also have some
    experience in programming basic circuits and executing them on your local simulator
    and a quantum device available on the **IBM Quantum** platform. Finally, you should
    be familiar with both classical bit notation and logic, quantum **Dirac notation**
    (or Bra-Ket notation), and understand the basic quantum computing principles such
    as superposition, entanglement, and interference that were covered in the previous
    chapters.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们期望你已经具备线性代数的基本知识，以便理解每个算法的方程。你还应该有一些编程基本电路并在本地模拟器和**IBM Quantum**平台上的量子设备上执行这些电路的经验。最后，你应该熟悉经典比特表示法和逻辑、量子**狄拉克表示法**（或括号表示法），以及理解前几章中涵盖的基本量子计算原理，如叠加、纠缠和干涉。
- en: 'Here is the full source code used throughout this book: [https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition](https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中使用的完整源代码如下：[https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition](https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition).
- en: Understanding the meaning of outperforming classical systems
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解优于经典系统的意义
- en: In this section, we will learn about the potential advantages that a quantum
    system has over classical systems by studying some of the early examples that
    illustrate quantum speedup versus classical systems, albeit some of the examples
    are simple illustrations of the advantages that, in themselves, do not have any
    practical usage.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过研究一些早期示例来了解量子系统相对于经典系统的潜在优势，尽管其中一些示例只是简单说明了优势，而这些优势本身并没有任何实际用途。
- en: Claims such as quantum systems potentially solving equations at rapid speeds
    over classical systems or having the capability of a larger computation space
    all sound fascinating. However, recall that, at the time of writing this chapter,
    there are still no quantum systems available that can outperform current classical
    systems in solving real-world commercial problems. “*So why all the chatter?*”
    you ask.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 声称量子系统可能在快速速度上解决方程式，超过经典系统，或者具有更大的计算空间的能力，这些都听起来非常吸引人。然而，回想一下，在撰写本章时，还没有可用的量子系统能够在解决现实世界的商业问题方面超越当前的经典系统。“*那么为什么会有这么多议论？*”你可能会问。
- en: The answer is simple—potential. Theoretically speaking, there are quantum algorithms
    that describe solutions to problems that illustrate quantum speedup, such as Shor’s
    algorithm. However, it is expected that we will see quantum advantage before we
    will see quantum breaks in encryption. This is because reaching quantum advantage
    is based on a specific problem. It will not be specific data for all; it will
    evolve as the technology is able to compute very large and complex circuits. To
    implement complex circuits or algorithms, we will require systems that contain
    error mitigation, suppression, and, eventually, correction in order to obtain
    accurate results. This, of course, could be similar to most new technologies.
    A good example of this is **video streaming**.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 答案很简单——潜力。从理论上讲，存在描述量子加速问题解决方案的量子算法，例如肖尔算法。然而，我们预计在看到量子加密的突破之前，我们将先看到量子优势。这是因为达到量子优势是基于特定问题的。它不会针对所有特定数据；它将随着技术能够计算非常庞大和复杂的电路而发展。为了实现复杂的电路或算法，我们需要包含错误缓解、抑制，最终是纠正的系统，以获得准确的结果。当然，这可能与大多数新技术相似。一个很好的例子是**视频流**。
- en: Multimedia compression has been around for decades, with video streaming invented
    in the early 1990s. When video compression was first made commercially available,
    internet bandwidth had increased and was more widely available, albeit the quality
    of the video and the audio was not as rich as it is today; the resolution was
    around 150 x 76 pixels, with a refresh rate of around 8–12 frames per second with
    poor audio quality. The limitation back then was both the compression technique
    to decrease the quality of the multimedia and the bandwidth to stream the multimedia
    content to multiple viewers simultaneously.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 多媒体压缩已经存在了几十年，视频流是在20世纪90年代初发明的。当视频压缩首次商业化时，互联网带宽已经增加，并且更广泛地可用，尽管视频和音频的质量不如今天丰富；分辨率大约是150
    x 76像素，刷新率大约是每秒8-12帧，音频质量较差。那时的限制是压缩技术降低多媒体质量以及带宽将多媒体内容流式传输到多个观众同时观看。
- en: 'The infrastructure to ensure proper decompression and minimize information
    loss was dependent on error correction, and a proper protocol to avoid low-quality
    and often jittery resolution. Now, of course, just a little over two decades later,
    we can see the progress: we can stream live multimedia events with low errors
    and high resolution. Streaming to your home theater system with a large 4K high-definition
    screen where you don’t have to worry too much about the quality of the video is
    something of a norm nowadays.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 确保适当解压缩和最小化信息损失的基础设施依赖于纠错，以及一个适当的协议来避免低质量和经常抖动的分辨率。当然，仅仅二十多年后，我们可以看到进步：我们可以以低错误率和高分辨率流式传输实时多媒体事件。现在，将视频流到拥有大尺寸4K高清屏幕的家庭影院系统，你不必太担心视频质量，这已经成为一种常态。
- en: 'Quantum systems share this same *roadmap*, where we have the hardware (quantum
    systems) and the algorithms to do things at a *medium resolution* now. The difference
    here is that we have something we did not have back then: a global infrastructure
    in which anyone, anywhere, has access to a quantum system via the cloud. IBM quantum
    computers are available for anyone to access by simply registering for a free
    account.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 量子系统拥有相同的**路线图**，我们现在有硬件（量子系统）和算法以中等分辨率做事。这里的区别在于，我们有一些当时没有的东西：一个全球性的基础设施，任何人，无论何地，都可以通过云访问量子系统。IBM量子计算机任何人都可以通过简单地注册免费账户来访问。
- en: In the early days of video streaming, very few had access to bandwidth. Those
    who did were limited by the infrastructure to collaborate. By having cloud-accessible
    systems, many industries and academic institutions are doing more research on
    quantum hardware and algorithms. Of course, back in the early days of multimedia
    streaming, the solutions being solved were classified as toy problems. However,
    don’t let the name fool you. These toy problems are far from just something to
    play with and show off to your colleagues. They are the stepping stones to real-world
    solutions.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在视频流媒体早期，很少有人能够访问带宽。那些能够访问的人受到基础设施的限制，无法协作。通过拥有云访问的系统，许多行业和学术机构正在对量子硬件和算法进行更多研究。当然，在多媒体流媒体早期，被解决的问题被归类为玩具问题。然而，不要被这个名字欺骗。这些玩具问题远非仅仅是用来玩耍和向同事炫耀的东西。它们是通往现实世界解决方案的垫脚石。
- en: For example, if you find a solution that illustrates quantum speedup vis-à-vis
    classical, with just a handful of qubits and very little quantum volume, then
    that might not be useful for solving many of today’s commercial or real-world
    problems.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你找到一个解决方案，它展示了量子速度相对于经典的速度，只需要几个量子比特和非常小的量子体积，那么这可能对解决许多当今的商业或现实世界问题没有用。
- en: What it does provide is the foundational information needed to scale your solution
    to a system with the necessary quantum volume to solve a real-world problem. To
    understand what that roadmap to quantum advantage is, where a quantum solution
    exists that can outperform a classical system in solving a real-world problem,
    it’s important to first understand the foundational quantum algorithms and how
    they not only differ from classical algorithms but also provide an advantage over
    them. This will simplify your understanding of other, more complex algorithms
    and how they are used to solve problems in various industries.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 它所提供的是将你的解决方案扩展到具有必要量子体积以解决实际问题的系统的基本信息。要理解通往量子优势的道路是什么，在哪里存在一个量子解决方案可以比经典系统更有效地解决实际问题时，首先理解基本的量子算法以及它们不仅与经典算法不同，而且比它们提供优势，这一点很重要。这将简化你对其他更复杂算法的理解以及它们如何被用于解决各个行业的各种问题。
- en: In the next section, we will discuss the various types of foundational quantum
    algorithms, starting with the original algorithms that demonstrate an advantage
    over classical systems.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论各种基础量子算法，从最初展示对经典系统优势的算法开始。
- en: Learning about Deutsch’s algorithm
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解德施特算法
- en: David Deutsch, a physicist at the **University of Oxford**, first discovered
    a problem that could be solved by a quantum computer faster than a classical computer.
    The problem itself has no importance or use in any computer problems, but it did
    serve to illustrate the advantage that quantum computation has over classical
    computation. Let’s understand that problem in the next section.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 大卫·德施特，牛津大学的物理学家，首先发现了一个可以用量子计算机比经典计算机更快解决的问题。这个问题本身在计算机问题中没有任何重要性或用途，但它确实用来说明量子计算相对于经典计算的优势。让我们在下一节中理解这个问题。
- en: Understanding the problem
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解问题
- en: 'The problem is very simple. We’ll use a simple analogy to explain it. Imagine
    someone is hiding a coin in each hand. Each coin, when revealed, will either be
    heads or tails. Since there are two coins, one in each hand, there are four possible
    results, as shown in the following table:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题非常简单。我们将用一个简单的类比来解释它。想象有人在每个手里藏了一枚硬币。每枚硬币，当揭示时，要么是正面要么是反面。由于有两枚硬币，一枚在手，一枚在手，所以有四种可能的结果，如下表所示：
- en: '| **Events** | **Left hand** | **Right hand** |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| **事件** | **左手** | **右手** |'
- en: '| 1 | Heads | Heads |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 正面 | 正面 |'
- en: '| 2 | Heads | Tails |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 正面 | 反面 |'
- en: '| 3 | Tails | Heads |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 反面 | 正面 |'
- en: '| 4 | Tails | Tails |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 反面 | 反面 |'
- en: 'Table 11.1: All four possible outcomes'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.1：所有四种可能的结果
- en: From the preceding list of events, we can see there are two categories. The
    first and fourth events are an example of a constant outcome, where both the left
    and right produce the same result of either heads or tails. The second and third
    events are examples of balanced outcomes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的事件列表中，我们可以看到有两种类型。第一和第四个事件是恒定结果的一个例子，其中左手和右手都产生相同的结果，要么是正面要么是反面。第二和第三个事件是平衡结果的一个例子。
- en: Here, the event results are the opposite of one another, indicating that if
    one is heads, then the other will be tails, or vice versa. Using this same analogy,
    if I were to reveal one hand at a time, let’s say the left hand, then by just
    viewing the results of the left hand, you would not have enough information to
    determine whether the result will be constant or balanced because you still need
    to know what is in the other hand.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，事件结果是相互对立的，这表明如果一个结果是正面，那么另一个将是反面，反之亦然。使用这个相同的类比，如果我要逐个揭示一只手，比如说左手，那么仅通过查看左手的结果，你将没有足够的信息来确定结果将是恒定还是平衡，因为你还需要知道另一只手的内容。
- en: Now, imagine there were 100 hands in front of you and you had to examine each
    hand one at a time in order to determine if there are a balanced number of heads
    and tails, or if all of the hands contain only heads or only tails. In the best-case
    scenario, you would get it on the first two tries, meaning if the first hand had
    heads and the second had tails, you can conclude that the results of the other
    hands will be balanced. On the other hand (pun intended), if the first two hands
    revealed the same, either heads or tails, then you cannot conclude that it is
    balanced or constant.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象你面前有100只手，你必须逐个检查每只手，以确定是否有平衡数量的正面和反面，或者所有手都只包含正面或只包含反面。在最佳情况下，你会在前两次尝试中得出结论，这意味着如果第一只手是正面，第二只手是反面，你就可以得出结论，其他手的结果将是平衡的。另一方面（有意为之），如果前两只手显示相同，无论是正面还是反面，那么你不能得出它是平衡的还是恒定的结论。
- en: You would have to, in a worst-case scenario, continue until the 51^(st) hand
    is revealed, because if the first 50 hands are heads, then the 51^(st) would indicate
    whether the whole set is constant (if the 51^(st) is heads) or balanced (if the
    51^(st) is tails). However, we are jumping ahead a little bit, so let’s stick
    to the current scope of the problem of just two events.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在最坏的情况下，你可能需要继续检查，直到第51只手被揭示，因为如果前50只手都是正面，那么第51只手将表明整个集合是恒定的（如果第51只是正面）还是平衡的（如果第51只是反面）。然而，我们有点超前了，所以让我们专注于当前的问题范围，即只有两个事件。
- en: Using a quantum algorithm, which is what Deutsch proposed here, to solve this
    problem is the same as opening all the hands at once and determining whether the
    first two qubits are constant or balanced. *Interesting, isn’t it?* Let’s see
    how this works!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用德鲁茨提出的量子算法来解决这个问题，相当于一次性打开所有手并确定前两个量子位是恒定还是平衡的。*有趣，不是吗？* 让我们看看它是如何工作的！
- en: 'We’ll begin by migrating the analogy of the problem to a mathematical equation.
    This will simplify the description of the solution later:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从将问题的类比迁移到数学方程式开始。这将简化稍后对解决方案的描述：
- en: First, substitute heads and tails with binary notations of 0 and 1, respectively.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将正面和反面分别用二进制数0和1表示。
- en: Next, we’ll refer to the result of each hand as a function ![](img/B18420_11_002.png),
    where the argument can refer to left or right, ![](img/B18420_11_003.png) or ![](img/B18420_11_004.png),
    respectively.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将每个手的结果称为一个函数 ![img/B18420_11_002.png]，其中自变量可以指左或右，![img/B18420_11_003.png]
    或 ![img/B18420_11_004.png]，分别。
- en: 'Therefore, the results are as follows. In this case, the function ![](img/B18420_11_002.png)
    is ![](img/B18420_11_006.png), where the argument *x* can be either a 0 or 1 (left
    or right). The results represent each of the events that have a different result,
    where each one is either balanced or constant:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，结果如下。在这种情况下，函数 ![img/B18420_11_002.png] 是 ![img/B18420_11_006.png]，其中自变量
    *x* 可以是0或1（左或右）。结果表示每个具有不同结果的事件，其中每个事件要么是平衡的，要么是恒定的：
- en: '| **Events** | ![](img/B18420_11_007.png) | ![](img/B18420_11_008.png) | **Results**
    |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| **事件** | ![img/B18420_11_007.png] | ![img/B18420_11_008.png] | **结果** |'
- en: '| 1 | 0 | 0 | Constant |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 0 | 恒定 |'
- en: '| 2 | 0 | 1 | Balanced |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 0 | 1 | 平衡 |'
- en: '| 3 | 1 | 0 | Balanced |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 1 | 0 | 平衡 |'
- en: '| 4 | 1 | 1 | Constant |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 1 | 1 | 恒定 |'
- en: 'Table 11.2: Mathematical representation of outcomes'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.2：结果的数学表示
- en: As you can see from the preceding table, now we can restate our problem as a
    function ![](img/B18420_11_002.png) that maps a single bit {0,1} to a result of
    either {0,1}, the results of which would be constant if the results for both ![](img/B18420_11_003.png)
    and ![](img/B18420_11_004.png) are the same, such as *Event 1* and *Event 4* (from
    the preceding table), or the results would be balanced otherwise. Now that we
    understand the problem, let’s figure out the solution.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如前表所示，现在我们可以将我们的问题重新表述为一个函数 ![图片](img/B18420_11_002.png)，它将单个比特 {0,1} 映射到 {0,1}
    的结果，如果 ![图片](img/B18420_11_003.png) 和 ![图片](img/B18420_11_004.png) 的结果相同，例如 *事件1*
    和 *事件4*（来自前表），则结果将是常数；否则，结果将是平衡的。现在我们理解了问题，让我们来找出解决方案。
- en: Defining the problem
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义问题
- en: 'We now know that if ![](img/B18420_11_003.png) = ![](img/B18420_11_004.png),
    then we say ![](img/B18420_11_002.png) is *constant*; otherwise, ![](img/B18420_11_002.png)
    is *balanced*. The problem becomes interesting if we were to introduce a **black
    box**, sometimes referred to as an oracle, that is hidden from us. We don’t know
    whether the function, hidden in the black box, is either constant or balanced,
    which is the problem we are asked to solve. The following diagram is a graphical
    example of our input value, *x*, going into the black box function, ![](img/B18420_11_002.png),
    and outputting the result value, ![](img/B18420_11_006.png):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道，如果 ![图片](img/B18420_11_003.png) = ![图片](img/B18420_11_004.png)，那么我们说
    ![图片](img/B18420_11_002.png) 是 *常数*；否则，![图片](img/B18420_11_002.png) 是 *平衡的*。如果我们引入一个
    **黑盒**，有时被称为神谕，对我们来说是隐藏的，那么问题就变得有趣了。我们不知道隐藏在黑盒中的函数是常数还是平衡的，这正是我们被要求解决的问题。以下图示是我们输入值
    *x* 进入黑盒函数 ![图片](img/B18420_11_002.png)，并输出结果值 ![图片](img/B18420_11_006.png) 的图形示例：
- en: '![Figure 13.5 – Black box representation of our problem ](img/B18420_11_01.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图13.5 – 我们问题的黑盒表示](img/B18420_11_01.png)'
- en: 'Figure 11.1: Black box representation of our problem'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1：我们问题的黑盒表示
- en: As you can see in the preceding diagram, this problem can be solved classically.
    However, it will need to have two queries to determine whether ![](img/B18420_11_002.png)
    is constant or balanced, where each query would view the results of both ![](img/B18420_11_003.png)
    and ![](img/B18420_11_004.png) to conclude whether it is constant or balanced.
    When using Deutsch’s quantum algorithm, we will see whether we can determine ![](img/B18420_11_002.png)
    using just one query that leverages the superposition principle. Let’s see how
    in the next section.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '如前图所示，这个问题可以用经典方法解决。但是，它需要两个查询来确定 ![图片](img/B18420_11_002.png) 是常数还是平衡的，其中每个查询都会查看
    ![图片](img/B18420_11_003.png) 和 ![图片](img/B18420_11_004.png) 的结果，以判断它是常数还是平衡的。当使用德意志的量子算法时，我们将看到是否可以通过利用叠加原理仅用一个查询来确定
    ![图片](img/B18420_11_002.png)。让我们在下一节中看看。 '
- en: Describing the problem as a quantum problem
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将问题描述为一个量子问题
- en: 'Since we are working with quantum computations, we’ll have to first switch
    to representing our functions and values using vectors. Therefore, our constant
    function, where both inputs result in the same output, can be represented in vector
    form as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在处理量子计算，我们首先需要将我们的函数和值表示为矢量。因此，我们的常数函数，其中两个输入都产生相同的输出，可以用以下矢量形式表示：
- en: '![](img/B18420_11_022.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18420_11_022.png)'
- en: 'The results of this function with a different input having the same result
    can be represented as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数对不同输入产生相同结果的输出可以表示如下：
- en: '![](img/B18420_11_023.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18420_11_023.png)'
- en: 'The function ![](img/B18420_11_002.png) can therefore be represented by the
    following matrix:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 ![图片](img/B18420_11_002.png) 可以用以下矩阵表示：
- en: '![](img/B18420_11_025.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18420_11_025.png)'
- en: 'Equally, the following is an example of a balanced function, where the results
    are the opposites of the two input values:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，以下是一个平衡函数的例子，其结果是两个输入值的相反数：
- en: '![](img/B18420_11_026.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18420_11_026.png)'
- en: '![](img/B18420_11_027.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18420_11_027.png)'
- en: '![](img/B18420_11_028.png) will be our black box, or oracle function. To do
    this, we will need to extend our previous diagram to include the extra components
    necessary to create our oracle:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B18420_11_028.png) 将成为我们的黑盒，或称为神谕函数。为此，我们需要扩展我们之前的图示，包括创建我们的神谕所需的额外组件：'
- en: First, we will convert our input and output registers into Dirac **ket notation**,
    ![](img/B18420_11_029.png).
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将我们的输入和输出寄存器转换为狄拉克 **矢量表示法** ![图片](img/B18420_11_029.png)。
- en: Next, we will create two input registers, ![](img/B18420_11_029.png) and ![](img/B18420_11_031.png),
    where the input registers will feed into our black box, or oracle function, ![](img/B18420_11_028.png),
    and the ![](img/B18420_11_031.png) register is used as an ancillary qubit. Ancilla
    qubits are extra bits used to store information that might be used later or to
    track information throughout the quantum circuit.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建两个输入寄存器，![](img/B18420_11_029.png) 和 ![](img/B18420_11_031.png)，其中输入寄存器将输入到我们的黑盒，或或然函数
    ![](img/B18420_11_028.png)，而 ![](img/B18420_11_031.png) 寄存器用作辅助量子比特。辅助量子比特是额外的位，用于存储可能稍后使用的信息或在整个量子电路中跟踪信息。
- en: 'Finally, we’ll define our two output registers: one that is just the same as
    the input ![](img/B18420_11_029.png), and the other that is the **XOR** of the
    input register *x* and the input register x *XORed* with the function ![](img/B18420_11_006.png),
    as ![](img/B18420_11_036.png).'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将定义我们的两个输出寄存器：一个与输入 ![](img/B18420_11_029.png) 相同，另一个是输入寄存器 *x* 和与函数 ![](img/B18420_11_006.png)
    XORed 的输入寄存器 x 的 **XOR**，如 ![](img/B18420_11_036.png)。
- en: 'Therefore, we can now define the oracle function as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在可以定义或然函数如下：
- en: '![](img/B18420_11_037.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_11_037.png)'
- en: 'This is illustrated as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这如下所示：
- en: '![Figure 13.6 – Graphical representation of the Deutsch algorithm ](img/B18420_11_02.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.6 – Deutsch算法的图形表示](img/B18420_11_02.png)'
- en: 'Figure 11.2: Graphical representation of the Deutsch algorithm'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2：Deutsch算法的图形表示
- en: 'Another requirement is that the function should be reversible and we can test
    to see if it is by working it out in reverse:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个要求是该函数应该是可逆的，我们可以通过反向工作来测试它：
- en: '![](img/B18420_11_038.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_11_038.png)'
- en: Now that we have our function defined as a quantum function for our problem,
    we’ll see how Deutsch’s algorithm works.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将函数定义为我们的问题的量子函数，我们将看到Deutsch算法是如何工作的。
- en: Implementing Deutsch’s algorithm
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现Deutsch算法
- en: 'In this section, we will implement the algorithm with a balanced function as
    an example but will leave it to you to update the code to implement a constant
    function. We’ll examine the Deutsch algorithm and step through each task as we
    build the algorithm on the IQL as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将以平衡函数为例实现算法，但将代码更新以实现常量函数的任务留给你。我们将检查Deutsch算法，并在构建IQL算法时逐步执行每个任务如下：
- en: 'Open a new Jupyter notebook where you have Qiskit installed, and in the first
    cell, include the helper file:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你已安装Qiskit的新Jupyter笔记本中打开，并在第一个单元中包含辅助文件：
- en: '[PRE0]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we will create a 2-qubit circuit and prepare each input, the first to
    ![](img/B18420_06_015.png) and the second to ![](img/B18420_06_018.png). We will
    use the identity gate to represent the ![](img/B18420_06_015.png), which is the
    initial state, and an X-gate to represent the initial state of ![](img/B18420_06_018.png):'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个双量子比特电路，并为每个输入准备，第一个到 ![](img/B18420_06_015.png)，第二个到 ![](img/B18420_06_018.png)。我们将使用恒等门来表示
    ![](img/B18420_06_015.png)，即初始状态，以及X门来表示 ![](img/B18420_06_018.png)的初始状态：
- en: '[PRE1]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This results in the following circuit diagram:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了以下电路图：
- en: '![Figure 13.7 – Initializing the qubits to 0 and 1 ](img/B18420_11_03.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.7 – 初始化量子比特为 0 和 1](img/B18420_11_03.png)'
- en: 'Figure 11.3: Initializing the qubits to 0 and 1'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3：初始化量子比特为 0 和 1
- en: As you can see from the preceding diagram, **q**[0] is set to ![](img/B18420_06_015.png)
    and **q**[1] is set to ![](img/B18420_06_018.png), which creates the first state
    at the barrier (![](img/B18420_11_045.png)) as ![](img/B18420_11_046.png). The
    use of the barrier is just to indicate checkpoints as we traverse through each
    operation in the circuit.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，**q**[0] 被设置为 ![](img/B18420_06_015.png)，**q**[1] 被设置为 ![](img/B18420_06_018.png)，这创建了第一个状态在障碍(![](img/B18420_11_045.png))处为
    ![](img/B18420_11_046.png)。使用障碍只是为了在遍历电路中的每个操作时指示检查点。
- en: 'Now that our inputs are set, we will place them in a superposition state using
    Hadamard gates. This will allow us to iterate through once while leveraging all
    four states, rather than iterating through each of them one at a time:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经设置了输入，我们将使用Hadamard门将它们置于叠加态。这将使我们能够利用所有四个状态进行一次迭代，而不是逐个迭代：
- en: '[PRE2]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The result of the preceding code is illustrated in the following diagram. The
    barriers are used to separate each step so as to simplify reading the circuit:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码的结果如下所示。障碍用于分隔每个步骤，以便简化电路的阅读：
- en: '![Figure 13.8 – Applying Hadamard to both qubits ](img/B18420_11_04.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.8 – 对两个量子比特应用Hadamard](img/B18420_11_04.png)'
- en: 'Figure 11.4: Applying Hadamard gates to both qubits'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4：对两个量子比特应用Hadamard门
- en: 'As you can see from the preceding diagram, the Hadamard gate transforms the
    basis vectors for each qubit as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，Hadamard门将每个量子比特的基向量转换为以下形式：
- en: '![](img/B18420_11_047.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_11_047.png)'
- en: 'This generates the following state at the second barrier as ![](img/B18420_11_048.png),
    where ![](img/B18420_11_049.png) describes a single qubit:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这在第二个势垒处生成以下状态 ![](img/B18420_11_048.png)，其中 ![](img/B18420_11_049.png) 描述了一个单个量子比特：
- en: '![](img/B18420_11_050.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_11_050.png)'
- en: 'After the qubits have applied the preceding Hadamard gates, the resulting value
    for the quantum registers will be as follows:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在量子比特应用了前面的Hadamard门之后，量子寄存器的结果值将如下所示：
- en: '![](img/B18420_11_051.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_11_051.png)'
- en: 'One thing to note here is that we now have the second qubit in a ![](img/B18420_11_052.png)
    superposition, ![](img/B18420_11_053.png). This allows us to define the first
    and second qubit out of ![](img/B18420_11_028.png), as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一点需要注意，我们现在将第二个量子比特置于 ![](img/B18420_11_052.png) 超叠加状态，![](img/B18420_11_053.png)。这允许我们定义
    ![](img/B18420_11_028.png) 中的第一个和第二个量子比特，如下所示：
- en: '![](img/B18420_11_055.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_11_055.png)'
- en: From the preceding equation, you can see that the second qubit, grouped in the
    second set of parentheses, has the same value, which is the ![](img/B18420_11_056.png)
    superposition, ![](img/B18420_11_049.png).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 从前一个方程中，你可以看到第二个量子比特，分组在第二组括号中，具有相同的值，即 ![](img/B18420_11_056.png) 超叠加状态，![](img/B18420_11_049.png)。
- en: However, the first qubit we see has an interesting result. Let’s dig a little
    deeper to understand what this means.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们看到的第一个量子比特有一个有趣的结果。让我们深入挖掘以了解这意味着什么。
- en: 'Here, we see that if ![](img/B18420_11_002.png) is constant, we’ll have the
    following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到如果 ![](img/B18420_11_002.png) 是恒定的，我们将得到以下结果：
- en: '![](img/B18420_11_059.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_11_059.png)'
- en: 'If ![](img/B18420_11_002.png) is balanced, then we’ll have the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 ![](img/B18420_11_002.png) 是平衡的，那么我们将得到以下结果：
- en: '![](img/B18420_11_061.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_11_061.png)'
- en: Note that the second qubit is always the same, but the first has a phase kickback
    from positive if constant, and negative if balanced. This phase kickback is a
    common trick used in many quantum algorithms, so rest assured we will see this
    again.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第二个量子比特始终相同，但第一个量子比特如果恒定则会有正相位回弹，如果平衡则会有负相位回弹。这种相位回弹是许多量子算法中常用的技巧，所以请放心，我们还会再次看到它。
- en: Next, by applying a Hadamard gate to the first qubit, we can see something interesting
    as a result. Let’s look at this one at a time.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过将Hadamard门应用于第一个量子比特，我们可以看到一些有趣的结果。让我们逐个来看。
- en: 'For a constant function, the first qubit is set to the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个恒定函数，第一个量子比特被设置为以下状态：
- en: '![](img/B18420_11_062.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_11_062.png)'
- en: We recall that applying a Hadamard gate to this superposition state will return
    us to the ![](img/B18420_06_015.png) state.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回忆一下，将Hadamard门应用于这个超叠加状态将带我们回到 ![](img/B18420_06_015.png) 状态。
- en: 'For the balanced function, the first qubit is set to the following superposition
    state:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于平衡函数，第一个量子比特被设置为以下超叠加状态：
- en: '![](img/B18420_11_064.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_11_064.png)'
- en: We can also recall that applying a Hadamard gate to the previous superposition
    state will return us to the ![](img/B18420_06_018.png) state.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以回忆一下，将Hadamard门应用于前面的超叠加状态将带我们回到 ![](img/B18420_06_018.png) 状态。
- en: This means that measuring only the first qubit after applying a Hadamard gate
    to it will provide us with a resulting state of either ![](img/B18420_06_015.png)
    or ![](img/B18420_06_018.png), constant or balanced, respectively.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在将Hadamard门应用于它之后仅测量第一个量子比特将为我们提供以下结果状态之一：![](img/B18420_06_015.png) 或 ![](img/B18420_06_018.png)，分别是恒定或平衡状态。
- en: Let’s implement this using our Qiskit notebook.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用我们的Qiskit笔记本来实现这一点。
- en: This is where we wish to set a quantum gate that would operate on q[1], which
    represents the *y* value, based on the value of q[0], which represents the *x*
    value. Therefore, this operator, which we’ll call ![](img/B18420_11_028.png),
    will have inputs (*x*, *y*). The gate we will use to represent this will be a
    **Control-Not** (**CNOT**) gate. The reason for using this for the balanced function
    is because it produces the Bell states 01 and 10 with the input qubits. And, of
    course, this could be switched to the other two Bell states, 00 and 11, by adding
    an X gate, which would make this a constant function.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们希望设置一个量子门来操作q[1]，它代表*y*值，基于q[0]的值，它代表*x*值的地方。因此，这个操作符，我们将称之为![](img/B18420_11_028.png)，将有输入(*x*,
    *y*)。我们将使用表示这个的**控制非**（**CNOT**）门。使用这个平衡函数的原因是因为它产生Bell态01和10，输入量子比特。当然，通过添加X门，这可以切换到其他两个Bell态，00和11，这将使其成为一个常数函数。
- en: 'In this case, we are working to create a balanced function, one to one, which
    equates to the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们正在努力创建一个平衡函数，一对一，这相当于以下内容：
- en: '![](img/B18420_11_069.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_11_069.png)'
- en: 'To accomplish this, we will need to define our state operator, ![](img/B18420_11_028.png),
    as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个，我们需要定义我们的状态算符![](img/B18420_11_028.png)，如下所示：
- en: '![](img/B18420_11_071.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_11_071.png)'
- en: 'Now, we will place a CNOT gate with the control on the first qubit, **q**[0],
    and the target on the second qubit, **q**[1]:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将放置一个控制位在第一个量子比特**q**[0]，目标在第二个量子比特**q**[1]上的CNOT门：
- en: '[PRE3]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This should now include the CNOT gate that generates the function type (balanced)
    and renders the following diagram:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这现在应该包括生成函数类型（平衡）的CNOT门，并呈现以下图示：
- en: '![Figure 13.9 – Defining the function type (balanced) ](img/B18420_11_05.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图13.9 – 定义函数类型（平衡）](img/B18420_11_05.png)'
- en: 'Figure 11.5: Defining the function type (balanced)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5：定义函数类型（平衡）
- en: 'Next, we’ll add Hadamard gates to all qubits and a measurement operator to
    the first qubit:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将向所有量子比特添加Hadamard门，并将测量算符添加到第一个量子比特：
- en: '[PRE4]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As we saw in our equation earlier, we only need to apply a Hadamard gate to
    the first qubit, as we will only be measuring the one qubit:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前方程中看到的，我们只需要对第一个量子比特应用Hadamard门，因为我们只测量一个量子比特：
- en: '![Figure 13.10 – Applying the Hadamard gate to the qubits before measuring
    ](img/B18420_11_06.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图13.10 – 在测量之前对量子比特应用Hadamard门](img/B18420_11_06.png)'
- en: 'Figure 11.6: Applying the Hadamard gate to the qubits before measuring'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6：在测量之前对量子比特应用Hadamard门
- en: 'This results in the following state, ![](img/B18420_11_072.png):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下状态，![](img/B18420_11_072.png)：
- en: '![](img/B18420_11_073.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_11_073.png)'
- en: '![](img/B18420_11_074.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_11_074.png)'
- en: '![](img/B18420_11_075.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_11_075.png)'
- en: '![](img/B18420_11_076.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_11_076.png)'
- en: 'Let’s now apply some algebra to simplify our results:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们对结果应用一些代数来简化它们：
- en: '![](img/B18420_11_077.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_11_077.png)'
- en: Since we will only be measuring the first qubit, we can throw the second qubit
    away or just not measure it as it is just an ancillary qubit in this case.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只测量第一个量子比特，我们可以丢弃第二个量子比特，或者根本不测量它，因为在这种情况下它只是一个辅助量子比特。
- en: 'Let’s take a measurement of the first qubit, shown as follows, the result of
    which will determine the category of the function as either balanced (`1`) or
    constant (`0`):'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们对第一个量子比特进行测量，如下所示，其结果将确定函数的类别，要么是平衡（`1`），要么是常数（`0`）：
- en: '[PRE5]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We already know from the previous equation that this should equate to a balanced
    function:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从之前的方程中知道，这应该等于一个平衡函数：
- en: '![Figure 13.11 – Applying the measurement operator to just the first qubit
    ](img/B18420_11_07.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图13.11 – 仅对第一个量子比特应用测量算符](img/B18420_11_07.png)'
- en: 'Figure 11.7: Applying the measurement operator to just the first qubit'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7：仅对第一个量子比特应用测量算符
- en: 'Next, to simplify a few things, let’s define a function to run our circuits
    on a Sampler installed on your local machine. We’ll use the following function,
    which leverages the `StatevectorSampler`:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为了简化一些事情，让我们定义一个函数来在我们的本地机器上安装的采样器上运行我们的电路。我们将使用以下函数，该函数利用`StatevectorSampler`：
- en: '[PRE6]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now we can run the preceding circuit and verify our results by using the following
    code:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以运行前面的电路，并使用以下代码验证我们的结果：
- en: '[PRE7]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As calculated previously, the results of this experiment indicate a balanced
    function, as indicated by the result `1`, rather than `0`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述计算，这个实验的结果表明这是一个平衡函数，如结果`1`所示，而不是`0`。
- en: 'This results in the following output:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下输出：
- en: '![A blue rectangular graph with white text  Description automatically generated](img/B18420_11_08.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![一个带有白色文字的蓝色矩形图表，描述自动生成](img/B18420_11_08.png)'
- en: 'Figure 11.8: Result of value 1, indicating a balanced function'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.8：值为 1 的结果，表示平衡函数
- en: As expected, we see that our result is **1**, indicating a balanced function.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，我们看到结果是 **1**，表明这是一个平衡函数。
- en: Observe that to retrieve the counts from the results, we need to map to the
    data object and then to the name of the classical register that we wish to extract
    the counts from.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，要从结果中检索计数，我们需要映射到数据对象，然后映射到我们希望从中提取计数的经典寄存器的名称。
- en: From the preceding output, the result shows the same as what we expected for
    the given function we provided, which, in this case, is the balanced function,
    where 1 has a higher probability. There is an exercise in the *Questions* section
    where you are required to create a constant function.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，结果显示与我们所期望的给定函数相同，在这种情况下，是一个平衡函数，其中 1 的概率更高。在 *问题* 部分有一个练习，要求你创建一个常数函数。
- en: What we have shown here is the potential of a quantum algorithm to perform operations
    faster than a classical system, which would otherwise need to calculate each function
    in series for each input. Naturally, this exercise does not offer any real-world
    applications, but it does help in understanding how these systems have potential
    speedup properties. In the next section, we will look at generalizing this example
    by applying it to more than one qubit.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里展示的是量子算法执行操作比经典系统更快的能力，否则它需要为每个输入按顺序计算每个函数。当然，这个练习并不提供任何实际应用，但它有助于理解这些系统具有潜在的加速特性。在下一节中，我们将通过将其应用于多个量子比特来推广这个例子。
- en: Understanding the Deutsch-Jozsa algorithm
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 Deutsch-Jozsa 算法
- en: In the previous section, the Deutsch algorithm provided us with an example of
    quantum speedup where we use two qubits but only measure one qubit. Here, the
    **Deutsch-Jozsa** algorithm provides a more generalized form of the algorithm.
    It can be applied to more than one qubit. Originally proposed by David Deutsch
    and Richard Jozsa in 1992, with improvements by Richard Cleve, Artur Ekert, Chiara
    Macchiavello, and Michele Mosca in 1998, the problem is still the same, but as
    we mentioned at the end of the previous section, the problem is now extended to
    more than just a single qubit. The Deutsch-Jozsa algorithm will operate on multiple
    qubits at once, and, of course, will still provide a quantum speedup compared
    with classical computing as it would need to calculate each event in series, as
    we will see in the next section.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，Deutsch 算法为我们提供了一个量子加速的例子，我们使用了两个量子比特，但只测量了一个量子比特。在这里，**Deutsch-Jozsa**
    算法提供了一个更通用的算法形式。它可以应用于多个量子比特。该问题最初由 David Deutsch 和 Richard Jozsa 在 1992 年提出，并在
    1998 年由 Richard Cleve、Artur Ekert、Chiara Macchiavello 和 Michele Mosca 进行了改进，问题仍然是相同的，但正如我们在上一节末提到的，问题现在扩展到了不仅仅是单个量子比特。Deutsch-Jozsa
    算法将同时作用于多个量子比特，当然，与经典计算相比，它仍然会提供量子加速，因为它需要按顺序计算每个事件，正如我们将在下一节中看到的。
- en: Understanding the Deutsch-Jozsa problem
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 Deutsch-Jozsa 问题
- en: 'In this example, we will extend the previous definition of the problem. Previously,
    we defined our problem on a single-bit value function to determine whether a function
    was constant or balanced, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将扩展之前的问题定义。之前，我们在单比特值函数上定义了我们的问题，以确定一个函数是常数还是平衡的，如下所示：
- en: '![](img/B18420_11_078.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18420_11_078.png)'
- en: 'In this case, we will expand the problem to include more than one bit as an
    input, such that:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将问题扩展到包含多个比特作为输入，以便：
- en: '![](img/B18420_11_079.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18420_11_079.png)'
- en: You can see from the preceding equation that ![](img/B18420_11_002.png) is *constant*
    if ![](img/B18420_11_006.png)is the same for all, that is, ![](img/B18420_11_082.png).
    Otherwise, ![](img/B18420_11_002.png) is *balanced* if ![](img/B18420_11_084.png)
    for half of x, and ![](img/B18420_11_085.png) for the other half of x. For example,
    if we set *n* equal to 2 in our input values, ![](img/B18420_11_086.png), then
    this will result in four different input values, that is, 00, 01, 10, and 11.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从前面的方程式中看到，如果对于所有情况 ![](img/B18420_11_002.png) 是相同的，即 ![](img/B18420_11_006.png)，那么
    ![](img/B18420_11_002.png) 是**常数**的。否则，如果对于 x 的一半 ![](img/B18420_11_084.png) 和
    x 的另一半 ![](img/B18420_11_085.png)，那么 ![](img/B18420_11_002.png) 是**平衡**的。例如，如果我们把输入值中的
    *n* 设置为 2，即 ![](img/B18420_11_086.png)，那么这将产生四个不同的输入值，即 00、01、10 和 11。
- en: 'Based on these four possible input values of x, to create a balanced function,
    we can set the first half of the results to 0, such that:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这四个可能的输入值 x，为了创建一个平衡函数，我们可以将结果的前半部分设置为 0，如下所示：
- en: '| **Input 1** | **Input 2** | **Output** |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| **输入 1** | **输入 2** | **输出** |'
- en: '| 0 | 0 | 0 |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 |'
- en: '| 0 | 1 | 0 |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 0 |'
- en: 'We can set the second half of the results to 1:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将结果的后半部分设置为 1：
- en: '| **Input 1** | **Input 2** | **Output** |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| **输入 1** | **输入 2** | **输出** |'
- en: '| 1 | 0 | 1 |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 |'
- en: '| 1 | 1 | 1 |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 |'
- en: If we were to solve this classically, we would need ![](img/B18420_11_087.png)
    queries to determine whether the results are constant or balanced. On the other
    hand, the Deutsch-Jozsa algorithm will only require one query in order to determine
    whether the function is constant or balanced, just as in the Deutsch algorithm.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用经典方法来解决这个问题，我们需要 ![](img/B18420_11_087.png) 次查询来确定结果是否恒定或平衡。另一方面，Deutsch-Jozsa
    算法只需要一次查询就能确定函数是否恒定或平衡，就像在 Deutsch 算法中一样。
- en: Generating a quantum solution using the Deutsch-Jozsa algorithm
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Deutsch-Jozsa 算法生成量子解
- en: 'To generate our quantum circuit to implement the Deutsch-Jozsa algorithm, we
    will use some of the same components as before:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成实现 Deutsch-Jozsa 算法的量子电路，我们将使用之前的一些相同组件：
- en: Let’s start with our inputs to our black box (oracle). The first input register
    is an *n*-bit string representing the input X. We denote this with a capital X,
    as most texts refer to single qubit or bit values with a lowercase variable such
    as ![](img/B18420_11_029.png), whereas multi-qubits are represented by uppercase
    variables such as ![](img/B18420_11_089.png).
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从黑盒（或门）的输入开始。第一个输入寄存器是一个 *n* 比特字符串，表示输入 X。我们用大写 X 表示，因为大多数文本用小写变量（如 ![](img/B18420_11_029.png)）来引用单个量子比特或比特值，而多量子比特用大写变量（如
    ![](img/B18420_11_089.png)）表示。
- en: The second input register is a single-bit string representing the input y, which,
    as before, is initialized to 1\. This is commonly referred to as an **ancilla
    qubit**.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个输入寄存器是一个表示输入 y 的单比特字符串，正如之前一样，它被初始化为 1。这通常被称为 **辅助量子比特**。
- en: 'Next, we define the function of the oracle similar to how we did in the previous
    form. However, the difference here is that ![](img/B18420_11_029.png) is now a
    multi-qubit input, ![](img/B18420_11_089.png). ![](img/B18420_11_028.png) is then
    defined as follows:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义类似之前形式的或门函数。然而，这里的区别在于 ![](img/B18420_11_029.png) 现在是一个多量子比特输入，![](img/B18420_11_089.png)。![](img/B18420_11_028.png)
    定义如下：
- en: '![](img/B18420_11_093.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_11_093.png)'
- en: 'So, our output would similarly map to two outputs. The first is the same as
    the first input ![](img/B18420_11_089.png), and the second output is our function
    ![](img/B18420_11_095.png). This results in the following graphical representation:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的输出将类似于两个输出。第一个与第一个输入 ![](img/B18420_11_089.png) 相同，第二个输出是我们的函数 ![](img/B18420_11_095.png)。这导致了以下图形表示：
- en: '![Figure 13.14 – Graphical representation of the Deutsch-Jozsa algorithm ](img/B18420_11_09.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.14 – Deutsch-Jozsa 算法的图形表示](img/B18420_11_09.png)'
- en: 'Figure 11.9: Graphical representation of the Deutsch-Jozsa algorithm'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9：Deutsch-Jozsa 算法的图形表示
- en: Now that we have defined our components, let’s implement this block digram as
    a circuit in the next section.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的组件，让我们在下一节中将这个框图实现为一个电路。
- en: Implementing the Deutsch-Jozsa algorithm
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现 Deutsch-Jozsa 算法
- en: In this example we will implement the Deutsch-Jozsa algorithm to determine that
    a given function is constant in one query, whereas determining the same on a classical
    system will require multiple queries, therefore illustrating how using quantum
    computing can provide a speedup.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将实现 Deutsch-Jozsa 算法，以确定给定的函数在一次查询中是恒定的，而在经典系统中确定相同的结果将需要多次查询，从而说明使用量子计算可以提供加速。
- en: 'In order to implement the Deutsch-Jozsa algorithm, create a new Qiskit notebook
    and run the boilerplate cell to load up all our Qiskit modules. Once the setup
    is complete, let’s create our circuit step by step and see how it resolves our
    problem as we go:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现 Deutsch-Jozsa 算法，创建一个新的 Qiskit 笔记本并运行模板单元格以加载所有 Qiskit 模块。一旦设置完成，让我们一步一步地创建我们的电路，并看看它如何随着我们的进展解决我们的问题：
- en: 'First, let’s set our input values. We will start by creating a quantum circuit
    with two inputs, the first set to `X`, which we will create as a 4-qubit input,
    followed by a single qubit representing `y`, which we will initialize to `1`.
    Then we will apply a Hadamard gate to all the input qubits:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们设置我们的输入值。我们将从创建一个具有两个输入的量子电路开始，第一个设置为 `X`，我们将创建一个 4 量子比特输入，然后是一个表示 `y`
    的单个量子比特，我们将它初始化为 `1`。然后我们将 Hadamard 门应用于所有输入量子比特：
- en: '[PRE8]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will result in the following diagram:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下图：
- en: '![Figure 13.15 – Preparing the input values of our quantum circuit ](img/B18420_11_10.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.15 – 准备我们的量子电路的输入值](img/B18420_11_10.png)'
- en: 'Figure 11.10: Preparing the input values of our quantum circuit'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.10：准备我们的量子电路的输入值
- en: 'The input state results in the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 输入状态的结果如下：
- en: '![](img/B18420_11_096.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图片 B18420_11_096](img/B18420_11_096.png)'
- en: 'When we apply a Hadamard gate to the preceding equation, it breaks out into
    the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将 Hadamard 门应用于前面的方程时，它分解为以下方程：
- en: '![](img/B18420_11_097.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图片 B18420_11_097](img/B18420_11_097.png)'
- en: 'When we apply a Hadamard gate to the single qubit ![](img/B18420_11_098.png),
    this gives us the following equation:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将 Hadamard 门应用于单个量子比特 ![](img/B18420_11_098.png) 时，这给我们以下方程：
- en: '![](img/B18420_11_099.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图片 B18420_11_099](img/B18420_11_099.png)'
- en: 'Simplifying both ![](img/B18420_11_100.png) and ![](img/B18420_11_101.png)
    gives us the following equation:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 简化 ![](img/B18420_11_100.png) 和 ![](img/B18420_11_101.png) 得到以下方程：
- en: '![](img/B18420_11_102.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图片 B18420_11_102](img/B18420_11_102.png)'
- en: 'Next, we will create the oracle ![](img/B18420_11_028.png) function for our
    circuit similar to how we created it in the previous section on the Deutsch algorithm.
    We will use the same here, only this time, we have the ket X, which is more than
    a single bit of information:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将为我们的电路创建预言机函数 ![](img/B18420_11_028.png)，类似于我们在上一节关于 Deutsch 算法的部分中创建它的方式。我们将在这里使用相同的，只是这次，我们有了
    ket X，它包含的信息不止一个比特：
- en: '![](img/B18420_11_104.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图片 B18420_11_104](img/B18420_11_104.png)'
- en: The value of x is the bit representation of the bit string X of 0 or 1.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: x 的值是位串 X 的 0 或 1 的位表示。
- en: 'Let’s now set our input state using a bit string to represent the balanced
    ![](img/B18420_11_028.png) function—in this case, `''1010''`, which we construct
    by placing an X gate with the set bits and Identity gates with the others. This
    will allow us to determine whether the input is balanced or constant—in this case,
    since we have an equal number of 1s and 0s, it is balanced. You can also just
    not add an Identity gate, but for now, we will add one just to visually indicate
    the `0` values of the bit string:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用位串来设置我们的输入状态，以表示平衡的 ![](img/B18420_11_028.png) 函数——在这种情况下，`'1010'`，我们通过放置一个
    X 门到设置位和其余的恒等门来构建它。这将使我们能够确定输入是平衡的还是常数——在这种情况下，因为我们有相等数量的 1 和 0，它是平衡的。你也可以不添加恒等门，但为了现在，我们将添加一个，以便直观地表示位串的
    `0` 值：
- en: '[PRE9]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will render the following addition to our circuit, where the added section
    represents setting the input state ![](img/B18420_11_106.png) based on the bit
    string `1010`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们的电路中添加以下部分，其中添加的部分表示根据位串 `1010` 设置输入状态 ![](img/B18420_11_106.png)：
- en: '![Figure 13.16 – State representation |1010 of bit string 1010 ](img/B18420_11_11.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.16 – 位串 1010 的状态表示 |1010](img/B18420_11_11.png)'
- en: 'Figure 11.11: State representation ![](img/B18420_11_106.png) of the bit string
    1010'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.11：位串 1010 的状态表示 ![](img/B18420_11_106.png)
- en: 'Next, we will apply our oracle. In this case, we will set it to a constant
    output where all outputs should be 1s, with zero probability of 0s. We’ll do so
    by adding CNOT gates, where the Control is applied to each qubit and the Target
    is set to the last qubit:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将应用我们的预言机。在这种情况下，我们将它设置为常数输出，其中所有输出都应该是 1，0 的概率为零。我们将通过添加 CNOT 门来实现这一点，其中控制位应用于每个量子比特，目标设置为最后一个量子比特：
- en: '[PRE10]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The result of this should be as follows, where we set each Control of the CNOT
    gate to all qubits and the Target to our ancilla qubit, **q**[4]:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果应该是这样的，其中我们设置了每个 CNOT 门的控制位到所有量子比特，目标到我们的辅助量子比特 **q**[4]：
- en: '![Figure 13.17 – Representation of the added balanced oracle ](img/B18420_11_12.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.17 – 添加的平衡预言机的表示](img/B18420_11_12.png)'
- en: 'Figure 11.12: Representation of the added balanced oracle'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.12：添加的平衡预言机的表示
- en: 'Next, we will set the closing bit string, which we use to wrap our oracle—in
    this case, `''1010''`:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将设置关闭的位串，我们用它来封装我们的预言机——在这种情况下，`'1010'`：
- en: '[PRE11]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code will give us the following diagram, just as we expected,
    where the oracle is bound by the bit string:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将给出以下图，正如我们所期望的，其中预言机被位串绑定：
- en: '![Figure 13.18 – Oracle bounded by bit string representation ](img/B18420_11_13.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.18 – 由位串表示限定的 Oracle](img/B18420_11_13.png)'
- en: 'Figure 11.13: Oracle bounded by the bit string representation'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.13：由位串表示限定的 Oracle
- en: 'Next, we will apply the Hadamard gates to all the qubits:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将应用 Hadamard 门到所有的量子位上：
- en: '[PRE12]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The result of this is rendered as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果如下所示：
- en: '![Figure 13.19 – Completed quantum circuit of the Deutsch-Jozsa algorithm for
    a balanced function ](img/B18420_11_14.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.19 – 完成的 Deutsch-Jozsa 算法量子电路](img/B18420_11_14.png)'
- en: 'Figure 11.14: A complete quantum circuit of the Deutsch-Jozsa algorithm for
    a balanced function'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.14：平衡函数的 Deutsch-Jozsa 算法的完整量子电路
- en: 'Finally, we will add our measurements so that we can read out the results.
    We will apply the measurements only to the first four qubits:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将添加我们的测量，以便我们可以读取结果。我们只将对前四个量子位应用测量：
- en: '[PRE13]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Therefore, our final quantum circuit should be as follows. Each step in creating
    the Deutsch-Jozsa algorithm is separated by the barriers, where the first is the
    preparation, the second is to set the bit string `1010`, the third is to set our
    oracle ![](img/B18420_11_028.png), and then we reverse the first two steps, followed
    by our measurements:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的最终量子电路应该是这样的。创建 Deutsch-Jozsa 算法的每一步都由壁垒分开，第一步是准备，第二步是设置位串 `1010`，第三步是设置我们的
    Oracle ![img/B18420_11_028.png]，然后我们反转前两步，接着进行测量：
- en: '![Figure 13.20 – Final circuit for the Deutsch-Jozsa algorithm ](img/B18420_11_15.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.20 – Deutsch-Jozsa 算法的最终电路](img/B18420_11_15.png)'
- en: 'Figure 11.15: Final circuit for the Deutsch-Jozsa algorithm'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.15：Deutsch-Jozsa 算法的最终电路
- en: 'Now that we have created our quantum circuit for the Deutsch-Jozsa algorithm,
    let’s execute the circuit on a simulator first to visualize what results we get
    back:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了 Deutsch-Jozsa 算法的量子电路，让我们首先在模拟器上执行电路，以可视化我们得到的结果：
- en: '[PRE14]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As expected, our results returned a probability of 100% of 1s for a balanced
    circuit:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，我们的结果返回了一个平衡电路 100% 的 1s 概率：
- en: '![A blue rectangular graph with white lines  Description automatically generated](img/B18420_11_16.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![一个蓝色矩形图，带有白色线条  自动生成的描述](img/B18420_11_16.png)'
- en: 'Figure 11.16: Results from the simulator of a balanced function'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.16：平衡函数模拟器的结果
- en: As expected, we see that we have a high quasi-probability of `1111`. This was
    computed using a single query, as opposed to the multiple queries that we would
    have needed to compute the same thing classically.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，我们看到我们有一个高准概率的 `1111`。这是通过单次查询计算的，而不是我们通常在经典计算中需要的多次查询。
- en: Now that we have completed both the Deutsch and Deutsch-Jozsa algorithms, we
    can see that there is some speedup when compared to classical systems. However,
    we can also see that there are no practical or real-world examples where we can
    apply these algorithms. That said, we have understood how the use of superposition
    and entanglement can speed up certain functions compared to classical techniques.
    We’ll expand our understanding of algorithms into something that is a bit more
    of a generalized quantum algorithm, namely, Bernstein-Vazirani, in the next section.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了 Deutsch 和 Deutsch-Jozsa 算法，我们可以看到与经典系统相比，它们确实有一定的加速。然而，我们也可以看到，目前还没有实际或现实世界的例子可以应用这些算法。话虽如此，我们已经了解了如何使用叠加和纠缠来加速某些功能，与经典技术相比。在下一节中，我们将扩展我们对算法的理解，将其扩展到更通用的量子算法，即
    Bernstein-Vazirani 算法。
- en: Learning about the foundational oracle-based quantum algorithm
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解基于 Oracle 的基础量子算法
- en: We learned in the previous section that the very early quantum algorithms illustrated
    quantum speedup vis-à-vis classical systems in relation to a simple problem. In
    this section, we will expand on this to look at a more complex problem. To do
    this, we will learn about another oracle-based algorithm, **Bernstein-Vazirani**.
    The difference between this one and the previous foundational algorithms is that
    the Bernstein-Vazirani algorithm will identify a hidden bit string using an oracle
    function in a single query.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们了解到非常早期的量子算法展示了量子速度相对于经典系统在简单问题上的加速。在本节中，我们将扩展这一点，以查看一个更复杂的问题。为此，我们将学习另一个基于
    Oracle 的算法，即 **Bernstein-Vazirani 算法**。与之前的基算法相比，Bernstein-Vazirani 算法将使用 Oracle
    函数在单次查询中识别隐藏的位串。
- en: Learning about the Bernstein-Vazirani algorithm
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解 Bernstein-Vazirani 算法
- en: Originally invented in 1992 by Ethan Bernstein and Umesh Vazirani, the Bernstein-Vazirani
    algorithm extends the Deutsch-Jozsa algorithm to a generalization to find an unknown
    or secret bit string. Where the Deutsch-Jozsa algorithm worked to solve the problem
    of determining whether a given function is constant or balanced, the Bernstein-Vazirani
    algorithm works to determine a secret number by applying a function that maps
    an input to its output.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 原创于1992年由Ethan Bernstein和Umesh Vazirani发明，Bernstein-Vazirani算法将Deutsch-Jozsa算法扩展到寻找未知或秘密比特字符串的泛化。在Deutsch-Jozsa算法旨在解决确定给定函数是否为常数或平衡的问题时，Bernstein-Vazirani算法通过应用将输入映射到其输出的函数来确定秘密数字。
- en: Understanding the Bernstein-Vazirani problem
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解Bernstein-Vazirani问题
- en: 'The problem that the Bernstein-Vazirani algorithm addresses is straightforward
    and similar to the previous problem. Given an unknown function, or black box (oracle),
    similar to the Deutsch-Jozsa oracle, an input string of bits results in an output
    of either 0 or 1\. A simple example could be a logical expression that maps the
    input values to a single output value of either 0 or 1:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Bernstein-Vazirani算法解决的问题非常直接，与先前的问题类似。给定一个未知函数，或黑盒（预言机），类似于Deutsch-Jozsa预言机，一个比特字符串的输入会产生0或1的输出。一个简单的例子可能是一个逻辑表达式，将输入值映射到单个0或1的输出值：
- en: '![](img/B18420_11_109.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18420_11_109.png)'
- en: 'For this function ![](img/B18420_11_002.png), we are guaranteed that the following
    applies:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个函数![图片](img/B18420_11_002.png)，我们可以保证以下成立：
- en: '![](img/B18420_11_111.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18420_11_111.png)'
- en: 'From the preceding equation, *s* is an unknown or secret string such that:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的方程中，*s*是一个未知或秘密字符串，使得：
- en: '![](img/B18420_11_112.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18420_11_112.png)'
- en: The problem, therefore, is to find the secret value *s*.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，问题是要找到秘密值 *s*。
- en: Solving this classically is the same as the previous examples, where we would
    have to check each value one bit at a time to determine the secret value, *s*.
    However, as we have seen in the previous examples, we can solve this with a quantum
    algorithm executing a single query. Let’s walk through the example to see how
    we can solve this using the Bernstein-Vazirani algorithm.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于前面的例子，用经典方法解决这个问题，我们需要逐位检查每个值以确定秘密值，*s*。然而，正如我们前面所看到的，我们可以使用执行单个查询的量子算法来解决这个问题。让我们通过Bernstein-Vazirani算法的例子来了解如何解决这个问题。
- en: Generating a quantum solution using the Bernstein-Vazirani algorithm
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Bernstein-Vazirani算法生成量子解决方案
- en: 'The Bernstein-Vazirani algorithm is very similar to Deutsch-Jozsa in that it
    performs the same steps to create the quantum circuit for the algorithm:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Bernstein-Vazirani算法与Deutsch-Jozsa算法非常相似，因为它执行相同的步骤来创建算法的量子电路：
- en: Initialize all *n* input qubits to the ground state ![](img/B18420_09_039.png).
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有*n*个输入量子比特初始化为基态![图片](img/B18420_09_039.png)。
- en: Initialize the ancilla qubit to the excited state ![](img/B18420_09_034.png).
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将辅助量子比特初始化为激发态![图片](img/B18420_09_034.png)。
- en: Apply a Hadamard gate to all input qubits and the ancilla qubit, ![](img/B18420_11_115.png).
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对所有输入量子比特和辅助量子比特应用Hadamard门，![图片](img/B18420_11_115.png)。
- en: Query the oracle to apply a phase change based on the secret string value using
    CNOT gates.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用CNOT门根据秘密字符串值查询预言机以应用相变。
- en: Apply another set of Hadamard gates to the input qubits.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对输入量子比特应用另一组Hadamard门。
- en: Measure the input qubits to obtain the secret string.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测量输入量子比特以获得秘密字符串。
- en: As you can see from the preceding steps, the algorithm is very similar. However,
    the main differentiator here is *steps 4* and *5*. When a qubit hits the secret
    key, we then apply a phase shift, that is, when ![](img/B18420_11_116.png), where
    *s*[i] is the *i*th term of the secret string. Then, in *step 5*, when we apply
    the second set of Hadamard gates, the qubit will return from ![](img/B18420_09_035.png)
    to ![](img/B18420_09_034.png) if ![](img/B18420_11_116.png), or from ![](img/B18420_11_120.png)
    to ![](img/B18420_09_039.png) if ![](img/B18420_11_122.png).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，算法非常相似。然而，这里的主要区别在于*步骤4*和*步骤5*。当一个量子比特遇到秘密密钥时，我们就会应用相移，即当![图片](img/B18420_11_116.png)，其中*s*[i]是秘密字符串的第*i*个项。然后，在*步骤5*中，当我们应用第二组Hadamard门时，如果![图片](img/B18420_11_116.png)，量子比特将从![图片](img/B18420_09_035.png)返回到![图片](img/B18420_09_034.png)，或者如果![图片](img/B18420_11_122.png)，则从![图片](img/B18420_11_120.png)返回到![图片](img/B18420_09_039.png)。
- en: Let’s implement these steps one at a time and review the changes to the state.
    As before, we will use barriers to separate each step so that we can visualize
    each step along the way.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地实现这些步骤并回顾状态的变化。像以前一样，我们将使用屏障来分隔每个步骤，这样我们就可以在过程中可视化每个步骤。
- en: Implementing the Bernstein-Vazirani algorithm
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现Bernstein-Vazirani算法
- en: 'The following steps are a step-by-step guide to creating the **Bernstein-Vazirani**
    algorithm and describe the outcome of each step to help you understand how each
    step affects the state, which will eventually produce the secret string:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤是创建**Bernstein-Vazirani**算法的逐步指南，并描述每个步骤的结果，以帮助您了解每个步骤如何影响状态，最终产生秘密字符串：
- en: Start by creating a new Qiskit notebook with the usual boilerplate cell that
    will load much of the base Qiskit modules and our account, so that we can execute
    the quantum circuit on an actual quantum computer.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个新的Qiskit笔记本，包含通常的样板单元格，该单元格将加载许多基础Qiskit模块和我们的账户，这样我们就可以在实际量子计算机上执行量子电路。
- en: 'First, we will create our quantum circuit, which will be made up of four qubits,
    and one ancilla qubit, and we will define our **secret bit string** (`shh`):'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建我们的量子电路，它将由四个量子比特和一个辅助量子比特组成，我们将定义我们的**秘密比特字符串**（`shh`）：
- en: '[PRE15]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code creates our base quantum circuit, `qc`, which we will use
    to construct the Bernstein-Vazirani algorithm. The input qubits must be at least
    the length of our secret string, which, in this case, is the value `1010`. Our
    input register will need to be at least this many qubits in length. We then added
    an ancilla qubit, which, in the previous examples, we referred to as the output
    qubit. Moving forward, we will start referring to this qubit as an ancilla qubit
    in that it is more of a utility qubit that will not be measured or output to our
    results.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建我们的基础量子电路`qc`，我们将用它来构建Bernstein-Vazirani算法。输入量子比特的长度必须至少与我们的秘密字符串长度相同，在这个例子中是值`1010`。我们的输入寄存器长度至少需要这么多量子比特。然后我们添加了一个辅助量子比特，在之前的例子中我们称之为输出量子比特。从现在开始，我们将开始将这个量子比特称为辅助量子比特，因为它更像是工具量子比特，它不会被测量或输出到我们的结果中。
- en: 'Next, we will add Hadamard gates to the input qubits to ensure that all input
    qubits are set to a superposition state:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将向输入量子比特添加Hadamard门，以确保所有输入量子比特都设置为叠加态：
- en: '[PRE16]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This will render our quantum circuit as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这将渲染我们的量子电路如下：
- en: '![Figure 13.23 – Initializing the input qubits state from |0 to a superposition
    state, |+ ](img/B18420_11_17.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![图13.23 – 将输入量子比特的状态从|0初始化为叠加态|+](img/B18420_11_17.png)'
- en: 'Figure 11.17: Initializing the input qubits’ state from ![](img/B18420_06_015.png)
    to a superposition state, ![](img/B18420_11_124.png)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.17：将输入量子比特的状态从![img/B18420_06_015.png]初始化为叠加态![img/B18420_11_124.png]
- en: 'Next, we will need to prepare our ancilla qubit, **q**[4], just as we did before,
    by first initializing it to the state ![](img/B18420_06_018.png), followed by
    a Hadamard gate, which will prepare the state of the ancilla qubit to ![](img/B18420_11_056.png):'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要准备我们的辅助量子比特**q**[4]，就像我们之前做的那样，首先将其初始化为![img/B18420_06_018.png]状态，然后是一个Hadamard门，这将准备辅助量子比特的状态为![img/B18420_11_056.png]：
- en: '[PRE17]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding code will render the following circuit, which we see is the same
    initialization of our circuit as before. This is how most quantum algorithms are
    initialized, which allows working with all possible combinations of qubit states.
    The barrier is added simply to view the various state changes:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将渲染以下电路，我们看到这与我们之前的电路初始化相同。这是大多数量子算法初始化的方式，允许处理所有可能的量子比特状态组合。屏障的添加只是为了观察各种状态变化：
- en: '![Figure 13.24 – Initialization of all qubits ](img/B18420_11_18.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图13.24 – 所有量子比特的初始化](img/B18420_11_18.png)'
- en: 'Figure 11.18: Initialization of all qubits'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.18：所有量子比特的初始化
- en: 'The state at the first barrier is now set to the following, where the input
    qubits are as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个屏障处的状态现在设置为以下内容，其中输入量子比特如下：
- en: '![](img/B18420_11_127.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![img/B18420_11_127.png]'
- en: 'The ancilla qubit is set to:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助量子比特被设置为：
- en: '![](img/B18420_11_128.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![img/B18420_11_128.png]'
- en: 'Next, we need to make a quick bit order adjustment before we apply our oracle
    function. Since the qubits are ordered from right to left, we will need to reverse
    the order of our secret number:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在我们应用预言函数之前，我们需要进行快速位顺序调整。由于量子比特是从右到左排序的，因此我们需要反转我们的秘密数字的顺序：
- en: '[PRE18]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As you can see from the following output, the order is now `0101`, so we can
    now apply our oracle function:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从以下输出中可以看到，现在的顺序是`0101`，因此我们现在可以应用我们的预言函数：
- en: '[PRE19]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To apply the oracle function, we want to trigger a phase shift each time we
    hit a `''1''` in the secret string. To do that, we will apply a CNOT gate to each
    qubit, where the Control is set to each qubit and the Target is linked to the
    ancilla. In our case, the secret string has `''1''` set on **qubit 1** (q[1])
    and **qubit 3** (q[3]):'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了应用量子计算器函数，我们希望在秘密字符串中每次遇到'1'时触发相移。为此，我们将对每个量子比特应用一个CNOT门，其中控制位设置为每个量子比特，目标位连接到辅助位。在我们的情况下，秘密字符串在**量子比特1**（q[1]）和**量子比特3**（q[3]）上设置了'1'：
- en: '[PRE20]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding code renders the quantum circuit up to the oracle:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码生成了直到量子计算器的量子电路：
- en: '![Figure 13.25 – Oracle applying CNOT where the secret string is set to ''1''
    ](img/B18420_11_19.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![图13.25 – 量子计算器应用CNOT，其中秘密字符串设置为''1''](img/B18420_11_19.png)'
- en: 'Figure 11.19: Oracle applying CNOT where the secret string is set to ‘1’'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.19：量子计算器应用CNOT，其中秘密字符串设置为‘1’
- en: 'Since all our qubits are in a superposition state, by applying the phase shift
    based on the secret string |S⟩, we get the following equation:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有我们的量子比特都处于叠加态，通过根据秘密字符串|S⟩应用相移，我们得到以下方程：
- en: '![](img/B18420_11_129.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![img/B18420_11_129.png]'
- en: Therefore, from the preceding equation, our secret string ![](img/B18420_11_130.png)
    will apply a phase shift to each qubit where the string is set. This will shift
    the ![](img/B18420_11_124.png) to ![](img/B18420_11_056.png) whenever the input
    bit x and the secret string s are equal to 1.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根据前面的方程，我们的秘密字符串![img/B18420_11_130.png]将对设置为字符串的每个量子比特应用相移。这将使![img/B18420_11_124.png]在输入比特x和秘密字符串s等于1时转换为![img/B18420_11_056.png]。
- en: Finally, in our last step before applying measurements to the input qubits,
    we apply another set of Hadamard gates. What this set of Hadamard gates achieves
    is that it will return the state of each qubit back to either the ![](img/B18420_06_015.png)
    or ![](img/B18420_06_018.png) state.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在我们对输入量子比特应用测量之前，我们应用另一组Hadamard门。这组Hadamard门达到的效果是，它将每个量子比特的状态返回到![img/B18420_06_015.png]或![img/B18420_06_018.png]状态。
- en: 'This is entirely dependent on whether the qubit experienced a phase shift while
    passing through the oracle. If it did not, then the state would change from ![](img/B18420_11_124.png)
    to ![](img/B18420_06_015.png), or from ![](img/B18420_11_056.png) to ![](img/B18420_06_018.png):'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全取决于量子比特在通过量子计算器时是否经历了相移。如果没有，那么状态将从![img/B18420_11_124.png]变为![img/B18420_06_015.png]，或者从![img/B18420_11_056.png]变为![img/B18420_06_018.png]：
- en: '[PRE21]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This will render the following circuit diagram, which completes the steps to
    implement the Bernstein-Vazirani algorithm along with the measurement operators:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下电路图，它完成了实现Bernstein-Vazirani算法以及测量算子的步骤：
- en: '![Figure 13.26 – Final circuit that implements the Bernstein-Vazirani algorithm
    ](img/B18420_11_20.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图13.26 – 实现Bernstein-Vazirani算法的最终电路](img/B18420_11_20.png)'
- en: 'Figure 11.20: Final circuit that implements the Bernstein-Vazirani algorithm'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.20：实现Bernstein-Vazirani算法的最终电路
- en: 'Now that the circuit is complete and ready to go, we can execute the circuit
    on your local simulator and then on a real quantum device:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在电路已经完成并准备就绪，我们可以在本地模拟器上执行电路，然后在实际量子设备上执行：
- en: '[PRE22]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The results should have a 100% probability for the value of our secret string,
    as illustrated in the following histogram:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该有100%的概率对应于我们秘密字符串的值，如下面的直方图所示：
- en: '![A blue rectangular graph with white text  Description automatically generated](img/B18420_11_21.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![一个蓝色矩形图，带有白色文字  自动生成的描述](img/B18420_11_21.png)'
- en: 'Figure 11.21: Result identifies with 100% probability the value of our secret
    string'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.21：结果以100%的概率识别出我们的秘密字符串的值
- en: As you can see from the preceding result, like the earlier quantum algorithms,
    we can solve certain problems in a single query, whereas it would take classical
    systems a few queries to solve. These problems leveraged **phase kickback**, where
    we used the phase to solve the question of whether the function was balanced or
    constant.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的结果所示，像早期的量子算法一样，我们可以通过单次查询解决某些问题，而经典系统需要多次查询才能解决。这些问题利用了**相回弹**，我们使用相移来解决函数是否平衡或常数的问题。
- en: Looking back at the step where we applied the last layer of Hadamard gates,
    it appears as if the control qubit got flipped instead of the other qubit.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们应用最后层Hadamard门的那一步，看起来控制量子比特被翻转了，而不是其他量子比特。
- en: In this section, we learned about the foundational oracle-based algorithms and
    how they illustrate quantum advantage over classical systems to solve problems.
    We also learned about how oracles and ancilla qubits are leveraged to obtain some
    of the solutions, which will, in turn, help you understand the more complex algorithms
    as you expand your knowledge and research. Although these were simple problems
    that have no commercial value by themselves, they did, however, manage to trigger
    an interest in the quantum information science field that is still growing to
    this day.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了基于预言机的基础算法以及它们如何展示量子系统相对于经典系统在解决问题上的优势。我们还学习了如何利用预言机和辅助量子比特来获得一些解决方案，这反过来又可以帮助你在扩展知识和研究时理解更复杂的算法。尽管这些是简单的没有商业价值的问题，但它们确实成功地激发了对量子信息科学领域的兴趣，而这个领域至今仍在不断发展。
- en: Summary
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered some of the many quantum algorithms that employ
    common techniques that are used in a variety of other quantum algorithms.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了一些使用在许多其他量子算法中常见的技术的量子算法。
- en: The goal of this chapter was to explore each of them systematically so you could
    have a good understanding of the problem each algorithm solves. The topics here
    are, of course, foundational and oracle-based, although the techniques are commonly
    found in many other quantum algorithms.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是系统地探索每一个，以便你能对每个算法解决的问题有一个良好的理解。这里讨论的主题当然是基础的和基于预言机的，尽管这些技术也常见于许多其他量子算法中。
- en: In the next chapter, we will step away from the oracle-based foundational algorithms
    and look at another form of algorithm that solves similar problems. However, rather
    than using phases to identify the solution, they will instead leverage periodicity,
    which is primarily why they are called **periodic algorithms**.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从基于预言机的基础算法转向另一种解决类似问题的算法形式。然而，它们将不会使用相位来识别解决方案，而是利用周期性，这也是它们被称为**周期算法**的主要原因。
- en: Questions
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which algorithm would you use to determine whether an *n*-bit string is balanced?
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会用哪个算法来确定一个 *n*-位字符串是否平衡？
- en: Implement the Bernstein-Vazirani algorithm to find the state `170`.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现伯恩斯坦-瓦齐拉尼算法以找到状态 `170`。
- en: How many oracle functions are there?
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有多少个预言机函数？
- en: Join us on Discord
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/3FyN1](Chapter_11.xhtml)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/3FyN1](Chapter_11.xhtml)'
- en: '![](img/QR_Code2617625996838265933.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code2617625996838265933.png)'
