- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding Quantum Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’ve been reading the news about quantum computing, you will have noticed
    many articles from various companies, both large and small, all working on different
    projects related to quantum computing. The reason is largely based on the potential
    computing power that quantum systems offer when compared to classical systems.
    The potential to provide speedup, quality, and scalability are the main areas
    of interest that most companies and research institutions are looking heavily
    into now.
  prefs: []
  type: TYPE_NORMAL
- en: By grasping the intricacies of the various quantum algorithms and learning how
    to apply them to a specific problem set or industry, researchers and developers
    can then look at extending what they learned about the small problems and apply
    them to large real-world enterprise solutions. This era of solving real-world
    problems using quantum computers that are intractable to classic computers is
    referred to as **quantum advantage**. Currently, most of the work being done centers
    on understanding and creating quantum computation algorithms, which are usually
    focused on smaller **toy problems**, as they are commonly referred to.
  prefs: []
  type: TYPE_NORMAL
- en: However, in 2021, IBM Quantum introduced a 127-qubit processor that broke the
    100-qubit barrier. This signifies a great move forward as it represents a barrier
    in which classical simulations may no longer mimic a quantum computer of equal
    size. Early evidence of this was found in 2023 when a 127-qubit Eagle processor
    was able to perform exact solutions to computational problems beyond classical
    brute force. Details about this can be found in the Nature article *Evidence for
    the utility of quantum computing before fault tolerance* ([https://www.nature.com/articles/s41586-023-06096-3](https://www.nature.com/articles/s41586-023-06096-3)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: This brings us a step closer to the quantum advantage phase that everyone is
    racing to achieve. Of course, this will vary as some problems might require more
    quantum computational power than others, but, over time, different industries
    will eventually achieve it soon enough. To get yourselves suited up and in the
    race, you’ll need to understand some of the foundational quantum algorithms and
    how they are applied to solve general problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the meaning of outperforming classical systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about the Deutsch algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Deutsch-Jozsa algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about the foundational oracle-based quantum algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will review the various quantum algorithms in use today.
    One of the most difficult hurdles to overcome while learning about quantum algorithms
    is that it is not a lift and shift from classical to quantum. Simply implementing
    a classical algorithm’s steps from a classic system onto a quantum system, such
    as a simple adder, will not automatically make it a quantum speedup algorithm.
    There’s a bit more to it than that.
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 5*, *Understanding the Qubit*, we discussed how quantum states are
    manipulated, and in *Chapter 7*, *Programming with Qiskit*, we covered how to
    run a circuit on a quantum system. We will now put all those pieces together to
    learn about and create quantum algorithms and illustrate how they can outperform
    classical algorithms in this chapter. We will begin by providing an example of
    a quantum algorithm that is foundational and illustrate how quantum systems perform
    operations much faster by reviewing both the **Deutsch** and **Deutsch-Jozsa**
    algorithms. We’ll follow that up with more generalized algorithms that focus on
    solving simple problems with the **Bernstein**-**Vazirani** algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: This is by no means an exhaustive list of quantum algorithms, but this chapter
    will provide you with the early foundational algorithms that will help you understand
    the advanced algorithms and how they compare to classical algorithms. Should you
    want to see a more complete algorithm list, refer to *Appendix A,* *Resources*,
    for some links to sites that keep track of quantum algorithms and research. Of
    course, as the technology and algorithms advance, new algorithms will be discovered
    that may have different methods than the following, but in all of these, it is
    ideal to understand the basics to get you up and running without having to delve
    too deep into the physics.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, it is expected that you have a basic understanding of linear
    algebra to understand the equations of each algorithm. You should also have some
    experience in programming basic circuits and executing them on your local simulator
    and a quantum device available on the **IBM Quantum** platform. Finally, you should
    be familiar with both classical bit notation and logic, quantum **Dirac notation**
    (or Bra-Ket notation), and understand the basic quantum computing principles such
    as superposition, entanglement, and interference that were covered in the previous
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the full source code used throughout this book: [https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition](https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the meaning of outperforming classical systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn about the potential advantages that a quantum
    system has over classical systems by studying some of the early examples that
    illustrate quantum speedup versus classical systems, albeit some of the examples
    are simple illustrations of the advantages that, in themselves, do not have any
    practical usage.
  prefs: []
  type: TYPE_NORMAL
- en: Claims such as quantum systems potentially solving equations at rapid speeds
    over classical systems or having the capability of a larger computation space
    all sound fascinating. However, recall that, at the time of writing this chapter,
    there are still no quantum systems available that can outperform current classical
    systems in solving real-world commercial problems. “*So why all the chatter?*”
    you ask.
  prefs: []
  type: TYPE_NORMAL
- en: The answer is simple—potential. Theoretically speaking, there are quantum algorithms
    that describe solutions to problems that illustrate quantum speedup, such as Shor’s
    algorithm. However, it is expected that we will see quantum advantage before we
    will see quantum breaks in encryption. This is because reaching quantum advantage
    is based on a specific problem. It will not be specific data for all; it will
    evolve as the technology is able to compute very large and complex circuits. To
    implement complex circuits or algorithms, we will require systems that contain
    error mitigation, suppression, and, eventually, correction in order to obtain
    accurate results. This, of course, could be similar to most new technologies.
    A good example of this is **video streaming**.
  prefs: []
  type: TYPE_NORMAL
- en: Multimedia compression has been around for decades, with video streaming invented
    in the early 1990s. When video compression was first made commercially available,
    internet bandwidth had increased and was more widely available, albeit the quality
    of the video and the audio was not as rich as it is today; the resolution was
    around 150 x 76 pixels, with a refresh rate of around 8–12 frames per second with
    poor audio quality. The limitation back then was both the compression technique
    to decrease the quality of the multimedia and the bandwidth to stream the multimedia
    content to multiple viewers simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: 'The infrastructure to ensure proper decompression and minimize information
    loss was dependent on error correction, and a proper protocol to avoid low-quality
    and often jittery resolution. Now, of course, just a little over two decades later,
    we can see the progress: we can stream live multimedia events with low errors
    and high resolution. Streaming to your home theater system with a large 4K high-definition
    screen where you don’t have to worry too much about the quality of the video is
    something of a norm nowadays.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Quantum systems share this same *roadmap*, where we have the hardware (quantum
    systems) and the algorithms to do things at a *medium resolution* now. The difference
    here is that we have something we did not have back then: a global infrastructure
    in which anyone, anywhere, has access to a quantum system via the cloud. IBM quantum
    computers are available for anyone to access by simply registering for a free
    account.'
  prefs: []
  type: TYPE_NORMAL
- en: In the early days of video streaming, very few had access to bandwidth. Those
    who did were limited by the infrastructure to collaborate. By having cloud-accessible
    systems, many industries and academic institutions are doing more research on
    quantum hardware and algorithms. Of course, back in the early days of multimedia
    streaming, the solutions being solved were classified as toy problems. However,
    don’t let the name fool you. These toy problems are far from just something to
    play with and show off to your colleagues. They are the stepping stones to real-world
    solutions.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you find a solution that illustrates quantum speedup vis-à-vis
    classical, with just a handful of qubits and very little quantum volume, then
    that might not be useful for solving many of today’s commercial or real-world
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: What it does provide is the foundational information needed to scale your solution
    to a system with the necessary quantum volume to solve a real-world problem. To
    understand what that roadmap to quantum advantage is, where a quantum solution
    exists that can outperform a classical system in solving a real-world problem,
    it’s important to first understand the foundational quantum algorithms and how
    they not only differ from classical algorithms but also provide an advantage over
    them. This will simplify your understanding of other, more complex algorithms
    and how they are used to solve problems in various industries.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss the various types of foundational quantum
    algorithms, starting with the original algorithms that demonstrate an advantage
    over classical systems.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about Deutsch’s algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: David Deutsch, a physicist at the **University of Oxford**, first discovered
    a problem that could be solved by a quantum computer faster than a classical computer.
    The problem itself has no importance or use in any computer problems, but it did
    serve to illustrate the advantage that quantum computation has over classical
    computation. Let’s understand that problem in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The problem is very simple. We’ll use a simple analogy to explain it. Imagine
    someone is hiding a coin in each hand. Each coin, when revealed, will either be
    heads or tails. Since there are two coins, one in each hand, there are four possible
    results, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Events** | **Left hand** | **Right hand** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Heads | Heads |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Heads | Tails |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Tails | Heads |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Tails | Tails |'
  prefs: []
  type: TYPE_TB
- en: 'Table 11.1: All four possible outcomes'
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding list of events, we can see there are two categories. The
    first and fourth events are an example of a constant outcome, where both the left
    and right produce the same result of either heads or tails. The second and third
    events are examples of balanced outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: Here, the event results are the opposite of one another, indicating that if
    one is heads, then the other will be tails, or vice versa. Using this same analogy,
    if I were to reveal one hand at a time, let’s say the left hand, then by just
    viewing the results of the left hand, you would not have enough information to
    determine whether the result will be constant or balanced because you still need
    to know what is in the other hand.
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine there were 100 hands in front of you and you had to examine each
    hand one at a time in order to determine if there are a balanced number of heads
    and tails, or if all of the hands contain only heads or only tails. In the best-case
    scenario, you would get it on the first two tries, meaning if the first hand had
    heads and the second had tails, you can conclude that the results of the other
    hands will be balanced. On the other hand (pun intended), if the first two hands
    revealed the same, either heads or tails, then you cannot conclude that it is
    balanced or constant.
  prefs: []
  type: TYPE_NORMAL
- en: You would have to, in a worst-case scenario, continue until the 51^(st) hand
    is revealed, because if the first 50 hands are heads, then the 51^(st) would indicate
    whether the whole set is constant (if the 51^(st) is heads) or balanced (if the
    51^(st) is tails). However, we are jumping ahead a little bit, so let’s stick
    to the current scope of the problem of just two events.
  prefs: []
  type: TYPE_NORMAL
- en: Using a quantum algorithm, which is what Deutsch proposed here, to solve this
    problem is the same as opening all the hands at once and determining whether the
    first two qubits are constant or balanced. *Interesting, isn’t it?* Let’s see
    how this works!
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll begin by migrating the analogy of the problem to a mathematical equation.
    This will simplify the description of the solution later:'
  prefs: []
  type: TYPE_NORMAL
- en: First, substitute heads and tails with binary notations of 0 and 1, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we’ll refer to the result of each hand as a function ![](img/B18420_11_002.png),
    where the argument can refer to left or right, ![](img/B18420_11_003.png) or ![](img/B18420_11_004.png),
    respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Therefore, the results are as follows. In this case, the function ![](img/B18420_11_002.png)
    is ![](img/B18420_11_006.png), where the argument *x* can be either a 0 or 1 (left
    or right). The results represent each of the events that have a different result,
    where each one is either balanced or constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Events** | ![](img/B18420_11_007.png) | ![](img/B18420_11_008.png) | **Results**
    |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 0 | Constant |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 0 | 1 | Balanced |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 1 | 0 | Balanced |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 1 | 1 | Constant |'
  prefs: []
  type: TYPE_TB
- en: 'Table 11.2: Mathematical representation of outcomes'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the preceding table, now we can restate our problem as a
    function ![](img/B18420_11_002.png) that maps a single bit {0,1} to a result of
    either {0,1}, the results of which would be constant if the results for both ![](img/B18420_11_003.png)
    and ![](img/B18420_11_004.png) are the same, such as *Event 1* and *Event 4* (from
    the preceding table), or the results would be balanced otherwise. Now that we
    understand the problem, let’s figure out the solution.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We now know that if ![](img/B18420_11_003.png) = ![](img/B18420_11_004.png),
    then we say ![](img/B18420_11_002.png) is *constant*; otherwise, ![](img/B18420_11_002.png)
    is *balanced*. The problem becomes interesting if we were to introduce a **black
    box**, sometimes referred to as an oracle, that is hidden from us. We don’t know
    whether the function, hidden in the black box, is either constant or balanced,
    which is the problem we are asked to solve. The following diagram is a graphical
    example of our input value, *x*, going into the black box function, ![](img/B18420_11_002.png),
    and outputting the result value, ![](img/B18420_11_006.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5 – Black box representation of our problem ](img/B18420_11_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.1: Black box representation of our problem'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding diagram, this problem can be solved classically.
    However, it will need to have two queries to determine whether ![](img/B18420_11_002.png)
    is constant or balanced, where each query would view the results of both ![](img/B18420_11_003.png)
    and ![](img/B18420_11_004.png) to conclude whether it is constant or balanced.
    When using Deutsch’s quantum algorithm, we will see whether we can determine ![](img/B18420_11_002.png)
    using just one query that leverages the superposition principle. Let’s see how
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Describing the problem as a quantum problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since we are working with quantum computations, we’ll have to first switch
    to representing our functions and values using vectors. Therefore, our constant
    function, where both inputs result in the same output, can be represented in vector
    form as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_11_022.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The results of this function with a different input having the same result
    can be represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_11_023.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The function ![](img/B18420_11_002.png) can therefore be represented by the
    following matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_11_025.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Equally, the following is an example of a balanced function, where the results
    are the opposites of the two input values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_11_026.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/B18420_11_027.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/B18420_11_028.png) will be our black box, or oracle function. To do
    this, we will need to extend our previous diagram to include the extra components
    necessary to create our oracle:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we will convert our input and output registers into Dirac **ket notation**,
    ![](img/B18420_11_029.png).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we will create two input registers, ![](img/B18420_11_029.png) and ![](img/B18420_11_031.png),
    where the input registers will feed into our black box, or oracle function, ![](img/B18420_11_028.png),
    and the ![](img/B18420_11_031.png) register is used as an ancillary qubit. Ancilla
    qubits are extra bits used to store information that might be used later or to
    track information throughout the quantum circuit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we’ll define our two output registers: one that is just the same as
    the input ![](img/B18420_11_029.png), and the other that is the **XOR** of the
    input register *x* and the input register x *XORed* with the function ![](img/B18420_11_006.png),
    as ![](img/B18420_11_036.png).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Therefore, we can now define the oracle function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_11_037.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is illustrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6 – Graphical representation of the Deutsch algorithm ](img/B18420_11_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2: Graphical representation of the Deutsch algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another requirement is that the function should be reversible and we can test
    to see if it is by working it out in reverse:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_11_038.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have our function defined as a quantum function for our problem,
    we’ll see how Deutsch’s algorithm works.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Deutsch’s algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we will implement the algorithm with a balanced function as
    an example but will leave it to you to update the code to implement a constant
    function. We’ll examine the Deutsch algorithm and step through each task as we
    build the algorithm on the IQL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new Jupyter notebook where you have Qiskit installed, and in the first
    cell, include the helper file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will create a 2-qubit circuit and prepare each input, the first to
    ![](img/B18420_06_015.png) and the second to ![](img/B18420_06_018.png). We will
    use the identity gate to represent the ![](img/B18420_06_015.png), which is the
    initial state, and an X-gate to represent the initial state of ![](img/B18420_06_018.png):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This results in the following circuit diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.7 – Initializing the qubits to 0 and 1 ](img/B18420_11_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.3: Initializing the qubits to 0 and 1'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the preceding diagram, **q**[0] is set to ![](img/B18420_06_015.png)
    and **q**[1] is set to ![](img/B18420_06_018.png), which creates the first state
    at the barrier (![](img/B18420_11_045.png)) as ![](img/B18420_11_046.png). The
    use of the barrier is just to indicate checkpoints as we traverse through each
    operation in the circuit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our inputs are set, we will place them in a superposition state using
    Hadamard gates. This will allow us to iterate through once while leveraging all
    four states, rather than iterating through each of them one at a time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result of the preceding code is illustrated in the following diagram. The
    barriers are used to separate each step so as to simplify reading the circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.8 – Applying Hadamard to both qubits ](img/B18420_11_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.4: Applying Hadamard gates to both qubits'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the preceding diagram, the Hadamard gate transforms the
    basis vectors for each qubit as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_11_047.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This generates the following state at the second barrier as ![](img/B18420_11_048.png),
    where ![](img/B18420_11_049.png) describes a single qubit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_11_050.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After the qubits have applied the preceding Hadamard gates, the resulting value
    for the quantum registers will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18420_11_051.png)'
  prefs: []
  type: TYPE_IMG
- en: 'One thing to note here is that we now have the second qubit in a ![](img/B18420_11_052.png)
    superposition, ![](img/B18420_11_053.png). This allows us to define the first
    and second qubit out of ![](img/B18420_11_028.png), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_11_055.png)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding equation, you can see that the second qubit, grouped in the
    second set of parentheses, has the same value, which is the ![](img/B18420_11_056.png)
    superposition, ![](img/B18420_11_049.png).
  prefs: []
  type: TYPE_NORMAL
- en: However, the first qubit we see has an interesting result. Let’s dig a little
    deeper to understand what this means.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we see that if ![](img/B18420_11_002.png) is constant, we’ll have the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_11_059.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If ![](img/B18420_11_002.png) is balanced, then we’ll have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_11_061.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that the second qubit is always the same, but the first has a phase kickback
    from positive if constant, and negative if balanced. This phase kickback is a
    common trick used in many quantum algorithms, so rest assured we will see this
    again.
  prefs: []
  type: TYPE_NORMAL
- en: Next, by applying a Hadamard gate to the first qubit, we can see something interesting
    as a result. Let’s look at this one at a time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For a constant function, the first qubit is set to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_11_062.png)'
  prefs: []
  type: TYPE_IMG
- en: We recall that applying a Hadamard gate to this superposition state will return
    us to the ![](img/B18420_06_015.png) state.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the balanced function, the first qubit is set to the following superposition
    state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_11_064.png)'
  prefs: []
  type: TYPE_IMG
- en: We can also recall that applying a Hadamard gate to the previous superposition
    state will return us to the ![](img/B18420_06_018.png) state.
  prefs: []
  type: TYPE_NORMAL
- en: This means that measuring only the first qubit after applying a Hadamard gate
    to it will provide us with a resulting state of either ![](img/B18420_06_015.png)
    or ![](img/B18420_06_018.png), constant or balanced, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement this using our Qiskit notebook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is where we wish to set a quantum gate that would operate on q[1], which
    represents the *y* value, based on the value of q[0], which represents the *x*
    value. Therefore, this operator, which we’ll call ![](img/B18420_11_028.png),
    will have inputs (*x*, *y*). The gate we will use to represent this will be a
    **Control-Not** (**CNOT**) gate. The reason for using this for the balanced function
    is because it produces the Bell states 01 and 10 with the input qubits. And, of
    course, this could be switched to the other two Bell states, 00 and 11, by adding
    an X gate, which would make this a constant function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we are working to create a balanced function, one to one, which
    equates to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_11_069.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To accomplish this, we will need to define our state operator, ![](img/B18420_11_028.png),
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_11_071.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we will place a CNOT gate with the control on the first qubit, **q**[0],
    and the target on the second qubit, **q**[1]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This should now include the CNOT gate that generates the function type (balanced)
    and renders the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.9 – Defining the function type (balanced) ](img/B18420_11_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.5: Defining the function type (balanced)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll add Hadamard gates to all qubits and a measurement operator to
    the first qubit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As we saw in our equation earlier, we only need to apply a Hadamard gate to
    the first qubit, as we will only be measuring the one qubit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.10 – Applying the Hadamard gate to the qubits before measuring
    ](img/B18420_11_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.6: Applying the Hadamard gate to the qubits before measuring'
  prefs: []
  type: TYPE_NORMAL
- en: 'This results in the following state, ![](img/B18420_11_072.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_11_073.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/B18420_11_074.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/B18420_11_075.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/B18420_11_076.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s now apply some algebra to simplify our results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_11_077.png)'
  prefs: []
  type: TYPE_IMG
- en: Since we will only be measuring the first qubit, we can throw the second qubit
    away or just not measure it as it is just an ancillary qubit in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a measurement of the first qubit, shown as follows, the result of
    which will determine the category of the function as either balanced (`1`) or
    constant (`0`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We already know from the previous equation that this should equate to a balanced
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.11 – Applying the measurement operator to just the first qubit
    ](img/B18420_11_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.7: Applying the measurement operator to just the first qubit'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, to simplify a few things, let’s define a function to run our circuits
    on a Sampler installed on your local machine. We’ll use the following function,
    which leverages the `StatevectorSampler`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can run the preceding circuit and verify our results by using the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As calculated previously, the results of this experiment indicate a balanced
    function, as indicated by the result `1`, rather than `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A blue rectangular graph with white text  Description automatically generated](img/B18420_11_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.8: Result of value 1, indicating a balanced function'
  prefs: []
  type: TYPE_NORMAL
- en: As expected, we see that our result is **1**, indicating a balanced function.
  prefs: []
  type: TYPE_NORMAL
- en: Observe that to retrieve the counts from the results, we need to map to the
    data object and then to the name of the classical register that we wish to extract
    the counts from.
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding output, the result shows the same as what we expected for
    the given function we provided, which, in this case, is the balanced function,
    where 1 has a higher probability. There is an exercise in the *Questions* section
    where you are required to create a constant function.
  prefs: []
  type: TYPE_NORMAL
- en: What we have shown here is the potential of a quantum algorithm to perform operations
    faster than a classical system, which would otherwise need to calculate each function
    in series for each input. Naturally, this exercise does not offer any real-world
    applications, but it does help in understanding how these systems have potential
    speedup properties. In the next section, we will look at generalizing this example
    by applying it to more than one qubit.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Deutsch-Jozsa algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, the Deutsch algorithm provided us with an example of
    quantum speedup where we use two qubits but only measure one qubit. Here, the
    **Deutsch-Jozsa** algorithm provides a more generalized form of the algorithm.
    It can be applied to more than one qubit. Originally proposed by David Deutsch
    and Richard Jozsa in 1992, with improvements by Richard Cleve, Artur Ekert, Chiara
    Macchiavello, and Michele Mosca in 1998, the problem is still the same, but as
    we mentioned at the end of the previous section, the problem is now extended to
    more than just a single qubit. The Deutsch-Jozsa algorithm will operate on multiple
    qubits at once, and, of course, will still provide a quantum speedup compared
    with classical computing as it would need to calculate each event in series, as
    we will see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Deutsch-Jozsa problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this example, we will extend the previous definition of the problem. Previously,
    we defined our problem on a single-bit value function to determine whether a function
    was constant or balanced, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_11_078.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this case, we will expand the problem to include more than one bit as an
    input, such that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_11_079.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see from the preceding equation that ![](img/B18420_11_002.png) is *constant*
    if ![](img/B18420_11_006.png)is the same for all, that is, ![](img/B18420_11_082.png).
    Otherwise, ![](img/B18420_11_002.png) is *balanced* if ![](img/B18420_11_084.png)
    for half of x, and ![](img/B18420_11_085.png) for the other half of x. For example,
    if we set *n* equal to 2 in our input values, ![](img/B18420_11_086.png), then
    this will result in four different input values, that is, 00, 01, 10, and 11.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on these four possible input values of x, to create a balanced function,
    we can set the first half of the results to 0, such that:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Input 1** | **Input 2** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: 'We can set the second half of the results to 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Input 1** | **Input 2** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: If we were to solve this classically, we would need ![](img/B18420_11_087.png)
    queries to determine whether the results are constant or balanced. On the other
    hand, the Deutsch-Jozsa algorithm will only require one query in order to determine
    whether the function is constant or balanced, just as in the Deutsch algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a quantum solution using the Deutsch-Jozsa algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To generate our quantum circuit to implement the Deutsch-Jozsa algorithm, we
    will use some of the same components as before:'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with our inputs to our black box (oracle). The first input register
    is an *n*-bit string representing the input X. We denote this with a capital X,
    as most texts refer to single qubit or bit values with a lowercase variable such
    as ![](img/B18420_11_029.png), whereas multi-qubits are represented by uppercase
    variables such as ![](img/B18420_11_089.png).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second input register is a single-bit string representing the input y, which,
    as before, is initialized to 1\. This is commonly referred to as an **ancilla
    qubit**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define the function of the oracle similar to how we did in the previous
    form. However, the difference here is that ![](img/B18420_11_029.png) is now a
    multi-qubit input, ![](img/B18420_11_089.png). ![](img/B18420_11_028.png) is then
    defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18420_11_093.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So, our output would similarly map to two outputs. The first is the same as
    the first input ![](img/B18420_11_089.png), and the second output is our function
    ![](img/B18420_11_095.png). This results in the following graphical representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.14 – Graphical representation of the Deutsch-Jozsa algorithm ](img/B18420_11_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.9: Graphical representation of the Deutsch-Jozsa algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have defined our components, let’s implement this block digram as
    a circuit in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Deutsch-Jozsa algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this example we will implement the Deutsch-Jozsa algorithm to determine that
    a given function is constant in one query, whereas determining the same on a classical
    system will require multiple queries, therefore illustrating how using quantum
    computing can provide a speedup.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to implement the Deutsch-Jozsa algorithm, create a new Qiskit notebook
    and run the boilerplate cell to load up all our Qiskit modules. Once the setup
    is complete, let’s create our circuit step by step and see how it resolves our
    problem as we go:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s set our input values. We will start by creating a quantum circuit
    with two inputs, the first set to `X`, which we will create as a 4-qubit input,
    followed by a single qubit representing `y`, which we will initialize to `1`.
    Then we will apply a Hadamard gate to all the input qubits:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will result in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.15 – Preparing the input values of our quantum circuit ](img/B18420_11_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.10: Preparing the input values of our quantum circuit'
  prefs: []
  type: TYPE_NORMAL
- en: 'The input state results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_11_096.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When we apply a Hadamard gate to the preceding equation, it breaks out into
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_11_097.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When we apply a Hadamard gate to the single qubit ![](img/B18420_11_098.png),
    this gives us the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_11_099.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Simplifying both ![](img/B18420_11_100.png) and ![](img/B18420_11_101.png)
    gives us the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_11_102.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we will create the oracle ![](img/B18420_11_028.png) function for our
    circuit similar to how we created it in the previous section on the Deutsch algorithm.
    We will use the same here, only this time, we have the ket X, which is more than
    a single bit of information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18420_11_104.png)'
  prefs: []
  type: TYPE_IMG
- en: The value of x is the bit representation of the bit string X of 0 or 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now set our input state using a bit string to represent the balanced
    ![](img/B18420_11_028.png) function—in this case, `''1010''`, which we construct
    by placing an X gate with the set bits and Identity gates with the others. This
    will allow us to determine whether the input is balanced or constant—in this case,
    since we have an equal number of 1s and 0s, it is balanced. You can also just
    not add an Identity gate, but for now, we will add one just to visually indicate
    the `0` values of the bit string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will render the following addition to our circuit, where the added section
    represents setting the input state ![](img/B18420_11_106.png) based on the bit
    string `1010`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.16 – State representation |1010 of bit string 1010 ](img/B18420_11_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.11: State representation ![](img/B18420_11_106.png) of the bit string
    1010'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will apply our oracle. In this case, we will set it to a constant
    output where all outputs should be 1s, with zero probability of 0s. We’ll do so
    by adding CNOT gates, where the Control is applied to each qubit and the Target
    is set to the last qubit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result of this should be as follows, where we set each Control of the CNOT
    gate to all qubits and the Target to our ancilla qubit, **q**[4]:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.17 – Representation of the added balanced oracle ](img/B18420_11_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.12: Representation of the added balanced oracle'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will set the closing bit string, which we use to wrap our oracle—in
    this case, `''1010''`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code will give us the following diagram, just as we expected,
    where the oracle is bound by the bit string:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.18 – Oracle bounded by bit string representation ](img/B18420_11_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.13: Oracle bounded by the bit string representation'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will apply the Hadamard gates to all the qubits:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result of this is rendered as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.19 – Completed quantum circuit of the Deutsch-Jozsa algorithm for
    a balanced function ](img/B18420_11_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.14: A complete quantum circuit of the Deutsch-Jozsa algorithm for
    a balanced function'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will add our measurements so that we can read out the results.
    We will apply the measurements only to the first four qubits:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Therefore, our final quantum circuit should be as follows. Each step in creating
    the Deutsch-Jozsa algorithm is separated by the barriers, where the first is the
    preparation, the second is to set the bit string `1010`, the third is to set our
    oracle ![](img/B18420_11_028.png), and then we reverse the first two steps, followed
    by our measurements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.20 – Final circuit for the Deutsch-Jozsa algorithm ](img/B18420_11_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.15: Final circuit for the Deutsch-Jozsa algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have created our quantum circuit for the Deutsch-Jozsa algorithm,
    let’s execute the circuit on a simulator first to visualize what results we get
    back:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As expected, our results returned a probability of 100% of 1s for a balanced
    circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A blue rectangular graph with white lines  Description automatically generated](img/B18420_11_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.16: Results from the simulator of a balanced function'
  prefs: []
  type: TYPE_NORMAL
- en: As expected, we see that we have a high quasi-probability of `1111`. This was
    computed using a single query, as opposed to the multiple queries that we would
    have needed to compute the same thing classically.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have completed both the Deutsch and Deutsch-Jozsa algorithms, we
    can see that there is some speedup when compared to classical systems. However,
    we can also see that there are no practical or real-world examples where we can
    apply these algorithms. That said, we have understood how the use of superposition
    and entanglement can speed up certain functions compared to classical techniques.
    We’ll expand our understanding of algorithms into something that is a bit more
    of a generalized quantum algorithm, namely, Bernstein-Vazirani, in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the foundational oracle-based quantum algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned in the previous section that the very early quantum algorithms illustrated
    quantum speedup vis-à-vis classical systems in relation to a simple problem. In
    this section, we will expand on this to look at a more complex problem. To do
    this, we will learn about another oracle-based algorithm, **Bernstein-Vazirani**.
    The difference between this one and the previous foundational algorithms is that
    the Bernstein-Vazirani algorithm will identify a hidden bit string using an oracle
    function in a single query.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the Bernstein-Vazirani algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Originally invented in 1992 by Ethan Bernstein and Umesh Vazirani, the Bernstein-Vazirani
    algorithm extends the Deutsch-Jozsa algorithm to a generalization to find an unknown
    or secret bit string. Where the Deutsch-Jozsa algorithm worked to solve the problem
    of determining whether a given function is constant or balanced, the Bernstein-Vazirani
    algorithm works to determine a secret number by applying a function that maps
    an input to its output.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Bernstein-Vazirani problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The problem that the Bernstein-Vazirani algorithm addresses is straightforward
    and similar to the previous problem. Given an unknown function, or black box (oracle),
    similar to the Deutsch-Jozsa oracle, an input string of bits results in an output
    of either 0 or 1\. A simple example could be a logical expression that maps the
    input values to a single output value of either 0 or 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_11_109.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For this function ![](img/B18420_11_002.png), we are guaranteed that the following
    applies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_11_111.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the preceding equation, *s* is an unknown or secret string such that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_11_112.png)'
  prefs: []
  type: TYPE_IMG
- en: The problem, therefore, is to find the secret value *s*.
  prefs: []
  type: TYPE_NORMAL
- en: Solving this classically is the same as the previous examples, where we would
    have to check each value one bit at a time to determine the secret value, *s*.
    However, as we have seen in the previous examples, we can solve this with a quantum
    algorithm executing a single query. Let’s walk through the example to see how
    we can solve this using the Bernstein-Vazirani algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a quantum solution using the Bernstein-Vazirani algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Bernstein-Vazirani algorithm is very similar to Deutsch-Jozsa in that it
    performs the same steps to create the quantum circuit for the algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize all *n* input qubits to the ground state ![](img/B18420_09_039.png).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize the ancilla qubit to the excited state ![](img/B18420_09_034.png).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply a Hadamard gate to all input qubits and the ancilla qubit, ![](img/B18420_11_115.png).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Query the oracle to apply a phase change based on the secret string value using
    CNOT gates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply another set of Hadamard gates to the input qubits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Measure the input qubits to obtain the secret string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see from the preceding steps, the algorithm is very similar. However,
    the main differentiator here is *steps 4* and *5*. When a qubit hits the secret
    key, we then apply a phase shift, that is, when ![](img/B18420_11_116.png), where
    *s*[i] is the *i*th term of the secret string. Then, in *step 5*, when we apply
    the second set of Hadamard gates, the qubit will return from ![](img/B18420_09_035.png)
    to ![](img/B18420_09_034.png) if ![](img/B18420_11_116.png), or from ![](img/B18420_11_120.png)
    to ![](img/B18420_09_039.png) if ![](img/B18420_11_122.png).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement these steps one at a time and review the changes to the state.
    As before, we will use barriers to separate each step so that we can visualize
    each step along the way.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Bernstein-Vazirani algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following steps are a step-by-step guide to creating the **Bernstein-Vazirani**
    algorithm and describe the outcome of each step to help you understand how each
    step affects the state, which will eventually produce the secret string:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a new Qiskit notebook with the usual boilerplate cell that
    will load much of the base Qiskit modules and our account, so that we can execute
    the quantum circuit on an actual quantum computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we will create our quantum circuit, which will be made up of four qubits,
    and one ancilla qubit, and we will define our **secret bit string** (`shh`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code creates our base quantum circuit, `qc`, which we will use
    to construct the Bernstein-Vazirani algorithm. The input qubits must be at least
    the length of our secret string, which, in this case, is the value `1010`. Our
    input register will need to be at least this many qubits in length. We then added
    an ancilla qubit, which, in the previous examples, we referred to as the output
    qubit. Moving forward, we will start referring to this qubit as an ancilla qubit
    in that it is more of a utility qubit that will not be measured or output to our
    results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will add Hadamard gates to the input qubits to ensure that all input
    qubits are set to a superposition state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will render our quantum circuit as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.23 – Initializing the input qubits state from |0 to a superposition
    state, |+ ](img/B18420_11_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.17: Initializing the input qubits’ state from ![](img/B18420_06_015.png)
    to a superposition state, ![](img/B18420_11_124.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will need to prepare our ancilla qubit, **q**[4], just as we did before,
    by first initializing it to the state ![](img/B18420_06_018.png), followed by
    a Hadamard gate, which will prepare the state of the ancilla qubit to ![](img/B18420_11_056.png):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code will render the following circuit, which we see is the same
    initialization of our circuit as before. This is how most quantum algorithms are
    initialized, which allows working with all possible combinations of qubit states.
    The barrier is added simply to view the various state changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.24 – Initialization of all qubits ](img/B18420_11_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.18: Initialization of all qubits'
  prefs: []
  type: TYPE_NORMAL
- en: 'The state at the first barrier is now set to the following, where the input
    qubits are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_11_127.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The ancilla qubit is set to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_11_128.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we need to make a quick bit order adjustment before we apply our oracle
    function. Since the qubits are ordered from right to left, we will need to reverse
    the order of our secret number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see from the following output, the order is now `0101`, so we can
    now apply our oracle function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To apply the oracle function, we want to trigger a phase shift each time we
    hit a `''1''` in the secret string. To do that, we will apply a CNOT gate to each
    qubit, where the Control is set to each qubit and the Target is linked to the
    ancilla. In our case, the secret string has `''1''` set on **qubit 1** (q[1])
    and **qubit 3** (q[3]):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code renders the quantum circuit up to the oracle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.25 – Oracle applying CNOT where the secret string is set to ''1''
    ](img/B18420_11_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.19: Oracle applying CNOT where the secret string is set to ‘1’'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since all our qubits are in a superposition state, by applying the phase shift
    based on the secret string |S⟩, we get the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_11_129.png)'
  prefs: []
  type: TYPE_IMG
- en: Therefore, from the preceding equation, our secret string ![](img/B18420_11_130.png)
    will apply a phase shift to each qubit where the string is set. This will shift
    the ![](img/B18420_11_124.png) to ![](img/B18420_11_056.png) whenever the input
    bit x and the secret string s are equal to 1.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in our last step before applying measurements to the input qubits,
    we apply another set of Hadamard gates. What this set of Hadamard gates achieves
    is that it will return the state of each qubit back to either the ![](img/B18420_06_015.png)
    or ![](img/B18420_06_018.png) state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is entirely dependent on whether the qubit experienced a phase shift while
    passing through the oracle. If it did not, then the state would change from ![](img/B18420_11_124.png)
    to ![](img/B18420_06_015.png), or from ![](img/B18420_11_056.png) to ![](img/B18420_06_018.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This will render the following circuit diagram, which completes the steps to
    implement the Bernstein-Vazirani algorithm along with the measurement operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.26 – Final circuit that implements the Bernstein-Vazirani algorithm
    ](img/B18420_11_20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.20: Final circuit that implements the Bernstein-Vazirani algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the circuit is complete and ready to go, we can execute the circuit
    on your local simulator and then on a real quantum device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The results should have a 100% probability for the value of our secret string,
    as illustrated in the following histogram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A blue rectangular graph with white text  Description automatically generated](img/B18420_11_21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.21: Result identifies with 100% probability the value of our secret
    string'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the preceding result, like the earlier quantum algorithms,
    we can solve certain problems in a single query, whereas it would take classical
    systems a few queries to solve. These problems leveraged **phase kickback**, where
    we used the phase to solve the question of whether the function was balanced or
    constant.
  prefs: []
  type: TYPE_NORMAL
- en: Looking back at the step where we applied the last layer of Hadamard gates,
    it appears as if the control qubit got flipped instead of the other qubit.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about the foundational oracle-based algorithms and
    how they illustrate quantum advantage over classical systems to solve problems.
    We also learned about how oracles and ancilla qubits are leveraged to obtain some
    of the solutions, which will, in turn, help you understand the more complex algorithms
    as you expand your knowledge and research. Although these were simple problems
    that have no commercial value by themselves, they did, however, manage to trigger
    an interest in the quantum information science field that is still growing to
    this day.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered some of the many quantum algorithms that employ
    common techniques that are used in a variety of other quantum algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this chapter was to explore each of them systematically so you could
    have a good understanding of the problem each algorithm solves. The topics here
    are, of course, foundational and oracle-based, although the techniques are commonly
    found in many other quantum algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will step away from the oracle-based foundational algorithms
    and look at another form of algorithm that solves similar problems. However, rather
    than using phases to identify the solution, they will instead leverage periodicity,
    which is primarily why they are called **periodic algorithms**.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which algorithm would you use to determine whether an *n*-bit string is balanced?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the Bernstein-Vazirani algorithm to find the state `170`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many oracle functions are there?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Join us on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/3FyN1](Chapter_11.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code2617625996838265933.png)'
  prefs: []
  type: TYPE_IMG
