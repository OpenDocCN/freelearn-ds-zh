- en: Chapter 3. Moving Spatial Data from One Format to Another
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Converting a Shapefile to a PostGIS table using ogr2ogr
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Batch importing a folder of Shapefiles into PostGIS using ogr2ogr
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Batch exporting a list of tables from PostGIS to Shapefiles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting an OpenStreetMap (OSM) XML to a Shapefile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting a Shapefile (vector) to a GeoTiff (raster)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting a raster (GeoTiff) to a vector (Shapefile) using GDAL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Shapefile from point data stored in Microsoft Excel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting an ESRI ASCII DEM to an image height map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Geospatial data comes in hundreds of formats and massaging this data from one
    format to another is a simple task. The ability to convert between data types,
    such as rasters or vectors, belongs to data wrangling tasks and can be used for
    better geospatial analysis. Here is an example of a raster and vector dataset
    so that you can take a look at what I am talking about:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](img/B03543_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The best practice methodology is to run analysis functions or models over data
    stored in a common format, such as a PostgreSQL PostGIS database, or a set of
    Shapefiles in a common coordinate system. For example, running an analysis on
    input data stored in multiple formats is also possible, but you can expect to
    find the devil in the detail if something goes wrong or your results are not as
    you expected them to be.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter looks at some common data formats and demonstrates how to move
    these from one format to another with the help of the most common tools.
  prefs: []
  type: TYPE_NORMAL
- en: Converting a Shapefile to a PostGIS table using ogr2ogr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest way to transform data from one format to another is to directly
    use the *ogr2ogr* tool that comes with the installation of GDAL. This powerful
    tool can convert over 200 geospatial formats. In this solution, we will execute
    the *ogr2ogr* utility from within a Python script to perform generic vector data
    conversions. The Python code is, therefore, used to execute this command-line
    tool and pass around variables so that you can create your own scripts for data
    imports or exports.
  prefs: []
  type: TYPE_NORMAL
- en: Using this tool is also recommended if you are not really interested in coding
    too much and simply want to get the job done to move your data. A pure Python
    solution is, of course, possible, but it's definitely more orientated to the needs
    of developers (or a Python purist). Since this book is aimed at developers, analysts,
    or researchers, this kind of a recipe is simple and yet extensible.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To run this script, you will need the GDAL utilities application installed
    on your system. Windows users can visit OSGeo4W ([http://trac.osgeo.org/osgeo4w](http://trac.osgeo.org/osgeo4w))
    and download the 32-bit or 64-bit Windows installer. Simply double-click on the
    installer to start the script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the bottom option, **Advanced Installation** | **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Next** to download the GDAL utilities from the Internet (first default
    option).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Next** to accept the default location of the path or change it to
    your liking.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Next** to accept the location of local saved downloads (default).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Next** to accept a direct connection (default).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Next** to select the default download site.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, you can finally see the menu. Click on **+** to open the **Commandline_Utilities**
    tab, and you should see what is shown in this screenshot:![Getting ready](img/B03543_03_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, select **gdal: The GDAL/OGR library and commandline tools** to install
    it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Next** to start downloading and install.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ubuntu/Linux users can use the following steps to install the GDAL utilities:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute this simple one-line command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will get you up and running so that you can execute `ogr2ogr` directly
    from your terminal.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The Shapefile to be imported is located in your `/ch02/geodata/` folder if you've
    downloaded the entire source and code from GitHub at [https://github.com/mdiener21/python-geospatial-analysis-cookbook/](https://github.com/mdiener21/python-geospatial-analysis-cookbook/).
    The Vancouver open geodata portal ([http://data.vancouver.ca/datacatalogue/index.htm](http://data.vancouver.ca/datacatalogue/index.htm))
    is our source that provides a dataset of local bikeways.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let''s set up our PostgreSQL database with the PostGIS extension. To
    do this, we''ll first create a new user to manage our new database and tables
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Enter a password for the new role.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the password again for the new role.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter a password for the `postgres` user as you will create the user using this
    `postgres` user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `–P` option prompts you to give the new user, called `pluto`, a password.
    For the following examples, our password is `stars`; I would recommend a much
    more secure password for your production database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Windows users can navigate to the `c:\Program Files\PostgreSQL\9.3\bin\` folder
    and execute the following command, and follow the on-screen instructions as you
    did earlier:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To create the database, we will use the same command-line `createdb` command
    as the `postgres` user to create a database named `py_geoan_cb`, and assign the
    `pluto` user to be the database owner. Here is the command to do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Windows users can visit `c:\Program Files\PostgreSQL\9.3\bin\` and execute
    the `createdb.exe` command as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll create the PostGIS extension for our newly created database:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Windows users can also execute `psql` from within the `c:\Program Files\PostgreSQL\9.3\bin\`
    folder as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Lastly, we'll create a schema called **geodata** to store our new spatial table.
    It is common to store spatial data in another schema outside the default `public`
    schema of PostgreSQL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Windows users can use the following command to do this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s get into the actual importing of our Shapefile into a PostGIS database
    that will automatically create a new table from our Shapefile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll call our script from the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We begin with importing the standard Python `subprocess` module that will call
    the *ogr2ogr* command-line tool. Next, we'll set up a range of variables that
    are used as input arguments and provide various options for ogr2ogr to execute.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with the PostgreSQL `SCHEMA=geodata` database, we set a nondefault
    database schema for the destination of our new table. It is a best practice to
    store your spatial data tables in a separate schema outside the public schema,
    which is the default. This practice will make backups and restores much easier
    and keeps your database better organized.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a `overwrite_option` variable set to `yes` so that we can overwrite
    any table with the same name when it's created. This is helpful when you want
    to completely replace the table with new data; otherwise, it is recommended to
    use the `-append` option. We also specify the geometry type because, sometimes,
    ogr2ogr does not always guess the correct geometry type of our Shapefile so setting
    this value spares you that worry.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we'll set our `output_format` variable with the `PostgreSQL` key word,
    telling ogr2ogr that we want to output data into a PostgreSQL database. This is
    then followed by the `db_connection` variable that specifies our database connection
    information. We must not forget that the database must already exist along with
    the `geodata` schema; otherwise, we will get an error.
  prefs: []
  type: TYPE_NORMAL
- en: The last `input_shp` variable is the full path to our Shapefile including the
    `.shp` file ending. We'll call the subprocess module and it will call the ogr2ogr
    command-line tool and pass along the variable options required to run the tool.
    We pass this function an array of arguments, starting with the first object in
    the array being the ogr2ogr command-line tool name. Following the name, we pass
    one option after another in the array to complete the call.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Subprocess can be used to call any command-line tool directly. Subprocess takes
    a list of parameters separated by spaces. This passing of parameters is quite
    fussy, so make sure you follow along closely and don't add any extra spaces or
    commas.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, we need to execute our script from the command line to actually
    import our Shapefile by calling the Python interpreter and passing the script.
    Now head over to the **PgAdmin** PostgreSQL database viewer and see if it's worked.
    Or, even better, open up Quantum GIS ([www.qgis.org](http://www.qgis.org)) and
    take a look at the newly created tables.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you would like to see the full list of options available with the ogr2ogr
    command, simply enter the following in the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You will see the full list of options available. Also, visit [http://gdal.org/ogr2ogr.html](http://gdal.org/ogr2ogr.html)
    to read the available documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For those of you who are curious to see how this call would run without using
    Python, the call directly to `ogr2ogr` will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Batch importing a folder of Shapefiles into PostGIS using ogr2ogr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We would like to extend our last script to loop over a folder full of Shapefiles
    and import them into PostGIS. Most importing tasks involve more than one file
    to import, so this makes it a very practical task.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our script will reuse the previous code in the form of a function so that we
    can batch process a list of Shapefiles to import into the PostgreSQL PostGIS database.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create our list of Shapefiles from a single folder for the sake of
    simplicity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can simply run our new script from the command line once again as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we are reusing our code from the previous script but have converted it
    into a Python function called `run_shp2pg (input_shp)` that takes exactly one
    argument and the complete path to the Shapefile that we want to import. The input
    argument must include the Shapefile ending, `.shp`.
  prefs: []
  type: TYPE_NORMAL
- en: We have a helper function that will get the geometry type as a string by reading
    in the Shapefile feature layer and outputting the geometry type so that the `ogr`
    commands know what to expect. This does not always work and some errors can occur.
    The `–skipfailures` option will plow over any errors that are thrown during insertion
    and will still populate our tables.
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, we need to define the folder that contains all our Shapefiles
    to be imported. Next up, we can create an empty list object called `shapefile_list`
    that will hold the list of all our Shapefiles that we want to import.
  prefs: []
  type: TYPE_NORMAL
- en: The first `for` loop is used to get a list of all the Shapefiles in the directory
    specified using the standard Python `os.listdir()` function. We do not want all
    the files in this folder. We only want files with the file ending `.shp`; hence,
    the `if` statement that will evaluate to `True` if the file ends with `.shp`.
    Once the `.shp` file is found, we need to append the file path to the filename
    to create a single string that holds the path plus the Shapefile name and the
    `full_shapefile_path` variable. In the final part, we add each new file with its
    attached path to our `shapefile_list` list object so that we have our final list
    to loop through.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it is time to loop through each Shapefile in our new list and run our `run_shp2pg(input_shp)`
    function for each Shapefile in the list, importing it into our PostgreSQL PostGIS
    database.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have a lot of Shapefiles (and I mean a lot, as in 100 or more Shapefiles),
    performance will be one consideration and will, therefore, require a lot of machines
    with free resources.
  prefs: []
  type: TYPE_NORMAL
- en: Batch exporting a list of tables from PostGIS to Shapefiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now change direction and take a look at how we can batch export a list
    of tables from our PostGIS database into a folder of Shapefiles. We'll again use
    the ogr2ogr command-line tool from within a Python script so that you can include
    it in your application programming work flow. Near the end, you can also see how
    all this works in one single command line.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following script will fire the `ogr2ogr` command and loop over a list of
    tables to export the Shapefile format into an existing folder. So, let''s take
    a look at how to do this as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we''ll call our script from the command line as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Beginning with the simple import of our `subprocess` and `os` modules, we immediately
    define our destination directory where we want to store the exported Shapefiles.
    This variable is followed by the list of table names that we want to export. This
    list can only include files located in the same PostgreSQL schema. The schema
    is defined as the `active_schema` so that `ogr2ogr` knows where to find tables
    to export.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, we define the output format as **ESRI Shapefile**. Now, we'll check
    whether the destination folder exists. If it does, we'll continue and call our
    loop. Then, we'll loop through the list of tables stored in our `postgis_tables_list`
    variable. If the destination folder does not exist, you will see an error printed
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Programming an application and then executing the ogr2ogr command from inside
    your script is definitely quick and easy. On the other hand, for a one-off job,
    simply executing the command-line tool is what you want to do when exporting your
    list of Shapefiles. To do this in a one-liner, take a look at this information
    box.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A one-line example of calling the ogr2ogr batch PostGIS table to Shapefiles
    is shown here if you simply want to execute this once and not in a scripting environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The list of tables you want to export is located at the end as a list separated
    by spaces. The destination location of the exported Shapefiles is `../geodata/temp`.
    Note that this `/temp` directory must exist.
  prefs: []
  type: TYPE_NORMAL
- en: Converting an OpenStreetMap (OSM) XML to a Shapefile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenStreetMap (OSM) has a wealth of free data, but to use it with most other
    applications, we need to convert it to other formats, such as Shapefile or PostgreSQL
    PostGIS databases. This recipe will use the **ogr2ogr** tool to perform the conversion
    for us within a Python script. The benefit of this is, again, simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started, you will need to download the OSM data at [http://www.openstreetmap.org/export#map=17/37.80721/-122.47305](http://www.openstreetmap.org/export#map=17/37.80721/-122.47305)
    and save the file (`.osm`) to your `/ch03/geodata` directory. The download button
    is located on the left-hand side bar and, when pressed, it should immediately
    start the download (refer to the following screenshot). The area we are testing
    is in San Francisco, just before the **Golden Gate Bridge**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/B03543_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you choose to download another area from OSM, feel free but make sure you
    take a small area similar to my example. If you select a larger area, the OSM
    web tool will give you a warning and disable the download button. The reason for
    this is simple: if the dataset is very large, it is most likely better suited
    for another tool, such as **osm2pgsql**, ([http://wiki.openstreetmap.org/wiki/Osm2pgsql](http://wiki.openstreetmap.org/wiki/Osm2pgsql))
    for your conversion. If you need to get OSM data for a large area and want to
    export it to Shapefile, it would be advisable to use another tool, such as **osm2pgsql**,
    which will first import your data into a PostgreSQL database. Then, export the
    data from the PostGIS database to Shapefile using the **pgsql2shp** tool.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A Python tool called **imposm** can be used to import the OSM data into a PostGIS
    database and is available at [http://imposm.org/](http://imposm.org/). Version
    2 of it is written in Python and version 3 is written in the *go* programming
    language, if you want to give this a try as well.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the following steps to convert an OpenStreetMap (OSM) XML into a Shapefile:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the subprocess module, we will execute **ogr2ogr** to convert our OSM
    data that we downloaded into a new Shapefile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can call our script from the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Go and have a look in your `../geodata` folder to see the newly created Shapefiles
    and try to open them up in Quantum GIS, which is a free GIS software ([www.qgis.org](http://www.qgis.org)).
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This script should be clear as we are using the subprocess module call to fire
    our ogr2ogr command-line tool. We'll specify our OSM dataset as an input file,
    including the full path to the file. The Shapefile name is not supplied as ogr2ogr
    will output a set of Shapefiles, one for each geometry shape according to the
    geometry types it finds inside the OSM file. We only need to specify the name
    of the folder where we want ogr2ogr to export the Shapefiles to, automatically
    creating the folder if it does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Windows users: If you do not have your ogr2ogr tool mapped to your environment
    variables, you can simply uncomment the code at lines 16 and 17 and replace the
    path shown with the path on your machine to the Windows executables.'
  prefs: []
  type: TYPE_NORMAL
- en: The first subprocess call prints out to the screen the geometry types found
    inside our OSM file. This is helpful in most cases to help identify what is available.
    Shapefiles can only support one geometry type per file, and this is why ogr2ogr
    outputs a folder full of Shapefiles, each one representing a separate geometry
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we call subprocess to execute ogr2ogr, passing in the output file type
    called ESRI Shapefile, the output folder, and the name of the OSM dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Converting a Shapefile (vector) to a GeoTiff (raster)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Moving data from format to format also includes moving it from vector to raster
    or the other way round. In this recipe, we move data from a vector (Shapefile)
    to a raster (GeoTiff) with the Python `gdal` and `ogr` modules.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to be inside our virtual environment again, so fire it up so that we
    can access the `gdal` and `ogr` Python modules that we installed in [Chapter 1](ch01.html
    "Chapter 1. Setting Up Your Geospatial Python Environment"), *Setting Up Your
    Geospatial Python Environment*.
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, enter your Python virtual environment with the `workon pygeoan_cb`
    command or this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: A Shapefile is also needed, so be sure to download the source and access the
    `/ch03/geodata` folder ([https://github.com/mdiener21/python-geospatial-analysis-cookbook/archive/master.zip](https://github.com/mdiener21/python-geospatial-analysis-cookbook/archive/master.zip)).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s dive in and convert our golf course polygon Shapefile into a GeoTif;
    here comes the code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the libraries `ogr` and `gdal`, and then define our output pixel size
    along with a value to assign to null:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set up the input Shapefile we want to convert alongside the new GeoTiff raster
    that will be created when the script is executed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need to create the input Shapefile object, get the layer information,
    and finally set the extent values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we need to calculate the resolution distance to pixel value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our new raster type is a GeoTiff, so we must explicitly tell GDAL to get this
    driver. The driver is then able to create a new GeoTiff by passing in the filename
    or the new raster that we want to create, called the *x* direction resolution,
    followed by the *y* direction resolution, and then the number of bands; in this
    case, it is 1\. Lastly, we set a new type of `GDT_Byte` raster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can access the new raster band and assign the no data values and the
    inner data values for the new raster. All the inner values will receive a value
    of 255 similar to what we set in the `burn_values` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here we go; let''s run this script to see what our new raster looks like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our resulting raster should look like what is shown in the following screenshot
    if you open it using **QGIS** ([http://www.qgis.org](http://www.qgis.org)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B03543_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several steps involved in this code so follow along as some points
    could lead to trouble if you are not sure what values to input. We start with
    the import of the *gdal* and *ogr* modules, respectively, since they will do the
    work for us by inputting a Shapefile (vector) and outputting a GeoTiff (raster).
  prefs: []
  type: TYPE_NORMAL
- en: The `pixel_size` variable is very important since it will determine the size
    of the new raster that we will create. In this example, we only have two polygons,
    so we set `pixel_size = 1` to keep a fine border between them. If you have many
    polygons stretching across the globe in one Shapefile, it is wiser to set this
    value to 25 or more. Otherwise, you could end up with a 10 GB raster and your
    machine will run all night long! The `no_data_value` is needed to tell GDAL what
    values to set in the empty space around our input polygons and we set it to `-9999`
    for easy identification.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we simply set the input Shapefile stored in EPSG:3857 Web Mercator and
    output GeoTiff. Check to make sure that you change the filenames accordingly if
    you want to use some other dataset. We start by working with the OGR module to
    open the Shapefile and retrieve its layer information and the extent information.
    The extent is important because it is used to calculate the size of the output
    raster width and height values that must be integers represented by the `x_res`
    and `y_res` variables.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the projection of your Shapefile must be in meters and not degrees.
    This is very important since this will NOT work in EPSG:4326, WGS 84, for example.
    The reason for this is that the coordinate units are LAT/LON. This means that
    WGS84 is not a flat plane projection and cannot be drawn as is. Our `x_res` and
    `y_res` values would evaluate to 0 since we cannot get a real ratio using degrees.
    This is a result of us not being able to simply subtract coordinate *x* from coordinate
    *y* because the units are in degrees and not in a flat plane meters projection.
  prefs: []
  type: TYPE_NORMAL
- en: Now, moving on to the raster setup, we define the type of raster we want to
    export as a `Gtiff`. Then, we'll get the correct GDAL driver by the raster type.
    Once the raster type is set, we can create a new empty raster dataset, passing
    in a raster filename, the width, the height of the raster in pixels, the number
    of raster bands, and finally, the type of rasters in GDAL terms, such as `gdal.GDT_Byte`.
    These five parameters are mandatory to create a new raster.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we call `SetGeoTransform` that handles transforming between pixel/line
    raster space and projection coordinate space. We'll want to activate `band 1`
    as it is the only band we have in our raster. Then, we'll assign the no data value
    to all our empty space around a polygon.
  prefs: []
  type: TYPE_NORMAL
- en: The final step is to call the `gdal.RasterizeLayer()` function and pass in our
    new raster, band, Shapefile, and the value to assign to the inside of our raster.
    All the pixels inside the polygon will be assigned a value of 255.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are interested, you can visit the `gdal_rasterize` command-line tool
    at [http://www.gdal.org/gdal_rasterize.html](http://www.gdal.org/gdal_rasterize.html).
    You can run this straight from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Converting a raster (GeoTiff) to a vector (Shapefile) using GDAL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now looked at how we can go from a vector to a raster, so it is now
    time to go from a raster to a vector. This method is much more common because
    most of our vector data is derived from remotely sensed data, such as satellite
    images, orthophotos, or some other remote sensing dataset, such as `lidar`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As usual, enter the `workon pygeoan_cb` command in your Python virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe only requires four steps utilizing OGR and GDAL so please open
    up a new file for your code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `ogr` and `gdal` modules and go straight ahead and open the raster
    we want to convert by passing it the filename on disk and getting a raster band:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set up the output vector file as a Shapefile with output_shp, and then get
    a Shapefile driver. Now, we can create the output from our driver and create a
    layer as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final step is to run the `gdal.Polygonize` function that does the heavy
    lifting by converting our raster to a vector as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute the new script as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Working with `ogr` and `gdal` is similar in all our recipes; we must define
    the inputs and get an appropriate file driver to open the files. The GDAL library
    is very powerful and in only one line of code we can convert a raster to a vector
    with the help of the `gdal.Polygonize` function. The preceding code is simply
    setup code to define which format we want to work with and then set up an appropriate
    driver to input and output our new file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Shapefile from point data stored in Microsoft Excel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Excel files are so common these days that often an analyst or developer receives
    an Excel file that needs to be mapped out. Sure, we could save these to a `.csv`
    file and then use the great Python standard *csv* module but this involves an
    extra manual step. We will take a look at how to read a very simple Excel file
    that contains a list of Europe's highest mountains. This data set is derived from
    [http://www.geonames.org](http://www.geonames.org).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to need one new Python library to read a Microsoft Excel file and
    this library is **xlrd** ([http://www.python-excel.org](http://www.python-excel.org)).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This library can only READ an Excel file; if you are looking to write out to
    an Excel file, download and install **xlwt**.
  prefs: []
  type: TYPE_NORMAL
- en: First, fire up you virtual environment from your `workon pygeoan_cb` Linux machine,
    run `pip install xlrd`, and you are off to the races.
  prefs: []
  type: TYPE_NORMAL
- en: To write out to a new Shapefile, we will use the pyshp library we installed
    in [Chapter 1](ch01.html "Chapter 1. Setting Up Your Geospatial Python Environment"),
    *Setting Up Your Geospatial Python environment*, so that there is no need to do
    anything.
  prefs: []
  type: TYPE_NORMAL
- en: The data is located in your downloads in `/ch03/geodata` and the output Shapefile
    will also be written to this location after you go through this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So let''s get started with some code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start with the import of `xlrd` and the pyshp module; note that the import
    name is `shapefile` and not pyshp as the module name would imply:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the Excel file using the xlrd module and create a variable to hold the
    Excel sheet. We reference the first sheet in the Excel file by an index number,
    always starting with (0) in the first sheet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the Shapefile object as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the new Shapefile fields and their data types. *F* stands for float
    and *C* is for character:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Loop through each row in the Excel file and create the geometry values along
    with attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, we''ll create the new Shapefile in the `/ch03/geodata` folder as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Go ahead and execute our new `ch03-07_excel2shp.py` script from the command
    line as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Python code reads similar to making a description of how code works and
    is almost all too easy to explain. We start with importing our new *xlrd* module
    along with the Shapefile module needed to write out to a Shapefile. Taking a look
    at our Excel file, we see which fields are available and locate where the *X*
    coordinate (longitude) and *Y* coordinate (latitude) are positioned. This position
    index number remembers the starting point by counting from 0 for the first column.
  prefs: []
  type: TYPE_NORMAL
- en: Our Excel file also has a header row and this is, of course, not to be included
    in the new data attributes; this is why we check to see whether row numbers are
    equal to 0—that is, the first row—and then continue. The continue statements allow
    the code to continue without an error and enter the `else` statement where we
    define the index positions of our columns. Each column is referenced using the
    `pyshp` syntax, referencing the columns by name to make the code even easier to
    read.
  prefs: []
  type: TYPE_NORMAL
- en: We call the `w.point` pyshp function to create the point geometry passing in
    our x and y coordinates as floats. The `xlrd` module converts the values for us
    automatically into floats, which is nice. All we need to do in the end is use
    the pyshp save function to write out to our `/ch03/geodata` folder. There is no
    need to add the `.shp` extension; pyshp handles this for us and outputs `.shp`,
    `.dbf`, and `.shx`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that a `.prj` projection file is not automatically output. If you would
    like to have the projection information exported as well, you will need to manually
    create it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Converting an ESRI ASCII DEM to an image height map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To end this chapter with a bang, here is the most complicated conversion we
    have seen so far and the most fun as well. Input is an elevation dataset that's
    stored in *ASCII* format, more specifically, Arc/Info ASCII Grid, for short with
    the AAIGrid with the (`.asc`) file ending. Our output is a *heightmap* image ([http://en.wikipedia.org/wiki/Heightmap](http://en.wikipedia.org/wiki/Heightmap)).
    A heightmap image is an image that stores height elevation as a pixel value. A
    heightmap is also simply known as a **digital elevation model** (**DEM**). The
    benefit of using an image to store elevation data is that it is *web compatible*
    and we can use this in a 3D visualization with **threejs**, for example, as shown
    in [Chapter 10](ch10.html "Chapter 10. Visualizing Your Analysis"), *Visualizing
    Your Analysis*.
  prefs: []
  type: TYPE_NORMAL
- en: We need to be careful with regard to the output image format because simply
    storing an 8-bit image limits us to only storing 0 to 255 height values, which
    is typically not enough. The output image should store a minimum of 16-bits, giving
    us a range from -32,767 to 32,767\. If I am correct, the tallest mountain on earth
    is Mt. Everest at a height of 8,848 m, so a 16-bit image should be more than enough
    to hold our elevation data.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A DEM is needed to run this exercise so please make sure you have downloaded
    the code and geodata included at [https://github.com/mdiener21/python-geospatial-analysis-cookbook/archive/master.zip](https://github.com/mdiener21/python-geospatial-analysis-cookbook/archive/master.zip)
    and download the sample DEM needed to process. You do not need to run your script
    from within your virtual environment because this script will be executing standard
    Python modules and several GDAL built-in tools installed with GDAL. This simply
    means that you need to make sure your GDAL utilities are properly installed and
    running on your machine. (Refer to [Chapter 2](ch02.html "Chapter 2. Working with
    Projections"), *Working with Projections*, for the reference installation.)
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will execute this script by calling several GDAL utility scripts installed
    by `gdal` from our Python script:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by importing the subprocess standard module; this will be used
    to execute our GDAL utility functions. Then, we''ll set the base path to where
    we will store our geodata for input files, temporary files, and output files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Windows users who have installed GDAL using the great OSGeo4w installer might
    want to specify the path directly to the GDAL utilities if it is not available
    in the Windows Environment variables as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Linux users can use these variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll create a set of variables to hold our input DEM, output files, temporary
    files, and our final output file. The variables concatenate the base path folder
    to the filename as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we''ll call the `gdal_translate` command to create our new temporary
    GeoTiff as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll open the temp GeoTiff and read the information about the tiff
    to find out the minimum and maximum height values stored in our data. This is
    not needed to complete the script but is very useful to identify your maximum
    and minimum height values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, call the gdal_translate utility with the following parameters, setting
    the scale range from its original min/max values to a new scale ranging from the
    0 to 65,535 values. Specify the `-ot` output type to be in the vENVI format using
    our temporary GeoTiff as the input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s run our new `ch03-08_dem2heightmap.py` script from the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s run our new `ch03-08_dem2heightmap.py` script from the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The result is that you have a new .bin file located in your /ch03/geodata/ folder
    that stores your new ENVI 16-bit image including all your elevation data. The
    image height map can now be used in your 3D software, such as Blender ([www.blender.org](http://www.blender.org)),
    Unity ([www.unity3d.com](http://www.unity3d.com)), or in an even cooler web application
    using a JavaScript library such as `threejs`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start with the imports, and then we'll specify the base path to where
    our inputs and outputs will be stored. After this, we'll see the actual commands
    we used to execute the `gdal_translate` transformation. The commands for Windows
    and Linux are for you to decide whether to use or not and this depends on how
    you have set up up your machine. We then set our variable to define the input
    DEM, temporary GeoTiff, and the output ENVI height map image.
  prefs: []
  type: TYPE_NORMAL
- en: At last, we can call the first transformation that converts our DEM ASCII file
    into a GeoTiff with the `gdal_translate` utility. Now to get a little information
    about our data, we print out the `min` and `max` height values to the screen.
    Sometimes, this is very useful when transforming, allowing you to check whether
    the output data actually contains the input height values and that nothing went
    astray during conversion.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, we simply call the `gdal_translate` utility once again to convert
    our GeoTiff into an ENVI heightmap image. The -scale with no parameters automatically
    fills our 16-bit image with values ranging from 0 to 65,535\. Our next parameter
    is `-ot`, which specifies the output type as 16-bit followed by `-outsize 500
    500`, setting the output image size to 500 x 500 pixels. Lastly, `-of ENVI` is
    our output format followed by the name of the input GeoTiff and the name of the
    output height map.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical work flow when working with DEM''s is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Download a DEM that is usually a very large file and covers a large geographic
    region.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clip the DEM to a smaller region of interest.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the clipped region to another format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Export the DEM as a heightmap image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We introduce `.split()` that will return a Python list of words, separated by
    a character. In our case, the separator character is a *single space* character
    but you could split based on any other character or a combination of characters
    (refer to the Python documentation at [https://docs.python.org/2/library/string.html#string.split](https://docs.python.org/2/library/string.html#string.split))
    This helps us reduce the amount of concatenating that we need to do in our code.
  prefs: []
  type: TYPE_NORMAL
