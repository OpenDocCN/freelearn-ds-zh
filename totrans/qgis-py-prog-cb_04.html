<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;4.&#xA0;Using Raster Data"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04" class="calibre1"/>Chapter 4. Using Raster Data</h1></div></div></div><p class="calibre9">In this chapter, we will cover the following recipes:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Loading a raster layer</li><li class="listitem">Getting the cell size of a raster layer</li><li class="listitem">Obtaining the width and height of a raster</li><li class="listitem">Counting raster bands</li><li class="listitem">Swapping raster bands</li><li class="listitem">Querying the value of a raster at a specified point</li><li class="listitem">Reprojecting a raster</li><li class="listitem">Creating an elevation hillshade</li><li class="listitem">Creating vector contours from elevation data</li><li class="listitem">Sampling a raster dataset using a regular grid</li><li class="listitem">Adding elevation data to line using a digital elevation model</li><li class="listitem">Creating a common extent for rasters</li><li class="listitem">Resampling raster resolution</li><li class="listitem">Counting the unique values in a raster</li><li class="listitem">Mosaicing rasters</li><li class="listitem">Converting a TIFF image to a JPEG image</li><li class="listitem">Creating pyramids for a raster</li><li class="listitem">Converting a pixel location to a map coordinate</li><li class="listitem">Converting a map coordinate to a pixel location</li><li class="listitem">Creating a KML image overlay for a raster</li><li class="listitem">Classifying a raster</li><li class="listitem">Converting a raster to a vector</li><li class="listitem">Georeferencing a raster from ground control points</li><li class="listitem">Clipping a raster using a shapefile</li></ul></div></div>

<div class="book" title="Chapter&#xA0;4.&#xA0;Using Raster Data">
<div class="book" title="Introduction"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch04lvl1sec56" class="calibre1"/>Introduction</h1></div></div></div><p class="calibre9">This chapter shows you how to bring raster data into a GIS and create derivative raster products using QGIS and Python. QGIS is equally adept at working with raster data as with vector data, by incorporating leading-edge open source libraries and algorithms, including GDAL, SAGA, and the Orfeo Toolbox. QGIS provides a consistent interface to for large array of remote sensing tools. We will switch back and forth between visually working with raster data and using QGIS as a processing engine via the Processing Toolbox, to completely automating remote sensing workflows.</p><p class="calibre9">Raster data consists of rows and columns of cells or pixels, with each cell representing a single value. The easiest way to think of raster data is as images, which is how they are typically represented by software. However, raster datasets are not necessarily stored as images. They<a id="id244" class="calibre1"/> can also be ASCII text files or <span class="strong"><strong class="calibre2">binary large objects</strong></span> (<span class="strong"><strong class="calibre2">BLOBs</strong></span>) in databases.</p><p class="calibre9">Another difference between geospatial raster data and regular digital images is their resolution. Digital images express resolution as dots-per-inch, if they are printed in full size. Resolution can also be expressed as the total number of pixels in the image, defined as megapixels. However, geospatial raster data uses the ground distance that each cell represents. For example, a raster dataset with a two-feet resolution means that a single cell represents two feet on the ground. This also means that only objects larger than two feet can be identified visually in the dataset.</p><p class="calibre9">Raster datasets may contain multiple bands, meaning that different wavelengths of light can be collected at the same time over the same area. Often, this range is from 3 to 7 bands wide, but it can be several hundred bands wide in hyperspectral systems. These bands are viewed individually or swapped in and out as the RGB bands of an image. They can also be recombined using mathematics into a derived single band image and then recolored using a set number of classes, representing similar values within the dataset.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Loading a raster layer"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec57" class="calibre1"/>Loading a raster layer</h1></div></div></div><p class="calibre9">The <code class="literal">QGSRasterLayer</code> API provides a convenient, high-level interface to raster data. To use this <a id="id245" class="calibre1"/>interface, we must load a layer into QGIS. The API allows you to <a id="id246" class="calibre1"/>work with a layer without adding it to the map. In this way, we'll load layer and then add it to the map.</p></div>

<div class="book" title="Loading a raster layer">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec155" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">As with the other recipes in this book, you need to create a directory called <code class="literal">qgis_data</code> in our root or user directory, which provides a short pathname without spaces. This setup will help prevent any frustrating errors that result from path-related issues on a given system. In this <a id="id247" class="calibre1"/> recipe, and the others, we'll use a Landsat satellite image of the Mississippi Gulf Coast, which you can download from <a class="calibre1" href="https://geospatialpython.googlecode.com/files/SatImage.zip">https://geospatialpython.googlecode.com/files/SatImage.zip</a>.</p><p class="calibre9">Unzip the <code class="literal">SatImage.tif</code> and <code class="literal">SatImage.tfw</code> files and place them in a directory named <code class="literal">rasters</code>
 within your <code class="literal">qgis_data</code> directory.</p></div></div>

<div class="book" title="Loading a raster layer">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec156" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">Now, we'll go <a id="id248" class="calibre1"/>through how to load a raster layer and then step by step add it to the map</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Start QGIS.</li><li class="listitem" value="2">From the <span class="strong"><strong class="calibre2">Plugins</strong></span> menu, select <span class="strong"><strong class="calibre2">Python Console</strong></span>.</li><li class="listitem" value="3">Then, in the <span class="strong"><strong class="calibre2">Python Console</strong></span>, create the layer by specifying the source file and a layer name:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">rasterLyr = QgsRasterLayer("/qgis_data/rasters/SatImage.tif", "Gulf Coast")</strong></span>
</pre></div></li><li class="listitem" value="4">Next, ensure that the layer is created as expected. The following command should return <code class="literal">True</code>:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">rasterLyr.isValid()</strong></span>
</pre></div></li><li class="listitem" value="5">Finally, add the layer to the layer registry:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayers([rasterLyr])</strong></span>
</pre></div></li><li class="listitem" value="6">Verify that your QGIS map looks similar to the following image:<div class="mediaobject"><img src="../images/00029.jpeg" alt="How to do it..." class="calibre11"/><div class="caption"><p class="calibre16">QGIS zooms to the extent of the raster layer when it is loaded as shown in this example of a Landsat satellite image of the Mississippi Gulf Coast</p></div></div><p class="calibre15"> </p></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Loading a raster layer">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec157" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The <code class="literal">QgsRasterLayer</code> object <a id="id249" class="calibre1"/>requires the location of the file and a name for the layer in QGIS. The underlying GDAL library determines the appropriate method of loading the layer. This approach contrasts with the <code class="literal">QgsVectorLayer()</code> method, which requires you to specify a data provider. Raster layers also have a data provider, but unlike vector layers, all raster<a id="id250" class="calibre1"/> layers are managed through GDAL. One of the best features of QGIS is that it combines the best of breed open source geospatial tools into one package. GDAL can be used as a library as we are using it here from Python or as a command-line tool.</p><p class="calibre9">Once we have created the <code class="literal">QgsRasterLayer</code> object, we do a quick check using the <code class="literal">rasterLayer.isValid()</code> method to see whether the file was loaded properly. This method will return <code class="literal">True</code> if the layer is valid. We won't use this method in every recipe; however, it is a best practice, especially when building dynamic applications that accept user input. Because most of the PyQGIS API is built around C libraries, many methods do not throw exceptions if an operation fails. You must use specialized methods to verify the output.</p><p class="calibre9">Finally, we add the layer to the map layer registry, which makes it available on the map and in the legend. The registry keeps track of all the loaded layers by separating, loading, and visualizing the layers. QGIS allows you to work behind the scenes in order to perform unlimited intermediate processes on a layer before adding the final product to the map.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Getting the cell size of a raster layer"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec58" class="calibre1"/>Getting the cell size of a raster layer</h1></div></div></div><p class="calibre9">The first key<a id="id251" class="calibre1"/> element of a geospatial raster is the width and height, in pixels. The second key element is the ground distance of each pixel, also called the pixel size. Once you know the cell size and a coordinate somewhere on the image (usually the upper-left corner), you can begin using remote sensing tools on the image. In this <a id="id252" class="calibre1"/>recipe, we'll query the cell size of a raster.</p></div>

<div class="book" title="Getting the cell size of a raster layer">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec158" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">Once again, we<a id="id253" class="calibre1"/> will use the SatImage raster available at <a class="calibre1" href="https://geospatialpython.googlecode.com/files/SatImage.zip">https://geospatialpython.googlecode.com/files/SatImage.zip</a>.</p><p class="calibre9">Place this raster in your <code class="literal">/qgis_data/rasters</code> directory.</p></div></div>

<div class="book" title="Getting the cell size of a raster layer">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec159" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will load the raster as a layer and then use the <code class="literal">QgsRasterLayer</code> API to get the cell size for the <span class="strong"><em class="calibre10">x</em></span> and <span class="strong"><em class="calibre10">y</em></span> axis. To do this, we need to perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Start QGIS.</li><li class="listitem" value="2">From the <span class="strong"><strong class="calibre2">Plugins</strong></span> menu, select <span class="strong"><strong class="calibre2">Python Console</strong></span>.</li><li class="listitem" value="3">Load the layer and validate it:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">rasterLyr = QgsRasterLayer("/qgis_data/rasters/satimage.tif", "Sat Image")</strong></span>
<span class="strong"><strong class="calibre2">rasterLyr.isValid()</strong></span>
</pre></div></li><li class="listitem" value="4">Now, call the x distance method, which should return 0.00029932313140079714:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">rasterLyr.rasterUnitsPerPixelX()</strong></span>
</pre></div></li><li class="listitem" value="5">Then, call the <span class="strong"><em class="calibre10">y</em></span> distance, which should be <code class="literal">0.00029932313140079714</code>:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">rasterLyr.rasterUnitsPerPixelY()</strong></span>
</pre></div></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Getting the cell size of a raster layer">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec160" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">GDAL provides this information, which is passed through to the layer API. Note that while the <span class="strong"><em class="calibre10">x</em></span> and <span class="strong"><em class="calibre10">y</em></span> values are essentially the same in this case, it is entirely possible for the <span class="strong"><em class="calibre10">x</em></span> and <span class="strong"><em class="calibre10">y</em></span> distances to be different—especially if an image is projected or warped in some way.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Obtaining the width and height of a raster"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec59" class="calibre1"/>Obtaining the width and height of a raster</h1></div></div></div><p class="calibre9">All raster layers have a width and height in pixels. Because remote sensing data can be considered <a id="id254" class="calibre1"/>an image as well as an array or matrix, you will often see different terms used, including columns and rows or pixels and lines. These different terms surface many times within the QGIS API.</p></div>

<div class="book" title="Obtaining the width and height of a raster">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec161" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">We will use the SatImage raster again, which is available at <a class="calibre1" href="https://geospatialpython.googlecode.com/files/SatImage.zip">https://geospatialpython.googlecode.com/files/SatImage.zip</a>.</p><p class="calibre9">Place this raster in your <code class="literal">/qgis_data/rasters</code> directory.</p></div></div>

<div class="book" title="Obtaining the width and height of a raster">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec162" class="calibre1"/>How to do it...</h2></div></div></div><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Start QGIS.</li><li class="listitem" value="2">From the <span class="strong"><strong class="calibre2">Plugins</strong></span> menu, select <span class="strong"><strong class="calibre2">Python Console</strong></span>.</li><li class="listitem" value="3">In the Python Console, load the layer and ensure that it is valid:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">rasterLyr = QgsRasterLayer("/qgis_data/rasters/satimage.tif", "satimage")</strong></span>
<span class="strong"><strong class="calibre2">rasterLyr.isValid()</strong></span>
</pre></div><p class="calibre17">Check the name of SatImage after unzipping.</p></li><li class="listitem" value="4">Obtain the layer's width, which should be <code class="literal">2592</code>:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">rasterLyr.width()</strong></span>
</pre></div></li><li class="listitem" value="5">Now, get the raster's height, which will return <code class="literal">2693</code>:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">rasterLyr.height()</strong></span>
</pre></div></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Obtaining the width and height of a raster">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec163" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The width and height of a raster are critical pieces of information for many algorithms, including calculating the map units that the raster occupies.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Counting raster bands"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec60" class="calibre1"/>Counting raster bands</h1></div></div></div><p class="calibre9">A raster might have<a id="id255" class="calibre1"/> one or more bands. Bands represent layers of information within a raster. Each band has the same number of columns and rows.</p></div>

<div class="book" title="Counting raster bands">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec164" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">We will again use the SatImage raster available at <a class="calibre1" href="https://geospatialpython.googlecode.com/files/SatImage.zip">https://geospatialpython.googlecode.com/files/SatImage.zip</a>.</p><p class="calibre9">Place this raster in your <code class="literal">/qgis_data/rasters</code> directory.</p></div></div>

<div class="book" title="Counting raster bands">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec165" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will load the<a id="id256" class="calibre1"/> layer and then print the band count to the console. To do this, we need to perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Start QGIS.</li><li class="listitem" value="2">From the <span class="strong"><strong class="calibre2">Plugins</strong></span> menu, select <span class="strong"><strong class="calibre2">Python Console</strong></span>.</li><li class="listitem" value="3">In the Python Console, load the layer and ensure that it is valid:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">rasterLyr = QgsRasterLayer("/qgis_data/rasters/satimage.tif", "Sat Image")</strong></span>
<span class="strong"><strong class="calibre2">rasterLyr.isValid()</strong></span>
</pre></div></li><li class="listitem" value="4">Now, get the band count, which should be <code class="literal">3</code> in this case:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">rasterLyr.bandCount()</strong></span>
</pre></div></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Counting raster bands">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec166" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">It is important to note that raster bands are not zero-based indexes. When you want to access the first band, you reference it as <code class="literal">1</code> instead of <code class="literal">0</code>. Most sequences within a programming context start with <code class="literal">0</code>.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Swapping raster bands"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec61" class="calibre1"/>Swapping raster bands</h1></div></div></div><p class="calibre9">Computer displays<a id="id257" class="calibre1"/> render images in the visible spectrum of red, green, and blue light (RGB). However, raster images may contain bands outside the visible spectrum. These types of rasters make poor visualizations, so you will often want to recombine the bands to change the RGB values.</p></div>

<div class="book" title="Swapping raster bands">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec167" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">For this recipe, we will <a id="id258" class="calibre1"/>use a false-color image, which you can download from <a class="calibre1" href="https://geospatialpython.googlecode.com/files/FalseColor.zip">https://geospatialpython.googlecode.com/files/FalseColor.zip</a>.</p><p class="calibre9">Unzip this <code class="literal">tif</code> file and place it in your <code class="literal">/qgis_data/rasters</code> directory.</p></div></div>

<div class="book" title="Swapping raster bands">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec168" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will load this raster and swap the order of the first and second bands. Then, we will add it to the <a id="id259" class="calibre1"/>map. To do this, we need to perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Start QGIS.</li><li class="listitem" value="2">From the <span class="strong"><strong class="calibre2">Plugins</strong></span> menu, select <span class="strong"><strong class="calibre2">Python Console</strong></span>.</li><li class="listitem" value="3">In the <span class="strong"><strong class="calibre2">Python Console</strong></span>, load the layer and ensure that it is valid:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">rasterLyr = QgsRasterLayer("/qgis_data/rasters/FalseColor.tif", "Band Swap")</strong></span>
<span class="strong"><strong class="calibre2">rasterLyr.isValid()</strong></span>
</pre></div></li><li class="listitem" value="4">Now, we must access the layer renderer in order to manipulate the order of the bands displayed. Note that this change does not affect the underlying data:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">ren = rasterLyr.renderer()</strong></span>
</pre></div></li><li class="listitem" value="5">Next, we will set the <code class="literal">red band</code> to band <code class="literal">2</code>:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">ren.setRedBand(2)</strong></span>
</pre></div></li><li class="listitem" value="6">Now, we will set the <code class="literal">green band</code> to band <code class="literal">1</code>:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">ren.setGreenBand(1)</strong></span>
</pre></div></li><li class="listitem" value="7">Finally, add the altered raster layer to the map:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayers([rasterLyr])</strong></span>
</pre></div></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Swapping raster bands">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec169" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">Load the source image into QGIS as well to compare the results. In the false-color image, vegetation appears red, while in the band-swapped image, trees appear a more natural green and the water is blue. QGIS uses the RGB order to allow you to continue to reference the bands by number. Even though band <code class="literal">2</code> is displayed first, it is still referenced as band <code class="literal">2</code>. Also, notice that the band order is controlled by a <code class="literal">QgsMultiBandColorRenderer</code> object instantiated by the layer rather than the layer itself. The type of renderer that is needed is determined at load time by the data type and number of bands.</p></div></div>

<div class="book" title="Swapping raster bands">
<div class="book" title="There's more..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch04lvl2sec170" class="calibre1"/>There's more...</h2></div></div></div><p class="calibre9">The <code class="literal">QgsMultiBandColorRenderer()</code> method has other methods to control contrast enhancement<a id="id260" class="calibre1"/> for each band, such as <code class="literal">setRedContrastEnhancement()</code>. You can learn more about raster renderers for different<a id="id261" class="calibre1"/> types of data in the QGIS API documentation at <a class="calibre1" href="http://qgis.org/api/classQgsRasterRenderer.html">http://qgis.org/api/classQgsRasterRenderer.html</a>.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Querying the value of a raster at a specified point"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec62" class="calibre1"/>Querying the value of a raster at a specified point</h1></div></div></div><p class="calibre9">A common<a id="id262" class="calibre1"/> remote sensing operation is to<a id="id263" class="calibre1"/> get the raster data value at a specified coordinate. In this recipe, we'll query the data value in the center of the image. It so happens that the raster layer will calculate the center coordinate of its extent for you.</p></div>

<div class="book" title="Querying the value of a raster at a specified point">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec171" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">As with many recipes in this chapter, we will again use the SatImage raster, which is available at <a class="calibre1" href="https://geospatialpython.googlecode.com/files/SatImage.zip">https://geospatialpython.googlecode.com/files/SatImage.zip</a>.</p><p class="calibre9">Place this raster in your <code class="literal">/qgis_data/rasters</code> directory.</p></div></div>

<div class="book" title="Querying the value of a raster at a specified point">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec172" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will load the layer, get the center coordinate, and then query the value. To do this, we need to perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, load and validate the layer:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">rasterLyr = QgsRasterLayer("/qgis_data/rasters/satimage.tif", "Sat Image")</strong></span>
<span class="strong"><strong class="calibre2">rasterLyr.isValid()</strong></span>
</pre></div></li><li class="listitem" value="2">Next, get the layer's center point from its <code class="literal">QgsRectangle extent</code> object, which will return a tuple with the <span class="strong"><em class="calibre10">x</em></span> and <span class="strong"><em class="calibre10">y</em></span> values:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">c = rasterLyr.extent().center()</strong></span>
</pre></div></li><li class="listitem" value="3">Now, using the layer's data provider, we can query the data value at that point using the <code class="literal">identify()</code> method:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">qry = rasterLyr.dataProvider().identify(c, QgsRaster.IdentifyFormatValue)</strong></span>
</pre></div></li><li class="listitem" value="4">Because a query error won't throw an exception, we must validate the query:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">qry.isValid()</strong></span>
</pre></div></li><li class="listitem" value="5">Finally, we can view the query results, which will return a Python dictionary with each band number as the key pointing to the data values in that band:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">qry.results()</strong></span>
</pre></div></li><li class="listitem" value="6">Verify that you get the following output:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">{1: 17.0, 2: 66.0, 3: 56.0}</strong></span>
</pre></div></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Querying the value of a raster at a specified point">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec173" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">This recipe is short<a id="id264" class="calibre1"/> compared to others, however, we have touched upon several portions of the PyQGIS raster API. First start with a raster layer and get the extents; we then calculate the center and create a point at the center<a id="id265" class="calibre1"/> coordinates, and lastly we query the raster at that point. If we were to perform this same, seemingly simple operation using the Python API of the underlying GDAL library, which does the work, this example would have be approximately seven times longer.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Reprojecting a raster"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec63" class="calibre1"/>Reprojecting a raster</h1></div></div></div><p class="calibre9">A core requirement for all geospatial analysis is the ability to change the map projection of data in <a id="id266" class="calibre1"/>order to allow different layers to be open on the same map. Reprojection can be challenging, but QGIS makes it a snap of the fingers. Starting with this recipe, we will begin using the powerful QGIS Processing Toolbox. The Processing Toolbox wraps over 600 algorithms into a highly consistent API, available to Python and also as interactive tools. This toolbox was originally a third-party plugin named SEXTANTE, but is now a standard plugin distributed with QGIS.</p></div>

<div class="book" title="Reprojecting a raster">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec174" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">As with many recipes in this chapter, we will use the SatImage raster available at <a class="calibre1" href="https://geospatialpython.googlecode.com/files/SatImage.zip">https://geospatialpython.googlecode.com/files/SatImage.zip</a>.</p><p class="calibre9">Place this raster in your <code class="literal">/qgis_data/rasters</code> directory.</p></div></div>

<div class="book" title="Reprojecting a raster">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec175" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">In this recipe, we will use the <code class="literal">gdal warp</code>
 algorithm of the <code class="literal">processing</code> module to reproject our image from <code class="literal">EPSG 4326</code> to <code class="literal">3722</code>. To do this, we need to perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Start QGIS.</li><li class="listitem" value="2">From the <span class="strong"><strong class="calibre2">Plugins</strong></span> menu, select <span class="strong"><strong class="calibre2">Python Console</strong></span>.</li><li class="listitem" value="3">The first line of code is used to import the <code class="literal">processing</code> module:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">import processing</strong></span>
</pre></div></li><li class="listitem" value="4">Next, we load our raster layer and validate it:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">rasterLyr = QgsRasterLayer("/qgis_data/rasters/SatImage.tif", "Reproject")</strong></span>
<span class="strong"><strong class="calibre2">rasterLyr.isValid()</strong></span>
</pre></div></li><li class="listitem" value="5">Finally, we run the <code class="literal">gdal warp</code> algorithm by inserting the correct parameters, including the layer reference, current projection, desired projection, <code class="literal">None</code> for changes to the resolution, <code class="literal">0</code> to represent nearest neighbor resampling, <code class="literal">None</code> for additional parameters, <code class="literal">0 –Byte</code> output raster data type (<code class="literal">1 for int16</code>), and an output name for the reprojected image:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">processing.runalg("gdalogr:warpreproject", rasterLyr, "EPSG:4326", "EPSG:3722", None, 0, None, "/0, qgis_data/rasters/warped.tif")</strong></span>
</pre></div></li><li class="listitem" value="6">Verify<a id="id267" class="calibre1"/> that the output image, <code class="literal">warped.tif</code>, was properly created in the filesystem.</li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Reprojecting a raster">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec176" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The Processing Toolbox is essentially a wrapper for command-line tools. However, unlike the tools it accesses, the toolbox provides a consistent and mostly predictable API. Users familiar with Esri's ArcGIS ArcToolbox will find this approach familiar. Besides consistency, the toolbox adds additional validation of parameters and logging, making these tools more user friendly. It is important to remember that you must explicitly import the <code class="literal">processing</code> module. PyQGIS automatically loads the QGIS API, but this module is not yet included. Remember that it was a third-party plugin until fairly recently.</p></div></div>

<div class="book" title="Reprojecting a raster">
<div class="book" title="There's more..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch04lvl2sec177" class="calibre1"/>There's more...</h2></div></div></div><p class="calibre9">The <code class="literal">runalg()</code> method, short for the run algorithm, is the most common way to run processing commands. There are other processing methods that you can use though. If you want to load the output of your command straight into QGIS, you can swap <code class="literal">runalg()</code> for the <code class="literal">runandload()</code> method. All arguments to the method remain the same. You can also get a list of processing algorithms with descriptions by running <code class="literal">processing.alglist()</code>. For any given algorithm, you can run the <code class="literal">alghelp()</code> command to see the types of input it requires, such as <code class="literal">processing.alghelp("gdalogr:warpproject")</code>. You can also write your own processing scripts based on combinations of algorithms and add them to the processing toolbox. There is also a visual modeler for chaining processing commands together.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Creating an elevation hillshade"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec64" class="calibre1"/>Creating an elevation hillshade</h1></div></div></div><p class="calibre9">A hillshade, or<a id="id268" class="calibre1"/> shaded relief, is a technique to visualize elevation<a id="id269" class="calibre1"/> data in order to make it photorealistic for presentation as a map. This capability is part of GDAL and is available in QGIS in two different ways. It is a tool in the <span class="strong"><strong class="calibre2">Terrain Analysis</strong></span> menu under the <span class="strong"><strong class="calibre2">Raster</strong></span> menu and it is also an algorithm in the Processing Toolbox.</p></div>

<div class="book" title="Creating an elevation hillshade">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec178" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You will need to <a id="id270" class="calibre1"/>download a DEM from <a class="calibre1" href="https://geospatialpython.googlecode.com/files/dem.zip">https://geospatialpython.googlecode.com/files/dem.zip</a>.</p><p class="calibre9">Unzip the file named <code class="literal">dem.asc</code> and place it in your <code class="literal">/qgis_data/rasters</code> directory.</p></div></div>

<div class="book" title="Creating an elevation hillshade">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec179" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">In this recipe, we will<a id="id271" class="calibre1"/> load the DEM layer and run the <code class="literal">Hillshade</code> processing algorithm against it. To do this, we need to perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Start QGIS.</li><li class="listitem" value="2">From the <span class="strong"><strong class="calibre2">Plugins</strong></span> menu, select <span class="strong"><strong class="calibre2">Python Console</strong></span>.</li><li class="listitem" value="3">Import the <code class="literal">processing</code> module:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">import processing</strong></span>
</pre></div></li><li class="listitem" value="4">Load and validate the layer:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">rasterLyr = QgsRasterLayer("/qgis_data/rasters/dem.asc", "Hillshade")</strong></span>
<span class="strong"><strong class="calibre2">rasterLyr.isValid()</strong></span>
</pre></div></li><li class="listitem" value="5">Run the <code class="literal">Hillshade</code> algorithm, providing the algorithm name, layer reference, band number, compute edges option, zevenbergen option for smoother terrain, <code class="literal">z</code>-factor elevation exaggeration number, scaling ratio of vertical to horizontal units, azimuth (angle of the light source), altitude (height of the light source), and output image's name:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">processing.runandload("gdalogr:hillshade", rasterLyr, 1, False, False, 1.0, 1.0, 315.0, 45.0, "/qgis_data/rasters/hillshade.tif")</strong></span>
</pre></div></li><li class="listitem" value="6">Verify that the output image, <code class="literal">hillshade.tif</code>, looks similar to the following image in QGIS. It should be automatically loaded into QGIS via the <code class="literal">processing.runandload()</code> method:<div class="mediaobject"><img src="../images/00030.jpeg" alt="How to do it..." class="calibre11"/></div><p class="calibre15"> </p></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Creating an elevation hillshade">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec180" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The <code class="literal">Hillshade</code> algorithm <a id="id272" class="calibre1"/>simulates a light source over an elevation dataset to make it more visually<a id="id273" class="calibre1"/> appealing. Most of the time, the only variables in the algorithm you need to alter are the z-factor, azimuth, and altitude to get different effects. However, if the resulting image doesn't look right, you may need to alter the scale. According to the GDAL documentation, if your DEM is in degrees, you should set a scale of <code class="literal">111120</code>, and if it is in meters, you should set a scale of <code class="literal">370400</code>. This dataset covers a small area <a id="id274" class="calibre1"/>such that a scale of 1 is sufficient. For more information on these values, see the gdaldem documentation at <a class="calibre1" href="http://www.gdal.org/gdaldem.html">http://www.gdal.org/gdaldem.html</a>.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Creating vector contours from elevation data"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec65" class="calibre1"/>Creating vector contours from elevation data</h1></div></div></div><p class="calibre9">Contours <a id="id275" class="calibre1"/>provides an effective visualization of terrain data by tracing a line along the same elevation to form a loop at set intervals in the dataset. Similar to the hillshade capability in QGIS, the <span class="strong"><strong class="calibre2">Contour</strong></span> tool is provided by GDAL both as a menu option under the <span class="strong"><strong class="calibre2">Raster</strong></span> menu in the <span class="strong"><strong class="calibre2">Extraction category</strong></span> as well as a Processing Toolbox algorithm.</p></div>

<div class="book" title="Creating vector contours from elevation data">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec181" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">This recipe uses the DEM from <a class="calibre1" href="https://geospatialpython.googlecode.com/files/dem.zip">https://geospatialpython.googlecode.com/files/dem.zip</a>, which is used in the other recipes as well.</p><p class="calibre9">Unzip the file named <code class="literal">dem.asc</code> and place it in your <code class="literal">/qgis_data/rasters</code> directory.</p></div></div>

<div class="book" title="Creating vector contours from elevation data">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec182" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">In this recipe, we will load and validate the DEM layer, add it to the map, and then produce <a id="id276" class="calibre1"/>and load the contour vector as a layer. To do this, we need to perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Start QGIS.</li><li class="listitem" value="2">From the <span class="strong"><strong class="calibre2">Plugins</strong></span> menu, select <span class="strong"><strong class="calibre2">Python Console</strong></span>.</li><li class="listitem" value="3">Import the <code class="literal">processing</code> module.<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">import processing</strong></span>
</pre></div></li><li class="listitem" value="4">Load and validate the DEM:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">rasterLyr = QgsRasterLayer("/qgis_data/rasters/dem.asc", "DEM")</strong></span>
<span class="strong"><strong class="calibre2">rasterLyr.isValid()</strong></span>
</pre></div></li><li class="listitem" value="5">Add the DEM to the map using the <code class="literal">mapLayerRegistry</code> method:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayers([rasterLyr])</strong></span>
</pre></div></li><li class="listitem" value="6">Run the contour algorithm and draw the results on top of the DEM layer, specifying the algorithm name, layer reference, interval between contour lines in map units, name of the vector data attribute field that will contain the elevation value, any extra parameters, and output filename:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">processing.runandload("gdalogr:contour", rasterLyr, 50.0, "Elv", None, "/qgis_data/rasters/contours.shp")</strong></span>
</pre></div></li><li class="listitem" value="7">Verify that the output in QGIS looks similar to the following screenshot:<div class="mediaobject"><img src="../images/00031.jpeg" alt="How to do it..." class="calibre11"/><div class="caption"><p class="calibre16">This recipe overlays the resulting elevation contours over the DEM as a way to convert elevation data into a vector data set.</p></div></div><p class="calibre15"> </p></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Creating vector contours from elevation data">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec183" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The <a id="id277" class="calibre1"/>contour algorithm creates a vector dataset, that is a shapefile. The layer attribute table contains the elevation values for each line. Depending on the resolution of the elevation dataset, you may need to change the contour interval to stop the contours from becoming too crowded or too sparse at your desired map resolution. Usually, autogenerated contours like this are a starting point, and you must manually edit the result to make it visually appealing. You may want to smoothen lines or remove unnecessary small loops.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Sampling a raster dataset using a regular grid"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec66" class="calibre1"/>Sampling a raster dataset using a regular grid</h1></div></div></div><p class="calibre9">Sometimes, you <a id="id278" class="calibre1"/>need to sample a raster dataset at <a id="id279" class="calibre1"/>regular intervals in order to provide summary statistics or for quality assurance purposes on the raster data. A common way to accomplish this regular sampling is to create a point grid over the dataset, query the grid at each point, and assign the results as attributes to those points. In this recipe, we will perform this type of sampling over a satellite image. QGIS has a tool to perform this <a id="id280" class="calibre1"/>operation called regular <a id="id281" class="calibre1"/>points, which is in the <span class="strong"><strong class="calibre2">Vector</strong></span> menu under <span class="strong"><strong class="calibre2">Research Tools</strong></span>. However, there is no tool in the QGIS API to perform this operation programmatically. However, we can implement this algorithm directly using Python's <code class="literal">numpy</code>
 module.</p></div>

<div class="book" title="Sampling a raster dataset using a regular grid">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec184" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">In this recipe, we will use the previously used SatImage raster, available at <a class="calibre1" href="https://geospatialpython.googlecode.com/files/SatImage.zip">https://geospatialpython.googlecode.com/files/SatImage.zip</a>.</p><p class="calibre9">Place this raster in your <code class="literal">/qgis_data/rasters</code> directory.</p></div></div>

<div class="book" title="Sampling a raster dataset using a regular grid">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec185" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">The order of operation for this recipe is to load the raster layer, create a vector layer in memory, add points at regular intervals, sample the raster layer at these points, and then add the sampling data as attributes for each point. To do this, we need to perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Start QGIS.</li><li class="listitem" value="2">From the <span class="strong"><strong class="calibre2">Plugins</strong></span> menu, select <span class="strong"><strong class="calibre2">Python Console</strong></span>.</li><li class="listitem" value="3">We will need to import the <code class="literal">numpy</code> module, which is included with QGIS, as well as the Qt core module:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">import numpy</strong></span>
<span class="strong"><strong class="calibre2">from PyQt4.QtCore import *</strong></span>
</pre></div></li><li class="listitem" value="4">Now, we will create a <code class="literal">spacing</code> variable to control how far apart the points are in map units:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">spacing = .1</strong></span>
</pre></div></li><li class="listitem" value="5">Next, we will create an <code class="literal">inset</code> variable to determine how close to the edge of the image the points start, in map units:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">inset = .04</strong></span>
</pre></div></li><li class="listitem" value="6">Now, we load and validate the raster layer:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">rasterLyr = QgsRasterLayer("/qgis_data/rasters/satimage.tif", "Sat Image")</strong></span>
<span class="strong"><strong class="calibre2">rasterLyr.isValid()</strong></span>
</pre></div></li><li class="listitem" value="7">Next, we collect the coordinate reference system and extent from the raster layer in order to transfer it to the point layer:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">rpr = rasterLyr.dataProvider()</strong></span>
<span class="strong"><strong class="calibre2">epsg = rasterLyr.crs().postgisSrid()</strong></span>
<span class="strong"><strong class="calibre2">ext = rasterLyr.extent()</strong></span>
</pre></div></li><li class="listitem" value="8">Now, we create an in-memory vector point layer, which won't be written to disk:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">vectorLyr = QgsVectorLayer('Point?crs=epsg:%s' % epsg, 'Grid' , "memory")</strong></span>
</pre></div></li><li class="listitem" value="9">In <a id="id282" class="calibre1"/>order to add points to the<a id="id283" class="calibre1"/> vector layer, we must access its data provider:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">vpr = vectorLyr.dataProvider()</strong></span>
<span class="strong"><strong class="calibre2">qd = QVariant.Double</strong></span>
</pre></div></li><li class="listitem" value="10">Next, we create the attributes' fields to store the raster data samples:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">vpr.addAttributes([QgsField("Red", qd), QgsField("Green", qd), QgsField("Blue", qd)])</strong></span>
<span class="strong"><strong class="calibre2">vectorLyr.updateFields()</strong></span>
</pre></div></li><li class="listitem" value="11">We use the <code class="literal">inset</code> variable to set up the layer's extents inside the raster layer:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">xmin = ext.xMinimum() + inset</strong></span>
<span class="strong"><strong class="calibre2">xmax = ext.xMaximum()</strong></span>
<span class="strong"><strong class="calibre2">ymin = ext.yMinimum() + inset</strong></span>
<span class="strong"><strong class="calibre2">ymax = ext.yMaximum() – inset</strong></span>
</pre></div></li><li class="listitem" value="12">Now, we use the <code class="literal">numpy</code> module to efficiently create the coordinates of the points in our regular grid:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">pts = [(x,y) for x in (i for i in numpy.arange(xmin, xmax, spacing)) for y in (j for j in numpy.arange(ymin, ymax, spacing))]</strong></span>
</pre></div></li><li class="listitem" value="13">Then, we create a list to store the point features we will create:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">feats = []</strong></span>
</pre></div></li><li class="listitem" value="14">In one loop, we create the point features, query the raster, and then update the attribute table. We store the points in a list for now:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">for x,y in pts:</strong></span>
<span class="strong"><strong class="calibre2">  f = QgsFeature()</strong></span>
<span class="strong"><strong class="calibre2">  f.initAttributes(3)</strong></span>
<span class="strong"><strong class="calibre2">  p = QgsPoint(x,y)</strong></span>
<span class="strong"><strong class="calibre2">  qry = rasterLyr.dataProvider().identify(p, QgsRaster.IdentifyFormatValue)</strong></span>
<span class="strong"><strong class="calibre2">  r = qry.results()</strong></span>
<span class="strong"><strong class="calibre2">  f.setAttribute(0, r[1])</strong></span>
<span class="strong"><strong class="calibre2">  f.setAttribute(1, r[2])</strong></span>
<span class="strong"><strong class="calibre2">  f.setAttribute(2, r[3])</strong></span>
<span class="strong"><strong class="calibre2">  f.setGeometry(QgsGeometry.fromPoint(p))</strong></span>
<span class="strong"><strong class="calibre2">  feats.append(f)</strong></span>
</pre></div></li><li class="listitem" value="15">Next, we <a id="id284" class="calibre1"/>pass the list of points to <a id="id285" class="calibre1"/>the data provider of the points layer:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">vpr.addFeatures(feats)</strong></span>
</pre></div></li><li class="listitem" value="16">Now, we update the layer's extents:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">vectorLyr.updateExtents()</strong></span>
</pre></div></li><li class="listitem" value="17">Then, we add both the raster and vector layers to the map in the list. The last item in the list is on top:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayers([rasterLyr,vectoryr])</strong></span>
</pre></div></li><li class="listitem" value="18">Finally, we refresh the map to see the result:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">canvas = iface.mapCanvas()</strong></span>
<span class="strong"><strong class="calibre2">canvas.setExtent(rasterLyr.extent())</strong></span>
<span class="strong"><strong class="calibre2">canvas.refresh()</strong></span>
</pre></div></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Sampling a raster dataset using a regular grid">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec186" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The following screenshot shows the end result, with one of the points in the grid identified using the <span class="strong"><strong class="calibre2">Identify Features</strong></span> map tool. The results dialog shows the raster values of the selected point:</p><div class="mediaobject"><img src="../images/00032.jpeg" alt="How it works..." class="calibre11"/><div class="caption"><p class="calibre16">When you use the QGIS Identification Tool to click on one of the points, the results dialog shows the extracted Red, Green, and Blue values from the image.</p></div></div><p class="calibre12"> </p><p class="calibre9">Using memory<a id="id286" class="calibre1"/> layers in QGIS is an easy way to<a id="id287" class="calibre1"/> perform quick, one-off operations without the overhead of creating files on disk. Memory layers also tend to be fast if your machine has the resources to spare.</p></div></div>

<div class="book" title="Sampling a raster dataset using a regular grid">
<div class="book" title="There's more..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch04lvl2sec187" class="calibre1"/>There's more...</h2></div></div></div><p class="calibre9">In this example, we used a regular grid, but we could have just as easily modified the numpy-based algorithm to create a random points grid, which in some cases is more useful. However, the Processing Toolbox also has a simple algorithm for random points called <code class="literal">grass:v.random</code>.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Adding elevation data to line vertices using a digital elevation model"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec67" class="calibre1"/>Adding elevation data to line vertices using a digital elevation model</h1></div></div></div><p class="calibre9">If you have a<a id="id288" class="calibre1"/> transportation route through some terrain, it is useful to know the elevation profile of that route. This operation can be accomplished using the points that make up the line along the route to query a DEM and to assign elevation values to that point. In this recipe, we'll do exactly that.</p></div>

<div class="book" title="Adding elevation data to line vertices using a digital elevation model">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec188" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You will need an elevation grid and a route. You can download this dataset from <a class="calibre1" href="https://geospatialpython.googlecode.com/svn/path.zip">https://geospatialpython.googlecode.com/svn/path.zip</a>.</p><p class="calibre9">Unzip the <code class="literal">path</code> directory containing a shapefile and the elevation grid. Place the whole path directory in your <code class="literal">qgis_data/rasters</code> directory.</p></div></div>

<div class="book" title="Adding elevation data to line vertices using a digital elevation model">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec189" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will <a id="id289" class="calibre1"/>need two processing algorithms to complete this recipe. We will load the raster and vector layers, convert the line feature to points, and then use these points to query the raster. The resulting point dataset will serve as the elevation profile for the route. To do this, we need to perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Start QGIS.</li><li class="listitem" value="2">From the <span class="strong"><strong class="calibre2">Plugins</strong></span> menu, select <span class="strong"><strong class="calibre2">Python Console</strong></span>.</li><li class="listitem" value="3">Import the <code class="literal">processing</code> module:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">import processing</strong></span>
</pre></div></li><li class="listitem" value="4">Set up the filenames as variables, so they can be used throughout the script:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">pth = "/qgis_data/rasters/path/"</strong></span>
<span class="strong"><strong class="calibre2">rasterPth = pth + "elevation.asc"</strong></span>
<span class="strong"><strong class="calibre2">vectorPth = pth + "path.shp"</strong></span>
<span class="strong"><strong class="calibre2">pointsPth = pth + "points.shp"</strong></span>
<span class="strong"><strong class="calibre2">elvPointsPth = pth + "elvPoints.shp"</strong></span>
</pre></div></li><li class="listitem" value="5">Load and validate the source layers:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">rasterLyr = QgsRasterLayer(rasterPth, "Elevation")</strong></span>
<span class="strong"><strong class="calibre2">rasterLyr.isValid()</strong></span>
<span class="strong"><strong class="calibre2">vectorLyr = QgsVectorLayer(vectorPth, "Path", "ogr")</strong></span>
<span class="strong"><strong class="calibre2">vectorLyr.isValid()</strong></span>
</pre></div></li><li class="listitem" value="6">Add the layers to the map:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayers([vectorLyr, rasterLyr])</strong></span>
</pre></div></li><li class="listitem" value="7">Create an intermediate point dataset from the line using a SAGA algorithm in the Processing Toolbox:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">processing.runalg("saga:convertlinestopoints", vectorLyr, False, 1, pointsPth)</strong></span>
</pre></div></li><li class="listitem" value="8">Finally, use another processing algorithm from SAGA to create the final dataset with the grid values assigned to the points:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">processing.runandload("saga:addgridvaluestopoints", pointsPth, rasterPth, 0, elvPointsPth)</strong></span>
</pre></div></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Adding elevation data to line vertices using a digital elevation model">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec190" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The<a id="id290" class="calibre1"/> following image saved from QGIS shows the DEM, route line, and elevation points with elevation labels, all displayed on the map, with some styling:</p><div class="mediaobject"><img src="../images/00033.jpeg" alt="How it works..." class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">It is necessary to convert the lines to points because a line feature can only have one set of attributes. You can perform the same operation with a polygon as well.</p></div></div>

<div class="book" title="Adding elevation data to line vertices using a digital elevation model">
<div class="book" title="There's more..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch04lvl2sec191" class="calibre1"/>There's more...</h2></div></div></div><p class="calibre9">Instead of running two algorithms, we can build a processing script that combines these two algorithms into one interface and then added it to the toolbox. In the Processing Toolbox, there is a category called <span class="strong"><strong class="calibre2">Scripts</strong></span>, which has a tool called <span class="strong"><strong class="calibre2">Create new script</strong></span>. Double-clicking on this tool will bring up an editor that lets you build your own processing scripts. Depending on your platform, you may need to install or configure SAGA to use <a id="id291" class="calibre1"/>this algorithm. You can find binary packages for Linux at <a class="calibre1" href="http://sourceforge.net/p/saga-gis/wiki/Binary%20Packages/">http://sourceforge.net/p/saga-gis/wiki/Binary%20Packages/</a>.</p><p class="calibre9">Also, on Linux, you may need to change the following option:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">In the <span class="strong"><strong class="calibre2">Processing</strong></span> menu, select <span class="strong"><strong class="calibre2">Options…</strong></span>.</li><li class="listitem" value="2">In the <span class="strong"><strong class="calibre2">Options</strong></span> dialog, open the <span class="strong"><strong class="calibre2">Providers</strong></span> tree menu and then open the <span class="strong"><strong class="calibre2">Saga</strong></span> tree menu.</li><li class="listitem" value="3">Uncheck <span class="strong"><strong class="calibre2">the Use 2.0.8 syntax</strong></span> option.</li></ol><div class="calibre14"/></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Creating a common extent for rasters"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec68" class="calibre1"/>Creating a common extent for rasters</h1></div></div></div><p class="calibre9">If you are<a id="id292" class="calibre1"/> trying to compare two raster images, it is<a id="id293" class="calibre1"/> important that they have the same extent and resolution. Most software packages won't even allow you to attempt to compare images if they don't have the same extent. Sometimes, you have images that overlap but do not share a common extent and/or are of different resolutions. The following illustration is an example of this scenario:</p><div class="mediaobject"><img src="../images/00034.jpeg" alt="Creating a common extent for rasters" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">In this recipe, we'll take two overlapping images and give them the same extents.</p></div>

<div class="book" title="Creating a common extent for rasters">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec192" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You can <a id="id294" class="calibre1"/>download two overlapping images from <a class="calibre1" href="https://geospatialpython.googlecode.com/svn/overlap.zip">https://geospatialpython.googlecode.com/svn/overlap.zip</a>.</p><p class="calibre9">Unzip the images and place them in your <code class="literal">/qgis_data/rasters</code> directory.</p><p class="calibre9">You will also<a id="id295" class="calibre1"/> need to download the following processing script from:</p><p class="calibre9">
<a class="calibre1" href="https://geospatialpython.googlecode.com/svn/unify_extents.zip">https://geospatialpython.googlecode.com/svn/unify_extents.zip</a>
</p><p class="calibre9">Unzip the contents and place the scripts in your <code class="literal">\.qgis2\processing\scripts</code> directory, found within your user directory. For example, on a Windows 64-bit machine, the directory will be <code class="literal">C:\Users\&lt;username&gt;\.qgis2\processing\scripts</code>, replacing <code class="literal">&lt;username&gt;</code> with your username.</p><p class="calibre9">Make sure you restart QGIS. This script is a modified version of the one created by Yury Ryabov on his blog at <a class="calibre1" href="http://ssrebelious.blogspot.com/2014/01/unifying-extent-and-resolution-of.html">http://ssrebelious.blogspot.com/2014/01/unifying-extent-and-resolution-of.html</a>.</p><p class="calibre9">The original <a id="id296" class="calibre1"/>script used a confirmation dialog that <a id="id297" class="calibre1"/>required user interaction. The modified script adheres to the Processing Toolbox programming conventions and allows you to use it programmatically as well.</p></div></div>

<div class="book" title="Creating a common extent for rasters">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec193" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">The only step in QGIS is to run the newly created processing command. To do this, we need to perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Start QGIS.</li><li class="listitem" value="2">From the <span class="strong"><strong class="calibre2">Plugins</strong></span> menu, select <span class="strong"><strong class="calibre2">Python Console</strong></span>.</li><li class="listitem" value="3">Import the <code class="literal">processing</code> module:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">import processing</strong></span>
</pre></div></li><li class="listitem" value="4">Run the newly added processing algorithm, specifying the algorithm name, path to the two images, an optional no data value, an output directory for the unified images, and a Boolean flag to load the images into QGIS:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">processing.runalg("script:unifyextentandresolution","/qgis_data/rasters/Image2.tif;/qgis_data/rasters/Image1.tif",-9999,"/qgis_data/rasters",True)</strong></span>
</pre></div></li><li class="listitem" value="5">In the QGIS table of contents, verify that you have two images named:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">Image1_unified.tif</strong></span>
<span class="strong"><strong class="calibre2">Image2_unfied.tif</strong></span>
</pre></div></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Creating a common extent for rasters">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec194" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The following screenshot shows the common extent for the rasters, by setting the transparency of <code class="literal">Image1_unified.tif</code>
 to the pixel <code class="literal">0,0,0</code>:</p><div class="mediaobject"><img src="../images/00035.jpeg" alt="How it works..." class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">If you don't <a id="id298" class="calibre1"/>use the transparency setting, you will see that both<a id="id299" class="calibre1"/> images fill the non-overlapping areas with no data within the minimum bounding box of both extents. The no data values, specified as <code class="literal">-9999</code>, will be ignored by other processing algorithms.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Resampling raster resolution"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec69" class="calibre1"/>Resampling raster resolution</h1></div></div></div><p class="calibre9">Resampling<a id="id300" class="calibre1"/> an image allows you to change the current<a id="id301" class="calibre1"/> resolution of an image to a different resolution. Resampling to a lower resolution, also known as downsampling, requires you to remove<a id="id302" class="calibre1"/> pixels from the image while maintaining the geospatial referencing integrity of the dataset. In the QGIS Processing Toolbox, the <code class="literal">gdalogr:warpproject</code> algorithm is used, which is the same as the algorithm used for reprojection.</p></div>

<div class="book" title="Resampling raster resolution">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec195" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">We will again use the SatImage raster available at <a class="calibre1" href="https://geospatialpython.googlecode.com/files/SatImage.zip">https://geospatialpython.googlecode.com/files/SatImage.zip</a>.</p><p class="calibre9">Place this raster in your <code class="literal">/qgis_data/rasters</code> directory.</p></div></div>

<div class="book" title="Resampling raster resolution">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec196" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">There's an<a id="id303" class="calibre1"/> extra step in this process, where we will get the current<a id="id304" class="calibre1"/> pixel resolution of the raster as a reference to calculate the new resolution and pass it to the algorithm. To do this, we need to perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Start QGIS.</li><li class="listitem" value="2">From the <span class="strong"><strong class="calibre2">Plugins</strong></span> menu, select <span class="strong"><strong class="calibre2">Python Console</strong></span>.</li><li class="listitem" value="3">Import the <code class="literal">processing</code> module:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">import processing</strong></span>
</pre></div></li><li class="listitem" value="4">Load and validate the raster layer:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">rasterLyr = QgsRasterLayer("/qgis_data/rasters/SatImage.tif", "Resample")</strong></span>
<span class="strong"><strong class="calibre2">rasterLyr.isValid()</strong></span>
</pre></div></li><li class="listitem" value="5">The algorithm requires projection information. We are not changing it, so just assign the current projection to a variable:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">epsg = rasterLyr.crs().postgisSrid()</strong></span>
<span class="strong"><strong class="calibre2">srs = "EPSG:%s" % epsg</strong></span>
</pre></div></li><li class="listitem" value="6">Get the current pixel's ground distance and multiply it by 2 to calculate half the ground resolution. We only use the X distance because in this case, it is identical to the Y distance:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">res = rasterLyr.rasterUnitsPerPixelX() * 2</strong></span>
</pre></div></li><li class="listitem" value="7">Run the resampling algorithm, specifying the algorithm name, layer reference, input and then output spatial reference system, desired resolution, resampling algorithm (<code class="literal">0</code> is the nearest neighbor), any additional parameters, <code class="literal">0</code> for output raster data type, and the output filename:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">processing.runalg("gdalogr:warpreproject", rasterLyr, srs, srs, res, 0, None, 0,  "/qgis_data/rasters/resampled.tif")</strong></span>
</pre></div></li><li class="listitem" value="8">Verify that the <code class="literal">resampled.tif</code> image was created in your <code class="literal">/qgis_data/rasters</code> directory.</li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Resampling raster resolution">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec197" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">It is counterintuitive at first to reduce the resolution by multiplying it. However, by increasing the spatial coverage of each pixel, it takes less pixels to cover the extent of the raster. You can easily compare the difference between the two in QGIS visually by loading both the images and zooming to an area with buildings or other detailed structures and then turning one layer off or on.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Counting the unique values in a raster"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec70" class="calibre1"/>Counting the unique values in a raster</h1></div></div></div><p class="calibre9">Remotely-sensed images are not just pictures; they are data. The value of the pixels has meaning<a id="id305" class="calibre1"/> that can be automatically analyzed by a computer. The<a id="id306" class="calibre1"/> ability to run statistical algorithms on a dataset is key to remote sensing. This recipe counts the number of unique combinations of pixels across multiple bands. A use case for this recipe will be to assess the results of image classification, which is a recipe that we'll cover later in this chapter. This recipe is in contrast to the typical histogram function, which totals the unique values and the frequency of each value per band.</p></div>

<div class="book" title="Counting the unique values in a raster">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec198" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">We will use the SatImage raster available at <a class="calibre1" href="https://geospatialpython.googlecode.com/files/SatImage.zip">https://geospatialpython.googlecode.com/files/SatImage.zip</a>.</p><p class="calibre9">Place this raster in your <code class="literal">/qgis_data/rasters</code> directory.</p></div></div>

<div class="book" title="Counting the unique values in a raster">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec199" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">This algorithm relies completely on the <code class="literal">numpy</code> module, which is included with PyQGIS. Numpy can be accessed through the GDAL package's <code class="literal">gdalnumeric</code> module. To do this, we need to perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Start QGIS.</li><li class="listitem" value="2">From the <span class="strong"><strong class="calibre2">Plugins </strong></span>menu, select <span class="strong"><strong class="calibre2">Python Console</strong></span>.</li><li class="listitem" value="3">First, we must import the bridge module called <code class="literal">gdalnumeric</code>, which connects GDAL to Numpy in order to perform an array math on geospatial images:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">import gdalnumeric</strong></span>
</pre></div></li><li class="listitem" value="4">Now, we will load our raster image directly into a multidimensional array:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">a = gdalnumeric.LoadFile("/qgis_data/rasters/satimage.tif")</strong></span>
</pre></div></li><li class="listitem" value="5">The following code counts the number of pixel combinations in the image:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">b = a.T.ravel()</strong></span>
<span class="strong"><strong class="calibre2">c=b.reshape((b.size/3,3))</strong></span>
<span class="strong"><strong class="calibre2">order = gdalnumeric.numpy.lexsort(c.T)</strong></span>
<span class="strong"><strong class="calibre2">c = c[order]</strong></span>
<span class="strong"><strong class="calibre2">diff = gdalnumeric.numpy.diff(c, axis=0)</strong></span>
<span class="strong"><strong class="calibre2">ui = gdalnumeric.numpy.ones(len(c), 'bool')</strong></span>
<span class="strong"><strong class="calibre2">ui[1:] = (diff != 0).any(axis=1)</strong></span>
<span class="strong"><strong class="calibre2">u = c[ui]</strong></span>
</pre></div></li><li class="listitem" value="6">Now, we can take a look at the size of the resulting one-dimensional array to get the unique values count:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">u.size</strong></span>
</pre></div></li></ol><div class="calibre14"/></div><p class="calibre9">Lastly, verify that the result is <code class="literal">16085631</code>.</p></div></div>

<div class="book" title="Counting the unique values in a raster">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec200" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The <code class="literal">numpy</code> module<a id="id307" class="calibre1"/> is an open source equivalent of the commercial package <code class="literal">Matlab</code>. You can learn more about Numpy at: <a class="calibre1" href="http://Numpy.org">http://Numpy.org</a>.</p><p class="calibre9">When you load an<a id="id308" class="calibre1"/> image using Numpy, it is loaded as a multidimensional array of numbers. Numpy allows you to do an array math on the entire array using operators and specialized functions, in the same way you would on variables containing a single numeric value.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Mosaicing rasters"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec71" class="calibre1"/>Mosaicing rasters</h1></div></div></div><p class="calibre9">Mosaicing rasters is<a id="id309" class="calibre1"/> the process of fusing multiple geospatial images with the same resolution and map projection into one raster. In this recipe, we'll combine two overlapping satellite images into a single dataset.</p></div>

<div class="book" title="Mosaicing rasters">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec201" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You will need to <a id="id310" class="calibre1"/>download the overlapping dataset from <a class="calibre1" href="https://geospatialpython.googlecode.com/svn/overlap.zip">https://geospatialpython.googlecode.com/svn/overlap.zip</a> if you haven't downloaded it from a previous recipe.</p><p class="calibre9">Place the two images in your <code class="literal">/qgis_data/rasters/</code> directory.</p></div></div>

<div class="book" title="Mosaicing rasters">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec202" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">This process is relatively straightforward and has a dedicated algorithm within the Processing Toolbox. Perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Start QGIS.</li><li class="listitem" value="2">From the <span class="strong"><strong class="calibre2">Plugins</strong></span> menu, select <span class="strong"><strong class="calibre2">Python Console</strong></span>.</li><li class="listitem" value="3">Run the gdalogr:merge algorithm, specifying the process name, two images, a boolean to use the pseudocolor palette from the first image, a boolean to stack each<a id="id311" class="calibre1"/> image into a separate band, and the output filename:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">processing.runalg("gdalogr:merge","C:/qgis_data/rasters/Image2.tif;C:/qgis_data/rasters/Image1.tif",False,False,"/qgis_data/rasters/merged.tif")</strong></span>
</pre></div></li><li class="listitem" value="4">Verify that the <code class="literal">merged.tif</code> image has been created and displays the two images as a single raster within QGIS.</li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Mosaicing rasters">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec203" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The <span class="strong"><strong class="calibre2">merge</strong></span> processing algorithm is a simplified version of the actual <code class="literal">gdal_merge</code> command-line <a id="id312" class="calibre1"/>utility. This algorithm is limited to the GDAL output and aggregates the extent of input rasters. It can only merge two rasters at a time. The gdal_merge tool has far more options, including additional output formats, the ability to merge more than two rasters at once, the ability to control the extent, and more. You can also use the GDAL API directly to take advantage of these features, but it will take far more code than what is used in this simple example.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Converting a TIFF image to a JPEG image"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec72" class="calibre1"/>Converting a TIFF image to a JPEG image</h1></div></div></div><p class="calibre9">Image <a id="id313" class="calibre1"/>format conversion is a part of nearly every<a id="id314" class="calibre1"/> geospatial project. Rasters come in dozens of different specialized formats, making conversion to a more common format a necessity. The GDAL utilities include a tool called <code class="literal">gdal_translate</code>
 specifically for format conversion. Unfortunately, the algorithm in the Processing Toolbox is limited in functionality. For format conversion, it is easier to use the core GDAL API.</p></div>

<div class="book" title="Converting a TIFF image to a JPEG image">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec204" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">We will use the SatImage raster available at <a class="calibre1" href="https://geospatialpython.googlecode.com/files/SatImage.zip">https://geospatialpython.googlecode.com/files/SatImage.zip</a>.</p><p class="calibre9">Place this raster in your <code class="literal">/qgis_data/rasters</code> directory.</p></div></div>

<div class="book" title="Converting a TIFF image to a JPEG image">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec205" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">In this recipe, we'll open a TIFFimage using GDAL and copy it to a new dataset as a JPEG2000 image, which allows you to use the common JPEG format while maintaining geospatial<a id="id315" class="calibre1"/> information. To do this, we need to<a id="id316" class="calibre1"/> perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Start QGIS.</li><li class="listitem" value="2">From the <span class="strong"><strong class="calibre2">Plugins</strong></span> menu, select <span class="strong"><strong class="calibre2">Python Console</strong></span>.</li><li class="listitem" value="3">Import the gdal module:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">from osgeo import gdal</strong></span>
</pre></div></li><li class="listitem" value="4">Get a GDAL driver for our desired format:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">drv = gdal.GetDriverByName("JP2OpenJPEG")</strong></span>
</pre></div></li><li class="listitem" value="5">Open the source image:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">src = gdal.Open("/qgis_data/rasters/satimage.tif")</strong></span>
</pre></div></li><li class="listitem" value="6">Copy the source dataset to the new format:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">tgt = drv.CreateCopy("/qgis_data/rasters/satimage.jp2", src)</strong></span>
</pre></div></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Converting a TIFF image to a JPEG image">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec206" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">For the straight format conversion of an image format, the core GDAL library is extremely fast and simple. GDAL supports the creation of over 60 raster formats and the reading of over 130 raster formats.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Creating pyramids for a raster"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec73" class="calibre1"/>Creating pyramids for a raster</h1></div></div></div><p class="calibre9">Pyramids, or<a id="id317" class="calibre1"/> overview images, sacrifice the disk space for map <a id="id318" class="calibre1"/>rendering speed by storing resampled, lower-resolution versions of images in the file alongside the full resolution image. Once you have finalized a raster, building pyramid overviews is a good idea.</p></div>

<div class="book" title="Creating pyramids for a raster">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec207" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">For this recipe, we will use a false-color image, that you can download from <a class="calibre1" href="https://geospatialpython.googlecode.com/files/FalseColor.zip">https://geospatialpython.googlecode.com/files/FalseColor.zip</a>.</p><p class="calibre9">Unzip this <code class="literal">TIF </code>file and place it in your <code class="literal">/qgis_data/rasters</code> directory.</p></div></div>

<div class="book" title="Creating pyramids for a raster">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec208" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">The Processing Toolbox has a dedicated algorithm for building pyramid images. Perform the following steps to create pyramids for a raster</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Start QGIS.</li><li class="listitem" value="2">From the <span class="strong"><strong class="calibre2">Plugins</strong></span> menu, select <span class="strong"><strong class="calibre2">Python Console</strong></span>.</li><li class="listitem" value="3">Import the <code class="literal">processing</code> module:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">import processing</strong></span>
</pre></div></li><li class="listitem" value="4">Run the <code class="literal">gdalogr:overviews</code> algorithm, specifying the process name, input image, overview levels, the option to remove existing overviews, resampling method (<code class="literal">0</code> is the nearest neighbor), and overview format (<code class="literal">1</code> is internal):<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">processing.runalg("gdalogr:overviews","/qgis_data/rasters/FalseColor.tif","2 4 8 16",True,0,1)</strong></span>
</pre></div></li><li class="listitem" value="5">Now, load the raster into QGIS by dragging and dropping it from the filesystem onto the map canvas.</li><li class="listitem" value="6">Double-click on the layer name in the map's legend to open the <span class="strong"><strong class="calibre2">Layer Properties</strong></span> dialog.</li><li class="listitem" value="7">In the <span class="strong"><strong class="calibre2">Layer Properties</strong></span> dialog, click on the <span class="strong"><strong class="calibre2">Pyramids</strong></span> tab and verify that the layer has multiple resolutions listed.</li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Creating pyramids for a raster">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec209" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The concept <a id="id319" class="calibre1"/>of overview images is quite simple. You resample the<a id="id320" class="calibre1"/> images several times, and then a viewer chooses the most appropriate, smallest file to load on the map, depending on scale. The overviews can be stored in the header of the file for certain formats or as an external file format. The level of overviews needed depends largely on the file size and resolution of your current image, but is really arbitrary. In this example, we double the scale by a factor of 2, which a is common practice. Most of the zoom tools in the applications will double the scale when you click to zoom in. The factor of 2 gives you enough zoom levels, so that you usually won't zoom to a level where there is no pyramid image. There is a point of diminishing returns if you create too many levels because pyramids take up additional disk space. Usually 4 to 5 levels is effective.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Converting a pixel location to a map coordinate"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec74" class="calibre1"/>Converting a pixel location to a map coordinate</h1></div></div></div><p class="calibre9">The ability to<a id="id321" class="calibre1"/> view rasters in a geospatial context relies on the conversion of pixel locations to coordinates on the ground. Sooner or later when you use Python to write geospatial programs, you'll have to perform this conversion yourself.</p></div>

<div class="book" title="Converting a pixel location to a map coordinate">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec210" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">We will use the SatImage raster available at:</p><p class="calibre9">
<a class="calibre1" href="https://geospatialpython.googlecode.com/files/SatImage.zip">https://geospatialpython.googlecode.com/files/SatImage.zip</a>
</p><p class="calibre9">Place this raster in your <code class="literal">/qgis_data/rasters</code> directory.</p></div></div>

<div class="book" title="Converting a pixel location to a map coordinate">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec211" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will use GDAL to extract the information needed to convert pixels to coordinates and then use<a id="id322" class="calibre1"/> pure Python to perform the calculation. We'll use the center pixel of the image as the location to convert.</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Start QGIS.</li><li class="listitem" value="2">From the <span class="strong"><strong class="calibre2">Plugins</strong></span> menu select <span class="strong"><strong class="calibre2">Python Console</strong></span></li><li class="listitem" value="3">We need to import the <code class="literal">gdal</code> module:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">from osgeo import gdal</strong></span>
</pre></div></li><li class="listitem" value="4">Then, we need to define the reusable function that does the conversion accepting a GDAL <code class="literal">GeoTransform</code> object containing the raster georeferencing information and the pixel's <span class="strong"><em class="calibre10">x</em></span>,<span class="strong"><em class="calibre10">y</em></span> values:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">def Pixel2world(geoMatrix, x, y):</strong></span>
<span class="strong"><strong class="calibre2">    ulX = geoMatrix[0]</strong></span>
<span class="strong"><strong class="calibre2">    ulY = geoMatrix[3]</strong></span>
<span class="strong"><strong class="calibre2">    xDist = geoMatrix[1]</strong></span>
<span class="strong"><strong class="calibre2">    yDist = geoMatrix[5]</strong></span>
<span class="strong"><strong class="calibre2">    coorX = (ulX + (x * xDist))</strong></span>
<span class="strong"><strong class="calibre2">    coorY = (ulY + (y * yDist))</strong></span>
<span class="strong"><strong class="calibre2">    return (coorX, coorY)</strong></span>
</pre></div></li><li class="listitem" value="5">Now, we'll open the image in GDAL<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">src = gdal.Open("/qgis_data/rasters/Satimage.tif")</strong></span>
</pre></div></li><li class="listitem" value="6">Next, get the <code class="literal">GeoTransform</code> object from the image:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">geoTrans = src.GetGeoTransform()</strong></span>
</pre></div></li><li class="listitem" value="7">Now, calculate the center pixel of the image:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">centerX = src.RasterXSize/2</strong></span>
<span class="strong"><strong class="calibre2">centerY = src.RasterYSize/2</strong></span>
</pre></div></li><li class="listitem" value="8">Finally, perform the conversion by calling our function:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">Pixel2world(geoTrans, centerX, centerY)</strong></span>
</pre></div></li><li class="listitem" value="9">Verify the coordinates returned are close to the following output:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">(-89.59486002580364, 30.510227817850406)</strong></span>
</pre></div></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Converting a pixel location to a map coordinate">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec212" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">Pixel conversion is just a scaling ratio between two planes, the image coordinate system and the Earth <a id="id323" class="calibre1"/>coordinate system. When dealing with large areas, this conversion can become a more complex projection because the curvature of the Earth comes into play. The GDAL website has a nice tutorial about the geotransform object at the following URL: <a class="calibre1" href="http://www.gdal.org/gdal_tutorial.html">http://www.gdal.org/gdal_tutorial.html</a>
</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Converting a map coordinate to a pixel location"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec75" class="calibre1"/>Converting a map coordinate to a pixel location</h1></div></div></div><p class="calibre9">When you<a id="id324" class="calibre1"/> receive a map coordinate as user input or from some other source, you must be able to convert it back to the appropriate pixel location on a raster.</p></div>

<div class="book" title="Converting a map coordinate to a pixel location">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec213" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">We will use the SatImage raster available at:</p><p class="calibre9">
<a class="calibre1" href="https://geospatialpython.googlecode.com/files/SatImage.zip">https://geospatialpython.googlecode.com/files/SatImage.zip</a>
</p><p class="calibre9">Place this raster in your <code class="literal">/qgis_data/rasters</code> directory.</p></div></div>

<div class="book" title="Converting a map coordinate to a pixel location">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec214" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">Similar to the previous recipe, we will define a function, extract the GDAL <code class="literal">GeoTransform</code> object from our raster, and use it for the conversion.</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Start QGIS.</li><li class="listitem" value="2">From the <span class="strong"><strong class="calibre2">Plugins</strong></span> menu select <span class="strong"><strong class="calibre2">Python Console</strong></span></li><li class="listitem" value="3">We need to import the gdal module:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">from osgeo import gdal</strong></span>
</pre></div></li><li class="listitem" value="4">Then, we need to define the reusable function that does the coordinate to pixel conversion. We get the GDAL <code class="literal">GeoTransform</code> object containing the raster georeferencing information and the map <span class="strong"><em class="calibre10">x</em></span>,<span class="strong"><em class="calibre10">y</em></span> coordinates:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">def world2Pixel(geoMatrix, x, y):</strong></span>
<span class="strong"><strong class="calibre2">  ulX = geoMatrix[0]</strong></span>
<span class="strong"><strong class="calibre2">  ulY = geoMatrix[3]</strong></span>
<span class="strong"><strong class="calibre2">  xDist = geoMatrix[1]</strong></span>
<span class="strong"><strong class="calibre2">  yDist = geoMatrix[5]</strong></span>
<span class="strong"><strong class="calibre2">  rtnX = geoMatrix[2]</strong></span>
<span class="strong"><strong class="calibre2">  rtnY = geoMatrix[4]</strong></span>
<span class="strong"><strong class="calibre2">  pixel = int((x - ulX) / xDist)</strong></span>
<span class="strong"><strong class="calibre2">  line = int((y - ulY) / yDist)</strong></span>
<span class="strong"><strong class="calibre2">  return (pixel, line)</strong></span>
</pre></div></li><li class="listitem" value="5">Next, we open the source image:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">src = gdal.Open("/qgis_data/rasters/satimage.tif")</strong></span>
</pre></div></li><li class="listitem" value="6">Now, get the GeoTransform object:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">geoTrans = src.GetGeoTransform()</strong></span>
</pre></div></li><li class="listitem" value="7">Finally, perform the conversion:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">world2Pixel(geoTrans, -89.59486002580364, 30.510227817850406)</strong></span>
</pre></div></li><li class="listitem" value="8">Verify your output is the following:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">(1296, 1346)</strong></span>
</pre></div></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Converting a map coordinate to a pixel location">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec215" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">This<a id="id325" class="calibre1"/> conversion is very reliable over small areas, but as the area of interest expands you must account for elevation as well, which requires a far more complex transformation depending on how an image was generated.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note07" class="calibre1"/>Note</h3><p class="calibre9">The following presentation from the University of Massachusetts does an excellent job of explain the challenges of georeferencing data:</p><p class="calibre9">
<a class="calibre1" href="http://courses.umass.edu/nrc592g-cschweik/pdfs/Class_3_Georeferencing_concepts.pdf">http://courses.umass.edu/nrc592g-cschweik/pdfs/Class_3_Georeferencing_concepts.pdf</a></p></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Creating a KML image overlay for a raster"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec76" class="calibre1"/>Creating a KML image overlay for a raster</h1></div></div></div><p class="calibre9">
<span class="strong"><strong class="calibre2">GoogleEarth</strong></span> is <a id="id326" class="calibre1"/>one of the most widely available geospatial viewers in<a id="id327" class="calibre1"/> existence. The XML data format used by GoogleEarth for<a id="id328" class="calibre1"/> geospatial data is called <span class="strong"><strong class="calibre2">KML</strong></span>. The <a id="id329" class="calibre1"/>Open Geospatial Consortium adopted KML as a data standard. Converting rasters into a <span class="strong"><strong class="calibre2">KML</strong></span> overlay compressed in a <span class="strong"><strong class="calibre2">KMZ</strong></span> archive file is a very popular way to make data available to end users who know how to use GoogleEarth.</p></div>

<div class="book" title="Creating a KML image overlay for a raster">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec216" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">We will use the SatImage raster again available at the following URL if you haven't downloaded it from previous recipes:</p><p class="calibre9">
<a class="calibre1" href="https://geospatialpython.googlecode.com/files/SatImage.zip">https://geospatialpython.googlecode.com/files/SatImage.zip</a>
</p><p class="calibre9">Place this raster in your <code class="literal">/qgis_data/rasters</code> directory.</p></div></div>

<div class="book" title="Creating a KML image overlay for a raster">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec217" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">In this recipe, we'll create a <span class="strong"><strong class="calibre2">KML</strong></span> document describing our image. Then we'll convert the image to a <span class="strong"><strong class="calibre2">JPEG</strong></span> in memory using GDAL's specialized virtual file system and write all of the contents<a id="id330" class="calibre1"/> directly to a <span class="strong"><strong class="calibre2">KMZ</strong></span> file using Python's <code class="literal">zipfile</code> module.</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Start QGIS.</li><li class="listitem" value="2">From the <span class="strong"><strong class="calibre2">Plugins</strong></span> menu select <span class="strong"><strong class="calibre2">Python Console</strong></span></li><li class="listitem" value="3">We <a id="id331" class="calibre1"/>need to import the <code class="literal">gdal</code> module as well as the Python <code class="literal">zipfile</code> module:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">from osgeo import gdal</strong></span>
<span class="strong"><strong class="calibre2">import zipfile</strong></span>
</pre></div></li><li class="listitem" value="4">Next, we'll open our satellite image in <code class="literal">gdal</code>:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">srcf = "/qgis_data/rasters/Satimage.tif"</strong></span>
</pre></div></li><li class="listitem" value="5">Now, we'll create a variable with our virtualized file name, using the GDAL virtual file naming convention beginning with <code class="literal">vismem</code>:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">vfn = "/vsimem/satimage.jpg"</strong></span>
</pre></div></li><li class="listitem" value="6">We create the JPEG gdal driver object for the output format:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">drv = gdal.GetDriverByName('JPEG')</strong></span>
</pre></div></li><li class="listitem" value="7">Now, we can open the source file:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">src = gdal.Open(srcf)</strong></span>
</pre></div></li><li class="listitem" value="8">Then, we can copy that source file to our virtual JPEG:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">tgt = drv.CreateCopy(vfn, src)</strong></span>
</pre></div></li><li class="listitem" value="9">Now, we are going to create a raster layer in QGIS for our raster, just for the benefit of it calculating the image's extent:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">rasterLyr = QgsRasterLayer(srcf, "SatImage")</strong></span>
</pre></div></li><li class="listitem" value="10">Next, we get the layer's extent:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">e = rasterLyr.extent()</strong></span>
</pre></div></li><li class="listitem" value="11">Next, we format our KML document template and insert the image extents:<div class="informalexample"><pre class="programlisting">kml = """&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;kml &gt;
  &lt;Document&gt;
    &lt;name&gt;QGIS KML Example&lt;/name&gt;
    &lt;GroundOverlay&gt;
        &lt;name&gt;SatImage&lt;/name&gt;
        &lt;drawOrder&gt;30&lt;/drawOrder&gt;
        &lt;Icon&gt;
          &lt;href&gt;SatImage.jpg&lt;/href&gt;
        &lt;/Icon&gt;
        &lt;LatLonBox&gt;
          &lt;north&gt;%s&lt;/north&gt;
          &lt;south&gt;%s&lt;/south&gt;
          &lt;east&gt;%s&lt;/east&gt;
          &lt;west&gt;%s&lt;/west&gt;
        &lt;/LatLonBox&gt;
    &lt;/GroundOverlay&gt;
  &lt;/Document&gt;
&lt;/kml&gt;""" %(e.yMaximum(), e.yMinimum(), e.xMaximum(), e.xMinimum())</pre></div></li><li class="listitem" value="12">Now, we<a id="id332" class="calibre1"/> open our virtual JPEG in GDAL and prepare it for reading:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">vsifile = gdal.VSIFOpenL(vfn,'r')</strong></span>
<span class="strong"><strong class="calibre2">gdal.VSIFSeekL(vsifile, 0, 2)</strong></span>
<span class="strong"><strong class="calibre2">vsileng = gdal.VSIFTellL(vsifile)</strong></span>
<span class="strong"><strong class="calibre2">gdal.VSIFSeekL(vsifile, 0, 0)</strong></span>
</pre></div></li><li class="listitem" value="13">Finally, we <a id="id333" class="calibre1"/>write our KML document and virtual JPEG into a zipped KMZ file:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">z = zipfile.ZipFile("/qgis_data/rasters/satimage.kmz", "w", zipfile.ZIP_DEFLATED)</strong></span>
<span class="strong"><strong class="calibre2">z.writestr("doc.kml", kml)</strong></span>
<span class="strong"><strong class="calibre2">z.writestr("SatImage.jpg", gdal.VSIFReadL(1, vsileng, vsifile))</strong></span>
<span class="strong"><strong class="calibre2">z.close()</strong></span>
</pre></div></li><li class="listitem" value="14">Now, open the KMZ file in GoogleEarth and verify it looks like the following screenshot:<div class="mediaobject"><img src="../images/00036.jpeg" alt="How to do it..." class="calibre11"/></div><p class="calibre15"> </p></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Creating a KML image overlay for a raster">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec218" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">KML is a<a id="id334" class="calibre1"/> straightforward XML format. There are entire libraries in Python<a id="id335" class="calibre1"/> dedicated to reading and writing it, but for a <a id="id336" class="calibre1"/>simple export to share an image or two, the PyQGIS console is more than adequate. While we run this script in the QGIS Python interpreter, it could be run outside of QGIS using just GDAL.</p></div></div>

<div class="book" title="Creating a KML image overlay for a raster">
<div class="book" title="There's more..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch04lvl2sec219" class="calibre1"/>There's more...</h2></div></div></div><p class="calibre9">The <span class="strong"><strong class="calibre2">Orfeo Toolbox</strong></span> has <a id="id337" class="calibre1"/>a processing algorithm called <code class="literal">otb:imagetokmzexport</code> which has a much more sophisticated KMZ export tool for images.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Classifying a raster"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec77" class="calibre1"/>Classifying a raster</h1></div></div></div><p class="calibre9">Image classification<a id="id338" class="calibre1"/> is one of the most complex aspects of remote sensing. While QGIS is able to color pixels based on values for visualization, it stops short of doing much classification. It does provide a Raster Calculator tool where you can perform arbitrary math formulas on an image, however it does not attempt to implement any common algorithms. The Orfeo Toolbox is dedicated purely to remote sensing and includes an automated classification algorithm called K-means clustering, which groups <a id="id339" class="calibre1"/>pixels into an arbitrary number of similar classes to create a new image. We can do a nice demonstration of image classification using this algorithm.</p></div>

<div class="book" title="Classifying a raster">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec220" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">For this recipe, we<a id="id340" class="calibre1"/> will use a false color image which you can download here:</p><p class="calibre9">
<a class="calibre1" href="https://geospatialpython.googlecode.com/files/FalseColor.zip">https://geospatialpython.googlecode.com/files/FalseColor.zip</a>
</p><p class="calibre9">Unzip this TIFF file and place it in your <code class="literal">/qgis_data/rasters</code> directory.</p></div></div>

<div class="book" title="Classifying a raster">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec221" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">All we need to do is run the algorithm on our input image. The important parameters are the second, third, sixth, and tenth parameters. They define the input image name, the amount of RAM to dedicate to the task, the number of classes, and the output name respectively.</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, import the <code class="literal">processing</code> module in the QGIS <span class="strong"><strong class="calibre2">Python Console</strong></span>:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">import processing</strong></span>
</pre></div></li><li class="listitem" value="2">Next, run the <code class="literal">otb</code> algorithm using the <code class="literal">processing.runandload()</code> method to display the output in QGIS:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">processing.runandload("otb:unsupervisedkmeansimageclassification","/qgis_data/rasters/FalseColor.tif",768,None,10000,3,1000,0.95,"/qgis_data/rasters/classify.tif",None)</strong></span>
</pre></div></li><li class="listitem" value="3">When the image loads in QGIS, double click the layer name in the <span class="strong"><strong class="calibre2">Table of Contents</strong></span>.</li><li class="listitem" value="4">In the <span class="strong"><strong class="calibre2">Layer Properties</strong></span> dialog, choose <span class="strong"><strong class="calibre2">Style</strong></span>.</li><li class="listitem" value="5">Change the <span class="strong"><strong class="calibre2">Render type</strong></span> menu to <span class="strong"><strong class="calibre2">Singleband pseudocolor</strong></span>.</li><li class="listitem" value="6">Change the <span class="strong"><strong class="calibre2">color map</strong></span> menu on the right to <span class="strong"><strong class="calibre2">Spectral</strong></span>.</li><li class="listitem" value="7">Click the <span class="strong"><strong class="calibre2">Classify</strong></span> button.</li><li class="listitem" value="8">Choose the <span class="strong"><strong class="calibre2">Ok</strong></span> button at the bottom of the window.</li><li class="listitem" value="9">Verify your image looks similar to the following image, except without the class labels:<div class="mediaobject"><img src="../images/00037.jpeg" alt="How to do it..." class="calibre11"/></div><p class="calibre15"> </p></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Classifying a raster">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec222" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">Keeping the <a id="id341" class="calibre1"/>class number low allows the automated classification algorithm to focus on the major features in the image and helps when us to achieve a very high level of accuracy determining overall land use. Additional automated classification would require supervised analysis with training data sets and more in-depth preparation. But the overall concept would remain the same. QGIS has a nice plugin for semi-automatic <a id="id342" class="calibre1"/>classification. You can learn more about it at the following URL:</p><p class="calibre9">
<a class="calibre1" href="https://plugins.qgis.org/plugins/SemiAutomaticClassificationPlugin/">https://plugins.qgis.org/plugins/SemiAutomaticClassificationPlugin/</a>
</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Converting a raster to a vector"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec78" class="calibre1"/>Converting a raster to a vector</h1></div></div></div><p class="calibre9">Raster datasets<a id="id343" class="calibre1"/> represent real-world features efficiently but<a id="id344" class="calibre1"/> can have limited usage for geospatial analysis. Once you have classified an image into a manageable data set, you can convert those raster classes into a vector data set for more sophisticated GIS analysis. GDAL has a function for this <a id="id345" class="calibre1"/>operation called <span class="strong"><strong class="calibre2">polygonize.</strong></span>
</p></div>

<div class="book" title="Converting a raster to a vector">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec223" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You will need to download the following classified raster and place it in your <code class="literal">/qgis_data/rasters</code> directory:</p><p class="calibre9">
<a class="calibre1" href="https://geospatialpython.googlecode.com/svn/landuse_bay.zip">https://geospatialpython.googlecode.com/svn/landuse_bay.zip</a>
</p></div></div>

<div class="book" title="Converting a raster to a vector">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec224" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">Normally, you <a id="id346" class="calibre1"/>would save the output of this recipe as a shapefile. We<a id="id347" class="calibre1"/> won't specify an output file name. The Processing Toolbox will assign it a temporary filename and return that filename. We'll simply load the temporary file into QGIS. The algorithm allows you to write to a shapefile by specifying it as the last parameter.</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">In the QGIS <span class="strong"><strong class="calibre2">Python Console</strong></span>, import the <code class="literal">processing</code> module:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">import processing</strong></span>
</pre></div></li><li class="listitem" value="2">Next, run the algorithm specifying the process name, input image, the field name for the class number, and optionally the output shapefile:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">processing.runalg("gdalogr:polygonize","C:/qgis_data/rasters/landuse_bay.tif","DN",None)</strong></span>
</pre></div></li><li class="listitem" value="3">You should get a vector layer with three classes, defined as polygons, denoting developed areas. In the sample image below, we have assigned unique colors to each class: developed area (darkest), water (midtones), and land (lightest color):<div class="mediaobject"><img src="../images/00038.jpeg" alt="How to do it..." class="calibre11"/></div><p class="calibre15"> </p></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Converting a raster to a vector">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec225" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">GDAL looks<a id="id348" class="calibre1"/> for clusters of pixels and creates polygons<a id="id349" class="calibre1"/> around them. It is important to have as few classes as possible. If there is too much variation in the pixels, then GDAL will create a polygon around each pixel in the image. You turn this recipe into a true analysis product by using the recipe in <a class="calibre1" title="Chapter 1. Automating QGIS" href="part0015_split_000.html#page">Chapter 1</a>, <span class="strong"><em class="calibre10">Calculating the Area of a Polygon</em></span> to quantify each class of land use.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Georeferencing a raster from control points"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec79" class="calibre1"/>Georeferencing a raster from control points</h1></div></div></div><p class="calibre9">Sometimes a<a id="id350" class="calibre1"/> raster that represents features on the earth is just an image with no georeferencing information. That is certainly the case with historical scanned maps. However, you can use a referenced data set of the same area to create tie points, or ground control points, and then use an algorithm to warp the image to fit the model of the earth. It is common for data collection systems to just store the <span class="strong"><strong class="calibre2">ground control points (GCP)</strong></span> along with the raster to keep the image in as raw a format as possible. Each change to an image holds the possibility of losing data. So <a id="id351" class="calibre1"/>georeferencing an image on demand is often the best approach.</p><p class="calibre9">In this recipe, we'll georeference a historical survey map of the Louisiana and Mississippi Gulf Coast from 1853. The control points were manually created with the QGIS Georeferencer<a id="id352" class="calibre1"/> plugin and saved to a standardized control point file.</p></div>

<div class="book" title="Georeferencing a raster from control points">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec226" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">Download the following zip file, unzip the contents, and put the <code class="literal">georef</code> directory in <code class="literal">/qgis_data/rasters</code>:</p><p class="calibre9">
<a class="calibre1" href="https://geospatialpython.googlecode.com/svn/georef.zip">https://geospatialpython.googlecode.com/svn/georef.zip</a>
</p></div></div>

<div class="book" title="Georeferencing a raster from control points">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec227" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will use a low-level module of the processing API to access some specialized GDAL utility functions.</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">In the QGIS <span class="strong"><strong class="calibre2">Python Console</strong></span>, import the <code class="literal">GdalUtils</code> module:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">from processing.algs.gdal.GdalUtils import GdalUtils</strong></span>
</pre></div></li><li class="listitem" value="2">Now, we will set up some path names for source and target data, which will be used multiple times:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">src = "/qgis_data/rasters/georef/1853survey.jpg"</strong></span>
<span class="strong"><strong class="calibre2">points = "/qgis_data/rasters/georef/1853Survey.points"</strong></span>
<span class="strong"><strong class="calibre2">trans = "/qgis_data/rasters/georef/1835survey_trans.tif"</strong></span>
<span class="strong"><strong class="calibre2">final = "/qgis_data/rasters/georef/1835survey_georef.tif"</strong></span>
</pre></div></li><li class="listitem" value="3">Next, we will open up our GCP file and read past the header line:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">gcp = open(points, "rb")</strong></span>
<span class="strong"><strong class="calibre2">hdr = gcp.readline()</strong></span>
</pre></div></li><li class="listitem" value="4">Then, we can begin building our first gdal utility command:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">command = ["gdal_translate"]</strong></span>
</pre></div></li><li class="listitem" value="5">Loop through the GCP file and append the points to the command arguments:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">for line in gcp:</strong></span>
<span class="strong"><strong class="calibre2">  x,y,col,row,e = line.split(",")</strong></span>
<span class="strong"><strong class="calibre2">  command.append("-gcp")</strong></span>
<span class="strong"><strong class="calibre2">  command.append("%s" % col)</strong></span>
<span class="strong"><strong class="calibre2">  command.append("%s" % abs(float(row)))</strong></span>
<span class="strong"><strong class="calibre2">  command.append("%s" % x)</strong></span>
<span class="strong"><strong class="calibre2">  command.append("%s" % y)</strong></span>
</pre></div></li><li class="listitem" value="6">Now, add the input and output file to the command:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">command.append(src)</strong></span>
<span class="strong"><strong class="calibre2">command.append(trans)</strong></span>
</pre></div></li><li class="listitem" value="7">Next, we can execute the first command:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">GdalUtils.runGdal(command, None)</strong></span>
</pre></div></li><li class="listitem" value="8">Next, we change the command to warp the image:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">command = ["gdalwarp"]</strong></span>
<span class="strong"><strong class="calibre2">command.extend(["-r", "near", "-order", "3", "-co", "COMPRESS=NONE", "-dstalpha"])</strong></span>
</pre></div></li><li class="listitem" value="9">Add the <a id="id353" class="calibre1"/>output of the last command as the input and use the final image path as the output:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">command.append(trans)</strong></span>
<span class="strong"><strong class="calibre2">command.append(final)</strong></span>
</pre></div></li><li class="listitem" value="10">Now, run the warp command to complete the task:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">GdalUtils.runGdal(command, None)</strong></span>
</pre></div></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Georeferencing a raster from control points">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec228" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The GdalUtils API exposes the underlying tools used by the Processing Toolbox algorithm, yet<a id="id354" class="calibre1"/> provides a robust cross-platform approach that is better than other traditional methods of accessing external programs from Python. If you pull the output image into QGIS and compare it to the USGS coastline shapefile, you can see the results are fairly accurate and could be improved with additional control points and referenced data. The number of GCPs required for a given image is a matter of trial and error. Adding more GCPs won't necessarily lead to better results. You can find out more about<a id="id355" class="calibre1"/> creating GCPs in the QGIS documentation:</p><p class="calibre9">
<a class="calibre1" href="http://docs.qgis.org/2.6/en/docs/user_manual/plugins/plugins_georeferencer.html">http://docs.qgis.org/2.6/en/docs/user_manual/plugins/plugins_georeferencer.html</a>
</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Clipping a raster using a shapefile"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec80" class="calibre1"/>Clipping a raster using a shapefile</h1></div></div></div><p class="calibre9">Sometimes<a id="id356" class="calibre1"/> you need to use a subset of an image which<a id="id357" class="calibre1"/> covers an area of interest for a project. In fact, areas of an image outside your area of interest can distract your audience from the idea you are trying to convey. Clipping a raster to a vector boundary allows you to only use the portions of the raster you need. It can also save processing time by eliminating areas outside your area of interest.</p></div>

<div class="book" title="Clipping a raster using a shapefile">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec229" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">We will use<a id="id358" class="calibre1"/> the SatImage raster again available at the following URL if you haven't downloaded it from previous recipes:</p><p class="calibre9">
<a class="calibre1" href="https://geospatialpython.googlecode.com/files/SatImage.zip">https://geospatialpython.googlecode.com/files/SatImage.zip</a>
</p><p class="calibre9">Place this raster in your <code class="literal">/qgis_data/rasters</code> directory.</p></div></div>

<div class="book" title="Clipping a raster using a shapefile">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec230" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">Clipping is a <a id="id359" class="calibre1"/>common operation and GDAL is well suited for it.</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, in the QGIS <span class="strong"><strong class="calibre2">Python Console</strong></span>, run import the processing module:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">import processing</strong></span>
</pre></div></li><li class="listitem" value="2">Next, run the processing command specifying the input image name as the second argument and the output image as the seventh argument:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">processing.runandload("gdalogr:cliprasterbymasklayer","/qgis_data/rasters/SatImage.tif","/qgis_data/hancock/hancock.shp","none",False,False,"","/qgis_data/rasters/clipped.tif")</strong></span>
</pre></div></li><li class="listitem" value="3">Verify your <code class="literal">output</code> raster looks like the following screenshot:<div class="mediaobject"><img src="../images/00039.jpeg" alt="How to do it..." class="calibre11"/></div><p class="calibre15"> </p></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Clipping a raster using a shapefile">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec231" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">GDAL<a id="id360" class="calibre1"/> creates a no data mask outside the shapefile<a id="id361" class="calibre1"/> boundary. To the extent of the original image remains the same, however you no longer visualize it and processing algorithms will ignore the no data values.</p></div></div></body></html>