<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-66"><a id="_idTextAnchor066" class="pcalibre calibre6 pcalibre1"/>5</h1>
<h1 id="_idParaDest-67" class="calibre5"><a id="_idTextAnchor067" class="pcalibre calibre6 pcalibre1"/>Ecological Data</h1>
<p class="calibre3">In this chapter, we’ll introduce some methods commonly used in ecological data collection and then explore graph-theoretic clustering methods that can parse out animal populations across monitored geographic areas. This is a very common problem within ecological research, as populations of animals migrate and overlap with other populations of animals. In addition, parsing out healthy and unhealthy ecosystems is a common survey task for conservation and urban planning. We’ll analyze two types of ecological data<a id="_idIndexMarker206" class="pcalibre calibre6 pcalibre1"/> with <strong class="bold">spectral clustering</strong> to find groups within snake capture count and ecological survey text data.</p>
<p class="calibre3">By the end of this chapter, you’ll understand how to apply spectral clustering to find groups on networks. You’ll also see how different implementations of spectral clustering can be formulated, with some algorithms scaling better to large networks than other algorithms.</p>
<p class="calibre3">Specifically, we will cover the following topics:</p>
<ul class="calibre10">
<li class="calibre11">Introduction to ecological data</li>
<li class="calibre11">Spectral graph tools</li>
</ul>
<p class="calibre3">Let’s get started with some background on ecological problems.</p>
<h1 id="_idParaDest-68" class="calibre5"><a id="_idTextAnchor068" class="pcalibre calibre6 pcalibre1"/>Technical requirements</h1>
<p class="calibre3">You will require Jupyter Notebook to run the practical examples in this chapter. </p>
<p class="calibre3">The code for this chapter is available here: <a href="https://github.com/PacktPublishing/Modern-Graph-Theory-Algorithms-with-Python" class="pcalibre calibre6 pcalibre1">https://github.com/PacktPublishing/Modern-Graph-Theory-Algorithms-with-Python</a></p>
<h1 id="_idParaDest-69" class="calibre5"><a id="_idTextAnchor069" class="pcalibre calibre6 pcalibre1"/>Introduction to ecological data</h1>
<p class="calibre3">Environmental <a id="_idIndexMarker207" class="pcalibre calibre6 pcalibre1"/>research plays a large role in conservation strategy, climate change monitoring, and farming practices. Data collected might include data on plant type distributions and densities, animal migration patterns, or extent of disease. For instance, farmers may wish to track crop disease across large farms to monitor potential threats to their annual yield from various crops. Conservationists may wish to track endangered animal populations as they migrate through a national park to deploy anti-poaching resources to areas with large native or migratory populations. Let’s first explore some data collection methods.</p>
<h2 id="_idParaDest-70" class="calibre7"><a id="_idTextAnchor070" class="pcalibre calibre6 pcalibre1"/>Exploring methods to track animal populations across geographies</h2>
<p class="calibre3">Animal populations <a id="_idIndexMarker208" class="pcalibre calibre6 pcalibre1"/>are frequently mobile, with seasonal changes, weather events, and human interactions driving the movement of animals from one geographic location to another. One of the largest mass migrations of animals occurs in the grasslands of East Africa, where millions of herd animals (such as wildebeests and zebras) trek from the Serengeti to Masai Mara back to the Serengeti each year as rains come and go (<em class="italic">Figure 5</em><em class="italic">.1</em>). Poaching not only harms animal populations but often fuels other illegal activities, creating problems locally and internationally; understanding migration patterns on the borders of protected areas can position resources to stem poaching:</p>
<div><div><img alt="Figure 5.1 – ﻿An illustration of a zebra herd as the rainy season begins" src="img/B21087_05_01.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.1 – An illustration of a zebra herd as the rainy season begins</p>
<p class="calibre3">There<a id="_idIndexMarker209" class="pcalibre calibre6 pcalibre1"/> are many ways to monitor a population’s movement across geographies. One way involves tagging animals with satellite tracking tags that upload location data for each tagged animal. This allows researchers to construct paths for each animal and aggregate results across tagged populations (which might include only one species or several species of interest). For instance, in the zebra herd, perhaps a conservation team has tagged 10 of <a id="_idIndexMarker210" class="pcalibre calibre6 pcalibre1"/>the zebras prior to the rainy season with tags that will track the zebras’ location each hour for a period of several weeks. While we would expect all 10 animals to follow the same general path from one park to the next, individuals may migrate at different paces, take slightly different routes, or stop for food and water in different locations. This data allows researchers to identify subpopulations within the herd whose behavior deviates from the herd’s majority.</p>
<p class="calibre3">Another common method to track animal populations across geographies is to use trap cameras hidden in locations that are likely to be frequented by species of interest (such as watering holes, clearings in forests, or healthy coral reefs). For instance, suppose public health officials have noticed an increase in king cobra bites in villages near the Atrai River in Bangladesh (<em class="italic">Figure 5</em><em class="italic">.2</em>) and would like to understand the local king cobra population to enact policies to prevent humans and cobras from interacting.</p>
<p class="calibre3">Perhaps work hours can be adjusted to keep agricultural workers from areas frequented by king cobras at certain times of day or seasons. Officials can set the trap cameras in areas where bites have become more common to capture images of cobras throughout the lifetime of the film used in the trap camera. Several cameras are set throughout the area of interest according to bite densities, and species of venomous snakes, including king cobras, are tracked by time of day, species, and number of individual snakes identified by each camera. Data then informs policies regarding population movement and snake control strategies to mitigate the threat to public safety.</p>
<div><div><img alt="Figure 5.2 – ﻿An illustration of king cobra in rural Bangladesh" src="img/B21087_05_02.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.2 – An illustration of king cobra in rural Bangladesh</p>
<h2 id="_idParaDest-71" class="calibre7"><a id="_idTextAnchor071" class="pcalibre calibre6 pcalibre1"/>Exploring methods to capture plant distributions and diseases</h2>
<p class="calibre3">Data capture <a id="_idIndexMarker211" class="pcalibre calibre6 pcalibre1"/>on plant distributions and diseases involves a different sort of approach, as plants generally are not moving across geographies. Manual data collection requires human discernment of plant species and diseases, which may be unreliable and will take long periods of time to capture meaningful data. However, autonomous vehicles and drones offer a way to capture images and videos of plants across wide geographic areas, which can be processed <a id="_idIndexMarker212" class="pcalibre calibre6 pcalibre1"/>with <strong class="bold">convolutional neural networks</strong> (<strong class="bold">CNNs</strong>) trained on plant image data of species native to the study area. For instance, Colombian farmers may want to identify instances of coffee rust early to avoid crop loss by running a coffee rust classifier CNN <a id="_idIndexMarker213" class="pcalibre calibre6 pcalibre1"/>on drone or rover data captured weekly across their regional farms (example shown in <em class="italic">Figure 5</em><em class="italic">.3</em>). Images showing potential coffee rust could trigger a system alert that provides a geographic location on the farm or plant identification number to farmers.</p>
<div><div><img alt="Figure 5.3 – ﻿An illustration of a coffee plant image to scan for coffee rust on a Colombian farm" src="img/B21087_05_03.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.3 – An illustration of a coffee plant image to scan for coffee rust on a Colombian farm</p>
<p class="calibre3">However, the manual documentation of plants can be a useful tool in studies of areas with potentially new plant species to identify through fieldwork. Much of the Congo and Amazon basins are relatively unexplored, and identifying potential new plant species may yield insights<a id="_idIndexMarker214" class="pcalibre calibre6 pcalibre1"/> into an important part of the ecosystem, possible medications to treat human diseases, or the identification of threats from an invasive species.</p>
<p class="calibre3">Invasive plants may threaten an ecosystem. New species may herald discoveries of new chemical compounds. Let’s consider a botanist doing fieldwork in the Amazon who comes across a new type of mushroom that she hasn’t seen before (<em class="italic">Figure 5</em><em class="italic">.4</em>). To confirm that this is a new mushroom species, our botanist would take photographs, collect a sample for genetic analysis, and log the ecosystem in which she encountered the mushroom.</p>
<div><div><img alt="Figure 5.4 – ﻿An illustration of a potentially new species of mushroom" src="img/B21087_05_04.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.4 – An illustration of a potentially new species of mushroom</p>
<p class="calibre3">All of these<a id="_idIndexMarker215" class="pcalibre calibre6 pcalibre1"/> data collection methods create spatial data, where some areas may or may not be physically located next to each other. Species found in groups of geographic areas that are far from each other likely correspond to distinct populations that will be impacted by different human and environmental factors. Treating this data as spatial data and applying a few tools from graph theory can help parse out subpopulations of interest within ecological data analytics.</p>
<p class="calibre3">In many cases, collecting<a id="_idIndexMarker216" class="pcalibre calibre6 pcalibre1"/> biological samples of plants or placing tracking tags on animals is not feasible. However, drones and other autonomous vehicles can snap pictures of flora and fauna in a region (<em class="italic">Figure 5</em><em class="italic">.5</em>), allowing researchers to identify species from the images through a special type of deep learning algorithm and build a network from the deep learning results.</p>
<div><div><img alt="Figure 5.5 – ﻿An illustration of a forest stream, from which flora can be identified through deep-learning algorithms" src="img/B21087_05_05.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.5 – An illustration of a forest stream, from which flora can be identified through deep-learning algorithms</p>
<p class="calibre3">Now that we know how to collect ecological data, let’s explore a few tools from graph theory that will<a id="_idIndexMarker217" class="pcalibre calibre6 pcalibre1"/> help us analyze ecological data that has been collected across different geographical regions.</p>
<h1 id="_idParaDest-72" class="calibre5"><a id="_idTextAnchor072" class="pcalibre calibre6 pcalibre1"/>Spectral graph tools</h1>
<p class="calibre3">The <strong class="bold">adjacency matrix</strong> and <strong class="bold">degree of vertices</strong> in <a id="_idIndexMarker218" class="pcalibre calibre6 pcalibre1"/>the adjacency matrix <a id="_idIndexMarker219" class="pcalibre calibre6 pcalibre1"/>contain information <a id="_idIndexMarker220" class="pcalibre calibre6 pcalibre1"/>about the connectivity of vertices within the network. For an undirected network, the <strong class="bold">Laplacian matrix</strong> of the network is found by subtracting the adjacency matrix <a id="_idIndexMarker221" class="pcalibre calibre6 pcalibre1"/>from the degree matrix (i.e., <em class="italic">L = D - A</em>, where <em class="italic">D</em> is the degree matrix and <em class="italic">A</em> is the adjacency matrix). This matrix contains information about many important properties of the network, including the number of connected components, the sparsest cut that can separate the network into separate components, and the strength of connection within the network overall.</p>
<p class="calibre3"><strong class="bold">Connectivity</strong> is an<a id="_idIndexMarker222" class="pcalibre calibre6 pcalibre1"/> important concept in graph theory. A <strong class="bold">connected network</strong> is <a id="_idIndexMarker223" class="pcalibre calibre6 pcalibre1"/>one in which there is a path between all pairs of vertices; a <strong class="bold">disconnected network</strong> is <a id="_idIndexMarker224" class="pcalibre calibre6 pcalibre1"/>one in which some vertices do not have paths to all other vertices. Connected networks can be separated by cutting edges; the <strong class="bold">minimum cut set</strong> is<a id="_idIndexMarker225" class="pcalibre calibre6 pcalibre1"/> the set of the fewest edges that need to be removed to separate a network into two pieces to disconnect a connected network. Not only do these values connect to theoretical results in graph theory related to spreading processes and other differential equations defined on the network, but this information also tells us about how to separate groups on the network.</p>
<p class="calibre3">To obtain this information, we need to perform a decomposition on the Laplacian matrix to obtain eigenvectors and eigenvalues (the network spectrum). Sometimes, we normalize the Laplacian matrix first; in spectral clustering, this is less of a necessity than when computing specific graph theoretic values from the spectrum. Then, we find the Laplacian matrix’s eigenvalues and eigenvectors. In practice, this is done through an algorithm rather than through linear algebra operations directly.</p>
<p class="calibre3">The second eigenvalue obtained from this process <a id="_idIndexMarker226" class="pcalibre calibre6 pcalibre1"/>corresponds to the <strong class="bold">Fiedler value</strong> (also termed <strong class="bold">algebraic connectivity</strong>); this <a id="_idIndexMarker227" class="pcalibre calibre6 pcalibre1"/>value calculates how many connected components exist in the network and relates to the robustness of the network. The corresponding eigenvector partitions the network into separate networks, thus providing a two-cluster solution to partitioning groups on the network. In spectral clustering, this process of partitioning a network into two separate networks can be repeated until a predefined stopping point is reached (such as a total number of clusters).</p>
<p class="calibre3">Spectral clustering<a id="_idIndexMarker228" class="pcalibre calibre6 pcalibre1"/> on spatial networks constructed from ecological data allows researchers to partition out areas in which animals migrate, distinguish populations that might be isolated, and catalog differences in vegetation type or crop disease. Let’s set up a simple example and explore different ways to compute spectral clustering.</p>
<h1 id="_idParaDest-73" class="calibre5"><a id="_idTextAnchor073" class="pcalibre calibre6 pcalibre1"/>Clustering ecological populations using spectral graph tools</h1>
<p class="calibre3">Consider a<a id="_idIndexMarker229" class="pcalibre calibre6 pcalibre1"/> researcher in Gabon hoping to understand the interconnectivity of Gaboon viper populations in a protected <a id="_idIndexMarker230" class="pcalibre calibre6 pcalibre1"/>area of Loango National Park (<em class="italic">Figure 5</em><em class="italic">.6</em>). Snakes are tagged in seven regions of the park (represented by a vertex), and their tags record their location for the next month. Snakes often will move between regions if their habitat overlaps with multiple regions. It’s possible that multiple populations of snakes exist, giving different territories for different populations of snakes. If the two regions share a regional population, then the two vertices corresponding to these regions will have an edge. If no snakes migrate between regions, two vertices will not share an edge and likely represent different populations. Isolated populations tend to be more vulnerable to climate change, poaching, and habitat loss; understanding species and individual population ranges is critical to conservation efforts.</p>
<div><div><img alt="Figure 5.6 – ﻿An illustration of a ﻿Gaboon viper on the forest floor" src="img/B21087_05_06.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.6 – An illustration of a Gaboon viper on the forest floor</p>
<p class="calibre3">Let’s create <a id="_idIndexMarker231" class="pcalibre calibre6 pcalibre1"/>some data on our<a id="_idIndexMarker232" class="pcalibre calibre6 pcalibre1"/> snake population movements with <code>Script 5.1</code>:</p>
<pre class="source-code">
#create snake area network adjacency matrix
import numpy as np
import networkx as nx
np.random.seed(0)
adj_mat = [[1,1,1,0,0,0,1],
           [1,1,1,0,0,0,0],
           [1,1,1,0,0,0,0],
           [0,0,0,1,1,1,0],
           [0,0,0,1,1,1,0],
           [0,0,0,1,1,1,1],
           [1,0,0,0,0,1,1]]
adj_mat = np.array(adj_mat)</pre> <p class="calibre3">In practice, geographic <a id="_idIndexMarker233" class="pcalibre calibre6 pcalibre1"/>regions rarely share borders with all other regions in a dataset. <code>Script 5.1</code> spatial weighting component (weights total) to our adjacency matrix of snake overlap (<code>adj_mat</code>) to derive a weighted adjacency matrix (<code>adj_mat_w</code>):</p>
<pre class="source-code">
#create spatial weight matrix
weights_total = [[1,1,1,0,0,0,1],
           [1,1,1,0,0,0,0],
           [1,1,1,0,0,0,0],
           [0,0,0,1,1,1,1],
           [0,0,0,1,1,1,1],
           [0,0,0,1,1,1,1],
           [1,0,0,1,1,1,1]]
weights_total = np.array(weights_total)
adj_mat_w=np.multiply(adj_mat,weights_total)</pre> <p class="calibre3">We can create and explore our degree matrix, as well as our Laplacian matrix (subtracting the adjacency matrix from the degree matrix). Let’s add this information to <code>Script 5.1</code>:</p>
<pre class="source-code">
#explore degree and Laplacian matrices
degree_matrix=np.diag(adj_mat_w.sum(axis=1))
laplacian_matrix=degree_matrix-adj_mat_w
print(degree_matrix)
print(laplacian_matrix)</pre> <p class="calibre3">The degree<a id="_idIndexMarker237" class="pcalibre calibre6 pcalibre1"/> matrix encodes the number of vertices connected to a given vertex and serves as a basic measure of<a id="_idIndexMarker238" class="pcalibre calibre6 pcalibre1"/> centrality. Hubs have high degree scores, while more isolated regions might have a degree of zero or one. Our network of snake population overlap has similar degree centrality measures across the entire network:</p>
<pre class="source-code">
[[4 0 0 0 0 0 0]
 [0 3 0 0 0 0 0]
 [0 0 3 0 0 0 0]
 [0 0 0 3 0 0 0]
 [0 0 0 0 3 0 0]
 [0 0 0 0 0 4 0]
 [0 0 0 0 0 0 3]]</pre> <p class="calibre3">Let’s now look at the Laplacian matrix, which encodes the connectivity information we’ll use in our spectral decomposition and clustering:</p>
<pre class="source-code">
[[ 3 -1 -1  0  0  0 -1]
 [-1  2 -1  0  0  0  0]
 [-1 -1  2  0  0  0  0]
 [ 0  0  0  2 -1 -1  0]
 [ 0  0  0 -1  2 -1  0]
 [ 0  0  0 -1 -1  3 -1]
 [-1  0  0  0  0 -1  2]]</pre> <p class="calibre3">There are multiple ways we can compute the Fielder vector to get our spectral clustering results. We’ll go through two ways to compute this with Python. You may need to replace <code>nx.from_numpy_matrix</code> with <code>nx.from_numpy_array</code>, depending on your version of NetworkX. Depending on the size of the problem, it may be easier<a id="_idIndexMarker239" class="pcalibre calibre6 pcalibre1"/> to use a linear algebra solver similar to the one we added to Script 5.1:</p>
<pre class="source-code">
#define Fiedler vector and obtain clustering
G = nx.from_numpy_matrix(adj_mat_w)
ev = nx.linalg.algebraicconnectivity.fiedler_vector(G)
labels = [0 if v &lt; 0 else 1 for v in ev]
labels
nx.draw(G,with_labels=True, node_color=labels)</pre> <p class="calibre3">This<a id="_idIndexMarker240" class="pcalibre calibre6 pcalibre1"/> shows two distinct snake populations that converge to the sixth region of our Loango National Park sampling area (along with snakes staying in the exact same area, noted by loops), as shown in <em class="italic">Figure 5</em><em class="italic">.7</em>:</p>
<div><div><img alt="Figure 5.7 – Spectral clustering of snake populations" src="img/B21087_05_07.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.7 – Spectral clustering of snake populations</p>
<p class="calibre3">Scikit-learn <a id="_idIndexMarker241" class="pcalibre calibre6 pcalibre1"/>provides a spectral <a id="_idIndexMarker242" class="pcalibre calibre6 pcalibre1"/>clustering package, which we provide as an alternative calculation method by adding to <code>Script 5.1</code>. If you encounter a warning message on Windows, don’t be alarmed; it is not an error. Let’s add to <code>Script </code><code>5.1</code> now:</p>
<pre class="source-code">
#perform spectral clustering with sklearn
from sklearn.cluster import SpectralClustering
from sklearn import metrics
sc = SpectralClustering(2, affinity='precomputed', n_init=100)
sp_clust=sc.fit(adj_mat_w)
sc_labels=sp_clust.labels_
nx.draw(G,with_labels=True, node_color=sc_labels)</pre> <p class="calibre3">As expected, the<a id="_idIndexMarker243" class="pcalibre calibre6 pcalibre1"/> scikit-learn <a id="_idIndexMarker244" class="pcalibre calibre6 pcalibre1"/>package produces the same partitioning of the network (<em class="italic">Figure 5</em><em class="italic">.8</em>) as our linear algebra approach:</p>
<div><div><img alt="Figure 5.8 – Scikit-learn spectral clustering of snake populations" src="img/B21087_05_08.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.8 – Scikit-learn spectral clustering of snake populations</p>
<p class="calibre3">Spectral clustering is not limited to network data or ecological data. Any numeric dataset can be clustered using spectral clustering. In image and text analytics, we often don’t have<a id="_idIndexMarker245" class="pcalibre calibre6 pcalibre1"/> many instances of pre-labeled data, and manually annotating data is time consuming and can miss important classes in the dataset if they don’t happen to be in a small sample for someone to score manually. Spectral clustering allows us to embed data through<a id="_idIndexMarker246" class="pcalibre calibre6 pcalibre1"/> tools in these fields, create a network based on nearest neighbors, and apply spectral clustering to obtain labels for a<a id="_idIndexMarker247" class="pcalibre calibre6 pcalibre1"/> dataset that can then be used to train a classification algorithm. This process is termed <strong class="bold">semi-supervised learning</strong>, and real-world data science in natural language processing and image analytics often relies on this methodology to build classification models from datasets. Let’s see this in action by considering a text-based ecological dataset.</p>
<h2 id="_idParaDest-74" class="calibre7"><a id="_idTextAnchor074" class="pcalibre calibre6 pcalibre1"/>Spectral clustering on text notes</h2>
<p class="calibre3">Let’s consider<a id="_idIndexMarker248" class="pcalibre calibre6 pcalibre1"/> a dataset of ecological notes, including five healthy and five unhealthy local parks. While these notes are not as extensive <a id="_idIndexMarker249" class="pcalibre calibre6 pcalibre1"/>as a full ecological survey, they should demonstrate how to create a semi-supervised learning pipeline to classify ecosystem health. Here is one example of a healthy ecosystem in the notes:</p>
<pre class="source-code">
"Mangrove ecosystem. Numerous butterflies, lizards, and insects. Gumbolimbo trees. Soggy soil.', 'Tropical pines. Scat shows raccoon and coyote populations here. Recent controlled burn."</pre> <p class="calibre3">Here is an example of an unhealthy ecosystem in the dataset:</p>
<pre class="source-code">
"Small grass area. Some saplings. Gravel paths. Many cars parked in non-parking zones. Lots of run-off."</pre> <p class="calibre3">While we could annotate these notes ourselves, we’ll use spectral clustering to see how semi-supervised learning can be used to generate training data labels for much larger datasets where annotation might be unfeasible or unreliable. First, we’ll import our data with <code>Script 5.2</code>:</p>
<pre class="source-code">
#set up needed packages
import pandas as pd
import numpy as np
import os
#you may need to install sentence_transformers
#if the package is not already in your environment
#!pip install sentence_transformers
from sentence_transformers import SentenceTransformer
#import first network's data
File ="C:/users/njfar/OneDrive/Desktop/SC_Notes.csv"
pwd = os.getcwd()
os.chdir(os.path.dirname(File))
mydata = pd.read_csv(os.path.basename(File),encoding='latin1')</pre> <p class="calibre3">To<a id="_idIndexMarker250" class="pcalibre calibre6 pcalibre1"/> embed our data, we’ll use a <code>Script 5.2</code>:</p>
<pre class="source-code">
#prepare data
mydata['Notes']=mydata['Notes'].fillna(value=".")
#strip to text for input into BERT model
text_list=list(mydata.Notes)
#get BERT--768 vectors;
#note: you will need enough memory to load the transformer model
sbert_model1 = SentenceTransformer('all-mpnet-base-v2')
#encode data with BERT
encoded_text1=sbert_model1.encode(text_list)</pre> <p class="calibre3">Now that we <a id="_idIndexMarker254" class="pcalibre calibre6 pcalibre1"/>have embedded our data, we can create our nearest neighbors graph. Since we have such a small sample size, we’ll consider a point’s three nearest neighbors by adding to <code>Script 5.2</code>:</p>
<pre class="source-code">
#make nearest neighbors graph
from sklearn.neighbors import kneighbors_graph
n_adj = kneighbors_graph(encoded_text1, n_neighbors=3).toarray()</pre> <p class="calibre3">Now <a id="_idIndexMarker255" class="pcalibre calibre6 pcalibre1"/>we’re ready to run our spectral clustering and examine how our data clusters in this algorithm. Let’s add to <code>Script 5.2</code> to see this in action:</p>
<pre class="source-code">
#run spectral clustering
from sklearn.cluster import SpectralClustering
from sklearn import metrics
sc = SpectralClustering(2, affinity='precomputed', n_init=100)
sp_clust=sc.fit(n_adj)
sc_labels=sp_clust.labels_
print(sc_labels)</pre> <p class="calibre3">From our printed labels, we can see that ecosystems <code>3</code>, <code>7</code>, <code>8</code>, and <code>10</code> form one cluster, while ecosystems <code>1</code>, <code>2</code>, <code>4</code>, <code>5</code>, <code>6</code>, <code>7</code>, and <code>9</code> form the other. Let’s look at our sample of notes to see how well this method found differences in tone or theme by adding to <code>Script 5.2</code>:</p>
<pre class="source-code">
#examine notes
print(text_list)</pre> <p class="calibre3">We can <a id="_idIndexMarker256" class="pcalibre calibre6 pcalibre1"/>see that notes <code>3</code>, <code>4</code>, <code>7</code>, <code>8</code>, and <code>10</code> are unhealthy <a id="_idIndexMarker257" class="pcalibre calibre6 pcalibre1"/>ecosystems compared to the rest of our sample. Spectral clustering doesn’t seem to find all of these differences, but it’s possible that another type of text embedding would distinguish tone better than the one we selected. It’s also possible that fewer neighbors or a larger sample size would provide better results. However, we do find four of our five unhealthy ecosystems through our spectral clustering algorithm. A human reviewing results would not have to switch many labels (20%) to generate correct training labels for this data to be used to train a classification model. The second column of our dataset includes correct tone classification labels. Let’s convert our BERT embeddings to a DataFrame by adding to <code>Script 5.2</code>:</p>
<pre class="source-code">
#create training dataset for supervised learning
#turn BERT embedding into array
BERT_array1=np.array([x for x in encoded_text1])
#convert to dataframes
BERT_df1=pd.DataFrame(BERT_array1)</pre> <p class="calibre3">Now, let’s split our data into training and test sets (80% and 20% splits, respectively), create a <em class="italic">k</em>-nearest neighbors classifier (which classifies points according to the labels of their two nearest neighbors with <em class="italic">k</em> = 2), and measure the test set error by adding to <code>Script 5.2</code>:</p>
<pre class="source-code">
#create KNN classifier and test accuracy
from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import train_test_split
#get predictors and outcome
BERT_df1['Type']=mydata['Type']
df_train, df_test = train_test_split(BERT_df1,test_size=0.2, random_state=0)
X = df_train.iloc[:,0:767]
y = df_train.iloc[:,768]
X_test = df_test.iloc[:,0:767]
y_test = df_test.iloc[:,768]
#create KNN classifier and print accuracy
eu=KNeighborsClassifier(n_neighbors=2,metric='euclidean')
eu.fit(X,y)
print(eu.score(X_test,y_test))</pre> <p class="calibre3">Our <a id="_idIndexMarker258" class="pcalibre calibre6 pcalibre1"/>split yields an accuracy of 100%, suggesting <a id="_idIndexMarker259" class="pcalibre calibre6 pcalibre1"/>no misclassification of ecosystem types. Yours may vary given seeds and random number generators on your machine. However, this approach seems to work well for this dataset. Our pipeline of processing text data via embeddings, deriving a good start to label creation via spectral clustering, and then creating a classifier model yielded a high-accuracy classification system for our dataset.</p>
<h1 id="_idParaDest-75" class="calibre5"><a id="_idTextAnchor075" class="pcalibre calibre6 pcalibre1"/>Summary</h1>
<p class="calibre3">In this chapter, we learned how to collect ecological data for a variety of data science problems. After a brief introduction to the theory of spectral clustering, we showed how spectral clustering could parse out different animal populations through our Gaboon viper distribution example. Finally, we explored spectral clustering of nearest neighbor networks that can be used in semi-supervised learning pipelines through an ecosystem note data example. In <a href="B21087_06.xhtml#_idTextAnchor078" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 6</em></a>, we'll introduce centrality measurements and use them to find tipping points in stock pricing.</p>
<h1 id="_idParaDest-76" class="calibre5"><a id="_idTextAnchor076" class="pcalibre calibre6 pcalibre1"/>References</h1>
<p class="calibre3">Angelici, F. M., Effah, C., Inyang, M. A., &amp; Luiselli, L. (2000). <em class="italic">A preliminary radiotracking study of movements, activity patterns and habitat use of free-ranging Gaboon vipers, Bitis gabonica</em>. <em class="italic">Revue d’Ecologie, Terre et Vie</em>, <em class="italic">55</em>(1), 45-55.</p>
<p class="calibre3">Corrales, D. C., Figueroa, A., Ledezma, A., &amp; Corrales, J. C. (2015). <em class="italic">An empirical multi-classifier for coffee rust detection in Colombian crops</em>. In <em class="italic">Computational Science and Its Applications--ICCSA 2015: 15th International Conference, Banff, AB, Canada, June 22-25, 2015, Proceedings, Part I 15</em> (pp. 60-74). Springer International Publishing.</p>
<p class="calibre3">Froese, G. Z., Ebang Mbélé, A., Beirne, C., Atsame, L., Bayossa, C., Bazza, B., ... &amp; Poulsen, J. R. (2022). <em class="italic">Coupling paraecology and hunter GPS self</em>‐<em class="italic">follows to quantify village bushmeat hunting dynamics across the landscape scale</em>. <em class="italic">African Journal of Ecology</em>, <em class="italic">60</em> (2), 229-249.</p>
<p class="calibre3">Mutombo, F. K. (2012). <em class="italic">Long-range interactions in </em><em class="italic">complex networks</em>.</p>
<p class="calibre3">Ng, A., Jordan, M., &amp; Weiss, Y. (2001). <em class="italic">On spectral clustering: Analysis and an algorithm</em>. <em class="italic">Advances in neural information processing </em><em class="italic">systems</em>, <em class="italic">14</em>.</p>
<p class="calibre3">Nunez‐Mir, G. C., Iannone III, B. V., Pijanowski, B. C., Kong, N., &amp; Fei, S. (2016). <em class="italic">Automated content analysis: addressing the big literature challenge in ecology and evolution</em>. <em class="italic">Methods in Ecology and Evolution</em>, <em class="italic">7</em> (11), 1262-1272.</p>
<p class="calibre3">Qi, X., Fuller, E., Wu, Q., Wu, Y., &amp; Zhang, C. Q. (2012). <em class="italic">Laplacian centrality: A new centrality measure for weighted networks</em>. <em class="italic">Information Sciences</em>, <em class="italic">194</em>, 240-253.</p>
<p class="calibre3">Reimers, N., &amp; Gurevych, I. (2019). <em class="italic">Sentence-bert: Sentence embeddings using siamese bert-networks</em>. <em class="italic">arXiv </em><em class="italic">preprint arXiv:1908.10084</em>.</p>
<p class="calibre3">White, S., &amp; Smyth, P. (2005, April). <em class="italic">A spectral clustering approach to finding communities in graphs</em>. In <em class="italic">Proceedings of the 2005 SIAM international conference on data mining</em> (pp. 274-285). Society for industrial and applied Mathematics.</p>
</div>
</body></html>