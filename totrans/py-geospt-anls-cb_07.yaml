- en: Chapter 7. Raster Analysis
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 栅格分析
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Loading a DEM USGS ACSII CDED into PostGIS
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将USGS ACSII CDED格式的DEM加载到PostGIS中
- en: Creating an elevation profile
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建高程剖面
- en: Creating a hillshade raster from your DEM with ogr
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ogr从您的DEM创建阴影栅格
- en: Generating slope and aspect images from your DEM
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从您的DEM生成坡度和方位图像
- en: Merging rasters to generate a color relief map
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并栅格以生成彩色地形图
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Raster analysis works similar to vector analysis but the spatial relation is
    determined by the position of the raster cell. Most of our raster data is collected
    through diverse remote sensing techniques. In this chapter, the goals are quite
    simple and focused on working with and around a **digital elevation model** (**DEM**).
    The DEM we are using is from Whistler, BC, Canada, home to the 2010 Winter Olympics.
    Our DEM is in the form of the USGS ASCII CDED (`.dem`) format. The DEM is our
    source data that is used to derive several new raster datasets. As with other
    chapters, we will leverage Python as our glue to run scripts to enable a processing
    pipeline for raster data. The visualization of our data will play out with matplotlib
    along with the QGIS desktop GIS.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 栅格分析的工作方式与矢量分析类似，但空间关系由栅格单元格的位置决定。我们的大部分栅格数据都是通过多种遥感技术收集的。在本章中，目标非常简单且专注于处理和围绕**数字高程模型**（**DEM**）。我们使用的DEM来自加拿大不列颠哥伦比亚省惠斯勒，这里是2010年冬季奥运会的举办地。我们的DEM是以USGS
    ASCII CDED（`.dem`）格式存在的。DEM是我们用于派生几个新的栅格数据集的源数据。与其他章节一样，我们将利用Python作为粘合剂来运行脚本，以实现栅格数据的处理流程。我们的数据可视化将通过matplotlib和QGIS桌面GIS来完成。
- en: Loading a DEM USGS ACSII CDED into PostGIS
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将USGS ACSII CDED格式的DEM加载到PostGIS中
- en: Importing and working with a DEM in PostGIS is what this recipe is all about.
    We begin our journey with a text file that's full of points and is stored in the
    USGS ASCII CDED format (to read more about the details of this format, feel free
    to look at the documentation page at [http://www.gdal.org/frmt_usgsdem.html](http://www.gdal.org/frmt_usgsdem.html)).
    The ASCII format is well known and accepted by many desktop GIS applications as
    a direct data source. Feel free to simply open up your ASCII file with QGIS to
    view the files and see the resulting raster representation that it creates for
    you. Our task at hand is to import this DEM file into a PostGIS database, creating
    a new PostGIS raster dataset within PostGIS We perform this task by using a command-line
    tool called `raster2pgsql`, which is installed along with your PostGIS installation.
    The `raster2pgsql` tool is located on Windows under `C:\Program Files\PostgreSQL\9.3\bin\`
    if you are running PostgreSQL 9.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 导入和处理PostGIS中的DEM是本菜谱的主要内容。我们的旅程从一个充满点且以USGS ASCII CDED格式存储的文本文件开始（要了解更多关于此格式的详细信息，请自由查看[http://www.gdal.org/frmt_usgsdem.html](http://www.gdal.org/frmt_usgsdem.html)的文档页面）。ASCII格式是众所周知且被许多桌面GIS应用程序作为直接数据源所接受的。您可以自由地使用QGIS打开您的ASCII文件来查看文件，并查看它为您创建的栅格表示。我们当前的任务是将此DEM文件导入PostGIS数据库，在PostGIS中创建一个新的PostGIS栅格数据集。我们通过使用与PostGIS安装一起安装的命令行工具`raster2pgsql`来完成此任务。如果您正在运行PostgreSQL
    9，则`raster2pgsql`工具位于Windows上的`C:\Program Files\PostgreSQL\9.3\bin\`。
- en: Getting ready
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Your data is available in the `ch07/geodata/dem_3857.dem` folder. Feel free
    to get the original DEM from GeoGratis Canada, the area around Whistler Mountain,
    British Columbia, at [http://ftp2.cits.rncan.gc.ca/pub/geobase/official/cded/50k_dem/092/092j02.zip](http://ftp2.cits.rncan.gc.ca/pub/geobase/official/cded/50k_dem/092/092j02.zip).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您的数据位于`ch07/geodata/dem_3857.dem`文件夹中。您可以自由地从GeoGratis Canada获取原始DEM，这是不列颠哥伦比亚省惠斯勒山周围地区，请访问[http://ftp2.cits.rncan.gc.ca/pub/geobase/official/cded/50k_dem/092/092j02.zip](http://ftp2.cits.rncan.gc.ca/pub/geobase/official/cded/50k_dem/092/092j02.zip)。
- en: If you have not already created your `Postgresql` database in [Chapter 1](ch01.html
    "Chapter 1. Setting Up Your Geospatial Python Environment"), *Setting Up Your
    Geospatial Python Environment*, do so now and then continue with starting your
    virtual environment to run this script.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有在[第1章](ch01.html "第1章. 设置您的地理空间Python环境")中创建您的`Postgresql`数据库，*设置您的地理空间Python环境*，请现在创建，然后继续启动虚拟环境以运行此脚本。
- en: Also, make sure that the `raster2pgsql` command is available in your command
    prompt. If not, set up your environment variables on Windows or a sym link on
    your Linux machine.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请确保`raster2pgsql`命令在您的命令提示符中可用。如果不是，请在Windows上设置您的环境变量或在Linux机器上设置符号链接。
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s move on to the fun part that can be found in your `/ch07/code/ch07-01_dem2postgis.py`
    file:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到 `/ch07/code/ch07-01_dem2postgis.py` 文件中可以找到的有趣部分：
- en: 'The code found in the `/ch07/code/ch07-01_dem2postgis.py` file is as follows:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `/ch07/code/ch07-01_dem2postgis.py` 文件中找到的代码如下：
- en: '[PRE0]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Python, once again, is our glue that leverages the power of a command-line tool
    to do the dirty work. This time around, we use the Python subprocess module to
    call `raster2pgsql` the command-line tool. The `psycopg2` module then executes
    our `insert` statements.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Python，再次成为我们的粘合剂，利用命令行工具的力量来完成脏活。这次，我们使用 Python 的 subprocess 模块来调用 `raster2pgsql`
    命令行工具。然后 `psycopg2` 模块执行我们的 `insert` 语句。
- en: Starting from the top and working our way down, we see the database connection
    settings for `psycopg2`. The input path to our DEM is set as the `input_dem` variable.
    Then, we pack our command-line arguments into a single string called `command`.
    This is then run by subprocess. The individual command-line arguments are described
    in the code comments and further information and options can be found directly
    at [http://postgis.refractions.net/docs/using_raster.xml.html#RT_Raster_Loader](http://postgis.refractions.net/docs/using_raster.xml.html#RT_Raster_Loader).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶部开始，向下工作，我们看到 `psycopg2` 的数据库连接设置。我们的 DEM 输入路径设置为 `input_dem` 变量。然后，我们将命令行参数打包成一个名为
    `command` 的单个字符串。然后通过 subprocess 运行它。单个命令行参数在代码注释中描述，更多信息选项可以直接在 [http://postgis.refractions.net/docs/using_raster.xml.html#RT_Raster_Loader](http://postgis.refractions.net/docs/using_raster.xml.html#RT_Raster_Loader)
    找到。
- en: Now that the command is ready, we need to create a temporary file to store the
    generated SQL `insert` and `create` statements that the `raster2pgsql` command
    creates. Using the `with open()` syntax, we create our temporary file and then
    call the command using subprocess. We use `stdout` to specify where to write out
    this file. The `shell=True` argument comes with a *big* warning.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在命令已经准备好了，我们需要创建一个临时文件来存储 `raster2pgsql` 命令生成的 SQL `insert` 和 `create` 语句。使用
    `with open()` 语法，我们创建我们的临时文件，然后使用 subprocess 调用命令。我们使用 `stdout` 来指定输出文件的路径。`shell=True`
    参数附带一个 *重要* 警告。
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following is the `mention` warning taken from the Python documentation:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从 Python 文档中摘取的 `mention` 警告：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If all goes well, no exceptions should pop up, but if they do, we catch them
    using the standard Python `try` statement.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，不应该出现任何异常，但如果出现了，我们会使用标准的 Python `try` 语句来捕获它们。
- en: The last step is to open the newly created SQL file that's full of inserts and
    execute each line in the file using `psycopg2`. This populates our new table that
    has the name of the input DEM file.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是打开新创建的包含插入语句的 SQL 文件，并使用 `psycopg2` 执行文件中的每一行。这将填充我们新创建的名为输入 DEM 文件名称的表。
- en: Go ahead and open up **QGIS** | **2.8.x** and have a look at the raster you've
    just loaded into PostGIS.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 **QGIS** | **2.8.x** 并查看你刚刚加载到 PostGIS 中的栅格。
- en: Tip
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To open the raster in QGIS, I've found that you need to open the Database Manager
    application that comes with QGIS and connect to your Postgresql-PostGIS database
    and schema. Then, you will see the new raster, and you will need to right-click
    on it to add it to the canvas. This will finally add the raster to your QGIS project.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 QGIS 中打开栅格，我发现你需要打开 QGIS 附加的数据库管理器应用程序，连接到你的 Postgresql-PostGIS 数据库和模式。然后，你将看到新的栅格，你需要右键单击它将其添加到画布上。这将最终将栅格添加到你的
    QGIS 项目中。
- en: Creating an elevation profile
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建高程剖面
- en: Creating an elevation profile is very helpful when trying to visualize a 3D
    terrain cross-section or simply to see the elevation gain of a bike tour. In this
    example, we will define our own LineString geometry and extract the elevation
    values from the DEMs that are located every 20 m along our line. The analysis
    will generate a new CSV file that we can open in Libre Office Calc or Microsoft
    Excel to visualize the new data as a line chart.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 创建高程剖面在尝试可视化 3D 地形横截面或简单地查看自行车之旅的高程增益时非常有帮助。在这个例子中，我们将定义自己的 LineString 几何形状，并从位于我们沿线每
    20 米处的 DEM 中提取高程值。分析将生成一个新的 CSV 文件，我们可以在 Libre Office Calc 或 Microsoft Excel 中打开它，将新数据可视化为折线图。
- en: 'The 2D view of our line plotted on top of the elevation model as seen inside
    QGIS looks like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 QGIS 内部看到的高程模型上方的线（二维视图）看起来像这样：
- en: '![Creating an elevation profile](img/50790OS_07_01.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![创建高程剖面](img/50790OS_07_01.jpg)'
- en: Getting ready
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe calls for GDAL and Shapely. Make sure that you have them installed
    and are running them inside your python virtual environment that you set up earlier.
    To visualize your final CSV file, you must also install Libre Office Calc or some
    other charting software. The code to execute this is located at `/ch07/code/ch07-02_elev_profile.py`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方需要GDAL和Shapely。请确保您已安装它们，并且正在您之前设置的python虚拟环境中运行它们。为了可视化您的最终CSV文件，您还必须安装Libre
    Office Calc或其他图表软件。执行此操作的代码位于`/ch07/code/ch07-02_elev_profile.py`。
- en: How to do it...
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Running the script directly from your command line will generate your CSV,
    so read the code comments to see all the little details of what is going on in
    order to generate our new file as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 直接从您的命令行运行脚本将生成您的CSV文件，因此请阅读代码注释以了解生成我们新文件的所有细节，如下所示：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: There are two functions that are used to create our elevation profile. The first
    `get_elevation()`function returns a single elevation value per pixel for each
    band in a raster. This means that our input raster can contain multiple bands
    of data. Our second function will write our results to a CSV file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个函数用于创建我们的高程剖面。第一个`get_elevation()`函数返回每个波段中每个像素的单个高程值。这意味着我们的输入栅格可以包含多个数据波段。我们的第二个函数将我们的结果写入CSV文件。
- en: The `get_elevation()` function creates a list of elevation values; to achieve
    this, we need to extract some details from our input elevation raster. The *x*
    and *y* origin coordinates are used in combination with the raster pixel width
    and height to help find pixels in our raster. This information is then processed
    with our input *x* and *y* coordinates where we want the elevation value to be
    extracted.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_elevation()`函数创建一个高程值列表；为了实现这一点，我们需要从我们的输入高程栅格中提取一些细节。*x*和*y*起始坐标与栅格像素宽度和高度结合使用，以帮助我们找到我们的栅格中的像素。然后，这些信息与我们的输入*x*和*y*坐标一起处理，这些坐标是我们想要提取高程值的位置。'
- en: Next up, we loop through all the available bands in our raster and find the
    elevation value per band that's located at coordinates *x* and *y* from our input.
    The `ReadAsArray` GDAL function finds this location, and then all we need to do
    is get the first object of the second nested list array. This value is then appended
    to a new list of elevation values.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们遍历我们的栅格中所有可用的波段，并找到位于输入*x*和*y*坐标处的每个波段的高程值。GDAL的`ReadAsArray`函数找到这个位置，然后我们只需要获取第二个嵌套列表数组中的第一个对象。然后将此值附加到新的高程值列表中。
- en: To process our data, we define the input paths of our raster with the `os.path.realpath()`
    Python function that returns the full path to our input. GDAL is used to open
    our DEM raster and return the number of bands plus the *x* origin, *y* origin,
    pixel width, and pixel height information from our raster. This is located in
    the transform variable that's passed into our `get_elevation()` function.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理我们的数据，我们使用Python函数`os.path.realpath()`定义我们的栅格输入路径，该函数返回我们的输入的完整路径。GDAL用于打开我们的DEM栅格并从我们的栅格返回波段数、*x*起始点、*y*起始点、像素宽度和像素高度信息。这些信息位于传递给我们的`get_elevation()`函数的transform变量中。
- en: Working our way further, we define our input LineString. This LineString defines
    where the cross-section profile is going to be extracted. To process our data,
    we want to extract elevation values every 20 m along our input LineString. This
    is done in the `for` loop as we specify the range based on the LineString length
    and our input of 20 m. Using the Shapely `Interpolate` linear referencing function,
    we then create a point object every 20 m. These values are then stored in separate
    *x*, *y*, and *z* lists, which are then updated. The *z* list contains our list
    of new elevation points. Individual elevations are collected by specifying the
    first object in the list that's returned by our `get_elevation()` function.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步工作，我们定义我们的输入LineString。这个LineString定义了横截面剖面将要被提取的位置。为了处理我们的数据，我们希望在输入LineString上每20米提取一次高程值。这是在`for`循环中完成的，因为我们根据LineString的长度和我们的20米输入来指定范围。使用Shapely的`Interpolate`线性引用函数，我们然后每20米创建一个点对象。这些值随后存储在单独的*x*、*y*和*z*列表中，然后进行更新。*z*列表包含我们新的高程点列表。通过指定由我们的`get_elevation()`函数返回的列表中的第一个对象，可以收集个别的高程值。
- en: To put all this together in a CSV file, we use the Python `zip` function to
    combine the distance values with the elevation values. This creates the final
    two columns of data, showing us the distance from the starting point of our LineString
    on the *x*-axis and the elevation value on the *y*-axis.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要将这些数据汇总到一个CSV文件中，我们使用Python的`zip`函数将距离值与高程值合并。这创建了数据的最后两列，显示了从我们的LineString起点在*x*轴上的距离和*y*轴上的高程值。
- en: 'Visualizing the results is then easy in Libre Office Calc or Microsoft Excel.
    Go ahead and open up the output CSV file located in your `/ch07/geodata/output_profile.csv`
    folder and create a simple line chart:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在Libre Office Calc或Microsoft Excel中可视化结果非常简单。请打开位于您的`/ch07/geodata/output_profile.csv`文件夹中的输出CSV文件，并创建一个简单的折线图：
- en: '![How it works...](img/50790OS_07_02.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/50790OS_07_02.jpg)'
- en: Your resulting chart should look similar to what is shown in the preceding screenshot.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您生成的图表应类似于前一张截图所示。
- en: 'To plot the graph using Libre Office Calc, see the following plotting options:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Libre Office Calc绘制图表，请参阅以下绘图选项：
- en: '![How it works...](img/50790OS_07_03.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/50790OS_07_03.jpg)'
- en: Creating a hillshade raster from your DEM with ogr
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ogr从您的DEM创建阴影栅格
- en: Our DEM can be the basis for many types of derived raster datasets. One of these
    derivatives is the so called **hillshade** raster dataset. A hillshade raster
    represents a 2D view of 3D elevation data, assigning gray raster shades and giving
    them a 3D effect by enabling you to see the highs and lows of your terrain. The
    hillshade is a pure visualization helper to create a nice looking map and show
    relief on a 2D map.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的DEM可以作为许多类型派生栅格数据集的基础。其中之一是所谓的**阴影**栅格数据集。阴影栅格表示3D高程数据的2D视图，通过赋予灰度栅格阴影并使您能够看到地形的高低，从而产生3D效果。阴影是一个纯可视化辅助工具，用于创建外观良好的地图并在2D地图上显示地形。
- en: The pure Python solution to creating a hillshade is written by Roger Veciana
    i Rovira and you can find it at [http://geoexamples.blogspot.co.at/2014/03/shaded-relief-images-using-gdal-python.html](http://geoexamples.blogspot.co.at/2014/03/shaded-relief-images-using-gdal-python.html).
    There is also a nice solution by Joel Lawhead in *Chapter 7*, *Python and Elevation
    Data* of *Learning Geospatial Analysis with Python*. For those of you looking
    for a detailed description of the hillshade from ESRI, check this page out at
    [http://webhelp.esri.com/arcgisdesktop/9.3/index.cfm?TopicName=How%20Hillshade%20works](http://webhelp.esri.com/arcgisdesktop/9.3/index.cfm?TopicName=How%20Hillshade%20works).
    The `gdaldem` hillshade command-line tool will be used to generate the image to
    disk.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 创建阴影的纯Python解决方案由Roger Veciana i Rovira编写，您可以在[http://geoexamples.blogspot.co.at/2014/03/shaded-relief-images-using-gdal-python.html](http://geoexamples.blogspot.co.at/2014/03/shaded-relief-images-using-gdal-python.html)找到它。在《使用Python进行地理空间分析》的第七章“Python和高程数据”中，Joel
    Lawhead也提供了一个很好的解决方案。如果您想了解ESRI对阴影的详细描述，请查看这个页面：[http://webhelp.esri.com/arcgisdesktop/9.3/index.cfm?TopicName=How%20Hillshade%20works](http://webhelp.esri.com/arcgisdesktop/9.3/index.cfm?TopicName=How%20Hillshade%20works)。`gdaldem`阴影命令行工具将被用来生成磁盘上的图像。
- en: '![Creating a hillshade raster from your DEM with ogr](img/50790OS_07_04.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![从您的DEM创建阴影栅格的示例](img/50790OS_07_04.jpg)'
- en: Getting ready
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The prerequisites for this example require the `gdal` (`osgeo`), `numpy`, and
    `matplotlib` python libraries. Plus, you need to have downloaded the data folder
    for this book and have the `/ch07/geodata` folder available for read/write access.
    We are directly accessing our USGS ASCII CDED DEM `.dem` file on disk to render
    our hillshade, so be sure that you have this folder. The code execution will take
    place as usual from your `/ch07/code/` folder that runs the `ch07-03_shaded_relief.py`
    python file. So, for the impatient coders go ahead and give it a try at the command
    line as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的先决条件需要`gdal`（`osgeo`）、`numpy`和`matplotlib`Python库。此外，您需要下载本书的数据文件夹，并确保`/ch07/geodata`文件夹可用于读写访问。我们将直接访问磁盘上的USGS
    ASCII CDED DEM `.dem`文件以渲染阴影，因此请确保您有这个文件夹。代码执行将像往常一样在您的`/ch07/code/`文件夹中进行，该文件夹运行`ch07-03_shaded_relief.py`Python文件。因此，对于急于编码的开发者，请在命令行中按照以下方式尝试：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How to do it...
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Our Python script will run through a few mathematical operations and call the
    gdaldem command-line tool to generate our output using the following steps:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Python脚本将执行几个数学运算，并调用gdaldem命令行工具，按照以下步骤生成输出：
- en: 'The code contains some math that is not always easy to follow; the calculation
    of the greyscale values is determined by the elevation and its surrounding pixels,
    so read along:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码中包含一些不是总是容易跟上的数学；灰度值的计算取决于高程及其周围的像素，所以请继续阅读：
- en: '[PRE4]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The hillshade function calculates slope and aspect values for each cell as the
    input to calculate the shaded gray value. The `azimuth` variable defines the direction
    of light in degrees that hits our DEM. Inverting and playing with `azimuth` can
    lead to some effects, such as valleys looking like hills and hills looking like
    valleys. Our `shaded` variable holds the shade values as an array that we can
    plot with matplotlib.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影功能计算每个单元格的坡度和方向值，作为计算阴影灰度值的输入。`azimuth`变量定义了光线以度数击中我们的DEM的方向。反转和调整`azimuth`可以产生一些效果，例如山谷看起来像山，山看起来像山谷。我们的`shaded`变量持有阴影值作为数组，我们可以使用matplotlib进行绘图。
- en: Using the `gdaldem` command-line tool is definitely more robust and faster than
    the pure Python solution. With `gdaldem`, we create a new hillshade TIF file on
    disk that can open either with a local image viewer or can be drag-and-dropped
    into QGIS. QGIS will automatically stretch the gray values for you so that you
    will be able to see a nice representation of your hillshade.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`gdaldem`命令行工具肯定比纯Python解决方案更健壮且更快。使用`gdaldem`，我们在磁盘上创建一个新的阴影TIF文件，可以用本地图像查看器打开，也可以拖放到QGIS中。QGIS会自动拉伸灰度值，以便您可以看到您阴影的漂亮表示。
- en: Generating slope and aspect images from your DEM
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从您的DEM生成坡度和方向图像
- en: 'Slope maps are very useful, for example, to help biologists identify habitat
    zones. Certain species only live in areas that are very steep—mountain goats,
    for instance. The slope raster can then quick identify potential habitat areas.
    To visualize this, we use QGIS to display our slope map, which will look similar
    to the following image. The area in white indicates the steeper area and the darker
    the color, the flatter the terrain:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 坡度图非常有用，例如，可以帮助生物学家识别栖息地区域。某些物种只生活在非常陡峭的地区——例如高山山羊。坡度栅格可以快速识别潜在的栖息地区域。为了可视化这一点，我们使用QGIS显示我们的坡度图，它将类似于以下图像。白色区域表示较陡的区域，颜色越深，地形越平坦：
- en: '![Generating slope and aspect images from your DEM](img/50790OS_07_05.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![从您的DEM生成坡度和方向图像](img/50790OS_07_05.jpg)'
- en: 'Our aspect map displays the direction that the surface faces towards—such as
    north, east, south, and west—and this is expressed in degrees. In the screenshot,
    the orange area represents warm south-facing areas. The north-facing sides are
    cooler and are indicated in different hues of blues from our color spectrum. To
    achieve the colors, the QGIS singleband pseudocolor was classified into five continuous
    classes as shown in the following screenshot:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方向图显示了表面朝向的方向——例如北、东、南和西——这以度数表示。在屏幕截图中，橙色区域代表温暖的朝南区域。朝北的侧面较冷，并且用我们颜色光谱的不同色调表示。为了达到这些颜色，我们将QGIS单波段伪彩色分类为五个连续类别，如下面的屏幕截图所示：
- en: '![Generating slope and aspect images from your DEM](img/50790OS_07_06.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![从您的DEM生成坡度和方向图像](img/50790OS_07_06.jpg)'
- en: Getting ready
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Ensure that your `/ch07/geodata` folder is downloaded and the DEM `092j02_0200_demw.dem`
    file from Whistler, BC, Canada, is available.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您的`/ch07/geodata`文件夹已下载，并且加拿大不列颠哥伦比亚省惠斯勒的DEM文件`092j02_0200_demw.dem`可用。
- en: How to do it...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We utilize the `gdaldem` command-line tool to create our slope raster. You can
    tweak this recipe to batch generate slope images from several DEM rasters.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`gdaldem`命令行工具创建我们的坡度栅格。您可以调整此配方以批量生成多个DEM栅格的坡度图像。
- en: '[PRE5]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `gdaldem` command-line tool is our workhorse once again and all we need
    to do is pass along our DEM and specify an output file. Inside the code, you'll
    see the arguments passed include `-co compress=lzw`, which reduces the size of
    the image dramatically. Our `-p` option states that we want the results in a percentage
    slope followed by the input DEM and our output file.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`gdaldem`命令行工具再次成为我们的工作马，我们只需要传递我们的DEM并指定一个输出文件。在代码内部，您会看到传递的参数包括`-co compress=lzw`，这可以显著减小图像的大小。我们的`-p`选项表示我们希望结果以百分比坡度表示，然后是输入DEM和我们的输出文件。'
- en: As for our `gdaldem` aspect raster, the same compression applies this time and
    no other arguments are needed to generate the aspect raster. To visualize the
    aspect raster, open it inside QGIS and assign it a color as described earlier
    in the introduction.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的`gdaldem`方向栅格，这次同样适用相同的压缩，并且不需要其他参数来生成方向栅格。要可视化方向栅格，请在QGIS中打开它，并分配一个颜色，如介绍中所述。
- en: Merging rasters to generate a color relief map
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并栅格以生成彩色高程图
- en: 'Generating a color relief raster is a one-liner with the `gdaldem color-relief`
    command line. If you want something that''s a little more visually appealing,
    we will perform a combination of a slope, hillshade, and some color relief. Our
    end result is a single new raster representing a merge of layers to give a nice
    visual effect of elevation relief. The results are going to look similar to the
    following image:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`gdaldem color-relief`命令行生成彩色高程栅格是一行代码。如果你想要更直观的效果，我们将执行一个组合，包括坡度、阴影和一些颜色高程。我们的最终结果是单个新的栅格，表示层合并，以给出一个美观的高程视觉效果。结果看起来将类似于以下图像：
- en: '![Merging rasters to generate a color relief map](img/50790OS_07_07.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![合并栅格以生成彩色高程图](img/50790OS_07_07.jpg)'
- en: Getting ready
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this exercise, you need to have the GDAL libraries installed that include
    the `gdaldem` command-line tool.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习，你需要安装包含`gdaldem`命令行工具的GDAL库。
- en: How to do it...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s begin by extracting some key information out of our DEM using the `gdalinfo\ch07\code>gdalinfo
    ../geodata/092j02_0200_demw.dem` command-line tool as follows:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从使用`gdalinfo\ch07\code>gdalinfo ../geodata/092j02_0200_demw.dem`命令行工具从我们的DEM中提取一些关键信息开始，如下所示：
- en: '[PRE6]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This key information is then used to create our color `ramp.txt` file. Start
    off by creating a new text file called `ramp.txt` and type in the following color
    codes:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些关键信息随后被用来创建我们的颜色`ramp.txt`文件。首先创建一个名为`ramp.txt`的新文本文件，并输入以下颜色代码：
- en: '[PRE7]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `-32767` value defines our `NODATA` values in the white (`255 255 255`)
    RGB color. Now, save the `ramp.txt` file in the same folder as the following code
    that will generate the new raster color relief:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-32767`值定义了我们的`NODATA`值，在白色（`255 255 255`）RGB颜色中。现在，将`ramp.txt`文件保存在以下代码相同的文件夹中，该代码将生成新的栅格彩色高程：'
- en: '[PRE8]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We need to chain together some commands and variables to get the desired results
    to look good. To begin our journey, we'll extract some key information from our
    DEM to enable us to create a color ramp that defines what colors are assigned
    to the elevation values. This new `ramp.txt` file stores our color ramp values
    that are then used by the `gdaldem color-relief` command.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要链式连接一些命令和变量以获得期望的结果，使其看起来更好。开始我们的旅程，我们将从DEM中提取一些关键信息，以便我们能够创建一个颜色渐变，定义哪些颜色被分配给高程值。这个新的`ramp.txt`文件存储我们的颜色渐变值，然后由`gdaldem
    color-relief`命令使用。
- en: The code then begins by defining the input and output needed as variables throughout
    this script. In the preceding code we have defined the input `DEM` and three output
    `.tif` files.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先定义了在整个脚本中需要的输入和输出变量。在前面的代码中，我们定义了输入`DEM`和三个输出`.tif`文件。
- en: The first call will execute the `gdaldem hillshade` command to generate our
    hillshade. This is closely followed by the `gdaldem color-relief` command, creating
    our nice color raster that's based on the `ramp.txt` file we've defined. The `ramp.txt`
    file contains the NODATA value and sets it as the white RGB color. The five categories
    are based on the DEM data itself.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用将执行`gdaldem hillshade`命令以生成我们的阴影图。紧接着是`gdaldem color-relief`命令，创建基于我们定义的`ramp.txt`文件的好看的彩色栅格。`ramp.txt`文件包含NODATA值并将其设置为白色RGB颜色。五个类别基于DEM数据本身。
- en: The final merge takes place using the Frank Warmerdam `hsv_merge.py` script
    that combines our relief output with the generated hillshade raster, leaving us
    with our final raster. Our result is a nice looking combination of a color-relief
    map and a hillshade.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最终合并使用Frank Warmerdam的`hsv_merge.py`脚本完成，该脚本将我们的高程输出与生成的阴影栅格合并，留下我们的最终栅格。我们的结果是颜色高程图和阴影的漂亮组合。
