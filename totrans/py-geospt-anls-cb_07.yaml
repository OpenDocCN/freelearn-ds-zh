- en: Chapter 7. Raster Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Loading a DEM USGS ACSII CDED into PostGIS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an elevation profile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a hillshade raster from your DEM with ogr
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating slope and aspect images from your DEM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Merging rasters to generate a color relief map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Raster analysis works similar to vector analysis but the spatial relation is
    determined by the position of the raster cell. Most of our raster data is collected
    through diverse remote sensing techniques. In this chapter, the goals are quite
    simple and focused on working with and around a **digital elevation model** (**DEM**).
    The DEM we are using is from Whistler, BC, Canada, home to the 2010 Winter Olympics.
    Our DEM is in the form of the USGS ASCII CDED (`.dem`) format. The DEM is our
    source data that is used to derive several new raster datasets. As with other
    chapters, we will leverage Python as our glue to run scripts to enable a processing
    pipeline for raster data. The visualization of our data will play out with matplotlib
    along with the QGIS desktop GIS.
  prefs: []
  type: TYPE_NORMAL
- en: Loading a DEM USGS ACSII CDED into PostGIS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Importing and working with a DEM in PostGIS is what this recipe is all about.
    We begin our journey with a text file that's full of points and is stored in the
    USGS ASCII CDED format (to read more about the details of this format, feel free
    to look at the documentation page at [http://www.gdal.org/frmt_usgsdem.html](http://www.gdal.org/frmt_usgsdem.html)).
    The ASCII format is well known and accepted by many desktop GIS applications as
    a direct data source. Feel free to simply open up your ASCII file with QGIS to
    view the files and see the resulting raster representation that it creates for
    you. Our task at hand is to import this DEM file into a PostGIS database, creating
    a new PostGIS raster dataset within PostGIS We perform this task by using a command-line
    tool called `raster2pgsql`, which is installed along with your PostGIS installation.
    The `raster2pgsql` tool is located on Windows under `C:\Program Files\PostgreSQL\9.3\bin\`
    if you are running PostgreSQL 9.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your data is available in the `ch07/geodata/dem_3857.dem` folder. Feel free
    to get the original DEM from GeoGratis Canada, the area around Whistler Mountain,
    British Columbia, at [http://ftp2.cits.rncan.gc.ca/pub/geobase/official/cded/50k_dem/092/092j02.zip](http://ftp2.cits.rncan.gc.ca/pub/geobase/official/cded/50k_dem/092/092j02.zip).
  prefs: []
  type: TYPE_NORMAL
- en: If you have not already created your `Postgresql` database in [Chapter 1](ch01.html
    "Chapter 1. Setting Up Your Geospatial Python Environment"), *Setting Up Your
    Geospatial Python Environment*, do so now and then continue with starting your
    virtual environment to run this script.
  prefs: []
  type: TYPE_NORMAL
- en: Also, make sure that the `raster2pgsql` command is available in your command
    prompt. If not, set up your environment variables on Windows or a sym link on
    your Linux machine.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s move on to the fun part that can be found in your `/ch07/code/ch07-01_dem2postgis.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code found in the `/ch07/code/ch07-01_dem2postgis.py` file is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python, once again, is our glue that leverages the power of a command-line tool
    to do the dirty work. This time around, we use the Python subprocess module to
    call `raster2pgsql` the command-line tool. The `psycopg2` module then executes
    our `insert` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from the top and working our way down, we see the database connection
    settings for `psycopg2`. The input path to our DEM is set as the `input_dem` variable.
    Then, we pack our command-line arguments into a single string called `command`.
    This is then run by subprocess. The individual command-line arguments are described
    in the code comments and further information and options can be found directly
    at [http://postgis.refractions.net/docs/using_raster.xml.html#RT_Raster_Loader](http://postgis.refractions.net/docs/using_raster.xml.html#RT_Raster_Loader).
  prefs: []
  type: TYPE_NORMAL
- en: Now that the command is ready, we need to create a temporary file to store the
    generated SQL `insert` and `create` statements that the `raster2pgsql` command
    creates. Using the `with open()` syntax, we create our temporary file and then
    call the command using subprocess. We use `stdout` to specify where to write out
    this file. The `shell=True` argument comes with a *big* warning.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following is the `mention` warning taken from the Python documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If all goes well, no exceptions should pop up, but if they do, we catch them
    using the standard Python `try` statement.
  prefs: []
  type: TYPE_NORMAL
- en: The last step is to open the newly created SQL file that's full of inserts and
    execute each line in the file using `psycopg2`. This populates our new table that
    has the name of the input DEM file.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and open up **QGIS** | **2.8.x** and have a look at the raster you've
    just loaded into PostGIS.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To open the raster in QGIS, I've found that you need to open the Database Manager
    application that comes with QGIS and connect to your Postgresql-PostGIS database
    and schema. Then, you will see the new raster, and you will need to right-click
    on it to add it to the canvas. This will finally add the raster to your QGIS project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an elevation profile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating an elevation profile is very helpful when trying to visualize a 3D
    terrain cross-section or simply to see the elevation gain of a bike tour. In this
    example, we will define our own LineString geometry and extract the elevation
    values from the DEMs that are located every 20 m along our line. The analysis
    will generate a new CSV file that we can open in Libre Office Calc or Microsoft
    Excel to visualize the new data as a line chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'The 2D view of our line plotted on top of the elevation model as seen inside
    QGIS looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an elevation profile](img/50790OS_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe calls for GDAL and Shapely. Make sure that you have them installed
    and are running them inside your python virtual environment that you set up earlier.
    To visualize your final CSV file, you must also install Libre Office Calc or some
    other charting software. The code to execute this is located at `/ch07/code/ch07-02_elev_profile.py`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Running the script directly from your command line will generate your CSV,
    so read the code comments to see all the little details of what is going on in
    order to generate our new file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two functions that are used to create our elevation profile. The first
    `get_elevation()`function returns a single elevation value per pixel for each
    band in a raster. This means that our input raster can contain multiple bands
    of data. Our second function will write our results to a CSV file.
  prefs: []
  type: TYPE_NORMAL
- en: The `get_elevation()` function creates a list of elevation values; to achieve
    this, we need to extract some details from our input elevation raster. The *x*
    and *y* origin coordinates are used in combination with the raster pixel width
    and height to help find pixels in our raster. This information is then processed
    with our input *x* and *y* coordinates where we want the elevation value to be
    extracted.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we loop through all the available bands in our raster and find the
    elevation value per band that's located at coordinates *x* and *y* from our input.
    The `ReadAsArray` GDAL function finds this location, and then all we need to do
    is get the first object of the second nested list array. This value is then appended
    to a new list of elevation values.
  prefs: []
  type: TYPE_NORMAL
- en: To process our data, we define the input paths of our raster with the `os.path.realpath()`
    Python function that returns the full path to our input. GDAL is used to open
    our DEM raster and return the number of bands plus the *x* origin, *y* origin,
    pixel width, and pixel height information from our raster. This is located in
    the transform variable that's passed into our `get_elevation()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Working our way further, we define our input LineString. This LineString defines
    where the cross-section profile is going to be extracted. To process our data,
    we want to extract elevation values every 20 m along our input LineString. This
    is done in the `for` loop as we specify the range based on the LineString length
    and our input of 20 m. Using the Shapely `Interpolate` linear referencing function,
    we then create a point object every 20 m. These values are then stored in separate
    *x*, *y*, and *z* lists, which are then updated. The *z* list contains our list
    of new elevation points. Individual elevations are collected by specifying the
    first object in the list that's returned by our `get_elevation()` function.
  prefs: []
  type: TYPE_NORMAL
- en: To put all this together in a CSV file, we use the Python `zip` function to
    combine the distance values with the elevation values. This creates the final
    two columns of data, showing us the distance from the starting point of our LineString
    on the *x*-axis and the elevation value on the *y*-axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Visualizing the results is then easy in Libre Office Calc or Microsoft Excel.
    Go ahead and open up the output CSV file located in your `/ch07/geodata/output_profile.csv`
    folder and create a simple line chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/50790OS_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Your resulting chart should look similar to what is shown in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'To plot the graph using Libre Office Calc, see the following plotting options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/50790OS_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a hillshade raster from your DEM with ogr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our DEM can be the basis for many types of derived raster datasets. One of these
    derivatives is the so called **hillshade** raster dataset. A hillshade raster
    represents a 2D view of 3D elevation data, assigning gray raster shades and giving
    them a 3D effect by enabling you to see the highs and lows of your terrain. The
    hillshade is a pure visualization helper to create a nice looking map and show
    relief on a 2D map.
  prefs: []
  type: TYPE_NORMAL
- en: The pure Python solution to creating a hillshade is written by Roger Veciana
    i Rovira and you can find it at [http://geoexamples.blogspot.co.at/2014/03/shaded-relief-images-using-gdal-python.html](http://geoexamples.blogspot.co.at/2014/03/shaded-relief-images-using-gdal-python.html).
    There is also a nice solution by Joel Lawhead in *Chapter 7*, *Python and Elevation
    Data* of *Learning Geospatial Analysis with Python*. For those of you looking
    for a detailed description of the hillshade from ESRI, check this page out at
    [http://webhelp.esri.com/arcgisdesktop/9.3/index.cfm?TopicName=How%20Hillshade%20works](http://webhelp.esri.com/arcgisdesktop/9.3/index.cfm?TopicName=How%20Hillshade%20works).
    The `gdaldem` hillshade command-line tool will be used to generate the image to
    disk.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a hillshade raster from your DEM with ogr](img/50790OS_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The prerequisites for this example require the `gdal` (`osgeo`), `numpy`, and
    `matplotlib` python libraries. Plus, you need to have downloaded the data folder
    for this book and have the `/ch07/geodata` folder available for read/write access.
    We are directly accessing our USGS ASCII CDED DEM `.dem` file on disk to render
    our hillshade, so be sure that you have this folder. The code execution will take
    place as usual from your `/ch07/code/` folder that runs the `ch07-03_shaded_relief.py`
    python file. So, for the impatient coders go ahead and give it a try at the command
    line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our Python script will run through a few mathematical operations and call the
    gdaldem command-line tool to generate our output using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code contains some math that is not always easy to follow; the calculation
    of the greyscale values is determined by the elevation and its surrounding pixels,
    so read along:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The hillshade function calculates slope and aspect values for each cell as the
    input to calculate the shaded gray value. The `azimuth` variable defines the direction
    of light in degrees that hits our DEM. Inverting and playing with `azimuth` can
    lead to some effects, such as valleys looking like hills and hills looking like
    valleys. Our `shaded` variable holds the shade values as an array that we can
    plot with matplotlib.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `gdaldem` command-line tool is definitely more robust and faster than
    the pure Python solution. With `gdaldem`, we create a new hillshade TIF file on
    disk that can open either with a local image viewer or can be drag-and-dropped
    into QGIS. QGIS will automatically stretch the gray values for you so that you
    will be able to see a nice representation of your hillshade.
  prefs: []
  type: TYPE_NORMAL
- en: Generating slope and aspect images from your DEM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Slope maps are very useful, for example, to help biologists identify habitat
    zones. Certain species only live in areas that are very steep—mountain goats,
    for instance. The slope raster can then quick identify potential habitat areas.
    To visualize this, we use QGIS to display our slope map, which will look similar
    to the following image. The area in white indicates the steeper area and the darker
    the color, the flatter the terrain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating slope and aspect images from your DEM](img/50790OS_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Our aspect map displays the direction that the surface faces towards—such as
    north, east, south, and west—and this is expressed in degrees. In the screenshot,
    the orange area represents warm south-facing areas. The north-facing sides are
    cooler and are indicated in different hues of blues from our color spectrum. To
    achieve the colors, the QGIS singleband pseudocolor was classified into five continuous
    classes as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating slope and aspect images from your DEM](img/50790OS_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ensure that your `/ch07/geodata` folder is downloaded and the DEM `092j02_0200_demw.dem`
    file from Whistler, BC, Canada, is available.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We utilize the `gdaldem` command-line tool to create our slope raster. You can
    tweak this recipe to batch generate slope images from several DEM rasters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `gdaldem` command-line tool is our workhorse once again and all we need
    to do is pass along our DEM and specify an output file. Inside the code, you'll
    see the arguments passed include `-co compress=lzw`, which reduces the size of
    the image dramatically. Our `-p` option states that we want the results in a percentage
    slope followed by the input DEM and our output file.
  prefs: []
  type: TYPE_NORMAL
- en: As for our `gdaldem` aspect raster, the same compression applies this time and
    no other arguments are needed to generate the aspect raster. To visualize the
    aspect raster, open it inside QGIS and assign it a color as described earlier
    in the introduction.
  prefs: []
  type: TYPE_NORMAL
- en: Merging rasters to generate a color relief map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Generating a color relief raster is a one-liner with the `gdaldem color-relief`
    command line. If you want something that''s a little more visually appealing,
    we will perform a combination of a slope, hillshade, and some color relief. Our
    end result is a single new raster representing a merge of layers to give a nice
    visual effect of elevation relief. The results are going to look similar to the
    following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Merging rasters to generate a color relief map](img/50790OS_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this exercise, you need to have the GDAL libraries installed that include
    the `gdaldem` command-line tool.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s begin by extracting some key information out of our DEM using the `gdalinfo\ch07\code>gdalinfo
    ../geodata/092j02_0200_demw.dem` command-line tool as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This key information is then used to create our color `ramp.txt` file. Start
    off by creating a new text file called `ramp.txt` and type in the following color
    codes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `-32767` value defines our `NODATA` values in the white (`255 255 255`)
    RGB color. Now, save the `ramp.txt` file in the same folder as the following code
    that will generate the new raster color relief:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to chain together some commands and variables to get the desired results
    to look good. To begin our journey, we'll extract some key information from our
    DEM to enable us to create a color ramp that defines what colors are assigned
    to the elevation values. This new `ramp.txt` file stores our color ramp values
    that are then used by the `gdaldem color-relief` command.
  prefs: []
  type: TYPE_NORMAL
- en: The code then begins by defining the input and output needed as variables throughout
    this script. In the preceding code we have defined the input `DEM` and three output
    `.tif` files.
  prefs: []
  type: TYPE_NORMAL
- en: The first call will execute the `gdaldem hillshade` command to generate our
    hillshade. This is closely followed by the `gdaldem color-relief` command, creating
    our nice color raster that's based on the `ramp.txt` file we've defined. The `ramp.txt`
    file contains the NODATA value and sets it as the white RGB color. The five categories
    are based on the DEM data itself.
  prefs: []
  type: TYPE_NORMAL
- en: The final merge takes place using the Frank Warmerdam `hsv_merge.py` script
    that combines our relief output with the generated hillshade raster, leaving us
    with our final raster. Our result is a nice looking combination of a color-relief
    map and a hillshade.
  prefs: []
  type: TYPE_NORMAL
