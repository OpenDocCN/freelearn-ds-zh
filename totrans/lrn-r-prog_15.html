<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch15"/>Chapter 15. Boosting Productivity</h1></div></div></div><p>In the previous chapter, we learned to use R to extract information from web pages. To understand how this works, we learned several languages such as HTML, CSS, and XPath. In fact, R has much more to offer than just a statistical computing environment. The R community provides tools for everything from data collection, to data manipulation, statistical modeling, visualization, and all the way to reporting and presentation.</p><p>In this chapter, we will learn about a number of packages that boost our productivity. We'll review several languages we learned throughout this book and get to know another one: markdown. We'll see how R and markdown can be combined to produce powerful dynamic documents. More specifically, we'll:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Get to know markdown and R Markdown</li><li class="listitem" style="list-style-type: disc">Embed tables, charts, diagrams and interactive plots</li><li class="listitem" style="list-style-type: disc">Create interactive apps</li></ul></div><div><div><div><div><h1 class="title"><a id="ch15lvl1sec76"/>Writing R Markdown documents</h1></div></div></div><p>The work of data analysts is more than putting data into models and drawing some conclusions. We usually need to go through a complete workflow from data collecting, to data cleaning, visualization, modeling, and finally writing a report or making a presentation.</p><p>In the previous chapters, we improved our productivity by learning the R programming language from different aspects. In this chapter, we will further boost our productivity by focusing on the final step: reporting and presentation. In the following sections, we'll learn a very simple language to write documents: markdown.</p><div><div><div><div><h2 class="title"><a id="ch15lvl2sec155"/>Getting to know markdown</h2></div></div></div><p>Throughout this book, we have already learned a bunch of languages. These languages are very different and may confuse beginners. But if you keep in mind their purposes, it won't be hard to use them together. Before learning markdown, we'll take a quick review of the languages we learned in the previous chapters.</p><p>The first is, of course, the R programming language. A programming language is designed for solving problems. R is specially designed and tailored for statistical computing and is empowered by the community to be capable of doing many other things; the example is shown as follows:</p><pre class="programlisting">n &lt;- 100 &#13;
x &lt;- rnorm(n) &#13;
y &lt;- 2 * x + rnorm(n) &#13;
m &lt;- lm(y ~ x) &#13;
coef(m) &#13;
</pre><p>In <a class="link" href="ch12.html" title="Chapter 12. Data Manipulation">Chapter 12</a>, <em>Data Manipulation</em>, we learned SQL to query relational databases. It is designed to be a programming language but is used to express relational database operations such as inserting or updating records and querying data:</p><pre class="programlisting">SELECT name, price &#13;
FROM products &#13;
WHERE category = 'Food' &#13;
ORDER BY price desc &#13;
</pre><p>The R programming language is executed by the R interpreter and SQL is executed by a database engine. However, we also learned languages that are not designed for execution but to represent data. Perhaps the most commonly used data representation languages in programming world are JSON and XML:</p><pre class="programlisting">[ &#13;
  { &#13;
    "id": 1, &#13;
    "name": "Product-A", &#13;
    "price": 199.95 &#13;
  }, &#13;
  { &#13;
    "id": 2, &#13;
    "name": "Product-B", &#13;
    "price": 129.95 &#13;
  } &#13;
] &#13;
</pre><p>The specification of JSON defines elements such as value <code class="literal">(1, "text")</code>, array (<code class="literal">[]</code>), and object (<code class="literal">{}</code>), and so on, while XML does not provide type support but allows the usage of attributes and nodes:</p><pre class="programlisting">&lt;?xml version="1.0"?&gt; &#13;
&lt;root&gt; &#13;
  &lt;product id="1"&gt; &#13;
    &lt;name&gt;Product-A&lt;name&gt; &#13;
    &lt;price&gt;$199.95&lt;/price&gt; &#13;
  &lt;/product&gt; &#13;
  &lt;product id="2"&gt; &#13;
    &lt;name&gt;Product-B&lt;/name&gt; &#13;
    &lt;price&gt;$129.95&lt;/price&gt; &#13;
  &lt;/product&gt; &#13;
&lt;/root&gt; &#13;
</pre><p>In the previous chapter on web scraping, we learned the basics of HTML which is quite similar to XML. Most web pages are written in HTML due to its flexible representation of contents and layouts:</p><pre class="programlisting">&lt;!DOCTYPE html&gt; &#13;
&lt;html&gt; &#13;
&lt;head&gt; &#13;
  &lt;title&gt;Simple page&lt;/title&gt; &#13;
&lt;/head&gt; &#13;
&lt;body&gt; &#13;
  &lt;h1&gt;Heading 1&lt;/h1&gt; &#13;
  &lt;p&gt;This is a paragraph.&lt;/p&gt; &#13;
&lt;/body&gt; &#13;
&lt;/html&gt; &#13;
</pre><p>In this chapter, we'll learn markdown, a lightweight markup language with a syntax designed for plain text formatting and which can be converted to many other document formats. After getting familiar with markdown, we'll go further with R Markdown, which is designed for dynamic documents and is actively supported by RStudio and the rest of the R community. The format is so simple that we can use any plain text editor to write markdown documents.</p><p>The following code block shows its syntax:</p><pre class="programlisting"># Heading 1 &#13;
 &#13;
This is a top level section. This paragraph contains both __bold__ text and _italic_ text. There are more than one syntax to represent **bold** text and *italic* text. &#13;
 &#13;
## Heading 2 &#13;
 &#13;
This is a second level section. The following are some bullets. &#13;
 &#13;
* Point 1 &#13;
* Point 2 &#13;
* Point 3 &#13;
 &#13;
### Heading 3 &#13;
 &#13;
This is a third level section. Here are some numbered bullets. &#13;
 &#13;
1. hello &#13;
2. world &#13;
 &#13;
Link: [click here](https://r-project.org) &#13;
Image: ![image-title](https://www.r-project.org/Rlogo.png) &#13;
Image link: [![image-title](https://www.r-project.org/Rlogo.png)](https://r-project.org) &#13;
</pre><p>The syntax is extremely simple: Some characters are devoted to representing different formats. In a plain text editor, we cannot preview the formats as it indicates. But when converted to a HTML document, the texts will be formatted according to the syntax.</p><p>The following screenshot shows the preview of a markdown document in Abricotine (<a class="ulink" href="http://abricotine.brrd.fr/">http://abricotine.brrd.fr/</a>), an open-source markdown editor with live preview:</p><div><img src="img/image_15_001.jpg" alt="Getting to know markdown"/></div><p>There are also online markdown editors with fantastic features. One of my favorites is StackEdit (<a class="ulink" href="https://stackedit.io/">https://stackedit.io/</a>). You can create a new blank document and copy the above markdown texts into the editor, and then the you can see the instant preview as an HTML page:</p><div><img src="img/image_15_002.jpg" alt="Getting to know markdown"/></div><p>Markdown is widely used in online discussion. The largest open-source repository host, GitHub (<a class="ulink" href="https://github.com">https://github.com</a>), supports markdown in writing issues as shown in the following screenshot:</p><div><img src="img/image_15_003.jpg" alt="Getting to know markdown"/></div><p>Note that backticks (<code class="literal">`</code>) are used to create source code symbols and three-backticks (<code class="literal">```X</code>) are used to contain a code block written in language X. Code blocks are shown in fixed-width font which is better for presenting program code. Also, we can preview what we have written so far:</p><div><img src="img/image_15_004.jpg" alt="Getting to know markdown"/></div><p>Another special symbol, <code class="literal">$</code>, is used to quote math formulas. Single dollar (<code class="literal">$</code>) indicates inline math whereas double dollars (<code class="literal">$$</code>) displays math (in a new line). The math formula should be written in LaTeX math syntax (<a class="ulink" href="https://en.wikibooks.org/wiki/LaTeX/Mathematics">https://en.wikibooks.org/wiki/LaTeX/Mathematics</a>).</p><p>The following math equation is not that simple: <em>$$x^2+y^2=z^2$$</em>, where <em>$x$</em>,<em>$y$</em>, and <em>$z$</em> are integers.</p><p>Not all markdown editors support the preview of math formulas. In StackEdit, the preceding markdown is previewed as follows:</p><div><img src="img/image_15_005.jpg" alt="Getting to know markdown"/></div><p>In addition, many markdown renderers support the table syntax shown as follows:</p><pre class="programlisting">| Sepal.Length| Sepal.Width| Petal.Length| Petal.Width|Species | &#13;
|------------:|-----------:|------------:|-----------:|:-------| &#13;
|          5.1|         3.5|          1.4|         0.2|setosa  | &#13;
|          4.9|         3.0|          1.4|         0.2|setosa  | &#13;
|          4.7|         3.2|          1.3|         0.2|setosa  | &#13;
|          4.6|         3.1|          1.5|         0.2|setosa  | &#13;
|          5.0|         3.6|          1.4|         0.2|setosa  | &#13;
|          5.4|         3.9|          1.7|         0.4|setosa  | &#13;
</pre><p>In StackEdit, the preceding text table is rendered as follows:</p><div><img src="img/image_15_006.jpg" alt="Getting to know markdown"/></div></div><div><div><div><div><h2 class="title"><a id="ch15lvl2sec156"/>Integrating R into Markdown</h2></div></div></div><p>Markdown is easy to write and read, and has most necessary features for writing reports such as simple text formatting, embedding images, links, tables, quotes, math formula, and code blocks.</p><p>Although writing plain texts in markdown is easy, creating reports with many images and tables is not, especially when the images and tables are produced dynamically by code. R Markdown is the killer app that integrates R into markdown.</p><p>More specifically, the markdowns we showed earlier in this chapter are all static documents; that is, they were determined when we wrote them. However, R Markdown is a combination of R code and markdown texts. The output of R code can be text, table, images, and interactive widgets. It can be rendered as an HTML web page, a PDF document, and even a Word document. Visit <a class="ulink" href="http://rmarkdown.rstudio.com/formats.html">http://rmarkdown.rstudio.com/formats.html</a> to learn more about supported formats.</p><p>To create an R Markdown document, click the menu item, as shown in the following screenshot:</p><div><img src="img/image_15_007.jpg" alt="Integrating R into Markdown"/></div><p>If you don't have <code class="literal">rmarkdown</code> and <code class="literal">knitr</code> installed, RStudio will install these necessary packages automatically. Then you can write a title and author and choose a default output format, as shown in the following screenshot:</p><div><img src="img/image_15_008.jpg" alt="Integrating R into Markdown"/></div><p>Then a new R Markdown document will be created. The new document is not empty but a demo document that shows the basics of writing texts and embedding R code which produces images. In the template document, we can see some code chunks like:</p><div><img src="img/image_15_009.jpg" alt="Integrating R into Markdown"/></div><p>The preceding chunk evaluates <code class="literal">summary(cars)</code> and will produce some text output:</p><div><img src="img/image_15_010.jpg" alt="Integrating R into Markdown"/></div><p>The preceding chunk evaluates <code class="literal">plot(pressure)</code> and will produce an image. Note that we can specify options for each chunk in the form of <code class="literal">{r [chunk_name], [options]}</code> where <code class="literal">[chunk_name]</code> is optional and is used to name the produced image and <code class="literal">[options]</code> is optional and may specify whether the code should appear in the output document, the width and height of the produced graphics, and so on. To find more options, visit <a class="ulink" href="http://yihui.name/knitr/options/">http://yihui.name/knitr/options/</a>.</p><p>To render the document, just click on the <strong>Knit</strong> button:</p><div><img src="img/image_15_011.jpg" alt="Integrating R into Markdown"/></div><p>When the document is properly saved to disk, RStudio will call functions to render the document into a web page. More specifically, the document is rendered in two steps:</p><div><ol class="orderedlist arabic"><li class="listitem">The <code class="literal">knitr</code> module runs the code of each chunk and places the code and output according to the chunk options so that <code class="literal">Rmd</code> is fully rendered as a static markdown document.</li><li class="listitem">The <code class="literal">pandoc</code> module renders the resulted markdown document as HTML, PDF, or DOCX according to the <code class="literal">Rmd</code> options specified in file header.</li></ol></div><p>As we are editing an R Markdown document in RStudio, we can choose which format to produce anytime and then it will automatically call the <code class="literal">knitr</code> module to render the document into markdown and then run the <code class="literal">pandoc</code> module with the proper arguments to produce a document in that format. This can also be done with code using functions provided by <code class="literal">knitr</code> and <code class="literal">rmarkdown</code> modules.</p><p>In the new document dialog, we can also choose presentation and create slides using R Markdown. Since writing documents and writing slides are similar, we won't go into detail on this topic.</p></div><div><div><div><div><h2 class="title"><a id="ch15lvl2sec157"/>Embedding tables and charts</h2></div></div></div><p>Without R code chunks, R Markdown is no different from a plain markdown document. With code chunks, the output of code is embedded into the document so that the final content is dynamic. If a code chunk uses a random number generator without fixing the random seed, each time we knit the document we will get different results.</p><p>By default, the output of a code chunk is put directly beneath the code in fixed-width font starting with <code class="literal">##</code> as if the code is run in the console. This form of output works but is not always satisfactory, especially when we want to present the data in more straightforward forms.</p><div><div><div><div><h3 class="title"><a id="ch15lvl3sec74"/>Embedding tables</h3></div></div></div><p>When writing a report, we often need to put tables within the contents. In an R Markdown document, we can directly evaluate a <code class="literal">data.frame</code> variable. Suppose we have the following <code class="literal">data.frame</code>:</p><pre class="programlisting">toys &lt;- data.frame( &#13;
  id = 1:3, &#13;
  name = c("Car", "Plane", "Motocycle"), &#13;
  price = c(15, 25, 14), &#13;
  share = c(0.3, 0.1, 0.2), &#13;
  stringsAsFactors = FALSE &#13;
) &#13;
</pre><p>To output the variable in plain text, we only need to type the variable name in a code chunk:</p><pre class="programlisting">toys &#13;
##   id      name price share &#13;
## 1  1       Car    15   0.3 &#13;
## 2  2     Plane    25   0.1 &#13;
## 3  3 Motocycle    14   0.2 &#13;
</pre><p>Note that HTML, PDF, and Word documents all support native tables. To produce a native table for the chosen format, we can use <code class="literal">knitr::kable()</code> to produce the markdown representation of the table just like the following:</p><pre class="programlisting">| id|name      | price| share| &#13;
|--:|:---------|-----:|-----:| &#13;
|  1|Car       |    15|   0.3| &#13;
|  2|Plane     |    25|   0.1| &#13;
|  3|Motocycle |    14|   0.2| &#13;
</pre><p>When <code class="literal">pandoc</code> renders the resulted markdown document to other formats, it will produce a native table from the markdown representation:</p><pre class="programlisting">knitr::kable(toys) &#13;
</pre><p>The table generated native table is shown as follows:</p><div><table border="1"><colgroup><col/><col/><col/><col/></colgroup><tbody><tr><td>
<p><strong>id</strong></p>
</td><td>
<p><strong>name</strong></p>
</td><td>
<p><strong>price</strong></p>
</td><td>
<p><strong>share</strong></p>
</td></tr><tr><td>
<p>1</p>
</td><td>
<p>Car</p>
</td><td>
<p>15</p>
</td><td>
<p>0.3</p>
</td></tr><tr><td>
<p>2</p>
</td><td>
<p>Plane</p>
</td><td>
<p>25</p>
</td><td>
<p>0.1</p>
</td></tr><tr><td>
<p>3</p>
</td><td>
<p>Motocycle</p>
</td><td>
<p>14</p>
</td><td>
<p>0.2</p>
</td></tr></tbody></table></div><p>There are other packages that produce native tables but with enhanced features. For example, the <code class="literal">xtable</code> package not only supports converting <code class="literal">data.frame</code> to LaTeX, it also provides pre-defined templates to present the results of a number of statistical models.</p><pre class="programlisting">xtable::xtable(lm(mpg ~ cyl + vs, data = mtcars)) &#13;
</pre><p>When the preceding code is knitted with the <code class="literal">results='asis'</code> option, the linear model will be shown as the following table in the output PDF document:</p><div><img src="img/image_15_012.jpg" alt="Embedding tables"/></div><p>The most well-known data software is perhaps Microsoft Excel. A very interesting feature of Excel is conditional formatting. To implement such features in R, I developed <code class="literal">formattable</code> package. To install, run <code class="literal">install.packages("formattable")</code>. It enables cell formatting in a data frame to exhibit more comparative information:</p><pre class="programlisting">library(formattable) &#13;
formattable(toys,  &#13;
  list(price = color_bar("lightpink"), share = percent)) &#13;
</pre><p>The generated table is shown as follows:</p><div><img src="img/image_15_013.jpg" alt="Embedding tables"/></div><p>Sometimes, the data has many rows, which makes embedding such a table into the document not a good idea. But JavaScript libraries such as DataTables (<a class="ulink" href="https://datatables.net/">https://datatables.net/</a>) make it easier to embed large data sets in a web page because it automatically performs paging and also supports search and filtering. Since an R Markdown document can be rendered into an HTML web page, it is natural to leverage the JavaScript package. An R package called DT (<a class="ulink" href="http://rstudio.github.io/DT/">http://rstudio.github.io/DT/</a>) ports DataTables to R data frames and we can easily put a large data set into a document to let the reader explore and inspect the data in detail:</p><pre class="programlisting">library(DT) &#13;
datatable(mtcars) &#13;
</pre><p>The generated table is shown as follows:</p><div><img src="img/image_15_014.jpg" alt="Embedding tables"/></div><p>The preceding packages, <code class="literal">formattable</code> and <code class="literal">DT</code> are two examples of a wide range of HTML widgets (<a class="ulink" href="http://www.htmlwidgets.org/">http://www.htmlwidgets.org/</a>). Many of them are adapted from popular JavaScript libraries since there are already a good number of high quality JavaScript libraries in the community.</p></div><div><div><div><div><h3 class="title"><a id="ch15lvl3sec75"/>Embedding charts and diagrams</h3></div></div></div><p>Embedding charts is as easy as embedding tables as we demonstrated. If a code chunk produces a plot, <code class="literal">knitr</code> will save the image to a file with the name of the code chunk and write <code class="literal">[name](image-file.png)</code> below the code so that when <code class="literal">pandoc</code> renders the document the image will be found and inserted to the right place:</p><pre class="programlisting">set.seed(123) &#13;
x &lt;- rnorm(1000) &#13;
y &lt;- 2 * x + rnorm(1000) &#13;
m &lt;- lm(y ~ x) &#13;
plot(x, y, main = "Linear regression", col = "darkgray") &#13;
abline(coef(m)) &#13;
</pre><p>The plot generated is shown as follows:</p><div><img src="img/image_15_015.jpg" alt="Embedding charts and diagrams"/></div><p>The default image size may not apply to all scenarios. We can specify chunk options <code class="literal">fig.height</code> and <code class="literal">fig.width</code> to alter the size of the image.</p><p>In addition to creating charts with basic graphics and packages like <code class="literal">ggplot2</code>, we can also create diagrams and graphs using <code class="literal">DiagrammeR</code> package. To install the package from CRAN, run <code class="literal">install.packages("DiagrammeR")</code>.</p><p>This package uses Graphviz (<a class="ulink" href="https://en.wikipedia.org/wiki/Graphviz">https://en.wikipedia.org/wiki/Graphviz</a>) to describe the relations and styling of a diagram. The following code produces a very simple directed graph:</p><pre class="programlisting">library(DiagrammeR) &#13;
grViz(" &#13;
digraph rmarkdown { &#13;
  A -&gt; B; &#13;
  B -&gt; C; &#13;
  C -&gt; A; &#13;
}") &#13;
</pre><p>The generated graph is shown as follows:</p><div><img src="img/image_15_016.jpg" alt="Embedding charts and diagrams"/></div><p>DiagrammeR also provides a more programmable way to construct diagrams. It exports a set of functions to perform operations on a graph. Each function takes a graph and outputs a modified graph. Therefore it is easy to use pipeline to connect all operations to produce a graph in a streamline. For more details, visit the package website at <a class="ulink" href="http://rich-iannone.github.io/DiagrammeR">http://rich-iannone.github.io/DiagrammeR</a>.</p></div><div><div><div><div><h3 class="title"><a id="ch15lvl3sec76"/>Embedding interactive plots</h3></div></div></div><p>Previously, we demonstrated both static tables (<code class="literal">knitr::kable</code>, <code class="literal">xtable</code>, and <code class="literal">formattable</code>) and interactive tables (<code class="literal">DT</code>). Similar things happen to plots too. We can not only place static images in the document as we did in the previous section, but also create dynamic and interactive plots in either the viewer or the output document.</p><p>In fact, there are more packages designed to produce interactive graphics than tables. Most of them take advantage of existing JavaScript libraries and make R data structures easier to work with them. In the following code, we introduce some of the most popular packages used to create interactive graphics.</p><p>The ggvis (<a class="ulink" href="http://ggvis.rstudio.com/">http://ggvis.rstudio.com/</a>) developed by RStudio uses Vega (<a class="ulink" href="https://vega.github.io/vega/">https://vega.github.io/vega/</a>) as its graphics backend:</p><pre class="programlisting">library(ggvis) &#13;
mtcars %&gt;%  &#13;
  ggvis(~mpg, ~disp, opacity := 0.6) %&gt;%  &#13;
  layer_points(size := input_slider(1, 100, value = 50, label = "size")) %&gt;% &#13;
  layer_smooths(span = input_slider(0.5, 1, value = 1, label = "span")) &#13;
</pre><p>The plot generated is shown as follows:</p><div><img src="img/image_15_017.jpg" alt="Embedding interactive plots"/></div><p>Note that its grammar is a bit like <code class="literal">ggplot2</code>. It best works with a pipeline operator.</p><p>Another package is called <code class="literal">dygraphs</code> (<a class="ulink" href="https://rstudio.github.io/dygraphs/">https://rstudio.github.io/dygraphs/</a>) which uses the JavaScript library (<a class="ulink" href="http://dygraphs.com/">http://dygraphs.com/</a>) of the same name. This package specializes in plotting time series data with interactive capabilities.</p><p>In the following example, we use the temperature data of airports provided in the <code class="literal">nycflights13</code> package. To plot the daily temperature time series of each airport present in the data, we need to summarize the data by computing the mean temperature on each day, reshape the long-format data to wide-format, and convert the results to an <code class="literal">xts</code> time series object with a date index and temperature columns corresponding to each airport:</p><pre class="programlisting">library(dygraphs) &#13;
library(xts) &#13;
library(dplyr) &#13;
library(reshape2) &#13;
data(weather, package = "nycflights13") &#13;
temp &lt;- weather %&gt;% &#13;
  group_by(origin, year, month, day) %&gt;% &#13;
  summarize(temp = mean(temp)) %&gt;% &#13;
  ungroup() %&gt;% &#13;
  mutate(date = as.Date(sprintf("%d-%02d-%02d",  &#13;
    year, month, day))) %&gt;% &#13;
  select(origin, date, temp) %&gt;% &#13;
  dcast(date ~ origin, value.var = "temp") &#13;
 &#13;
temp_xts &lt;- as.xts(temp[-1], order.by = temp[[1]]) &#13;
head(temp_xts) &#13;
##                EWR     JFK      LGA &#13;
## 2013-01-01 38.4800 38.8713 39.23913 &#13;
## 2013-01-02 28.8350 28.5425 28.72250 &#13;
## 2013-01-03 29.4575 29.7725 29.70500 &#13;
## 2013-01-04 33.4775 34.0325 35.26250 &#13;
## 2013-01-05 36.7325 36.8975 37.73750 &#13;
## 2013-01-06 37.9700 37.4525 39.70250 &#13;
</pre><p>Then we supply <code class="literal">temp_xts</code> to <code class="literal">dygraph()</code> to create an interactive time series plot with a range selector and dynamic highlighting:</p><pre class="programlisting">dygraph(temp_xts, main = "Airport Temperature") %&gt;% &#13;
  dyRangeSelector() %&gt;% &#13;
  dyHighlight(highlightCircleSize = 3,  &#13;
    highlightSeriesBackgroundAlpha = 0.3, &#13;
    hideOnMouseOut = FALSE) &#13;
</pre><p>The plot generated is shown as follows:</p><div><img src="img/image_15_018.jpg" alt="Embedding interactive plots"/></div><p>If the code is run in R terminal, the web browser will launch and show a web page containing the plot. If the code is run in RStudio, the plot will show up in the <strong>Viewer</strong> pane. If the code is a chunk in R Markdown document, the plot will be embedded into the rendered document.</p><p>The main advantage of interactive graphics over static plots is that interactivity allows users to further examine and explore the data rather than forcing users to view it from a fixed perspective.</p><p>There are other remarkable packages of interactive graphics. For example, <code class="literal">plotly</code> (<a class="ulink" href="https://plot.ly/r/">https://plot.ly/r/</a>) and <code class="literal">highcharter</code> (<a class="ulink" href="http://jkunst.com/highcharter/">http://jkunst.com/highcharter/</a>) are nice packages to produce a wide range of interactive plots based on JavaScript backends.</p><p>In addition to the features we demonstrated in the previous sections, R Markdown can also be used to create presentation slides, journal articles, books and websites. Visit the official website at <a class="ulink" href="http://rmarkdown.rstudio.com">http://rmarkdown.rstudio.com</a> to learn more.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch15lvl1sec77"/>Creating interactive apps</h1></div></div></div><p>In the previous section, we demonstrated the use of R Markdown that is designed for creating dynamic documents. In this section, we will take a quick tour of creating interactive apps where we use a graphical user interface to interact with the data.</p><div><div><div><div><h2 class="title"><a id="ch15lvl2sec158"/>Creating a shiny app</h2></div></div></div><p>R itself is a great environment for data analysis and visualization. However, it is not usual to deliver R and some analytic scripts to the customers to run by themselves. The outcome of data analysis can be presented not only in a HTML page, PDF document, or a Word document, but also in an interactive app that allows readers to interact with the data by modifying some parameters and see what happens with the outcome.</p><p>A powerful package, <code class="literal">shiny</code> (<a class="ulink" href="http://shiny.rstudio.com/">http://shiny.rstudio.com/</a>), developed by RStudio, is designed exactly for this purpose. A shiny app is different from the interactive graphics we demonstrated previously. It works in a web browser and the developer has all the say about what appears in the web page and how users can interact with it. To achieve this, a shiny app basically consists of two important parts: An HTTP server that interacts with the web browser, and an R session that interacts with the HTTP server.</p><p>The following is a minimal shiny app. We write an R script to define its user interface (<code class="literal">ui</code>) and <code class="literal">server</code> logic. The user interface is a <code class="literal">boostrapPage</code> which contains a <code class="literal">numericInput</code> to take an integer of sample size and a <code class="literal">textOutput</code> to show the mean of the randomly generated sample. The logic behind <code class="literal">server</code> is to simply generate random numbers according to the sample size (<code class="literal">n</code>) in the <code class="literal">input</code> and put the mean of the random sample to the <code class="literal">output</code>:</p><pre class="programlisting">library(shiny) &#13;
 &#13;
ui &lt;- bootstrapPage( &#13;
  numericInput("n", label = "Sample size", value = 10, min = 10, max = 100), &#13;
  textOutput("mean") &#13;
) &#13;
 &#13;
server &lt;- function(input, output) { &#13;
  output$mean &lt;- renderText(mean(rnorm(input$n))) &#13;
} &#13;
 &#13;
app &lt;- shinyApp(ui, server) &#13;
runApp(app) &#13;
</pre><p>The definition is now complete and we can source the code in RStudio to play with this minimal shiny app, as shown in the following screenshot:</p><div><img src="img/image_15_019.jpg" alt="Creating a shiny app"/></div><p>Each time we change the number of the sample size, the HTTP server will ask the R backend to rerun the server logic and refresh the output mean.</p><p>Although the preceding example is not useful, it at least demonstrates the basic components of a shiny app. Now we look at a more complicated but useful example.</p><p>The following example is a visualizer of many paths generated by geometric Brownian motion which is often used to model stock prices. As we know, a geometric Brownian motion is characterized by starting value, expected growth rate (<code class="literal">r</code>), volatility (<code class="literal">sigma</code>), duration (<code class="literal">T</code>) and the number of <code class="literal">periods</code>. Expect for <code class="literal">T = 1</code>, we allow users to modify all other parameters.</p><p>Now we can define the user interface of the shiny app according to the parameters we want to expose to users. The <code class="literal">shiny</code> package provides a rich set of input controls listed as follows:</p><pre class="programlisting">shiny_vars &lt;- ls(getNamespace("shiny")) &#13;
shiny_vars[grep("Input$", shiny_vars)] &#13;
##  [1] "checkboxGroupInput"       "checkboxInput"            &#13;
##  [3] "dateInput"                "dateRangeInput"           &#13;
##  [5] "fileInput"                "numericInput"             &#13;
##  [7] "passwordInput"            "selectInput"              &#13;
##  [9] "selectizeInput"           "sliderInput"              &#13;
## [11] "textInput"                "updateCheckboxGroupInput" &#13;
## [13] "updateCheckboxInput"      "updateDateInput"          &#13;
## [15] "updateDateRangeInput"     "updateNumericInput"       &#13;
## [17] "updateSelectInput"        "updateSelectizeInput"     &#13;
## [19] "updateSliderInput"        "updateTextInput" &#13;
</pre><p>To control the randomness of the generated paths, we allow users to specify the random seed (<code class="literal">seed</code>) so that the same seed produces the same paths. In the following code where <code class="literal">ui</code> is defined, we use <code class="literal">numericInput</code> for <code class="literal">seed</code> and <code class="literal">sliderInput</code> for other parameters. The <code class="literal">sliderInput</code> control has a certain range and step so that we can force a parameter to take reasonable values.</p><p>The user interface not only defines the input part but also the output part, that is, where to show what. The following is all output types shiny provides:</p><pre class="programlisting">shiny_vars[grep("Output$", shiny_vars)] &#13;
## [1] "dataTableOutput"    "htmlOutput"         &#13;
## [3] "imageOutput"        "plotOutput"         &#13;
## [5] "tableOutput"        "textOutput"         &#13;
## [7] "uiOutput"           "verbatimTextOutput" &#13;
</pre><p>In this example, the shiny app only shows a plot of all paths put together to indicate different possibilities with the same set of parameters:</p><pre class="programlisting">library(shiny) &#13;
ui &lt;- fluidPage( &#13;
  titlePanel("Random walk"), &#13;
  sidebarLayout( &#13;
    sidebarPanel( &#13;
      numericInput("seed", "Random seed", 123), &#13;
      sliderInput("paths", "Paths", 1, 100, 1), &#13;
      sliderInput("start", "Starting value", 1, 10, 1, 1), &#13;
      sliderInput("r", "Expected return", -0.1, 0.1, 0, 0.001), &#13;
      sliderInput("sigma", "Sigma", 0.001, 1, 0.01, 0.001), &#13;
      sliderInput("periods", "Periods", 10, 1000, 200, 10)), &#13;
  mainPanel( &#13;
    plotOutput("plot", width = "100%", height = "600px") &#13;
  )) &#13;
) &#13;
</pre><p>Once the user interface is defined, we need to implement the server logic which is basically about generating random paths according to user-specified parameters and put them together in the same plot.</p><p>The following code is a simple implementation of the server logic. First we set the random seed. Then we iteratively call <code class="literal">sde::GBM</code> to generate random paths from geometric Brownian motion. To install the package, run <code class="literal">install.packages("sde")</code> before calling <code class="literal">GBM</code>:</p><p>The <code class="literal">GBM</code> package is responsible for generating one path while <code class="literal">sapply</code> is used to combine all generated paths into a matrix (<code class="literal">mat</code>) where each column represents a path. Finally, we use <code class="literal">matplot</code> to plot each path in different colors together in one chart.</p><p>The calculation is done in <code class="literal">render*</code> functions no matter whether it is a text, image, or a table. The following lists all the render functions shiny provides:</p><pre class="programlisting">shiny_vars[grep("^render", shiny_vars)] &#13;
## [1] "renderDataTable" "renderImage"     "renderPage"      &#13;
## [4] "renderPlot"      "renderPrint"     "renderReactLog"  &#13;
## [7] "renderTable"     "renderText"      "renderUI" &#13;
</pre><p>In this example, we only need <code class="literal">renderPlot()</code> and to put the plotting code in it. The <code class="literal">output$plot</code> function will go to <code class="literal">plotOutput("plot")</code> in the user interface when the input is modified:</p><pre class="programlisting">server &lt;- function(input, output) { &#13;
  output$plot &lt;- renderPlot({ &#13;
    set.seed(input$seed) &#13;
    mat &lt;- sapply(seq_len(input$paths), function(i) { &#13;
      sde::GBM(input$start,  &#13;
        input$r, input$sigma, 1, input$periods) &#13;
    }) &#13;
    matplot(mat, type = "l", lty = 1, &#13;
      main = "Geometric Brownian motions") &#13;
  }) &#13;
} &#13;
</pre><p>Now both user interface and server logic are ready. We can combine them together to create a shiny app and run it in the web browser.</p><pre class="programlisting">app &lt;- shinyApp(ui, server) &#13;
runApp(app) &#13;
</pre><p>When the parameters are modified, the plot will be refreshed automatically:</p><div><img src="img/image_15_020.jpg" alt="Creating a shiny app"/></div><p>If we set a significantly positive annualized expected return, the generated paths will tend to grow more than decline:</p><div><img src="img/image_15_021.jpg" alt="Creating a shiny app"/></div></div><div><div><div><div><h2 class="title"><a id="ch15lvl2sec159"/>Using shinydashboard</h2></div></div></div><p>In addition to the functions <code class="literal">shiny</code> provides, RStudio also develops <code class="literal">shinydashboard</code> (<a class="ulink" href="http://rstudio.github.io/shinydashboard/">http://rstudio.github.io/shinydashboard/</a>) which is specialized in presenting data for overview or monitoring purposes.</p><p>The following example demonstrates how easy it is to create a simple dashboard to show the most popular R packages on CRAN with the most downloads in weekly and monthly time scale.</p><p>The data source is provided by <code class="literal">cranlogs</code> (<a class="ulink" href="http://cranlogs.r-pkg.org">http://cranlogs.r-pkg.org</a>). First run the following code to install the packages we need:</p><pre class="programlisting">install_packages(c("shinydashboard", "cranlogs")) &#13;
</pre><p>Then we take a quick view of the data source of CRAN downloads:</p><pre class="programlisting">library(cranlogs) &#13;
cran_top_downloads() &#13;
## No encoding supplied: defaulting to UTF-8. &#13;
##    rank  package count       from         to &#13;
## 1     1     Rcpp  9682 2016-08-18 2016-08-18 &#13;
## 2     2   digest  8937 2016-08-18 2016-08-18 &#13;
## 3     3  ggplot2  8269 2016-08-18 2016-08-18 &#13;
## 4     4     plyr  7816 2016-08-18 2016-08-18 &#13;
## 5     5  stringi  7471 2016-08-18 2016-08-18 &#13;
## 6     6  stringr  7242 2016-08-18 2016-08-18 &#13;
## 7     7 jsonlite  7100 2016-08-18 2016-08-18 &#13;
## 8     8 magrittr  6824 2016-08-18 2016-08-18 &#13;
## 9     9   scales  6397 2016-08-18 2016-08-18 &#13;
## 10   10     curl  6383 2016-08-18 2016-08-18 &#13;
cran_top_downloads("last-week") &#13;
## No encoding supplied: defaulting to UTF-8. &#13;
##    rank  package count       from         to &#13;
## 1     1     Rcpp 50505 2016-08-12 2016-08-18 &#13;
## 2     2   digest 46086 2016-08-12 2016-08-18 &#13;
## 3     3  ggplot2 39808 2016-08-12 2016-08-18 &#13;
## 4     4     plyr 38593 2016-08-12 2016-08-18 &#13;
## 5     5 jsonlite 36984 2016-08-12 2016-08-18 &#13;
## 6     6  stringi 36271 2016-08-12 2016-08-18 &#13;
## 7     7  stringr 34800 2016-08-12 2016-08-18 &#13;
## 8     8     curl 33739 2016-08-12 2016-08-18 &#13;
## 9     9      DBI 33595 2016-08-12 2016-08-18 &#13;
## 10   10 magrittr 32880 2016-08-12 2016-08-18 &#13;
</pre><p>After getting familiar with the form of data we want to present in the dashboard, we can now think about constructing the dashboard in exactly the same way as constructing a typical shiny app. To make the most of <code class="literal">shinydashboard</code>, it is better to go through <a class="ulink" href="http://rstudio.github.io/shinydashboard/structure.html">http://rstudio.github.io/shinydashboard/structure.html</a> to get a general idea of the nice components it provides.</p><p>Similarly to shiny app, we start by creating the user interface. This time, we use <code class="literal">dashboardPage</code>, <code class="literal">dashboardSidebar</code> and <code class="literal">dashboardBody</code>. In the dashboard, we want to present the package download dynamics and tables of the most popular packages with top downloads in both monthly and weekly scales.</p><p>We put the menu of monthly and weekly in the side bar so users can choose which to see. In each tab page, we can put plots and tables together. In this example, we use <code class="literal">formattable</code> to add color bars on the download column to make the numbers more comparable and straightforward.</p><pre class="programlisting">library(shiny) &#13;
library(shinydashboard) &#13;
library(formattable) &#13;
library(cranlogs) &#13;
 &#13;
ui &lt;- dashboardPage( &#13;
  dashboardHeader(title = "CRAN Downloads"), &#13;
  dashboardSidebar(sidebarMenu( &#13;
    menuItem("Last week",  &#13;
      tabName = "last_week", icon = icon("list")), &#13;
    menuItem("Last month",  &#13;
      tabName = "last_month", icon = icon("list")) &#13;
  )), &#13;
  dashboardBody(tabItems( &#13;
    tabItem(tabName = "last_week",  &#13;
      fluidRow(tabBox(title = "Total downloads", &#13;
        tabPanel("Total", formattableOutput("last_week_table"))), &#13;
        tabBox(title = "Top downloads", &#13;
          tabPanel("Top", formattableOutput("last_week_top_table"))))), &#13;
    tabItem(tabName = "last_month",  &#13;
      fluidRow(tabBox(title = "Total downloads", &#13;
        tabPanel("Total", plotOutput("last_month_barplot"))), &#13;
        tabBox(title = "Top downloads", &#13;
          tabPanel("Top", formattableOutput("last_month_top_table"))))) &#13;
  )) &#13;
) &#13;
</pre><p>Note that <code class="literal">plotOutput</code> is provided by <code class="literal">shiny</code> while <code class="literal">formattableOutput</code> is provided by <code class="literal">formattable</code> package. In fact, developers can create all kinds of HTML widgets that can be embedded into a shiny app as long as the package properly defines the <code class="literal">render*</code> function and <code class="literal">*Output</code> function to produce the correct HTML code.</p><p>Then we define the server logic. Since the output relies purely on the data source, we download the data before calling <code class="literal">formattable</code> and <code class="literal">plot</code>.</p><pre class="programlisting">server &lt;- function(input, output) { &#13;
  output$last_week_table &lt;- renderFormattable({ &#13;
    data &lt;- cran_downloads(when = "last-week") &#13;
    formattable(data, list(count = color_bar("lightblue"))) &#13;
  }) &#13;
   &#13;
  output$last_week_top_table &lt;- renderFormattable({ &#13;
    data &lt;- cran_top_downloads("last-week") &#13;
    formattable(data, list(count = color_bar("lightblue"), &#13;
      package = formatter("span",  &#13;
        style = "font-family: monospace;"))) &#13;
  }) &#13;
   &#13;
  output$last_month_barplot &lt;- renderPlot({ &#13;
    data &lt;- subset(cran_downloads(when = "last-month"),  &#13;
      count &gt; 0) &#13;
    with(data, barplot(count, names.arg = date), &#13;
      main = "Last month downloads") &#13;
  }) &#13;
   &#13;
  output$last_month_top_table &lt;- renderFormattable({ &#13;
    data &lt;- cran_top_downloads("last-month") &#13;
    formattable(data, list(count = color_bar("lightblue"), &#13;
      package = formatter("span",  &#13;
        style = "font-family: monospace;"))) &#13;
  }) &#13;
} &#13;
</pre><p>In fact, if the data is updating, we can create a dynamic dashboard where the tables and charts periodically refresh. Using <code class="literal">?reactiveTimer</code> and <code class="literal">?reactive</code> will be the key to achieve this. Read the documentation for more information.</p><p>Both the user interface and the server logic are ready, so we can run the app now:</p><pre class="programlisting">runApp(shinyApp(ui, server)) &#13;
</pre><p>By default, the shiny app shows the first page at the first visit. The following is a screenshot of the <strong>Last week</strong> tab page which consists of two tab panels of <code class="literal">formattable</code> data frames:</p><div><img src="img/image_15_022.jpg" alt="Using shinydashboard"/></div><p>The following screenshot shows the <strong>Last month</strong> tab page which consists of a histogram and a <code class="literal">formattable</code> data frame:</p><div><img src="img/image_15_023.jpg" alt="Using shinydashboard"/></div><div><div><h3 class="title"><a id="note6"/>Note</h3><p>To see more examples and the code behind them, visit <a class="ulink" href="http://rstudio.github.io/shinydashboard/examples.html">http://rstudio.github.io/shinydashboard/examples.html</a>.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch15lvl1sec78"/>Summary</h1></div></div></div><p>In this chapter, we demonstrated the use of R Markdown to produce dynamic documents where tables, graphics, and interactive plots can be easily embedded. Then we saw a few simple examples of shiny apps which are basically web-based interactive apps with an R backend. With these powerful productivity tools, data analysis can be made more interesting and full of fun because the outcome can be demonstrated in a nice, interactive way, which is usually better for conveying more information, drawing more insights and making better decisions.</p><p>Now we have finished this book. We started learning R by getting familiar with the fundamental concepts, data structures and language constructs and features. We went through a wide range of examples to understand how these fit the needs of practical data analysis. To build a concrete and consistent understanding of the R programming language and the behavior of data structures, we discussed several advanced topics such as R's evaluation model, metaprogramming, and object-oriented systems. With the above knowledge, we then explored a series of more practical topics such as working with databases, data manipulation techniques, high performance computing, web scraping techniques, dynamic documents, and interactive apps.</p><p>This books covers a variety of topics to expand a wide horizon on the possibility of what R and its extension packages can do. Now you should feel empowered and much more confident using R to solve data analysis problems with the right techniques. More importantly, I hope this book enables you to better work with data and go further with other useful topics such as visualization, specialized statistical modeling, and machine learning. If you are interested in going even deeper, I strongly recommend that you read <em>Advanced R</em> by Hadley Wickham.</p></div></body></html>