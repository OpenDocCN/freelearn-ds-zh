- en: Chapter 6. Mastering the QGIS Python API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at a number of more advanced aspects of the PyQGIS
    library, as well as various techniques for working with QGIS using Python. In
    particular, we will learn:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: How to work with symbol layers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More advanced ways of using symbols to draw vector data onto a map
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement your own symbols and renderers in Python
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a custom map layer using Python
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement your own custom map canvas items
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use memory data providers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with symbol layers
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapters, we created symbols to display vector features by
    instantiating one of the three basic subclasses of `QgsSymbolV2`:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '`QgsMarkerSymbolV2` for point geometries'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QgsLineSymbolV2` for line geometries'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QgsFillSymbolV2` for polygon geometries'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We did this either by calling one of the preceding class's static `createSimple()`
    methods, or by asking the `QgsSymbolV2` class to provide us with the default symbol
    for a given type of geometry. Irrespective of how we did it, the result was a
    ready-to-use symbol object that displays a given type of vector geometry.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'Internally, symbols consist of one or more symbol layers that are displayed
    one on top of the other, to draw the vector feature:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with symbol layers](img/00056.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The symbol layers are drawn in the order in which they are added to the symbol.
    So, in this example, **Symbol Layer 1** will be drawn *before* **Symbol Layer
    2**. This has the effect of drawing the second symbol layer on top of the first.
    Make sure you get the order of your symbol layers correct, or you might find a
    symbol layer completely obscured by another layer.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: While the symbols we have been working with so far have had only one layer,
    there are some clever tricks you can perform with multilayer symbols. We will
    look at multilayer symbols in the section *Combining symbol layers*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: When you create a symbol, it will automatically be initialized with a default
    symbol layer. For example, a line symbol (an instance of `QgsLineSymbolV2`) will
    be created with a single layer of type `QgsSimpleLineSymbolLayerV2`. This layer
    is used to draw the line feature onto the map.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'To work with symbol layers, you need to remove this default layer and replace
    it with your own symbol layer or layers. For example:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following methods can be used to manipulate the layers within a symbol:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '`symbol.symbolLayerCount()`: This returns the number of symbol layers within
    this symbol.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`symbol.symbolLayer(index)`: This returns the given symbol layer within the
    symbol. Note that the first symbol layer has an index of zero.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`symbol.changeSymbolLayer(index, symbol_layer)`: This replaces a given symbol
    layer within the symbol.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`symbol.appendSymbolLayer(symbol_layer)`: This appends a new symbol layer to
    the symbol.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`symbol.insertSymbolLayer(index, symbol_layer)`: This inserts a symbol layer
    at a given index.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`symbol.deleteSymbolLayer(index)`: This removes the symbol layer at the given
    index.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Remember that to use the symbol once you''ve created it, you create an appropriate
    renderer and then assign that renderer to your map layer. For example:'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following symbol layer classes are available for you to use:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '| PyQGIS class | Description | Example |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
- en: '| `QgsSimpleMarkerSymbolLayerV2` | This displays a point geometry as a small
    colored circle. | ![Working with symbol layers](img/00057.jpeg) |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
- en: '| `QgsEllipseSymbolLayerV2` | This displays a point geometry as an ellipse.
    | ![Working with symbol layers](img/00058.jpeg) |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
- en: '| `QgsFontMarkerSymbolLayerV2` | This displays a point geometry as a single
    character. You can choose the font and character to be displayed. | ![Working
    with symbol layers](img/00059.jpeg) |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
- en: '| `QgsSvgMarkerSymbolLayerV2` | This displays a point geometry using a single
    SVG format image. | ![Working with symbol layers](img/00060.jpeg) |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
- en: '| `QgsVectorFieldSymbolLayer` | This displays a point geometry by drawing a
    **displacement line**. One end of the line is the coordinate of the point, while
    the other end is calculated using attributes of the feature. | ![Working with
    symbol layers](img/00061.jpeg) |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
- en: '| `QgsSimpleLineSymbolLayerV2` | This displays a line geometry or the outline
    of a polygon geometry using a line of a given color, width, and style. | ![Working
    with symbol layers](img/00062.jpeg) |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
- en: '| `QgsMarkerLineSymbolLayerV2` | This displays a line geometry or the outline
    of a polygon geometry by repeatedly drawing a marker symbol along the length of
    the line. | ![Working with symbol layers](img/00063.jpeg) |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
- en: '| `QgsSimpleFillSymbolLayerV2` | This displays a polygon geometry by filling
    the interior with a given solid color and then drawing a line around the perimeter.
    | ![Working with symbol layers](img/00064.jpeg) |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
- en: '| `QgsGradientFillSymbolLayerV2` | This fills the interior of a polygon geometry
    using a color or grayscale gradient. | ![Working with symbol layers](img/00065.jpeg)
    |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
- en: '| `QgsCentroidFillSymbolLayerV2` | This draws a simple dot at the centroid
    of a polygon geometry. | ![Working with symbol layers](img/00066.jpeg) |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
- en: '| `QgsLinePatternFillSymbolLayer` | This draws the interior of a polygon geometry
    using a repeated line. You can choose the angle, width, and color to use for the
    line. | ![Working with symbol layers](img/00067.jpeg) |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
- en: '| `QgsPointPatternFillSymbolLayer` | This draws the interior of a polygon geometry
    using a repeated point. | ![Working with symbol layers](img/00068.jpeg) |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
- en: '| `QgsSVGFillSymbolLayer` | This draws the interior of a polygon geometry using
    a repeated SVG format image. | ![Working with symbol layers](img/00069.jpeg) |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
- en: These predefined symbol layers, either individually or in various combinations,
    give you enormous flexibility in how features are to be displayed. However, if
    these aren't enough for you, you can also implement your own symbol layers using
    Python. We will look at how this can be done later in this chapter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Combining symbol layers
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By combining symbol layers, you can achieve a range of complex visual effects.
    For example, you can combine an instance of `QgsSimpleMarkerSymbolLayerV2` with
    an instance of `QgsVectorFieldSymbolLayer` to display a point geometry using two
    symbols at once:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '![Combining symbol layers](img/00070.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: 'One of the main uses of symbol layers is to draw different LineString or PolyLine
    symbols to represent different types of roads. For example, you can draw a complex
    road symbol by combining multiple symbol layers, like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![Combining symbol layers](img/00071.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: 'This effect is achieved by using three separate symbol layers:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '![Combining symbol layers](img/00072.jpeg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
- en: 'Here is the Python code used to generate the preceding map symbol:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, you can set the line width, color, and style to create whatever
    effect you want. As always, you have to define the layers in the correct order,
    with the back-most symbol layer defined first. By combining line symbol layers
    in this way, you can create almost any type of road symbol that you want.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use symbol layers when displaying polygon geometries. For example,
    you can draw `QgsPointPatternFillSymbolLayer` on top of `QgsSimpleFillSymbolLayerV2`
    to have repeated points on top of a simple filled polygon, like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '![Combining symbol layers](img/00073.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
- en: 'Finally, you can make use of **transparency** to allow the various symbol layers
    (or entire symbols) to blend into each other. For example, you can create a pinstripe
    effect by combining two symbol layers, like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The result is quite subtle and visually pleasing:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '![Combining symbol layers](img/00074.jpeg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
- en: 'In addition to changing the transparency for a symbol layer, you can also change
    the transparency for the symbol as a whole. This is done by using the `setAlpha()`
    method, like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The result looks like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '![Combining symbol layers](img/00075.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that `setAlpha()` takes a floating point number between 0.0 and 1.0, while
    the transparency of a `QColor` object, like the ones we used earlier, is specified
    using an alpha value between 0 and 255.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Implementing symbol layers in Python
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If the built-in symbol layers aren''t flexible enough for your needs, you can
    implement your own symbol layers using Python. To do this, you create a subclass
    of the appropriate type of symbol layer (`QgsMarkerSymbolLayerV2`, `QgsLineSymbolV2`,
    or `QgsFillSymbolV2`) and implement the various drawing methods yourself. For
    example, here is a simple marker symbol layer that draws a cross for a Point geometry:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Using this custom symbol layer in your code is straightforward:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Running this code will draw a cross at the location of each point geometry,
    as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing symbol layers in Python](img/00076.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
- en: 'Of course, this is a simple example, but it shows you how to use custom symbol
    layers implemented in Python. Let''s now take a closer look at the implementation
    of the `CrossSymbolLayer` class, and see what each method does:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '`__init__()`: Notice how the `__init__` method accepts parameters that customize
    the way the symbol layer works. These parameters, which should always have default
    values assigned to them, are the **properties** associated with the symbol layer.
    If you want to make your custom symbol available within the **QGIS Layer Properties**
    window, you will need to register your custom symbol layer and tell QGIS how to
    edit the symbol layer''s properties. We will look at this shortly.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layerType()`: This method returns a unique name for your symbol layer.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`properties()`: This should return a dictionary that contains the various properties
    used by this symbol layer. The properties returned by this method will be stored
    in the QGIS project file, and used later to restore the symbol layer.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clone()`: This method should return a copy of the symbol layer. Since we have
    defined our properties as parameters to the `__init__` method, implementing this
    method simply involves creating a new instance of the class and copying the properties
    from the current symbol layer to the new instance.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`startRender()`: This method is called before the first feature in the map
    layer is rendered. This can be used to define any objects that will be required
    to draw the feature. Rather than creating these objects each time, it is more
    efficient (and therefore faster) to create them only once to render all the features.
    In this example, we create the `QPen` object that we will use to draw the Point
    geometries.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stopRender()`: This method is called after the last feature has been rendered.
    This can be used to release the objects created by the `startRender()` method.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`renderPoint()`: This is where all the work is done for drawing point geometries.
    As you can see, this method takes two parameters: the point at which to draw the
    symbol, and the **rendering context** (an instance of `QgsSymbolV2RenderContext`)
    to use for drawing the symbol.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rendering context provides various methods to access the feature being displayed,
    as well as information about the rendering operation, the current scale factor,
    and so on. Most importantly, it allows you to access the PyQt `QPainter` object
    required to actually draw the symbol on the screen.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `renderPoint()` method is only used for symbol layers that draw point geometries.
    For line geometries, you should implement the `renderPolyline()` method, which
    has the following signature:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `points` parameter will be a `QPolygonF` object that contains the various
    points that make up the LineString, and `context` will be the rendering context
    to use to draw the geometry.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'If your symbol layer is intended to work with polygons, you should implement
    the `renderPolygon()` method, which looks like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, `outline` is a `QPolygonF` object that contains the points that make up
    the exterior of the polygon, and `rings` is a list of `QPolygonF` objects that
    define the interior rings or "holes" within the polygon. As always, `context`
    is the rendering context to use when drawing the geometry.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'A custom symbol layer created in this way will work fine if you just want to
    use it within your own external PyQGIS application. However, if you want to use
    a custom symbol layer within a running copy of QGIS, and in particular, if you
    want to allow end users to work with the symbol layer using the **Layer Properties**
    window, there are some extra steps you will have to take, which are as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want the symbol to be visually highlighted when the user clicks on it,
    you will need to change your symbol layer''s `renderXXX()` method to see if the
    feature being drawn has been selected by the user, and if so, change the way it
    is drawn. The easiest way to do this is to change the geometry''s color. For example:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To allow the user to edit the symbol layer''s properties, you should create
    a subclass of `QgsSymbolLayerV2Widget`, which defines the user interface to edit
    the properties. For example, a simple widget for the purpose of editing the length
    and width of a `CrossSymbolLayer` can be defined as follows:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We define the contents of our widget using the standard `__init__()` initializer.
    As you can see, we define two fields, `lengthField` and `widthField`, which let
    the user change the `length` and `width` properties respectively for our symbol
    layer.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `setSymbolLayer()` method tells the widget which `QgsSymbolLayerV2` object
    to use, while the `symbolLayer()` method returns the `QgsSymbolLayerV2` object
    this widget is editing. Finally, the two `XXXChanged()` methods are called when
    the user changes the value of the fields, allowing us to update the symbol layer's
    properties to match the value set by the user.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, you will need to register your symbol layer. To do this, create a
    subclass of `QgsSymbolLayerV2AbstractMetadata` and pass it to the `QgsSymbolLayerV2Registry`
    object''s `addSymbolLayerType()` method. Here is an example implementation of
    the metadata for our `CrossSymbolLayer` class, along with the code to register
    it within QGIS:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Note that the parameters for the `QgsSymbolLayerV2AbstractMetadata.__init__()`
    method are as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: The unique name for the symbol layer, which must match the name returned
    by the symbol layer''s `layerType()` method.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`visibleName`: A display name for this symbol layer, as shown to the user within
    the **Layer Properties** window.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type`: The type of symbol that this symbol layer will be used for.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `createSymbolLayer()` method is used to restore the symbol layer based on
    the properties stored in the QGIS project file when the project was saved. The
    `createSymbolLayerWidget()` method is called to create the user interface widget
    that lets the user view and edit the symbol layer's properties.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Implementing renderers in Python
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you need to choose symbols based on more complicated criteria than the built-in
    renderers will provide, you can write your own custom `QgsFeatureRendererV2` subclass
    using Python. For example, the following Python code implements a simple renderer
    that alternates between odd and even symbols as point features are displayed:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Using this renderer will cause the various point geometries to be displayed
    in alternating colors, for example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing renderers in Python](img/00077.jpeg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a closer look at how this class was implemented, and what the various
    methods do:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '`__init__()`: This is your standard Python initializer. Notice how we have
    to provide a unique name for the renderer when calling the `QgsFeatureRendererV2.__init__()`
    method; this is used to keep track of the various renderers within QGIS itself.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clone()`: This creates a copy of this renderer. If your renderer uses properties
    to control how it works, this method should copy those properties into the new
    renderer object.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`symbolForFeature()`: This returns the symbol to use for drawing the given
    feature.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`startRender()`: This gives you the opportunity to prepare your renderer and
    any symbols you use before the features are rendered. Note that you must call
    the `startRender()` method on each symbol that your renderer uses; as the renderer
    can make use of multiple symbols, you need to implement this so that your symbols
    are also given a chance to prepare for rendering.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stopRender()`: This finishes rendering the features. Once again, you need
    to implement this so that your symbols can have a chance to clean up once the
    rendering process has finished.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`usedAttributes()`: This method should be implemented to return the list of
    feature attributes that the renderer makes use of. If your renderer does not use
    attributes to choose between the various symbols, then you do not need to implement
    this method.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you wish, you can also implement your own widget that lets the user change
    the way the renderer works. This is done by subclassing `QgsRendererV2Widget`
    and setting up the widget to edit the renderer's various properties in the same
    way that we implemented a subclass of `QgsSymbolLayerV2Widget` to edit the properties
    for a symbol layer. You will also need to provide metadata for your new renderer
    (by subclassing `QgsRendererV2AbstractMetadata`) and use the `QgsRendererV2Registry`
    object to register your new renderer. If you do this, the user will be able to
    select your custom renderer for new map layers, and change the way your renderer
    works by editing the renderer's properties.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Working with custom map layers
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of using a standard map layer with a data provider, features, symbols,
    and so on, you can implement your own **custom map layer** entirely in Python.
    Custom map layers are generally used to draw specific data that is too complicated
    to represent as vector format data, or to draw special visual features such as
    a grid or a watermark onto the map.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Custom map layers are implemented by subclassing the `QgsPluginLayer` class.
    The process is actually very simple, though you will need to translate between
    map and device coordinates so that the items you draw in your Python layer match
    up with the features drawn in the other layers within your canvas.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't get confused by the name; you don't have to write a QGIS plugin to create
    your own `QgsPluginLayer` subclass.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we can create our own subclass of `QgsPluginLayer`. We''re going
    to create a simple grid that can appear as a layer within the map. Let''s start
    by defining the `QgsPluginLayer` subclass itself:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In our `__init__()` method, we give the plugin layer a unique name (`"GridLayer"`)
    and a user-visible name (`"Grid Layer"`), and then tell QGIS that the layer is
    valid.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to set up the coordinate reference system and extent of our layer.
    Since we''re creating a grid that covers the entire Earth, we''ll use the standard
    EPSG 4236 coordinate system (that is, latitude/longitude coordinates), and set
    the extent of the layer to cover the entire surface of the Earth:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We''re now ready to define the method that draws the contents of the layer.
    As you might imagine, this method is called `draw()`. Let''s start by obtaining
    the `QPainter` object we''ll use to do the actual drawing:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we want to find the portion of the Earth''s surface that is currently
    visible:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This gives us the portion of the grid that we want to draw. To make sure the
    grid lines are on whole degrees of latitude and longitude, we round the extent
    up and down to the nearest whole number, like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we need to set up the painter to draw the grid lines:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, we''re almost ready to start drawing the grid. To draw the grid lines,
    though, we''ll need some way of translating between latitude/longitude values
    and pixel coordinates on the computer screen. We''ll do this using a `QgsMapToPixel`
    object, which we can get from the rendering context:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we''re finally ready to draw the grid lines. Let''s start by drawing a
    vertical grid line on each whole degree of longitude:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can then do the same for the horizontal grid lines:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The last thing we need to do is tell QGIS that our layer was drawn successfully.
    We do this by having our `draw()` method return `True`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This completes our implementation of the `GridLayer` class. If you want to
    use this class within a QGIS script or plugin, you will need to register the class
    so that QGIS knows about it. Fortunately, doing this is straightforward:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you run this program within QGIS and add the `GridLayer` to your project,
    you''ll see the grid lines drawn on the map:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with custom map layers](img/00078.jpeg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
- en: Look carefully at the preceding image; you'll see that the grid lines are drawn
    in front of the polygon, but behind the circle. This is one of the main benefits
    of implementing your own map layer, as opposed to using a map canvas item; you
    can choose which layers appear in front or behind your custom map layer.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom map canvas items
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A map canvas item is an item that is placed on top of the map canvas. Standard
    map canvas items include text annotations, vertex markers, and the visual highlighting
    of a feature. It is also possible to create your own custom map canvas items by
    subclassing `QgsMapCanvasItem`. To see how this works, let''s create a map canvas
    item that draws a compass rose onto the map:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating custom map canvas items](img/00079.jpeg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
- en: 'We''ll start by creating the basic `QgsMapCanvasItem` subclass:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, we position the compass rose onto the map canvas by defining
    `center` and `size` instance variables, and provide methods to retrieve and set
    these values. We also implement the required `boundingRect()` method, which returns
    the overall bounding rectangle for the canvas item, in screen coordinates.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: This leaves us with the `paint()` method, which does the job of drawing the
    compass rose. While this method takes three parameters, the only parameter we'll
    be using is the first one, which is the `QPainter` object we will use to draw
    the compass rose.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'The compass rose might look quite complicated, but the code needed to implement
    it is quite straightforward. The most complicated part is figuring out the dimensions
    of the `"N"`, `"S"`, `"E"`, and `"W"` labels so that we have enough room left
    for the compass rose itself. Let''s start by calculating some basic information
    about the labels that we are going to display:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We calculate the size of the font to use for the labels (in points), and then
    set our painter to use a boldfaced `"Times"` font of that size. We then get a
    `QFontMetrics` object that we will use to calculate the labels' dimensions, and
    define a hardwired pixel margin so that we leave a gap between the label and the
    compass rose itself.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we want to draw the two central parts of the compass rose in light gray
    and black respectively. To do this, we''ll use a `QPainterPath` object to define
    the area to be filled in:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, we want to draw the labels at each of the four compass points:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This completes the implementation of our `QgsMapCanvasItem` subclass. To use
    it, we simply have to create and initialize a new `CompassRoseItem`. Here is an
    example of how we can display a `CompassRoseItem` within the map canvas:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Your new `QgsMapCanvasItem` will automatically be added to the map canvas when
    the object is initialized—you don''t need to explicitly add it to the canvas.
    To remove the compass rose from the map canvas, you can do the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that map canvas items float above the map layers, and unfortunately, cannot
    directly interact with the user—you can't intercept and respond to mouse events
    using a map canvas item.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Using memory-based layers
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While a map layer would normally display geospatial data taken from an external
    data source such as a shapefile, a raster DEM file, or a database, it is also
    possible to create geospatial features directly from your Python code. For example,
    imagine that you write a program to display the halfway point along a road. This
    halfway point could be represented as a `QgsPoint` geometry, which would be displayed
    on the map using an appropriate marker symbol. Since you are calculating the point,
    this isn't a feature you would want to store in a shapefile or database. Rather,
    the feature is calculated and displayed when your program is run.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: This is an ideal application for a memory-based layer. This type of layer stores
    geospatial features in memory, allowing you to create new features on the fly
    and display them within a map layer.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a memory-based map layer, instantiate a new `QgsVectorLayer` object,
    just like normal. The initializer for this class looks like the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is slightly simplified—there is another parameter, `loadDefaultStyleFlag`,
    which doesn't apply to memory-based layers. Fortunately, there's a default value
    for this parameter, so we can ignore it.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the three parameters needed to create a memory-based
    map layer:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '`path`: This string provides information that is needed to create the memory-based
    layer, including the type of information that the layer will store. We will look
    at this parameter in more detail shortly.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`baseName`: This is the name used for the memory-based layer. The name can
    be anything you like, though the user will see it in the QGIS layer legend.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`providerLib`: This should be set to `"memory"` for memory-based layers.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To create a simple memory-based layer, you can do the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This will create a memory-based layer named `"My Layer"`, which stores polygon
    features with no attributes.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'The `path` parameter will let us do much more than simply define the type of
    geometry to be stored in the layer. The `path` parameter has the following overall
    syntax:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This URL-like syntax starts with the type of geometry, and can have any number
    of key/value pairs that provide additional information about the memory layer.
    The following geometry types are currently supported:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '`Point`'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LineString`'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Polygon`'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MultiPoint`'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MultiLineString`'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MultiPolygon`'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the key/value pairs, you can also define:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'The coordinate reference system that the layer should use. For example:'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The coordinate reference system can be defined using a CRS authority code,
    as in the preceding example, or you can specify the CRS in WKT format, for example:
    `crs=+proj=longlat +a=69000 +b=55000 +no_defs`.'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If you don't define the coordinate reference system in this way, QGIS will prompt
    the user to select a CRS when your program is run. This could be very confusing
    for the user, so you should always specify a CRS when you create a memory layer.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Attributes to store for each feature within the layer. Here is an example of
    an attribute definition:'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following types of fields are currently supported:'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`integer`'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`double`'
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`string`'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also specify the field length and precision by listing these in parentheses,
    for example, `field=height:double(10,2)` or `field=name:string(50)`.
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you want to have multiple attributes, you simply have one `field=...`entry
    for each of the attributes you want to define.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The memory layer's data provider has an `addAttributes()` method, which you
    might assume you'd use to define the attributes. However, the `addAttributes()`
    method only adds the attributes to the data provider, not the map layer, which
    can cause QGIS to crash. To avoid this, it is better to define your attributes
    within the path when you set up your map layer, rather than trying to add them
    later.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A spatial index for this layer''s features:'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s use this to create a more complex memory layer that stores point geometries
    using a specified coordinate reference system, a spatial index, and some attributes.
    Here is how we might do this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Once we''ve instantiated our memory layer, we can create the various features
    we want to display, and then add them to the layer. The following pseudocode shows
    how this is done:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As you can see, we define the various features (which are instances of `QgsFeature`),
    and then add them all at once to the memory layer. You can add the features one
    at a time, of course, but it's generally more efficient to define a list of features
    and add them all at once.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now see how we can create a feature. We start by defining the underlying
    geometry that the feature will display. There are various ways of creating geometries,
    including:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'Instantiating a `QgsPoint`, `QgsPolyLine`, `QgsPolygon`, or related object,
    and then using this to create a `QgsGeometry` object using one of the `QgsGeometry.fromXXX()`
    methods. For example:'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Creating a WKT-format string that represents the geometry, and then creating
    the `QgsGeometry` object using this string. For example:'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Creating a new `QgsGeometry` object out of an existing geometry by using one
    of the geometry manipulation methods. For example:'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Once we have the geometry, we''re ready to create the `QgsFeature` object itself:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, we want to set the attributes for this feature. Before we can do this
    though, we need to tell the feature which attributes it will store. This is done
    in the following way:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Finally, we can set the attribute values. For example:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Putting all this together, let''s build a complete example program that creates
    a memory layer, populates it with a few `QgsPoint` features, and updates the map
    canvas to show those points. Here is this example program:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Running this program from within QGIS will create a new memory-based map layer
    named `"Point Layer"` with three features in it, which represent the location
    of three famous towers in Western Europe:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在 QGIS 内运行此程序将创建一个名为 `"Point Layer"` 的新基于记忆的地图层，其中包含三个要素，代表西欧三个著名塔的位置：
- en: '![Using memory-based layers](img/00080.jpeg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![使用基于记忆的层](img/00080.jpeg)'
- en: To make this example useful, we would add symbols to draw the towers in a more
    meaningful way, and probably also display the name and height as a label beside
    each point. However, you can see how a memory layer can be used to create spatial
    data from within your program and include it as a layer within the map.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个例子更有用，我们会添加符号以更有意义的方式绘制塔，并且可能还会在每个点的旁边显示名称和高度作为标签。然而，您可以看到如何使用记忆层在程序内部创建空间数据并将其作为地图中的一个图层包含进来。
- en: Note that you aren't limited to using memory layers to represent actual geospatial
    data. You could just as easily use the memory layer to display information that
    doesn't represent a location. For example, you can use a memory layer to draw
    arrows onto a map, or to shade certain areas of the map using a semi-transparent
    polygon. Memory-based map layers are an extremely powerful tool, and one that
    you will often use when writing your own programs based on QGIS.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您不仅限于使用基于记忆的层来表示实际的地理空间数据。您同样可以使用记忆层来显示不表示位置的信息。例如，您可以使用记忆层在地图上绘制箭头，或者使用半透明多边形来阴影地图的某些区域。基于记忆的地图层是一个非常强大的工具，您在编写基于
    QGIS 的程序时经常会使用它。
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at many of the more advanced features of the QGIS
    Python API. We learned how the various built-in symbol layers can be used to draw
    geometries on the map, how to combine symbol layers in useful ways, and how to
    implement your own symbol layers using Python. We then looked at writing your
    own custom renderer to choose which symbol to use for each feature, and how to
    create your own custom map layer using Python code. We investigated the creation
    of custom map canvas items, and then saw how memory-based map layers can be used
    to programmatically add features to your map.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 QGIS Python API 的许多高级功能。我们学习了如何使用各种内置符号层在地图上绘制几何形状，如何以有用的方式组合符号层，以及如何使用
    Python 实现自己的符号层。然后，我们探讨了编写自己的自定义渲染器以选择每个要素应使用的符号，以及如何使用 Python 代码创建自己的自定义地图层。我们研究了创建自定义地图画布项，然后看到了如何使用基于记忆的地图层以编程方式将要素添加到地图中。
- en: With this, we complete our tour of the more advanced aspects of PyQGIS. In the
    next chapter, we will learn how to create custom map tools that let the user select,
    add, edit, and delete features within a PyQGIS application.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们完成了对 PyQGIS 更高级方面的探索。在下一章中，我们将学习如何创建自定义地图工具，使用户能够在 PyQGIS 应用程序中选择、添加、编辑和删除要素。
