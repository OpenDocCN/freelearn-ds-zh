- en: Chapter 6. Mastering the QGIS Python API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at a number of more advanced aspects of the PyQGIS
    library, as well as various techniques for working with QGIS using Python. In
    particular, we will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to work with symbol layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More advanced ways of using symbols to draw vector data onto a map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement your own symbols and renderers in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a custom map layer using Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement your own custom map canvas items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use memory data providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with symbol layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapters, we created symbols to display vector features by
    instantiating one of the three basic subclasses of `QgsSymbolV2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QgsMarkerSymbolV2` for point geometries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QgsLineSymbolV2` for line geometries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QgsFillSymbolV2` for polygon geometries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We did this either by calling one of the preceding class's static `createSimple()`
    methods, or by asking the `QgsSymbolV2` class to provide us with the default symbol
    for a given type of geometry. Irrespective of how we did it, the result was a
    ready-to-use symbol object that displays a given type of vector geometry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Internally, symbols consist of one or more symbol layers that are displayed
    one on top of the other, to draw the vector feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with symbol layers](img/00056.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The symbol layers are drawn in the order in which they are added to the symbol.
    So, in this example, **Symbol Layer 1** will be drawn *before* **Symbol Layer
    2**. This has the effect of drawing the second symbol layer on top of the first.
    Make sure you get the order of your symbol layers correct, or you might find a
    symbol layer completely obscured by another layer.
  prefs: []
  type: TYPE_NORMAL
- en: While the symbols we have been working with so far have had only one layer,
    there are some clever tricks you can perform with multilayer symbols. We will
    look at multilayer symbols in the section *Combining symbol layers*.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a symbol, it will automatically be initialized with a default
    symbol layer. For example, a line symbol (an instance of `QgsLineSymbolV2`) will
    be created with a single layer of type `QgsSimpleLineSymbolLayerV2`. This layer
    is used to draw the line feature onto the map.
  prefs: []
  type: TYPE_NORMAL
- en: 'To work with symbol layers, you need to remove this default layer and replace
    it with your own symbol layer or layers. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following methods can be used to manipulate the layers within a symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '`symbol.symbolLayerCount()`: This returns the number of symbol layers within
    this symbol.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`symbol.symbolLayer(index)`: This returns the given symbol layer within the
    symbol. Note that the first symbol layer has an index of zero.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`symbol.changeSymbolLayer(index, symbol_layer)`: This replaces a given symbol
    layer within the symbol.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`symbol.appendSymbolLayer(symbol_layer)`: This appends a new symbol layer to
    the symbol.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`symbol.insertSymbolLayer(index, symbol_layer)`: This inserts a symbol layer
    at a given index.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`symbol.deleteSymbolLayer(index)`: This removes the symbol layer at the given
    index.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Remember that to use the symbol once you''ve created it, you create an appropriate
    renderer and then assign that renderer to your map layer. For example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following symbol layer classes are available for you to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '| PyQGIS class | Description | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `QgsSimpleMarkerSymbolLayerV2` | This displays a point geometry as a small
    colored circle. | ![Working with symbol layers](img/00057.jpeg) |'
  prefs: []
  type: TYPE_TB
- en: '| `QgsEllipseSymbolLayerV2` | This displays a point geometry as an ellipse.
    | ![Working with symbol layers](img/00058.jpeg) |'
  prefs: []
  type: TYPE_TB
- en: '| `QgsFontMarkerSymbolLayerV2` | This displays a point geometry as a single
    character. You can choose the font and character to be displayed. | ![Working
    with symbol layers](img/00059.jpeg) |'
  prefs: []
  type: TYPE_TB
- en: '| `QgsSvgMarkerSymbolLayerV2` | This displays a point geometry using a single
    SVG format image. | ![Working with symbol layers](img/00060.jpeg) |'
  prefs: []
  type: TYPE_TB
- en: '| `QgsVectorFieldSymbolLayer` | This displays a point geometry by drawing a
    **displacement line**. One end of the line is the coordinate of the point, while
    the other end is calculated using attributes of the feature. | ![Working with
    symbol layers](img/00061.jpeg) |'
  prefs: []
  type: TYPE_TB
- en: '| `QgsSimpleLineSymbolLayerV2` | This displays a line geometry or the outline
    of a polygon geometry using a line of a given color, width, and style. | ![Working
    with symbol layers](img/00062.jpeg) |'
  prefs: []
  type: TYPE_TB
- en: '| `QgsMarkerLineSymbolLayerV2` | This displays a line geometry or the outline
    of a polygon geometry by repeatedly drawing a marker symbol along the length of
    the line. | ![Working with symbol layers](img/00063.jpeg) |'
  prefs: []
  type: TYPE_TB
- en: '| `QgsSimpleFillSymbolLayerV2` | This displays a polygon geometry by filling
    the interior with a given solid color and then drawing a line around the perimeter.
    | ![Working with symbol layers](img/00064.jpeg) |'
  prefs: []
  type: TYPE_TB
- en: '| `QgsGradientFillSymbolLayerV2` | This fills the interior of a polygon geometry
    using a color or grayscale gradient. | ![Working with symbol layers](img/00065.jpeg)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `QgsCentroidFillSymbolLayerV2` | This draws a simple dot at the centroid
    of a polygon geometry. | ![Working with symbol layers](img/00066.jpeg) |'
  prefs: []
  type: TYPE_TB
- en: '| `QgsLinePatternFillSymbolLayer` | This draws the interior of a polygon geometry
    using a repeated line. You can choose the angle, width, and color to use for the
    line. | ![Working with symbol layers](img/00067.jpeg) |'
  prefs: []
  type: TYPE_TB
- en: '| `QgsPointPatternFillSymbolLayer` | This draws the interior of a polygon geometry
    using a repeated point. | ![Working with symbol layers](img/00068.jpeg) |'
  prefs: []
  type: TYPE_TB
- en: '| `QgsSVGFillSymbolLayer` | This draws the interior of a polygon geometry using
    a repeated SVG format image. | ![Working with symbol layers](img/00069.jpeg) |'
  prefs: []
  type: TYPE_TB
- en: These predefined symbol layers, either individually or in various combinations,
    give you enormous flexibility in how features are to be displayed. However, if
    these aren't enough for you, you can also implement your own symbol layers using
    Python. We will look at how this can be done later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Combining symbol layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By combining symbol layers, you can achieve a range of complex visual effects.
    For example, you can combine an instance of `QgsSimpleMarkerSymbolLayerV2` with
    an instance of `QgsVectorFieldSymbolLayer` to display a point geometry using two
    symbols at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Combining symbol layers](img/00070.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'One of the main uses of symbol layers is to draw different LineString or PolyLine
    symbols to represent different types of roads. For example, you can draw a complex
    road symbol by combining multiple symbol layers, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Combining symbol layers](img/00071.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This effect is achieved by using three separate symbol layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Combining symbol layers](img/00072.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the Python code used to generate the preceding map symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, you can set the line width, color, and style to create whatever
    effect you want. As always, you have to define the layers in the correct order,
    with the back-most symbol layer defined first. By combining line symbol layers
    in this way, you can create almost any type of road symbol that you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use symbol layers when displaying polygon geometries. For example,
    you can draw `QgsPointPatternFillSymbolLayer` on top of `QgsSimpleFillSymbolLayerV2`
    to have repeated points on top of a simple filled polygon, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Combining symbol layers](img/00073.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, you can make use of **transparency** to allow the various symbol layers
    (or entire symbols) to blend into each other. For example, you can create a pinstripe
    effect by combining two symbol layers, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is quite subtle and visually pleasing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Combining symbol layers](img/00074.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In addition to changing the transparency for a symbol layer, you can also change
    the transparency for the symbol as a whole. This is done by using the `setAlpha()`
    method, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The result looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Combining symbol layers](img/00075.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that `setAlpha()` takes a floating point number between 0.0 and 1.0, while
    the transparency of a `QColor` object, like the ones we used earlier, is specified
    using an alpha value between 0 and 255.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing symbol layers in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If the built-in symbol layers aren''t flexible enough for your needs, you can
    implement your own symbol layers using Python. To do this, you create a subclass
    of the appropriate type of symbol layer (`QgsMarkerSymbolLayerV2`, `QgsLineSymbolV2`,
    or `QgsFillSymbolV2`) and implement the various drawing methods yourself. For
    example, here is a simple marker symbol layer that draws a cross for a Point geometry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this custom symbol layer in your code is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this code will draw a cross at the location of each point geometry,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing symbol layers in Python](img/00076.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Of course, this is a simple example, but it shows you how to use custom symbol
    layers implemented in Python. Let''s now take a closer look at the implementation
    of the `CrossSymbolLayer` class, and see what each method does:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__init__()`: Notice how the `__init__` method accepts parameters that customize
    the way the symbol layer works. These parameters, which should always have default
    values assigned to them, are the **properties** associated with the symbol layer.
    If you want to make your custom symbol available within the **QGIS Layer Properties**
    window, you will need to register your custom symbol layer and tell QGIS how to
    edit the symbol layer''s properties. We will look at this shortly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layerType()`: This method returns a unique name for your symbol layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`properties()`: This should return a dictionary that contains the various properties
    used by this symbol layer. The properties returned by this method will be stored
    in the QGIS project file, and used later to restore the symbol layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clone()`: This method should return a copy of the symbol layer. Since we have
    defined our properties as parameters to the `__init__` method, implementing this
    method simply involves creating a new instance of the class and copying the properties
    from the current symbol layer to the new instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`startRender()`: This method is called before the first feature in the map
    layer is rendered. This can be used to define any objects that will be required
    to draw the feature. Rather than creating these objects each time, it is more
    efficient (and therefore faster) to create them only once to render all the features.
    In this example, we create the `QPen` object that we will use to draw the Point
    geometries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stopRender()`: This method is called after the last feature has been rendered.
    This can be used to release the objects created by the `startRender()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`renderPoint()`: This is where all the work is done for drawing point geometries.
    As you can see, this method takes two parameters: the point at which to draw the
    symbol, and the **rendering context** (an instance of `QgsSymbolV2RenderContext`)
    to use for drawing the symbol.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rendering context provides various methods to access the feature being displayed,
    as well as information about the rendering operation, the current scale factor,
    and so on. Most importantly, it allows you to access the PyQt `QPainter` object
    required to actually draw the symbol on the screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `renderPoint()` method is only used for symbol layers that draw point geometries.
    For line geometries, you should implement the `renderPolyline()` method, which
    has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `points` parameter will be a `QPolygonF` object that contains the various
    points that make up the LineString, and `context` will be the rendering context
    to use to draw the geometry.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your symbol layer is intended to work with polygons, you should implement
    the `renderPolygon()` method, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, `outline` is a `QPolygonF` object that contains the points that make up
    the exterior of the polygon, and `rings` is a list of `QPolygonF` objects that
    define the interior rings or "holes" within the polygon. As always, `context`
    is the rendering context to use when drawing the geometry.
  prefs: []
  type: TYPE_NORMAL
- en: 'A custom symbol layer created in this way will work fine if you just want to
    use it within your own external PyQGIS application. However, if you want to use
    a custom symbol layer within a running copy of QGIS, and in particular, if you
    want to allow end users to work with the symbol layer using the **Layer Properties**
    window, there are some extra steps you will have to take, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want the symbol to be visually highlighted when the user clicks on it,
    you will need to change your symbol layer''s `renderXXX()` method to see if the
    feature being drawn has been selected by the user, and if so, change the way it
    is drawn. The easiest way to do this is to change the geometry''s color. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To allow the user to edit the symbol layer''s properties, you should create
    a subclass of `QgsSymbolLayerV2Widget`, which defines the user interface to edit
    the properties. For example, a simple widget for the purpose of editing the length
    and width of a `CrossSymbolLayer` can be defined as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We define the contents of our widget using the standard `__init__()` initializer.
    As you can see, we define two fields, `lengthField` and `widthField`, which let
    the user change the `length` and `width` properties respectively for our symbol
    layer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `setSymbolLayer()` method tells the widget which `QgsSymbolLayerV2` object
    to use, while the `symbolLayer()` method returns the `QgsSymbolLayerV2` object
    this widget is editing. Finally, the two `XXXChanged()` methods are called when
    the user changes the value of the fields, allowing us to update the symbol layer's
    properties to match the value set by the user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, you will need to register your symbol layer. To do this, create a
    subclass of `QgsSymbolLayerV2AbstractMetadata` and pass it to the `QgsSymbolLayerV2Registry`
    object''s `addSymbolLayerType()` method. Here is an example implementation of
    the metadata for our `CrossSymbolLayer` class, along with the code to register
    it within QGIS:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that the parameters for the `QgsSymbolLayerV2AbstractMetadata.__init__()`
    method are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: The unique name for the symbol layer, which must match the name returned
    by the symbol layer''s `layerType()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`visibleName`: A display name for this symbol layer, as shown to the user within
    the **Layer Properties** window.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type`: The type of symbol that this symbol layer will be used for.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `createSymbolLayer()` method is used to restore the symbol layer based on
    the properties stored in the QGIS project file when the project was saved. The
    `createSymbolLayerWidget()` method is called to create the user interface widget
    that lets the user view and edit the symbol layer's properties.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing renderers in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you need to choose symbols based on more complicated criteria than the built-in
    renderers will provide, you can write your own custom `QgsFeatureRendererV2` subclass
    using Python. For example, the following Python code implements a simple renderer
    that alternates between odd and even symbols as point features are displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this renderer will cause the various point geometries to be displayed
    in alternating colors, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing renderers in Python](img/00077.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a closer look at how this class was implemented, and what the various
    methods do:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__init__()`: This is your standard Python initializer. Notice how we have
    to provide a unique name for the renderer when calling the `QgsFeatureRendererV2.__init__()`
    method; this is used to keep track of the various renderers within QGIS itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clone()`: This creates a copy of this renderer. If your renderer uses properties
    to control how it works, this method should copy those properties into the new
    renderer object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`symbolForFeature()`: This returns the symbol to use for drawing the given
    feature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`startRender()`: This gives you the opportunity to prepare your renderer and
    any symbols you use before the features are rendered. Note that you must call
    the `startRender()` method on each symbol that your renderer uses; as the renderer
    can make use of multiple symbols, you need to implement this so that your symbols
    are also given a chance to prepare for rendering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stopRender()`: This finishes rendering the features. Once again, you need
    to implement this so that your symbols can have a chance to clean up once the
    rendering process has finished.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`usedAttributes()`: This method should be implemented to return the list of
    feature attributes that the renderer makes use of. If your renderer does not use
    attributes to choose between the various symbols, then you do not need to implement
    this method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you wish, you can also implement your own widget that lets the user change
    the way the renderer works. This is done by subclassing `QgsRendererV2Widget`
    and setting up the widget to edit the renderer's various properties in the same
    way that we implemented a subclass of `QgsSymbolLayerV2Widget` to edit the properties
    for a symbol layer. You will also need to provide metadata for your new renderer
    (by subclassing `QgsRendererV2AbstractMetadata`) and use the `QgsRendererV2Registry`
    object to register your new renderer. If you do this, the user will be able to
    select your custom renderer for new map layers, and change the way your renderer
    works by editing the renderer's properties.
  prefs: []
  type: TYPE_NORMAL
- en: Working with custom map layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of using a standard map layer with a data provider, features, symbols,
    and so on, you can implement your own **custom map layer** entirely in Python.
    Custom map layers are generally used to draw specific data that is too complicated
    to represent as vector format data, or to draw special visual features such as
    a grid or a watermark onto the map.
  prefs: []
  type: TYPE_NORMAL
- en: Custom map layers are implemented by subclassing the `QgsPluginLayer` class.
    The process is actually very simple, though you will need to translate between
    map and device coordinates so that the items you draw in your Python layer match
    up with the features drawn in the other layers within your canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't get confused by the name; you don't have to write a QGIS plugin to create
    your own `QgsPluginLayer` subclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we can create our own subclass of `QgsPluginLayer`. We''re going
    to create a simple grid that can appear as a layer within the map. Let''s start
    by defining the `QgsPluginLayer` subclass itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In our `__init__()` method, we give the plugin layer a unique name (`"GridLayer"`)
    and a user-visible name (`"Grid Layer"`), and then tell QGIS that the layer is
    valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to set up the coordinate reference system and extent of our layer.
    Since we''re creating a grid that covers the entire Earth, we''ll use the standard
    EPSG 4236 coordinate system (that is, latitude/longitude coordinates), and set
    the extent of the layer to cover the entire surface of the Earth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re now ready to define the method that draws the contents of the layer.
    As you might imagine, this method is called `draw()`. Let''s start by obtaining
    the `QPainter` object we''ll use to do the actual drawing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we want to find the portion of the Earth''s surface that is currently
    visible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the portion of the grid that we want to draw. To make sure the
    grid lines are on whole degrees of latitude and longitude, we round the extent
    up and down to the nearest whole number, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to set up the painter to draw the grid lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''re almost ready to start drawing the grid. To draw the grid lines,
    though, we''ll need some way of translating between latitude/longitude values
    and pixel coordinates on the computer screen. We''ll do this using a `QgsMapToPixel`
    object, which we can get from the rendering context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''re finally ready to draw the grid lines. Let''s start by drawing a
    vertical grid line on each whole degree of longitude:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then do the same for the horizontal grid lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to do is tell QGIS that our layer was drawn successfully.
    We do this by having our `draw()` method return `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This completes our implementation of the `GridLayer` class. If you want to
    use this class within a QGIS script or plugin, you will need to register the class
    so that QGIS knows about it. Fortunately, doing this is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this program within QGIS and add the `GridLayer` to your project,
    you''ll see the grid lines drawn on the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with custom map layers](img/00078.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Look carefully at the preceding image; you'll see that the grid lines are drawn
    in front of the polygon, but behind the circle. This is one of the main benefits
    of implementing your own map layer, as opposed to using a map canvas item; you
    can choose which layers appear in front or behind your custom map layer.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom map canvas items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A map canvas item is an item that is placed on top of the map canvas. Standard
    map canvas items include text annotations, vertex markers, and the visual highlighting
    of a feature. It is also possible to create your own custom map canvas items by
    subclassing `QgsMapCanvasItem`. To see how this works, let''s create a map canvas
    item that draws a compass rose onto the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating custom map canvas items](img/00079.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ll start by creating the basic `QgsMapCanvasItem` subclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we position the compass rose onto the map canvas by defining
    `center` and `size` instance variables, and provide methods to retrieve and set
    these values. We also implement the required `boundingRect()` method, which returns
    the overall bounding rectangle for the canvas item, in screen coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: This leaves us with the `paint()` method, which does the job of drawing the
    compass rose. While this method takes three parameters, the only parameter we'll
    be using is the first one, which is the `QPainter` object we will use to draw
    the compass rose.
  prefs: []
  type: TYPE_NORMAL
- en: 'The compass rose might look quite complicated, but the code needed to implement
    it is quite straightforward. The most complicated part is figuring out the dimensions
    of the `"N"`, `"S"`, `"E"`, and `"W"` labels so that we have enough room left
    for the compass rose itself. Let''s start by calculating some basic information
    about the labels that we are going to display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We calculate the size of the font to use for the labels (in points), and then
    set our painter to use a boldfaced `"Times"` font of that size. We then get a
    `QFontMetrics` object that we will use to calculate the labels' dimensions, and
    define a hardwired pixel margin so that we leave a gap between the label and the
    compass rose itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we want to draw the two central parts of the compass rose in light gray
    and black respectively. To do this, we''ll use a `QPainterPath` object to define
    the area to be filled in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we want to draw the labels at each of the four compass points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This completes the implementation of our `QgsMapCanvasItem` subclass. To use
    it, we simply have to create and initialize a new `CompassRoseItem`. Here is an
    example of how we can display a `CompassRoseItem` within the map canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Your new `QgsMapCanvasItem` will automatically be added to the map canvas when
    the object is initialized—you don''t need to explicitly add it to the canvas.
    To remove the compass rose from the map canvas, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note that map canvas items float above the map layers, and unfortunately, cannot
    directly interact with the user—you can't intercept and respond to mouse events
    using a map canvas item.
  prefs: []
  type: TYPE_NORMAL
- en: Using memory-based layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While a map layer would normally display geospatial data taken from an external
    data source such as a shapefile, a raster DEM file, or a database, it is also
    possible to create geospatial features directly from your Python code. For example,
    imagine that you write a program to display the halfway point along a road. This
    halfway point could be represented as a `QgsPoint` geometry, which would be displayed
    on the map using an appropriate marker symbol. Since you are calculating the point,
    this isn't a feature you would want to store in a shapefile or database. Rather,
    the feature is calculated and displayed when your program is run.
  prefs: []
  type: TYPE_NORMAL
- en: This is an ideal application for a memory-based layer. This type of layer stores
    geospatial features in memory, allowing you to create new features on the fly
    and display them within a map layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a memory-based map layer, instantiate a new `QgsVectorLayer` object,
    just like normal. The initializer for this class looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is slightly simplified—there is another parameter, `loadDefaultStyleFlag`,
    which doesn't apply to memory-based layers. Fortunately, there's a default value
    for this parameter, so we can ignore it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the three parameters needed to create a memory-based
    map layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '`path`: This string provides information that is needed to create the memory-based
    layer, including the type of information that the layer will store. We will look
    at this parameter in more detail shortly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`baseName`: This is the name used for the memory-based layer. The name can
    be anything you like, though the user will see it in the QGIS layer legend.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`providerLib`: This should be set to `"memory"` for memory-based layers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To create a simple memory-based layer, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This will create a memory-based layer named `"My Layer"`, which stores polygon
    features with no attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `path` parameter will let us do much more than simply define the type of
    geometry to be stored in the layer. The `path` parameter has the following overall
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This URL-like syntax starts with the type of geometry, and can have any number
    of key/value pairs that provide additional information about the memory layer.
    The following geometry types are currently supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Point`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LineString`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Polygon`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MultiPoint`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MultiLineString`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MultiPolygon`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the key/value pairs, you can also define:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The coordinate reference system that the layer should use. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The coordinate reference system can be defined using a CRS authority code,
    as in the preceding example, or you can specify the CRS in WKT format, for example:
    `crs=+proj=longlat +a=69000 +b=55000 +no_defs`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If you don't define the coordinate reference system in this way, QGIS will prompt
    the user to select a CRS when your program is run. This could be very confusing
    for the user, so you should always specify a CRS when you create a memory layer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Attributes to store for each feature within the layer. Here is an example of
    an attribute definition:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following types of fields are currently supported:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`integer`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`double`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`string`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also specify the field length and precision by listing these in parentheses,
    for example, `field=height:double(10,2)` or `field=name:string(50)`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you want to have multiple attributes, you simply have one `field=...`entry
    for each of the attributes you want to define.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The memory layer's data provider has an `addAttributes()` method, which you
    might assume you'd use to define the attributes. However, the `addAttributes()`
    method only adds the attributes to the data provider, not the map layer, which
    can cause QGIS to crash. To avoid this, it is better to define your attributes
    within the path when you set up your map layer, rather than trying to add them
    later.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A spatial index for this layer''s features:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s use this to create a more complex memory layer that stores point geometries
    using a specified coordinate reference system, a spatial index, and some attributes.
    Here is how we might do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve instantiated our memory layer, we can create the various features
    we want to display, and then add them to the layer. The following pseudocode shows
    how this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we define the various features (which are instances of `QgsFeature`),
    and then add them all at once to the memory layer. You can add the features one
    at a time, of course, but it's generally more efficient to define a list of features
    and add them all at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now see how we can create a feature. We start by defining the underlying
    geometry that the feature will display. There are various ways of creating geometries,
    including:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instantiating a `QgsPoint`, `QgsPolyLine`, `QgsPolygon`, or related object,
    and then using this to create a `QgsGeometry` object using one of the `QgsGeometry.fromXXX()`
    methods. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Creating a WKT-format string that represents the geometry, and then creating
    the `QgsGeometry` object using this string. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Creating a new `QgsGeometry` object out of an existing geometry by using one
    of the geometry manipulation methods. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we have the geometry, we''re ready to create the `QgsFeature` object itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we want to set the attributes for this feature. Before we can do this
    though, we need to tell the feature which attributes it will store. This is done
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can set the attribute values. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Putting all this together, let''s build a complete example program that creates
    a memory layer, populates it with a few `QgsPoint` features, and updates the map
    canvas to show those points. Here is this example program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this program from within QGIS will create a new memory-based map layer
    named `"Point Layer"` with three features in it, which represent the location
    of three famous towers in Western Europe:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using memory-based layers](img/00080.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: To make this example useful, we would add symbols to draw the towers in a more
    meaningful way, and probably also display the name and height as a label beside
    each point. However, you can see how a memory layer can be used to create spatial
    data from within your program and include it as a layer within the map.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you aren't limited to using memory layers to represent actual geospatial
    data. You could just as easily use the memory layer to display information that
    doesn't represent a location. For example, you can use a memory layer to draw
    arrows onto a map, or to shade certain areas of the map using a semi-transparent
    polygon. Memory-based map layers are an extremely powerful tool, and one that
    you will often use when writing your own programs based on QGIS.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at many of the more advanced features of the QGIS
    Python API. We learned how the various built-in symbol layers can be used to draw
    geometries on the map, how to combine symbol layers in useful ways, and how to
    implement your own symbol layers using Python. We then looked at writing your
    own custom renderer to choose which symbol to use for each feature, and how to
    create your own custom map layer using Python code. We investigated the creation
    of custom map canvas items, and then saw how memory-based map layers can be used
    to programmatically add features to your map.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we complete our tour of the more advanced aspects of PyQGIS. In the
    next chapter, we will learn how to create custom map tools that let the user select,
    add, edit, and delete features within a PyQGIS application.
  prefs: []
  type: TYPE_NORMAL
