- en: Chapter 6. Enhancing a Version
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。增强版本
- en: Traditionally, changes are usually not welcomed and are avoided as much as possible
    by a relational database developer. However, business changes every day, especially
    in the present fast-paced era. The delayed response to business changes of a system
    using a relational database deteriorates the agility and even threatens the survival
    of the enterprise. With the advancement of NoSQL and other related technologies,
    we now have alternatives to embrace such business changes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，更改通常不受欢迎，并且关系型数据库开发人员会尽可能地避免更改。然而，业务每天都在变化，尤其是在当前这个快节奏的时代。使用关系型数据库的系统对业务变化的延迟响应会降低企业的敏捷性，甚至威胁到企业的生存。随着NoSQL和其他相关技术的发展，我们现在有替代方案来拥抱这样的业务变化。
- en: By continuing with the enhancements of the Stock Screener Application developed
    in [Chapter 5](ch05.html "Chapter 5. First-cut Design and Implementation"), *First-cut
    Design and Implementation*, the techniques of how to evolve an existing Cassandra
    data model will be explained in detail. Meanwhile, the techniques of modeling
    by query will be demonstrated as well. The source code of the Stock Screener Application
    will then be modified accordingly. By the end of this chapter, a complete technical
    analysis application on stocks will be developed. You can use it as a foundation
    to quickly develop your own.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通过继续增强在第5章[“初步设计和实现”](ch05.html "第5章。初步设计和实现")中开发的股票筛选器应用程序，将详细解释如何演进现有的Cassandra数据模型的技术。同时，还将展示查询建模技术。然后，将相应地修改股票筛选器应用程序的源代码。到本章结束时，将开发一个完整的股票技术分析应用程序。您可以用它作为快速开发您自己的基础。
- en: Evolving the data model
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化数据模型
- en: The Stock Screener Application created in [Chapter 5](ch05.html "Chapter 5. First-cut
    Design and Implementation"), *First-cut Design and Implementation*, is good enough
    to retrieve and analyze a single stock at one time. However, scanning just a single
    stock looks very limited in practical use. A slight improvement can be made here;
    it can handle a bunch of stocks instead of one. This bunch of stocks will be stored
    as Watch List in the Cassandra database.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.html "第5章。初步设计和实现")中创建的股票筛选器应用程序，*初步设计和实现*，足以一次检索和分析一只股票。然而，在实际应用中，仅扫描一只股票看起来非常有限。这里可以稍作改进；它可以处理一组股票而不是单个股票。这组股票将被存储在Cassandra数据库中的观察名单中。
- en: Accordingly, the Stock Screener Application will be modified to analyze the
    stocks in the Watch List, and therefore it will produce alerts for each of the
    stocks being watched based on the same screening rule.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，股票筛选器应用程序将被修改以分析观察名单中的股票，因此它将根据相同的筛选规则为每个被观察的股票生成警报。
- en: For the produced alerts, saving them in Cassandra will be beneficial for backtesting
    trading strategies and continuous improvement of the Stock Screener Application.
    They can be reviewed from time to time without having to review them on the fly.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对于产生的警报，将它们保存在Cassandra中将有利于回测交易策略和持续改进股票筛选器应用程序。它们可以不时地被审查，而无需即时审查。
- en: Note
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Backtesting is a jargon used to refer to testing a trading strategy, investment
    strategy, or a predictive model using existing historical data. It is also a special
    type of cross-validation applied to time series data.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 回测是一个术语，用于指用现有历史数据测试交易策略、投资策略或预测模型。它也是应用于时间序列数据的一种特殊类型的交叉验证。
- en: In addition, when the number of the stocks in the Watch List grows to a few
    hundred, it will be difficult for a user of the Stock Screener Application to
    recall what the stocks are by simply referring to their stock codes. Hence, it
    would be nice to have the name of the stocks added to the produced alerts to make
    them more descriptive and user-friendly.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当观察名单中的股票数量增长到几百只时，股票筛选器应用程序的用户将很难仅通过参考它们的股票代码来回忆起这些股票。因此，最好将股票名称添加到生成的警报中，使它们更具描述性和用户友好性。
- en: Finally, we might have an interest in finding out how many alerts were generated
    on a particular stock over a specified period of time and how many alerts were
    generated on a particular date. We will use CQL to write queries to answer these
    two questions. By doing so, the modeling by query technique can be demonstrated.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可能对找出在特定时间段内特定股票上生成的警报数量以及特定日期上生成的警报数量感兴趣。我们将使用CQL编写查询来回答这两个问题。通过这样做，可以展示查询建模技术。
- en: The enhancement approach
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增强方法
- en: The enhancement approach consists of four change requests in total. First, we
    will conduct changes in the data model and then the code will be enhanced to provide
    the new features. Afterwards, we will test run the enhanced Stock Screener Application
    again. The parts of the Stock Screener Application that require modifications
    are highlighted in the following figure.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 增强方法总共包括四个变更请求。首先，我们将对数据模型进行更改，然后代码将增强以提供新功能。之后，我们将再次测试运行增强的股票筛选应用程序。以下图中突出显示了需要修改的股票筛选应用程序的部分。
- en: 'It is remarkable that two new components are added to the Stock Screener Application.
    The first component, **Watch List**, governs **Data Mapper and Archiver** to collect
    stock quote data of those stocks in the Watch List from Yahoo! Finance. The second
    component is **Query**. It provides two Queries on **Alert List** for backtesting
    purposes:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，股票筛选应用程序中增加了两个新组件。第一个组件是 **观察列表**，它管理 **数据映射器和存档器**，以从 Yahoo! Finance
    收集观察列表中股票的股票报价数据。第二个组件是 **查询**。它提供了两个针对 **警报列表**的查询，用于回测目的：
- en: '![The enhancement approach](img/8884OS_06_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![增强方法](img/8884OS_06_01.jpg)'
- en: Watch List
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 观察列表
- en: '**Watch List** is a very simple table that merely stores the stock code of
    its constituents. It is rather intuitive for a relational database developer to
    define the stock code as the primary key, isn''t it? Nevertheless, remember that
    in Cassandra, the primary key is used to determine the node that stores the row.
    As Watch List is expected to not be a very long list, it would be more appropriate
    to put all of its rows on the same node for faster retrieval. But how can we do
    that?'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**观察列表**是一个非常简单的表，仅存储其组成部分的股票代码。对于关系型数据库开发者来说，将股票代码定义为主键是非常直观的，对吧？然而，请记住，在
    Cassandra 中，主键用于确定存储行的节点。由于观察列表预计不会非常长，将其所有行放在同一个节点上以实现更快的检索会更合适。但我们应该如何做到这一点呢？'
- en: 'We can create an additional column, say `watch_list_code`, for this particular
    purpose. The new table is called `watchlist` and will be created in the `packtcdma`
    keyspace. The CQL statement is shown in `chapter06_001.py`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为此特定目的创建一个额外的列，例如 `watch_list_code`。新表称为 `watchlist`，并将创建在 `packtcdma` 键空间中。CQL
    语句显示在 `chapter06_001.py` 中：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `create_watchlist` function creates the table. Note that the `watchlist`
    table has a compound primary key made of `watch_list_code` and `symbol`. A Watch
    List called `WS01` is also created, which contains three stocks, `AAPL`, `AMZN`,
    and `GS`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_watchlist` 函数创建表。请注意，`watchlist` 表由 `watch_list_code` 和 `symbol` 组成的复合主键构成。还创建了一个名为
    `WS01` 的观察列表，其中包含三只股票，`AAPL`、`AMZN` 和 `GS`。'
- en: Alert List
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警报列表
- en: In [Chapter 5](ch05.html "Chapter 5. First-cut Design and Implementation"),
    *First-cut Design and Implementation*, **Alert List** is very rudimentary. It
    is produced by a Python program and enumerates the date when the close price was
    above its 10-day SMA, that is, the signal and the close price at that time. Note
    that there were no stock code and stock name.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 5 章](ch05.html "第 5 章。初步设计和实现")，*初步设计和实现* 中，**警报列表**非常基础。它由一个 Python 程序生成，列出了收盘价高于其
    10 日简单移动平均线的日期，即当时的信号和收盘价。请注意，当时没有股票代码和股票名称。
- en: We will create a table called `alertlist` to store the alerts with the code
    and name of the stock. The inclusion of the stock name is to meet the requirement
    of making the Stock Screener Application more user-friendly. Also, remember that
    joins are not allowed and denormalization is really the best practice in Cassandra.
    This means that we do not mind repeatedly storing (duplicating) the stock name
    in the tables that will be queried. A rule of thumb is *one table for one query*;
    as simple as that.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为 `alertlist` 的表来存储警报，包括股票的代码和名称。包含股票名称是为了满足使股票筛选应用程序更用户友好的要求。同时，请记住，不允许使用连接，并且在
    Cassandra 中去规范化确实是最佳实践。这意味着我们不会介意在将要查询的表中重复存储（复制）股票名称。一个经验法则是 *一个表对应一个查询*；就这么简单。
- en: 'The `alertlist` table is created by the CQL statement, as shown in `chapter06_002.py`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`alertlist` 表是通过 CQL 语句创建的，如 `chapter06_002.py` 中所示：'
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The primary key is also a compound primary key that consists of `symbol` and
    `price_time`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 主键也是一个复合主键，由 `symbol` 和 `price_time` 组成。
- en: Adding the descriptive stock name
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加描述性股票名称
- en: Until now, the `packtcdma` keyspace has three tables, which are `alertlist`,
    `quote`, and `watchlist`. To add the descriptive stock name, one can think of
    only adding a column of stock name to `alertlist` only. As seen in the previous
    section, this has been done. So, do we need to add a column for `quote` and `watchlist`?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`packtcdma`键空间有三个表，分别是`alertlist`、`quote`和`watchlist`。为了添加描述性的股票名称，人们可能会想到只向`alertlist`添加一个股票名称列。如前所述，这已经完成了。那么，我们是否需要为`quote`和`watchlist`添加列？
- en: It is, in fact, a design decision that depends on whether these two tables will
    be serving user queries. What a user query means is that the table will be used
    to retrieve rows for a query raised by a user. If a user wants to know the close
    price of Apple Inc. on June 30, 2014, it is a user query. On the other hand, if
    the Stock Screener Application uses a query to retrieve rows for its internal
    processing, it is not a user query. Therefore, if we want `quote` and `watchlist`
    to return rows for user queries, they need the stock name column; otherwise, they
    do not need it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这是一个设计决策，取决于这两个表是否将用于处理用户查询。用户查询的含义是，该表将用于检索用户提出的查询所需的行。如果用户想知道2014年6月30日苹果公司的收盘价，这便是一个用户查询。另一方面，如果股票筛选应用程序使用查询来检索其内部处理的行，那么这便不是用户查询。因此，如果我们想让`quote`和`watchlist`为用户查询返回行，它们就需要包含股票名称列；否则，它们不需要。
- en: The `watchlist` table is only for internal use by the current design, and so
    it need not have the stock name column. Of course, if in future, the Stock Screener
    Application allows a user to maintain Watch List, the stock name should also be
    added to the `watchlist` table.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`watchlist`表仅用于当前设计的内部使用，因此它不需要包含股票名称列。当然，如果将来股票筛选应用程序允许用户维护股票观察列表，那么股票名称也应该添加到`watchlist`表中。'
- en: 'However, for `quote`, it is a bit tricky. As the stock name should be retrieved
    from the Data Feed Provider, which is Yahoo! Finance in our case, the most suitable
    time to get it is when the corresponding stock quote data is retrieved. Hence,
    a new column called `stock_name` is added to `quote`, as shown in `chapter06_003.py`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于`quote`来说，这有点棘手。因为股票名称应该从数据提供者那里检索，在我们的案例中是雅虎财经，最适合获取股票名称的时间是在检索相应的股票报价数据时。因此，在`quote`中添加了一个名为`stock_name`的新列，如`chapter06_003.py`所示：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It is quite self-explanatory. Here, we use the `ALTER TABLE` statement to add
    the `stock_name` column of the `varchar` data type to `quote`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当直观。在这里，我们使用`ALTER TABLE`语句向`quote`添加了`varchar`数据类型的`stock_name`列。
- en: Queries on alerts
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警报查询
- en: 'As mentioned previously, we are interested in two questions:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们感兴趣的是两个问题：
- en: How many alerts were generated on a stock over a specified period of time?
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在指定时间段内，针对某只股票生成了多少个警报？
- en: How many alerts were generated on a particular date?
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在特定日期上生成了多少个警报？
- en: For the first question, `alertlist` is sufficient to provide an answer. However,
    `alertlist` cannot answer the second question because its primary key is composed
    of `symbol` and `price_time`. We need to create another table specifically for
    that question. This is an example of modeling by query.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个问题，`alertlist`足以提供答案。然而，`alertlist`无法回答第二个问题，因为它的主键由`symbol`和`price_time`组成。我们需要为这个问题创建另一个特定的表。这是一个通过查询建模的例子。
- en: 'Basically, the structure of the new table for the second question should resemble
    the structure of `alertlist`. We give that table a name, `alert_by_date`, and
    create it as shown in `chapter06_004.py`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，第二个问题的新表结构应该类似于`alertlist`的结构。我们给这个表起了一个名字，`alert_by_date`，并在`chapter06_004.py`中创建了它：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When compared to `alertlist` in `chapter06_002.py`, `alert_by_date` only swaps
    the order of the columns in the compound primary key. One might think that a secondary
    index can be created on `alertlist` to achieve the same effect. Nonetheless, in
    Cassandra, a secondary index cannot be created on columns that are already engaged
    in the primary key. Always be aware of this constraint.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 与`chapter06_002.py`中的`alertlist`相比，`alert_by_date`只是在复合主键中交换了列的顺序。有人可能会认为可以在`alertlist`上创建一个二级索引来实现相同的效果。然而，在Cassandra中，不能在已经参与主键的列上创建二级索引。始终要注意这个限制。
- en: We now finish the modifications on the data model. It is time for us to enhance
    the application logic in the next section.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在完成了数据模型的修改。接下来，我们需要增强下一节中的应用逻辑。
- en: Enhancing the code
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码增强
- en: Regarding the new requirements to be incorporated into the Stock Screener Application,
    Watch List is created, and we will continue to implement the code for the remaining
    changes in this section.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 关于要纳入股票筛选应用程序的新要求，已创建观察列表，我们将在本节中继续实现剩余更改的代码。
- en: Data Mapper and Archiver
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据映射器和归档器
- en: 'Data Mapper and Archiver are components of the Data Feed Provider module, and
    its source code file is `chapter05_005.py`. Most of the source code can be left
    intact; we only need to add code to:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 数据映射器和归档器是数据馈送提供器模块的组件，其源代码文件是`chapter05_005.py`。大部分源代码可以保持不变；我们只需要添加代码到：
- en: Load Watch List for a Watch List code and retrieve data feed based on that
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为观察列表代码加载观察列表并检索基于该列表的数据馈送
- en: Retrieve the name of the stocks and store it in the quote table
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检索股票名称并将其存储在报价表中
- en: 'The modified source code is shown in `chapter06_005.py`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的源代码显示在`chapter06_005.py`中：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, we changed the `INSERT` statement to store the stock name into `quote`
    in the `insert_quote` function. We then add a function called `load_watchlist`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`INSERT`语句修改为在`insert_quote`函数中将股票名称存储到`quote`中。然后我们添加一个名为`load_watchlist`的函数：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, the new function, `load_watchlist`, submits a `SELECT` query on `watch_list`
    to retrieve the stocks to be watched of a particular Watch List code; it then
    returns a list of `symbol`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，新函数`load_watchlist`对`watch_list`执行`SELECT`查询，以检索特定观察列表代码的观察股票；然后它返回一个`symbol`列表：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The change here is a new function named `get_stock_name`, which sends a web
    service request to Yahoo! Finance and extracts the name of the stock from the
    returned HTML page. We use a Python package called `BeautifulSoup` to make the
    extraction of an element from a HTML page very convenient. The `get_stock_name`
    function then returns the stock name.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的更改是一个名为`get_stock_name`的新函数，它向Yahoo! Finance发送一个网络服务请求，并从返回的HTML页面中提取股票名称。我们使用一个名为`BeautifulSoup`的Python包来使从HTML页面中提取元素变得非常方便。然后`get_stock_name`函数返回股票名称。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`BeautifulSoup` is a library designed for quick turnaround projects such as
    screen scraping. It primarily parses any text given to it and finds anything wanted
    through the tree traversal of the parsed text. More information can be found at
    [http://www.crummy.com/software/BeautifulSoup/](http://www.crummy.com/software/BeautifulSoup/).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`BeautifulSoup`是一个为快速周转项目如屏幕抓取而设计的库。它主要解析它所接收的任何文本，并通过解析文本的树遍历找到所需的内容。更多信息可以在[http://www.crummy.com/software/BeautifulSoup/](http://www.crummy.com/software/BeautifulSoup/)找到。'
- en: A `for` loop is used to iterate through the Watch List to retrieve the stock
    name and the stock quote data. In addition, as we need to store the stock name
    in the `quote` table, the `insert_quote` function accepts the stock name as a
    new parameter and requires a little modification on the `INSERT` statement and
    the `for` loop accordingly.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`for`循环遍历观察列表以检索股票名称和股票报价数据。此外，由于我们需要将股票名称存储在`quote`表中，`insert_quote`函数接受股票名称作为新参数，并相应地对`INSERT`语句和`for`循环进行少量修改。
- en: That is all about the changes on Data Mapper and Archiver.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是关于数据映射器和归档器更改的全部内容。
- en: Stock Screener Engine
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 股票筛选引擎
- en: 'We will use the source code of Stock Screener Engine in [Chapter 5](ch05.html
    "Chapter 5. First-cut Design and Implementation"), *First-cut Design and Implementation*
    to include the enhancements; to do so, we will perform the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用[第5章](ch05.html "第5章. 初步设计和实现")中Stock Screener Engine的源代码，*初步设计和实现*来包含增强功能；为此，我们将执行以下操作：
- en: Similar to Data Mapper and Archiver, we will load Watch List for a Watch List
    code and scan for alerts on each stock.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与数据映射器和归档器类似，我们将为观察列表代码加载观察列表并在每个股票上扫描警报。
- en: Retrieve stock quote data with the stock name column from the quote table.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从报价表中的股票名称列检索股票报价数据。
- en: Save the alerts into `alertlist`.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将警报保存到`alertlist`中。
- en: 'The modified source code is shown in `chapter06_006.py`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的源代码显示在`chapter06_006.py`中：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As we have included the stock name in the query resultset, we need to modify
    the `SELECT` statement in the `retrieve_data` function:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经将股票名称包含在查询结果集中，我们需要修改`retrieve_data`函数中的`SELECT`语句：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: At the bottom of `chapter06_006.py`, the `for` loop is responsible for iterating
    `watchlist` loaded by the new `load_watchlist` function, which is the same function
    as in `chapter06_005.py` and does not require further explanation. Another `for`
    loop inside saves the scanned alerts into `alertlist` by calling the new `insert_alert`
    function.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `chapter06_006.py` 的底部，`for` 循环负责迭代由新的 `load_watchlist` 函数加载的 `watchlist`，这个函数与
    `chapter06_005.py` 中的函数相同，不需要进一步解释。另一个 `for` 循环内部通过调用新的 `insert_alert` 函数将扫描到的警报保存到
    `alertlist`。
- en: Before explaining the `insert_alert` function, let us jump to the `retrieve_data`
    function at the top. The `retrieve_data` function is modified to return the name
    of the stock as well and hence the `cols` variable now contains six columns. Scroll
    down a bit to `insert_alert`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释 `insert_alert` 函数之前，让我们跳转到顶部的 `retrieve_data` 函数。`retrieve_data` 函数被修改为同时返回股票名称，因此
    `cols` 变量现在包含六个列。向下滚动一点到 `insert_alert`。
- en: The `insert_alert` function, as its name suggests, saves the alert into `alertlist`
    and `alert_by_date`. It has two `INSERT` statements for these two tables, respectively.
    The `INSERT` statements are almost identical except for the name of the table.
    Obviously, they are repeated, and this is what denormalization means. We also
    apply a new feature of Cassandra 2.0 here, known as *batch*. A batch combines
    multiple **data modification language** (**DML**) statements into a single logical,
    atomic operation. The Cassandra Python driver from DataStax supports this feature
    by the `BatchStatement` package. We create a batch by calling the `BatchStatement()`
    function, then add the prepared `INSERT` statements into the batch, and finally
    execute it. If either `INSERT` statement comes across an error during commit,
    all DML statements in the batch will not be executed. Therefore, it is analogous
    to a transaction in a relational database.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，`insert_alert` 函数将警报保存到 `alertlist` 和 `alert_by_date`。它为这两个表分别有两个 `INSERT`
    语句。这两个 `INSERT` 语句几乎完全相同，只是表名不同。显然，它们是重复的，这就是反规范化的含义。我们在这里还应用了 Cassandra 2.0 的新特性，称为
    *批处理*。批处理将多个 **数据修改语言** (**DML**) 语句组合成一个单一的逻辑、原子操作。DataStax 的 Cassandra Python
    驱动程序通过 `BatchStatement` 包支持此功能。我们通过调用 `BatchStatement()` 函数创建一个批处理，然后将准备好的 `INSERT`
    语句添加到批处理中，最后执行它。如果在提交过程中任一 `INSERT` 语句遇到错误，批处理中的所有 DML 语句将不会执行。因此，这与关系型数据库中的事务类似。
- en: Queries on Alerts
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警报查询
- en: 'The last modification to the Stock Screener Application is the enquiry functions
    on alerts that are useful for backtesting and performance measurement. We write
    two queries to answer the two questions, which are as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Stock Screener 应用程序的最后一次修改是关于警报的查询功能，这些功能对回测和性能测量很有用。我们编写了两个查询来回答两个问题，如下所示：
- en: How many alerts were generated on a stock over a specified period of time?
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在指定时间段内，一只股票产生了多少个警报？
- en: How many alerts were generated on a particular date?
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在特定日期上产生了多少个警报？
- en: 'As we have used denormalization on the data model, it is very easy to execute.
    For the first query, see `chapter06_007.py`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在数据模型上使用了反规范化，因此执行起来非常容易。对于第一次查询，请参阅 `chapter06_007.py`：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A function named `alert_over_daterange` is defined to retrieve the rows relevant
    to the first question. Then it transforms the CQL resultset to a pandas DataFrame.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了一个名为 `alert_over_daterange` 的函数来检索与第一个问题相关的行，然后将其转换为 pandas DataFrame。
- en: 'Then we can come up with a query for the second question with reference to
    the same logic in `chapter06_007.py`. The source code is shown in `chapter06_008.py`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以根据 `chapter06_007.py` 中的相同逻辑来为第二个问题编写查询。源代码显示在 `chapter06_008.py`：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once again, denormalization is a friend of Cassandra. It does not require a
    foreign key, referential integrity, or table join.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，反规范化是 Cassandra 的朋友。它不需要外键、引用完整性或表连接。
- en: Implementing system changes
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现系统更改
- en: 'We can now implement the changes to the system one-by-one:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以逐个实现系统更改：
- en: First we run `chapter06_001.py` through to `chapter06_004.py` in sequence to
    make changes to the data model.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们按顺序运行 `chapter06_001.py` 到 `chapter06_004.py`，以对数据模型进行修改。
- en: Then we execute `chapter06_005.py` to retrieve stock quote data for the Watch
    List. It is worth mentioning that UPSERT is a very nice feature of Cassandra.
    We do not encounter a duplicate primary key while we insert the same row into
    a table. It simply updates the row if the row already exists or inserts the row
    otherwise. It makes the data manipulation logic neat and clean.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们执行`chapter06_005.py`以检索观察列表的股票报价数据。值得一提的是，UPSERT是Cassandra的一个非常好的特性。当我们向表中插入相同的行时，我们不会遇到重复的主键。如果行已存在，它将简单地更新该行，否则将插入该行。这使得数据操作逻辑变得整洁且清晰。
- en: Further, we run `chatper06_006.py` to store the alerts by scanning over the
    stock quote data of each stock in the Watch List.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们运行`chatper06_006.py`通过扫描观察列表中每只股票的股票报价数据来存储警报。
- en: Finally, we execute `chapter06_007.py` and `chapter06_008.py` to enquire `alertlist`
    and `alert_by_date`, respectively. Their sample test results are shown in the
    following figure:![Implementing system changes](img/8884OS_06_02.jpg)
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们执行`chapter06_007.py`和`chapter06_008.py`来查询`alertlist`和`alert_by_date`，其样本测试结果如下：![实施系统更改](img/8884OS_06_02.jpg)
- en: Summary
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter extends the Stock Screener Application by a number of enhancements.
    We made changes to the data model to demonstrate the modeling by query techniques
    and how denormalization can help us achieve a high-performance application. We
    also tried the batch feature provided by Cassandra 2.0.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过一系列增强扩展了股票筛选应用程序。我们对数据模型进行了修改，以展示通过查询技术建模以及非规范化如何帮助我们实现高性能应用程序。我们还尝试了Cassandra
    2.0提供的批量功能。
- en: Note that the source code in this chapter is not housekept and can be refactored
    somehow. However, because of the limit on the number of pages, it is left as an
    exercise for the reader.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，本章中的源代码未经整理，可以进行某种重构。然而，由于页面数量的限制，它被留作读者的练习。
- en: The Stock Screener Application is now running on a single node cluster.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 股票筛选应用程序现在运行在单个节点集群上。
- en: In the next chapter, we will delve into the considerations and procedures of
    expanding it to a larger cluster, which is quite common in real-life production
    systems.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨将其扩展到更大集群的考虑和流程，这在现实生活中的生产系统中相当常见。
