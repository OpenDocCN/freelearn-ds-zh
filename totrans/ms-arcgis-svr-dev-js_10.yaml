- en: Chapter 10. Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。测试
- en: When you publish a website or a web application to the public, users expect
    it to work. Links are supposed to take their places, and buttons are supposed
    to do things. They may not have the technical knowhow to look in good their browser
    console or observe network traffic. They may even have good reason to disable
    JavaScript on their browser.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将网站或网络应用程序发布给公众时，用户期望它能正常工作。链接应该占据它们的位置，按钮应该执行它们的功能。他们可能没有足够的技能去检查浏览器控制台或观察网络流量。他们甚至有充分的理由在浏览器中禁用JavaScript。
- en: The truth is, sometimes websites don't work because of hardware, software, or
    user error, but at other times the cause comes from the developer's buggy code.
    Maybe the code was pieced together from a cut-and-paste collage of code samples
    and stack overflow answers. Then the developer rushes to test the application
    once or twice, using the same workflow they use every time they write a component.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，有时网站无法正常工作是因为硬件、软件或用户错误，但有时原因来自开发者的有缺陷的代码。也许代码是从代码样本和Stack Overflow答案的剪切和粘贴拼贴画中拼凑起来的。然后开发者匆忙测试应用程序一次或两次，使用他们每次编写组件时都使用的相同工作流程。
- en: Maybe, though, something changed outside of the developer's control. Maybe a
    feature attribute that once held numeric values now contains strings. Maybe the
    API was updated and there was a fundamental change in the application. Maybe a
    REST data service is down, or maybe some bored kid is trying to input random data
    or malicious SQL injection code to bring down the website.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也许有些事情超出了开发者的控制范围。也许曾经包含数字值的功能属性现在包含字符串。也许API已更新，应用程序发生了根本性的变化。也许REST数据服务宕机了，或者也许有些无聊的孩子正在尝试输入随机数据或恶意SQL注入代码来使网站崩溃。
- en: Testing through code
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过代码进行测试
- en: These are all good reasons to create tests for your applications. Testing is
    one method of ensuring that your code does as expected. It defines clear use cases,
    with clearly defined, expected results. Testing also acts as a sort of project
    documentation. It tells other developers who work with the project how the code
    is supposed to behave.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是为你的应用程序创建测试的良好理由。测试是确保你的代码按预期执行的一种方法。它定义了明确的用例，具有明确定义的预期结果。测试还充当一种项目文档。它告诉其他与项目合作的开发者代码应该如何表现。
- en: Now that you understand why testing is important, let's look at the testing
    methodologies used by other developers over the years.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了为什么测试很重要，让我们来看看多年来其他开发者所使用的测试方法。
- en: Unit testing
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit testing is when individual components or modules of code are loaded into
    a testing framework and tested individually. Tests are developed and results are
    compared to expected values. For object-oriented programming, individual objects
    can be loaded and tested without having to wait for other components to load.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是指将单个组件或代码模块加载到测试框架中并单独进行测试。测试被开发出来，结果与预期值进行比较。对于面向对象的编程，可以加载并测试单个对象，而无需等待其他组件加载。
- en: JavaScript objects and modules lend themselves well to unit testing. Developers
    can write scripts to load modules individually, pass values into functions and
    objects, and see what comes out. Passing the tests ensures the JavaScript modules
    and objects will perform as far as expected test cases go.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript对象和模块非常适合单元测试。开发者可以编写脚本来单独加载模块，将值传递给函数和对象，并查看输出结果。通过测试确保JavaScript模块和对象将按照预期的测试案例执行。
- en: However, unit testing doesn't prevent all errors. While they tests the input
    and output of objects and functions, they don't test how these objects interact.
    What happens when two or more memory-intense modules are running in the same browser?
    What happens to module A when input expected from module B times out? Also, unit
    testing doesn't address user experience concerns. It's hard to write a unit test
    for a map that pans slower than I think it should. Clearly, unit testing can't
    be the only tool in your testing tool belt.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，单元测试并不能防止所有错误。虽然它们测试了对象和函数的输入和输出，但它们并没有测试这些对象是如何交互的。当两个或更多内存密集型模块在同一浏览器中运行时会发生什么？当从模块B期望的输入超时时，模块A会发生什么？此外，单元测试也没有解决用户体验问题。很难为地图编写单元测试，因为它的缩放速度比我预期的要慢。显然，单元测试不能成为你测试工具箱中的唯一工具。
- en: Functional testing
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能测试
- en: Functional testing handles the testing of a single process, instead of a single
    unit. It makes many of the changes expected in a workflow, and checks that the
    results line up with what is expected. While one or more unit tests may cover
    the components tested in the functional test, the functional test connects them
    together to simulate a real-world example.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 功能测试处理单个流程的测试，而不是单个单元的测试。它执行工作流程中预期的许多更改，并检查结果是否符合预期。虽然一个或多个单元测试可能覆盖功能测试中测试的组件，但功能测试将它们连接起来以模拟现实世界的例子。
- en: 'An example might be the calculation of **Value Added Tax** (**VAT**) on an
    online purchase in European countries. You might have unit tests that cover the
    following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子可能是计算欧洲国家在线购买中的**增值税**（**VAT**）。你可能有一些单元测试覆盖以下内容：
- en: Whether Italy has the correct VAT percentage
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 意大利是否有正确的增值税百分比
- en: What the subtotal of a list of purchased items costs
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购买物品列表的小计成本是多少
- en: What the total cost of a purchase would be after VAT is applied
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用增值税后购买的总成本是多少
- en: With a functional test, you can string them all together. You could ask, given
    that a person in Italy purchases these items, does the total cost after VAT matches
    what is expected.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用功能测试，你可以将它们全部串联起来。你可以问，如果意大利人购买了这些物品，增值税后的总成本是否符合预期。
- en: End-to-end testing
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 端到端测试
- en: If unit testing examines the individual components of an application and functional
    testing tests a single workflow, then end-to-end testing examines the whole thing
    from beginning to end. The entire application is loaded into a platform specially
    designed for handling tests. A user script is loaded with predefined actions,
    such as text to enter or buttons to click. Any errors are logged by the system
    for review. Some testing frameworks even record screenshots or video of the testing
    process for review.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果单元测试检查应用程序的各个组件，而功能测试测试单个工作流程，那么端到端测试则从开始到结束检查整个流程。整个应用程序被加载到一个专门为处理测试而设计的平台上。一个用户脚本被加载，包含预定义的操作，如要输入的文本或要点击的按钮。任何错误都会由系统记录以供审查。一些测试框架甚至记录测试过程的截图或视频以供审查。
- en: End-to-end testing is meant to catch the errors generated by components interacting
    with one another. They also tend to catch improper implementation of the components
    (that is human error). However, end-to-end testing can be expensive in terms of
    computer resources and time. The more use cases you test using end-to-end testing,
    the longer it will take to get results. End-to-end testing is typically saved
    for code releases or nightly build processes, while unit testing is expected to
    cover the minor code changes between releases.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试旨在捕获组件之间交互产生的错误。它们还倾向于捕获组件的不当实现（即人为错误）。然而，端到端测试在计算机资源和时间方面可能很昂贵。你使用端到端测试测试的用例越多，得到结果所需的时间就越长。端到端测试通常用于代码发布或夜间构建过程，而单元测试则预期覆盖发布之间的较小代码更改。
- en: There are a number of paid services available on the web for end-to-end testing.
    For some frameworks, such as Angular, there are testing frameworks such as **Protractor**.js
    that can be used for end-to-end testing, but if you want end-to-end testing that
    is both free and framework agnostic, you have options. Open source libraries such
    as Phantom.js, Casper.js, and web browser automation tools such as Selenium, can
    help you test your application from start to finish, with a bit of setup.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 网上有很多端到端测试的付费服务。对于一些框架，例如Angular，有如**Protractor**.js这样的测试框架可用于端到端测试，但如果你想要既免费又与框架无关的端到端测试，你也有选择。开源库如Phantom.js、Casper.js以及像Selenium这样的网络浏览器自动化工具可以帮助你从开始到结束测试你的应用程序，只需一点设置。
- en: Testing as you code
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码时的测试
- en: Many developers have found that the best time to test their code is when they
    are writing it. It's a horrible feeling when you spend all day writing a module,
    only to have it fail and not know why. By creating unit tests in the middle of
    development, the developer receives quick feedback regarding whether part of their
    code succeeds or fails. Now, let's look at some ways developers write tests as
    they code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者发现，测试代码的最佳时机是在编写代码时。当你花费一整天编写一个模块，结果却失败，却不知道为什么，这是一种糟糕的感觉。通过在开发过程中创建单元测试，开发者可以快速收到有关其代码部分成功或失败的反馈。现在，让我们看看开发者如何在编码时编写测试的一些方法。
- en: Test-Driven Development
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: '**Test-Driven Development** (**TDD**) is the process of writing unit tests
    and end-to-end tests, then writing code to pass those tests. Whenever code is
    refactored, it runs through the same tests to ensure results come out as expected.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试驱动开发**（**TDD**）是一个编写单元测试和端到端测试，然后编写代码以通过这些测试的过程。每当代码重构时，它都会运行相同的测试以确保结果符合预期。'
- en: 'Developers using TDD tend to code using the following steps:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 TDD 的开发者通常会按照以下步骤进行编码：
- en: Write a test based on requirements.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需求编写一个测试。
- en: Run all tests and see that the new test fails. This eliminates unnecessary tests
    and tests the overall testing framework.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行所有测试并查看新测试失败。这消除了不必要的测试并测试了整体测试框架。
- en: Write some code to pass the test.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一些代码以通过测试。
- en: Run the tests again.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行测试。
- en: Refactor as necessary to clean up ugly code, names, and functionality.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需要重构，以清理丑陋的代码、名称和功能。
- en: Repeat steps 1 to 5 until done.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤 1 到 5，直到完成。
- en: By writing the test before writing code, the developer keeps their focus on
    the module's objectives and does not write unnecessary code. The tests also give
    the developer confidence in the code, and lead to faster code development.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在编写代码之前编写测试，开发者保持对模块目标的关注，并且不会编写不必要的代码。测试还增强了开发者对代码的信心，并导致代码开发速度更快。
- en: Behavior-Driven Development
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为驱动开发
- en: '**Behavior-Driven Development** (**BDD**) is a form of TDD that answers the
    question "how much should I test?". In BDD, tests for code modules and objects
    are written with descriptions that start with "It should do _____". Code tests
    are then written to test for those features and those only.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**行为驱动开发**（**BDD**）是 TDD 的一种形式，它回答了“我应该测试多少？”的问题。在 BDD 中，为代码模块和对象编写的测试带有以“它应该做______”开始的描述。然后编写代码测试以测试这些特性和这些特性。'
- en: BDD tests help to both define acceptance criteria and document code. By looking
    through the test descriptions, other developers will have a better idea of what
    the code is supposed to do. By describing acceptance criteria up front, the developer
    doesn't have to write extra code for use cases the code will never experience.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: BDD 测试有助于定义验收标准和记录代码。通过查看测试描述，其他开发者将更好地了解代码应该做什么。通过提前描述验收标准，开发者不需要为代码永远不会遇到的使用情况编写额外的代码。
- en: Test statements
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试语句
- en: At the heart of every TDD and BDD setup is the test statement. The test statements
    are lines of code written in a readable format to test properties and values of
    results. Test statements define a simple test within unit tests or functional
    tests.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 TDD 和 BDD 设置的核心是测试语句。测试语句是以可读的格式编写的代码行，用于测试结果的性质和值。测试语句在单元测试或功能测试中定义了一个简单的测试。
- en: 'Depending on the library you choose for generating test statements, they may
    follow a BDD `should` pattern, a TDD `expect` pattern, or a TDD `assert` pattern.
    Some libraries may let you use one or more of these patterns for your tests. For
    example, using the `Chai.js` library (which we''ll discuss a little later in the
    chapter), we can look at examples using any of the three patterns. Tests using
    the `should` pattern might look like the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你选择的生成测试语句的库，它们可能遵循 BDD 的 `should` 模式、TDD 的 `expect` 模式或 TDD 的 `assert` 模式。一些库可能允许你为测试使用这些模式中的一个或多个。例如，使用
    `Chai.js` 库（我们将在本章稍后讨论），我们可以查看使用这三种模式中的任何一种的示例。使用 `should` 模式的测试可能看起来像以下这样：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `expect` pattern may look something like the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`expect` 模式可能看起来像以下这样：'
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, the `assert` pattern should look something like the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`assert` 模式应该看起来像以下这样：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: All three formats test the same things. Their only difference is the syntax
    they use to get the same results. Depending on which testing formats your team
    likes to write, many of the testing libraries will have something in that flavor.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种格式测试相同的内容。它们之间的唯一区别是它们用来获得相同结果的语法。根据你的团队喜欢使用的测试格式，许多测试库都将提供相应的功能。
- en: 'Now that we''ve reviewed the general concepts behind software testing, let''s
    look at the tools we have to work with. In the last few years, the JavaScript
    community has produced a number of testing frameworks. Some are specific to a
    framework, such as Protractor for Angular, while others work with almost any library
    or framework, such as Mocha, Jasmine, or Intern. In this chapter, we''re going
    to examine two of them: Intern and Jasmine.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了软件测试背后的基本概念，让我们看看我们可用的工具。在过去的几年里，JavaScript社区已经产生了一系列测试框架。有些是特定于某个框架的，例如用于Angular的Protractor，而其他则几乎与任何库或框架一起工作，例如Mocha、Jasmine或Intern。在本章中，我们将探讨其中的两个：Intern和Jasmine。
- en: Intern testing framework
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Intern测试框架
- en: Intern ([https://theintern.github.io/](https://theintern.github.io/)) is a testing
    framework for testing websites and applications. Its website boasts that not only
    can it test plain JavaScript applications, but also test server-side websites
    built with Ruby and PHP, as well as mobile iOS, Android, and Firefox apps. Intern
    supports AMD and promises asynchronous testing.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Intern ([https://theintern.github.io/](https://theintern.github.io/)) 是一个用于测试网站和应用的测试框架。其网站宣称，它不仅可以测试纯JavaScript应用，还可以测试用Ruby和PHP构建的服务器端网站，以及iOS、Android和Firefox应用。Intern支持AMD和异步测试。
- en: If you're using Node.js in your development environment, Intern may integrate
    well. If you use Grunt, Intern comes with its own Grunt tasks for easy integration
    into your existing workflow. Intern also works with continuous integration services
    such as Jenkins and Travis CI.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Node.js作为你的开发环境，Intern可能很好地集成。如果你使用Grunt，Intern自带Grunt任务，可以轻松集成到现有的工作流程中。Intern还与持续集成服务如Jenkins和Travis
    CI兼容。
- en: Intern works in most modern browsers, including Android Browser, Chrome, Firefox,
    Safari, Opera, and Internet Explorer. For Internet Explorer, Intern works with
    versions 9 and later. If you need to test older versions of Internet Explorer,
    there is an `intern-geezer` module available through `npm`. The tests will work
    with Internet Explorer versions 6-8, which do not support EcmaScript 5, which
    is required by regular Intern.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Intern在大多数现代浏览器中工作，包括Android Browser、Chrome、Firefox、Safari、Opera和Internet Explorer。对于Internet
    Explorer，Intern与9及更高版本兼容。如果你需要测试Internet Explorer的旧版本，可以通过`npm`获取一个名为`intern-geezer`的模块。测试将适用于不支持EcmaScript
    5的Internet Explorer 6-8版本，而常规的Intern需要EcmaScript 5。
- en: Setting up your testing environment
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置你的测试环境
- en: 'If you''re using Node.js, installation can be as simple as `npm install intern`.
    According to the website, Intern has a recommended folder structure for your projects,
    as shown in the following screenshot:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Node.js，安装可以像`npm install intern`一样简单。根据网站上的说明，Intern为你的项目推荐了一种文件夹结构，如下面的截图所示：
- en: '![Setting up your testing environment](img/6459OT_10_01.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![设置你的测试环境](img/6459OT_10_01.jpg)'
- en: The makers of Intern recommend that you keep your source code and distributable
    code in folders separate from the tests. In that way, the tests aren't accidently
    published along with the code. You may not want people finding your tests, which
    could expose your secured services, private API keys, and sensitive passwords.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Intern的制作者建议你将源代码和可分发代码保存在与测试不同的文件夹中。这样，测试就不会意外地与代码一起发布。你可能不希望人们找到你的测试，这可能会暴露你的安全服务、私有API密钥和敏感密码。
- en: Special requirements for the ArcGIS JavaScript API
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ArcGIS JavaScript API的特殊要求
- en: According to reports from several users, using Intern with ESRI's hosted link
    to the ArcGIS API for JavaScript is not recommended. It can cause tests to fail
    where they shouldn't because a module and its dependencies load too slowly. The
    recommended solution is to download the API and the Dojo framework into folders
    alongside your project files. You can use Grunt, a Node.js task runner.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 根据几位用户的报告，使用Intern与ESRI提供的ArcGIS API for JavaScript的托管链接不建议。因为它可能导致测试在不应失败的地方失败，因为模块及其依赖加载得太慢。推荐的解决方案是将API和Dojo框架下载到与你的项目文件并列的文件夹中。你可以使用Grunt，这是一个Node.js任务运行器。
- en: Writing tests for Intern
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为Intern编写测试
- en: Writing tests for Intern was achieved with modules like Dojo's AMD style in
    mind. Once module paths have been assigned, these modules can be loaded into tests
    and run. Let's look at how to do that.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到Dojo的AMD风格，为Intern编写测试是可能的。一旦分配了模块路径，这些模块就可以加载到测试中并运行。让我们看看如何做到这一点。
- en: Unit testing with Intern
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Intern进行单元测试
- en: Writing unit tests for Intern is very similar to writing `Dojo` modules, with
    a few exceptions. Each unit test is made up of a `define()` function. The `define()`
    function may take either a function with a single `require` argument, or a list
    of string references to modules, and a function to run when all those modules
    have loaded. It is a common practice in Node.js modules to load them individually
    through a single `require()` function.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为Intern编写单元测试与编写`Dojo`模块非常相似，但有几点例外。每个单元测试由一个`define()`函数组成。`define()`函数可以接受一个带有单个`require`参数的函数，或者是一个字符串引用模块的列表，以及一个在所有这些模块加载完成后要运行的函数。在Node.js模块中，通过单个`require()`函数单独加载模块是一种常见的做法。
- en: 'You will need to load a testing interface and an assertion library in the unit
    testing function. The testing interface provides a way to register testing suites.
    When calling the interface as a function, you provide a JavaScript object with
    descriptive key strings and values containing functions to run tests or objects
    to classify subtests. An example unit test is shown in the following snippet:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在单元测试函数中加载一个测试接口和一个断言库。测试接口提供了一种注册测试套件的方式。当将接口作为函数调用时，你提供一个JavaScript对象，其中包含描述性的键字符串和包含运行测试或分类子测试的函数的值。以下是一个单元测试的示例：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, the `registerSuite` variable accepts Intern's object
    interface for creating tests, while `assert` accepts the `chai.assert` library
    loaded with Intern. The `registerSuite()`function is called, passing in two tests
    in an object. The first test looks at whether adding one and one will equal two,
    while the second test looks at adding two two's to see if that equals four. The
    `assert.equal()` function tests whether the result variable matches the expected
    result, and will throw an error with a text message should the test fail.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`registerSuite`变量接受Intern创建测试的对象接口，而`assert`接受Intern加载的`chai.assert`库。调用`registerSuite()`函数，传入一个包含两个测试的对象。第一个测试检查一加一是否等于二，而第二个测试检查两个二相加是否等于四。`assert.equal()`函数测试结果变量是否与预期结果匹配，如果测试失败，将抛出一个带有文本消息的错误。
- en: Test lifecycle with Intern
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Intern的测试生命周期
- en: 'There may be something you need to do before you run your test in a testing
    suite, or before and after each test. This is the test lifecycle. Intern provides
    keywords in your test definitions to define what should happen during the test
    lifecycle. All these lifecycle functions are optional, but they will help you
    to create useable tests. Here is an outline of the general lifecycle of a test:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试套件中运行测试之前，或者在每个测试之前和之后，你可能需要做一些事情。这是测试生命周期。Intern在测试定义中提供了关键字来定义测试生命周期中应该发生什么。所有这些生命周期函数都是可选的，但它们将帮助你创建可用的测试。以下是测试的一般生命周期的概述：
- en: '`setup`: This function runs before any of the tests run, presumably to set
    up something to test against. For example, you may create a map here before you
    test your widget against it.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setup`: 这个函数在所有测试运行之前执行，可能是为了设置测试对象。例如，你可以在测试小部件之前在这里创建一个地图。'
- en: 'During each test, the following events occur:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个测试期间，以下事件会发生：
- en: '`beforeEach`: This function will run before each test. As an example, you might
    load a fresh copy of your widget.'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeEach`: 这个函数将在每个测试之前运行。例如，你可能需要加载你小部件的新副本。'
- en: The test runs.
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试运行。
- en: '`afterEach`: This function will run after each test. Here, you might destroy
    the widget you created in the `beforeEach` function, or you might reset variable
    values that may have changed during tests.'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`afterEach`: 这个函数将在每个测试之后运行。在这里，你可能需要销毁在`beforeEach`函数中创建的小部件，或者你可能需要重置在测试过程中可能改变的变量值。'
- en: '`teardown`: This function runs after all the tests within the suite run. Here,
    you might destroy any maps or objects you created in the `setup` phase.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`teardown`: 这个函数在套件中的所有测试运行之后执行。在这里，你可能需要销毁在`setup`阶段创建的任何地图或对象。'
- en: 'You can see an example of a unit test using the lifecycle in the following
    code. This one simulates loading a map and adding a widget to the map:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下代码中看到一个使用生命周期的单元测试示例。这个示例模拟了加载地图并向地图添加小部件：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, the `define` statement looks a lot like the one we're
    familiar with, loading multiple objects at once. Note that the `map` is created
    on `setup` and destroyed on `teardown`, while the `widget` is newly created before
    each test and destroyed after each test.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`define`语句看起来与我们熟悉的语句非常相似，可以一次性加载多个对象。请注意，`map`是在`setup`阶段创建并在`teardown`阶段销毁的，而`widget`是在每个测试之前新创建的，并在每个测试之后销毁。
- en: Jasmine testing framework
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jasmine测试框架
- en: If you're looking for a simple BDD framework to test your application, Jasmine
    might have what you need. Jasmine is a framework-independent BDD library that
    can be used to run tests on JavaScript applications. It can either be installed
    through Node.js, or the library can be downloaded and copied to the test project
    folder.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找一个简单的 BDD 框架来测试你的应用程序，Jasmine 可能正是你所需要的。Jasmine 是一个框架无关的 BDD 库，可以用来在
    JavaScript 应用程序上运行测试。它可以通过 Node.js 安装，或者将库下载并复制到测试项目文件夹中。
- en: Jasmine loads its test in an HTML file called a `SpecRunner` (short for specifications
    runner). This page loads the main Jasmine library, as well as all the user libraries
    and unit tests. Once loaded, the Jasmine library runs tests in the browser and
    displays the results.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine 将其测试加载到一个名为 `SpecRunner` 的 HTML 文件中（简称规范运行器）。这个页面加载了主要的 Jasmine 库，以及所有用户库和单元测试。一旦加载，Jasmine
    库就会在浏览器中运行测试并显示结果。
- en: Writing tests for Jasmine
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 Jasmine 编写测试
- en: Once we have the `SpecRunner` in place, it's time to write tests. Tests are
    written using normal JavaScript logic and a few testing objects and methods provided
    by Jasmine. Let's look at some of the different parts.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了 `SpecRunner`，就到了编写测试的时候了。测试使用常规的 JavaScript 逻辑和 Jasmine 提供的一些测试对象和方法编写。让我们看看一些不同的部分。
- en: Writing suites, specs, and tests
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写套件、规范和测试
- en: Jasmine tests are organized by suites, specs, and tests. Suites make up the
    top level, and describe the unit tested. In fact, Jasmine tests write the suites
    using the `describe()` function, which describes the feature to be tested. The
    arguments for the `describe()` function include a string describing the feature,
    and a function to run the tests.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine 测试是由套件、规范和测试组成的。套件构成了顶层，并描述了被测试的单元。实际上，Jasmine 测试使用 `describe()` 函数来编写套件，该函数描述了要测试的功能。`describe()`
    函数的参数包括一个描述功能的字符串和一个运行测试的函数。
- en: 'Specs for the features can be written using the `it()` function in the `describe`
    suite. The `it()` function, like the `describe()` function, contains a string
    to describe the test and a function where a test is performed on the behavior.
    Any errors that occur in the `it()` function lead to a failing test, while an
    `it()` function that runs successfully shows a passing test for the behavior.
    In the following you can see an example of a `describe()` and `it()` statement:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `describe` 套件中的 `it()` 函数编写功能的规范。`it()` 函数与 `describe()` 函数类似，包含一个描述测试的字符串和一个执行测试的函数。在
    `it()` 函数中发生的任何错误都会导致测试失败，而成功运行的 `it()` 函数会显示行为的通过测试。以下是一个 `describe()` 和 `it()`
    语句的示例：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Inside each spec is one or more tests. In Jasmine, tests are written in the
    expect format. Based on the object passed to the `expect` object, you have numerous
    tests that can be performed on it, such as whether or not it equals a specific
    value, or whether it comes back as a "truthy" JavaScript statement:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个规范中都有一个或多个测试。在 Jasmine 中，测试是以 expect 格式编写的。根据传递给 `expect` 对象的对象，你可以对其进行多种测试，例如是否等于特定值，或者它是否返回一个“真”的
    JavaScript 语句：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Setup and teardown
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置和清理
- en: 'There are times when you will need to load modules or create JavaScript objects
    to test. You may also want to reset them between tests and tear them down to save
    memory. To set up and tear down items to be tested, you would use the `beforeEach`
    and `afterEach` functions. Each one lets you set up and tear down values between
    tests, so that each test has fresh values that are repeatable. These are loaded
    in the suites, and are supposed to be called before any specs that require them
    are called:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你需要加载模块或创建 JavaScript 对象来测试。你可能还希望在测试之间重置它们，并在测试后拆解它们以节省内存。为了设置和清理要测试的项目，你会使用
    `beforeEach` 和 `afterEach` 函数。每个函数都允许你在测试之间设置和清理值，以便每个测试都有新鲜且可重复的值。这些值在套件中加载，并应在需要它们的任何规范之前调用：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Ignoring tests
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 忽略测试
- en: 'What if your module has a depreciated feature? What if you expect your module
    to have a feature one day, but you don''t want to write a test that fails now.
    You could delete or comment out the code, but in doing so you lose some of the
    history of your module in some respect. Jasmine has a way of disabling suites
    and marking specs as pending without losing code. By replacing your `describe`
    statements with `xdescribe`, and your `it` statements with `xit`, you can write
    tests that won''t fail now, but will be marked as "pending". You can find an example
    in the following code that uses `xit`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的模块有一个已过时的功能呢？如果你期望你的模块有一天会有一个功能，但现在你不想编写一个会失败的测试。你可以删除或注释掉代码，但这样做你会在某种程度上失去你模块的一些历史。Jasmine有一种方法可以禁用套件并将规范标记为挂起，而不会丢失代码。通过将你的`describe`语句替换为`xdescribe`，以及将你的`it`语句替换为`xit`，你可以编写现在不会失败的测试，但会被标记为“挂起”。你可以在以下代码示例中找到一个使用`xit`的例子：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Red-light green-light
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 红灯绿灯
- en: 'Many developers who write TDD and BDD tests practice red-green testing, which
    is supported in Jasmine. Red stands for a failed test, while green stands for
    a passed test. In red-green testing, a developer does the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编写TDD和BDD测试的开发者会练习红绿测试，这在Jasmine中得到支持。红代表失败的测试，而绿代表通过的测试。在红绿测试中，开发者会做以下操作：
- en: Writes a necessary unit test that they know will fail (red).
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个他们知道会失败的必要单元测试（红）。
- en: Writes code for the object or module so that the test passes (green).
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码以使对象或模块通过测试（绿）。
- en: Refactors the code as needed, making sure it still passes the test.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需要重构代码，确保它仍然通过测试。
- en: Repeats steps 1 to 3 until both the code and tests are satisfactory.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤1到3，直到代码和测试都令人满意。
- en: Using the red-green testing method, the developer keeps the tests in mind as
    they develop module functionality. Passing tests gives the developer confidence
    in their code, and allows for faster development.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用红绿测试方法，开发者在开发模块功能时始终牢记测试。通过测试会给予开发者对代码的信心，并允许更快地开发。
- en: In Jasmine, test results on the `SpecRunner` HTML page are displayed using red
    and green colors. Red colors are shown when a test fails, while green colors show
    when all tests pass. The `SpecRunner` page will display which specification failed
    (if any), and the error thrown when the failure occurred. Armed with that information,
    the developer can fix the problem and move on to the next step in development.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jasmine中，`SpecRunner` HTML页面上的测试结果使用红色和绿色显示。当测试失败时显示红色，而当所有测试通过时显示绿色。`SpecRunner`页面将显示哪个规范失败（如果有），以及失败时抛出的错误。有了这些信息，开发者可以修复问题并继续开发过程中的下一步。
- en: Jasmine and the ArcGIS JavaScript API
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Jasmine和ArcGIS JavaScript API
- en: Setting up your `SpecRunner` for applications using the ArcGIS JavaScript API
    is a little more challenging. The AMD nature of the Dojo framework makes loading
    the modules and tests a little more challenging, but it can be done.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为使用ArcGIS JavaScript API的应用程序设置`SpecRunner`会有点更具挑战性。Dojo框架的AMD特性使得加载模块和测试变得有点更具挑战性，但这是可以做到的。
- en: 'The first step is to load the Jasmine and ArcGIS JavaScript APIs into the application.
    Due to all the parts that Jasmine has to handle outside our application, and because
    AMD modules tend to not show up when errors occur, we need to load Jasmine before
    the ArcGIS JavaScript API:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将Jasmine和ArcGIS JavaScript API加载到应用程序中。由于Jasmine需要在我们的应用程序外部处理所有部分，以及因为AMD模块在发生错误时往往不会显示，我们需要在ArcGIS
    JavaScript API之前加载Jasmine：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You will be able to load the locations of both your modules, and the tests
    on those modules, in the `dojoConfig` packages. We will be using the AMD loader
    to load the test suites as modules. In the following example, the AMD modules
    are in the `js` subfolder, while the spec tests are in the `tests` subfolder.
    The `dojoConfig` package should look something like the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你将能够加载你模块的位置，以及那些模块上的测试，在`dojoConfig`包中。我们将使用AMD加载器来加载测试套件作为模块。在以下示例中，AMD模块位于`js`子文件夹中，而规范测试位于`tests`子文件夹中。`dojoConfig`包应该看起来像以下这样：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Since many of your custom widgets will require other modules, including other
    custom modules, to load, you need to keep the path for your custom modules the
    same as in your application.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你的许多自定义小部件将需要加载其他模块，包括其他自定义模块，因此你需要确保你的自定义模块的路径与你的应用程序中的路径相同。
- en: 'In the body of the HTML document, add a script to call the specs through Dojo''s
    `require()` function. The code will load the specs out of the tests subfolder
    through AMD. When the modules have loaded and the `dojo/ready` function is called,
    we will load Jasmine''s `HtmlReporter` and execute the Jasmine testing:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML文档的主体中，添加一个脚本通过Dojo的`require()`函数调用规范。代码将通过AMD从测试子文件夹中加载规范。当模块加载完毕并且调用`dojo/ready`函数时，我们将加载Jasmine的`HtmlReporter`并执行Jasmine测试：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When the tests are loaded and run, they will be rendered on this HTML page in
    the browser.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试加载并运行时，它们将在浏览器中的这个HTML页面上渲染。
- en: In the specs
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在规范中
- en: Normally, Jasmine specs can either be run as a script or enclosed in a self-running
    JavaScript function. However, to work with Dojo, they need to be enclosed in module
    definitions. Unlike the custom modules we've made in the past, we won't use the
    `dojo/_base/declare` module to make a custom module. We'll simply use the `define()`
    statement to load the necessary modules, and run the test inside it.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Jasmine规范可以作为脚本运行或封装在自运行的JavaScript函数中。然而，为了与Dojo一起工作，它们需要被封装在模块定义中。与过去我们制作的自定义模块不同，我们不会使用`dojo/_base/declare`模块来创建自定义模块。我们将简单地使用`define()`语句来加载必要的模块，并在其中运行测试。
- en: 'For each suite, use the `define()` statement to help load the tests. You could
    also load any other ArcGIS JavaScript API modules or widgets you might need to
    help test the module. The code for the `Widget1` spec, as requested by the main
    app, might look like the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个套件，使用`define()`语句来帮助加载测试。你也可以加载任何可能需要的其他ArcGIS JavaScript API模块或小部件来帮助测试模块。根据主应用的要求，`Widget1`规范代码可能如下所示：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Start writing Jasmine specs in the `define` statement. When the suite modules
    are loaded, they will automatically run any tests inside them and display the
    results on the `SpecRunner` page in the browser. You can use `beforeEach` to load
    a fresh module for testing, and `afterEach` to destroy it, if necessary. You can
    perform any custom ArcGIS JavaScript API-related tasks within the suites and specs:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在`define`语句中开始编写Jasmine规范。当套件模块加载时，它们将自动运行其中的任何测试并显示在浏览器中的`SpecRunner`页面上的结果。你可以使用`beforeEach`来加载一个全新的模块进行测试，如果需要的话，使用`afterEach`来销毁它。你可以在套件和规范中执行任何与ArcGIS
    JavaScript API相关的自定义任务：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once you have your tests defined, you can view the `SpecRunner` page in the
    browser and check out the results. If you have set everything up, you should have
    tests running and displaying results. Have a look at the following screenshot
    for an example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你定义了测试，你可以在浏览器中查看`SpecRunner`页面并检查结果。如果你已经设置好了一切，你应该有正在运行的测试并显示结果。查看以下截图以获取示例：
- en: '![In the specs](img/6459OT_10_02.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![在规范中](img/6459OT_10_02.jpg)'
- en: Use case for Jasmine and the ArcGIS JavaScript API
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Jasmine和ArcGIS JavaScript API的使用案例
- en: Jasmine provides an easy-to-write testing environment for your JavaScript widgets.
    If you are new to unit testing and BDD, and you aren't comfortable with setting
    up the Node.js environment on top of your tests, then Jasmine is a good place
    to start. All the libraries you need can be downloaded from GitHub, and you can
    begin writing tests almost right away.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine为你的JavaScript小部件提供了一个易于编写的测试环境。如果你是单元测试和BDD的新手，并且不习惯在测试之上设置Node.js环境，那么Jasmine是一个很好的起点。你需要的所有库都可以从GitHub下载，你几乎可以立即开始编写测试。
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Jasmine can be downloaded from its GitHub repository at [https://github.com/jasmine/jasmine](https://github.com/jasmine/jasmine).
    Documentation for Jasmine can be found at [http://jasmine.github.io/.](http://jasmine.github.io/.)
    If you are interested in more reading material on this framework, you can read
    *Jasmine JavaScript Testing, Second Edition* by Paulo Ragonha, or *Jasmine Cookbook*
    by Munish Sethi.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从其GitHub仓库[https://github.com/jasmine/jasmine](https://github.com/jasmine/jasmine)下载Jasmine。Jasmine的文档可以在[http://jasmine.github.io/](http://jasmine.github.io/)找到。如果你对这个框架感兴趣，可以阅读Paulo
    Ragonha的《Jasmine JavaScript Testing, Second Edition》或Munish Sethi的《Jasmine Cookbook》。
- en: Our application
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的应用
- en: For our application, we're going to set up unit testing for our Y2K map app
    using Intern. Unlike our other applications, which only required a browser, we're
    going to use Node.js for this setup. If we were following real TDD/BDD practices,
    we would have written these tests while we were developing the application. However,
    this will give you practice writing tests for any legacy applications you've previously
    written.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，我们将使用 Intern 为我们的 Y2K 地图应用程序设置单元测试。与我们的其他应用程序不同，它们只需要浏览器，我们将使用 Node.js
    进行此设置。如果我们遵循真正的 TDD/BDD 实践，我们会在开发应用程序时编写这些测试。然而，这将为您练习为之前编写的任何遗留应用程序编写测试提供机会。
- en: For this sample, we'll follow the example provided by David Spriggs and Tom
    Wayson through GitHub ([https://github.com/DavidSpriggs/intern-tutorial-esri-jsapi](https://github.com/DavidSpriggs/intern-tutorial-esri-jsapi)).
    We'll make some modifications to work with more recent updates in both the ArcGIS
    JavaScript API and in the modules associated with the tests.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将遵循 David Spriggs 和 Tom Wayson 通过 GitHub 提供的示例（[https://github.com/DavidSpriggs/intern-tutorial-esri-jsapi](https://github.com/DavidSpriggs/intern-tutorial-esri-jsapi)）。我们将对
    ArcGIS JavaScript API 和与测试相关的模块的最新更新进行一些修改。
- en: Adding testing files
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加测试文件
- en: In our Y2K application, we're going to add several files to work with the required
    Node.js modules. We'll add a `package.json` file, which tells the **Node Package
    Manager** (**NPM**) what modules we need and what version numbers we require.
    Next, we'll add a `Grunt.js` file, since we'll use Grunt to load the ArcGIS JavaScript
    API locally. We'll also add a `bower.json` file for Bower to load the correct
    `Dojo` libraries locally, and a `.bowerc` file to configure Bower when we run
    it. Finally, we're going to add an `intern.js` file in a `tests` folder to configure
    the Intern tests.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 Y2K 应用程序中，我们将添加几个文件以与所需的 Node.js 模块一起工作。我们将添加一个 `package.json` 文件，它告诉 **Node
    包管理器** (**NPM**) 我们需要哪些模块以及需要哪些版本号。接下来，我们将添加一个 `Grunt.js` 文件，因为我们将使用 Grunt 在本地加载
    ArcGIS JavaScript API。我们还将添加一个 `bower.json` 文件，以便 Bower 在本地加载正确的 `Dojo` 库，并添加一个
    `.bowerc` 文件以在运行时配置 Bower。最后，我们将在 `tests` 文件夹中添加一个 `intern.js` 文件以配置 Intern 测试。
- en: 'Our new folder structure should look like the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新文件夹结构应该如下所示：
- en: '![Adding testing files](img/6459OT_10_03.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![添加测试文件](img/6459OT_10_03.jpg)'
- en: The package.json file
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: package.json 文件
- en: 'In our `package.json` file, we''ll add the file dependencies required for our
    Node.js modules. When specifying version numbers for some of the modules, you''ll
    note that some have a tilde (~) in front while others have a caret symbol(`^`).
    A tilde matches both major and minor version numbers (the first and second numbers
    in the three-number version code), while the caret will pull the most recent matching
    major version number. Copy the following into your `package.json` file:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `package.json` 文件中，我们将添加我们 Node.js 模块所需的文件依赖项。当指定某些模块的版本号时，你会注意到一些模块前面有一个波浪号
    (~) 符号，而其他模块则有一个 caret 符号 (`^`)。波浪号匹配主版本号和次版本号（三位版本代码中的前两个数字），而 caret 符号将拉取最新的匹配主版本号。将以下内容复制到您的
    `package.json` 文件中：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The Grunt setup
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Grunt 设置
- en: 'Grunt is a popular task runner used in Node.js applications. It''s used to
    automate code building steps, such as minifying JavaScript, creating CSS files
    from CSS preprocessors like LESS or SASS, or, in this case, testing code. Grunt
    reads a `Grunt.js` file, which tells it where to look for files and what to do
    with them. In our `Grunt.js` file, we''re going to add the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt 是在 Node.js 应用程序中使用的流行任务运行器。它用于自动化代码构建步骤，例如压缩 JavaScript、从 LESS 或 SASS
    等预处理器创建 CSS 文件，或者在这种情况下，测试代码。Grunt 读取 `Grunt.js` 文件，该文件告诉它在哪里查找文件以及如何处理它们。在我们的
    `Grunt.js` 文件中，我们将添加以下代码：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding code, Node.js expects that we will pass our module definition
    to the `module.exports` variable. We tell Grunt where to find our `intern` module
    for testing in `grunt.initConfig`, and `esri_slurp` for downloading the ArcGIS
    JavaScript API. We also tell it to watch the `src/js/` folder for any changes
    to JavaScript files, which will trigger the tests to run again.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，Node.js 预期我们将把我们的模块定义传递给 `module.exports` 变量。我们在 `grunt.initConfig`
    中告诉 Grunt 在哪里找到我们的 `intern` 模块以进行测试，以及 `esri_slurp` 以下载 ArcGIS JavaScript API。我们还告诉它监视
    `src/js/` 文件夹中的任何 JavaScript 文件更改，这将触发测试再次运行。
- en: Once the configuration has loaded, we tell Grunt to load the modules for `intern`,
    `grunt-contrib-watch`, and `grunt-esri-slurp` to modules from `npm`. The tasks
    are then registered, and everything is set up to run the tests.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置加载完成，我们告诉 Grunt 加载 `intern`、`grunt-contrib-watch` 和 `grunt-esri-slurp` 模块，从
    `npm` 中加载模块。然后注册任务，并设置好运行测试的环境。
- en: Setting up Bower
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置 Bower
- en: Bower is a Node.js module used to download all the required JavaScript libraries
    for a project automatically. We will use Bower to download the libraries and Dojo
    modules necessary to run our tests. Most common libraries and frameworks can be
    downloaded locally through Bower. Our exception in this case is the ArcGIS JavaScript
    API, which will currently be handled through `esri-slurp`. We need to fill out
    a `bower.json` file to tell Bower what libraries we need, and what library versions
    they should be as well.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Bower 是一个 Node.js 模块，用于自动下载项目所需的所有 JavaScript 库。我们将使用 Bower 下载运行测试所需的库和 Dojo
    模块。大多数常见的库和框架都可以通过 Bower 在本地下载。在这个例子中，我们的例外是 ArcGIS JavaScript API，它目前将通过 `esri-slurp`
    处理。我们需要填写一个 `bower.json` 文件来告诉 Bower 我们需要哪些库，以及它们的版本应该是什么。
- en: Within our `bower.json` file, we need to create a JSON object to list our project
    name, version number, dependencies, and any development dependencies. We can name
    it whatever we want, so we'll name it `y2k-map-app`. We'll give it a version of
    `0.0.1` for testing, and we'll be sure to increment it whenever dependencies or
    library version numbers need to be updated. We have no development dependencies
    in this case, but we do need to list the parts of the Dojo framework, as well
    as `D3.js` , in this application.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `bower.json` 文件中，我们需要创建一个 JSON 对象来列出我们的项目名称、版本号、依赖项以及任何开发依赖项。我们可以将其命名为任何我们想要的名称，所以我们将命名为
    `y2k-map-app`。我们将为测试分配版本号 `0.0.1`，并且我们确保在依赖项或库版本号需要更新时增加它。在这种情况下，我们没有开发依赖项，但我们需要列出
    Dojo 框架的各个部分，以及 `D3.js`，在这个应用程序中。
- en: 'We not only need to list the libraries and modules required for the tests,
    but the version numbers as well. We can refer to the ArcGIS JavaScript API *What''s
    New* page at [https://developers.arcgis.com/javascript/jshelp/whats_new.html](https://developers.arcgis.com/javascript/jshelp/whats_new.html)
    to find out. According to the page, we need version `1.10.4` of the Dojo framework,
    including `dojo`, `dijit`, `dojox`, and `util` modules from `dojo/util`. We also
    need to add the `dgrid` modules with version `0.3.16`, `put-selector` version
    `0.3.6`, and `xstyle` version `0.1.3`. Referring back to the `dojoConfig` packages
    from our `index.html` page, we see that `d3.js` is using version `3.5.6`. We''ll
    list the dependencies within a JSON object, with the version numbers preceded
    by a `#` sign. The contents of our `bower.json` file should be the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅需要列出测试所需的库和模块，还需要列出版本号。我们可以参考 ArcGIS JavaScript API 的 *What's New* 页面 [https://developers.arcgis.com/javascript/jshelp/whats_new.html](https://developers.arcgis.com/javascript/jshelp/whats_new.html)
    来查找。根据页面，我们需要 Dojo 框架的版本 `1.10.4`，包括来自 `dojo/util` 的 `dojo`、`dijit`、`dojox` 和
    `util` 模块。我们还需要添加版本为 `0.3.16` 的 `dgrid` 模块、版本为 `0.3.6` 的 `put-selector` 和版本为 `0.1.3`
    的 `xstyle`。回顾我们 `index.html` 页面上的 `dojoConfig` 包，我们看到 `d3.js` 使用的是版本 `3.5.6`。我们将在
    JSON 对象中列出依赖项，版本号前加一个 `#` 符号。我们的 `bower.json` 文件的内容应如下所示：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For the `.bowerc` file, we''re going to add a simple configuration object.
    In the configuration object JSON, we''re going to add a directories field and
    assign a value of `.`. This will tell Bower to load the files requested in this
    folder. The contents of the `.bowerc` file should look like the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `.bowerc` 文件，我们将添加一个简单的配置对象。在配置对象的 JSON 中，我们将添加一个目录字段并分配一个值为 `.`。这将告诉 Bower
    加载此文件夹中请求的文件。`.bowerc` 文件的内容应如下所示：
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Intern.js configuration
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Intern.js 配置
- en: 'Now we need to set up our `Intern.js` configuration file in the `tests` folder
    to run our tests. We''ll start by adding some default code in the page. More information
    on this configuration file can be found at [https://github.com/theintern/intern/wiki/Configuring-Intern](https://github.com/theintern/intern/wiki/Configuring-Intern).
    Start by copying the following content:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要在 `tests` 文件夹中设置我们的 `Intern.js` 配置文件以运行测试。我们将从在页面上添加一些默认代码开始。有关此配置文件的更多信息，请参阅
    [https://github.com/theintern/intern/wiki/Configuring-Intern](https://github.com/theintern/intern/wiki/Configuring-Intern)。首先，复制以下内容：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Inside the `loader.packages` list, we''ll add the folder locations of all the
    files we expect to have. These will include both the files we have now, plus the
    files we expect to download through Bower. Note that our `app` folder is referenced
    through the folder where our `Census` widget is stored. Also, we''re loading all
    the ESRI and Dojo files, as well as `D3.js` for the graphics. Your packages portion
    should look like the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `loader.packages` 列表中，我们将添加我们预期拥有的所有文件的文件夹位置。这包括我们现在拥有的文件，以及我们预期通过 Bower 下载的文件。请注意，我们的
    `app` 文件夹是通过存储我们的 `Census` 小部件的文件夹引用的。此外，我们正在加载所有 ESRI 和 Dojo 文件，以及用于图形的 `D3.js`。您的包部分应如下所示：
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We need to add the names of our test suites to the suites list. For now, we''ll
    add the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将我们的测试套件名称添加到套件列表中。目前，我们将添加以下内容：
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We should have everything we need in this file to run some successful tests
    on the `Census` widget. As we add more modules, we can expand this point with
    more tests.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们应该有运行 `Census` 小部件的一些成功测试所需的一切。随着我们添加更多模块，我们可以通过更多测试来扩展这一点。
- en: We should be ready at this point to load the files we need through Node.js.
    If you haven't installed Node.js or any of the other node dependencies for this
    application, please follow the next section. If you already have, you can still
    review the next section, or skip it if you're already familiar with Grunt and
    Bower.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们应该准备好通过 Node.js 加载所需的文件。如果您还没有安装 Node.js 或此应用程序的其他节点依赖项，请参阅下一节。如果您已经安装了，您仍然可以查看下一节，或者如果您已经熟悉
    Grunt 和 Bower，可以跳过。
- en: If you haven't installed Node.js
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果您还没有安装 Node.js
- en: In this section, we'll go through the necessary steps to set up Node.js and
    the necessary dependencies. In these examples, we'll be working with NPM, Grunt,
    Grunt-CLI, and Bower. If you already have these set up in your development environment,
    you can skip to the next section.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍设置 Node.js 和必要依赖项的必要步骤。在这些示例中，我们将使用 NPM、Grunt、Grunt-CLI 和 Bower。如果您已经在您的开发环境中设置了这些，您可以跳到下一节。
- en: If you haven't installed Node.js, you can download a copy from [http://nodejs.org](http://nodejs.org).
    On the home page, you'll find a link to the appropriate installer for your computer.
    Follow the directions in the installation wizard to install the software.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有安装 Node.js，您可以从 [http://nodejs.org](http://nodejs.org) 下载一份。在主页上，您会找到一个链接，指向适合您电脑的安装程序。按照安装向导中的说明来安装软件。
- en: Node.js works through a command-line interface. All commands will be typed in
    either through a Linux or OSX terminal, or through the Windows command prompt
    (`cmd.exe`). Some portions may need you to have root or administrative access.
    Also, if you're using a Windows machine, the `PATH` variable may need to be updated
    to include both the `node.js` folder and its `node_modules` subfolder, where other
    commands and utilities will be loaded.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 通过命令行界面工作。所有命令都将在 Linux 或 OSX 终端或 Windows 命令提示符 (`cmd.exe`) 中输入。某些部分可能需要您具有
    root 或管理员权限。此外，如果您使用的是 Windows 机器，可能需要更新 `PATH` 变量以包括 `node.js` 文件夹及其 `node_modules`
    子文件夹，其中将加载其他命令和实用程序。
- en: 'Next, if you have not installed the `grunt`, `grunt-cli`, and `bower` modules,
    we''ll install them using `npm`. NPM comes built into Node.js and provides access
    to a multitude of plugins, libraries, and applications to help you generate applications
    faster. From your command prompt (or terminal), type the following to download
    the modules we need:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果您还没有安装 `grunt`、`grunt-cli` 和 `bower` 模块，我们将使用 `npm` 安装它们。NPM 是 Node.js
    的内置组件，并提供对大量插件、库和应用程序的访问，以帮助您更快地生成应用程序。从您的命令提示符（或终端）输入以下内容以下载我们需要的模块：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `–g` flag tells `npm` to install the modules globally, so that they can
    be accessed anywhere that Node.js and `npm` can be called. Without the `–g` flag,
    the module will be loaded in a `node_modules` subfolder of your current directory.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`-g` 标志告诉 `npm` 全局安装模块，这样它们就可以在任何可以调用 Node.js 和 `npm` 的地方访问。如果没有 `-g` 标志，模块将在当前目录的
    `node_modules` 子目录中加载。'
- en: Loading all the libraries locally
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地加载所有库
- en: 'Now it is time to load all of the Node.js applications necessary for testing.
    We''re going to do the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是加载所有必要的 Node.js 应用程序以进行测试的时候了。我们将执行以下操作：
- en: Install all of our modules from `npm`.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `npm` 安装我们所有的模块。
- en: Load most of the external JavaScript libraries locally using Bower.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Bower 本地加载大多数外部 JavaScript 库。
- en: Download the ArcGIS JavaScript API using Grunt Slurp.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Grunt Slurp 下载 ArcGIS JavaScript API。
- en: 'We''ll start by loading all the modules from `npm`. You will need to use a
    command line tool like Windows command prompt (`cmd.exe`) or `terminal` for Mac
    or Linux to run the code. Our `package.json` file defines the modules we need
    to run. We can install the modules by typing the following in the command line:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过`npm`加载所有模块。您需要使用命令行工具，如Windows的命令提示符(`cmd.exe`)或Mac或Linux的`terminal`来运行代码。我们的`package.json`文件定义了我们需要运行的模块。我们可以在命令行中键入以下内容来安装模块：
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If we need to test for features in older browsers, such as Internet Explorer
    8 or earlier, we will need to install an Intern extension called `intern-geezer`.
    It allows tests to work on older browsers that may not have the features used
    in standard Intern. If you need the older support, enter the following into the
    command line:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要测试旧浏览器中的功能，例如Internet Explorer 8或更早版本，我们需要安装一个名为`intern-geezer`的Intern扩展。它允许测试在可能没有标准Intern使用的功能的旧浏览器上运行。如果您需要旧版支持，请在命令行中输入以下内容：
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To load our JavaScript libraries locally, we can call on Bower to install the
    files. Our `bower.json` file tells it what to load, and our `.bowerc` file tells
    it where to load it. Enter the following into the command line:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在本地上加载我们的JavaScript库，我们可以调用Bower来安装文件。我们的`bower.json`文件告诉它要加载什么，我们的`.bowerc`文件告诉它在哪里加载。在命令行中输入以下内容：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we need to load the ArcGIS JavaScript library for local testing. Since
    we defined everything for this task in our `Grunt.js` file, we can simply enter
    the following into the command line to download the files and start up our testing:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要加载ArcGIS JavaScript库以进行本地测试。由于我们在`Grunt.js`文件中为这个任务定义了所有内容，我们只需在命令行中输入以下内容即可下载文件并启动测试：
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now our project should be up and running. We can now focus on writing tests
    for our application.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的项目应该已经启动并运行。我们现在可以专注于为我们的应用程序编写测试。
- en: Writing our tests
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写我们的测试
- en: We will be writing tests using the same `dojo` module definition style we used
    with creating objects, and similar to the Jasmine tests we talked about earlier.
    However, since Intern is designed for AMD, we can load the intern items within
    the module `define()` statements. In our tests folder, we'll create a file called
    `Census.js`, and let that contain our test module definition.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与创建对象时相同的`dojo`模块定义风格来编写测试，类似于我们之前讨论的Jasmine测试。然而，由于Intern是为AMD设计的，我们可以在模块`define()`语句中加载intern项。在我们的测试文件夹中，我们将创建一个名为`Census.js`的文件，并让该文件包含我们的测试模块定义。
- en: 'We will start by stubbing out our `define()` statement. We will load both Intern
    and Chai to run our tests. With Chai, we''ll try using the `assert` module, where
    all test statements start with `assert`. We''ll also load our `Census` widget
    and all the modules necessary to get it working, like a map. Since Intern typically
    runs without requiring HTML DOM, but our maps and `Census` widget require it,
    we''ll add some modules to add elements to the DOM:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建我们的`define()`语句的占位符。我们将加载Intern和Chai来运行我们的测试。使用Chai，我们将尝试使用`assert`模块，其中所有测试语句都以`assert`开头。我们还将加载我们的`Census`小部件以及所有必要的模块，如地图。由于Intern通常在没有要求HTML
    DOM的情况下运行，但我们的地图和`Census`小部件需要它，我们将添加一些模块来向DOM添加元素：
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Within the module definition, we''ll add the variables for our map and `Census`
    widget, and then register our suite with Intern using `registerSuite()`. In the
    `registerSuite()` function, we''ll pass an object containing the test name `Census
    Widget`. We''ll also add two methods, `setup()` and `teardown()`, to call before
    and after all the tests have run:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块定义中，我们将添加我们的地图和`Census`小部件的变量，然后使用`registerSuite()`将我们的测试套件注册到Intern。在`registerSuite()`函数中，我们将传递一个包含测试名称`Census
    Widget`的对象。我们还将添加两个方法，`setup()`和`teardown()`，在所有测试运行前后调用：
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the setup function, we''ll need to create the DOM, the map to attach to
    the DOM, and the `Census` widget to attach to the map. We''ll use the `dojo/dom-construct`
    and the `dojo/_base/window` modules to create the DOM for both. Once the DOM elements
    have been created, we can initialize our map and census dijit. In our `teardown`
    function, we''ll destroy the map so that it doesn''t take up valuable memory space.
    The code should look like the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置函数中，我们需要创建DOM、要附加到DOM的地图以及要附加到地图的`Census`小部件。我们将使用`dojo/dom-construct`和`dojo/_base/window`模块来创建这两个DOM。一旦创建了DOM元素，我们就可以初始化我们的地图和人口普查dijit。在我们的`teardown`函数中，我们将销毁地图，以避免占用宝贵的内存空间。代码应该如下所示：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now that the map and the `Census` widget have been initialized, we can start
    adding tests. I''ll walk you through three relatively straightforward tests. It
    is up to you to extend them further. In this exercise, we''ll test the `Census`
    dijit for the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在地图和`Census`小部件已经初始化，我们可以开始添加测试。我将向您介绍三个相对简单的测试。您需要进一步扩展它们。在这个练习中，我们将测试以下`Census`
    dijit：
- en: It should have all its working parts
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该包含所有其工作部件
- en: It should return the correct query results when we make a known request
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们发出已知请求时，它应该返回正确的查询结果
- en: Parts of the charting widget should work as expected
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图表小部件的部分应该按预期工作
- en: 'When writing the first test, we''ll give it a label of `Test Census widget
    creation`. For the corresponding function, we''ll start by testing if the `baseClass`
    for the dijit is as expected. We''ll use `assert.strictEqual()` to test whether
    the value is correct. Note that `assert.strictEqual()` takes three arguments,
    two values to compare, and a string description of the test. That test should
    look like the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写第一个测试时，我们将给它一个标签`Test Census widget creation`。对于相应的函数，我们将首先测试dijit的`baseClass`是否符合预期。我们将使用`assert.strictEqual()`来测试值是否正确。请注意，`assert.strictEqual()`需要三个参数，两个要比较的值和一个测试的字符串描述。该测试应该看起来像以下这样：
- en: '[PRE29]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Our second test may seem a little tricky, since it's an asynchronous test. However,
    Intern is designed to handle asynchronous testing as well. If necessary, we can
    tweak Intern's timeout before it considers the task failed, but for now we will
    just load the test.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个测试可能看起来有点棘手，因为它是一个异步测试。然而，Intern被设计用来处理异步测试。如果需要，我们可以在Intern考虑任务失败之前调整其超时时间，但现在我们只是加载测试。
- en: 'In the query test, we''ll send a query to the map service with all the states,
    and ask for a list of the states. Using a `then()` statement after the query,
    we can grab the results and test those using `assert.strictEqual()`. The test
    should look like the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在查询测试中，我们将向地图服务发送包含所有州的查询，并请求一个州列表。在查询之后使用`then()`语句，我们可以获取结果并使用`assert.strictEqual()`进行测试。测试应该看起来像以下这样：
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, for the graphing functions, we''ll write tests to look at the functions
    we use to translate feature attribute data into a format that D3 can use. In this
    example, we''ll pass attribute data through the `census.ethnicData()` method and
    test the output for expected values. Like other testing libraries, we can add
    more than one test within this specification. The test should look like the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于绘图函数，我们将编写测试来检查我们用来将特征属性数据转换为D3可以使用格式的函数。在这个例子中，我们将通过`census.ethnicData()`方法传递属性数据，并测试输出是否符合预期值。像其他测试库一样，我们可以在本规范中添加多个测试。测试应该看起来像以下这样：
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Checking the results
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查结果
- en: 'In order to check our tests, we need to load our file in the browser. Since
    we installed Intern as a node module, we''ll need to view its test-running page.
    The file is located under `node_modules/intern/client.html`. You will need to
    specify where the tests are loaded in the browser by giving a query parameter
    of `config=tests/intern`. The following URL is an example you might view in a
    browser (it may be different depending on your setup): `http://localhost/MasteringArcGIS/Chapter10/node_modules/intern/client.html?config=tests/intern`.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查我们的测试，我们需要在浏览器中加载我们的文件。由于我们将Intern作为node模块安装，我们需要查看其测试运行页面。该文件位于`node_modules/intern/client.html`下。您需要通过提供一个查询参数`config=tests/intern`来指定在浏览器中加载测试的位置。以下是在浏览器中可能查看的URL示例（它可能取决于您的设置）：`http://localhost/MasteringArcGIS/Chapter10/node_modules/intern/client.html?config=tests/intern`。
- en: 'When you correctly view the page, you''ll be greeted with the Intern icon and
    a pass/fail report. Failing tests will be highlighted in red, while passing tests
    will be highlighted in green. You should see something like the following image:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当您正确查看页面时，您将看到Intern图标和通过/失败报告。失败的测试将以红色突出显示，而通过的测试将以绿色突出显示。您应该看到以下图像类似的内容：
- en: '![Checking the results](img/6459OT_10_04.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![检查结果](img/6459OT_10_04.jpg)'
- en: Summary
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have reviewed the reasons why we want to set up tests for
    our web applications. We have looked over different testing methodologies, development
    practices, and JavaScript libraries useful for testing our applications. Using
    Intern, we have set up tests for our own application.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了为什么我们要为我们的Web应用程序设置测试的原因。我们回顾了不同的测试方法、开发实践和用于测试我们应用程序的JavaScript库。使用Intern，我们为我们的应用程序设置了测试。
- en: In the next chapter, we'll look into the future of web applications for ArcGIS
    Server, checking into ArcGIS Online.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 ArcGIS Server 的网络应用程序的未来，并检查 ArcGIS Online。
