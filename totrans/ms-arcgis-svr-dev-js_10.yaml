- en: Chapter 10. Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you publish a website or a web application to the public, users expect
    it to work. Links are supposed to take their places, and buttons are supposed
    to do things. They may not have the technical knowhow to look in good their browser
    console or observe network traffic. They may even have good reason to disable
    JavaScript on their browser.
  prefs: []
  type: TYPE_NORMAL
- en: The truth is, sometimes websites don't work because of hardware, software, or
    user error, but at other times the cause comes from the developer's buggy code.
    Maybe the code was pieced together from a cut-and-paste collage of code samples
    and stack overflow answers. Then the developer rushes to test the application
    once or twice, using the same workflow they use every time they write a component.
  prefs: []
  type: TYPE_NORMAL
- en: Maybe, though, something changed outside of the developer's control. Maybe a
    feature attribute that once held numeric values now contains strings. Maybe the
    API was updated and there was a fundamental change in the application. Maybe a
    REST data service is down, or maybe some bored kid is trying to input random data
    or malicious SQL injection code to bring down the website.
  prefs: []
  type: TYPE_NORMAL
- en: Testing through code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These are all good reasons to create tests for your applications. Testing is
    one method of ensuring that your code does as expected. It defines clear use cases,
    with clearly defined, expected results. Testing also acts as a sort of project
    documentation. It tells other developers who work with the project how the code
    is supposed to behave.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand why testing is important, let's look at the testing
    methodologies used by other developers over the years.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unit testing is when individual components or modules of code are loaded into
    a testing framework and tested individually. Tests are developed and results are
    compared to expected values. For object-oriented programming, individual objects
    can be loaded and tested without having to wait for other components to load.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript objects and modules lend themselves well to unit testing. Developers
    can write scripts to load modules individually, pass values into functions and
    objects, and see what comes out. Passing the tests ensures the JavaScript modules
    and objects will perform as far as expected test cases go.
  prefs: []
  type: TYPE_NORMAL
- en: However, unit testing doesn't prevent all errors. While they tests the input
    and output of objects and functions, they don't test how these objects interact.
    What happens when two or more memory-intense modules are running in the same browser?
    What happens to module A when input expected from module B times out? Also, unit
    testing doesn't address user experience concerns. It's hard to write a unit test
    for a map that pans slower than I think it should. Clearly, unit testing can't
    be the only tool in your testing tool belt.
  prefs: []
  type: TYPE_NORMAL
- en: Functional testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functional testing handles the testing of a single process, instead of a single
    unit. It makes many of the changes expected in a workflow, and checks that the
    results line up with what is expected. While one or more unit tests may cover
    the components tested in the functional test, the functional test connects them
    together to simulate a real-world example.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example might be the calculation of **Value Added Tax** (**VAT**) on an
    online purchase in European countries. You might have unit tests that cover the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Whether Italy has the correct VAT percentage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the subtotal of a list of purchased items costs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the total cost of a purchase would be after VAT is applied
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With a functional test, you can string them all together. You could ask, given
    that a person in Italy purchases these items, does the total cost after VAT matches
    what is expected.
  prefs: []
  type: TYPE_NORMAL
- en: End-to-end testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If unit testing examines the individual components of an application and functional
    testing tests a single workflow, then end-to-end testing examines the whole thing
    from beginning to end. The entire application is loaded into a platform specially
    designed for handling tests. A user script is loaded with predefined actions,
    such as text to enter or buttons to click. Any errors are logged by the system
    for review. Some testing frameworks even record screenshots or video of the testing
    process for review.
  prefs: []
  type: TYPE_NORMAL
- en: End-to-end testing is meant to catch the errors generated by components interacting
    with one another. They also tend to catch improper implementation of the components
    (that is human error). However, end-to-end testing can be expensive in terms of
    computer resources and time. The more use cases you test using end-to-end testing,
    the longer it will take to get results. End-to-end testing is typically saved
    for code releases or nightly build processes, while unit testing is expected to
    cover the minor code changes between releases.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of paid services available on the web for end-to-end testing.
    For some frameworks, such as Angular, there are testing frameworks such as **Protractor**.js
    that can be used for end-to-end testing, but if you want end-to-end testing that
    is both free and framework agnostic, you have options. Open source libraries such
    as Phantom.js, Casper.js, and web browser automation tools such as Selenium, can
    help you test your application from start to finish, with a bit of setup.
  prefs: []
  type: TYPE_NORMAL
- en: Testing as you code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many developers have found that the best time to test their code is when they
    are writing it. It's a horrible feeling when you spend all day writing a module,
    only to have it fail and not know why. By creating unit tests in the middle of
    development, the developer receives quick feedback regarding whether part of their
    code succeeds or fails. Now, let's look at some ways developers write tests as
    they code.
  prefs: []
  type: TYPE_NORMAL
- en: Test-Driven Development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Test-Driven Development** (**TDD**) is the process of writing unit tests
    and end-to-end tests, then writing code to pass those tests. Whenever code is
    refactored, it runs through the same tests to ensure results come out as expected.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Developers using TDD tend to code using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Write a test based on requirements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run all tests and see that the new test fails. This eliminates unnecessary tests
    and tests the overall testing framework.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write some code to pass the test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the tests again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refactor as necessary to clean up ugly code, names, and functionality.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat steps 1 to 5 until done.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By writing the test before writing code, the developer keeps their focus on
    the module's objectives and does not write unnecessary code. The tests also give
    the developer confidence in the code, and lead to faster code development.
  prefs: []
  type: TYPE_NORMAL
- en: Behavior-Driven Development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Behavior-Driven Development** (**BDD**) is a form of TDD that answers the
    question "how much should I test?". In BDD, tests for code modules and objects
    are written with descriptions that start with "It should do _____". Code tests
    are then written to test for those features and those only.'
  prefs: []
  type: TYPE_NORMAL
- en: BDD tests help to both define acceptance criteria and document code. By looking
    through the test descriptions, other developers will have a better idea of what
    the code is supposed to do. By describing acceptance criteria up front, the developer
    doesn't have to write extra code for use cases the code will never experience.
  prefs: []
  type: TYPE_NORMAL
- en: Test statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the heart of every TDD and BDD setup is the test statement. The test statements
    are lines of code written in a readable format to test properties and values of
    results. Test statements define a simple test within unit tests or functional
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the library you choose for generating test statements, they may
    follow a BDD `should` pattern, a TDD `expect` pattern, or a TDD `assert` pattern.
    Some libraries may let you use one or more of these patterns for your tests. For
    example, using the `Chai.js` library (which we''ll discuss a little later in the
    chapter), we can look at examples using any of the three patterns. Tests using
    the `should` pattern might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `expect` pattern may look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `assert` pattern should look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: All three formats test the same things. Their only difference is the syntax
    they use to get the same results. Depending on which testing formats your team
    likes to write, many of the testing libraries will have something in that flavor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve reviewed the general concepts behind software testing, let''s
    look at the tools we have to work with. In the last few years, the JavaScript
    community has produced a number of testing frameworks. Some are specific to a
    framework, such as Protractor for Angular, while others work with almost any library
    or framework, such as Mocha, Jasmine, or Intern. In this chapter, we''re going
    to examine two of them: Intern and Jasmine.'
  prefs: []
  type: TYPE_NORMAL
- en: Intern testing framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Intern ([https://theintern.github.io/](https://theintern.github.io/)) is a testing
    framework for testing websites and applications. Its website boasts that not only
    can it test plain JavaScript applications, but also test server-side websites
    built with Ruby and PHP, as well as mobile iOS, Android, and Firefox apps. Intern
    supports AMD and promises asynchronous testing.
  prefs: []
  type: TYPE_NORMAL
- en: If you're using Node.js in your development environment, Intern may integrate
    well. If you use Grunt, Intern comes with its own Grunt tasks for easy integration
    into your existing workflow. Intern also works with continuous integration services
    such as Jenkins and Travis CI.
  prefs: []
  type: TYPE_NORMAL
- en: Intern works in most modern browsers, including Android Browser, Chrome, Firefox,
    Safari, Opera, and Internet Explorer. For Internet Explorer, Intern works with
    versions 9 and later. If you need to test older versions of Internet Explorer,
    there is an `intern-geezer` module available through `npm`. The tests will work
    with Internet Explorer versions 6-8, which do not support EcmaScript 5, which
    is required by regular Intern.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up your testing environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you''re using Node.js, installation can be as simple as `npm install intern`.
    According to the website, Intern has a recommended folder structure for your projects,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up your testing environment](img/6459OT_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The makers of Intern recommend that you keep your source code and distributable
    code in folders separate from the tests. In that way, the tests aren't accidently
    published along with the code. You may not want people finding your tests, which
    could expose your secured services, private API keys, and sensitive passwords.
  prefs: []
  type: TYPE_NORMAL
- en: Special requirements for the ArcGIS JavaScript API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: According to reports from several users, using Intern with ESRI's hosted link
    to the ArcGIS API for JavaScript is not recommended. It can cause tests to fail
    where they shouldn't because a module and its dependencies load too slowly. The
    recommended solution is to download the API and the Dojo framework into folders
    alongside your project files. You can use Grunt, a Node.js task runner.
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests for Intern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Writing tests for Intern was achieved with modules like Dojo's AMD style in
    mind. Once module paths have been assigned, these modules can be loaded into tests
    and run. Let's look at how to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing with Intern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Writing unit tests for Intern is very similar to writing `Dojo` modules, with
    a few exceptions. Each unit test is made up of a `define()` function. The `define()`
    function may take either a function with a single `require` argument, or a list
    of string references to modules, and a function to run when all those modules
    have loaded. It is a common practice in Node.js modules to load them individually
    through a single `require()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to load a testing interface and an assertion library in the unit
    testing function. The testing interface provides a way to register testing suites.
    When calling the interface as a function, you provide a JavaScript object with
    descriptive key strings and values containing functions to run tests or objects
    to classify subtests. An example unit test is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `registerSuite` variable accepts Intern's object
    interface for creating tests, while `assert` accepts the `chai.assert` library
    loaded with Intern. The `registerSuite()`function is called, passing in two tests
    in an object. The first test looks at whether adding one and one will equal two,
    while the second test looks at adding two two's to see if that equals four. The
    `assert.equal()` function tests whether the result variable matches the expected
    result, and will throw an error with a text message should the test fail.
  prefs: []
  type: TYPE_NORMAL
- en: Test lifecycle with Intern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There may be something you need to do before you run your test in a testing
    suite, or before and after each test. This is the test lifecycle. Intern provides
    keywords in your test definitions to define what should happen during the test
    lifecycle. All these lifecycle functions are optional, but they will help you
    to create useable tests. Here is an outline of the general lifecycle of a test:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setup`: This function runs before any of the tests run, presumably to set
    up something to test against. For example, you may create a map here before you
    test your widget against it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'During each test, the following events occur:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`beforeEach`: This function will run before each test. As an example, you might
    load a fresh copy of your widget.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The test runs.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`afterEach`: This function will run after each test. Here, you might destroy
    the widget you created in the `beforeEach` function, or you might reset variable
    values that may have changed during tests.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`teardown`: This function runs after all the tests within the suite run. Here,
    you might destroy any maps or objects you created in the `setup` phase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can see an example of a unit test using the lifecycle in the following
    code. This one simulates loading a map and adding a widget to the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `define` statement looks a lot like the one we're
    familiar with, loading multiple objects at once. Note that the `map` is created
    on `setup` and destroyed on `teardown`, while the `widget` is newly created before
    each test and destroyed after each test.
  prefs: []
  type: TYPE_NORMAL
- en: Jasmine testing framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're looking for a simple BDD framework to test your application, Jasmine
    might have what you need. Jasmine is a framework-independent BDD library that
    can be used to run tests on JavaScript applications. It can either be installed
    through Node.js, or the library can be downloaded and copied to the test project
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Jasmine loads its test in an HTML file called a `SpecRunner` (short for specifications
    runner). This page loads the main Jasmine library, as well as all the user libraries
    and unit tests. Once loaded, the Jasmine library runs tests in the browser and
    displays the results.
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests for Jasmine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we have the `SpecRunner` in place, it's time to write tests. Tests are
    written using normal JavaScript logic and a few testing objects and methods provided
    by Jasmine. Let's look at some of the different parts.
  prefs: []
  type: TYPE_NORMAL
- en: Writing suites, specs, and tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Jasmine tests are organized by suites, specs, and tests. Suites make up the
    top level, and describe the unit tested. In fact, Jasmine tests write the suites
    using the `describe()` function, which describes the feature to be tested. The
    arguments for the `describe()` function include a string describing the feature,
    and a function to run the tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specs for the features can be written using the `it()` function in the `describe`
    suite. The `it()` function, like the `describe()` function, contains a string
    to describe the test and a function where a test is performed on the behavior.
    Any errors that occur in the `it()` function lead to a failing test, while an
    `it()` function that runs successfully shows a passing test for the behavior.
    In the following you can see an example of a `describe()` and `it()` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside each spec is one or more tests. In Jasmine, tests are written in the
    expect format. Based on the object passed to the `expect` object, you have numerous
    tests that can be performed on it, such as whether or not it equals a specific
    value, or whether it comes back as a "truthy" JavaScript statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Setup and teardown
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are times when you will need to load modules or create JavaScript objects
    to test. You may also want to reset them between tests and tear them down to save
    memory. To set up and tear down items to be tested, you would use the `beforeEach`
    and `afterEach` functions. Each one lets you set up and tear down values between
    tests, so that each test has fresh values that are repeatable. These are loaded
    in the suites, and are supposed to be called before any specs that require them
    are called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Ignoring tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What if your module has a depreciated feature? What if you expect your module
    to have a feature one day, but you don''t want to write a test that fails now.
    You could delete or comment out the code, but in doing so you lose some of the
    history of your module in some respect. Jasmine has a way of disabling suites
    and marking specs as pending without losing code. By replacing your `describe`
    statements with `xdescribe`, and your `it` statements with `xit`, you can write
    tests that won''t fail now, but will be marked as "pending". You can find an example
    in the following code that uses `xit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Red-light green-light
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many developers who write TDD and BDD tests practice red-green testing, which
    is supported in Jasmine. Red stands for a failed test, while green stands for
    a passed test. In red-green testing, a developer does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Writes a necessary unit test that they know will fail (red).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Writes code for the object or module so that the test passes (green).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refactors the code as needed, making sure it still passes the test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeats steps 1 to 3 until both the code and tests are satisfactory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the red-green testing method, the developer keeps the tests in mind as
    they develop module functionality. Passing tests gives the developer confidence
    in their code, and allows for faster development.
  prefs: []
  type: TYPE_NORMAL
- en: In Jasmine, test results on the `SpecRunner` HTML page are displayed using red
    and green colors. Red colors are shown when a test fails, while green colors show
    when all tests pass. The `SpecRunner` page will display which specification failed
    (if any), and the error thrown when the failure occurred. Armed with that information,
    the developer can fix the problem and move on to the next step in development.
  prefs: []
  type: TYPE_NORMAL
- en: Jasmine and the ArcGIS JavaScript API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Setting up your `SpecRunner` for applications using the ArcGIS JavaScript API
    is a little more challenging. The AMD nature of the Dojo framework makes loading
    the modules and tests a little more challenging, but it can be done.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to load the Jasmine and ArcGIS JavaScript APIs into the application.
    Due to all the parts that Jasmine has to handle outside our application, and because
    AMD modules tend to not show up when errors occur, we need to load Jasmine before
    the ArcGIS JavaScript API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You will be able to load the locations of both your modules, and the tests
    on those modules, in the `dojoConfig` packages. We will be using the AMD loader
    to load the test suites as modules. In the following example, the AMD modules
    are in the `js` subfolder, while the spec tests are in the `tests` subfolder.
    The `dojoConfig` package should look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Since many of your custom widgets will require other modules, including other
    custom modules, to load, you need to keep the path for your custom modules the
    same as in your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the body of the HTML document, add a script to call the specs through Dojo''s
    `require()` function. The code will load the specs out of the tests subfolder
    through AMD. When the modules have loaded and the `dojo/ready` function is called,
    we will load Jasmine''s `HtmlReporter` and execute the Jasmine testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When the tests are loaded and run, they will be rendered on this HTML page in
    the browser.
  prefs: []
  type: TYPE_NORMAL
- en: In the specs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Normally, Jasmine specs can either be run as a script or enclosed in a self-running
    JavaScript function. However, to work with Dojo, they need to be enclosed in module
    definitions. Unlike the custom modules we've made in the past, we won't use the
    `dojo/_base/declare` module to make a custom module. We'll simply use the `define()`
    statement to load the necessary modules, and run the test inside it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each suite, use the `define()` statement to help load the tests. You could
    also load any other ArcGIS JavaScript API modules or widgets you might need to
    help test the module. The code for the `Widget1` spec, as requested by the main
    app, might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Start writing Jasmine specs in the `define` statement. When the suite modules
    are loaded, they will automatically run any tests inside them and display the
    results on the `SpecRunner` page in the browser. You can use `beforeEach` to load
    a fresh module for testing, and `afterEach` to destroy it, if necessary. You can
    perform any custom ArcGIS JavaScript API-related tasks within the suites and specs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have your tests defined, you can view the `SpecRunner` page in the
    browser and check out the results. If you have set everything up, you should have
    tests running and displaying results. Have a look at the following screenshot
    for an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![In the specs](img/6459OT_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Use case for Jasmine and the ArcGIS JavaScript API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Jasmine provides an easy-to-write testing environment for your JavaScript widgets.
    If you are new to unit testing and BDD, and you aren't comfortable with setting
    up the Node.js environment on top of your tests, then Jasmine is a good place
    to start. All the libraries you need can be downloaded from GitHub, and you can
    begin writing tests almost right away.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Jasmine can be downloaded from its GitHub repository at [https://github.com/jasmine/jasmine](https://github.com/jasmine/jasmine).
    Documentation for Jasmine can be found at [http://jasmine.github.io/.](http://jasmine.github.io/.)
    If you are interested in more reading material on this framework, you can read
    *Jasmine JavaScript Testing, Second Edition* by Paulo Ragonha, or *Jasmine Cookbook*
    by Munish Sethi.
  prefs: []
  type: TYPE_NORMAL
- en: Our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our application, we're going to set up unit testing for our Y2K map app
    using Intern. Unlike our other applications, which only required a browser, we're
    going to use Node.js for this setup. If we were following real TDD/BDD practices,
    we would have written these tests while we were developing the application. However,
    this will give you practice writing tests for any legacy applications you've previously
    written.
  prefs: []
  type: TYPE_NORMAL
- en: For this sample, we'll follow the example provided by David Spriggs and Tom
    Wayson through GitHub ([https://github.com/DavidSpriggs/intern-tutorial-esri-jsapi](https://github.com/DavidSpriggs/intern-tutorial-esri-jsapi)).
    We'll make some modifications to work with more recent updates in both the ArcGIS
    JavaScript API and in the modules associated with the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Adding testing files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our Y2K application, we're going to add several files to work with the required
    Node.js modules. We'll add a `package.json` file, which tells the **Node Package
    Manager** (**NPM**) what modules we need and what version numbers we require.
    Next, we'll add a `Grunt.js` file, since we'll use Grunt to load the ArcGIS JavaScript
    API locally. We'll also add a `bower.json` file for Bower to load the correct
    `Dojo` libraries locally, and a `.bowerc` file to configure Bower when we run
    it. Finally, we're going to add an `intern.js` file in a `tests` folder to configure
    the Intern tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our new folder structure should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding testing files](img/6459OT_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The package.json file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In our `package.json` file, we''ll add the file dependencies required for our
    Node.js modules. When specifying version numbers for some of the modules, you''ll
    note that some have a tilde (~) in front while others have a caret symbol(`^`).
    A tilde matches both major and minor version numbers (the first and second numbers
    in the three-number version code), while the caret will pull the most recent matching
    major version number. Copy the following into your `package.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The Grunt setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Grunt is a popular task runner used in Node.js applications. It''s used to
    automate code building steps, such as minifying JavaScript, creating CSS files
    from CSS preprocessors like LESS or SASS, or, in this case, testing code. Grunt
    reads a `Grunt.js` file, which tells it where to look for files and what to do
    with them. In our `Grunt.js` file, we''re going to add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, Node.js expects that we will pass our module definition
    to the `module.exports` variable. We tell Grunt where to find our `intern` module
    for testing in `grunt.initConfig`, and `esri_slurp` for downloading the ArcGIS
    JavaScript API. We also tell it to watch the `src/js/` folder for any changes
    to JavaScript files, which will trigger the tests to run again.
  prefs: []
  type: TYPE_NORMAL
- en: Once the configuration has loaded, we tell Grunt to load the modules for `intern`,
    `grunt-contrib-watch`, and `grunt-esri-slurp` to modules from `npm`. The tasks
    are then registered, and everything is set up to run the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Bower
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bower is a Node.js module used to download all the required JavaScript libraries
    for a project automatically. We will use Bower to download the libraries and Dojo
    modules necessary to run our tests. Most common libraries and frameworks can be
    downloaded locally through Bower. Our exception in this case is the ArcGIS JavaScript
    API, which will currently be handled through `esri-slurp`. We need to fill out
    a `bower.json` file to tell Bower what libraries we need, and what library versions
    they should be as well.
  prefs: []
  type: TYPE_NORMAL
- en: Within our `bower.json` file, we need to create a JSON object to list our project
    name, version number, dependencies, and any development dependencies. We can name
    it whatever we want, so we'll name it `y2k-map-app`. We'll give it a version of
    `0.0.1` for testing, and we'll be sure to increment it whenever dependencies or
    library version numbers need to be updated. We have no development dependencies
    in this case, but we do need to list the parts of the Dojo framework, as well
    as `D3.js` , in this application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We not only need to list the libraries and modules required for the tests,
    but the version numbers as well. We can refer to the ArcGIS JavaScript API *What''s
    New* page at [https://developers.arcgis.com/javascript/jshelp/whats_new.html](https://developers.arcgis.com/javascript/jshelp/whats_new.html)
    to find out. According to the page, we need version `1.10.4` of the Dojo framework,
    including `dojo`, `dijit`, `dojox`, and `util` modules from `dojo/util`. We also
    need to add the `dgrid` modules with version `0.3.16`, `put-selector` version
    `0.3.6`, and `xstyle` version `0.1.3`. Referring back to the `dojoConfig` packages
    from our `index.html` page, we see that `d3.js` is using version `3.5.6`. We''ll
    list the dependencies within a JSON object, with the version numbers preceded
    by a `#` sign. The contents of our `bower.json` file should be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `.bowerc` file, we''re going to add a simple configuration object.
    In the configuration object JSON, we''re going to add a directories field and
    assign a value of `.`. This will tell Bower to load the files requested in this
    folder. The contents of the `.bowerc` file should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Intern.js configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we need to set up our `Intern.js` configuration file in the `tests` folder
    to run our tests. We''ll start by adding some default code in the page. More information
    on this configuration file can be found at [https://github.com/theintern/intern/wiki/Configuring-Intern](https://github.com/theintern/intern/wiki/Configuring-Intern).
    Start by copying the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `loader.packages` list, we''ll add the folder locations of all the
    files we expect to have. These will include both the files we have now, plus the
    files we expect to download through Bower. Note that our `app` folder is referenced
    through the folder where our `Census` widget is stored. Also, we''re loading all
    the ESRI and Dojo files, as well as `D3.js` for the graphics. Your packages portion
    should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to add the names of our test suites to the suites list. For now, we''ll
    add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We should have everything we need in this file to run some successful tests
    on the `Census` widget. As we add more modules, we can expand this point with
    more tests.
  prefs: []
  type: TYPE_NORMAL
- en: We should be ready at this point to load the files we need through Node.js.
    If you haven't installed Node.js or any of the other node dependencies for this
    application, please follow the next section. If you already have, you can still
    review the next section, or skip it if you're already familiar with Grunt and
    Bower.
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't installed Node.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we'll go through the necessary steps to set up Node.js and
    the necessary dependencies. In these examples, we'll be working with NPM, Grunt,
    Grunt-CLI, and Bower. If you already have these set up in your development environment,
    you can skip to the next section.
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't installed Node.js, you can download a copy from [http://nodejs.org](http://nodejs.org).
    On the home page, you'll find a link to the appropriate installer for your computer.
    Follow the directions in the installation wizard to install the software.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js works through a command-line interface. All commands will be typed in
    either through a Linux or OSX terminal, or through the Windows command prompt
    (`cmd.exe`). Some portions may need you to have root or administrative access.
    Also, if you're using a Windows machine, the `PATH` variable may need to be updated
    to include both the `node.js` folder and its `node_modules` subfolder, where other
    commands and utilities will be loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, if you have not installed the `grunt`, `grunt-cli`, and `bower` modules,
    we''ll install them using `npm`. NPM comes built into Node.js and provides access
    to a multitude of plugins, libraries, and applications to help you generate applications
    faster. From your command prompt (or terminal), type the following to download
    the modules we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `–g` flag tells `npm` to install the modules globally, so that they can
    be accessed anywhere that Node.js and `npm` can be called. Without the `–g` flag,
    the module will be loaded in a `node_modules` subfolder of your current directory.
  prefs: []
  type: TYPE_NORMAL
- en: Loading all the libraries locally
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now it is time to load all of the Node.js applications necessary for testing.
    We''re going to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Install all of our modules from `npm`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load most of the external JavaScript libraries locally using Bower.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the ArcGIS JavaScript API using Grunt Slurp.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ll start by loading all the modules from `npm`. You will need to use a
    command line tool like Windows command prompt (`cmd.exe`) or `terminal` for Mac
    or Linux to run the code. Our `package.json` file defines the modules we need
    to run. We can install the modules by typing the following in the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need to test for features in older browsers, such as Internet Explorer
    8 or earlier, we will need to install an Intern extension called `intern-geezer`.
    It allows tests to work on older browsers that may not have the features used
    in standard Intern. If you need the older support, enter the following into the
    command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To load our JavaScript libraries locally, we can call on Bower to install the
    files. Our `bower.json` file tells it what to load, and our `.bowerc` file tells
    it where to load it. Enter the following into the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to load the ArcGIS JavaScript library for local testing. Since
    we defined everything for this task in our `Grunt.js` file, we can simply enter
    the following into the command line to download the files and start up our testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now our project should be up and running. We can now focus on writing tests
    for our application.
  prefs: []
  type: TYPE_NORMAL
- en: Writing our tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will be writing tests using the same `dojo` module definition style we used
    with creating objects, and similar to the Jasmine tests we talked about earlier.
    However, since Intern is designed for AMD, we can load the intern items within
    the module `define()` statements. In our tests folder, we'll create a file called
    `Census.js`, and let that contain our test module definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by stubbing out our `define()` statement. We will load both Intern
    and Chai to run our tests. With Chai, we''ll try using the `assert` module, where
    all test statements start with `assert`. We''ll also load our `Census` widget
    and all the modules necessary to get it working, like a map. Since Intern typically
    runs without requiring HTML DOM, but our maps and `Census` widget require it,
    we''ll add some modules to add elements to the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the module definition, we''ll add the variables for our map and `Census`
    widget, and then register our suite with Intern using `registerSuite()`. In the
    `registerSuite()` function, we''ll pass an object containing the test name `Census
    Widget`. We''ll also add two methods, `setup()` and `teardown()`, to call before
    and after all the tests have run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the setup function, we''ll need to create the DOM, the map to attach to
    the DOM, and the `Census` widget to attach to the map. We''ll use the `dojo/dom-construct`
    and the `dojo/_base/window` modules to create the DOM for both. Once the DOM elements
    have been created, we can initialize our map and census dijit. In our `teardown`
    function, we''ll destroy the map so that it doesn''t take up valuable memory space.
    The code should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the map and the `Census` widget have been initialized, we can start
    adding tests. I''ll walk you through three relatively straightforward tests. It
    is up to you to extend them further. In this exercise, we''ll test the `Census`
    dijit for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It should have all its working parts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should return the correct query results when we make a known request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parts of the charting widget should work as expected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When writing the first test, we''ll give it a label of `Test Census widget
    creation`. For the corresponding function, we''ll start by testing if the `baseClass`
    for the dijit is as expected. We''ll use `assert.strictEqual()` to test whether
    the value is correct. Note that `assert.strictEqual()` takes three arguments,
    two values to compare, and a string description of the test. That test should
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Our second test may seem a little tricky, since it's an asynchronous test. However,
    Intern is designed to handle asynchronous testing as well. If necessary, we can
    tweak Intern's timeout before it considers the task failed, but for now we will
    just load the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the query test, we''ll send a query to the map service with all the states,
    and ask for a list of the states. Using a `then()` statement after the query,
    we can grab the results and test those using `assert.strictEqual()`. The test
    should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, for the graphing functions, we''ll write tests to look at the functions
    we use to translate feature attribute data into a format that D3 can use. In this
    example, we''ll pass attribute data through the `census.ethnicData()` method and
    test the output for expected values. Like other testing libraries, we can add
    more than one test within this specification. The test should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Checking the results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to check our tests, we need to load our file in the browser. Since
    we installed Intern as a node module, we''ll need to view its test-running page.
    The file is located under `node_modules/intern/client.html`. You will need to
    specify where the tests are loaded in the browser by giving a query parameter
    of `config=tests/intern`. The following URL is an example you might view in a
    browser (it may be different depending on your setup): `http://localhost/MasteringArcGIS/Chapter10/node_modules/intern/client.html?config=tests/intern`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you correctly view the page, you''ll be greeted with the Intern icon and
    a pass/fail report. Failing tests will be highlighted in red, while passing tests
    will be highlighted in green. You should see something like the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Checking the results](img/6459OT_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have reviewed the reasons why we want to set up tests for
    our web applications. We have looked over different testing methodologies, development
    practices, and JavaScript libraries useful for testing our applications. Using
    Intern, we have set up tests for our own application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look into the future of web applications for ArcGIS
    Server, checking into ArcGIS Online.
  prefs: []
  type: TYPE_NORMAL
