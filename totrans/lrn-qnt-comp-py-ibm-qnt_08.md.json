["```py\n    # Load helper file\n    %run helper_file_1.0.ipynb\n    # Import the transpiler passes object\n    from qiskit.transpiler import passes\n    # List out all the passes available\n    print(dir(passes)) \n    ```", "```py\n# Get a list of all available backend devices\nservice.backends()\n# From the list of backends, select two.\n# Get the backend device: ibm_brisbane\nbackend_brisbane = service.get_backend('ibm_brisbane')\n# Get the backend device: ibm_nazca\nbackend_nazca = service.get_backend('ibm_nazca') \n```", "```py\n# Visualize the coupling directional map between the qubits\nplot_gate_map(backend_brisbane, plot_directed=True) \n```", "```py\n# Visualize the coupling directional map between the qubits\nplot_gate_map(backend_nazca, plot_directed=True) \n```", "```py\n    # Quantum circuit with a single and multi-qubit gates\n    qc = QuantumCircuit(4)\n    qc.h(0)\n    qc.cx(0,1)\n    qc.cx(0,2)\n    qc.cx(0,3)\n    circuit_drawer(qc) \n    ```", "```py\n# Generate a preset pass manager for Brisbane\npass_manager = generate_preset_pass_manager(backend=backend_brisbane, optimization_level = 0)\n# Transpile the circuit with an optimization level = 0\nqc_brisbane_0 = pass_manager.run(qc)\n# Print out the depth of the circuit\nprint('Depth:', qc_brisbane_0.depth())\n# Plot the resulting layout of the quantum circuit after # Layout\nplot_circuit_layout(qc_brisbane_0, backend_brisbane) \n```", "```py\n    # Draw the transpiled circuit pertaining to Brisbane\n    circuit_drawer(qc_brisbane_0, idle_wires=False, output='mpl') \n    ```", "```py\n    # Generate a preset pass manager for Brisbane\n    pass_manager = generate_preset_pass_manager(backend=backend_brisbane, optimization_level = 0)\n    # Transpile the circuit with an optimization level = 0\n    qc_brisbane_0 = pass_manager.run(qc)\n    print('Depth:', qc_nazca_0.depth())\n    plot_circuit_layout(qc_nazca_0, backend_nazca) \n    ```", "```py\nDepth: 4040 \n```", "```py\n    # Draw the transpiled circuit pertaining to Nazca\n    circuit_drawer(qc_nazca_0, idle_wires=False, output='mpl') \n    ```", "```py\n    # Generate a preset pass manager for Brisbane:\n    pass_manager = generate_preset_pass_manager(backend=backend_brisbane, optimization_level=3)\n    # Transpile the circuit with the optimization level = 3\n    qc_transpiled_brisbane= pass_manager.run(qc)\n    # Print the depth of the transpiled circuit\n    print('Depth:', qc_transpiled_brisbane.depth())\n    # Print the number of operations of the transpiled # circuit\n    print('Ops count: ', qc_transpiled_brisbane.count_ops())\n    # Plot the layout mapping of the transpiled circuit\n    plot_circuit_layout(qc_transpiled_brisbane, backend_brisbane) \n    ```", "```py\nDepth: 133\nOps count:  OrderedDict([('rz',14), ('sx', 7), ('ecr', 3), ('x', 1)]) \n```", "```py\n    # Redraw the transpiled circuit at new level\n    circuit_drawer(qc_transpiled_brisbane, idle_wires=False, output='mpl') \n    ```", "```py\n    # Generate a preset pass manager for Nazca:\n    pass_manager = generate_preset_pass_manager(backend=backend_nazca, optimization_level=3)\n    # Transpile the circuit with the optimization level = 3\n    qc_transpiled_nazca= pass_manager.run(qc)\n    # Get the depth and operation count of the transpiled\n    # circuit.\n    print('Depth:', qc_transpiled_nazca.depth())\n    print('Ops count: ', qc_transpiled_nazca.count_ops())\n    # Print the circuit layout\n    plot_circuit_layout(qc_transpiled_nazca, backend_nazca) \n    ```", "```py\nDepth: 1919\nOps count:  OrderedDict([('rz', 23), ('sx', 13), ('ecr', 3)]) \n```", "```py\n    # Draw the transpiled circuit\n    circuit_drawer(qc_transpiled_nazca, idle_wires=False, output='mpl') \n    ```", "```py\n    # Set the ibm_brisbane backend device to obtain #configuration\n    backend = service.get_backend('ibm_brisbane')\n    backend \n    ```", "```py\n    # View the backend coupling map, displayed as CNOTs\n    # (Control-Target)\n    # Extract the coupling map from the backend\n    ibm_brisbane_coupling_map = backend.configuration().coupling_map\n    # List out the extracted coupling map\n    ibm_brisbane_coupling_map \n    ```", "```py\n[[1, 0],\n[2, 1],\n[3, 2],\n[4, 3],\nâ€¦\n[125.126]] \n```", "```py\n    # Generate a preset pass manager for Brisbane\n    # Set the backend to None so it will force using the coupling map provided:\n    pass_manager = generate_preset_pass_manager(backend=None,\n    optimization_level=3,\n    coupling_map=ibm_brisbane_coupling_map)\n    # Transpile the circuit with the pass manager\n    qc_custom = pass_manager.run(qc)\n    # Draw the resulting custom topology circuit.\n    circuit_drawer(qc_custom, idle_wires=False, output='mpl') \n    ```", "```py\n    # Create our own coupling map (custom topology)\n    custom_linear_topology = [[0,1],[1,2],[2,3],[3,4]]\n\n    # Generate a preset pass manager\n    # Set the backend to None so it will force using the coupling map provided:\n    pass_manager = generate_preset_pass_manager(backend=None,\n    optimization_level=3,\n    coupling_map=custom_linear_topology)\n    # Transpile the circuit with the pass manager\n    qc_custom = pass_manager.run(qc)\n    # Draw the resulting custom topology circuit.\n    circuit_drawer(qc_custom, idle_wires=False, output='mpl') \n    ```", "```py\n    # Import the PassManager and a few Passes\n    from qiskit.transpiler import PassManager, CouplingMap\n    from qiskit.transpiler.passes import TrivialLayout, BasicSwap\n    pm = PassManager()\n    # Create a TrivialLayout based on the ibm_brisbane coupling map\n    trivial = TrivialLayout(CouplingMap(ibm_brisbane_coupling_map))\n    # Append the TrivialLayout to the PassManager\n    pm.append(trivial)\n    # Run the PassManager and draw the resulting circuit\n    tv_qc = pm.run(qc)\n    circuit_drawer(tv_qc, idle_wires=False, output='mpl') \n    ```", "```py\n    # Create a BasicSwap based on the ibm_brisbane coupling\n    # map we used earlier\n    basic_swap = BasicSwap(CouplingMap(ibm_brisbane_coupling_map))\n    #Add the BasicSwap to the PassManager\n    pm = PassManager(basic_swap)\n    # Run the PassManager and draw the results\n    new_qc = pm.run(qc)\n    circuit_drawer(new_qc, idle_wires=False, output='mpl') \n    ```", "```py\n    # Sample quantum circuit\n    qc = QuantumCircuit(4)\n    qc.h(0)\n    qc.cx(0,1)\n    qc.barrier()\n    qc.cx(0,2)\n    qc.cx(0,3)\n    qc.barrier()\n    qc.cz(3,0)\n    qc.h(0)\n    qc.measure_all()\n    # Draw the circuit using the default renderer\n    circuit_drawer(qc, output='mpl') \n    ```", "```py\n    circuit_drawer(qc, output='latex') \n    ```", "```py\n    # Define the style to render the circuit and components\n    style = {'backgroundcolor': 'lightblue','gatefacecolor':     'white', 'gatetextcolor': 'black', 'fontsize': 9}\n    # Draw the mpl with the specified style\n    circuit_drawer(qc, style=style, output='mpl') \n    ```", "```py\n# Import the Circuit to DAG converter\nfrom qiskit.converters import circuit_to_dag\n# Import the DAG drawer\nfrom qiskit.visualization import dag_drawer\n# Convert the circuit into a DAG\ndag = circuit_to_dag(qc)\n# Draw the DAG of the circuit\ndag_drawer(dag) \n```"]