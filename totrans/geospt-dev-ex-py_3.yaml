- en: (u'@xmlns', u'http://geocaching.com.au/geocache/1')
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: (u'desc', u'LaSalle Park No 1 by Mr.Yuck, Unknown Cache (1/1)') (u'urlname',
    u'LaSalle Park No 1')
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: (u'owner', u'Mr.Yuck')
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: (u'difficulty', u'1')
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: (u'sym', u'Geocache')
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: (u'terrain', u'1')
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: (u'status', u'Available')
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '**Importing massive amount of data**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Now that our environment is ready, we can begin working with bigger datasets.
    Let’s start by profiling the import process and then optimize it. We will start
    with our small geocaching dataset and after the code is optimized we will move
    to bigger sets.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '1\. In your geodata_app.py file, edit the if __name__ == ''__main__'': block
    to call the profiler.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: profile = cProfile.Profile()
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: profile.enable()
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: import_initial_data("../data/geocaching.gpx", 'geocaching') profile.disable()
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: profile.print_stats(sort='cumulative')
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Run the code and see the results. Don’t worry about duplicated entries in
    the database now, we will clean it later. (I removed some information from the
    following output for space reasons.)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Importing geocaching…
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 112 features.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Done!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 1649407 function calls (1635888 primitive calls) in 5.858 seconds cumtime percall
    filename:lineno(function)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 5.863 5.863 geodata_app.py:24(import_initial_data)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 5.862 5.862 managers.py:11(import_data)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 4.899 0.002 related.py:749(create)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 4.888 0.002 manager.py:126(manager_method)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 3.621 0.001 base.py:654(save)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 3.582 0.001 base.py:737(save_base)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 3.491 0.001 query.py:341(create)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 1.924 0.001 base.py:799(_save_table)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: ncalls tottime percall cumtime percall filename:lineno(function) 1 0.001 0.001
    5.863 5.863 (import_initial_data) 1 0.029 0.029 5.862 5.862 (import_data)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 2497 0.018 0.000 4.899 0.002 related.py:749(create) Take a look at ncalls and
    cumtime for each of the functions. The create function is called a lot of times
    and accumulates almost five seconds on my computer. This is the function (method)
    called when we add a tag to a GeoObject. The time spent on this function is relevant
    when we import geocaching data because every point has a lot of attributes. Maybe
    we can make this process more efficient.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '**Optimizing database inserts**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in the profiler, the method we are using to insert the tags into the
    database creates a bottleneck when we import geocaching data with our current
    code. If we can change how it’s done, we can make the code run faster.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Go to your manager and edit the import_data method of the GeoCollection
    manager:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'class GeoCollection(GeoManager):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '"""This class represents a collection of spatial data."""'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'def import_data(self, file_path, atype):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '"""Opens an vector file compatible with OGR and parses the data.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: ':param str file_path: The full path to the file.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: from models import Tag
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: features = open_vector_file(file_path)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: tags = []
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'for feature in features:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: geom = shape(feature['geometry'])
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: geo_object = self.model(geom=geom.wkt, atype=atype)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: geo_object.save()
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: geoo_id = geo_object.id
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'for key, value in feature[''properties''].iteritems():'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: tags.append(Tag(key=key, value=value,
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: geo_object_id=geoo_id))
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Tag.objects.bulk_create(tags)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Instead of creating the tags one by one, now we add them to a list without hitting
    the database; only in the end do we call bulk_create, which inserts all entries
    in a single request. Note that the import statements for the Tag model are inside
    the function.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: This will avoid an error with circular imports, because models also import the
    managers.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Run your code and see what happens:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'django.db.utils.DataError: value too long for type character varying(250)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 1
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Since bulk_insert sends everything together to the database, we can’t catch
    exceptions for individual tags.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: The solution is to validate the tag before we insert it. At this point we are
    making a trade-off between generalization and performance because the validation
    may fail depending on the type of data, whereas the error catching could be triggered
    by a wide range of reasons.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Edit the code again:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'class GeoCollection(GeoManager):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '"""This class represents a collection of spatial data."""'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'def import_data(self, file_path, atype):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '"""Opens an vector file compatible with OGR and parses the data.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: ':param str file_path: The full path to the file.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: from models import Tag
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: features = open_vector_file(file_path)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: tags = []
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'for feature in features:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: geom = shape(feature['geometry'])
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: geo_object = self.model(geom=geom.wkt, atype=atype)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: geo_object.save()
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: geoo_id = geo_object.id
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'for key, value in feature[''properties''].iteritems():'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: if value and (isinstance(value, unicode)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'or isinstance(value, str)):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'if len(value) <= 250:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: tags.append(Tag(key=key, value=value,
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: geo_object_id=geoo_id))
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Tag.objects.bulk_create(tags)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Now run geodata_app.py again and look at the profiler results: 506679 function
    calls (506308 primitive calls) in 1.144 seconds Ordered by: cumulative time'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: ncalls cumtime percall filename:lineno(function)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 1 1.144 1.144 geodata_app.py:24(import_initial_data)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 1 1.142 1.142 managers.py:12(import_data)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 1 0.556 0.556 geo_functions.py:91(open_vector_file)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 1 0.549 0.549 geo_functions.py:9(read_gpx_file)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '**1 0.541 0.541 xmltodict.py:155(parse)**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 1 0.541 0.541 {built-in method Parse}
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 6186 0.387 0.000 pyexpat.c:566(StartElement)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 6186 0.380 0.000 xmltodict.py:89(startElement)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 112 0.317 0.003 base.py:654(save)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 112 0.316 0.003 base.py:737(save_base)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 14/113 0.290 0.003 manager.py:126(manager_method)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 12487 0.278 0.000 collections.py:38(__init__)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 113 0.235 0.002 query.py:910(_insert)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 113 0.228 0.002 compiler.py:969(execute_sql)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 6186 0.178 0.000 xmltodict.py:84(_attrs_to_dict)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '**1 0.170 0.170 query.py:356(bulk_create)**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: The import now runs five times faster. Note how the profile changed. The database
    part of the process felt down on the list and now the most time-consuming part
    is the conversion from XML (the GPX file) to a dictionary.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the output, we also see that we have another.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have much more efficient code and we won’t change how the
    XML
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: conversion is done. Instead, we will move on to testing and optimizing the process
    for
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: other types of data.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '**Optimizing data parsing**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Remember that we made a branch in our code to import GPX files, because OGR/GDAL
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'was unable to import the nested data inside those files. So we should expect
    that when importing shapefiles or GML files, we will have a different profile
    for code execution time. Let’s try it:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Now we will test the code with the world borders dataset. Change the if
    __name__
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '== ''__main__'': block of geodata_app.py:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: profile = cProfile.Profile()
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: profile.enable()
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: import_initial_data("../data/world_borders_simple.shp",
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '''boundary'')'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: profile.disable()
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: profile.print_stats(sort='cumulative')
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Run the code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'ValueError: A LinearRing must have at least 3 coordinate tuples Process finished
    with exit code 1'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Well, it doesn’t work. What is happening here is that Shapely is complaining
    about the geometry that is being passed to it. This is because this branch of
    the code is passing a WKT geometry instead of coordinates.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Django can receive the geometry as a WKT and we are using Shapely for the conversion.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'This may be a time-consuming step and we are going to eliminate it. At this
    point, we are just using common sense to optimize the code: the fewer the steps,
    the faster the code.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Edit the GeoCollection manager:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'class GeoCollection(GeoManager):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '"""This class represents a collection of spatial data."""'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'def import_data(self, file_path, atype):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '"""Opens an vector file compatible with OGR and parses the data.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: ':param str file_path: The full path to the file.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: from models import Tag
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: features = open_vector_file(file_path)
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: tags = []
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'for feature in features:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: geo_object = self.model(geom=feature['geom'],
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: atype=atype)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: geo_object.save()
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: geoo_id = geo_object.id
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'for key, value in feature[''properties''].iteritems():'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: if value and (isinstance(value, unicode)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'or isinstance(value, str)): if len(value) <= 250:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: tags.append(Tag(key=key, value=value,
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: geo_object_id=geoo_id))
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Tag.objects.bulk_create(tags)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: We eliminated the Shapely use (you can remove it from the imports too) and changed
    how the geometry is retrieved from the dictionary.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Now go to geo_functions.py and edit the read_ogr_features function: def
    read_ogr_features(layer):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '"""Convert OGR features from a layer into dictionaries.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: ':param layer: OGR layer.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: features = []
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: layer_defn = layer.GetLayerDefn()
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: layer.ResetReading()
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: type = ogr.GeometryTypeToName(layer.GetGeomType())
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'for item in layer:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: attributes = {}
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'for index in range(layer_defn.GetFieldCount()):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: field_defn = layer_defn.GetFieldDefn(index)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: key = field_defn.GetName()
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: value = item.GetFieldAsString(index)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: attributes[key] = value
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: feature = {
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '"geom": item.GetGeometryRef().ExportToWkt(),'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '"properties": attributes}'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: features.append(feature)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: return features
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'As a trade-off between generalization and performance, we changed the feature
    dictionary from the universal GeoJSON format to contain only two keys: geom with
    a WKT geometry and properties.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Now edit the read_gpx_file function so it’s compliant with the new format:
    def read_gpx_file(file_path):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '"""Reads a GPX file containing geocaching points.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: ':param str file_path: The full path to the file.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'with open(file_path) as gpx_file:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: gpx_dict = xmltodict.parse(gpx_file.read())
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: output = []
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'for wpt in gpx_dict[''gpx''][''wpt'']:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: geometry = "POINT(" + wpt.pop('@lat') + " " + \ wpt.pop('@lon') + ")"
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: If geocache is not on the dict, skip this wpt.
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'try:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: geocache = wpt.pop('geocache')
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'except KeyError:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: continue
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'attributes = {''status'': geocache.pop(''@status'')}'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Merge the dictionaries.
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: attributes.update(wpt)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: attributes.update(geocache)
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Construct a GeoJSON feature and append to the list.
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: feature = {
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '"geom": geometry,'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '"properties": attributes}'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: output.append(feature)
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: return output
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Run your code again (you can also test importing points again if you wish,
    you will get a few milliseconds of improvement). Look at the result: Importing
    boundary…'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 245 features.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Done!
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 90746 function calls (90228 primitive calls) in 5.164 seconds
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 63](img/index-376_1.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
- en: '**Importing OpenStreetMap points of interest**'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '**OpenStreetMap** (**OSM**) is a collaborative mapping project where everyone
    can make an account and collaborate in the map making. It’s something like Wikipedia,
    but instead of articles the community make maps.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: The data is all available for download, and some regions have incredibly detailed
    maps.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: What we want here is to get **points of interest** (**POI**). These are points
    that represent the location of restaurants, supermarkets, banks, and so on.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshot of Boulevard Saint-Laurent in Montreal.
    Each one of those small icons is a POI:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: OSM data can be easily obtained using its API, which is called **Overpass API**.
    It allows the user to make advanced queries and filter data of interest.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: The obtained data is in XML format adapted for OSM needs. We are going to use
    overpy, a Python package that translates this data into Python objects.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: At this point, I have to admit that through my career I have been deeply inspired
    by OSM
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: and its data format. It’s simple and yet flexible, to the point where everything
    in OSM is represented by the same schema.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: OSM consists of nodes, a lot of nodes. Actually by this date it had 3,037,479,553
    nodes.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 64](img/index-377_1.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
- en: That’s right, more than three billion nodes. Nodes can be points or can be related
    to other nodes as part of something represented by a line or polygon.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'Every node can have an arbitrary number of tags made of key/value pairs, just
    like our data. Take a look at the information obtained from one of the POI: So,
    storing OpenStreetMap POIs in our database will be pretty straightforward. First,
    let’s create a utility function to download points for a given region of interest.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Go to the utils folder and create a new Python file named osm_data.py.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Add the following code to this file:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import overpy
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'def get_osm_poi(bbox):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '"""Downloads points of interest from OpenStreetMap.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: ':param bbox: The bounding box of the region to get the points.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: api = overpy.Overpass()
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: result = api.query("""
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: <osm-script>
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: <query type="node">
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: <bbox-query s="{ymin}" n="{ymax}" w="{xmin}" e="{xmax}"/>
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: <has-kv k="amenity"/>
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: </query>
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: <print/>
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: </osm-script>
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '""".format(**bbox))'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: print("Found {} POIs".format(len(result.nodes)))
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: return result
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == "__main__":'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: bbox = {"xmin":-71.606, "ymin":46.714,
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '"xmax":-71.140, "ymax":48.982}'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: result = get_osm_poi(bbox)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: print(result.nodes[0].tags)
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a simple wrapper for overpy that queries all points in a given region
    and has the amenity key. In the if __name__ == ''__main__'': block, we make a
    simple test, get some points, and print the tags of one of them.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get more information on the Overpass API at this site:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[http://wiki.openstreetmap.org/wiki/Overpass_API/Language_Guide](http://wiki.openstreetmap.org/wiki/Overpass_API/Language_Guide).'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Run the code on this file. Remember to press *Alt* + *Shift* + *F10* to
    choose a different file and select osm_data in the list. You should get an output
    like this: Found 3523 POIs'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '{''operator'': ''Desjardins'', ''amenity'': ''bank'', ''atm'': ''yes'', ''name'':'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '''Caisse Populaire Desjardins''}'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have overpy installed, just click on it in your code, press Alt
    + F10 and select "Install Package"
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s import this data into our database. Open your manage.py file. We
    will create a new method to our GeoCollection manager, very similar to import_data,
    but specific to OSM data.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Edit your manage.py file and add this new method to the GeoCollection class:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '#...'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'def import_osm_data(self, result):'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '"""Import OpenStreetMap points of interest.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: ':param str file_path: The full path to the file.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: from models import Tag
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: tags = []
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'for node in result.nodes:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: geometry = "POINT(" + str(node.lat) + " " + \ str(node.lon) + ")"
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: geo_object = self.model(geom=geometry, atype="poi") geo_object.save()
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: geoo_id = geo_object.id
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'for key, value in node.tags.iteritems():'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: tags.append(Tag(key=key, value=value, geo_object_id=geoo_id))
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Tag.objects.bulk_create(tags)
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: We could have reused the code that is common for both import_data and import_osm_data,
    but in this chapter we are emphasizing speed and, as was stated earlier, sometimes
    it’s easier to achieve better execution times with specific functions.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we were able to remove the verifications when creating the tags,
    making the loop run faster.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s test this new method:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Open the geodata_app.py file and add this import at the beginning of the
    file: from utils.osm_data import get_osm_poi'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '6\. Now edit the if __name__ == ''__main__'': block:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: bbox = {"xmin":-71.206, "ymin":47.714,
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '"xmax":-71.140, "ymax":48.982}'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: result = get_osm_poi(bbox)
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: GeoObject.objects.import_osm_data(result)
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: points = GeoObject.objects.filter(atype='poi')
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: print(len(points))
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '7\. Finally, run the code and see if you get an output resembling the following
    (the number of points may be different for you):'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Found 14 POIs
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '**Removing the test data**'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we continue with real imports, let’s clean the database of all the data
    we put into it for testing. Let’s make a simple function for this job in our app:
    1\. In geodata_app.py, add this function:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'def clean_database():'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '"""Remove all records from the database."""'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: from django.db import connection
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: cursor = connection.cursor()
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: cursor.execute('DELETE FROM geodata_tag;')
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: cursor.execute('DELETE FROM geodata_geoobject;')
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Here we are calling SQL commands directly on the database in order to avoid
    all Django overheads and get a better performance.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Now call it from the if __name__ == ''__main__'': block:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: clean_database()
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Run the code; it may take a while to finish.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Keep it as a resource in case you want to make other tests or if you need
    to start over.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '**Populating the database with real data**'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it’s time to put real data into our database. We will import all the data
    that we used so far, plus additional data:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Geocaching points (extended version)
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: World borders
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Canadian districts borders
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Points of interest in Canada
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Go to your geodata_app.py file and edit the if __name__ == ''__main__'':
    block: if __name__ == ''__main__'':'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: import_initial_data("../data/canada_div.gml", 'canada') import_initial_data("../data/world_borders_simple.shp",
    'world') import_initial_data("../data/geocaching_big.gpx", 'geocaching') This
    time we are setting more specific types for our data to make our queries easier.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Now, run the code to begin importing. In the end you should have this output:
    Importing canada…'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 293 features.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Done!
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Importing world…
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 245 features.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Done!
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Importing geocaching…
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 1638 features.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Done!
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s time to fetch points of interest from OpenStreetMap and add them to
    our database.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Add this function to your geodata_app.py:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: 'def import_from_osm(district):'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: tags = Tag.objects.filter(value="Montreal")
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: borders = GeoObject.objects.get(atype='canada',
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: tags__key='CDNAME',
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: tags__value=district)
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: extent = borders.geom.extent
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Extent: {}".format(extent))'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: bbox = {"xmin":extent[0], "ymin":extent[1],
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '"xmax":extent[2], "ymax":extent[3]}'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: osm_poi = get_osm_poi(bbox)
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: GeoObject.objects.import_osm_data(osm_poi)
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: print("Done!")
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: This function takes a district name. Get it from our database and use its extent
    to query the OSM API.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Change the if __name__ == ''__main__'': block:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: import_from_osm('Montréal')
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Now, run the code. It may take some time to download the data from OSM.
    When it’s done, your output should be something like the following (the number
    of features may be different):'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'Extent: (-73.9763757739999, 45.4021292300001, -73.476065978, 45.703747476)'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Found 5430 POIs
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Done!
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '--- Memory Error ----'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you will probably have your first contact with another issue
    in code optimization: memory consumption. Unless you have a large amount of RAM,
    you’ll be faced with Python’s MemoryError. This means that your computer ran out
    of memory while parsing the huge amount of POIs acquired from OSM.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: This happened because the whole XML from OSM was parsed into Python objects
    and later into Django objects, and they were all stored in the memory at the same
    time.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: The solution here is to read one XML tag at a time. If it’s a node, put it into
    the database, get its tags, and release the memory. To do that, we will use a
    XML file available on the sample data, so we don’t need to download it again.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Open the managers.py file and add this import at the beginning of the file:
    import xml.etree.cElementTree as ET'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Go to your GeoCollection manager and edit the import_osm_data method:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '#...'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '#...'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'def import_osm_data(self, input_file):'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '"""Import OpenStreetMap points of interest.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: ':param str input_file: The full path to the file.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: from models import Tag
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: tags = []
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: tags_counter = 0
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: nodes_counter = 0
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: xml_iter = ET.iterparse(input_file)
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'for event, elem in xml_iter:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'if elem.tag == ''node'':'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: lat, lon = elem.get('lat'), elem.get('lon')
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: geometry = "POINT(" + str(lat) + " " + str(lon) + ")"
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: geo_object = self.model(geom=geometry, atype="poi") geo_object.save()
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: geoo_id = geo_object.id
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: nodes_counter += 1
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'if nodes_counter % 10000 == 0:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: print("{} Nodes…".format(nodes_counter))
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: print("Creating tags…") Tag.objects.bulk_create(tags)
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: tags = []
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: 'for child_tag in elem:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: key = child_tag.get('k')
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: value = child_tag.get('v')
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: 'if len(value) <= 250:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: tags.append(Tag(key=key,
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: value=value,
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: geo_object_id=geoo_id))
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: tags_counter += 1
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: elem.clear()
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: print("Creating tags…")
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Tag.objects.bulk_create(tags)
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: print("Imported {} nodes with {} tags.".format(
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: nodes_counter, tags_counter))
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: print("Done!")
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '**ElementTree** is a Python module designed for XML parsing; cElementTree has
    the same functionality but is implemented in C. The only restriction on using
    cElementTree is when C library loading is not available, which is not the case
    here.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Note that the solution to optimizing tag creation is to accumulate the tags
    in a list, bulk-create tags every 10,000 nodes, and then clear the list.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Edit the if __name__ == ''__main__'': block of the geodata_app.py file
    to test the code:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: 'GeoObject.objects.import_osm_data("../data/osm.xml") 4\. Now run it. While
    you wait, you can open the Windows Task Manager, or the system monitor on Ubuntu,
    and see how your computer resources are being consumed and/or watch the progress
    in the console output:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: 10000 Nodes…
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Creating tags…
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 20000 Nodes…
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Creating tags…
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: 30000 Nodes…
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: Creating tags…
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: 40000 Nodes…
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: Creating tags…
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: 50000 Nodes…
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Imported 269300 nodes with 1272599 tags.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: Done!
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: If you were watching your computer resources, you should have seen that the
    memory consumption fluctuated around some value. As the memory didn’t keep increasing
    as more and more nodes were imported, we would be able to import virtually any
    given number of points on files of any size because the code is stable and has
    no memory leaks.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: On my computer, Python consumed something around 100 Mb of memory during the
    program execution. The processor cores stayed mostly at 5% of load (Python and
    PostgreSQL) and the hard drive was 100% occupied with database writing.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: It would be possible to tweak the database for a better performance, but this
    is beyond the scope of this book.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Remember that, if you want to make more tests, you can always clean the database
    with the function that we created before. Just remember to import all the data
    again before we continue.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '**Searching for data and crossing**'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '**information**'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our database populated with some data, it’s time to get some
    information from it; let’s explore what kind of information all those POIs hold.
    We know that we downloaded points that contain at least one of the amenity or
    store keys.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: 'Amenities are described by OSM as any type of community facilities. As an exercise,
    let’s see a list of amenity types that we got from the points:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Edit your geodata_app.py file’s if __name__ == ''__main__'': block: if
    __name__ == ''__main__'':'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: amenity_values = Tag.objects.filter(
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: key='amenity').distinct('value').values_list('value')
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: 'for item in amenity_values:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: print(item[0])
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Here we take the Tag model, access its manager (objects), then filter the tags
    whose key='amenity'. Then we separate only distinct values (exclude repeated values
    from the query). The final part—values_list('value')—tells Django that we don’t
    want it to create Tag models, we only want a list of values.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Run the code, and take a look at the huge list of amenity types: atm, fuel'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: atm;telephone
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: audiologist
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: auditorium
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: Auto Body Repair Shop
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: auto_club
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: automobile_club
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: baby_hatch
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: bail_bonds
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: bakery
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: ball_washer
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: ballet
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: bandshell
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: bank
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: bank_construction
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: banquet_hall
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: bar
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: bar/food
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: barber
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: barbershop
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: bathroom
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: bbq
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: beauty
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: Beauty Services
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: bell_tower
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: bench
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: betting
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: bicycle_dirt jumping
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 65](img/index-387_1.jpg)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
- en: bicycle_parking
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: bicycle_parking; bicycle_rental
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: bicycle_parking;bank
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: bicycle_rental
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: You can also spot some misuse of this OSM tag as people mistakenly put street
    names, business names, and so on instead of the amenity type.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: 'For a list of common amenity types, you can check the OpenStreetMap wiki:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '[http://wiki.openstreetmap.org/wiki/Key:amenity.](http://wiki.openstreetmap.org/wiki/Key:amenity)'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '**Filtering using boundaries**'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s try getting only the amenities that are at Montréal. The procedure
    is similar to what we did before. We will use one of the known predicates to filter
    objects by a geometry relationship, but this time the searches are powered by
    the database and spatial indexes, making them incredibly fast.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the *Geometry relationships* section in [Chapter 4,](index_split_001.html#p174)
    *Improving the App Search* *Capabilities* for a list of predicates.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: Get Montreal object.
  id: totrans-442
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: montreal = GeoObject.objects.get(atype='canada',
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: tags__key='CDNAME',
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: tags__value='Montréal')
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: Filter tags whose POI is within Montreal.
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: amenities = Tag.objects.filter(
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: key='amenity', geo_object__geom__within=montreal.geom)
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: Filter only the distinct values.
  id: totrans-449
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: amenities = amenities.distinct('value')
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: Get the list of 'values'
  id: totrans-451
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: amenity_values = amenities.values_list('value')
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: 'for item in amenity_values:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: print(item[0])
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: Here I separated each part into a different statement to facilitate understanding.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: It doesn’t make any difference if you put everything together or keep it separated,
    Django query sets are lazy (somewhat like what we did in [Chapter 7,](index_split_002.html#p312)
    *Extract Information from* *Raster Data*), and they are evaluated only when a
    value is needed. This means that Django will only hit the database once when we
    start iterating through the values (for item in amenity_values).
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Run the code. You should get a more modest list of amenity types: arts_centre'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: atm
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: audiologist
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: bakery
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: bank
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: bar
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: bbq
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: bench
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: bicycle_parking
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: bicycle_rental
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: billboard
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: bureau_de_change
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: bus_station
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: cafe
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: car_rental
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: car_repair
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: car_sharing
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: car_wash
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: childcare
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: cinema
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: city_hall
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: clinic
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: clock
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: college
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s find out how many cinemas (movie theatres) we can find in Montreal:
    2\. Edit the if __name__ == ''__main__'': block:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: montreal = GeoObject.objects.get(atype='canada',
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: tags__key='CDNAME',
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: tags__value='Montréal')
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: cinemas = GeoObject.objects.filter(atype='poi',
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: geom__within=montreal.geom,
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: tags__key='amenity',
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: tags__value='cinema')
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: print("{} cinemas.".format(cinemas.count()))
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: Note that we are using the count method instead of Python’s len function. This
    makes the counting happen on the database and only the output value is returned.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: This is much faster than getting all the objects and then counting with Python.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Now run it and check the output:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: 16 cinemas.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we explored introductory concepts about code efficiency and
    how to measure it. Equipped with the right tools, we optimized our code to make
    it run faster.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: Instead of storing data into Python objects, we turned to SQL databases. We
    thereby enhanced our app with state-of-the-art filtering and got information in
    an efficient way.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: Later, we came across a large amount of data that was impossible to import with
    ordinary computers. We optimized our code again, making it memory-efficient and
    stable, allowing us to import this data. Finally, we queried the data, testing
    the new feature capabilities.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will face similar speed and memory problems but with
    images (raster) data. This will require us to develop new and creative solutions.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter 9\. Processing Big Images**'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: 'Processing satellite images (or other remote sensing data) is a computational
    challenge for two reasons: normally, the images are big (many megabytes or gigabytes)
    and many images are needed in combination to produce the desired information.'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: Opening and processing many big images can consume a lot of computer memory.
    This condition sets a tight limit on what the user can do before running out of
    memory.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on how to perform sustainable image processing
    and how to open and make calculations with many big images while keeping the memory
    consumption low with efficient code.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to satellite images and Landsat 8 data
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: How to select and download Landsat 8 data
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: What happens to the computer memory when we work with images?
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: How to read images in chunks
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: What are Python iterators and generators?
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: How to iterate through an image
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: How to create color compositions with the new techniques
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 66](img/index-394_1.jpg)'
  id: totrans-515
  prefs: []
  type: TYPE_IMG
- en: '**Working with satellite images**'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: Satellite images are a form of remote sensing data. They are composed of the
    information collected by satellites and are made available to users as image files.
    Just like the digital elevation model that we worked on before, these images are
    made of pixels, each one representing the value of a given attribute for a given
    geographic extent.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: These images can be used to visualize features on Earth using real colors or
    they can be used to identify a variety of characteristics using parts of the light
    spectrum invisible to the human eyes.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: In order to follow the examples, we will use images from the Landsat 8 satellite.
    They are available for free on the Internet. Let’s take a look at some of the
    characteristics of this satellite.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: 'Landsat 8 carries two instruments: the **Operational Land Imager** (**OLI**)
    and the **Thermal Infrared Sensor** (**TIRS**).'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: These sensors can collect data in a total of 10 different bands processed in
    a resolution of 4096 possible levels (12-bit). The data is encoded into 16-bit
    TIFF images scaled to 55000
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: possible values.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: '**Wavelength**'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: '**Resolution**'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: '**Bands**'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: '**Common uses**'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: '**(micrometers)**'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: '**(meters)**'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: Band 1—Coastal
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: Shallow coastal water studies and estimation of the
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: 0.43 - 0.45
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: aerosol
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: concentration of aerosols in the atmosphere
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: Band 2—Blue
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: 0.45 - 0.51
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: Visible blue channel, distinguish soil from vegetation
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: Band 3—Green
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: 0.53 - 0.59
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: Visible green channel
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: Band 4—Red
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: 0.64 - 0.67
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: Visible red channel
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: Band 5—Near Infrared 0.85 - 0.88
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: Biomass estimation
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: (NIR)
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: Band 6—SWIR 1
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: 1.57 - 1.65
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: Soil moisture
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: Band 7—SWIR 2
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: 2.11 - 2.29
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: Soil moisture
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: Band 8—Panchromatic 0.50 - 0.68
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: '15'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: Sharper resolution
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: Band 9—Cirrus
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: 1.36 - 1.38
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: Detection of cirrus cloud contamination
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: Band 10—Thermal
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: 10.60 - 11.19
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: Thermal mapping and estimating soil moisture
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: Infrared (TIRS) 1
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: Band 11—Thermal
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: 11.50 - 12.51
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: Thermal mapping and estimating soil moisture
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: Infrared (TIRS) 2
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 67](img/index-396_1.jpg)'
  id: totrans-576
  prefs: []
  type: TYPE_IMG
- en: '**Getting Landsat 8 images**'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: Landsat 8 images are available freely on the Internet and there are some nice
    tools to find and download these images. For the book, we will use **U.S Geological
    Survey** (**USGS**) EarthExplorer. It’s a web app packed with resources to obtain
    geographic data.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: In order to follow the book’s examples, we will download data for the same Montreal
    (Quebec, Canada) area that we obtained the points of interest of the previous
    chapter. This data is included in the book’s sample data and you can skip these
    steps if you wish.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will open the website and select our region of interest as follows:
    1\. Go to the [http://earthexplorer.usgs.gov/](http://earthexplorer.usgs.gov/)
    website. You will see a map, some options at the top, and a panel with search
    tools on the left-hand side: 2\. At the top right, you will see a **Login**/**Register**
    button. If you don’t have an account, click on **Register** and create a new one.
    Otherwise, log in to the system.'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: 3\. The next step is to search for the location of interest. You can search
    by entering Montreal in the box and clicking on **Show**. A list will appear with
    the search results.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Montreal** on the list. A marker will appear and the coordinates
    will be set.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Click on the **Data Sets** button to show the available data for this coordinate.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: 5\. On the next screen, expand the **Landsat Archive** item, select **L8 OLI/TIRS**,
    and click on the **Additional Criteria** button.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 68](img/index-397_1.jpg)'
  id: totrans-585
  prefs: []
  type: TYPE_IMG
- en: '![Image 69](img/index-397_2.jpg)'
  id: totrans-586
  prefs: []
  type: TYPE_IMG
- en: 6\. Now, let’s make sure that we get images with little cloud cover. Use the
    scroll bar to find the **Cloud Cover** item and select **Less than 10%**. Now,
    click on **Results** to see what was found.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: '7\. A new tab will open showing the results. Note that each item contains a
    small toolbar with a set of icons. Click on the feet icon of some of the images
    to see their extent on the map:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: '8\. For our examples, we need just one data set: one for path 14, row 28\.
    Find the data'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 70](img/index-398_1.jpg)'
  id: totrans-590
  prefs: []
  type: TYPE_IMG
- en: for this set of rows and columns (you can use an image from any date; it’s up
    to you) and then click on the **Download Options** button on the mini toolbar
    (it’s the icon with a green arrow pointing to a hard drive).
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: 9\. A window will pop up with the download options. Click on **Download Level
    1**
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: '**GeoTIFF Data Product**.'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: USGS has an application that can manage and resume large downloads. Take a look
    at [https://lta.cr.usgs.gov/BulkDownloadApplication](https://lta.cr.usgs.gov/BulkDownloadApplication)
    for more information.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: 10\. After the download is complete, create a new folder in your data folder
    and name it landsat. Unpack all the images in this folder.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: Each package contains 12 .tif images and a text file containing the metadata.
    Each image name is composed of the row, column, date, and band of the image. Note
    that the band 8
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: image (B8) is much larger than the other images. This is because it has a better
    resolution.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: BQA is a quality assessment band. It contains information on the quality of
    each of the pixels in the image. We will see more about this band later.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory and images**'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will check how opening images affects random access memory (RAM)
    usage. In our first example, we will try to open band 8 of the Landsat data using
    the same technique as before:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Prepare the working environment for Chapter 9 by making a copy of the Chapter8
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: folder in your geopy project. Name the copied folder as Chapter9\.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: 2\. In Chapter9 folder, open the experiments folder and delete all the files
    inside it.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: 3\. In the experiments folder, create a new Python file and name it images.py.
    Open it for editing.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Now type the following code in this file:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  id: totrans-607
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import cv2 as cv
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: 'def open_image(img_path):'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: image = cv.imread(img_path)
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: print(type(image))
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: raw_input("Press any key.")
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: image_path = "../../data/landsat/LC80140282015270LGN00_B8.TIF"
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: open_image(image_path)
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Run the code. Press *Alt* + *Shift* + *F10* and select the images on the
    list.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: 6\. Depending on your computer’s memory and the OpenCV version, you may succeed.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: 'Otherwise, you will see this nice exception:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenCV Error: Insufficient memory (Failed to allocate 723585188 bytes) in cv::OutOfMemoryError,
    file ..\..\..\opencv-2.4.11\modules\core\src\alloc.cpp, line 52'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: 'Traceback (most recent call last):'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: File "Chapter9/experiments/images.py", line 14, in <module> open_image(image_path)
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: File " experiments/images.py", line 6, in open_image image = cv.imread(img_path)
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: 'cv2.error: ..\..\..\opencv-2.4.11\modules\core\src\alloc.cpp:52: error: (-4)
    Failed to allocate 723585188 bytes in function'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: cv::OutOfMemoryError
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 1
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: This happens because we are using the 32-bit version of the Python interpreter
    (that is, x86) and the program fails to allocate enough memory to open the whole
    image at once.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: 7\. Let’s try with a band with a smaller file size. Change the filename to match
    band 1 of any of the images. It could be LC80140282015270LGN00_B1.TIF.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 71](img/index-401_1.jpg)'
  id: totrans-628
  prefs: []
  type: TYPE_IMG
- en: '8\. Run the code again. You should see a prompt asking you to press any key:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: <type 'numpy.ndarray'>
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: Press any key.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: This was done on purpose in order to halt the program execution while the image
    is still in the memory.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: 9\. Now, if you are using Windows, press *Ctrl* + *Alt* + *Del* and open the
    task manager. If you are using Ubuntu Linux, open the system monitor.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: '10\. Look for the Python process and see how much memory it’s using. You should
    see something as follows:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: That’s OK. The image has opened and isn’t consuming much memory.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: 11\. Press any key on the console to finish program execution.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: '12\. Now, let’s simulate opening more than one image and see what happens.
    Change your open_image function:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: 'def open_image(img_path):'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: image = cv.imread(img_path)
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: image2 = cv.imread(img_path)
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: image3 = cv.imread(img_path)
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: image4 = cv.imread(img_path)
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: image5 = cv.imread(img_path)
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: raw_input("Press any key.")
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: 13\. Run the code again and check the memory used by Python. For me, it’s 872
    MB.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 13. 再次运行代码并检查Python使用的内存。对我来说，是872 MB。
- en: 14\. Press any key in the console to exit the program and release the memory.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 14. 在控制台中按任意键退出程序并释放内存。
- en: '15\. For our last test, open the image one more time to see what happens: def
    open_image(img_path):'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '15. 对于我们的最后一次测试，再次打开图像以查看会发生什么：def open_image(img_path):'
- en: image = cv.imread(img_path)
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: image = cv.imread(img_path)
- en: image2 = cv.imread(img_path)
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: image2 = cv.imread(img_path)
- en: image3 = cv.imread(img_path)
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: image3 = cv.imread(img_path)
- en: image4 = cv.imread(img_path)
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: image4 = cv.imread(img_path)
- en: image5 = cv.imread(img_path)
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: image5 = cv.imread(img_path)
- en: image6 = cv.imread(img_path)
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: image6 = cv.imread(img_path)
- en: raw_input("Press any key.")
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: raw_input("Press any key.")
- en: '16\. Run the code and see the result:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 16. 运行代码并查看结果：
- en: 'cv2.error: D:\Build\OpenCV\OpenCV-'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 'cv2.error: D:\Build\OpenCV\OpenCV-'
- en: '2.4.11\modules//python//src2//cv2.cpp:201: error: (-2) The numpy array of typenum=2,
    ndims=3 can not be created in function'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: '2.4.11\modules//python//src2//cv2.cpp:201: 错误：(-2) 在函数中无法创建typenum=2，ndims=3的numpy数组'
- en: NumpyAllocator::allocate
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: NumpyAllocator::allocate
- en: Process finished with exit code 1
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: Process finished with exit code 1
- en: Again, the program failed to allocate enough memory to open the image.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，程序未能分配足够的内存来打开图像。
- en: The point of these experiments was to show that, while processing images, there
    is a good chance of facing memory problems. With band 8, it was even impossible
    to begin processing it because we couldn’t open it.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实验的目的是为了展示，在处理图像时，有很大可能会遇到内存问题。对于波段8，甚至无法开始处理，因为我们无法打开它。
- en: With band 1, we simulated a common situation where we wanted to perform a calculation
    involving many images and this calculation had sub-steps. The memory consumption
    would escalate until the program crashes.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 对于波段1，我们模拟了一个常见的情况，我们想要执行涉及许多图像的计算，并且这个计算有子步骤。内存消耗会不断增加，直到程序崩溃。
- en: The maximum amount of memory that Python is allowed to use is limited by the
    operation system and the Python version (64 or 32 bits). Probably, if you are
    running the 64 bits version of Python, or using Linux, you won’t face any error
    during the examples.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: Python允许使用的最大内存量受操作系统和Python版本（64位或32位）的限制。可能，如果你正在运行64位版本的Python，或者使用Linux，你在这几个示例中不会遇到任何错误。
- en: Independent of being able to run this program or not, these examples show a
    code whose success is tied to the image size. Even while running a 64-bit Python
    on a Linux machine with 32 GB of RAM, the program may run out of memory if the
    images are too big and the process is complex. Remember that some satellite images
    could be pretty large.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 无论这个程序是否能运行，这些示例展示的代码的成功与图像大小有关。即使在一个拥有32GB RAM的Linux机器上运行64位Python，如果图像太大且处理过程复杂，程序也可能耗尽内存。记住，一些卫星图像可能相当大。
- en: '**Processing images in chunks**'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '**分块处理图像**'
- en: 'We will change the code, so we can open images of any size. The principle is
    the same as the one we applied in the previous chapter: in order to read and import
    an arbitrary number of points, we made the program read, import, and release the
    memory after each small set of points.'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改代码，以便我们可以打开任何大小的图像。原理与上一章中应用的方法相同：为了读取和导入任意数量的点，我们让程序在读取、导入和释放内存后，对每小批次的点进行操作。
- en: Instead of reading points, we will read a small piece from the image, make some
    calculations, write the output on the disk, and release the memory before repeating
    the process with the next piece.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不再读取点，而是从图像中读取一小部分，进行一些计算，将输出写入磁盘，并在重复下一部分之前释放内存。
- en: '**Using GDAL to open images**'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用GDAL打开图像**'
- en: 'The process of reading selected regions of a given image is no easy task. Many
    factors are relevant, such as how the data is encoded in the image, the type of
    data, how to read the data, and so on. Fortunately, GDAL is equipped with great
    functions and methods that abstract most of the low-level process. Let’s experiment
    with it: 1\. In the images.py file, import GDAL at the beginning of the file:
    import gdal'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 读取给定图像选定区域的过程并不容易。许多因素都相关，例如数据在图像中的编码方式、数据类型、如何读取数据等等。幸运的是，GDAL配备了强大的函数和方法，可以抽象出大部分底层过程。让我们来实验一下：1.
    在images.py文件中，在文件开头导入GDAL：import gdal
- en: '2\. Now, create a new function to open the Landsat band 8 using GDAL: def open_image_gdal(img_path):'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: '2. 现在，创建一个新的函数来使用GDAL打开Landsat波段8：def open_image_gdal(img_path):'
- en: dataset = gdal.Open(img_path)
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: dataset = gdal.Open(img_path)
- en: cols = dataset.RasterXSize
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: cols = dataset.RasterXSize
- en: rows = dataset.RasterYSize
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: rows = dataset.RasterYSize
- en: 'print "Image dimensions: {} x {}px".format(cols, rows) raw_input("Press any
    key.")'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Change the if __name__ == ''__main__'': block to use the new function:
    if __name__ == ''__main__'':'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: image_path = "../../data/landsat/LC80140282015270LGN00_B8.TIF"
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: open_image_gdal(image_path)
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Run your code and check the output:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: 'Image dimensions: 15401 x 15661px'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: Press any key.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: We simply opened the image and printed its dimensions. You should have noticed
    that the code ran incredibly fast and with no errors. If you wish, you can check
    how much memory the Python process is using (using the Task Manager or the system
    monitor).
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: What happened this time is that the data wasn’t read when the file was opened.
    GDAL
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: only got the information about the image, but the actual data wasn’t touched.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try reading a few pixels from this image:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Press any key to exit the program.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Edit the function:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: 'def open_image_gdal(img_path):'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: dataset = gdal.Open(img_path)
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: cols = dataset.RasterXSize
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: rows = dataset.RasterYSize
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: 'print "Image dimensions: {} x {}px".format(cols, rows) middle_col = int(cols
    / 2)'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: middle_row = int(rows / 2)
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: array = dataset.ReadAsArray(xoff=middle_col - 50,
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: yoff=middle_row - 50,
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: xsize=100, ysize=100)
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: print(array)
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: print(array.shape)
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Run the code again and check the output: Image dimensions: 15401 x 15661px'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: '[[8826 8821 8846…, 8001 7965 7806]'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: '[8842 8838 8853…, 7982 7931 7676]'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: '[8844 8860 8849…, 8050 7958 7693]'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: '...,'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: '[7530 7451 7531…, 7471 7457 7494]'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: '[7605 7620 7555…, 7533 7519 7610]'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: '[7542 7542 7499…, 7620 7947 7728]]'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: (100, 100)
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: We just read a chunk of 100 x 100 pixels from the centre of the image. Again,
    the code ran fast and little memory was consumed.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s try something fancier. Read a region from the image and save it on
    the disk, so we can visualize it.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: 4\. First, delete all the files from the Chapter9/output folder. We will save
    our image here.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Add the adjust_values function and edit the code of the open_image_gdal
    function: def adjust_values(array, img_range=None):'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: '"""Projects a range of values into a grayscale image.'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: ':param array: A Numpy array containing the image data.'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: ':param img_range: specified range of values or None to use'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: the range of the image (minimum and maximum).
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: 'if img_range:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: min = img_range[0]
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: max = img_range[1]
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: min = array.min()
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
- en: max = array.max()
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: interval = max - min
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: factor = 256.0 / interval
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
- en: output = array * factor
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
- en: return output
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: 'def open_image_gdal(img_path):'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
- en: dataset = gdal.Open(img_path)
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
- en: cols = dataset.RasterXSize
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: rows = dataset.RasterYSize
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: 'print "Image dimensions: {} x {}px".format(cols, rows) middle_col = int(cols
    / 2)'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
- en: middle_row = int(rows / 2)
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
- en: array = dataset.ReadAsArray(xoff=middle_col - 50,
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: yoff=middle_row - 50,
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
- en: xsize=1000, ysize=1000)
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: print(array.shape)
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
- en: greyscale_img = adjust_values(array)
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: cv.imwrite('../output/landsat_chunk.jpg', greyscale_img)
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 72](img/index-407_1.jpg)'
  id: totrans-739
  prefs: []
  type: TYPE_IMG
- en: The adjust_values function is the same that we used before to adjust the gray
    values of the elevation data in order to visualize it.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: adjust_values 函数与之前我们用来调整高程数据灰度值以便可视化的函数相同。
- en: 'We are using OpenCV to write the JPG image for two reasons: by default, GDAL'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 OpenCV 来写入 JPG 图像有两个原因：默认情况下，GDAL
- en: can’t write JPG on Windows, and OpenCV is easier to use in this simple case.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上无法写入 JPG 文件，而且在这个简单的情况下，OpenCV 更容易使用。
- en: '6\. Run the code and open the image in the output folder. If you are using
    the same Landsat data as I am, you should see this beautiful image of Quebec’s
    rural area:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 6\. 运行代码并在输出文件夹中打开图像。如果你和我使用的是相同的 Landsat 数据，你应该看到魁北克农村地区的这幅美丽图像：
- en: '![Image 73](img/index-408_1.jpg)'
  id: totrans-744
  prefs: []
  type: TYPE_IMG
  zh: '![Image 73](img/index-408_1.jpg)'
- en: '**Iterating through the whole image**'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: '**遍历整个图像**'
- en: We saw that we can read specific parts of an image. With this concept, we can
    process the whole image one piece at a time. By doing this, it’s possible to make
    calculations that involve many bands. We just need to read the same region of
    each band, obtain the results, write them, release the memory, and move to the
    next piece.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到我们可以读取图像的特定部分。利用这个概念，我们可以一次处理图像的一部分。通过这样做，我们可以进行涉及多个波段的计算。我们只需要读取每个波段相同区域，获取结果，写入它们，释放内存，然后移动到下一部分。
- en: The most obvious way to iterate through something in Python is to use a for
    loop. We can iterate through the elements on a list, characters on a string, keys
    on a dictionary, features on a vector layer, and so on.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中遍历某个对象的最明显方式是使用 for 循环。我们可以遍历列表的元素、字符串中的字符、字典的键、矢量图层上的要素等等。
- en: '*The preceding image is taken from http://nvie.com/posts/iterators-vs-generators/*'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: '*此前的图像来自 http://nvie.com/posts/iterators-vs-generators/*'
- en: 'You may have heard the concepts of iterables, iterators, and generators. **Iterables**,
    like a list, become iterators when they are used in a for loop. But we don’t want
    to create a list of image chunks, because in order to do this, we would need to
    read the whole image upfront to produce the list. That’s when a special feature
    of iterators comes into light: they are lazy.'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经听说过可迭代对象、迭代器和生成器的概念。**可迭代对象**，如列表，在用于 for 循环时成为迭代器。但我们不想创建图像块列表，因为为了做到这一点，我们需要预先读取整个图像来生成列表。这就是迭代器的特殊特性凸显出来的时候：它们是惰性的。
- en: 'An **iterator** is nothing more than a class with specific magic methods. At
    every loop, this class next() method is called and a new value is returned. Python
    has handy tools to create iterators and that’s the point when we are going to
    see what are generators. Let’s write some code:'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: '**迭代器**不过是一个具有特定魔法方法的类。在每次循环中，这个类的 next() 方法被调用，并返回一个新的值。Python 有创建迭代器的便捷工具，这正是我们要看到生成器的时候。让我们写一些代码：'
- en: '1\. In your images.py file, add a new function:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 在你的 images.py 文件中，添加一个新的函数：
- en: 'def create_image_generator(dataset):'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 'def create_image_generator(dataset):'
- en: cols = dataset.RasterXSize
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: cols = dataset.RasterXSize
- en: rows = dataset.RasterYSize
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: rows = dataset.RasterYSize
- en: 'for row_index in xrange(0, rows):'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 'for row_index in xrange(0, rows):'
- en: yield dataset.ReadAsArray(xoff=0, yoff=row_index,
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: yield dataset.ReadAsArray(xoff=0, yoff=row_index,
- en: xsize=cols, ysize=1)
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: xsize=cols, ysize=1)
- en: '2\. Now edit the if __name__ == ''__main__'': block: if __name__ == ''__main__'':'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: '2\. 现在编辑 if __name__ == ''__main__'': 块：if __name__ == ''__main__'':'
- en: base_path = "../../data/landsat"
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: base_path = "../../data/landsat"
- en: img_name = "LC80140282015270LGN00_B8.TIF"
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: img_name = "LC80140282015270LGN00_B8.TIF"
- en: img_path = os.path.join(base_path, img_name)
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: img_path = os.path.join(base_path, img_name)
- en: dataset = gdal.Open(img_path)
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: dataset = gdal.Open(img_path)
- en: img_generator = create_image_generator(dataset)
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: img_generator = create_image_generator(dataset)
- en: print(img_generator)
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: print(img_generator)
- en: print(type(img_generator))
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: print(type(img_generator))
- en: '3\. Run the code and check the output:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 运行代码并检查输出：
- en: <generator object create_image_generator at 0x0791D968>
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: <generator object create_image_generator at 0x0791D968>
- en: <type 'generator'>
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: <type 'generator'>
- en: Process finished with exit code 0
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: Process finished with exit code 0
- en: Our create_image_generator function has a special behavior because of the yield
    word in the for loop. When we iterate through the generator object created by
    this function, the yield statement halts the function execution and returns a
    value at each loop. In our case, the generator/iterator will return one image
    row at a time.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 for 循环中的 yield 关键字，我们的 create_image_generator 函数具有特殊的行为。当我们遍历由该函数创建的生成器对象时，yield
    语句会暂停函数执行并在每次循环中返回一个值。在我们的例子中，生成器/迭代器将一次返回一行图像。
- en: '4\. Just to check whether it works, try this in the if __name__ == ''__main__'':
    block: if __name__ == ''__main__'':'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: '4\. 只是为了检查它是否工作，在 if __name__ == ''__main__'': 块中尝试这个：if __name__ == ''__main__'':'
- en: base_path = "../../data/landsat"
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
- en: img_name = "LC80140282015270LGN00_B8.TIF"
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
- en: img_path = os.path.join(base_path, img_name)
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
- en: dataset = gdal.Open(img_path)
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
- en: img_generator = create_image_generator(dataset)
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
- en: print(img_generator)
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: print(type(img_generator))
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
- en: 'for row in img_generator:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: print(row)
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Run the code and look at the output:'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
- en: '[[0 0 0…, 0 0 0]]'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
- en: '[[0 0 0…, 0 0 0]]'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: '[[0 0 0…, 0 0 0]]'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
- en: '[[0 0 0…, 0 0 0]]'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: '[[0 0 0…, 0 0 0]]'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: '[[0 0 0…, 0 0 0]]'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
- en: What you see is Python printing a lot of arrays, each containing the data of
    one row. You see zeros because the borders of the image are black and all the
    other values are
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
- en: 'suppressed by NumPy to fit the console. Let’s make a few tests to explore the
    characteristics of iterators:'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Now, try this concept test just to check another characteristic of iterators:
    if __name__ == ''__main__'':'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
- en: base_path = "../../data/landsat"
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
- en: base_path = "C:/Users/Pablo/Desktop/landsat"
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
- en: img_name = "LC80140282015270LGN00_B8.TIF"
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
- en: img_path = os.path.join(base_path, img_name)
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
- en: dataset = gdal.Open(img_path)
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
- en: img_generator = create_image_generator(dataset)
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
- en: print(img_generator[4])
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Run the code and an error will be raised:'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
- en: 'Traceback (most recent call last):'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
- en: File "Chapter9/experiments/images.py", line 98, in <module> print(img_generator[4])
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeError: ''generator'' object has no attribute ''__getitem__'''
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
- en: Remember that iterators are lazy and do not behave like sequences (for example,
    lists). The elements are calculated one at a time and we can’t get the 5th element
    directly.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Now, to check whether it really works, let’s make a copy of the image one
    line at a time. Create this new function:'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
- en: 'def copy_image(src_image, dst_image):'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
- en: os.remove(dst_image)
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
- en: 'except OSError:'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
- en: pass
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
- en: src_dataset = gdal.Open(src_image)
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
- en: cols = src_dataset.RasterXSize
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
- en: rows = src_dataset.RasterYSize
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
- en: driver = gdal.GetDriverByName('GTiff')
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
- en: new_dataset = driver.Create(dst_image, cols, rows,
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
- en: eType=gdal.GDT_UInt16)
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
- en: gdal_array.CopyDatasetInfo(src_dataset, new_dataset)
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
- en: band = new_dataset.GetRasterBand(1)
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
- en: for index, img_row in enumerate(
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
- en: 'create_image_generator(src_dataset)):'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
- en: band.WriteArray(xoff=0, yoff=index, array=img_row)
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
- en: In order to copy the image, we created a new dataset using GDAL’s GTiff driver.
    The new dataset has the same number of rows, columns, and data types (an unsigned
    16-bit integer).
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
- en: To ensure that the copy has the same projection information as the source, we
    used
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
- en: the function gdal_array.CopyDatasetInfo, thus saving us a lot of code.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
- en: Finally, using our generator, we read one line at a time and wrote it to the
    output band.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Edit the if __name__ == ''__main__'': block and run the following code
    to test it: if __name__ == ''__main__'':'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
- en: base_path = "../../data/landsat"
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
- en: img_name = "LC80140282015270LGN00_B8.TIF"
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
- en: img_path = os.path.join(base_path, img_name)
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
- en: img_copy = "../output/B8_copy.TIF"
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: copy_image(img_path, img_copy)
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
- en: Open both of the images (the original and the copy) just to check whether they
    look the same.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating image compositions**'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the basics of iterating through the image, which allows us
    to process many bands together without running out of memory, let’s produce some
    fancier results.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
- en: '**True color compositions**'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
- en: Since we have Landsat’s red, green, and blue bands, we can create an image with
    *true* *colors*. This means an image with colors similar to what they would be
    if we were directly observing the scene (for example, the grass is green and the
    soil is brown). To do this, we will explore a little bit more of Python’s iterators.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
- en: 'The Landsat 8 RGB bands are respectively bands 4, 3, and 2\. Following the
    concept that we want to automate tasks and processes, we won’t repeat the commands
    for each one of the bands. We will program Python to do this as follows:'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Edit your imports at the beginning of the file to be as follows: import
    os'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
- en: import cv2 as cv
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
- en: import itertools
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
- en: from osgeo import gdal, gdal_array
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
- en: import numpy as np
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Now add this new function. It will prepare the bands’ paths for us: def
    compose_band_path(base_path, base_name, band_number):'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
- en: return os.path.join(
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
- en: base_path, base_name) + str(band_number) + ".TIF"
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
- en: '3\. To check the purpose of this function and itertools we imported, edit the
    if __name__ == ''__main__'': block with this code:'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
- en: base_path = "../../data/landsat"
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
- en: base_name = 'LC80140282015270LGN00_B'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
- en: bands_numbers = [4, 3, 2]
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
- en: bands = itertools.imap(
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
- en: compose_band_path,
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
- en: itertools.repeat(base_path),
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
- en: itertools.repeat(base_name),
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
- en: bands_numbers)
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
- en: print(bands)
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
- en: 'for item in bands:'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
- en: print(item)
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Now run the code and check the results:'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
- en: <itertools.imap object at 0x02DE9510>
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
- en: ../../data/landsat/LC80140282015270LGN00_B4.TIF
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
- en: ../../data/landsat/LC80140282015270LGN00_B3.TIF
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
- en: ../../data/landsat/LC80140282015270LGN00_B2.TIF
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
- en: The compose band path simply joins the base path, the name of the band, and
    the band number in order to output a band filename with its path.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
- en: Instead of calling the function in a for loop and appending the results to a
    list, we used the itertools.imap function. This function takes another function
    as the first argument and any iterables as the other arguments. It creates an
    iterator that will call the function with the arguments at each iteration. The
    itertools.repeat function is responsible for repeating a given value infinite
    times when iterated.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Now, we will write the function that will combine the bands into an RGB
    image. Add this function to your file:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
- en: 'def create_color_composition(bands, dst_image):'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
- en: os.remove(dst_image)
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
- en: 'except OSError:'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
- en: pass
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
- en: Part1
  id: totrans-873
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: datasets = map(gdal.Open, bands)
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
- en: img_iterators = map(create_image_generator, datasets)
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
- en: cols = datasets[0].RasterXSize
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
- en: rows = datasets[0].RasterYSize
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
- en: Part2
  id: totrans-878
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: driver = gdal.GetDriverByName('GTiff')
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
- en: new_dataset = driver.Create(dst_image, cols, rows,
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
- en: eType=gdal.GDT_Byte,
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
- en: bands=3,
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
- en: options=["PHOTOMETRIC=RGB"])
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
- en: gdal_array.CopyDatasetInfo(datasets[0], new_dataset)
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
- en: Part3
  id: totrans-885
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: rgb_bands = map(new_dataset.GetRasterBand, [1, 2, 3])
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
- en: for index, bands_rows in enumerate(
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
- en: 'itertools.izip(*img_iterators)):'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
- en: 'for band, row in zip(rgb_bands, bands_rows):'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
- en: row = adjust_values(row, [0, 30000])
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
- en: band.WriteArray(xoff=0, yoff=index, array=row)
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
- en: In Part 1, Python’s built-in map function works like itertools.imap, but instead
    of an iterator, it creates a list with the results. This means that all the items
    are calculated and available. First, we used it to create a list of GDAL datasets
    by calling gdal.Open on all the bands. Then, the map function is used to create
    a list of image iterators, one for each band.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
- en: In Part 2, we created the output database just like we did before. But this
    time, we told the driver to create a dataset with three bands, each with byte
    data type (256
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
- en: possible values). We also tell that it’s an RGB photo in the options.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
- en: In Part 3, we used the map function again to get the reference to the bands
    in the dataset. In the first for loop, at each iteration, we got an index, that
    is, the row number, and a tuple containing a row for every band.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
- en: In the nested for loop, each iteration gets one of the output image bands and
    one row of the input bands. The values of the row are then converted from 16-bit
    to 8-bit (byte) with our adjust_values function. To adjust the values, we passed
    a magic
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 74](img/index-416_1.jpg)'
  id: totrans-897
  prefs: []
  type: TYPE_IMG
- en: number in order to get a brighter image. Finally, the row is written to the
    output band.
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
- en: '6\. Finally, let’s test the code. Edit your if __name__ == ''__main__'': block:
    if __name__ == ''__main__'':'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
- en: base_path = "../../data/landsat/"
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
- en: base_name = 'LC80140282015270LGN00_B'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
- en: bands_numbers = [4, 3, 2]
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
- en: bands = itertools.imap(
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
- en: compose_band_path,
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
- en: itertools.repeat(base_path),
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
- en: itertools.repeat(base_name),
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
- en: bands_numbers)
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
- en: dst_image = "../output/color_composition.tif"
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
- en: create_color_composition(bands, dst_image)
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
- en: '7\. Now run it. After it’s done, open the image (color_composition.tif) in
    the output folder. You should see this beautiful color image:'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
- en: You can play with the numbers that we passed to the adjust_values function.
    Try changing the lower limit and the upper limit; you will get different variations
    of brightness.
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
- en: '**Processing specific regions**'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s change our code to crop the image for us, so we can have a better
    view of the details of the region around Montreal. It’s something like we did
    before. But instead of cropping the image after processing, we will only process
    the region of interest, making the code much more efficient.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Edit the create_image_generator function:'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
- en: 'def create_image_generator(dataset, crop_region=None):'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
- en: 'if not crop_region:'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
- en: cols = dataset.RasterXSize
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
- en: rows = dataset.RasterYSize
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
- en: xoff = 0
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
- en: yoff = 0
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
- en: xoff = crop_region[0]
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
- en: yoff = crop_region[1]
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
- en: cols = crop_region[2]
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
- en: rows = crop_region[3]
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
- en: 'for row_index in xrange(yoff, yoff + rows):'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
- en: yield dataset.ReadAsArray(xoff=xoff, yoff=row_index,
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
- en: xsize=cols, ysize=1)
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
- en: Now, the function receives an optional crop_region argument and only yields
    rows of the region of interest if it’s passed. If not, it yields rows for the
    whole image.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Change the create_color_composition class to work with the cropped data:
    def create_color_composition(bands, dst_image, crop_region=None): try:'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
- en: os.remove(dst_image)
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
- en: 'except OSError:'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
- en: pass
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
- en: datasets = map(gdal.Open, bands)
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
- en: img_iterators = list(itertools.imap(
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
- en: create_image_generator, datasets,
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
- en: itertools.repeat(crop_region)))
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
- en: 'if not crop_region:'
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
- en: cols = datasets[0].RasterXSize
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
- en: rows = datasets[0].RasterYSize
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
- en: cols = crop_region[2]
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
- en: rows = crop_region[3]
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
- en: driver = gdal.GetDriverByName('GTiff')
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
- en: new_dataset = driver.Create(dst_image, cols, rows,
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
- en: eType=gdal.GDT_Byte,
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
- en: bands=3,
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
- en: options=["PHOTOMETRIC=RGB"])
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
- en: gdal_array.CopyDatasetInfo(datasets[0], new_dataset)
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
- en: rgb_bands = map(new_dataset.GetRasterBand, [1, 2, 3])
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
- en: for index, bands_rows in enumerate(
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
- en: 'itertools.izip(*img_iterators)):'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 75](img/index-418_1.jpg)'
  id: totrans-953
  prefs: []
  type: TYPE_IMG
- en: 'for band, row in zip(rgb_bands, bands_rows):'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
- en: row = adjust_values(row, [1000, 30000])
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
- en: band.WriteArray(xoff=0, yoff=index, array=row)
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
- en: Note that when img_iterators was created, we replaced the map function by itertools.imap
    in order to be able to use the itertools.repeat function. Since we need img_iterators
    to be a list of iterators, we used the list function.
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Finally, edit the if __name__ == ''__main__'': block to pass our region
    of interest: if __name__ == ''__main__'':'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
- en: base_path = "../../data/landsat/"
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
- en: base_name = 'LC80140282015270LGN00_B'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
- en: bands_numbers = [4, 3, 2]
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
- en: bands = itertools.imap(
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
- en: compose_band_path,
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
- en: itertools.repeat(base_path),
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
- en: itertools.repeat(base_name),
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
- en: bands_numbers)
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
- en: dst_image = "../output/color_composition.tif"
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
- en: create_color_composition(bands, dst_image,
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
- en: (1385, 5145, 1985, 1195))
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Run the code. You should now have this nice image of Montreal:'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
- en: '**False color compositions**'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
- en: Color compositions are a great tool for information visualization, and we can
    use it even to see things that would be otherwise invisible to the human eye.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
- en: Landsat 8 and other satellites provide data in ranges of the spectrum that are
    reflected or absorbed more or less by specific objects. For example, vigorous
    vegetation reflects a lot of near-infrared radiation, so if we are looking for
    information on vegetation coverage or plant growth, we should consider this band.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the computational analysis of different bands, we are able to visualize
    them by replacing the red, blue, and green components by other bands. Let’s try
    it as follows: 1\. Just edit the if __name__ == ''__main__'': block, so we use
    the near infrared (band 5) as the green component of the RGB image:'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
- en: base_path = "../../data/landsat/"
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
- en: base_name = 'LC80140282015270LGN00_B'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
- en: bands_numbers = [4, 5, 2]
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
- en: bands = itertools.imap(
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
- en: compose_band_path,
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
- en: itertools.repeat(base_path),
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
- en: itertools.repeat(base_name),
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
- en: bands_numbers)
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
- en: dst_image = "../output/color_composition.tif"
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
- en: create_color_composition(bands, dst_image,
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
- en: (1385, 5145, 1985, 1195))
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: (1385, 5145, 1985, 1195))
- en: '2\. Run the code and look at the output image:'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 运行代码并查看输出图像：
- en: '![Image 76](img/index-420_1.jpg)'
  id: totrans-988
  prefs: []
  type: TYPE_IMG
  zh: '![图像 76](img/index-420_1.jpg)'
- en: '![Image 77](img/index-420_2.jpg)'
  id: totrans-989
  prefs: []
  type: TYPE_IMG
  zh: '![图像 77](img/index-420_2.jpg)'
- en: 3\. You can have many other combinations. Just change the band_numbers variables
    to achieve different results. Try changing it to [6, 5, 2 ]. Run the code and
    look at how the farm fields stand out from the other features.
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 您可以有其他许多组合。只需更改band_numbers变量以实现不同的结果。尝试将其更改为[6, 5, 2]。运行代码并查看农田如何从其他特征中脱颖而出。
- en: '**Note**'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'You can check out more interesting band combinations by clicking on the following
    links:'
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过点击以下链接查看更多有趣的波段组合：
- en: '[http://landsat.gsfc.nasa.gov/?page_id=5377](http://landsat.gsfc.nasa.gov/?page_id=5377)'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://landsat.gsfc.nasa.gov/?page_id=5377](http://landsat.gsfc.nasa.gov/?page_id=5377)'
- en: '[http://blogs.esri.com/esri/arcgis/2013/07/24/band-combinations-for-landsat-8/](http://blogs.esri.com/esri/arcgis/2013/07/24/band-combinations-for-landsat-8/)'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://blogs.esri.com/esri/arcgis/2013/07/24/band-combinations-for-landsat-8/](http://blogs.esri.com/esri/arcgis/2013/07/24/band-combinations-for-landsat-8/)'
- en: '**Summary**'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: '**总结**'
- en: As we did with the points of interest, we managed the problem of excessive computational
    resource consumption by splitting the load into pieces. Specifically, instead
    of reading and processing whole images, we created Python iterators that allowed
    us to iterate through these images one row at a time without hitting the memory
    limit of the computer.
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在兴趣点所做的那样，我们通过将负载分割成片段来管理过度的计算资源消耗问题。具体来说，我们不是读取和处理整个图像，而是创建了Python迭代器，允许我们逐行遍历这些图像，而不触及计算机的内存限制。
- en: With this technique, we were able to process three Landsat 8 bands at a time
    to produce fancy colored images valuable for data visualization.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种技术，我们能够一次处理三个Landsat 8波段，以生成对数据可视化有价值的彩色图像。
- en: At this point, we are able to split our processing tasks into pieces that can
    be processed independently. We can do this with vectors, with database access,
    and now, with images as well.
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们能够将我们的处理任务分割成可以独立处理的片段。我们可以用向量、数据库访问以及现在用图像来做这件事。
- en: With this, we completely paved the road for the next chapter, where we will
    be sending each of these pieces to be calculated at the same time by a different
    processor core performing the so-called parallel processing.
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们为下一章完全铺平了道路，在下一章中，我们将将这些部分发送给不同的处理器核心同时计算，从而执行所谓的并行处理。
- en: '**Chapter 10\. Parallel Processing**'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: '**第10章. 并行处理**'
- en: In this chapter, we will take another step in code optimization; we will experiment
    with the possibility of using multiple processor cores to perform calculations.
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将进一步优化代码；我们将尝试使用多个处理器核心进行计算的可能性。
- en: Using the satellite images from the previous chapter, we will use Python’s multiprocessing
    library to distribute tasks and make them run in parallel. As an example, we will
    experiment with different techniques to produce true color compositions from Landsat
    8
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上一章的卫星图像，我们将使用Python的multiprocessing库来分配任务并使它们并行运行。作为一个例子，我们将尝试不同的技术来从Landsat
    8生成真彩色合成图像
- en: data, with better resolution and a greater level of detail.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 数据，具有更好的分辨率和更高的细节水平。
- en: 'To achieve our objects, we will go through these topics:'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们的目标，我们将通过以下主题：
- en: How multiprocessing works
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 多进程是如何工作的
- en: How to iterate through two-dimensional image blocks
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 如何遍历二维图像块
- en: Image resizing and resampling
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 图像缩放和重采样
- en: Parallel processing in image operations
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 图像操作中的并行处理
- en: Image pan sharpening
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 图像拉伸增强
- en: '**Multiprocessing basics**'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: '**多进程基础**'
- en: The implementation of Python that we are using, CPython, has a mechanism called
    **global** **interpreter lock** (**GIL**). GIL’s purpose is to make CPython thread-safe;
    it works by preventing the code from being executed by more than one thread at
    once.
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的Python实现，CPython，有一个称为**全局** **解释器锁**（**GIL**）的机制。GIL的目的是使CPython线程安全；它通过防止代码一次由多个线程执行来实现。
- en: With that limitation, multiprocessing in Python works by forking the running
    program (for example, making a copy of the state of the program) and sending it
    to another computer core. As a consequence, the new process comes with an overhead.
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种限制，Python中的多进程通过复制正在运行的程序（例如，复制程序的状态）并将其发送到另一个计算机核心来实现。因此，新进程会带来一些开销。
- en: 'Let’s try a simple code:'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一段简单的代码：
- en: 1\. First, make a copy of the previous chapter folder in your geopy project
    and rename it to Chapter10\.
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Clean the Chapter10/output folder (delete all files in it).
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Expand the Chapter10/experiments folder, right-click on it, and create a
    new Python file. Name it parallel.py.
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Add this code to this new file:'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  id: totrans-1018
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from datetime import datetime
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
- en: import multiprocessing as mp
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
- en: 'def an_expensive_function(text):'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(500):'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
- en: out = "{} {} {}"
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
- en: out.format(text, text, text)
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
- en: return "dummy output"
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
- en: This is a simple function that receives text and performs string formatting
    multiple times. The only purpose of this function is to consume CPU time, so we
    can test whether we can speed up our code by running parallel processes.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Now, create an if __name__ == ''__main__'': block at the end of the file
    so we can test the code and measure its execution time.'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
- en: texts = []
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
- en: 'for t in range(100000):'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
- en: texts.append('test text')
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
- en: t1 = datetime.now()
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
- en: result = map(an_expensive_function, texts)
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Execution time: {}".format(datetime.now() - t1)) This code makes a list
    of 100000 strings, then this list is mapped to the function; this means that an_expensive_function
    is called 100000\. Note that here we are using a simpler technique for measuring
    the execution time for this piece of code; t1 holds the start time and in the
    end it’s subtracted from the current time. This avoids the'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
- en: overhead of using a profiler and is also more suitable for what we are going
    to do than the timeit module.
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
- en: '6\. Run the code and check the result in the console:'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
- en: 'Execution time: 0:00:35.667500'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
- en: My computer took approximately 35 seconds to run the function 100,000 times;
    probably your results will be different. If your computer is much faster, change
    this number to get an execution time of at least 10 seconds. Take note of your
    result.
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Now edit the if __name__ == ''__main__'': block so we can execute this
    code in parallel:'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
- en: texts = []
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
- en: 'for t in range(100000):'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
- en: texts.append('test text')
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
- en: multi = True
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
- en: t1 = datetime.now()
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
- en: 'if multi:'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
- en: my_pool = mp.Pool(processes=8)
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
- en: result = my_pool.map(an_expensive_function, texts)
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
- en: result = map(an_expensive_function, texts)
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Execution time: {}".format(datetime.now() - t1)) The Pool class represents
    a pool of worker processes; they stand by, waiting until we submit some jobs to
    be done.'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
- en: In order to use all of your processor cores, you need to create the same number
    as, or more than, the number of cores of your processor. Or, if you don’t want
    to fully load your computer processor, use fewer processes than the number of
    cores. This is done by changing the processes argument.
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
- en: We put the code in an if block so we can easily switch between parallel and
    single processes.
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Run your code and see the difference:'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
- en: 'Execution time: 0:00:08.373000'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
- en: The code ran approximately four times faster for me.
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Now, open your Task Manager, or your system monitor and open the CPU load
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 现在，打开你的任务管理器或系统监视器并打开CPU负载
- en: '![Image 78](img/index-428_1.jpg)'
  id: totrans-1060
  prefs: []
  type: TYPE_IMG
  zh: '![Image 78](img/index-428_1.jpg)'
- en: '![Image 79](img/index-428_2.jpg)'
  id: totrans-1061
  prefs: []
  type: TYPE_IMG
  zh: '![Image 79](img/index-428_2.jpg)'
- en: graphs.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: graphs.
- en: '4\. Run the code again, using multi=True, and take a look at the CPU load graph:
    5\. Change to multi=False and run it again. Inspect the graph now: Note that when
    using multiprocessing, all cores were fully occupied for a short period of time.
    However, when using a single process, some of the cores are partially occupied
    for a'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 再次运行代码，使用multi=True，并查看CPU负载图：5. 将multi更改为False并再次运行。现在检查图：注意，当使用多进程时，所有核心在短时间内都完全占用。然而，当使用单个进程时，一些核心只部分占用。
- en: long time. This pattern may vary according to the computer architecture.
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 长时间。此模式可能因计算机架构而异。
- en: '![Image 80](img/index-431_1.jpg)'
  id: totrans-1065
  prefs: []
  type: TYPE_IMG
  zh: '![Image 80](img/index-431_1.jpg)'
- en: '**Block iteration**'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: '**块迭代**'
- en: The TIFF format is a versatile image format that can be customized for very
    diverse needs. The file is composed of a **Header**, at least one **Image File
    Directory,** and any amount of **Image Data**. Explaining it in a simple way,
    the header tells where the first directory is on the file. The directory contains
    information about the image, tells how to read the data related to it, and tells
    where the next directory is. Each combination of a directory and image data is
    an image, so a single TIFF file may have multiple images inside it.
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: TIFF格式是一种灵活的图像格式，可以根据非常多样的需求进行定制。文件由一个**标题**、至少一个**图像文件目录**和任意数量的**图像数据**组成。简单来说，标题告诉文件中第一个目录的位置。目录包含有关图像的信息，说明如何读取与它相关的数据，并说明下一个目录的位置。每个目录和图像数据的组合都是一个图像，因此单个TIFF文件可能包含多个图像。
- en: Each image data (a whole image) contains blocks of data (that is, parts of the
    image) that can be read separately, each one representing a specific region of
    the image. This allows the user to read the image by chunks, just like we did.
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 每个图像数据（即整个图像）都包含数据块（即图像的部分），这些数据块可以单独读取，每个块代表图像的特定区域。这使用户能够按块读取图像，就像我们之前做的那样。
- en: The blocks of data are indivisible; in order to return data from an image, the
    program that is reading it needs to read at least one whole block. If the desired
    region is smaller than a block, the whole block will be read anyway, decoded,
    and cropped; the data will then be returned to the user.
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 数据块是不可分割的；为了从图像中返回数据，读取它的程序需要至少读取一个完整的块。如果所需的区域小于一个块，仍然会读取整个块，进行解码和裁剪；然后数据将被返回给用户。
- en: The blocks of data can be in strips or in tiles. Strips contain data for an
    entire image row and may be one row or more in length. Tiles have width and length
    (which must be a multiple of 16) and are interesting because they allow us to
    retrieve specific regions with no need to read entire rows.
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 数据块可以以条带或瓦片的形式存在。条带包含整个图像行中的数据，可能是一行或多行。瓦片具有宽度和长度（必须是16的倍数），它们很有趣，因为它们允许我们无需读取整个行即可检索特定区域。
- en: In our previous examples, we programmed a function that was able to read images
    one row at a time; now we will improve that function in order to read blocks of
    any size. This will allow us to make fancier stuff with the images in the upcoming
    topics.
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，我们编写了一个能够逐行读取图像的函数；现在我们将改进这个函数，以便能够读取任何大小的块。这将使我们能够在接下来的主题中用图像做更复杂的事情。
- en: This time, we will take a different approach to how we iterate the image.
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将采用不同的方法来迭代图像。
- en: 1\. Inside your Chapter10/experiments folder, create a new file named block_generator.py.
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 在你的Chapter10/experiments文件夹内，创建一个名为block_generator.py的新文件。
- en: '2\. Edit this file and insert the following code:'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 编辑此文件并插入以下代码：
- en: coding=utf-8
  id: totrans-1075
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coding=utf-8
- en: import os
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 导入os模块
- en: from pprint import pprint
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: from pprint import pprint
- en: from osgeo import gdal, gdal_array
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: from osgeo import gdal, gdal_array
- en: 'def create_blocks_list(crop_region, block_shape):'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 'def create_blocks_list(crop_region, block_shape):'
- en: '"""Creates a list of block reading coordinates.'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: '"""创建一个块读取坐标列表。'
- en: ':param crop_region: Offsets and shape of the region of interest.'
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: ':param crop_region: 目标区域的偏移量和形状。'
- en: (xoff, yoff, xsize, ysize)
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: (xoff, yoff, xsize, ysize)
- en: ':param block_shape: Width and height of each block.'
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: ':param block_shape: 每个块的宽度和高度。'
- en: '"""'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: img_columns = crop_region[2]
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: img_columns = crop_region[2]
- en: img_rows = crop_region[3]
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: img_rows = crop_region[3]
- en: blk_width = block_shape[0]
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: blk_width = block_shape[0]
- en: blk_height = block_shape[1]
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: blk_height = block_shape[1]
- en: Get the number of blocks.
  id: totrans-1089
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取块的数量。
- en: x_blocks = int((img_columns + blk_width - 1) / blk_width)
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: x_blocks = int((img_columns + blk_width - 1) / blk_width)
- en: y_blocks = int((img_rows + blk_height - 1) / blk_height)
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
- en: print("Creating blocks list with {} blocks ({} x {}).".format(
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
- en: x_blocks * y_blocks, x_blocks, y_blocks))
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
- en: blocks = []
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
- en: 'for block_column in range(0, x_blocks):'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
- en: Recalculate the shape of the rightmost block.
  id: totrans-1096
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if block_column == x_blocks - 1:'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
- en: valid_x = img_columns - block_column * blk_width
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
- en: valid_x = blk_width
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
- en: xoff = block_column * blk_width + crop_region[0]
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
- en: loop through Y lines
  id: totrans-1102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for block_row in range(0, y_blocks):'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
- en: Recalculate the shape of the final block.
  id: totrans-1104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if block_row == y_blocks - 1:'
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
- en: valid_y = img_rows - block_row * blk_height
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
- en: valid_y = blk_height
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
- en: yoff = block_row * blk_height + crop_region[1]
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
- en: blocks.append((xoff, yoff, valid_x, valid_y))
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
- en: return blocks
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Before some explanation, let’s see this function working. Add the if __name__
    ==
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
- en: '''__main__'': block at the end of the file with this code:'
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
- en: blocks_list = create_blocks_list((0, 0, 1024, 1024), (32, 32)) pprint(blocks_list)
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Run the code. Since we are running a different file from before, remember
    to press *Alt* + *Shift* + *F10* to select the file to run. Check the output:'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
- en: Creating blocks list with 1024 blocks (32 x 32).
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
- en: '[(0, 0, 32, 32),'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
- en: (0, 32, 32, 32),
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
- en: (0, 64, 32, 32),
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
- en: (0, 96, 32, 32),
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
- en: (0, 128, 32, 32),
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
- en: (0, 160, 32, 32),
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
- en: (0, 192, 32, 32),
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
- en: (992, 928, 32, 32),
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
- en: (992, 960, 32, 32),
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
- en: (992, 992, 32, 32)]
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
- en: The sole purpose of this function is to create a list of block coordinates and
    dimensions; each item on the list contains the offset and the size of a block.
    We need the size because the blocks on the edges may be smaller than the desired
    size.
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
- en: The intention of this design choice, instead of iterating through an image directly,
    was to hide this low-level functionality. This function is extensive and unintuitive;
    we don’t want it mixed with higher-level code, making our programs much cleaner.
    As a bonus, we may gain a little speed when iterating multiple images because
    the list only needs to be produced once.
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Now, let’s adapt the function to copy the image. To use the iteration by
    blocks, add this code to the file:'
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
- en: 'def copy_image(src_image, dst_image, block_shape):'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
- en: os.remove(dst_image)
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
- en: 'except OSError:'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
- en: pass
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
- en: src_dataset = gdal.Open(src_image)
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
- en: cols = src_dataset.RasterXSize
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
- en: rows = src_dataset.RasterYSize
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
- en: driver = gdal.GetDriverByName('GTiff')
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
- en: new_dataset = driver.Create(dst_image, cols, rows,
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
- en: eType=gdal.GDT_UInt16)
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
- en: gdal_array.CopyDatasetInfo(src_dataset, new_dataset)
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
- en: band = new_dataset.GetRasterBand(1)
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
- en: blocks_list = create_blocks_list((0, 0, cols, rows), block_shape) n_blocks =
    len(blocks_list)
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
- en: 'for index, block in enumerate(blocks_list, 1):'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
- en: 'if index % 10 == 0:'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
- en: print("Copying block {} of {}.".format(index, n_blocks)) block_data = src_dataset.ReadAsArray(*block)
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
- en: band.WriteArray(block_data, block[0], block[1])
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Edit the if __name__ == ''__main__'': block to test the code (we are also
    going to measure its execution time):'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
- en: base_path = "../../data/landsat/"
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
- en: img_name = "LC80140282015270LGN00_B8.TIF"
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
- en: img_path = os.path.join(base_path, img_name)
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
- en: img_copy = "../output/B8_copy.tif"
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
- en: t1 = datetime.now()
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
- en: copy_image(img_path, img_copy, (1024, 1024))
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Execution time: {}".format(datetime.now() - t1)) 3\. Now, run it and
    check the output:'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
- en: Creating blocks list with 256 blocks (16 x 16).
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
- en: Copying block 10 of 256\.
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
- en: Copying block 20 of 256….
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
- en: Copying block 240 of 256\.
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
- en: Copying block 250 of 256\.
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
- en: 'Execution time: 0:00:26.656000'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
- en: We used blocks of 1024 by 1024 pixels to copy the image. The first thing to
    notice is that the process is extremely slow. This happened because we are reading
    blocks smaller than the size of the blocks in the image, resulting in a lot of
    reading and writing overhead.
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s adapt our function in order to detect the block size and optimize
    the reading.
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Edit the copy_image function:'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
- en: '**def copy_image(src_image, dst_image, block_width=None,**'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
- en: '**block_height=None):**'
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
- en: os.remove(dst_image)
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
- en: 'except OSError:'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
- en: pass
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
- en: src_dataset = gdal.Open(src_image)
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
- en: cols = src_dataset.RasterXSize
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
- en: rows = src_dataset.RasterYSize
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
- en: '**src_band = src_dataset.GetRasterBand(1)**'
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
- en: '**src_block_size = src_band.GetBlockSize()**'
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
- en: '**print("Image shape {}x{}px. Block shape {}x{}px.").format(**'
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
- en: '**cols, rows, *src_block_size)**'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
- en: '**block_shape = (block_width or src_block_size[0],**'
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
- en: '**block_height or src_block_size[1])**'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
- en: driver = gdal.GetDriverByName('GTiff')
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
- en: new_dataset = driver.Create(dst_image, cols, rows,
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
- en: eType=gdal.GDT_UInt16)
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
- en: gdal_array.CopyDatasetInfo(src_dataset, new_dataset)
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
- en: band = new_dataset.GetRasterBand(1)
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
- en: blocks_list = create_blocks_list((0, 0, cols, rows), block_shape) n_blocks =
    len(blocks_list)
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
- en: 'for index, block in enumerate(blocks_list, 1):'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
- en: 'if index % 10 == 0:'
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
- en: print("Copying block {} of {}.".format(index, n_blocks)) block_data = src_dataset.ReadAsArray(*block)
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
- en: band.WriteArray(block_data, block[0], block[1])
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
- en: We separated the block shape arguments into width and height, and made them
    optional. Then we got the size (shape) of the block that is defined in the image.
    If the block width or height are not passed as arguments, the image values are
    used instead.
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
- en: We have a hint that this image is divided in stripes. Remember that when we
    copied the image one row at a time, it was fast. So, we are going to test reading
    multiple rows at a time.
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Edit the if __name__ == ''__main__'': block:'
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
- en: base_path = "../../data/landsat/"
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
- en: img_name = "LC80140282015270LGN00_B8.TIF"
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
- en: img_path = os.path.join(base_path, img_name)
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
- en: img_copy = "../output/B8_copy.tif"
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
- en: t1 = datetime.now()
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
- en: copy_image(img_path, img_copy, block_height=100)
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Execution time: {}".format(datetime.now() - t1)) 6\. Run the code and
    see the difference:'
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
- en: Image shape 15401x15661px. Block shape 15401x1px.
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
- en: Creating blocks list with 157 blocks (1 x 157).
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
- en: Copying block 10 of 157\.
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
- en: Copying block 20 of 157\.
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
- en: Copying block 30 of 157….
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
- en: Copying block 130 of 157\.
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
- en: Copying block 140 of 157\.
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
- en: Copying block 150 of 157\.
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
- en: 'Execution time: 0:00:02.083000'
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
- en: It’s confirmed that, for Landsat 8 images, each block is one row of the image.
    And by reading whole lines, we achieved the same level of speed as before.
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
- en: You can play with the block height parameter; instead of reading 100 lines,
    try reading 1
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
- en: or 1,000 lines and see if it has any influence on the execution time.
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
- en: '**Improving the image resolution**'
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
- en: In order to obtain a better image for visual analysis, we can combine different
    techniques to increase the image resolution. The first one changes the size of
    the image and recalculates the missing data by interpolation. The second one uses
    a band of higher resolution (band 8, in our case)—combined with bands in a lower
    resolution—to produce an improved true color map.
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
- en: '**Image resampling**'
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
- en: Image resizing or resampling is a technique to change the size of the image.
    By doing this we change the number of pixels in it (that is, the number of samples)
    or vice-versa.
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
- en: As the size of an image is increased, we need to give a value to pixels that
    didn’t exist before. This is done by interpolation; the new pixel value is given
    based on the value of its surrounding pixels. That’s why we needed two-dimensional
    chunks.
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
- en: In our first trial, we will resample one 30m-resolution band into a 15m-resolution
    image.
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
- en: Since we will perform a lot of tests, let’s start by creating a practical way
    of viewing and comparing our results. To do that we will crop the image and save
    it to disk so we can easily visualize the same region.
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Edit the imports at the beginning of the file:'
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  id: totrans-1227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from datetime import datetime
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
- en: import os
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
- en: import itertools
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
- en: import numpy as np
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
- en: from pprint import pprint
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
- en: import functools
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
- en: import multiprocessing as mp
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
- en: from osgeo import gdal, gdal_array
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
- en: from images import adjust_values, compose_band_path
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
- en: from images import create_color_composition
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
- en: import cv2 as cv
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Add this new function to your file:'
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
- en: 'def crop_and_save(image_path, prefix=""):'
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
- en: dataset = gdal.Open(image_path)
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
- en: array = dataset.ReadAsArray(4209, 11677, 348, 209)
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
- en: array = adjust_values(array, (10000, 30000))
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
- en: array = array.astype(np.ubyte)
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
- en: preview_path, preview_file = os.path.split(image_path)
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
- en: 'preview_file = "preview_" + prefix + preview_file cv.imwrite(os.path.join("../output/",
    preview_file), array) This time we will zoom the image to downtown Montreal, including
    the Mount Royal and the Old Port. As a reference, the next image is a high-resolution
    image extracted from Bing maps of our region of interest:'
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 81](img/index-439_1.jpg)'
  id: totrans-1247
  prefs: []
  type: TYPE_IMG
- en: '3\. Now, add the resampling function to your file:'
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
- en: def resample_image(src_image, dst_image,
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
- en: block_width=None, block_height=None, factor=2,
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
- en: 'interpolation=cv.INTER_LINEAR):'
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
- en: '"""Change image resolution by a factor.'
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
- en: ':param src_image: Input image.'
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
- en: ':param dst_image: Output image.'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
- en: ':param block_width: Width in pixels of the processing blocks.'
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
- en: ':param block_height: Height in pixels of the processing blocks.'
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
- en: ':param factor: Image size multiplier.'
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
- en: ':param interpolation: Interpolation method.'
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
- en: t1 = datetime.now()
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Start processing -> {}".format(dst_image)) try:'
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
- en: os.remove(dst_image)
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
- en: 'except OSError:'
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
- en: pass
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
- en: src_dataset = gdal.Open(src_image, gdal.GA_ReadOnly)
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
- en: cols = src_dataset.RasterXSize
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
- en: rows = src_dataset.RasterYSize
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
- en: src_band = src_dataset.GetRasterBand(1)
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
- en: src_block_size = src_band.GetBlockSize()
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
- en: print("Image shape {}x{}px. Block shape {}x{}px.").format(
  id: totrans-1270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: cols, rows, *src_block_size)
  id: totrans-1271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: block_shape = (block_width or src_block_size[0],
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
- en: block_height or src_block_size[1])
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
- en: driver = gdal.GetDriverByName('GTiff') new_dataset = driver.Create(dst_image,
    cols * factor,
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
- en: rows * factor,
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
- en: eType=gdal.GDT_UInt16)
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
- en: gdal_array.CopyDatasetInfo(src_dataset, new_dataset)
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
- en: band = new_dataset.GetRasterBand(1)
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
- en: blocks_list = create_blocks_list((0, 0, cols, rows), block_shape) new_block_shape
    = (block_shape[0] * factor,
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
- en: block_shape[1] * factor)
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
- en: new_blocks_list = create_blocks_list((0, 0,
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
- en: cols * factor,
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
- en: rows * factor),
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
- en: new_block_shape)
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
- en: n_blocks = len(blocks_list)
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
- en: for index, (block, new_block) in enumerate(
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
- en: 'zip(blocks_list, new_blocks_list), 1):'
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
- en: '#if index % 10 == 0:'
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
- en: print("Copying block {} of {}.".format(index, n_blocks)) block_data = src_dataset.ReadAsArray(*block)
  id: totrans-1289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: block_data = cv.resize(block_data, dsize=(0, 0),
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
- en: fx=factor, fy=factor,
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
- en: interpolation=interpolation)
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
- en: band.WriteArray(block_data, new_block[0], new_block[1])
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
- en: return dst_image, t1
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
- en: This function creates an output dataset that is scaled by the defined factor.
    It reads each block from the source image, changes its size by this same factor,
    and writes it to the output. Note that the size of the output block is also recalculated
    and scaled by the multiplying factor. The method of interpolation is optional
    and by default uses linear interpolation.
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
- en: Instead of just testing this function, let’s generate previews of every possible
    interpolation method, so we can visually compare it and see which one returns
    the best result. Since we will do this using multiprocessing, we also need a callback
    function so we can time the execution of each job.
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Add this function to your file:'
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
- en: 'def processing_callback(args):'
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
- en: t2 = datetime.now() - args[1]
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Done processing {}. {}".format(args[0], t2)) 5\. Finally, edit the if
    __name__ == ''__main__'': block:'
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
- en: base_path = "../../data/landsat/"
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
- en: img_name = "LC80140282015270LGN00_B4.TIF"
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
- en: img_path = os.path.join(base_path, img_name)
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
- en: interpolation_methods = {
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
- en: '"nearest": cv.INTER_NEAREST,'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
- en: '"linear": cv.INTER_LINEAR,'
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
- en: '"area": cv.INTER_AREA,'
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
- en: '"bicubic": cv.INTER_CUBIC,'
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
- en: '"lanczos": cv.INTER_LANCZOS4}'
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
- en: output_images = []
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
- en: multi = True
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
- en: my_pool = mp.Pool(processes=8)
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
- en: total_t1 = datetime.now()
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
- en: 'for name, inter_method in interpolation_methods.iteritems(): out_image = "../output/"
    + name + ''_B4.tif'''
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
- en: output_images.append(out_image)
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
- en: 'if multi:'
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
- en: my_pool.apply_async(
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
- en: resample_image, (img_path, out_image),
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
- en: '{''block_height'': 100,'
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
- en: '''interpolation'': inter_method},'
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
- en: processing_callback)
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
- en: result = resample_image(img_path, out_image,
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
- en: block_height=100,
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
- en: interpolation=inter_method)
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
- en: processing_callback(result)
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
- en: 'if multi:'
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
- en: Close the pool, no more jobs.
  id: totrans-1329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: my_pool.close()
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
- en: Wait for all results to be ready.
  id: totrans-1331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: my_pool.join()
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Total time: {}".format(datetime.now() - total_t1)) map(crop_and_save,
    output_images)'
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
- en: Here we used another technique for adding jobs to a queue. With apply_assinc,
    we added each job one at a time, telling that we wanted the calculations to happen
    asynchronously. In the end, my_pool.join() make the program wait until all the
    jobs in the pool are complete.
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
- en: '6\. With multi = True (multiprocessing enabled), run the code and look at the
    output: Start processing -> ../output/bicubic_B4.tif'
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
- en: Start processing -> ../output/nearest_B4.tif
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
- en: Start processing -> ../output/lanczos_B4.tif
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
- en: Start processing -> ../output/linear_B4.tif
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
- en: Start processing -> ../output/area_B4.tif
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
- en: Done processing ../output/nearest_B4.tif. 0:00:33.924000
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
- en: Done processing ../output/area_B4.tif. 0:00:37.263000
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
- en: Done processing ../output/linear_B4.tif. 0:00:37.700000
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
- en: Done processing ../output/bicubic_B4.tif. 0:00:39.546000
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
- en: Done processing ../output/lanczos_B4.tif. 0:00:41.361000
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
- en: 'Total time: 0:00:42.264000'
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
- en: '7\. Now, disable multiprocessing by setting multi = False and run the code
    again: Start processing -> ../output/bicubic_B4.tif'
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
- en: Done processing ../output/bicubic_B4.tif. 0:00:02.827000
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
- en: Start processing -> ../output/nearest_B4.tif
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
- en: Done processing ../output/nearest_B4.tif. 0:00:07.841000
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
- en: Start processing -> ../output/lanczos_B4.tif
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
- en: Done processing ../output/lanczos_B4.tif. 0:00:09.729000
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
- en: Start processing -> ../output/linear_B4.tif
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
- en: Done processing ../output/linear_B4.tif. 0:00:09.160000
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
- en: Start processing -> ../output/area_B4.tif
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
- en: Done processing ../output/area_B4.tif. 0:00:09.939000
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
- en: 'Total time: 0:00:39.498000'
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
- en: Comparing the output of both of the trials, we see a different pattern of execution.
    When using multiprocessing, all the processes are started, they take a long time
    to execute, and finish almost together. When not using multiprocessing, each process
    starts and finishes before the next one.
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
- en: On my computer, it took longer to execute the code when using multiprocessing.
    This happened because our jobs used intense reading and writing and my hard drive
    was the **hardware bottleneck** and not the CPU. So, when using multiprocessing
    we added a lot of extra labor and also enforced concurrent reading and writing
    of files, reducing the HD
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
- en: efficiency.
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
- en: There is no way to overcome hardware bottlenecks when the hardware is used at
    full capacity. As happened in this example, we needed to write 2.30 GB of resampled
    image data, so the program will take at least the time needed to write 2.30 GB
    to disk.
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot of my task manager was taken during the program execution
    and illustrates the described situation:'
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 82](img/index-443_1.jpg)'
  id: totrans-1364
  prefs: []
  type: TYPE_IMG
- en: '![Image 83](img/index-443_2.jpg)'
  id: totrans-1365
  prefs: []
  type: TYPE_IMG
- en: These results may vary from computer to computer, especially if you are using
    a configuration with more than one storage media, where the IO could also happen
    in parallel.
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your output folder and see what we have:'
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
- en: 'Area interpolation:'
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
- en: 'Bicubic interpolation:'
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 84](img/index-444_1.jpg)'
  id: totrans-1370
  prefs: []
  type: TYPE_IMG
- en: '![Image 85](img/index-444_2.jpg)'
  id: totrans-1371
  prefs: []
  type: TYPE_IMG
- en: '![Image 86](img/index-444_3.jpg)'
  id: totrans-1372
  prefs: []
  type: TYPE_IMG
- en: 'Lanczos interpolation:'
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
- en: 'Linear interpolation:'
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
- en: 'Nearest interpolation:'
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 87](img/index-445_1.jpg)'
  id: totrans-1376
  prefs: []
  type: TYPE_IMG
- en: '![Image 88](img/index-445_2.jpg)'
  id: totrans-1377
  prefs: []
  type: TYPE_IMG
- en: 'And finally, look at band 8, the panchromatic band, with 15m resolution, as
    a reference:'
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 89](img/index-446_1.jpg)'
  id: totrans-1379
  prefs: []
  type: TYPE_IMG
- en: '**Pan sharpening**'
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
- en: With the resampling, we were able to produce images with pixels of 15 meters,
    but we’ve achieved little improvement in the details of the objects in the image.
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
- en: To overcome this limitation, a technique called **pan sharpening** can be used
    to produce color images with a better resolution. The principle is to use the
    panchromatic band (Landsat band 8) to improve the resolution of the composition.
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
- en: Here we will use a method that consists of changing the color representation
    of an image from RGB to HSV—Hue, Saturation, Value.
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
- en: As can be seen from the image, the value component could be interpreted as the
    brightness or intensity of the color. So, after the color representation is transformed,
    the value component can to be replaced with the higher-resolution panchromatic
    band, resulting in an image with better definition.
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
- en: To do that, we need to produce a true color composition with the RGB bands,
    like we did before, but this time with the resampled images. Then we change the
    color representation, replace the value component, transform the color representation
    back to RGB, and save the image to disk.
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Since we have most of the function ready, start by editing the if __name__
    ==
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
- en: '''__main__'': block. Remove the older tests and add this code:'
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
- en: base_path = "../../data/landsat/"
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
- en: base_name = 'LC80140282015270LGN00_B'
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
- en: bands_numbers = [2, 3, 4]
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
- en: bands_paths = itertools.imap(
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
- en: compose_band_path,
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
- en: itertools.repeat(base_path),
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
- en: itertools.repeat(base_name),
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
- en: bands_numbers)
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
- en: output_images = list(itertools.imap(
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
- en: compose_band_path,
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
- en: itertools.repeat("../output/"),
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
- en: itertools.repeat("15m_B"),
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
- en: bands_numbers))
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
- en: 1) Resample RGB bands.
  id: totrans-1402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for source, destination in zip(bands_paths, output_images): resample_image(source,
    destination, block_height=200)'
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
- en: 2) Create a true color composition with the resampled bands.
  id: totrans-1404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This image is only for comparison.
  id: totrans-1405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: create_color_composition(list(output_images),
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
- en: '''../output/preview_resampled_composition.tif'','
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
- en: (4209, 11677, 348, 209))
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
- en: 3) Crop all the bands.
  id: totrans-1409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: output_images.append(
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
- en: '"../../data/landsat/LC80140282015270LGN00_B8.TIF") for source in output_images:'
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
- en: crop_and_save(source)
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
- en: 4) Use the cropped images for pan sharpening.
  id: totrans-1413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: band8 = "../output/preview__LC80140282015270LGN00_B8.TIF"
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
- en: bgr_bands = itertools.imap(
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
- en: compose_band_path,
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
- en: itertools.repeat("../output/"),
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
- en: itertools.repeat("preview__15m_B"),
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
- en: bands_numbers)
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
- en: pan_sharpen(list(bgr_bands),
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
- en: band8, "../output/pan_sharpened.tif")
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
- en: The procedure to generate the iterator with the file names is the same as used
    before.
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
- en: In Part 1, the resampling of the RGB bands will be made using the default linear
    interpolation.
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
- en: In Part 2 we will create a true color composition with the resampled RGB bands.
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
- en: We won’t use this image to perform the pan sharpening; we are creating it only
    to compare the results.
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
- en: We crop all the bands in Part 3\. By doing this, we are also adjusting the values
    of the grayscale from 16 bits to 8 bits. Finally, the pan sharpening is performed
    in Part 4\.
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 90](img/index-448_1.jpg)'
  id: totrans-1427
  prefs: []
  type: TYPE_IMG
- en: '2\. Now add the pan_sharpen function to your file:'
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
- en: 'def pan_sharpen(bgr_bands, pan_band, out_img):'
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
- en: bgr_arrays = []
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
- en: Read the images into Numpy arrays.
  id: totrans-1431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for item in bgr_bands:'
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
- en: array = cv.imread(item, flags=cv.CV_LOAD_IMAGE_GRAYSCALE)
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
- en: bgr_arrays.append(array)
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
- en: pan_array = cv.imread(pan_band, flags=cv.CV_LOAD_IMAGE_GRAYSCALE)
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
- en: Create the RGB (BGR) composition and convert it to HSV.
  id: totrans-1436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: bgr_composition = np.dstack(bgr_arrays)
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
- en: hsv_composition = cv.cvtColor(bgr_composition, cv.COLOR_BGR2HSV)
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
- en: Split the bands and remove the original value component,
  id: totrans-1439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: we wont use it.
  id: totrans-1440
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: h, s, v = np.dsplit(hsv_composition, 3)
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
- en: h, s = np.squeeze(h), np.squeeze(s)
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
- en: del v
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
- en: Use the panchromatic band as the V component.
  id: totrans-1444
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pan_composition = np.dstack((h, s, pan_array))
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
- en: Convert the image back to BGR and write it to the disk.
  id: totrans-1446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: bgr_composition = cv.cvtColor(pan_composition, cv.COLOR_HSV2BGR) cv.imwrite(out_img,
    bgr_composition)
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
- en: The process is simple. The joining and splitting of the bands is done with NumPy’s
    dstack and dsplit functions. The color conversion is done by the cvtcolor function.
    Note that OpenCV uses a sequence of BGR bands instead of RGB.
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Run the code and open the color compositions in the output folder to see
    the results.
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
- en: 'The resampled composition:'
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
- en: 'The image with pan sharpening:'
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 91](img/index-449_1.jpg)'
  id: totrans-1452
  prefs: []
  type: TYPE_IMG
- en: I would say that we achieved impressive results. The pan sharpened image is
    very clear and we can easily identify the city’s features on it.
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we saw how to distribute jobs into multiple processor cores,
    allowing the program to use all the available computing power.
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
- en: Although parallel processing is a great resource, we found in our examples that
    it’s not applicable for all situations. Specifically, when the bottleneck is not
    the CPU, multiprocessing may downgrade the program speed.
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
- en: In the course of our examples, we took low-resolution satellite images and were
    able to increase their resolution and level of detail through resampling and pan
    sharpening, obtaining images of much greater value for visual analysis.
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
- en: '**Index**'
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
- en: '**A**'
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
- en: abstraction / [Making data homogeneous](index_split_000.html#p148)
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
- en: about / [The concept of abstraction](index_split_000.html#p148)
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Spaceborne Thermal Emission and Reflection Radiometer (ASTER) /
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
- en: '[Processing remote sensing images and data](index_split_002.html#p286)'
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
- en: alpha blending / [Blending images](index_split_002.html#p336)
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
- en: app
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
- en: integrating with / [Integrating with the app](index_split_001.html#p221)
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
- en: area of all countries
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
- en: '[calculating / Transforming the coordinate system and calculating the area
    of all](index_split_000.html#p92)'
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
- en: '[countries](index_split_000.html#p92)'
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
- en: attributes and relations
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
- en: filtering by / [Filtering by attributes and relations](index_split_001.html#p212)
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
- en: attributes values
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
- en: obtaining / [Getting the attributes’ values](index_split_001.html#p191)
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
- en: '**B**'
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
- en: bands / [Processing remote sensing images and data](index_split_002.html#p286)
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
- en: basic statistics, raster data
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
- en: about / [Getting the basic statistics](index_split_002.html#p312)
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
- en: data, preparing / [Preparing the data](index_split_002.html#p312)
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
- en: simple information, printing / [Printing simple information](index_split_002.html#p312)
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
- en: output information, formatting / [Formatting the output information](index_split_002.html#p312)
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
- en: quartiles, calculating / [Calculating quartiles, histograms, and other statistics](index_split_002.html#p312)
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
- en: histograms, calculating / [Calculating quartiles, histograms, and other statistics](index_split_002.html#p312)
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
- en: '[other statistics, calculating / Calculating quartiles, histograms, and other](index_split_002.html#p312)'
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
- en: '[statistics](index_split_002.html#p312)'
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
- en: making, lazy property / [Making statistics a lazy property](index_split_002.html#p312)
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
- en: block iteration
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
- en: about / [Block iteration](#p430)
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
- en: book project
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
- en: creating / [Creating the book project](index_split_000.html#p84)
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
- en: '**C**'
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
- en: closest point
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
- en: searching / [Finding the closest point](index_split_000.html#p134)
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
- en: code comments
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
- en: about / [Documenting your code](index_split_000.html#p103)
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
- en: code profiling
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
- en: about / [Code profiling](index_split_002.html#p354)
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
- en: color classified images
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
- en: creating / [Creating color classified images](index_split_002.html#p325)
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
- en: right colors, selecting for map / [Choosing the right colors for a map](index_split_002.html#p325)
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
- en: context manager / [Downloading data from a URL](index_split_000.html#p112)
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
- en: coordinate system
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
- en: '[transforming / Transforming the coordinate system and calculating the area
    of](index_split_000.html#p92)'
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
- en: '[all countries](index_split_000.html#p92)'
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
- en: countries
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
- en: sorting, by area size / [Sort the countries by area size](index_split_000.html#p98)
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
- en: current location
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
- en: setting / [Setting your current location](index_split_000.html#p130)
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
- en: '**D**'
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
- en: data
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
- en: making homogeneous / [Making data homogeneous](index_split_000.html#p148)
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
- en: importing / [Generating the tables and importing data](index_split_002.html#p356)
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
- en: filtering / [Filtering the data](index_split_002.html#p356)
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
- en: searching for / [Searching for data and crossing information](#p385)
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
- en: filtering, boundaries used / [Filtering using boundaries](#p385)
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
- en: database
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
- en: information, storing on / [Storing information on a database](index_split_002.html#p356)
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
- en: populating, with real data / [Populating the database with real data](#p368)
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
- en: database inserts
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
- en: optimizing / [Optimizing database inserts](#p368)
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
- en: data parsing
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
- en: optimizing / [Optimizing data parsing](#p368)
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
- en: digital elevation models (DEM)
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
- en: about / [Processing remote sensing images and data](index_split_002.html#p286)
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
- en: reference / [Processing remote sensing images and data](index_split_002.html#p286)
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
- en: docstrings
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
- en: about / [Documenting your code](index_split_000.html#p103)
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
- en: '**E**'
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
- en: ElementTree / [Populating the database with real data](#p368)
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
- en: ESRI shapefile / [Representing geographic data](index_split_000.html#p142)
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
- en: execution time
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
- en: measuring / [Measuring execution time](index_split_002.html#p347)
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
- en: '**F**'
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
- en: file
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
- en: opening / [Opening the file and getting its contents](index_split_000.html#p122)
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
- en: contents, obtaining / [Opening the file and getting its contents](index_split_000.html#p122)
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
- en: content, preparing for analysis / [Preparing the content for analysis](index_split_000.html#p122)
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
- en: filters
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
- en: chaining / [Chaining filters](index_split_001.html#p217)
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
- en: first example
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
- en: programming / [Programming and running your first example](index_split_000.html#p88)
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
- en: running / [Programming and running your first example](index_split_000.html#p88)
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
- en: function
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
- en: combining, into application / [Combining functions into an application](index_split_000.html#p126)
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
- en: '**G**'
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
- en: GDAL
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
- en: about / [Installing GDAL and OGR](index_split_000.html#p62)
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
- en: installing, on Windows / [Windows](index_split_000.html#p62)
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
- en: installing, on Ubuntu Linux / [Ubuntu Linux](index_split_000.html#p62)
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
- en: geocache point
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
- en: abstracting / [Abstracting the geocache point](index_split_000.html#p148)
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
- en: geocaching app
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
- en: basic application structure, building / [Building the basic application structure](index_split_000.html#p103)
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
- en: application tree structure, creating / [Creating the application tree structure](index_split_000.html#p103)
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
- en: functions / [Functions and methods](index_split_000.html#p103)
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
- en: methods / [Functions and methods](index_split_000.html#p103)
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
- en: code, documenting / [Documenting your code](index_split_000.html#p103)
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
- en: application entry point, creating / [Creating the application entry point](index_split_000.html#p103)
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
- en: geocaching data
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
- en: downloading / [Downloading geocaching data](index_split_000.html#p112)
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
- en: direct download / [Downloading geocaching data](index_split_000.html#p112)
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
- en: REST API / [Downloading geocaching data](index_split_000.html#p112)
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
- en: sources / [Geocaching data sources](index_split_000.html#p112)
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
- en: information, fetching from REST API / [Fetching information from a REST API](index_split_000.html#p112)
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
- en: downloading, from URL / [Downloading data from a URL](index_split_000.html#p112)
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
- en: downloading manually / [Downloading data manually](index_split_000.html#p112)
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
- en: download link / [Downloading data manually](index_split_000.html#p112)
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
- en: abstracting / [Abstracting geocaching data](index_split_000.html#p148)
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
- en: importing / [Importing geocaching data](index_split_000.html#p154)
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
- en: GPX attributes, reading / [Reading GPX attributes](index_split_000.html#p154)
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
- en: homogeneous data, returning / [Returning the homogeneous data](index_split_000.html#p154)
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
- en: converting, into Geocache objects / [Converting the data into Geocache objects](index_split_000.html#p154)
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
- en: multiple sources, merging / [Merging multiple sources of data](index_split_000.html#p154)
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
- en: GeoDjango / [Creating an Object Relational Mapping](index_split_002.html#p356)
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
- en: geographic data
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
- en: representing / [Representing geographic data](index_split_000.html#p142)
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
- en: geometries
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
- en: representing / [Representing geometries](index_split_000.html#p142)
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
- en: geometry relationships
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
- en: about / [Geometry relationships](index_split_001.html#p203)
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
- en: touches / [Touches](index_split_001.html#p203)
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
- en: crosses / [Crosses](index_split_001.html#p203)
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
- en: contains / [Contains](index_split_001.html#p203)
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
- en: within / [Within](index_split_001.html#p203)
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
- en: equals or almost equals / [Equals or almost equals](index_split_001.html#p203)
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
- en: intersects / [Intersects](index_split_001.html#p203)
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
- en: disjoint / [Disjoint](index_split_001.html#p203)
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
- en: geo objects
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
- en: exporting / [Exporting geo objects](index_split_001.html#p259)
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
- en: global interpreter lock (GIL)
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
- en: pan sharpening / [Multiprocessing basics](#p424)
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
- en: GPX format / [Representing geographic data](index_split_000.html#p142)
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
- en: '**H**'
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
- en: hardware bottleneck / [Image resampling](#p436)
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
- en: hill shading / [Creating a shaded relief image](index_split_002.html#p286)
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
- en: histogram
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
- en: for colorizing maps / [Using the histogram to colorize the image](index_split_002.html#p339)
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
- en: '**I**'
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
- en: IDE
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
- en: about / [Installing an IDE](index_split_000.html#p80)
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
- en: installing / [Installing an IDE](index_split_000.html#p80)
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
- en: installing, on Windows / [Windows](index_split_000.html#p80)
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
- en: installing, on Linux / [Linux](index_split_000.html#p80)
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
- en: image compositions
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
- en: creating / [Creating image compositions](#p412)
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
- en: true color compositions / [True color compositions](#p412)
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
- en: specific regions, processing / [Processing specific regions](#p412)
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
- en: false color compositions / [False color compositions](#p412)
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
- en: image processing pipeline
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
- en: building / [Building an image processing pipeline](index_split_002.html#p300)
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
- en: image resolution
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
- en: improving / [Improving the image resolution](#p436)
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
- en: image resampling / [Image resampling](#p436)
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
- en: pan sharpening / [Pan sharpening](#p436)
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
- en: images
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
- en: representing / [Understanding how images are represented](index_split_002.html#p277)
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
- en: opening, with OpenCV / [Opening images with OpenCV](index_split_002.html#p277)
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
- en: numerical types / [Knowing numerical types](index_split_002.html#p277)
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
- en: blending / [Blending images](index_split_002.html#p336)
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
- en: memory usage / [Memory and images](#p399)
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
- en: processing, by chunks / [Processing images in chunks](#p403)
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
- en: opening, GDAL used / [Using GDAL to open images](#p403)
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
- en: iterating through, whole image / [Iterating through the whole image](#p403)
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
- en: iterables / [Iterating through the whole image](#p403)
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
- en: iterator / [Iterating through the whole image](#p403)
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
- en: '**J**'
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
- en: Java Topology Suite (JTS)
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
- en: about / [Using Shapely to handle geometries](index_split_001.html#p180)
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
- en: JSON (JavaScript Object Notation) / [Representing geographic data](index_split_000.html#p142)
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
- en: '**L**'
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
- en: Landsat 8 images
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
- en: about / [Getting Landsat 8 images](#p392)
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
- en: obtaining / [Getting Landsat 8 images](#p392)
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
- en: lazy evaluation / [Making statistics a lazy property](index_split_002.html#p312)
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
- en: lines
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
- en: importing / [Importing lines](index_split_001.html#p194)
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
- en: IDE, installing / [Linux](index_split_000.html#p80)
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
- en: '**M**'
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
- en: Map Maker app
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
- en: creating / [Creating the Map Maker app](index_split_001.html#p263)
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
- en: PythonDatasource, using / [Using PythonDatasource](index_split_001.html#p263)
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
- en: using, with filtering / [Using the app with filtering](index_split_001.html#p263)
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
- en: Mapnik
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
- en: about / [Installing Mapnik](index_split_000.html#p68), [Windows,](index_split_000.html#p68)
    [Knowing Mapnik](index_split_001.html#p227)
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
- en: installing / [Installing Mapnik](index_split_000.html#p68)
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
- en: installing, on Windows / [Windows](index_split_000.html#p68)
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
- en: installing, on Ubuntu Linux / [Ubuntu Linux](index_split_000.html#p68)
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
- en: experiments, performing with / [Knowing Mapnik](index_split_001.html#p227)
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
- en: map, making with pure Python / [Making a map with pure Python](index_split_001.html#p227)
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
- en: map, making with style sheet / [Making a map with a style sheet](index_split_001.html#p227)
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
- en: maps
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
- en: styling / [Styling maps](index_split_001.html#p241)
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
- en: style options / [Styling maps](index_split_001.html#p241)
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
- en: layers, adding / [Adding layers to the map](index_split_001.html#p241)
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
- en: massive data
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
- en: importing / [Importing massive amount of data](#p368)
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
- en: memoization / [Making statistics a lazy property](index_split_002.html#p312)
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
- en: memorization / [Converting the spatial reference system and units](index_split_001.html#p198)
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
- en: mosaicking / [Mosaicking images](index_split_002.html#p286)
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
- en: multiple attributes
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
- en: filtering by / [Filtering by multiple attributes](index_split_001.html#p217)
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
- en: multiprocessing
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
- en: basics / [Multiprocessing basics](#p424)
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
- en: about / [Multiprocessing basics](#p424)
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
- en: '**N**'
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
- en: new functionality
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
- en: integrating, into application / [Integrating new functionality into the application](index_split_001.html#p169)
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
- en: Noun Project
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
- en: reference / [Point styles](index_split_001.html#p241)
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
- en: Numpy
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
- en: about / [Installing NumPy](index_split_000.html#p58)
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
- en: installing / [Installing NumPy](index_split_000.html#p58)
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
- en: installing, on Windows / [Windows](index_split_000.html#p58)
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
- en: installing, on Ubuntu Linux / [Ubuntu Linux](index_split_000.html#p58)
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
- en: Numpy documentation
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
- en: reference / [Mosaicking images](index_split_002.html#p286)
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
- en: '**O**'
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
- en: Object Relational Mapping (ORM)
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
- en: creating / [Creating an Object Relational Mapping](index_split_002.html#p356)
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
- en: environment, preparing / [Preparing the environment](index_split_002.html#p356)
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
- en: models, changing / [Changing our models](index_split_002.html#p356)
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
- en: manager, customizing / [Customizing a manager](index_split_002.html#p356)
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
- en: OGR drivers
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
- en: about / [Installing GDAL and OGR](index_split_000.html#p62)
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
- en: Opencaching Nodes / [Geocaching data sources](index_split_000.html#p112)
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
- en: Open Computer Vision (OpenCV) package / [Automatically previewing the map](index_split_001.html#p234)
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
- en: OpenCV
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
- en: about / [OpenCV](index_split_000.html#p53)
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
- en: Open Geospatial Consortium (OGC)
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
- en: about / [Knowing well-known text](index_split_001.html#p174)
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
- en: OpenStreetMap / [Representing geometries](index_split_000.html#p142)
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
- en: OpenStreetMap points of interest
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
- en: importing / [Importing OpenStreetMap points of interest](#p368)
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
- en: OpenStreetMap wiki
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
- en: URL / [Searching for data and crossing information](#p385)
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
- en: Operational Land Imager (OLI) / [Working with satellite images](#p392)
  id: totrans-1696
  prefs: []
  type: TYPE_NORMAL
- en: other packages
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
- en: installing, from pip / [Installing other packages directly from pip](index_split_000.html#p76)
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
- en: installing, on Windows / [Windows](index_split_000.html#p76)
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
- en: installing, on Ubuntu Linux / [Ubuntu Linux](index_split_000.html#p76)
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
- en: Overpass API / [Importing OpenStreetMap points of interest](#p368)
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
- en: '**P**'
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
- en: painter model / [Polygon style](index_split_001.html#p241)
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
- en: pan sharpening / [Pan sharpening](#p436)
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
- en: PEP-8
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
- en: '[about / Transforming the coordinate system and calculating the area of all](index_split_000.html#p92)'
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
- en: '[countries](index_split_000.html#p92)'
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
- en: '[URL / Transforming the coordinate system and calculating the area of all](index_split_000.html#p92)'
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
- en: '[countries](index_split_000.html#p92)'
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
- en: pixel
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
- en: about / [Understanding how images are represented](index_split_002.html#p277)
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
- en: points of interest (POI) / [Importing OpenStreetMap points of interest](#p368)
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
- en: polygons
  id: totrans-1713
  prefs: []
  type: TYPE_NORMAL
- en: working with / [Working with polygons](index_split_001.html#p174)
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
- en: importing / [Importing polygons](index_split_001.html#p183)
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
- en: Postgis extension / [Storing information on a database](index_split_002.html#p356)
  id: totrans-1716
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
- en: URL / [Storing information on a database](index_split_002.html#p356)
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL database / [Storing information on a database](index_split_002.html#p356)
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
- en: Poços de Caldas / [Processing remote sensing images and data](index_split_002.html#p286)
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
- en: processing pipeline / [Building an image processing pipeline](index_split_002.html#p300)
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
- en: profiling / [Measuring execution time](index_split_002.html#p347)
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
- en: Python
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
- en: installing / [Installing Python](index_split_000.html#p45)
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
- en: installing, on Windows / [Windows](index_split_000.html#p45)
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
- en: installing, on Ubuntu Linux / [Ubuntu Linux](index_split_000.html#p45)
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
- en: Python glossary
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
- en: reference / [Using Python objects as a source of data](index_split_001.html#p254)
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
- en: Python objects
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
- en: using, as source of data / [Using Python objects as a source of data](index_split_001.html#p254)
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
- en: Python package
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
- en: about / [Python packages and package manager](index_split_000.html#p50)
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
- en: package manager / [Python packages and package manager](index_split_000.html#p50)
  id: totrans-1733
  prefs: []
  type: TYPE_NORMAL
- en: repository, for Windows / [The repository of Python packages for Windows](index_split_000.html#p50)
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
- en: installing / [Installing packages and required software](index_split_000.html#p53)
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
- en: required software / [Installing packages and required software](index_split_000.html#p53)
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
- en: installation, for Windows / [Windows](index_split_000.html#p53)
  id: totrans-1737
  prefs: []
  type: TYPE_NORMAL
- en: installation, for Ubuntu Linux / [Ubuntu Linux](index_split_000.html#p53)
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
- en: '**R**'
  id: totrans-1739
  prefs: []
  type: TYPE_NORMAL
- en: raster data
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
- en: basic statistics / [Getting the basic statistics](index_split_002.html#p312)
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
- en: RasterData class
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
- en: creating / [Creating a RasterData class](index_split_002.html#p300)
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
- en: relief shading / [Creating a shaded relief image](index_split_002.html#p286)
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
- en: remote sensing images
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
- en: processing / [Processing remote sensing images and data](index_split_002.html#p286)
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
- en: mosaicking / [Mosaicking images](index_split_002.html#p286)
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
- en: values, adjusting / [Adjusting the values of the images](index_split_002.html#p286)
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
- en: cropping / [Cropping an image](index_split_002.html#p286)
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
- en: shaded relief image, creating / [Creating a shaded relief image](index_split_002.html#p286)
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
- en: REST (Representational State Transfer) / [Downloading geocaching data](index_split_000.html#p112)
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
- en: reStructuredText
  id: totrans-1752
  prefs: []
  type: TYPE_NORMAL
- en: reference / [Documenting your code](index_split_000.html#p103)
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
- en: '**S**'
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
- en: satellite images
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
- en: about / [Working with satellite images](#p392)
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
- en: working with / [Working with satellite images](#p392)
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
- en: Scalable Vector Graphics (SVG) file / [Point styles](index_split_001.html#p241)
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
- en: Shapely
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
- en: about / [Installing Shapely,](index_split_000.html#p72) [Using Shapely to handle
    geometries](index_split_001.html#p180)
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
- en: installing, on Windows / [Windows](index_split_000.html#p72)
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
- en: installing, on Ubuntu Linux / [Ubuntu Linux](index_split_000.html#p72)
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
- en: for handling geometries / [Using Shapely to handle geometries](index_split_001.html#p180)
  id: totrans-1763
  prefs: []
  type: TYPE_NORMAL
- en: spaghetti data / [Representing geometries](index_split_000.html#p142)
  id: totrans-1764
  prefs: []
  type: TYPE_NORMAL
- en: Spatialite extension / [Storing information on a database](index_split_002.html#p356)
  id: totrans-1765
  prefs: []
  type: TYPE_NORMAL
- en: spatial reference system
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
- en: units, converting / [Converting the spatial reference system and units](index_split_001.html#p198)
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
- en: SpatiLite / [Representing geographic data](index_split_000.html#p142)
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
- en: SQLite database / [Storing information on a database](index_split_002.html#p356)
  id: totrans-1769
  prefs: []
  type: TYPE_NORMAL
- en: statistics
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
- en: showing, with colors / [Showing statistics with colors](index_split_002.html#p339)
  id: totrans-1771
  prefs: []
  type: TYPE_NORMAL
- en: style options, maps
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
- en: map style / [Map style](index_split_001.html#p241)
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
- en: polygon style / [Polygon style](index_split_001.html#p241)
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
- en: line styles / [Line styles](index_split_001.html#p241)
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
- en: text styles / [Text styles](index_split_001.html#p241)
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
- en: point styles / [Point styles](index_split_001.html#p241)
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
- en: SVG transformations
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
- en: reference / [Point styles](index_split_001.html#p241)
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
- en: '**T**'
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
- en: tables
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
- en: generating / [Generating the tables and importing data](index_split_002.html#p356)
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
- en: test data
  id: totrans-1783
  prefs: []
  type: TYPE_NORMAL
- en: removing / [Removing the test data](#p368)
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
- en: Thermal Infrared Sensor (TIRS) / [Working with satellite images](#p392)
  id: totrans-1785
  prefs: []
  type: TYPE_NORMAL
- en: TIFF format / [Block iteration](#p430)
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
- en: '**U**'
  id: totrans-1787
  prefs: []
  type: TYPE_NORMAL
- en: U.S Geological Survey (USGS) EarthExplorer / [Getting Landsat 8 images](#p392)
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
- en: URL / [Storing information on a database](index_split_002.html#p356)
  id: totrans-1790
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu Linux
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
- en: Python, installing / [Ubuntu Linux](index_split_000.html#p45)
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
- en: Python package, installing / [Ubuntu Linux](index_split_000.html#p53)
  id: totrans-1793
  prefs: []
  type: TYPE_NORMAL
- en: Numpy, installing / [Ubuntu Linux](index_split_000.html#p58)
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
- en: GDAL, installing / [Ubuntu Linux](index_split_000.html#p62)
  id: totrans-1795
  prefs: []
  type: TYPE_NORMAL
- en: Mapnik, installing / [Ubuntu Linux](index_split_000.html#p68)
  id: totrans-1796
  prefs: []
  type: TYPE_NORMAL
- en: Shapely, installing / [Ubuntu Linux](index_split_000.html#p72)
  id: totrans-1797
  prefs: []
  type: TYPE_NORMAL
- en: other packages, installing / [Ubuntu Linux](index_split_000.html#p76)
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
- en: utility functions
  id: totrans-1799
  prefs: []
  type: TYPE_NORMAL
- en: creating, for generating maps / [Creating utility functions to generate maps](index_split_001.html#p234)
  id: totrans-1800
  prefs: []
  type: TYPE_NORMAL
- en: data source, changing at runtime / [Changing the data source at runtime](index_split_001.html#p234)
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
- en: map, previewing automatically / [Automatically previewing the map](index_split_001.html#p234)
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
- en: '**W**'
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
- en: well-known binary (WKB)
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
- en: about / [Knowing well-known text](index_split_001.html#p174)
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
- en: well-known text (WKT)
  id: totrans-1806
  prefs: []
  type: TYPE_NORMAL
- en: about / [Knowing well-known text](index_split_001.html#p174)
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  id: totrans-1808
  prefs: []
  type: TYPE_NORMAL
- en: Python, installing / [Windows](index_split_000.html#p45)
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
- en: Python package, installing / [Windows](index_split_000.html#p53)
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
- en: Numpy, installing / [Windows](index_split_000.html#p58)
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
- en: GDAL, installing / [Windows](index_split_000.html#p62)
  id: totrans-1812
  prefs: []
  type: TYPE_NORMAL
- en: Mapnik, installing / [Windows](index_split_000.html#p68)
  id: totrans-1813
  prefs: []
  type: TYPE_NORMAL
- en: Shapely, installing / [Windows](index_split_000.html#p72)
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
- en: other packages, installing / [Windows](index_split_000.html#p76)
  id: totrans-1815
  prefs: []
  type: TYPE_NORMAL
- en: IDE, installing / [Windows](index_split_000.html#p80)
  id: totrans-1816
  prefs: []
  type: TYPE_NORMAL
- en: Document Outline
  id: totrans-1817
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Geospatial Development By Example with Python](index_split_000.html#p13)'
  id: totrans-1818
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Credits](index_split_000.html#p15)'
  id: totrans-1819
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[About the Author](index_split_000.html#p17)'
  id: totrans-1820
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[About the Reviewers](index_split_000.html#p19)'
  id: totrans-1821
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[www.PacktPub.com](index_split_000.html#p21)'
  id: totrans-1822
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Support files, eBooks, discount offers, and more](index_split_000.html#p23)'
  id: totrans-1823
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Why subscribe?](index_split_000.html#p24)'
  id: totrans-1824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Free access for Packt account holders](index_split_000.html#p25)'
  id: totrans-1825
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Preface](index_split_000.html#p26)'
  id: totrans-1826
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[What this book covers](index_split_000.html#p28)'
  id: totrans-1827
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[What you need for this book](index_split_000.html#p30)'
  id: totrans-1828
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Who this book is for](index_split_000.html#p32)'
  id: totrans-1829
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Conventions](index_split_000.html#p34)'
  id: totrans-1830
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Reader feedback](index_split_000.html#p36)'
  id: totrans-1831
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Customer support](index_split_000.html#p38)'
  id: totrans-1832
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Downloading the example code](index_split_000.html#p40)'
  id: totrans-1833
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Downloading the color images of this book](index_split_000.html#p41)'
  id: totrans-1834
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Errata](index_split_000.html#p42)'
  id: totrans-1835
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Piracy](index_split_000.html#p43)'
  id: totrans-1836
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Questions](index_split_000.html#p44)'
  id: totrans-1837
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[1\. Preparing the Work Environment](index_split_000.html#p45)'
  id: totrans-1838
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Installing Python](index_split_000.html#p47)'
  id: totrans-1839
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Windows](index_split_000.html#p48)'
  id: totrans-1840
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Ubuntu Linux](index_split_000.html#p49)'
  id: totrans-1841
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Python packages and package manager](index_split_000.html#p50)'
  id: totrans-1842
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The repository of Python packages for Windows](index_split_000.html#p52)'
  id: totrans-1843
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Installing packages and required software](index_split_000.html#p53)'
  id: totrans-1844
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[OpenCV](index_split_000.html#p55)'
  id: totrans-1845
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Windows](index_split_000.html#p56)'
  id: totrans-1846
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Ubuntu Linux](index_split_000.html#p57)'
  id: totrans-1847
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Installing NumPy](index_split_000.html#p58)'
  id: totrans-1848
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Windows](index_split_000.html#p60)'
  id: totrans-1849
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Ubuntu Linux](index_split_000.html#p61)'
  id: totrans-1850
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Installing GDAL and OGR](index_split_000.html#p62)'
  id: totrans-1851
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Windows](index_split_000.html#p66)'
  id: totrans-1852
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Ubuntu Linux](index_split_000.html#p67)'
  id: totrans-1853
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Installing Mapnik](index_split_000.html#p68)'
  id: totrans-1854
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Windows](index_split_000.html#p70)'
  id: totrans-1855
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Ubuntu Linux](index_split_000.html#p71)'
  id: totrans-1856
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Installing Shapely](index_split_000.html#p72)'
  id: totrans-1857
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Windows](index_split_000.html#p74)'
  id: totrans-1858
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Ubuntu Linux](index_split_000.html#p75)'
  id: totrans-1859
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Installing other packages directly from pip](index_split_000.html#p76)'
  id: totrans-1860
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Windows](index_split_000.html#p78)'
  id: totrans-1861
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Ubuntu Linux](index_split_000.html#p79)'
  id: totrans-1862
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Installing an IDE](index_split_000.html#p80)'
  id: totrans-1863
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Windows](index_split_000.html#p82)'
  id: totrans-1864
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Linux](index_split_000.html#p83)'
  id: totrans-1865
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Creating the book project](index_split_000.html#p84)'
  id: totrans-1866
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Programming and running your first example](index_split_000.html#p88)'
  id: totrans-1867
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Transforming the coordinate system and calculating the area of all countries](index_split_000.html#p92)'
  id: totrans-1868
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Sort the countries by area size](index_split_000.html#p98)'
  id: totrans-1869
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_000.html#p101)'
  id: totrans-1870
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[2\. The Geocaching App](index_split_000.html#p103)'
  id: totrans-1871
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Building the basic application structure](index_split_000.html#p105)'
  id: totrans-1872
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Creating the application tree structure](index_split_000.html#p106)'
  id: totrans-1873
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Functions and methods](index_split_000.html#p107)'
  id: totrans-1874
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Documenting your code](index_split_000.html#p108)'
  id: totrans-1875
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Creating the application entry point](index_split_000.html#p109)'
  id: totrans-1876
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Downloading geocaching data](index_split_000.html#p112)'
  id: totrans-1877
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Geocaching data sources](index_split_000.html#p114)'
  id: totrans-1878
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Fetching information from a REST API](index_split_000.html#p115)'
  id: totrans-1879
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Downloading data from a URL](index_split_000.html#p117)'
  id: totrans-1880
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Downloading data manually](index_split_000.html#p119)'
  id: totrans-1881
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Opening the file and getting its contents](index_split_000.html#p122)'
  id: totrans-1882
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Preparing the content for analysis](index_split_000.html#p125)'
  id: totrans-1883
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Combining functions into an application](index_split_000.html#p126)'
  id: totrans-1884
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Setting your current location](index_split_000.html#p130)'
  id: totrans-1885
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Finding the closest point](index_split_000.html#p134)'
  id: totrans-1886
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_000.html#p140)'
  id: totrans-1887
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[3\. Combining Multiple Data Sources](index_split_000.html#p142)'
  id: totrans-1888
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Representing geographic data](index_split_000.html#p144)'
  id: totrans-1889
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Representing geometries](index_split_000.html#p146)'
  id: totrans-1890
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Making data homogeneous](index_split_000.html#p148)'
  id: totrans-1891
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The concept of abstraction](index_split_000.html#p150)'
  id: totrans-1892
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Abstracting the geocache point](index_split_000.html#p151)'
  id: totrans-1893
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Abstracting geocaching data](index_split_000.html#p153)'
  id: totrans-1894
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Importing geocaching data](index_split_000.html#p154)'
  id: totrans-1895
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Reading GPX attributes](index_split_000.html#p158)'
  id: totrans-1896
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Returning the homogeneous data](index_split_001.html#p163)'
  id: totrans-1897
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Converting the data into Geocache objects](index_split_001.html#p165)'
  id: totrans-1898
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Merging multiple sources of data](index_split_001.html#p167)'
  id: totrans-1899
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Integrating new functionality into the application](index_split_001.html#p169)'
  id: totrans-1900
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_001.html#p172)'
  id: totrans-1901
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[4\. Improving the App Search Capabilities](index_split_001.html#p174)'
  id: totrans-1902
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Working with polygons](index_split_001.html#p176)'
  id: totrans-1903
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Knowing well-known text](index_split_001.html#p177)'
  id: totrans-1904
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using Shapely to handle geometries](index_split_001.html#p180)'
  id: totrans-1905
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Importing polygons](index_split_001.html#p183)'
  id: totrans-1906
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Getting the attributes'' values](index_split_001.html#p191)'
  id: totrans-1907
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Importing lines](index_split_001.html#p194)'
  id: totrans-1908
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Converting the spatial reference system and units](index_split_001.html#p198)'
  id: totrans-1909
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Geometry relationships](index_split_001.html#p203)'
  id: totrans-1910
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Touches](index_split_001.html#p205)'
  id: totrans-1911
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Crosses](index_split_001.html#p206)'
  id: totrans-1912
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Contains](index_split_001.html#p207)'
  id: totrans-1913
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Within](index_split_001.html#p208)'
  id: totrans-1914
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Equals or almost equals](index_split_001.html#p209)'
  id: totrans-1915
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Intersects](index_split_001.html#p210)'
  id: totrans-1916
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Disjoint](index_split_001.html#p211)'
  id: totrans-1917
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Filtering by attributes and relations](index_split_001.html#p212)'
  id: totrans-1918
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Filtering by multiple attributes](index_split_001.html#p217)'
  id: totrans-1919
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chaining filters](index_split_001.html#p219)'
  id: totrans-1920
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Integrating with the app](index_split_001.html#p221)'
  id: totrans-1921
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_001.html#p225)'
  id: totrans-1922
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[5\. Making Maps](index_split_001.html#p227)'
  id: totrans-1923
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Knowing Mapnik](index_split_001.html#p229)'
  id: totrans-1924
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Making a map with pure Python](index_split_001.html#p230)'
  id: totrans-1925
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Making a map with a style sheet](index_split_001.html#p232)'
  id: totrans-1926
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Creating utility functions to generate maps](index_split_001.html#p234)'
  id: totrans-1927
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Changing the data source at runtime](index_split_001.html#p236)'
  id: totrans-1928
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Automatically previewing the map](index_split_001.html#p239)'
  id: totrans-1929
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Styling maps](index_split_001.html#p241)'
  id: totrans-1930
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Map style](index_split_001.html#p243)'
  id: totrans-1931
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Polygon style](index_split_001.html#p244)'
  id: totrans-1932
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Line styles](index_split_001.html#p246)'
  id: totrans-1933
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Text styles](index_split_001.html#p248)'
  id: totrans-1934
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Adding layers to the map](index_split_001.html#p249)'
  id: totrans-1935
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Point styles](index_split_001.html#p252)'
  id: totrans-1936
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using Python objects as a source of data](index_split_001.html#p254)'
  id: totrans-1937
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Exporting geo objects](index_split_001.html#p259)'
  id: totrans-1938
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Creating the Map Maker app](index_split_001.html#p263)'
  id: totrans-1939
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using PythonDatasource](index_split_002.html#p267)'
  id: totrans-1940
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using the app with filtering](index_split_002.html#p273)'
  id: totrans-1941
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_002.html#p275)'
  id: totrans-1942
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[6\. Working with Remote Sensing Images](index_split_002.html#p277)'
  id: totrans-1943
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Understanding how images are represented](index_split_002.html#p279)'
  id: totrans-1944
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Opening images with OpenCV](index_split_002.html#p282)'
  id: totrans-1945
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Knowing numerical types](index_split_002.html#p284)'
  id: totrans-1946
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Processing remote sensing images and data](index_split_002.html#p286)'
  id: totrans-1947
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Mosaicking images](index_split_002.html#p289)'
  id: totrans-1948
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Adjusting the values of the images](index_split_002.html#p294)'
  id: totrans-1949
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Cropping an image](index_split_002.html#p296)'
  id: totrans-1950
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Creating a shaded relief image](index_split_002.html#p298)'
  id: totrans-1951
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Building an image processing pipeline](index_split_002.html#p300)'
  id: totrans-1952
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Creating a RasterData class](index_split_002.html#p303)'
  id: totrans-1953
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_002.html#p310)'
  id: totrans-1954
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[7\. Extract Information from Raster Data](index_split_002.html#p312)'
  id: totrans-1955
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Getting the basic statistics](index_split_002.html#p314)'
  id: totrans-1956
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Preparing the data](index_split_002.html#p316)'
  id: totrans-1957
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Printing simple information](index_split_002.html#p317)'
  id: totrans-1958
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Formatting the output information](index_split_002.html#p319)'
  id: totrans-1959
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Calculating quartiles, histograms, and other statistics](index_split_002.html#p321)'
  id: totrans-1960
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Making statistics a lazy property](index_split_002.html#p323)'
  id: totrans-1961
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Creating color classified images](index_split_002.html#p325)'
  id: totrans-1962
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Choosing the right colors for a map](index_split_002.html#p329)'
  id: totrans-1963
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Blending images](index_split_002.html#p336)'
  id: totrans-1964
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Showing statistics with colors](index_split_002.html#p339)'
  id: totrans-1965
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using the histogram to colorize the image](index_split_002.html#p342)'
  id: totrans-1966
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_002.html#p345)'
  id: totrans-1967
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[8\. Data Miner App](index_split_002.html#p347)'
  id: totrans-1968
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Measuring execution time](index_split_002.html#p350)'
  id: totrans-1969
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Code profiling](index_split_002.html#p354)'
  id: totrans-1970
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Storing information on a database](index_split_002.html#p356)'
  id: totrans-1971
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Creating an Object Relational Mapping](index_split_002.html#p358)'
  id: totrans-1972
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Preparing the environment](index_split_002.html#p359)'
  id: totrans-1973
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Changing our models](index_split_002.html#p360)'
  id: totrans-1974
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Customizing a manager](index_split_002.html#p360)'
  id: totrans-1975
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Generating the tables and importing data](index_split_002.html#p365)'
  id: totrans-1976
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Filtering the data](index_split_002.html#p367)'
  id: totrans-1977
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Importing massive amount of data](index_split_003.html#p368)'
  id: totrans-1978
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Optimizing database inserts](index_split_003.html#p370)'
  id: totrans-1979
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Optimizing data parsing](index_split_003.html#p373)'
  id: totrans-1980
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Importing OpenStreetMap points of interest](index_split_003.html#p376)'
  id: totrans-1981
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Removing the test data](index_split_003.html#p380)'
  id: totrans-1982
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Populating the database with real data](index_split_003.html#p381)'
  id: totrans-1983
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Searching for data and crossing information](index_split_003.html#p385)'
  id: totrans-1984
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Filtering using boundaries](index_split_003.html#p388)'
  id: totrans-1985
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_003.html#p390)'
  id: totrans-1986
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[9\. Processing Big Images](index_split_003.html#p392)'
  id: totrans-1987
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Working with satellite images](index_split_003.html#p394)'
  id: totrans-1988
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Getting Landsat 8 images](index_split_003.html#p396)'
  id: totrans-1989
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Memory and images](index_split_003.html#p399)'
  id: totrans-1990
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Processing images in chunks](index_split_003.html#p403)'
  id: totrans-1991
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using GDAL to open images](index_split_003.html#p405)'
  id: totrans-1992
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Iterating through the whole image](index_split_003.html#p408)'
  id: totrans-1993
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Creating image compositions](index_split_003.html#p412)'
  id: totrans-1994
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[True color compositions](index_split_003.html#p414)'
  id: totrans-1995
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Processing specific regions](index_split_003.html#p417)'
  id: totrans-1996
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[False color compositions](index_split_003.html#p419)'
  id: totrans-1997
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_003.html#p422)'
  id: totrans-1998
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[10\. Parallel Processing](index_split_003.html#p424)'
  id: totrans-1999
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Multiprocessing basics](index_split_003.html#p426)'
  id: totrans-2000
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Block iteration](index_split_003.html#p430)'
  id: totrans-2001
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Improving the image resolution](index_split_003.html#p436)'
  id: totrans-2002
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Image resampling](index_split_003.html#p438)'
  id: totrans-2003
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Pan sharpening](index_split_003.html#p446)'
  id: totrans-2004
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_003.html#p450)'
  id: totrans-2005
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Index](index_split_003.html#p452)'
  id: totrans-2006
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
