- en: (u'@xmlns', u'http://geocaching.com.au/geocache/1')
  prefs: []
  type: TYPE_NORMAL
- en: (u'desc', u'LaSalle Park No 1 by Mr.Yuck, Unknown Cache (1/1)') (u'urlname',
    u'LaSalle Park No 1')
  prefs: []
  type: TYPE_NORMAL
- en: (u'owner', u'Mr.Yuck')
  prefs: []
  type: TYPE_NORMAL
- en: (u'difficulty', u'1')
  prefs: []
  type: TYPE_NORMAL
- en: (u'sym', u'Geocache')
  prefs: []
  type: TYPE_NORMAL
- en: (u'terrain', u'1')
  prefs: []
  type: TYPE_NORMAL
- en: (u'status', u'Available')
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: '**Importing massive amount of data**'
  prefs: []
  type: TYPE_NORMAL
- en: Now that our environment is ready, we can begin working with bigger datasets.
    Let’s start by profiling the import process and then optimize it. We will start
    with our small geocaching dataset and after the code is optimized we will move
    to bigger sets.
  prefs: []
  type: TYPE_NORMAL
- en: '1\. In your geodata_app.py file, edit the if __name__ == ''__main__'': block
    to call the profiler.'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: profile = cProfile.Profile()
  prefs: []
  type: TYPE_NORMAL
- en: profile.enable()
  prefs: []
  type: TYPE_NORMAL
- en: import_initial_data("../data/geocaching.gpx", 'geocaching') profile.disable()
  prefs: []
  type: TYPE_NORMAL
- en: profile.print_stats(sort='cumulative')
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Run the code and see the results. Don’t worry about duplicated entries in
    the database now, we will clean it later. (I removed some information from the
    following output for space reasons.)
  prefs: []
  type: TYPE_NORMAL
- en: Importing geocaching…
  prefs: []
  type: TYPE_NORMAL
- en: 112 features.
  prefs: []
  type: TYPE_NORMAL
- en: Done!
  prefs: []
  type: TYPE_NORMAL
- en: 1649407 function calls (1635888 primitive calls) in 5.858 seconds cumtime percall
    filename:lineno(function)
  prefs: []
  type: TYPE_NORMAL
- en: 5.863 5.863 geodata_app.py:24(import_initial_data)
  prefs: []
  type: TYPE_NORMAL
- en: 5.862 5.862 managers.py:11(import_data)
  prefs: []
  type: TYPE_NORMAL
- en: 4.899 0.002 related.py:749(create)
  prefs: []
  type: TYPE_NORMAL
- en: 4.888 0.002 manager.py:126(manager_method)
  prefs: []
  type: TYPE_NORMAL
- en: 3.621 0.001 base.py:654(save)
  prefs: []
  type: TYPE_NORMAL
- en: 3.582 0.001 base.py:737(save_base)
  prefs: []
  type: TYPE_NORMAL
- en: 3.491 0.001 query.py:341(create)
  prefs: []
  type: TYPE_NORMAL
- en: 1.924 0.001 base.py:799(_save_table)
  prefs: []
  type: TYPE_NORMAL
- en: ncalls tottime percall cumtime percall filename:lineno(function) 1 0.001 0.001
    5.863 5.863 (import_initial_data) 1 0.029 0.029 5.862 5.862 (import_data)
  prefs: []
  type: TYPE_NORMAL
- en: 2497 0.018 0.000 4.899 0.002 related.py:749(create) Take a look at ncalls and
    cumtime for each of the functions. The create function is called a lot of times
    and accumulates almost five seconds on my computer. This is the function (method)
    called when we add a tag to a GeoObject. The time spent on this function is relevant
    when we import geocaching data because every point has a lot of attributes. Maybe
    we can make this process more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optimizing database inserts**'
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in the profiler, the method we are using to insert the tags into the
    database creates a bottleneck when we import geocaching data with our current
    code. If we can change how it’s done, we can make the code run faster.
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Go to your manager and edit the import_data method of the GeoCollection
    manager:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class GeoCollection(GeoManager):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""This class represents a collection of spatial data."""'
  prefs: []
  type: TYPE_NORMAL
- en: 'def import_data(self, file_path, atype):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Opens an vector file compatible with OGR and parses the data.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param str file_path: The full path to the file.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: from models import Tag
  prefs: []
  type: TYPE_NORMAL
- en: features = open_vector_file(file_path)
  prefs: []
  type: TYPE_NORMAL
- en: tags = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for feature in features:'
  prefs: []
  type: TYPE_NORMAL
- en: geom = shape(feature['geometry'])
  prefs: []
  type: TYPE_NORMAL
- en: geo_object = self.model(geom=geom.wkt, atype=atype)
  prefs: []
  type: TYPE_NORMAL
- en: geo_object.save()
  prefs: []
  type: TYPE_NORMAL
- en: geoo_id = geo_object.id
  prefs: []
  type: TYPE_NORMAL
- en: 'for key, value in feature[''properties''].iteritems():'
  prefs: []
  type: TYPE_NORMAL
- en: tags.append(Tag(key=key, value=value,
  prefs: []
  type: TYPE_NORMAL
- en: geo_object_id=geoo_id))
  prefs: []
  type: TYPE_NORMAL
- en: Tag.objects.bulk_create(tags)
  prefs: []
  type: TYPE_NORMAL
- en: Instead of creating the tags one by one, now we add them to a list without hitting
    the database; only in the end do we call bulk_create, which inserts all entries
    in a single request. Note that the import statements for the Tag model are inside
    the function.
  prefs: []
  type: TYPE_NORMAL
- en: This will avoid an error with circular imports, because models also import the
    managers.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Run your code and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: 'django.db.utils.DataError: value too long for type character varying(250)'
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 1
  prefs: []
  type: TYPE_NORMAL
- en: Since bulk_insert sends everything together to the database, we can’t catch
    exceptions for individual tags.
  prefs: []
  type: TYPE_NORMAL
- en: The solution is to validate the tag before we insert it. At this point we are
    making a trade-off between generalization and performance because the validation
    may fail depending on the type of data, whereas the error catching could be triggered
    by a wide range of reasons.
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Edit the code again:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class GeoCollection(GeoManager):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""This class represents a collection of spatial data."""'
  prefs: []
  type: TYPE_NORMAL
- en: 'def import_data(self, file_path, atype):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Opens an vector file compatible with OGR and parses the data.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param str file_path: The full path to the file.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: from models import Tag
  prefs: []
  type: TYPE_NORMAL
- en: features = open_vector_file(file_path)
  prefs: []
  type: TYPE_NORMAL
- en: tags = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for feature in features:'
  prefs: []
  type: TYPE_NORMAL
- en: geom = shape(feature['geometry'])
  prefs: []
  type: TYPE_NORMAL
- en: geo_object = self.model(geom=geom.wkt, atype=atype)
  prefs: []
  type: TYPE_NORMAL
- en: geo_object.save()
  prefs: []
  type: TYPE_NORMAL
- en: geoo_id = geo_object.id
  prefs: []
  type: TYPE_NORMAL
- en: 'for key, value in feature[''properties''].iteritems():'
  prefs: []
  type: TYPE_NORMAL
- en: if value and (isinstance(value, unicode)
  prefs: []
  type: TYPE_NORMAL
- en: 'or isinstance(value, str)):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if len(value) <= 250:'
  prefs: []
  type: TYPE_NORMAL
- en: tags.append(Tag(key=key, value=value,
  prefs: []
  type: TYPE_NORMAL
- en: geo_object_id=geoo_id))
  prefs: []
  type: TYPE_NORMAL
- en: Tag.objects.bulk_create(tags)
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Now run geodata_app.py again and look at the profiler results: 506679 function
    calls (506308 primitive calls) in 1.144 seconds Ordered by: cumulative time'
  prefs: []
  type: TYPE_NORMAL
- en: ncalls cumtime percall filename:lineno(function)
  prefs: []
  type: TYPE_NORMAL
- en: 1 1.144 1.144 geodata_app.py:24(import_initial_data)
  prefs: []
  type: TYPE_NORMAL
- en: 1 1.142 1.142 managers.py:12(import_data)
  prefs: []
  type: TYPE_NORMAL
- en: 1 0.556 0.556 geo_functions.py:91(open_vector_file)
  prefs: []
  type: TYPE_NORMAL
- en: 1 0.549 0.549 geo_functions.py:9(read_gpx_file)
  prefs: []
  type: TYPE_NORMAL
- en: '**1 0.541 0.541 xmltodict.py:155(parse)**'
  prefs: []
  type: TYPE_NORMAL
- en: 1 0.541 0.541 {built-in method Parse}
  prefs: []
  type: TYPE_NORMAL
- en: 6186 0.387 0.000 pyexpat.c:566(StartElement)
  prefs: []
  type: TYPE_NORMAL
- en: 6186 0.380 0.000 xmltodict.py:89(startElement)
  prefs: []
  type: TYPE_NORMAL
- en: 112 0.317 0.003 base.py:654(save)
  prefs: []
  type: TYPE_NORMAL
- en: 112 0.316 0.003 base.py:737(save_base)
  prefs: []
  type: TYPE_NORMAL
- en: 14/113 0.290 0.003 manager.py:126(manager_method)
  prefs: []
  type: TYPE_NORMAL
- en: 12487 0.278 0.000 collections.py:38(__init__)
  prefs: []
  type: TYPE_NORMAL
- en: 113 0.235 0.002 query.py:910(_insert)
  prefs: []
  type: TYPE_NORMAL
- en: 113 0.228 0.002 compiler.py:969(execute_sql)
  prefs: []
  type: TYPE_NORMAL
- en: 6186 0.178 0.000 xmltodict.py:84(_attrs_to_dict)
  prefs: []
  type: TYPE_NORMAL
- en: '**1 0.170 0.170 query.py:356(bulk_create)**'
  prefs: []
  type: TYPE_NORMAL
- en: The import now runs five times faster. Note how the profile changed. The database
    part of the process felt down on the list and now the most time-consuming part
    is the conversion from XML (the GPX file) to a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the output, we also see that we have another.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have much more efficient code and we won’t change how the
    XML
  prefs: []
  type: TYPE_NORMAL
- en: conversion is done. Instead, we will move on to testing and optimizing the process
    for
  prefs: []
  type: TYPE_NORMAL
- en: other types of data.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optimizing data parsing**'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that we made a branch in our code to import GPX files, because OGR/GDAL
  prefs: []
  type: TYPE_NORMAL
- en: 'was unable to import the nested data inside those files. So we should expect
    that when importing shapefiles or GML files, we will have a different profile
    for code execution time. Let’s try it:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Now we will test the code with the world borders dataset. Change the if
    __name__
  prefs: []
  type: TYPE_NORMAL
- en: '== ''__main__'': block of geodata_app.py:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: profile = cProfile.Profile()
  prefs: []
  type: TYPE_NORMAL
- en: profile.enable()
  prefs: []
  type: TYPE_NORMAL
- en: import_initial_data("../data/world_borders_simple.shp",
  prefs: []
  type: TYPE_NORMAL
- en: '''boundary'')'
  prefs: []
  type: TYPE_NORMAL
- en: profile.disable()
  prefs: []
  type: TYPE_NORMAL
- en: profile.print_stats(sort='cumulative')
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Run the code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'ValueError: A LinearRing must have at least 3 coordinate tuples Process finished
    with exit code 1'
  prefs: []
  type: TYPE_NORMAL
- en: Well, it doesn’t work. What is happening here is that Shapely is complaining
    about the geometry that is being passed to it. This is because this branch of
    the code is passing a WKT geometry instead of coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: Django can receive the geometry as a WKT and we are using Shapely for the conversion.
  prefs: []
  type: TYPE_NORMAL
- en: 'This may be a time-consuming step and we are going to eliminate it. At this
    point, we are just using common sense to optimize the code: the fewer the steps,
    the faster the code.'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Edit the GeoCollection manager:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class GeoCollection(GeoManager):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""This class represents a collection of spatial data."""'
  prefs: []
  type: TYPE_NORMAL
- en: 'def import_data(self, file_path, atype):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Opens an vector file compatible with OGR and parses the data.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param str file_path: The full path to the file.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: from models import Tag
  prefs: []
  type: TYPE_NORMAL
- en: features = open_vector_file(file_path)
  prefs: []
  type: TYPE_NORMAL
- en: tags = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for feature in features:'
  prefs: []
  type: TYPE_NORMAL
- en: geo_object = self.model(geom=feature['geom'],
  prefs: []
  type: TYPE_NORMAL
- en: atype=atype)
  prefs: []
  type: TYPE_NORMAL
- en: geo_object.save()
  prefs: []
  type: TYPE_NORMAL
- en: geoo_id = geo_object.id
  prefs: []
  type: TYPE_NORMAL
- en: 'for key, value in feature[''properties''].iteritems():'
  prefs: []
  type: TYPE_NORMAL
- en: if value and (isinstance(value, unicode)
  prefs: []
  type: TYPE_NORMAL
- en: 'or isinstance(value, str)): if len(value) <= 250:'
  prefs: []
  type: TYPE_NORMAL
- en: tags.append(Tag(key=key, value=value,
  prefs: []
  type: TYPE_NORMAL
- en: geo_object_id=geoo_id))
  prefs: []
  type: TYPE_NORMAL
- en: Tag.objects.bulk_create(tags)
  prefs: []
  type: TYPE_NORMAL
- en: We eliminated the Shapely use (you can remove it from the imports too) and changed
    how the geometry is retrieved from the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Now go to geo_functions.py and edit the read_ogr_features function: def
    read_ogr_features(layer):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Convert OGR features from a layer into dictionaries.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param layer: OGR layer.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: features = []
  prefs: []
  type: TYPE_NORMAL
- en: layer_defn = layer.GetLayerDefn()
  prefs: []
  type: TYPE_NORMAL
- en: layer.ResetReading()
  prefs: []
  type: TYPE_NORMAL
- en: type = ogr.GeometryTypeToName(layer.GetGeomType())
  prefs: []
  type: TYPE_NORMAL
- en: 'for item in layer:'
  prefs: []
  type: TYPE_NORMAL
- en: attributes = {}
  prefs: []
  type: TYPE_NORMAL
- en: 'for index in range(layer_defn.GetFieldCount()):'
  prefs: []
  type: TYPE_NORMAL
- en: field_defn = layer_defn.GetFieldDefn(index)
  prefs: []
  type: TYPE_NORMAL
- en: key = field_defn.GetName()
  prefs: []
  type: TYPE_NORMAL
- en: value = item.GetFieldAsString(index)
  prefs: []
  type: TYPE_NORMAL
- en: attributes[key] = value
  prefs: []
  type: TYPE_NORMAL
- en: feature = {
  prefs: []
  type: TYPE_NORMAL
- en: '"geom": item.GetGeometryRef().ExportToWkt(),'
  prefs: []
  type: TYPE_NORMAL
- en: '"properties": attributes}'
  prefs: []
  type: TYPE_NORMAL
- en: features.append(feature)
  prefs: []
  type: TYPE_NORMAL
- en: return features
  prefs: []
  type: TYPE_NORMAL
- en: 'As a trade-off between generalization and performance, we changed the feature
    dictionary from the universal GeoJSON format to contain only two keys: geom with
    a WKT geometry and properties.'
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Now edit the read_gpx_file function so it’s compliant with the new format:
    def read_gpx_file(file_path):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Reads a GPX file containing geocaching points.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param str file_path: The full path to the file.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: 'with open(file_path) as gpx_file:'
  prefs: []
  type: TYPE_NORMAL
- en: gpx_dict = xmltodict.parse(gpx_file.read())
  prefs: []
  type: TYPE_NORMAL
- en: output = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for wpt in gpx_dict[''gpx''][''wpt'']:'
  prefs: []
  type: TYPE_NORMAL
- en: geometry = "POINT(" + wpt.pop('@lat') + " " + \ wpt.pop('@lon') + ")"
  prefs: []
  type: TYPE_NORMAL
- en: If geocache is not on the dict, skip this wpt.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: geocache = wpt.pop('geocache')
  prefs: []
  type: TYPE_NORMAL
- en: 'except KeyError:'
  prefs: []
  type: TYPE_NORMAL
- en: continue
  prefs: []
  type: TYPE_NORMAL
- en: 'attributes = {''status'': geocache.pop(''@status'')}'
  prefs: []
  type: TYPE_NORMAL
- en: Merge the dictionaries.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: attributes.update(wpt)
  prefs: []
  type: TYPE_NORMAL
- en: attributes.update(geocache)
  prefs: []
  type: TYPE_NORMAL
- en: Construct a GeoJSON feature and append to the list.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: feature = {
  prefs: []
  type: TYPE_NORMAL
- en: '"geom": geometry,'
  prefs: []
  type: TYPE_NORMAL
- en: '"properties": attributes}'
  prefs: []
  type: TYPE_NORMAL
- en: output.append(feature)
  prefs: []
  type: TYPE_NORMAL
- en: return output
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Run your code again (you can also test importing points again if you wish,
    you will get a few milliseconds of improvement). Look at the result: Importing
    boundary…'
  prefs: []
  type: TYPE_NORMAL
- en: 245 features.
  prefs: []
  type: TYPE_NORMAL
- en: Done!
  prefs: []
  type: TYPE_NORMAL
- en: 90746 function calls (90228 primitive calls) in 5.164 seconds
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 63](img/index-376_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Importing OpenStreetMap points of interest**'
  prefs: []
  type: TYPE_NORMAL
- en: '**OpenStreetMap** (**OSM**) is a collaborative mapping project where everyone
    can make an account and collaborate in the map making. It’s something like Wikipedia,
    but instead of articles the community make maps.'
  prefs: []
  type: TYPE_NORMAL
- en: The data is all available for download, and some regions have incredibly detailed
    maps.
  prefs: []
  type: TYPE_NORMAL
- en: What we want here is to get **points of interest** (**POI**). These are points
    that represent the location of restaurants, supermarkets, banks, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshot of Boulevard Saint-Laurent in Montreal.
    Each one of those small icons is a POI:'
  prefs: []
  type: TYPE_NORMAL
- en: OSM data can be easily obtained using its API, which is called **Overpass API**.
    It allows the user to make advanced queries and filter data of interest.
  prefs: []
  type: TYPE_NORMAL
- en: The obtained data is in XML format adapted for OSM needs. We are going to use
    overpy, a Python package that translates this data into Python objects.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, I have to admit that through my career I have been deeply inspired
    by OSM
  prefs: []
  type: TYPE_NORMAL
- en: and its data format. It’s simple and yet flexible, to the point where everything
    in OSM is represented by the same schema.
  prefs: []
  type: TYPE_NORMAL
- en: OSM consists of nodes, a lot of nodes. Actually by this date it had 3,037,479,553
    nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 64](img/index-377_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That’s right, more than three billion nodes. Nodes can be points or can be related
    to other nodes as part of something represented by a line or polygon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every node can have an arbitrary number of tags made of key/value pairs, just
    like our data. Take a look at the information obtained from one of the POI: So,
    storing OpenStreetMap POIs in our database will be pretty straightforward. First,
    let’s create a utility function to download points for a given region of interest.'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Go to the utils folder and create a new Python file named osm_data.py.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Add the following code to this file:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import overpy
  prefs: []
  type: TYPE_NORMAL
- en: 'def get_osm_poi(bbox):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Downloads points of interest from OpenStreetMap.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param bbox: The bounding box of the region to get the points.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: api = overpy.Overpass()
  prefs: []
  type: TYPE_NORMAL
- en: result = api.query("""
  prefs: []
  type: TYPE_NORMAL
- en: <osm-script>
  prefs: []
  type: TYPE_NORMAL
- en: <query type="node">
  prefs: []
  type: TYPE_NORMAL
- en: <bbox-query s="{ymin}" n="{ymax}" w="{xmin}" e="{xmax}"/>
  prefs: []
  type: TYPE_NORMAL
- en: <has-kv k="amenity"/>
  prefs: []
  type: TYPE_NORMAL
- en: </query>
  prefs: []
  type: TYPE_NORMAL
- en: <print/>
  prefs: []
  type: TYPE_NORMAL
- en: </osm-script>
  prefs: []
  type: TYPE_NORMAL
- en: '""".format(**bbox))'
  prefs: []
  type: TYPE_NORMAL
- en: print("Found {} POIs".format(len(result.nodes)))
  prefs: []
  type: TYPE_NORMAL
- en: return result
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == "__main__":'
  prefs: []
  type: TYPE_NORMAL
- en: bbox = {"xmin":-71.606, "ymin":46.714,
  prefs: []
  type: TYPE_NORMAL
- en: '"xmax":-71.140, "ymax":48.982}'
  prefs: []
  type: TYPE_NORMAL
- en: result = get_osm_poi(bbox)
  prefs: []
  type: TYPE_NORMAL
- en: print(result.nodes[0].tags)
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a simple wrapper for overpy that queries all points in a given region
    and has the amenity key. In the if __name__ == ''__main__'': block, we make a
    simple test, get some points, and print the tags of one of them.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get more information on the Overpass API at this site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://wiki.openstreetmap.org/wiki/Overpass_API/Language_Guide](http://wiki.openstreetmap.org/wiki/Overpass_API/Language_Guide).'
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Run the code on this file. Remember to press *Alt* + *Shift* + *F10* to
    choose a different file and select osm_data in the list. You should get an output
    like this: Found 3523 POIs'
  prefs: []
  type: TYPE_NORMAL
- en: '{''operator'': ''Desjardins'', ''amenity'': ''bank'', ''atm'': ''yes'', ''name'':'
  prefs: []
  type: TYPE_NORMAL
- en: '''Caisse Populaire Desjardins''}'
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have overpy installed, just click on it in your code, press Alt
    + F10 and select "Install Package"
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s import this data into our database. Open your manage.py file. We
    will create a new method to our GeoCollection manager, very similar to import_data,
    but specific to OSM data.
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Edit your manage.py file and add this new method to the GeoCollection class:'
  prefs: []
  type: TYPE_NORMAL
- en: '#...'
  prefs: []
  type: TYPE_NORMAL
- en: 'def import_osm_data(self, result):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Import OpenStreetMap points of interest.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param str file_path: The full path to the file.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: from models import Tag
  prefs: []
  type: TYPE_NORMAL
- en: tags = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for node in result.nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: geometry = "POINT(" + str(node.lat) + " " + \ str(node.lon) + ")"
  prefs: []
  type: TYPE_NORMAL
- en: geo_object = self.model(geom=geometry, atype="poi") geo_object.save()
  prefs: []
  type: TYPE_NORMAL
- en: geoo_id = geo_object.id
  prefs: []
  type: TYPE_NORMAL
- en: 'for key, value in node.tags.iteritems():'
  prefs: []
  type: TYPE_NORMAL
- en: tags.append(Tag(key=key, value=value, geo_object_id=geoo_id))
  prefs: []
  type: TYPE_NORMAL
- en: Tag.objects.bulk_create(tags)
  prefs: []
  type: TYPE_NORMAL
- en: We could have reused the code that is common for both import_data and import_osm_data,
    but in this chapter we are emphasizing speed and, as was stated earlier, sometimes
    it’s easier to achieve better execution times with specific functions.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we were able to remove the verifications when creating the tags,
    making the loop run faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s test this new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Open the geodata_app.py file and add this import at the beginning of the
    file: from utils.osm_data import get_osm_poi'
  prefs: []
  type: TYPE_NORMAL
- en: '6\. Now edit the if __name__ == ''__main__'': block:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: bbox = {"xmin":-71.206, "ymin":47.714,
  prefs: []
  type: TYPE_NORMAL
- en: '"xmax":-71.140, "ymax":48.982}'
  prefs: []
  type: TYPE_NORMAL
- en: result = get_osm_poi(bbox)
  prefs: []
  type: TYPE_NORMAL
- en: GeoObject.objects.import_osm_data(result)
  prefs: []
  type: TYPE_NORMAL
- en: points = GeoObject.objects.filter(atype='poi')
  prefs: []
  type: TYPE_NORMAL
- en: print(len(points))
  prefs: []
  type: TYPE_NORMAL
- en: '7\. Finally, run the code and see if you get an output resembling the following
    (the number of points may be different for you):'
  prefs: []
  type: TYPE_NORMAL
- en: Found 14 POIs
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: '**Removing the test data**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we continue with real imports, let’s clean the database of all the data
    we put into it for testing. Let’s make a simple function for this job in our app:
    1\. In geodata_app.py, add this function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def clean_database():'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Remove all records from the database."""'
  prefs: []
  type: TYPE_NORMAL
- en: from django.db import connection
  prefs: []
  type: TYPE_NORMAL
- en: cursor = connection.cursor()
  prefs: []
  type: TYPE_NORMAL
- en: cursor.execute('DELETE FROM geodata_tag;')
  prefs: []
  type: TYPE_NORMAL
- en: cursor.execute('DELETE FROM geodata_geoobject;')
  prefs: []
  type: TYPE_NORMAL
- en: Here we are calling SQL commands directly on the database in order to avoid
    all Django overheads and get a better performance.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Now call it from the if __name__ == ''__main__'': block:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: clean_database()
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Run the code; it may take a while to finish.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Keep it as a resource in case you want to make other tests or if you need
    to start over.
  prefs: []
  type: TYPE_NORMAL
- en: '**Populating the database with real data**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it’s time to put real data into our database. We will import all the data
    that we used so far, plus additional data:'
  prefs: []
  type: TYPE_NORMAL
- en: Geocaching points (extended version)
  prefs: []
  type: TYPE_NORMAL
- en: World borders
  prefs: []
  type: TYPE_NORMAL
- en: Canadian districts borders
  prefs: []
  type: TYPE_NORMAL
- en: Points of interest in Canada
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Go to your geodata_app.py file and edit the if __name__ == ''__main__'':
    block: if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: import_initial_data("../data/canada_div.gml", 'canada') import_initial_data("../data/world_borders_simple.shp",
    'world') import_initial_data("../data/geocaching_big.gpx", 'geocaching') This
    time we are setting more specific types for our data to make our queries easier.
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Now, run the code to begin importing. In the end you should have this output:
    Importing canada…'
  prefs: []
  type: TYPE_NORMAL
- en: 293 features.
  prefs: []
  type: TYPE_NORMAL
- en: Done!
  prefs: []
  type: TYPE_NORMAL
- en: Importing world…
  prefs: []
  type: TYPE_NORMAL
- en: 245 features.
  prefs: []
  type: TYPE_NORMAL
- en: Done!
  prefs: []
  type: TYPE_NORMAL
- en: Importing geocaching…
  prefs: []
  type: TYPE_NORMAL
- en: 1638 features.
  prefs: []
  type: TYPE_NORMAL
- en: Done!
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s time to fetch points of interest from OpenStreetMap and add them to
    our database.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Add this function to your geodata_app.py:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def import_from_osm(district):'
  prefs: []
  type: TYPE_NORMAL
- en: tags = Tag.objects.filter(value="Montreal")
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: borders = GeoObject.objects.get(atype='canada',
  prefs: []
  type: TYPE_NORMAL
- en: tags__key='CDNAME',
  prefs: []
  type: TYPE_NORMAL
- en: tags__value=district)
  prefs: []
  type: TYPE_NORMAL
- en: extent = borders.geom.extent
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Extent: {}".format(extent))'
  prefs: []
  type: TYPE_NORMAL
- en: bbox = {"xmin":extent[0], "ymin":extent[1],
  prefs: []
  type: TYPE_NORMAL
- en: '"xmax":extent[2], "ymax":extent[3]}'
  prefs: []
  type: TYPE_NORMAL
- en: osm_poi = get_osm_poi(bbox)
  prefs: []
  type: TYPE_NORMAL
- en: GeoObject.objects.import_osm_data(osm_poi)
  prefs: []
  type: TYPE_NORMAL
- en: print("Done!")
  prefs: []
  type: TYPE_NORMAL
- en: This function takes a district name. Get it from our database and use its extent
    to query the OSM API.
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Change the if __name__ == ''__main__'': block:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: import_from_osm('Montréal')
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Now, run the code. It may take some time to download the data from OSM.
    When it’s done, your output should be something like the following (the number
    of features may be different):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Extent: (-73.9763757739999, 45.4021292300001, -73.476065978, 45.703747476)'
  prefs: []
  type: TYPE_NORMAL
- en: Found 5430 POIs
  prefs: []
  type: TYPE_NORMAL
- en: Done!
  prefs: []
  type: TYPE_NORMAL
- en: '--- Memory Error ----'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you will probably have your first contact with another issue
    in code optimization: memory consumption. Unless you have a large amount of RAM,
    you’ll be faced with Python’s MemoryError. This means that your computer ran out
    of memory while parsing the huge amount of POIs acquired from OSM.'
  prefs: []
  type: TYPE_NORMAL
- en: This happened because the whole XML from OSM was parsed into Python objects
    and later into Django objects, and they were all stored in the memory at the same
    time.
  prefs: []
  type: TYPE_NORMAL
- en: The solution here is to read one XML tag at a time. If it’s a node, put it into
    the database, get its tags, and release the memory. To do that, we will use a
    XML file available on the sample data, so we don’t need to download it again.
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Open the managers.py file and add this import at the beginning of the file:
    import xml.etree.cElementTree as ET'
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Go to your GeoCollection manager and edit the import_osm_data method:'
  prefs: []
  type: TYPE_NORMAL
- en: '#...'
  prefs: []
  type: TYPE_NORMAL
- en: '#...'
  prefs: []
  type: TYPE_NORMAL
- en: 'def import_osm_data(self, input_file):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Import OpenStreetMap points of interest.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param str input_file: The full path to the file.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: from models import Tag
  prefs: []
  type: TYPE_NORMAL
- en: tags = []
  prefs: []
  type: TYPE_NORMAL
- en: tags_counter = 0
  prefs: []
  type: TYPE_NORMAL
- en: nodes_counter = 0
  prefs: []
  type: TYPE_NORMAL
- en: xml_iter = ET.iterparse(input_file)
  prefs: []
  type: TYPE_NORMAL
- en: 'for event, elem in xml_iter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if elem.tag == ''node'':'
  prefs: []
  type: TYPE_NORMAL
- en: lat, lon = elem.get('lat'), elem.get('lon')
  prefs: []
  type: TYPE_NORMAL
- en: geometry = "POINT(" + str(lat) + " " + str(lon) + ")"
  prefs: []
  type: TYPE_NORMAL
- en: geo_object = self.model(geom=geometry, atype="poi") geo_object.save()
  prefs: []
  type: TYPE_NORMAL
- en: geoo_id = geo_object.id
  prefs: []
  type: TYPE_NORMAL
- en: nodes_counter += 1
  prefs: []
  type: TYPE_NORMAL
- en: 'if nodes_counter % 10000 == 0:'
  prefs: []
  type: TYPE_NORMAL
- en: print("{} Nodes…".format(nodes_counter))
  prefs: []
  type: TYPE_NORMAL
- en: print("Creating tags…") Tag.objects.bulk_create(tags)
  prefs: []
  type: TYPE_NORMAL
- en: tags = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for child_tag in elem:'
  prefs: []
  type: TYPE_NORMAL
- en: key = child_tag.get('k')
  prefs: []
  type: TYPE_NORMAL
- en: value = child_tag.get('v')
  prefs: []
  type: TYPE_NORMAL
- en: 'if len(value) <= 250:'
  prefs: []
  type: TYPE_NORMAL
- en: tags.append(Tag(key=key,
  prefs: []
  type: TYPE_NORMAL
- en: value=value,
  prefs: []
  type: TYPE_NORMAL
- en: geo_object_id=geoo_id))
  prefs: []
  type: TYPE_NORMAL
- en: tags_counter += 1
  prefs: []
  type: TYPE_NORMAL
- en: elem.clear()
  prefs: []
  type: TYPE_NORMAL
- en: print("Creating tags…")
  prefs: []
  type: TYPE_NORMAL
- en: Tag.objects.bulk_create(tags)
  prefs: []
  type: TYPE_NORMAL
- en: print("Imported {} nodes with {} tags.".format(
  prefs: []
  type: TYPE_NORMAL
- en: nodes_counter, tags_counter))
  prefs: []
  type: TYPE_NORMAL
- en: print("Done!")
  prefs: []
  type: TYPE_NORMAL
- en: '**ElementTree** is a Python module designed for XML parsing; cElementTree has
    the same functionality but is implemented in C. The only restriction on using
    cElementTree is when C library loading is not available, which is not the case
    here.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the solution to optimizing tag creation is to accumulate the tags
    in a list, bulk-create tags every 10,000 nodes, and then clear the list.
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Edit the if __name__ == ''__main__'': block of the geodata_app.py file
    to test the code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: 'GeoObject.objects.import_osm_data("../data/osm.xml") 4\. Now run it. While
    you wait, you can open the Windows Task Manager, or the system monitor on Ubuntu,
    and see how your computer resources are being consumed and/or watch the progress
    in the console output:'
  prefs: []
  type: TYPE_NORMAL
- en: 10000 Nodes…
  prefs: []
  type: TYPE_NORMAL
- en: Creating tags…
  prefs: []
  type: TYPE_NORMAL
- en: 20000 Nodes…
  prefs: []
  type: TYPE_NORMAL
- en: Creating tags…
  prefs: []
  type: TYPE_NORMAL
- en: 30000 Nodes…
  prefs: []
  type: TYPE_NORMAL
- en: Creating tags…
  prefs: []
  type: TYPE_NORMAL
- en: 40000 Nodes…
  prefs: []
  type: TYPE_NORMAL
- en: Creating tags…
  prefs: []
  type: TYPE_NORMAL
- en: 50000 Nodes…
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: Imported 269300 nodes with 1272599 tags.
  prefs: []
  type: TYPE_NORMAL
- en: Done!
  prefs: []
  type: TYPE_NORMAL
- en: If you were watching your computer resources, you should have seen that the
    memory consumption fluctuated around some value. As the memory didn’t keep increasing
    as more and more nodes were imported, we would be able to import virtually any
    given number of points on files of any size because the code is stable and has
    no memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: On my computer, Python consumed something around 100 Mb of memory during the
    program execution. The processor cores stayed mostly at 5% of load (Python and
    PostgreSQL) and the hard drive was 100% occupied with database writing.
  prefs: []
  type: TYPE_NORMAL
- en: It would be possible to tweak the database for a better performance, but this
    is beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that, if you want to make more tests, you can always clean the database
    with the function that we created before. Just remember to import all the data
    again before we continue.
  prefs: []
  type: TYPE_NORMAL
- en: '**Searching for data and crossing**'
  prefs: []
  type: TYPE_NORMAL
- en: '**information**'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our database populated with some data, it’s time to get some
    information from it; let’s explore what kind of information all those POIs hold.
    We know that we downloaded points that contain at least one of the amenity or
    store keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Amenities are described by OSM as any type of community facilities. As an exercise,
    let’s see a list of amenity types that we got from the points:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Edit your geodata_app.py file’s if __name__ == ''__main__'': block: if
    __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: amenity_values = Tag.objects.filter(
  prefs: []
  type: TYPE_NORMAL
- en: key='amenity').distinct('value').values_list('value')
  prefs: []
  type: TYPE_NORMAL
- en: 'for item in amenity_values:'
  prefs: []
  type: TYPE_NORMAL
- en: print(item[0])
  prefs: []
  type: TYPE_NORMAL
- en: Here we take the Tag model, access its manager (objects), then filter the tags
    whose key='amenity'. Then we separate only distinct values (exclude repeated values
    from the query). The final part—values_list('value')—tells Django that we don’t
    want it to create Tag models, we only want a list of values.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Run the code, and take a look at the huge list of amenity types: atm, fuel'
  prefs: []
  type: TYPE_NORMAL
- en: atm;telephone
  prefs: []
  type: TYPE_NORMAL
- en: audiologist
  prefs: []
  type: TYPE_NORMAL
- en: auditorium
  prefs: []
  type: TYPE_NORMAL
- en: Auto Body Repair Shop
  prefs: []
  type: TYPE_NORMAL
- en: auto_club
  prefs: []
  type: TYPE_NORMAL
- en: automobile_club
  prefs: []
  type: TYPE_NORMAL
- en: baby_hatch
  prefs: []
  type: TYPE_NORMAL
- en: bail_bonds
  prefs: []
  type: TYPE_NORMAL
- en: bakery
  prefs: []
  type: TYPE_NORMAL
- en: ball_washer
  prefs: []
  type: TYPE_NORMAL
- en: ballet
  prefs: []
  type: TYPE_NORMAL
- en: bandshell
  prefs: []
  type: TYPE_NORMAL
- en: bank
  prefs: []
  type: TYPE_NORMAL
- en: bank_construction
  prefs: []
  type: TYPE_NORMAL
- en: banquet_hall
  prefs: []
  type: TYPE_NORMAL
- en: bar
  prefs: []
  type: TYPE_NORMAL
- en: bar/food
  prefs: []
  type: TYPE_NORMAL
- en: barber
  prefs: []
  type: TYPE_NORMAL
- en: barbershop
  prefs: []
  type: TYPE_NORMAL
- en: bathroom
  prefs: []
  type: TYPE_NORMAL
- en: bbq
  prefs: []
  type: TYPE_NORMAL
- en: beauty
  prefs: []
  type: TYPE_NORMAL
- en: Beauty Services
  prefs: []
  type: TYPE_NORMAL
- en: bell_tower
  prefs: []
  type: TYPE_NORMAL
- en: bench
  prefs: []
  type: TYPE_NORMAL
- en: betting
  prefs: []
  type: TYPE_NORMAL
- en: bicycle_dirt jumping
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 65](img/index-387_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: bicycle_parking
  prefs: []
  type: TYPE_NORMAL
- en: bicycle_parking; bicycle_rental
  prefs: []
  type: TYPE_NORMAL
- en: bicycle_parking;bank
  prefs: []
  type: TYPE_NORMAL
- en: bicycle_rental
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: You can also spot some misuse of this OSM tag as people mistakenly put street
    names, business names, and so on instead of the amenity type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a list of common amenity types, you can check the OpenStreetMap wiki:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://wiki.openstreetmap.org/wiki/Key:amenity.](http://wiki.openstreetmap.org/wiki/Key:amenity)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filtering using boundaries**'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s try getting only the amenities that are at Montréal. The procedure
    is similar to what we did before. We will use one of the known predicates to filter
    objects by a geometry relationship, but this time the searches are powered by
    the database and spatial indexes, making them incredibly fast.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the *Geometry relationships* section in [Chapter 4,](index_split_001.html#p174)
    *Improving the App Search* *Capabilities* for a list of predicates.
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: Get Montreal object.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: montreal = GeoObject.objects.get(atype='canada',
  prefs: []
  type: TYPE_NORMAL
- en: tags__key='CDNAME',
  prefs: []
  type: TYPE_NORMAL
- en: tags__value='Montréal')
  prefs: []
  type: TYPE_NORMAL
- en: Filter tags whose POI is within Montreal.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: amenities = Tag.objects.filter(
  prefs: []
  type: TYPE_NORMAL
- en: key='amenity', geo_object__geom__within=montreal.geom)
  prefs: []
  type: TYPE_NORMAL
- en: Filter only the distinct values.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: amenities = amenities.distinct('value')
  prefs: []
  type: TYPE_NORMAL
- en: Get the list of 'values'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: amenity_values = amenities.values_list('value')
  prefs: []
  type: TYPE_NORMAL
- en: 'for item in amenity_values:'
  prefs: []
  type: TYPE_NORMAL
- en: print(item[0])
  prefs: []
  type: TYPE_NORMAL
- en: Here I separated each part into a different statement to facilitate understanding.
  prefs: []
  type: TYPE_NORMAL
- en: It doesn’t make any difference if you put everything together or keep it separated,
    Django query sets are lazy (somewhat like what we did in [Chapter 7,](index_split_002.html#p312)
    *Extract Information from* *Raster Data*), and they are evaluated only when a
    value is needed. This means that Django will only hit the database once when we
    start iterating through the values (for item in amenity_values).
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Run the code. You should get a more modest list of amenity types: arts_centre'
  prefs: []
  type: TYPE_NORMAL
- en: atm
  prefs: []
  type: TYPE_NORMAL
- en: audiologist
  prefs: []
  type: TYPE_NORMAL
- en: bakery
  prefs: []
  type: TYPE_NORMAL
- en: bank
  prefs: []
  type: TYPE_NORMAL
- en: bar
  prefs: []
  type: TYPE_NORMAL
- en: bbq
  prefs: []
  type: TYPE_NORMAL
- en: bench
  prefs: []
  type: TYPE_NORMAL
- en: bicycle_parking
  prefs: []
  type: TYPE_NORMAL
- en: bicycle_rental
  prefs: []
  type: TYPE_NORMAL
- en: billboard
  prefs: []
  type: TYPE_NORMAL
- en: bureau_de_change
  prefs: []
  type: TYPE_NORMAL
- en: bus_station
  prefs: []
  type: TYPE_NORMAL
- en: cafe
  prefs: []
  type: TYPE_NORMAL
- en: car_rental
  prefs: []
  type: TYPE_NORMAL
- en: car_repair
  prefs: []
  type: TYPE_NORMAL
- en: car_sharing
  prefs: []
  type: TYPE_NORMAL
- en: car_wash
  prefs: []
  type: TYPE_NORMAL
- en: childcare
  prefs: []
  type: TYPE_NORMAL
- en: cinema
  prefs: []
  type: TYPE_NORMAL
- en: city_hall
  prefs: []
  type: TYPE_NORMAL
- en: clinic
  prefs: []
  type: TYPE_NORMAL
- en: clock
  prefs: []
  type: TYPE_NORMAL
- en: college
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s find out how many cinemas (movie theatres) we can find in Montreal:
    2\. Edit the if __name__ == ''__main__'': block:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: montreal = GeoObject.objects.get(atype='canada',
  prefs: []
  type: TYPE_NORMAL
- en: tags__key='CDNAME',
  prefs: []
  type: TYPE_NORMAL
- en: tags__value='Montréal')
  prefs: []
  type: TYPE_NORMAL
- en: cinemas = GeoObject.objects.filter(atype='poi',
  prefs: []
  type: TYPE_NORMAL
- en: geom__within=montreal.geom,
  prefs: []
  type: TYPE_NORMAL
- en: tags__key='amenity',
  prefs: []
  type: TYPE_NORMAL
- en: tags__value='cinema')
  prefs: []
  type: TYPE_NORMAL
- en: print("{} cinemas.".format(cinemas.count()))
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Note that we are using the count method instead of Python’s len function. This
    makes the counting happen on the database and only the output value is returned.
  prefs: []
  type: TYPE_NORMAL
- en: This is much faster than getting all the objects and then counting with Python.
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Now run it and check the output:'
  prefs: []
  type: TYPE_NORMAL
- en: 16 cinemas.
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we explored introductory concepts about code efficiency and
    how to measure it. Equipped with the right tools, we optimized our code to make
    it run faster.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of storing data into Python objects, we turned to SQL databases. We
    thereby enhanced our app with state-of-the-art filtering and got information in
    an efficient way.
  prefs: []
  type: TYPE_NORMAL
- en: Later, we came across a large amount of data that was impossible to import with
    ordinary computers. We optimized our code again, making it memory-efficient and
    stable, allowing us to import this data. Finally, we queried the data, testing
    the new feature capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will face similar speed and memory problems but with
    images (raster) data. This will require us to develop new and creative solutions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter 9\. Processing Big Images**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Processing satellite images (or other remote sensing data) is a computational
    challenge for two reasons: normally, the images are big (many megabytes or gigabytes)
    and many images are needed in combination to produce the desired information.'
  prefs: []
  type: TYPE_NORMAL
- en: Opening and processing many big images can consume a lot of computer memory.
    This condition sets a tight limit on what the user can do before running out of
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on how to perform sustainable image processing
    and how to open and make calculations with many big images while keeping the memory
    consumption low with efficient code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to satellite images and Landsat 8 data
  prefs: []
  type: TYPE_NORMAL
- en: How to select and download Landsat 8 data
  prefs: []
  type: TYPE_NORMAL
- en: What happens to the computer memory when we work with images?
  prefs: []
  type: TYPE_NORMAL
- en: How to read images in chunks
  prefs: []
  type: TYPE_NORMAL
- en: What are Python iterators and generators?
  prefs: []
  type: TYPE_NORMAL
- en: How to iterate through an image
  prefs: []
  type: TYPE_NORMAL
- en: How to create color compositions with the new techniques
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 66](img/index-394_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Working with satellite images**'
  prefs: []
  type: TYPE_NORMAL
- en: Satellite images are a form of remote sensing data. They are composed of the
    information collected by satellites and are made available to users as image files.
    Just like the digital elevation model that we worked on before, these images are
    made of pixels, each one representing the value of a given attribute for a given
    geographic extent.
  prefs: []
  type: TYPE_NORMAL
- en: These images can be used to visualize features on Earth using real colors or
    they can be used to identify a variety of characteristics using parts of the light
    spectrum invisible to the human eyes.
  prefs: []
  type: TYPE_NORMAL
- en: In order to follow the examples, we will use images from the Landsat 8 satellite.
    They are available for free on the Internet. Let’s take a look at some of the
    characteristics of this satellite.
  prefs: []
  type: TYPE_NORMAL
- en: 'Landsat 8 carries two instruments: the **Operational Land Imager** (**OLI**)
    and the **Thermal Infrared Sensor** (**TIRS**).'
  prefs: []
  type: TYPE_NORMAL
- en: These sensors can collect data in a total of 10 different bands processed in
    a resolution of 4096 possible levels (12-bit). The data is encoded into 16-bit
    TIFF images scaled to 55000
  prefs: []
  type: TYPE_NORMAL
- en: possible values.
  prefs: []
  type: TYPE_NORMAL
- en: '**Wavelength**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resolution**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bands**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Common uses**'
  prefs: []
  type: TYPE_NORMAL
- en: '**(micrometers)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**(meters)**'
  prefs: []
  type: TYPE_NORMAL
- en: Band 1—Coastal
  prefs: []
  type: TYPE_NORMAL
- en: Shallow coastal water studies and estimation of the
  prefs: []
  type: TYPE_NORMAL
- en: 0.43 - 0.45
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  prefs: []
  type: TYPE_NORMAL
- en: aerosol
  prefs: []
  type: TYPE_NORMAL
- en: concentration of aerosols in the atmosphere
  prefs: []
  type: TYPE_NORMAL
- en: Band 2—Blue
  prefs: []
  type: TYPE_NORMAL
- en: 0.45 - 0.51
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  prefs: []
  type: TYPE_NORMAL
- en: Visible blue channel, distinguish soil from vegetation
  prefs: []
  type: TYPE_NORMAL
- en: Band 3—Green
  prefs: []
  type: TYPE_NORMAL
- en: 0.53 - 0.59
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  prefs: []
  type: TYPE_NORMAL
- en: Visible green channel
  prefs: []
  type: TYPE_NORMAL
- en: Band 4—Red
  prefs: []
  type: TYPE_NORMAL
- en: 0.64 - 0.67
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  prefs: []
  type: TYPE_NORMAL
- en: Visible red channel
  prefs: []
  type: TYPE_NORMAL
- en: Band 5—Near Infrared 0.85 - 0.88
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  prefs: []
  type: TYPE_NORMAL
- en: Biomass estimation
  prefs: []
  type: TYPE_NORMAL
- en: (NIR)
  prefs: []
  type: TYPE_NORMAL
- en: Band 6—SWIR 1
  prefs: []
  type: TYPE_NORMAL
- en: 1.57 - 1.65
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  prefs: []
  type: TYPE_NORMAL
- en: Soil moisture
  prefs: []
  type: TYPE_NORMAL
- en: Band 7—SWIR 2
  prefs: []
  type: TYPE_NORMAL
- en: 2.11 - 2.29
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  prefs: []
  type: TYPE_NORMAL
- en: Soil moisture
  prefs: []
  type: TYPE_NORMAL
- en: Band 8—Panchromatic 0.50 - 0.68
  prefs: []
  type: TYPE_NORMAL
- en: '15'
  prefs: []
  type: TYPE_NORMAL
- en: Sharper resolution
  prefs: []
  type: TYPE_NORMAL
- en: Band 9—Cirrus
  prefs: []
  type: TYPE_NORMAL
- en: 1.36 - 1.38
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  prefs: []
  type: TYPE_NORMAL
- en: Detection of cirrus cloud contamination
  prefs: []
  type: TYPE_NORMAL
- en: Band 10—Thermal
  prefs: []
  type: TYPE_NORMAL
- en: 10.60 - 11.19
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  prefs: []
  type: TYPE_NORMAL
- en: Thermal mapping and estimating soil moisture
  prefs: []
  type: TYPE_NORMAL
- en: Infrared (TIRS) 1
  prefs: []
  type: TYPE_NORMAL
- en: Band 11—Thermal
  prefs: []
  type: TYPE_NORMAL
- en: 11.50 - 12.51
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  prefs: []
  type: TYPE_NORMAL
- en: Thermal mapping and estimating soil moisture
  prefs: []
  type: TYPE_NORMAL
- en: Infrared (TIRS) 2
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 67](img/index-396_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Getting Landsat 8 images**'
  prefs: []
  type: TYPE_NORMAL
- en: Landsat 8 images are available freely on the Internet and there are some nice
    tools to find and download these images. For the book, we will use **U.S Geological
    Survey** (**USGS**) EarthExplorer. It’s a web app packed with resources to obtain
    geographic data.
  prefs: []
  type: TYPE_NORMAL
- en: In order to follow the book’s examples, we will download data for the same Montreal
    (Quebec, Canada) area that we obtained the points of interest of the previous
    chapter. This data is included in the book’s sample data and you can skip these
    steps if you wish.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will open the website and select our region of interest as follows:
    1\. Go to the [http://earthexplorer.usgs.gov/](http://earthexplorer.usgs.gov/)
    website. You will see a map, some options at the top, and a panel with search
    tools on the left-hand side: 2\. At the top right, you will see a **Login**/**Register**
    button. If you don’t have an account, click on **Register** and create a new one.
    Otherwise, log in to the system.'
  prefs: []
  type: TYPE_NORMAL
- en: 3\. The next step is to search for the location of interest. You can search
    by entering Montreal in the box and clicking on **Show**. A list will appear with
    the search results.
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Montreal** on the list. A marker will appear and the coordinates
    will be set.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Click on the **Data Sets** button to show the available data for this coordinate.
  prefs: []
  type: TYPE_NORMAL
- en: 5\. On the next screen, expand the **Landsat Archive** item, select **L8 OLI/TIRS**,
    and click on the **Additional Criteria** button.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 68](img/index-397_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 69](img/index-397_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 6\. Now, let’s make sure that we get images with little cloud cover. Use the
    scroll bar to find the **Cloud Cover** item and select **Less than 10%**. Now,
    click on **Results** to see what was found.
  prefs: []
  type: TYPE_NORMAL
- en: '7\. A new tab will open showing the results. Note that each item contains a
    small toolbar with a set of icons. Click on the feet icon of some of the images
    to see their extent on the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '8\. For our examples, we need just one data set: one for path 14, row 28\.
    Find the data'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 70](img/index-398_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: for this set of rows and columns (you can use an image from any date; it’s up
    to you) and then click on the **Download Options** button on the mini toolbar
    (it’s the icon with a green arrow pointing to a hard drive).
  prefs: []
  type: TYPE_NORMAL
- en: 9\. A window will pop up with the download options. Click on **Download Level
    1**
  prefs: []
  type: TYPE_NORMAL
- en: '**GeoTIFF Data Product**.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: USGS has an application that can manage and resume large downloads. Take a look
    at [https://lta.cr.usgs.gov/BulkDownloadApplication](https://lta.cr.usgs.gov/BulkDownloadApplication)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 10\. After the download is complete, create a new folder in your data folder
    and name it landsat. Unpack all the images in this folder.
  prefs: []
  type: TYPE_NORMAL
- en: Each package contains 12 .tif images and a text file containing the metadata.
    Each image name is composed of the row, column, date, and band of the image. Note
    that the band 8
  prefs: []
  type: TYPE_NORMAL
- en: image (B8) is much larger than the other images. This is because it has a better
    resolution.
  prefs: []
  type: TYPE_NORMAL
- en: BQA is a quality assessment band. It contains information on the quality of
    each of the pixels in the image. We will see more about this band later.
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory and images**'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will check how opening images affects random access memory (RAM)
    usage. In our first example, we will try to open band 8 of the Landsat data using
    the same technique as before:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Prepare the working environment for Chapter 9 by making a copy of the Chapter8
  prefs: []
  type: TYPE_NORMAL
- en: folder in your geopy project. Name the copied folder as Chapter9\.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. In Chapter9 folder, open the experiments folder and delete all the files
    inside it.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. In the experiments folder, create a new Python file and name it images.py.
    Open it for editing.
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Now type the following code in this file:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import cv2 as cv
  prefs: []
  type: TYPE_NORMAL
- en: 'def open_image(img_path):'
  prefs: []
  type: TYPE_NORMAL
- en: image = cv.imread(img_path)
  prefs: []
  type: TYPE_NORMAL
- en: print(type(image))
  prefs: []
  type: TYPE_NORMAL
- en: raw_input("Press any key.")
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: image_path = "../../data/landsat/LC80140282015270LGN00_B8.TIF"
  prefs: []
  type: TYPE_NORMAL
- en: open_image(image_path)
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Run the code. Press *Alt* + *Shift* + *F10* and select the images on the
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 6\. Depending on your computer’s memory and the OpenCV version, you may succeed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Otherwise, you will see this nice exception:'
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenCV Error: Insufficient memory (Failed to allocate 723585188 bytes) in cv::OutOfMemoryError,
    file ..\..\..\opencv-2.4.11\modules\core\src\alloc.cpp, line 52'
  prefs: []
  type: TYPE_NORMAL
- en: 'Traceback (most recent call last):'
  prefs: []
  type: TYPE_NORMAL
- en: File "Chapter9/experiments/images.py", line 14, in <module> open_image(image_path)
  prefs: []
  type: TYPE_NORMAL
- en: File " experiments/images.py", line 6, in open_image image = cv.imread(img_path)
  prefs: []
  type: TYPE_NORMAL
- en: 'cv2.error: ..\..\..\opencv-2.4.11\modules\core\src\alloc.cpp:52: error: (-4)
    Failed to allocate 723585188 bytes in function'
  prefs: []
  type: TYPE_NORMAL
- en: cv::OutOfMemoryError
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 1
  prefs: []
  type: TYPE_NORMAL
- en: This happens because we are using the 32-bit version of the Python interpreter
    (that is, x86) and the program fails to allocate enough memory to open the whole
    image at once.
  prefs: []
  type: TYPE_NORMAL
- en: 7\. Let’s try with a band with a smaller file size. Change the filename to match
    band 1 of any of the images. It could be LC80140282015270LGN00_B1.TIF.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 71](img/index-401_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '8\. Run the code again. You should see a prompt asking you to press any key:'
  prefs: []
  type: TYPE_NORMAL
- en: <type 'numpy.ndarray'>
  prefs: []
  type: TYPE_NORMAL
- en: Press any key.
  prefs: []
  type: TYPE_NORMAL
- en: This was done on purpose in order to halt the program execution while the image
    is still in the memory.
  prefs: []
  type: TYPE_NORMAL
- en: 9\. Now, if you are using Windows, press *Ctrl* + *Alt* + *Del* and open the
    task manager. If you are using Ubuntu Linux, open the system monitor.
  prefs: []
  type: TYPE_NORMAL
- en: '10\. Look for the Python process and see how much memory it’s using. You should
    see something as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: That’s OK. The image has opened and isn’t consuming much memory.
  prefs: []
  type: TYPE_NORMAL
- en: 11\. Press any key on the console to finish program execution.
  prefs: []
  type: TYPE_NORMAL
- en: '12\. Now, let’s simulate opening more than one image and see what happens.
    Change your open_image function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def open_image(img_path):'
  prefs: []
  type: TYPE_NORMAL
- en: image = cv.imread(img_path)
  prefs: []
  type: TYPE_NORMAL
- en: image2 = cv.imread(img_path)
  prefs: []
  type: TYPE_NORMAL
- en: image3 = cv.imread(img_path)
  prefs: []
  type: TYPE_NORMAL
- en: image4 = cv.imread(img_path)
  prefs: []
  type: TYPE_NORMAL
- en: image5 = cv.imread(img_path)
  prefs: []
  type: TYPE_NORMAL
- en: raw_input("Press any key.")
  prefs: []
  type: TYPE_NORMAL
- en: 13\. Run the code again and check the memory used by Python. For me, it’s 872
    MB.
  prefs: []
  type: TYPE_NORMAL
- en: 14\. Press any key in the console to exit the program and release the memory.
  prefs: []
  type: TYPE_NORMAL
- en: '15\. For our last test, open the image one more time to see what happens: def
    open_image(img_path):'
  prefs: []
  type: TYPE_NORMAL
- en: image = cv.imread(img_path)
  prefs: []
  type: TYPE_NORMAL
- en: image2 = cv.imread(img_path)
  prefs: []
  type: TYPE_NORMAL
- en: image3 = cv.imread(img_path)
  prefs: []
  type: TYPE_NORMAL
- en: image4 = cv.imread(img_path)
  prefs: []
  type: TYPE_NORMAL
- en: image5 = cv.imread(img_path)
  prefs: []
  type: TYPE_NORMAL
- en: image6 = cv.imread(img_path)
  prefs: []
  type: TYPE_NORMAL
- en: raw_input("Press any key.")
  prefs: []
  type: TYPE_NORMAL
- en: '16\. Run the code and see the result:'
  prefs: []
  type: TYPE_NORMAL
- en: 'cv2.error: D:\Build\OpenCV\OpenCV-'
  prefs: []
  type: TYPE_NORMAL
- en: '2.4.11\modules//python//src2//cv2.cpp:201: error: (-2) The numpy array of typenum=2,
    ndims=3 can not be created in function'
  prefs: []
  type: TYPE_NORMAL
- en: NumpyAllocator::allocate
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 1
  prefs: []
  type: TYPE_NORMAL
- en: Again, the program failed to allocate enough memory to open the image.
  prefs: []
  type: TYPE_NORMAL
- en: The point of these experiments was to show that, while processing images, there
    is a good chance of facing memory problems. With band 8, it was even impossible
    to begin processing it because we couldn’t open it.
  prefs: []
  type: TYPE_NORMAL
- en: With band 1, we simulated a common situation where we wanted to perform a calculation
    involving many images and this calculation had sub-steps. The memory consumption
    would escalate until the program crashes.
  prefs: []
  type: TYPE_NORMAL
- en: The maximum amount of memory that Python is allowed to use is limited by the
    operation system and the Python version (64 or 32 bits). Probably, if you are
    running the 64 bits version of Python, or using Linux, you won’t face any error
    during the examples.
  prefs: []
  type: TYPE_NORMAL
- en: Independent of being able to run this program or not, these examples show a
    code whose success is tied to the image size. Even while running a 64-bit Python
    on a Linux machine with 32 GB of RAM, the program may run out of memory if the
    images are too big and the process is complex. Remember that some satellite images
    could be pretty large.
  prefs: []
  type: TYPE_NORMAL
- en: '**Processing images in chunks**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will change the code, so we can open images of any size. The principle is
    the same as the one we applied in the previous chapter: in order to read and import
    an arbitrary number of points, we made the program read, import, and release the
    memory after each small set of points.'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of reading points, we will read a small piece from the image, make some
    calculations, write the output on the disk, and release the memory before repeating
    the process with the next piece.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using GDAL to open images**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The process of reading selected regions of a given image is no easy task. Many
    factors are relevant, such as how the data is encoded in the image, the type of
    data, how to read the data, and so on. Fortunately, GDAL is equipped with great
    functions and methods that abstract most of the low-level process. Let’s experiment
    with it: 1\. In the images.py file, import GDAL at the beginning of the file:
    import gdal'
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Now, create a new function to open the Landsat band 8 using GDAL: def open_image_gdal(img_path):'
  prefs: []
  type: TYPE_NORMAL
- en: dataset = gdal.Open(img_path)
  prefs: []
  type: TYPE_NORMAL
- en: cols = dataset.RasterXSize
  prefs: []
  type: TYPE_NORMAL
- en: rows = dataset.RasterYSize
  prefs: []
  type: TYPE_NORMAL
- en: 'print "Image dimensions: {} x {}px".format(cols, rows) raw_input("Press any
    key.")'
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Change the if __name__ == ''__main__'': block to use the new function:
    if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: image_path = "../../data/landsat/LC80140282015270LGN00_B8.TIF"
  prefs: []
  type: TYPE_NORMAL
- en: open_image_gdal(image_path)
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Run your code and check the output:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Image dimensions: 15401 x 15661px'
  prefs: []
  type: TYPE_NORMAL
- en: Press any key.
  prefs: []
  type: TYPE_NORMAL
- en: We simply opened the image and printed its dimensions. You should have noticed
    that the code ran incredibly fast and with no errors. If you wish, you can check
    how much memory the Python process is using (using the Task Manager or the system
    monitor).
  prefs: []
  type: TYPE_NORMAL
- en: What happened this time is that the data wasn’t read when the file was opened.
    GDAL
  prefs: []
  type: TYPE_NORMAL
- en: only got the information about the image, but the actual data wasn’t touched.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try reading a few pixels from this image:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Press any key to exit the program.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Edit the function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def open_image_gdal(img_path):'
  prefs: []
  type: TYPE_NORMAL
- en: dataset = gdal.Open(img_path)
  prefs: []
  type: TYPE_NORMAL
- en: cols = dataset.RasterXSize
  prefs: []
  type: TYPE_NORMAL
- en: rows = dataset.RasterYSize
  prefs: []
  type: TYPE_NORMAL
- en: 'print "Image dimensions: {} x {}px".format(cols, rows) middle_col = int(cols
    / 2)'
  prefs: []
  type: TYPE_NORMAL
- en: middle_row = int(rows / 2)
  prefs: []
  type: TYPE_NORMAL
- en: array = dataset.ReadAsArray(xoff=middle_col - 50,
  prefs: []
  type: TYPE_NORMAL
- en: yoff=middle_row - 50,
  prefs: []
  type: TYPE_NORMAL
- en: xsize=100, ysize=100)
  prefs: []
  type: TYPE_NORMAL
- en: print(array)
  prefs: []
  type: TYPE_NORMAL
- en: print(array.shape)
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Run the code again and check the output: Image dimensions: 15401 x 15661px'
  prefs: []
  type: TYPE_NORMAL
- en: '[[8826 8821 8846…, 8001 7965 7806]'
  prefs: []
  type: TYPE_NORMAL
- en: '[8842 8838 8853…, 7982 7931 7676]'
  prefs: []
  type: TYPE_NORMAL
- en: '[8844 8860 8849…, 8050 7958 7693]'
  prefs: []
  type: TYPE_NORMAL
- en: '...,'
  prefs: []
  type: TYPE_NORMAL
- en: '[7530 7451 7531…, 7471 7457 7494]'
  prefs: []
  type: TYPE_NORMAL
- en: '[7605 7620 7555…, 7533 7519 7610]'
  prefs: []
  type: TYPE_NORMAL
- en: '[7542 7542 7499…, 7620 7947 7728]]'
  prefs: []
  type: TYPE_NORMAL
- en: (100, 100)
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: We just read a chunk of 100 x 100 pixels from the centre of the image. Again,
    the code ran fast and little memory was consumed.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s try something fancier. Read a region from the image and save it on
    the disk, so we can visualize it.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. First, delete all the files from the Chapter9/output folder. We will save
    our image here.
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Add the adjust_values function and edit the code of the open_image_gdal
    function: def adjust_values(array, img_range=None):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Projects a range of values into a grayscale image.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param array: A Numpy array containing the image data.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param img_range: specified range of values or None to use'
  prefs: []
  type: TYPE_NORMAL
- en: the range of the image (minimum and maximum).
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: 'if img_range:'
  prefs: []
  type: TYPE_NORMAL
- en: min = img_range[0]
  prefs: []
  type: TYPE_NORMAL
- en: max = img_range[1]
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: min = array.min()
  prefs: []
  type: TYPE_NORMAL
- en: max = array.max()
  prefs: []
  type: TYPE_NORMAL
- en: interval = max - min
  prefs: []
  type: TYPE_NORMAL
- en: factor = 256.0 / interval
  prefs: []
  type: TYPE_NORMAL
- en: output = array * factor
  prefs: []
  type: TYPE_NORMAL
- en: return output
  prefs: []
  type: TYPE_NORMAL
- en: 'def open_image_gdal(img_path):'
  prefs: []
  type: TYPE_NORMAL
- en: dataset = gdal.Open(img_path)
  prefs: []
  type: TYPE_NORMAL
- en: cols = dataset.RasterXSize
  prefs: []
  type: TYPE_NORMAL
- en: rows = dataset.RasterYSize
  prefs: []
  type: TYPE_NORMAL
- en: 'print "Image dimensions: {} x {}px".format(cols, rows) middle_col = int(cols
    / 2)'
  prefs: []
  type: TYPE_NORMAL
- en: middle_row = int(rows / 2)
  prefs: []
  type: TYPE_NORMAL
- en: array = dataset.ReadAsArray(xoff=middle_col - 50,
  prefs: []
  type: TYPE_NORMAL
- en: yoff=middle_row - 50,
  prefs: []
  type: TYPE_NORMAL
- en: xsize=1000, ysize=1000)
  prefs: []
  type: TYPE_NORMAL
- en: print(array.shape)
  prefs: []
  type: TYPE_NORMAL
- en: greyscale_img = adjust_values(array)
  prefs: []
  type: TYPE_NORMAL
- en: cv.imwrite('../output/landsat_chunk.jpg', greyscale_img)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 72](img/index-407_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The adjust_values function is the same that we used before to adjust the gray
    values of the elevation data in order to visualize it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are using OpenCV to write the JPG image for two reasons: by default, GDAL'
  prefs: []
  type: TYPE_NORMAL
- en: can’t write JPG on Windows, and OpenCV is easier to use in this simple case.
  prefs: []
  type: TYPE_NORMAL
- en: '6\. Run the code and open the image in the output folder. If you are using
    the same Landsat data as I am, you should see this beautiful image of Quebec’s
    rural area:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 73](img/index-408_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Iterating through the whole image**'
  prefs: []
  type: TYPE_NORMAL
- en: We saw that we can read specific parts of an image. With this concept, we can
    process the whole image one piece at a time. By doing this, it’s possible to make
    calculations that involve many bands. We just need to read the same region of
    each band, obtain the results, write them, release the memory, and move to the
    next piece.
  prefs: []
  type: TYPE_NORMAL
- en: The most obvious way to iterate through something in Python is to use a for
    loop. We can iterate through the elements on a list, characters on a string, keys
    on a dictionary, features on a vector layer, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '*The preceding image is taken from http://nvie.com/posts/iterators-vs-generators/*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have heard the concepts of iterables, iterators, and generators. **Iterables**,
    like a list, become iterators when they are used in a for loop. But we don’t want
    to create a list of image chunks, because in order to do this, we would need to
    read the whole image upfront to produce the list. That’s when a special feature
    of iterators comes into light: they are lazy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An **iterator** is nothing more than a class with specific magic methods. At
    every loop, this class next() method is called and a new value is returned. Python
    has handy tools to create iterators and that’s the point when we are going to
    see what are generators. Let’s write some code:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. In your images.py file, add a new function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def create_image_generator(dataset):'
  prefs: []
  type: TYPE_NORMAL
- en: cols = dataset.RasterXSize
  prefs: []
  type: TYPE_NORMAL
- en: rows = dataset.RasterYSize
  prefs: []
  type: TYPE_NORMAL
- en: 'for row_index in xrange(0, rows):'
  prefs: []
  type: TYPE_NORMAL
- en: yield dataset.ReadAsArray(xoff=0, yoff=row_index,
  prefs: []
  type: TYPE_NORMAL
- en: xsize=cols, ysize=1)
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Now edit the if __name__ == ''__main__'': block: if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: base_path = "../../data/landsat"
  prefs: []
  type: TYPE_NORMAL
- en: img_name = "LC80140282015270LGN00_B8.TIF"
  prefs: []
  type: TYPE_NORMAL
- en: img_path = os.path.join(base_path, img_name)
  prefs: []
  type: TYPE_NORMAL
- en: dataset = gdal.Open(img_path)
  prefs: []
  type: TYPE_NORMAL
- en: img_generator = create_image_generator(dataset)
  prefs: []
  type: TYPE_NORMAL
- en: print(img_generator)
  prefs: []
  type: TYPE_NORMAL
- en: print(type(img_generator))
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Run the code and check the output:'
  prefs: []
  type: TYPE_NORMAL
- en: <generator object create_image_generator at 0x0791D968>
  prefs: []
  type: TYPE_NORMAL
- en: <type 'generator'>
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: Our create_image_generator function has a special behavior because of the yield
    word in the for loop. When we iterate through the generator object created by
    this function, the yield statement halts the function execution and returns a
    value at each loop. In our case, the generator/iterator will return one image
    row at a time.
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Just to check whether it works, try this in the if __name__ == ''__main__'':
    block: if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: base_path = "../../data/landsat"
  prefs: []
  type: TYPE_NORMAL
- en: img_name = "LC80140282015270LGN00_B8.TIF"
  prefs: []
  type: TYPE_NORMAL
- en: img_path = os.path.join(base_path, img_name)
  prefs: []
  type: TYPE_NORMAL
- en: dataset = gdal.Open(img_path)
  prefs: []
  type: TYPE_NORMAL
- en: img_generator = create_image_generator(dataset)
  prefs: []
  type: TYPE_NORMAL
- en: print(img_generator)
  prefs: []
  type: TYPE_NORMAL
- en: print(type(img_generator))
  prefs: []
  type: TYPE_NORMAL
- en: 'for row in img_generator:'
  prefs: []
  type: TYPE_NORMAL
- en: print(row)
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Run the code and look at the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '[[0 0 0…, 0 0 0]]'
  prefs: []
  type: TYPE_NORMAL
- en: '[[0 0 0…, 0 0 0]]'
  prefs: []
  type: TYPE_NORMAL
- en: '[[0 0 0…, 0 0 0]]'
  prefs: []
  type: TYPE_NORMAL
- en: '[[0 0 0…, 0 0 0]]'
  prefs: []
  type: TYPE_NORMAL
- en: '[[0 0 0…, 0 0 0]]'
  prefs: []
  type: TYPE_NORMAL
- en: '[[0 0 0…, 0 0 0]]'
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: What you see is Python printing a lot of arrays, each containing the data of
    one row. You see zeros because the borders of the image are black and all the
    other values are
  prefs: []
  type: TYPE_NORMAL
- en: 'suppressed by NumPy to fit the console. Let’s make a few tests to explore the
    characteristics of iterators:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Now, try this concept test just to check another characteristic of iterators:
    if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: base_path = "../../data/landsat"
  prefs: []
  type: TYPE_NORMAL
- en: base_path = "C:/Users/Pablo/Desktop/landsat"
  prefs: []
  type: TYPE_NORMAL
- en: img_name = "LC80140282015270LGN00_B8.TIF"
  prefs: []
  type: TYPE_NORMAL
- en: img_path = os.path.join(base_path, img_name)
  prefs: []
  type: TYPE_NORMAL
- en: dataset = gdal.Open(img_path)
  prefs: []
  type: TYPE_NORMAL
- en: img_generator = create_image_generator(dataset)
  prefs: []
  type: TYPE_NORMAL
- en: print(img_generator[4])
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Run the code and an error will be raised:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Traceback (most recent call last):'
  prefs: []
  type: TYPE_NORMAL
- en: File "Chapter9/experiments/images.py", line 98, in <module> print(img_generator[4])
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeError: ''generator'' object has no attribute ''__getitem__'''
  prefs: []
  type: TYPE_NORMAL
- en: Remember that iterators are lazy and do not behave like sequences (for example,
    lists). The elements are calculated one at a time and we can’t get the 5th element
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Now, to check whether it really works, let’s make a copy of the image one
    line at a time. Create this new function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def copy_image(src_image, dst_image):'
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: os.remove(dst_image)
  prefs: []
  type: TYPE_NORMAL
- en: 'except OSError:'
  prefs: []
  type: TYPE_NORMAL
- en: pass
  prefs: []
  type: TYPE_NORMAL
- en: src_dataset = gdal.Open(src_image)
  prefs: []
  type: TYPE_NORMAL
- en: cols = src_dataset.RasterXSize
  prefs: []
  type: TYPE_NORMAL
- en: rows = src_dataset.RasterYSize
  prefs: []
  type: TYPE_NORMAL
- en: driver = gdal.GetDriverByName('GTiff')
  prefs: []
  type: TYPE_NORMAL
- en: new_dataset = driver.Create(dst_image, cols, rows,
  prefs: []
  type: TYPE_NORMAL
- en: eType=gdal.GDT_UInt16)
  prefs: []
  type: TYPE_NORMAL
- en: gdal_array.CopyDatasetInfo(src_dataset, new_dataset)
  prefs: []
  type: TYPE_NORMAL
- en: band = new_dataset.GetRasterBand(1)
  prefs: []
  type: TYPE_NORMAL
- en: for index, img_row in enumerate(
  prefs: []
  type: TYPE_NORMAL
- en: 'create_image_generator(src_dataset)):'
  prefs: []
  type: TYPE_NORMAL
- en: band.WriteArray(xoff=0, yoff=index, array=img_row)
  prefs: []
  type: TYPE_NORMAL
- en: In order to copy the image, we created a new dataset using GDAL’s GTiff driver.
    The new dataset has the same number of rows, columns, and data types (an unsigned
    16-bit integer).
  prefs: []
  type: TYPE_NORMAL
- en: To ensure that the copy has the same projection information as the source, we
    used
  prefs: []
  type: TYPE_NORMAL
- en: the function gdal_array.CopyDatasetInfo, thus saving us a lot of code.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, using our generator, we read one line at a time and wrote it to the
    output band.
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Edit the if __name__ == ''__main__'': block and run the following code
    to test it: if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: base_path = "../../data/landsat"
  prefs: []
  type: TYPE_NORMAL
- en: img_name = "LC80140282015270LGN00_B8.TIF"
  prefs: []
  type: TYPE_NORMAL
- en: img_path = os.path.join(base_path, img_name)
  prefs: []
  type: TYPE_NORMAL
- en: img_copy = "../output/B8_copy.TIF"
  prefs: []
  type: TYPE_NORMAL
- en: copy_image(img_path, img_copy)
  prefs: []
  type: TYPE_NORMAL
- en: Open both of the images (the original and the copy) just to check whether they
    look the same.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating image compositions**'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the basics of iterating through the image, which allows us
    to process many bands together without running out of memory, let’s produce some
    fancier results.
  prefs: []
  type: TYPE_NORMAL
- en: '**True color compositions**'
  prefs: []
  type: TYPE_NORMAL
- en: Since we have Landsat’s red, green, and blue bands, we can create an image with
    *true* *colors*. This means an image with colors similar to what they would be
    if we were directly observing the scene (for example, the grass is green and the
    soil is brown). To do this, we will explore a little bit more of Python’s iterators.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Landsat 8 RGB bands are respectively bands 4, 3, and 2\. Following the
    concept that we want to automate tasks and processes, we won’t repeat the commands
    for each one of the bands. We will program Python to do this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Edit your imports at the beginning of the file to be as follows: import
    os'
  prefs: []
  type: TYPE_NORMAL
- en: import cv2 as cv
  prefs: []
  type: TYPE_NORMAL
- en: import itertools
  prefs: []
  type: TYPE_NORMAL
- en: from osgeo import gdal, gdal_array
  prefs: []
  type: TYPE_NORMAL
- en: import numpy as np
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Now add this new function. It will prepare the bands’ paths for us: def
    compose_band_path(base_path, base_name, band_number):'
  prefs: []
  type: TYPE_NORMAL
- en: return os.path.join(
  prefs: []
  type: TYPE_NORMAL
- en: base_path, base_name) + str(band_number) + ".TIF"
  prefs: []
  type: TYPE_NORMAL
- en: '3\. To check the purpose of this function and itertools we imported, edit the
    if __name__ == ''__main__'': block with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: base_path = "../../data/landsat"
  prefs: []
  type: TYPE_NORMAL
- en: base_name = 'LC80140282015270LGN00_B'
  prefs: []
  type: TYPE_NORMAL
- en: bands_numbers = [4, 3, 2]
  prefs: []
  type: TYPE_NORMAL
- en: bands = itertools.imap(
  prefs: []
  type: TYPE_NORMAL
- en: compose_band_path,
  prefs: []
  type: TYPE_NORMAL
- en: itertools.repeat(base_path),
  prefs: []
  type: TYPE_NORMAL
- en: itertools.repeat(base_name),
  prefs: []
  type: TYPE_NORMAL
- en: bands_numbers)
  prefs: []
  type: TYPE_NORMAL
- en: print(bands)
  prefs: []
  type: TYPE_NORMAL
- en: 'for item in bands:'
  prefs: []
  type: TYPE_NORMAL
- en: print(item)
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Now run the code and check the results:'
  prefs: []
  type: TYPE_NORMAL
- en: <itertools.imap object at 0x02DE9510>
  prefs: []
  type: TYPE_NORMAL
- en: ../../data/landsat/LC80140282015270LGN00_B4.TIF
  prefs: []
  type: TYPE_NORMAL
- en: ../../data/landsat/LC80140282015270LGN00_B3.TIF
  prefs: []
  type: TYPE_NORMAL
- en: ../../data/landsat/LC80140282015270LGN00_B2.TIF
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: The compose band path simply joins the base path, the name of the band, and
    the band number in order to output a band filename with its path.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of calling the function in a for loop and appending the results to a
    list, we used the itertools.imap function. This function takes another function
    as the first argument and any iterables as the other arguments. It creates an
    iterator that will call the function with the arguments at each iteration. The
    itertools.repeat function is responsible for repeating a given value infinite
    times when iterated.
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Now, we will write the function that will combine the bands into an RGB
    image. Add this function to your file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def create_color_composition(bands, dst_image):'
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: os.remove(dst_image)
  prefs: []
  type: TYPE_NORMAL
- en: 'except OSError:'
  prefs: []
  type: TYPE_NORMAL
- en: pass
  prefs: []
  type: TYPE_NORMAL
- en: Part1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: datasets = map(gdal.Open, bands)
  prefs: []
  type: TYPE_NORMAL
- en: img_iterators = map(create_image_generator, datasets)
  prefs: []
  type: TYPE_NORMAL
- en: cols = datasets[0].RasterXSize
  prefs: []
  type: TYPE_NORMAL
- en: rows = datasets[0].RasterYSize
  prefs: []
  type: TYPE_NORMAL
- en: Part2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: driver = gdal.GetDriverByName('GTiff')
  prefs: []
  type: TYPE_NORMAL
- en: new_dataset = driver.Create(dst_image, cols, rows,
  prefs: []
  type: TYPE_NORMAL
- en: eType=gdal.GDT_Byte,
  prefs: []
  type: TYPE_NORMAL
- en: bands=3,
  prefs: []
  type: TYPE_NORMAL
- en: options=["PHOTOMETRIC=RGB"])
  prefs: []
  type: TYPE_NORMAL
- en: gdal_array.CopyDatasetInfo(datasets[0], new_dataset)
  prefs: []
  type: TYPE_NORMAL
- en: Part3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: rgb_bands = map(new_dataset.GetRasterBand, [1, 2, 3])
  prefs: []
  type: TYPE_NORMAL
- en: for index, bands_rows in enumerate(
  prefs: []
  type: TYPE_NORMAL
- en: 'itertools.izip(*img_iterators)):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for band, row in zip(rgb_bands, bands_rows):'
  prefs: []
  type: TYPE_NORMAL
- en: row = adjust_values(row, [0, 30000])
  prefs: []
  type: TYPE_NORMAL
- en: band.WriteArray(xoff=0, yoff=index, array=row)
  prefs: []
  type: TYPE_NORMAL
- en: In Part 1, Python’s built-in map function works like itertools.imap, but instead
    of an iterator, it creates a list with the results. This means that all the items
    are calculated and available. First, we used it to create a list of GDAL datasets
    by calling gdal.Open on all the bands. Then, the map function is used to create
    a list of image iterators, one for each band.
  prefs: []
  type: TYPE_NORMAL
- en: In Part 2, we created the output database just like we did before. But this
    time, we told the driver to create a dataset with three bands, each with byte
    data type (256
  prefs: []
  type: TYPE_NORMAL
- en: possible values). We also tell that it’s an RGB photo in the options.
  prefs: []
  type: TYPE_NORMAL
- en: In Part 3, we used the map function again to get the reference to the bands
    in the dataset. In the first for loop, at each iteration, we got an index, that
    is, the row number, and a tuple containing a row for every band.
  prefs: []
  type: TYPE_NORMAL
- en: In the nested for loop, each iteration gets one of the output image bands and
    one row of the input bands. The values of the row are then converted from 16-bit
    to 8-bit (byte) with our adjust_values function. To adjust the values, we passed
    a magic
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 74](img/index-416_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: number in order to get a brighter image. Finally, the row is written to the
    output band.
  prefs: []
  type: TYPE_NORMAL
- en: '6\. Finally, let’s test the code. Edit your if __name__ == ''__main__'': block:
    if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: base_path = "../../data/landsat/"
  prefs: []
  type: TYPE_NORMAL
- en: base_name = 'LC80140282015270LGN00_B'
  prefs: []
  type: TYPE_NORMAL
- en: bands_numbers = [4, 3, 2]
  prefs: []
  type: TYPE_NORMAL
- en: bands = itertools.imap(
  prefs: []
  type: TYPE_NORMAL
- en: compose_band_path,
  prefs: []
  type: TYPE_NORMAL
- en: itertools.repeat(base_path),
  prefs: []
  type: TYPE_NORMAL
- en: itertools.repeat(base_name),
  prefs: []
  type: TYPE_NORMAL
- en: bands_numbers)
  prefs: []
  type: TYPE_NORMAL
- en: dst_image = "../output/color_composition.tif"
  prefs: []
  type: TYPE_NORMAL
- en: create_color_composition(bands, dst_image)
  prefs: []
  type: TYPE_NORMAL
- en: '7\. Now run it. After it’s done, open the image (color_composition.tif) in
    the output folder. You should see this beautiful color image:'
  prefs: []
  type: TYPE_NORMAL
- en: You can play with the numbers that we passed to the adjust_values function.
    Try changing the lower limit and the upper limit; you will get different variations
    of brightness.
  prefs: []
  type: TYPE_NORMAL
- en: '**Processing specific regions**'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s change our code to crop the image for us, so we can have a better
    view of the details of the region around Montreal. It’s something like we did
    before. But instead of cropping the image after processing, we will only process
    the region of interest, making the code much more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Edit the create_image_generator function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def create_image_generator(dataset, crop_region=None):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if not crop_region:'
  prefs: []
  type: TYPE_NORMAL
- en: cols = dataset.RasterXSize
  prefs: []
  type: TYPE_NORMAL
- en: rows = dataset.RasterYSize
  prefs: []
  type: TYPE_NORMAL
- en: xoff = 0
  prefs: []
  type: TYPE_NORMAL
- en: yoff = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: xoff = crop_region[0]
  prefs: []
  type: TYPE_NORMAL
- en: yoff = crop_region[1]
  prefs: []
  type: TYPE_NORMAL
- en: cols = crop_region[2]
  prefs: []
  type: TYPE_NORMAL
- en: rows = crop_region[3]
  prefs: []
  type: TYPE_NORMAL
- en: 'for row_index in xrange(yoff, yoff + rows):'
  prefs: []
  type: TYPE_NORMAL
- en: yield dataset.ReadAsArray(xoff=xoff, yoff=row_index,
  prefs: []
  type: TYPE_NORMAL
- en: xsize=cols, ysize=1)
  prefs: []
  type: TYPE_NORMAL
- en: Now, the function receives an optional crop_region argument and only yields
    rows of the region of interest if it’s passed. If not, it yields rows for the
    whole image.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Change the create_color_composition class to work with the cropped data:
    def create_color_composition(bands, dst_image, crop_region=None): try:'
  prefs: []
  type: TYPE_NORMAL
- en: os.remove(dst_image)
  prefs: []
  type: TYPE_NORMAL
- en: 'except OSError:'
  prefs: []
  type: TYPE_NORMAL
- en: pass
  prefs: []
  type: TYPE_NORMAL
- en: datasets = map(gdal.Open, bands)
  prefs: []
  type: TYPE_NORMAL
- en: img_iterators = list(itertools.imap(
  prefs: []
  type: TYPE_NORMAL
- en: create_image_generator, datasets,
  prefs: []
  type: TYPE_NORMAL
- en: itertools.repeat(crop_region)))
  prefs: []
  type: TYPE_NORMAL
- en: 'if not crop_region:'
  prefs: []
  type: TYPE_NORMAL
- en: cols = datasets[0].RasterXSize
  prefs: []
  type: TYPE_NORMAL
- en: rows = datasets[0].RasterYSize
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: cols = crop_region[2]
  prefs: []
  type: TYPE_NORMAL
- en: rows = crop_region[3]
  prefs: []
  type: TYPE_NORMAL
- en: driver = gdal.GetDriverByName('GTiff')
  prefs: []
  type: TYPE_NORMAL
- en: new_dataset = driver.Create(dst_image, cols, rows,
  prefs: []
  type: TYPE_NORMAL
- en: eType=gdal.GDT_Byte,
  prefs: []
  type: TYPE_NORMAL
- en: bands=3,
  prefs: []
  type: TYPE_NORMAL
- en: options=["PHOTOMETRIC=RGB"])
  prefs: []
  type: TYPE_NORMAL
- en: gdal_array.CopyDatasetInfo(datasets[0], new_dataset)
  prefs: []
  type: TYPE_NORMAL
- en: rgb_bands = map(new_dataset.GetRasterBand, [1, 2, 3])
  prefs: []
  type: TYPE_NORMAL
- en: for index, bands_rows in enumerate(
  prefs: []
  type: TYPE_NORMAL
- en: 'itertools.izip(*img_iterators)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 75](img/index-418_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'for band, row in zip(rgb_bands, bands_rows):'
  prefs: []
  type: TYPE_NORMAL
- en: row = adjust_values(row, [1000, 30000])
  prefs: []
  type: TYPE_NORMAL
- en: band.WriteArray(xoff=0, yoff=index, array=row)
  prefs: []
  type: TYPE_NORMAL
- en: Note that when img_iterators was created, we replaced the map function by itertools.imap
    in order to be able to use the itertools.repeat function. Since we need img_iterators
    to be a list of iterators, we used the list function.
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Finally, edit the if __name__ == ''__main__'': block to pass our region
    of interest: if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: base_path = "../../data/landsat/"
  prefs: []
  type: TYPE_NORMAL
- en: base_name = 'LC80140282015270LGN00_B'
  prefs: []
  type: TYPE_NORMAL
- en: bands_numbers = [4, 3, 2]
  prefs: []
  type: TYPE_NORMAL
- en: bands = itertools.imap(
  prefs: []
  type: TYPE_NORMAL
- en: compose_band_path,
  prefs: []
  type: TYPE_NORMAL
- en: itertools.repeat(base_path),
  prefs: []
  type: TYPE_NORMAL
- en: itertools.repeat(base_name),
  prefs: []
  type: TYPE_NORMAL
- en: bands_numbers)
  prefs: []
  type: TYPE_NORMAL
- en: dst_image = "../output/color_composition.tif"
  prefs: []
  type: TYPE_NORMAL
- en: create_color_composition(bands, dst_image,
  prefs: []
  type: TYPE_NORMAL
- en: (1385, 5145, 1985, 1195))
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Run the code. You should now have this nice image of Montreal:'
  prefs: []
  type: TYPE_NORMAL
- en: '**False color compositions**'
  prefs: []
  type: TYPE_NORMAL
- en: Color compositions are a great tool for information visualization, and we can
    use it even to see things that would be otherwise invisible to the human eye.
  prefs: []
  type: TYPE_NORMAL
- en: Landsat 8 and other satellites provide data in ranges of the spectrum that are
    reflected or absorbed more or less by specific objects. For example, vigorous
    vegetation reflects a lot of near-infrared radiation, so if we are looking for
    information on vegetation coverage or plant growth, we should consider this band.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the computational analysis of different bands, we are able to visualize
    them by replacing the red, blue, and green components by other bands. Let’s try
    it as follows: 1\. Just edit the if __name__ == ''__main__'': block, so we use
    the near infrared (band 5) as the green component of the RGB image:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: base_path = "../../data/landsat/"
  prefs: []
  type: TYPE_NORMAL
- en: base_name = 'LC80140282015270LGN00_B'
  prefs: []
  type: TYPE_NORMAL
- en: bands_numbers = [4, 5, 2]
  prefs: []
  type: TYPE_NORMAL
- en: bands = itertools.imap(
  prefs: []
  type: TYPE_NORMAL
- en: compose_band_path,
  prefs: []
  type: TYPE_NORMAL
- en: itertools.repeat(base_path),
  prefs: []
  type: TYPE_NORMAL
- en: itertools.repeat(base_name),
  prefs: []
  type: TYPE_NORMAL
- en: bands_numbers)
  prefs: []
  type: TYPE_NORMAL
- en: dst_image = "../output/color_composition.tif"
  prefs: []
  type: TYPE_NORMAL
- en: create_color_composition(bands, dst_image,
  prefs: []
  type: TYPE_NORMAL
- en: (1385, 5145, 1985, 1195))
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Run the code and look at the output image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 76](img/index-420_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 77](img/index-420_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 3\. You can have many other combinations. Just change the band_numbers variables
    to achieve different results. Try changing it to [6, 5, 2 ]. Run the code and
    look at how the farm fields stand out from the other features.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check out more interesting band combinations by clicking on the following
    links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://landsat.gsfc.nasa.gov/?page_id=5377](http://landsat.gsfc.nasa.gov/?page_id=5377)'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://blogs.esri.com/esri/arcgis/2013/07/24/band-combinations-for-landsat-8/](http://blogs.esri.com/esri/arcgis/2013/07/24/band-combinations-for-landsat-8/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: As we did with the points of interest, we managed the problem of excessive computational
    resource consumption by splitting the load into pieces. Specifically, instead
    of reading and processing whole images, we created Python iterators that allowed
    us to iterate through these images one row at a time without hitting the memory
    limit of the computer.
  prefs: []
  type: TYPE_NORMAL
- en: With this technique, we were able to process three Landsat 8 bands at a time
    to produce fancy colored images valuable for data visualization.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we are able to split our processing tasks into pieces that can
    be processed independently. We can do this with vectors, with database access,
    and now, with images as well.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we completely paved the road for the next chapter, where we will
    be sending each of these pieces to be calculated at the same time by a different
    processor core performing the so-called parallel processing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter 10\. Parallel Processing**'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will take another step in code optimization; we will experiment
    with the possibility of using multiple processor cores to perform calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Using the satellite images from the previous chapter, we will use Python’s multiprocessing
    library to distribute tasks and make them run in parallel. As an example, we will
    experiment with different techniques to produce true color compositions from Landsat
    8
  prefs: []
  type: TYPE_NORMAL
- en: data, with better resolution and a greater level of detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve our objects, we will go through these topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How multiprocessing works
  prefs: []
  type: TYPE_NORMAL
- en: How to iterate through two-dimensional image blocks
  prefs: []
  type: TYPE_NORMAL
- en: Image resizing and resampling
  prefs: []
  type: TYPE_NORMAL
- en: Parallel processing in image operations
  prefs: []
  type: TYPE_NORMAL
- en: Image pan sharpening
  prefs: []
  type: TYPE_NORMAL
- en: '**Multiprocessing basics**'
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of Python that we are using, CPython, has a mechanism called
    **global** **interpreter lock** (**GIL**). GIL’s purpose is to make CPython thread-safe;
    it works by preventing the code from being executed by more than one thread at
    once.
  prefs: []
  type: TYPE_NORMAL
- en: With that limitation, multiprocessing in Python works by forking the running
    program (for example, making a copy of the state of the program) and sending it
    to another computer core. As a consequence, the new process comes with an overhead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try a simple code:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. First, make a copy of the previous chapter folder in your geopy project
    and rename it to Chapter10\.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Clean the Chapter10/output folder (delete all files in it).
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Expand the Chapter10/experiments folder, right-click on it, and create a
    new Python file. Name it parallel.py.
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Add this code to this new file:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from datetime import datetime
  prefs: []
  type: TYPE_NORMAL
- en: import multiprocessing as mp
  prefs: []
  type: TYPE_NORMAL
- en: 'def an_expensive_function(text):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(500):'
  prefs: []
  type: TYPE_NORMAL
- en: out = "{} {} {}"
  prefs: []
  type: TYPE_NORMAL
- en: out.format(text, text, text)
  prefs: []
  type: TYPE_NORMAL
- en: return "dummy output"
  prefs: []
  type: TYPE_NORMAL
- en: This is a simple function that receives text and performs string formatting
    multiple times. The only purpose of this function is to consume CPU time, so we
    can test whether we can speed up our code by running parallel processes.
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Now, create an if __name__ == ''__main__'': block at the end of the file
    so we can test the code and measure its execution time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: texts = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for t in range(100000):'
  prefs: []
  type: TYPE_NORMAL
- en: texts.append('test text')
  prefs: []
  type: TYPE_NORMAL
- en: t1 = datetime.now()
  prefs: []
  type: TYPE_NORMAL
- en: result = map(an_expensive_function, texts)
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Execution time: {}".format(datetime.now() - t1)) This code makes a list
    of 100000 strings, then this list is mapped to the function; this means that an_expensive_function
    is called 100000\. Note that here we are using a simpler technique for measuring
    the execution time for this piece of code; t1 holds the start time and in the
    end it’s subtracted from the current time. This avoids the'
  prefs: []
  type: TYPE_NORMAL
- en: overhead of using a profiler and is also more suitable for what we are going
    to do than the timeit module.
  prefs: []
  type: TYPE_NORMAL
- en: '6\. Run the code and check the result in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execution time: 0:00:35.667500'
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: My computer took approximately 35 seconds to run the function 100,000 times;
    probably your results will be different. If your computer is much faster, change
    this number to get an execution time of at least 10 seconds. Take note of your
    result.
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Now edit the if __name__ == ''__main__'': block so we can execute this
    code in parallel:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: texts = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for t in range(100000):'
  prefs: []
  type: TYPE_NORMAL
- en: texts.append('test text')
  prefs: []
  type: TYPE_NORMAL
- en: multi = True
  prefs: []
  type: TYPE_NORMAL
- en: t1 = datetime.now()
  prefs: []
  type: TYPE_NORMAL
- en: 'if multi:'
  prefs: []
  type: TYPE_NORMAL
- en: my_pool = mp.Pool(processes=8)
  prefs: []
  type: TYPE_NORMAL
- en: result = my_pool.map(an_expensive_function, texts)
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: result = map(an_expensive_function, texts)
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Execution time: {}".format(datetime.now() - t1)) The Pool class represents
    a pool of worker processes; they stand by, waiting until we submit some jobs to
    be done.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to use all of your processor cores, you need to create the same number
    as, or more than, the number of cores of your processor. Or, if you don’t want
    to fully load your computer processor, use fewer processes than the number of
    cores. This is done by changing the processes argument.
  prefs: []
  type: TYPE_NORMAL
- en: We put the code in an if block so we can easily switch between parallel and
    single processes.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Run your code and see the difference:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execution time: 0:00:08.373000'
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: The code ran approximately four times faster for me.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Now, open your Task Manager, or your system monitor and open the CPU load
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 78](img/index-428_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 79](img/index-428_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: graphs.
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Run the code again, using multi=True, and take a look at the CPU load graph:
    5\. Change to multi=False and run it again. Inspect the graph now: Note that when
    using multiprocessing, all cores were fully occupied for a short period of time.
    However, when using a single process, some of the cores are partially occupied
    for a'
  prefs: []
  type: TYPE_NORMAL
- en: long time. This pattern may vary according to the computer architecture.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 80](img/index-431_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Block iteration**'
  prefs: []
  type: TYPE_NORMAL
- en: The TIFF format is a versatile image format that can be customized for very
    diverse needs. The file is composed of a **Header**, at least one **Image File
    Directory,** and any amount of **Image Data**. Explaining it in a simple way,
    the header tells where the first directory is on the file. The directory contains
    information about the image, tells how to read the data related to it, and tells
    where the next directory is. Each combination of a directory and image data is
    an image, so a single TIFF file may have multiple images inside it.
  prefs: []
  type: TYPE_NORMAL
- en: Each image data (a whole image) contains blocks of data (that is, parts of the
    image) that can be read separately, each one representing a specific region of
    the image. This allows the user to read the image by chunks, just like we did.
  prefs: []
  type: TYPE_NORMAL
- en: The blocks of data are indivisible; in order to return data from an image, the
    program that is reading it needs to read at least one whole block. If the desired
    region is smaller than a block, the whole block will be read anyway, decoded,
    and cropped; the data will then be returned to the user.
  prefs: []
  type: TYPE_NORMAL
- en: The blocks of data can be in strips or in tiles. Strips contain data for an
    entire image row and may be one row or more in length. Tiles have width and length
    (which must be a multiple of 16) and are interesting because they allow us to
    retrieve specific regions with no need to read entire rows.
  prefs: []
  type: TYPE_NORMAL
- en: In our previous examples, we programmed a function that was able to read images
    one row at a time; now we will improve that function in order to read blocks of
    any size. This will allow us to make fancier stuff with the images in the upcoming
    topics.
  prefs: []
  type: TYPE_NORMAL
- en: This time, we will take a different approach to how we iterate the image.
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Inside your Chapter10/experiments folder, create a new file named block_generator.py.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Edit this file and insert the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import os
  prefs: []
  type: TYPE_NORMAL
- en: from pprint import pprint
  prefs: []
  type: TYPE_NORMAL
- en: from osgeo import gdal, gdal_array
  prefs: []
  type: TYPE_NORMAL
- en: 'def create_blocks_list(crop_region, block_shape):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Creates a list of block reading coordinates.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param crop_region: Offsets and shape of the region of interest.'
  prefs: []
  type: TYPE_NORMAL
- en: (xoff, yoff, xsize, ysize)
  prefs: []
  type: TYPE_NORMAL
- en: ':param block_shape: Width and height of each block.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: img_columns = crop_region[2]
  prefs: []
  type: TYPE_NORMAL
- en: img_rows = crop_region[3]
  prefs: []
  type: TYPE_NORMAL
- en: blk_width = block_shape[0]
  prefs: []
  type: TYPE_NORMAL
- en: blk_height = block_shape[1]
  prefs: []
  type: TYPE_NORMAL
- en: Get the number of blocks.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: x_blocks = int((img_columns + blk_width - 1) / blk_width)
  prefs: []
  type: TYPE_NORMAL
- en: y_blocks = int((img_rows + blk_height - 1) / blk_height)
  prefs: []
  type: TYPE_NORMAL
- en: print("Creating blocks list with {} blocks ({} x {}).".format(
  prefs: []
  type: TYPE_NORMAL
- en: x_blocks * y_blocks, x_blocks, y_blocks))
  prefs: []
  type: TYPE_NORMAL
- en: blocks = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for block_column in range(0, x_blocks):'
  prefs: []
  type: TYPE_NORMAL
- en: Recalculate the shape of the rightmost block.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if block_column == x_blocks - 1:'
  prefs: []
  type: TYPE_NORMAL
- en: valid_x = img_columns - block_column * blk_width
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: valid_x = blk_width
  prefs: []
  type: TYPE_NORMAL
- en: xoff = block_column * blk_width + crop_region[0]
  prefs: []
  type: TYPE_NORMAL
- en: loop through Y lines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for block_row in range(0, y_blocks):'
  prefs: []
  type: TYPE_NORMAL
- en: Recalculate the shape of the final block.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if block_row == y_blocks - 1:'
  prefs: []
  type: TYPE_NORMAL
- en: valid_y = img_rows - block_row * blk_height
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: valid_y = blk_height
  prefs: []
  type: TYPE_NORMAL
- en: yoff = block_row * blk_height + crop_region[1]
  prefs: []
  type: TYPE_NORMAL
- en: blocks.append((xoff, yoff, valid_x, valid_y))
  prefs: []
  type: TYPE_NORMAL
- en: return blocks
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Before some explanation, let’s see this function working. Add the if __name__
    ==
  prefs: []
  type: TYPE_NORMAL
- en: '''__main__'': block at the end of the file with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: blocks_list = create_blocks_list((0, 0, 1024, 1024), (32, 32)) pprint(blocks_list)
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Run the code. Since we are running a different file from before, remember
    to press *Alt* + *Shift* + *F10* to select the file to run. Check the output:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating blocks list with 1024 blocks (32 x 32).
  prefs: []
  type: TYPE_NORMAL
- en: '[(0, 0, 32, 32),'
  prefs: []
  type: TYPE_NORMAL
- en: (0, 32, 32, 32),
  prefs: []
  type: TYPE_NORMAL
- en: (0, 64, 32, 32),
  prefs: []
  type: TYPE_NORMAL
- en: (0, 96, 32, 32),
  prefs: []
  type: TYPE_NORMAL
- en: (0, 128, 32, 32),
  prefs: []
  type: TYPE_NORMAL
- en: (0, 160, 32, 32),
  prefs: []
  type: TYPE_NORMAL
- en: (0, 192, 32, 32),
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: (992, 928, 32, 32),
  prefs: []
  type: TYPE_NORMAL
- en: (992, 960, 32, 32),
  prefs: []
  type: TYPE_NORMAL
- en: (992, 992, 32, 32)]
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: The sole purpose of this function is to create a list of block coordinates and
    dimensions; each item on the list contains the offset and the size of a block.
    We need the size because the blocks on the edges may be smaller than the desired
    size.
  prefs: []
  type: TYPE_NORMAL
- en: The intention of this design choice, instead of iterating through an image directly,
    was to hide this low-level functionality. This function is extensive and unintuitive;
    we don’t want it mixed with higher-level code, making our programs much cleaner.
    As a bonus, we may gain a little speed when iterating multiple images because
    the list only needs to be produced once.
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Now, let’s adapt the function to copy the image. To use the iteration by
    blocks, add this code to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def copy_image(src_image, dst_image, block_shape):'
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: os.remove(dst_image)
  prefs: []
  type: TYPE_NORMAL
- en: 'except OSError:'
  prefs: []
  type: TYPE_NORMAL
- en: pass
  prefs: []
  type: TYPE_NORMAL
- en: src_dataset = gdal.Open(src_image)
  prefs: []
  type: TYPE_NORMAL
- en: cols = src_dataset.RasterXSize
  prefs: []
  type: TYPE_NORMAL
- en: rows = src_dataset.RasterYSize
  prefs: []
  type: TYPE_NORMAL
- en: driver = gdal.GetDriverByName('GTiff')
  prefs: []
  type: TYPE_NORMAL
- en: new_dataset = driver.Create(dst_image, cols, rows,
  prefs: []
  type: TYPE_NORMAL
- en: eType=gdal.GDT_UInt16)
  prefs: []
  type: TYPE_NORMAL
- en: gdal_array.CopyDatasetInfo(src_dataset, new_dataset)
  prefs: []
  type: TYPE_NORMAL
- en: band = new_dataset.GetRasterBand(1)
  prefs: []
  type: TYPE_NORMAL
- en: blocks_list = create_blocks_list((0, 0, cols, rows), block_shape) n_blocks =
    len(blocks_list)
  prefs: []
  type: TYPE_NORMAL
- en: 'for index, block in enumerate(blocks_list, 1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if index % 10 == 0:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Copying block {} of {}.".format(index, n_blocks)) block_data = src_dataset.ReadAsArray(*block)
  prefs: []
  type: TYPE_NORMAL
- en: band.WriteArray(block_data, block[0], block[1])
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Edit the if __name__ == ''__main__'': block to test the code (we are also
    going to measure its execution time):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: base_path = "../../data/landsat/"
  prefs: []
  type: TYPE_NORMAL
- en: img_name = "LC80140282015270LGN00_B8.TIF"
  prefs: []
  type: TYPE_NORMAL
- en: img_path = os.path.join(base_path, img_name)
  prefs: []
  type: TYPE_NORMAL
- en: img_copy = "../output/B8_copy.tif"
  prefs: []
  type: TYPE_NORMAL
- en: t1 = datetime.now()
  prefs: []
  type: TYPE_NORMAL
- en: copy_image(img_path, img_copy, (1024, 1024))
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Execution time: {}".format(datetime.now() - t1)) 3\. Now, run it and
    check the output:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating blocks list with 256 blocks (16 x 16).
  prefs: []
  type: TYPE_NORMAL
- en: Copying block 10 of 256\.
  prefs: []
  type: TYPE_NORMAL
- en: Copying block 20 of 256….
  prefs: []
  type: TYPE_NORMAL
- en: Copying block 240 of 256\.
  prefs: []
  type: TYPE_NORMAL
- en: Copying block 250 of 256\.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execution time: 0:00:26.656000'
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: We used blocks of 1024 by 1024 pixels to copy the image. The first thing to
    notice is that the process is extremely slow. This happened because we are reading
    blocks smaller than the size of the blocks in the image, resulting in a lot of
    reading and writing overhead.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s adapt our function in order to detect the block size and optimize
    the reading.
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Edit the copy_image function:'
  prefs: []
  type: TYPE_NORMAL
- en: '**def copy_image(src_image, dst_image, block_width=None,**'
  prefs: []
  type: TYPE_NORMAL
- en: '**block_height=None):**'
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: os.remove(dst_image)
  prefs: []
  type: TYPE_NORMAL
- en: 'except OSError:'
  prefs: []
  type: TYPE_NORMAL
- en: pass
  prefs: []
  type: TYPE_NORMAL
- en: src_dataset = gdal.Open(src_image)
  prefs: []
  type: TYPE_NORMAL
- en: cols = src_dataset.RasterXSize
  prefs: []
  type: TYPE_NORMAL
- en: rows = src_dataset.RasterYSize
  prefs: []
  type: TYPE_NORMAL
- en: '**src_band = src_dataset.GetRasterBand(1)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**src_block_size = src_band.GetBlockSize()**'
  prefs: []
  type: TYPE_NORMAL
- en: '**print("Image shape {}x{}px. Block shape {}x{}px.").format(**'
  prefs: []
  type: TYPE_NORMAL
- en: '**cols, rows, *src_block_size)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**block_shape = (block_width or src_block_size[0],**'
  prefs: []
  type: TYPE_NORMAL
- en: '**block_height or src_block_size[1])**'
  prefs: []
  type: TYPE_NORMAL
- en: driver = gdal.GetDriverByName('GTiff')
  prefs: []
  type: TYPE_NORMAL
- en: new_dataset = driver.Create(dst_image, cols, rows,
  prefs: []
  type: TYPE_NORMAL
- en: eType=gdal.GDT_UInt16)
  prefs: []
  type: TYPE_NORMAL
- en: gdal_array.CopyDatasetInfo(src_dataset, new_dataset)
  prefs: []
  type: TYPE_NORMAL
- en: band = new_dataset.GetRasterBand(1)
  prefs: []
  type: TYPE_NORMAL
- en: blocks_list = create_blocks_list((0, 0, cols, rows), block_shape) n_blocks =
    len(blocks_list)
  prefs: []
  type: TYPE_NORMAL
- en: 'for index, block in enumerate(blocks_list, 1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if index % 10 == 0:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Copying block {} of {}.".format(index, n_blocks)) block_data = src_dataset.ReadAsArray(*block)
  prefs: []
  type: TYPE_NORMAL
- en: band.WriteArray(block_data, block[0], block[1])
  prefs: []
  type: TYPE_NORMAL
- en: We separated the block shape arguments into width and height, and made them
    optional. Then we got the size (shape) of the block that is defined in the image.
    If the block width or height are not passed as arguments, the image values are
    used instead.
  prefs: []
  type: TYPE_NORMAL
- en: We have a hint that this image is divided in stripes. Remember that when we
    copied the image one row at a time, it was fast. So, we are going to test reading
    multiple rows at a time.
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Edit the if __name__ == ''__main__'': block:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: base_path = "../../data/landsat/"
  prefs: []
  type: TYPE_NORMAL
- en: img_name = "LC80140282015270LGN00_B8.TIF"
  prefs: []
  type: TYPE_NORMAL
- en: img_path = os.path.join(base_path, img_name)
  prefs: []
  type: TYPE_NORMAL
- en: img_copy = "../output/B8_copy.tif"
  prefs: []
  type: TYPE_NORMAL
- en: t1 = datetime.now()
  prefs: []
  type: TYPE_NORMAL
- en: copy_image(img_path, img_copy, block_height=100)
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Execution time: {}".format(datetime.now() - t1)) 6\. Run the code and
    see the difference:'
  prefs: []
  type: TYPE_NORMAL
- en: Image shape 15401x15661px. Block shape 15401x1px.
  prefs: []
  type: TYPE_NORMAL
- en: Creating blocks list with 157 blocks (1 x 157).
  prefs: []
  type: TYPE_NORMAL
- en: Copying block 10 of 157\.
  prefs: []
  type: TYPE_NORMAL
- en: Copying block 20 of 157\.
  prefs: []
  type: TYPE_NORMAL
- en: Copying block 30 of 157….
  prefs: []
  type: TYPE_NORMAL
- en: Copying block 130 of 157\.
  prefs: []
  type: TYPE_NORMAL
- en: Copying block 140 of 157\.
  prefs: []
  type: TYPE_NORMAL
- en: Copying block 150 of 157\.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execution time: 0:00:02.083000'
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: It’s confirmed that, for Landsat 8 images, each block is one row of the image.
    And by reading whole lines, we achieved the same level of speed as before.
  prefs: []
  type: TYPE_NORMAL
- en: You can play with the block height parameter; instead of reading 100 lines,
    try reading 1
  prefs: []
  type: TYPE_NORMAL
- en: or 1,000 lines and see if it has any influence on the execution time.
  prefs: []
  type: TYPE_NORMAL
- en: '**Improving the image resolution**'
  prefs: []
  type: TYPE_NORMAL
- en: In order to obtain a better image for visual analysis, we can combine different
    techniques to increase the image resolution. The first one changes the size of
    the image and recalculates the missing data by interpolation. The second one uses
    a band of higher resolution (band 8, in our case)—combined with bands in a lower
    resolution—to produce an improved true color map.
  prefs: []
  type: TYPE_NORMAL
- en: '**Image resampling**'
  prefs: []
  type: TYPE_NORMAL
- en: Image resizing or resampling is a technique to change the size of the image.
    By doing this we change the number of pixels in it (that is, the number of samples)
    or vice-versa.
  prefs: []
  type: TYPE_NORMAL
- en: As the size of an image is increased, we need to give a value to pixels that
    didn’t exist before. This is done by interpolation; the new pixel value is given
    based on the value of its surrounding pixels. That’s why we needed two-dimensional
    chunks.
  prefs: []
  type: TYPE_NORMAL
- en: In our first trial, we will resample one 30m-resolution band into a 15m-resolution
    image.
  prefs: []
  type: TYPE_NORMAL
- en: Since we will perform a lot of tests, let’s start by creating a practical way
    of viewing and comparing our results. To do that we will crop the image and save
    it to disk so we can easily visualize the same region.
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Edit the imports at the beginning of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from datetime import datetime
  prefs: []
  type: TYPE_NORMAL
- en: import os
  prefs: []
  type: TYPE_NORMAL
- en: import itertools
  prefs: []
  type: TYPE_NORMAL
- en: import numpy as np
  prefs: []
  type: TYPE_NORMAL
- en: from pprint import pprint
  prefs: []
  type: TYPE_NORMAL
- en: import functools
  prefs: []
  type: TYPE_NORMAL
- en: import multiprocessing as mp
  prefs: []
  type: TYPE_NORMAL
- en: from osgeo import gdal, gdal_array
  prefs: []
  type: TYPE_NORMAL
- en: from images import adjust_values, compose_band_path
  prefs: []
  type: TYPE_NORMAL
- en: from images import create_color_composition
  prefs: []
  type: TYPE_NORMAL
- en: import cv2 as cv
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Add this new function to your file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def crop_and_save(image_path, prefix=""):'
  prefs: []
  type: TYPE_NORMAL
- en: dataset = gdal.Open(image_path)
  prefs: []
  type: TYPE_NORMAL
- en: array = dataset.ReadAsArray(4209, 11677, 348, 209)
  prefs: []
  type: TYPE_NORMAL
- en: array = adjust_values(array, (10000, 30000))
  prefs: []
  type: TYPE_NORMAL
- en: array = array.astype(np.ubyte)
  prefs: []
  type: TYPE_NORMAL
- en: preview_path, preview_file = os.path.split(image_path)
  prefs: []
  type: TYPE_NORMAL
- en: 'preview_file = "preview_" + prefix + preview_file cv.imwrite(os.path.join("../output/",
    preview_file), array) This time we will zoom the image to downtown Montreal, including
    the Mount Royal and the Old Port. As a reference, the next image is a high-resolution
    image extracted from Bing maps of our region of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 81](img/index-439_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '3\. Now, add the resampling function to your file:'
  prefs: []
  type: TYPE_NORMAL
- en: def resample_image(src_image, dst_image,
  prefs: []
  type: TYPE_NORMAL
- en: block_width=None, block_height=None, factor=2,
  prefs: []
  type: TYPE_NORMAL
- en: 'interpolation=cv.INTER_LINEAR):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Change image resolution by a factor.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param src_image: Input image.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param dst_image: Output image.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param block_width: Width in pixels of the processing blocks.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param block_height: Height in pixels of the processing blocks.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param factor: Image size multiplier.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param interpolation: Interpolation method.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: t1 = datetime.now()
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Start processing -> {}".format(dst_image)) try:'
  prefs: []
  type: TYPE_NORMAL
- en: os.remove(dst_image)
  prefs: []
  type: TYPE_NORMAL
- en: 'except OSError:'
  prefs: []
  type: TYPE_NORMAL
- en: pass
  prefs: []
  type: TYPE_NORMAL
- en: src_dataset = gdal.Open(src_image, gdal.GA_ReadOnly)
  prefs: []
  type: TYPE_NORMAL
- en: cols = src_dataset.RasterXSize
  prefs: []
  type: TYPE_NORMAL
- en: rows = src_dataset.RasterYSize
  prefs: []
  type: TYPE_NORMAL
- en: src_band = src_dataset.GetRasterBand(1)
  prefs: []
  type: TYPE_NORMAL
- en: src_block_size = src_band.GetBlockSize()
  prefs: []
  type: TYPE_NORMAL
- en: print("Image shape {}x{}px. Block shape {}x{}px.").format(
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: cols, rows, *src_block_size)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: block_shape = (block_width or src_block_size[0],
  prefs: []
  type: TYPE_NORMAL
- en: block_height or src_block_size[1])
  prefs: []
  type: TYPE_NORMAL
- en: driver = gdal.GetDriverByName('GTiff') new_dataset = driver.Create(dst_image,
    cols * factor,
  prefs: []
  type: TYPE_NORMAL
- en: rows * factor,
  prefs: []
  type: TYPE_NORMAL
- en: eType=gdal.GDT_UInt16)
  prefs: []
  type: TYPE_NORMAL
- en: gdal_array.CopyDatasetInfo(src_dataset, new_dataset)
  prefs: []
  type: TYPE_NORMAL
- en: band = new_dataset.GetRasterBand(1)
  prefs: []
  type: TYPE_NORMAL
- en: blocks_list = create_blocks_list((0, 0, cols, rows), block_shape) new_block_shape
    = (block_shape[0] * factor,
  prefs: []
  type: TYPE_NORMAL
- en: block_shape[1] * factor)
  prefs: []
  type: TYPE_NORMAL
- en: new_blocks_list = create_blocks_list((0, 0,
  prefs: []
  type: TYPE_NORMAL
- en: cols * factor,
  prefs: []
  type: TYPE_NORMAL
- en: rows * factor),
  prefs: []
  type: TYPE_NORMAL
- en: new_block_shape)
  prefs: []
  type: TYPE_NORMAL
- en: n_blocks = len(blocks_list)
  prefs: []
  type: TYPE_NORMAL
- en: for index, (block, new_block) in enumerate(
  prefs: []
  type: TYPE_NORMAL
- en: 'zip(blocks_list, new_blocks_list), 1):'
  prefs: []
  type: TYPE_NORMAL
- en: '#if index % 10 == 0:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Copying block {} of {}.".format(index, n_blocks)) block_data = src_dataset.ReadAsArray(*block)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: block_data = cv.resize(block_data, dsize=(0, 0),
  prefs: []
  type: TYPE_NORMAL
- en: fx=factor, fy=factor,
  prefs: []
  type: TYPE_NORMAL
- en: interpolation=interpolation)
  prefs: []
  type: TYPE_NORMAL
- en: band.WriteArray(block_data, new_block[0], new_block[1])
  prefs: []
  type: TYPE_NORMAL
- en: return dst_image, t1
  prefs: []
  type: TYPE_NORMAL
- en: This function creates an output dataset that is scaled by the defined factor.
    It reads each block from the source image, changes its size by this same factor,
    and writes it to the output. Note that the size of the output block is also recalculated
    and scaled by the multiplying factor. The method of interpolation is optional
    and by default uses linear interpolation.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of just testing this function, let’s generate previews of every possible
    interpolation method, so we can visually compare it and see which one returns
    the best result. Since we will do this using multiprocessing, we also need a callback
    function so we can time the execution of each job.
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Add this function to your file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def processing_callback(args):'
  prefs: []
  type: TYPE_NORMAL
- en: t2 = datetime.now() - args[1]
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Done processing {}. {}".format(args[0], t2)) 5\. Finally, edit the if
    __name__ == ''__main__'': block:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: base_path = "../../data/landsat/"
  prefs: []
  type: TYPE_NORMAL
- en: img_name = "LC80140282015270LGN00_B4.TIF"
  prefs: []
  type: TYPE_NORMAL
- en: img_path = os.path.join(base_path, img_name)
  prefs: []
  type: TYPE_NORMAL
- en: interpolation_methods = {
  prefs: []
  type: TYPE_NORMAL
- en: '"nearest": cv.INTER_NEAREST,'
  prefs: []
  type: TYPE_NORMAL
- en: '"linear": cv.INTER_LINEAR,'
  prefs: []
  type: TYPE_NORMAL
- en: '"area": cv.INTER_AREA,'
  prefs: []
  type: TYPE_NORMAL
- en: '"bicubic": cv.INTER_CUBIC,'
  prefs: []
  type: TYPE_NORMAL
- en: '"lanczos": cv.INTER_LANCZOS4}'
  prefs: []
  type: TYPE_NORMAL
- en: output_images = []
  prefs: []
  type: TYPE_NORMAL
- en: multi = True
  prefs: []
  type: TYPE_NORMAL
- en: my_pool = mp.Pool(processes=8)
  prefs: []
  type: TYPE_NORMAL
- en: total_t1 = datetime.now()
  prefs: []
  type: TYPE_NORMAL
- en: 'for name, inter_method in interpolation_methods.iteritems(): out_image = "../output/"
    + name + ''_B4.tif'''
  prefs: []
  type: TYPE_NORMAL
- en: output_images.append(out_image)
  prefs: []
  type: TYPE_NORMAL
- en: 'if multi:'
  prefs: []
  type: TYPE_NORMAL
- en: my_pool.apply_async(
  prefs: []
  type: TYPE_NORMAL
- en: resample_image, (img_path, out_image),
  prefs: []
  type: TYPE_NORMAL
- en: '{''block_height'': 100,'
  prefs: []
  type: TYPE_NORMAL
- en: '''interpolation'': inter_method},'
  prefs: []
  type: TYPE_NORMAL
- en: processing_callback)
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: result = resample_image(img_path, out_image,
  prefs: []
  type: TYPE_NORMAL
- en: block_height=100,
  prefs: []
  type: TYPE_NORMAL
- en: interpolation=inter_method)
  prefs: []
  type: TYPE_NORMAL
- en: processing_callback(result)
  prefs: []
  type: TYPE_NORMAL
- en: 'if multi:'
  prefs: []
  type: TYPE_NORMAL
- en: Close the pool, no more jobs.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: my_pool.close()
  prefs: []
  type: TYPE_NORMAL
- en: Wait for all results to be ready.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: my_pool.join()
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Total time: {}".format(datetime.now() - total_t1)) map(crop_and_save,
    output_images)'
  prefs: []
  type: TYPE_NORMAL
- en: Here we used another technique for adding jobs to a queue. With apply_assinc,
    we added each job one at a time, telling that we wanted the calculations to happen
    asynchronously. In the end, my_pool.join() make the program wait until all the
    jobs in the pool are complete.
  prefs: []
  type: TYPE_NORMAL
- en: '6\. With multi = True (multiprocessing enabled), run the code and look at the
    output: Start processing -> ../output/bicubic_B4.tif'
  prefs: []
  type: TYPE_NORMAL
- en: Start processing -> ../output/nearest_B4.tif
  prefs: []
  type: TYPE_NORMAL
- en: Start processing -> ../output/lanczos_B4.tif
  prefs: []
  type: TYPE_NORMAL
- en: Start processing -> ../output/linear_B4.tif
  prefs: []
  type: TYPE_NORMAL
- en: Start processing -> ../output/area_B4.tif
  prefs: []
  type: TYPE_NORMAL
- en: Done processing ../output/nearest_B4.tif. 0:00:33.924000
  prefs: []
  type: TYPE_NORMAL
- en: Done processing ../output/area_B4.tif. 0:00:37.263000
  prefs: []
  type: TYPE_NORMAL
- en: Done processing ../output/linear_B4.tif. 0:00:37.700000
  prefs: []
  type: TYPE_NORMAL
- en: Done processing ../output/bicubic_B4.tif. 0:00:39.546000
  prefs: []
  type: TYPE_NORMAL
- en: Done processing ../output/lanczos_B4.tif. 0:00:41.361000
  prefs: []
  type: TYPE_NORMAL
- en: 'Total time: 0:00:42.264000'
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: '7\. Now, disable multiprocessing by setting multi = False and run the code
    again: Start processing -> ../output/bicubic_B4.tif'
  prefs: []
  type: TYPE_NORMAL
- en: Done processing ../output/bicubic_B4.tif. 0:00:02.827000
  prefs: []
  type: TYPE_NORMAL
- en: Start processing -> ../output/nearest_B4.tif
  prefs: []
  type: TYPE_NORMAL
- en: Done processing ../output/nearest_B4.tif. 0:00:07.841000
  prefs: []
  type: TYPE_NORMAL
- en: Start processing -> ../output/lanczos_B4.tif
  prefs: []
  type: TYPE_NORMAL
- en: Done processing ../output/lanczos_B4.tif. 0:00:09.729000
  prefs: []
  type: TYPE_NORMAL
- en: Start processing -> ../output/linear_B4.tif
  prefs: []
  type: TYPE_NORMAL
- en: Done processing ../output/linear_B4.tif. 0:00:09.160000
  prefs: []
  type: TYPE_NORMAL
- en: Start processing -> ../output/area_B4.tif
  prefs: []
  type: TYPE_NORMAL
- en: Done processing ../output/area_B4.tif. 0:00:09.939000
  prefs: []
  type: TYPE_NORMAL
- en: 'Total time: 0:00:39.498000'
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: Comparing the output of both of the trials, we see a different pattern of execution.
    When using multiprocessing, all the processes are started, they take a long time
    to execute, and finish almost together. When not using multiprocessing, each process
    starts and finishes before the next one.
  prefs: []
  type: TYPE_NORMAL
- en: On my computer, it took longer to execute the code when using multiprocessing.
    This happened because our jobs used intense reading and writing and my hard drive
    was the **hardware bottleneck** and not the CPU. So, when using multiprocessing
    we added a lot of extra labor and also enforced concurrent reading and writing
    of files, reducing the HD
  prefs: []
  type: TYPE_NORMAL
- en: efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: There is no way to overcome hardware bottlenecks when the hardware is used at
    full capacity. As happened in this example, we needed to write 2.30 GB of resampled
    image data, so the program will take at least the time needed to write 2.30 GB
    to disk.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot of my task manager was taken during the program execution
    and illustrates the described situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 82](img/index-443_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 83](img/index-443_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: These results may vary from computer to computer, especially if you are using
    a configuration with more than one storage media, where the IO could also happen
    in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your output folder and see what we have:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Area interpolation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Bicubic interpolation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 84](img/index-444_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 85](img/index-444_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 86](img/index-444_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Lanczos interpolation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Linear interpolation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Nearest interpolation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 87](img/index-445_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 88](img/index-445_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And finally, look at band 8, the panchromatic band, with 15m resolution, as
    a reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 89](img/index-446_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Pan sharpening**'
  prefs: []
  type: TYPE_NORMAL
- en: With the resampling, we were able to produce images with pixels of 15 meters,
    but we’ve achieved little improvement in the details of the objects in the image.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome this limitation, a technique called **pan sharpening** can be used
    to produce color images with a better resolution. The principle is to use the
    panchromatic band (Landsat band 8) to improve the resolution of the composition.
  prefs: []
  type: TYPE_NORMAL
- en: Here we will use a method that consists of changing the color representation
    of an image from RGB to HSV—Hue, Saturation, Value.
  prefs: []
  type: TYPE_NORMAL
- en: As can be seen from the image, the value component could be interpreted as the
    brightness or intensity of the color. So, after the color representation is transformed,
    the value component can to be replaced with the higher-resolution panchromatic
    band, resulting in an image with better definition.
  prefs: []
  type: TYPE_NORMAL
- en: To do that, we need to produce a true color composition with the RGB bands,
    like we did before, but this time with the resampled images. Then we change the
    color representation, replace the value component, transform the color representation
    back to RGB, and save the image to disk.
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Since we have most of the function ready, start by editing the if __name__
    ==
  prefs: []
  type: TYPE_NORMAL
- en: '''__main__'': block. Remove the older tests and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: base_path = "../../data/landsat/"
  prefs: []
  type: TYPE_NORMAL
- en: base_name = 'LC80140282015270LGN00_B'
  prefs: []
  type: TYPE_NORMAL
- en: bands_numbers = [2, 3, 4]
  prefs: []
  type: TYPE_NORMAL
- en: bands_paths = itertools.imap(
  prefs: []
  type: TYPE_NORMAL
- en: compose_band_path,
  prefs: []
  type: TYPE_NORMAL
- en: itertools.repeat(base_path),
  prefs: []
  type: TYPE_NORMAL
- en: itertools.repeat(base_name),
  prefs: []
  type: TYPE_NORMAL
- en: bands_numbers)
  prefs: []
  type: TYPE_NORMAL
- en: output_images = list(itertools.imap(
  prefs: []
  type: TYPE_NORMAL
- en: compose_band_path,
  prefs: []
  type: TYPE_NORMAL
- en: itertools.repeat("../output/"),
  prefs: []
  type: TYPE_NORMAL
- en: itertools.repeat("15m_B"),
  prefs: []
  type: TYPE_NORMAL
- en: bands_numbers))
  prefs: []
  type: TYPE_NORMAL
- en: 1) Resample RGB bands.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for source, destination in zip(bands_paths, output_images): resample_image(source,
    destination, block_height=200)'
  prefs: []
  type: TYPE_NORMAL
- en: 2) Create a true color composition with the resampled bands.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This image is only for comparison.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: create_color_composition(list(output_images),
  prefs: []
  type: TYPE_NORMAL
- en: '''../output/preview_resampled_composition.tif'','
  prefs: []
  type: TYPE_NORMAL
- en: (4209, 11677, 348, 209))
  prefs: []
  type: TYPE_NORMAL
- en: 3) Crop all the bands.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: output_images.append(
  prefs: []
  type: TYPE_NORMAL
- en: '"../../data/landsat/LC80140282015270LGN00_B8.TIF") for source in output_images:'
  prefs: []
  type: TYPE_NORMAL
- en: crop_and_save(source)
  prefs: []
  type: TYPE_NORMAL
- en: 4) Use the cropped images for pan sharpening.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: band8 = "../output/preview__LC80140282015270LGN00_B8.TIF"
  prefs: []
  type: TYPE_NORMAL
- en: bgr_bands = itertools.imap(
  prefs: []
  type: TYPE_NORMAL
- en: compose_band_path,
  prefs: []
  type: TYPE_NORMAL
- en: itertools.repeat("../output/"),
  prefs: []
  type: TYPE_NORMAL
- en: itertools.repeat("preview__15m_B"),
  prefs: []
  type: TYPE_NORMAL
- en: bands_numbers)
  prefs: []
  type: TYPE_NORMAL
- en: pan_sharpen(list(bgr_bands),
  prefs: []
  type: TYPE_NORMAL
- en: band8, "../output/pan_sharpened.tif")
  prefs: []
  type: TYPE_NORMAL
- en: The procedure to generate the iterator with the file names is the same as used
    before.
  prefs: []
  type: TYPE_NORMAL
- en: In Part 1, the resampling of the RGB bands will be made using the default linear
    interpolation.
  prefs: []
  type: TYPE_NORMAL
- en: In Part 2 we will create a true color composition with the resampled RGB bands.
  prefs: []
  type: TYPE_NORMAL
- en: We won’t use this image to perform the pan sharpening; we are creating it only
    to compare the results.
  prefs: []
  type: TYPE_NORMAL
- en: We crop all the bands in Part 3\. By doing this, we are also adjusting the values
    of the grayscale from 16 bits to 8 bits. Finally, the pan sharpening is performed
    in Part 4\.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 90](img/index-448_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '2\. Now add the pan_sharpen function to your file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def pan_sharpen(bgr_bands, pan_band, out_img):'
  prefs: []
  type: TYPE_NORMAL
- en: bgr_arrays = []
  prefs: []
  type: TYPE_NORMAL
- en: Read the images into Numpy arrays.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for item in bgr_bands:'
  prefs: []
  type: TYPE_NORMAL
- en: array = cv.imread(item, flags=cv.CV_LOAD_IMAGE_GRAYSCALE)
  prefs: []
  type: TYPE_NORMAL
- en: bgr_arrays.append(array)
  prefs: []
  type: TYPE_NORMAL
- en: pan_array = cv.imread(pan_band, flags=cv.CV_LOAD_IMAGE_GRAYSCALE)
  prefs: []
  type: TYPE_NORMAL
- en: Create the RGB (BGR) composition and convert it to HSV.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: bgr_composition = np.dstack(bgr_arrays)
  prefs: []
  type: TYPE_NORMAL
- en: hsv_composition = cv.cvtColor(bgr_composition, cv.COLOR_BGR2HSV)
  prefs: []
  type: TYPE_NORMAL
- en: Split the bands and remove the original value component,
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: we wont use it.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: h, s, v = np.dsplit(hsv_composition, 3)
  prefs: []
  type: TYPE_NORMAL
- en: h, s = np.squeeze(h), np.squeeze(s)
  prefs: []
  type: TYPE_NORMAL
- en: del v
  prefs: []
  type: TYPE_NORMAL
- en: Use the panchromatic band as the V component.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pan_composition = np.dstack((h, s, pan_array))
  prefs: []
  type: TYPE_NORMAL
- en: Convert the image back to BGR and write it to the disk.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: bgr_composition = cv.cvtColor(pan_composition, cv.COLOR_HSV2BGR) cv.imwrite(out_img,
    bgr_composition)
  prefs: []
  type: TYPE_NORMAL
- en: The process is simple. The joining and splitting of the bands is done with NumPy’s
    dstack and dsplit functions. The color conversion is done by the cvtcolor function.
    Note that OpenCV uses a sequence of BGR bands instead of RGB.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Run the code and open the color compositions in the output folder to see
    the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resampled composition:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The image with pan sharpening:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 91](img/index-449_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: I would say that we achieved impressive results. The pan sharpened image is
    very clear and we can easily identify the city’s features on it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we saw how to distribute jobs into multiple processor cores,
    allowing the program to use all the available computing power.
  prefs: []
  type: TYPE_NORMAL
- en: Although parallel processing is a great resource, we found in our examples that
    it’s not applicable for all situations. Specifically, when the bottleneck is not
    the CPU, multiprocessing may downgrade the program speed.
  prefs: []
  type: TYPE_NORMAL
- en: In the course of our examples, we took low-resolution satellite images and were
    able to increase their resolution and level of detail through resampling and pan
    sharpening, obtaining images of much greater value for visual analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '**Index**'
  prefs: []
  type: TYPE_NORMAL
- en: '**A**'
  prefs: []
  type: TYPE_NORMAL
- en: abstraction / [Making data homogeneous](index_split_000.html#p148)
  prefs: []
  type: TYPE_NORMAL
- en: about / [The concept of abstraction](index_split_000.html#p148)
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Spaceborne Thermal Emission and Reflection Radiometer (ASTER) /
  prefs: []
  type: TYPE_NORMAL
- en: '[Processing remote sensing images and data](index_split_002.html#p286)'
  prefs: []
  type: TYPE_NORMAL
- en: alpha blending / [Blending images](index_split_002.html#p336)
  prefs: []
  type: TYPE_NORMAL
- en: app
  prefs: []
  type: TYPE_NORMAL
- en: integrating with / [Integrating with the app](index_split_001.html#p221)
  prefs: []
  type: TYPE_NORMAL
- en: area of all countries
  prefs: []
  type: TYPE_NORMAL
- en: '[calculating / Transforming the coordinate system and calculating the area
    of all](index_split_000.html#p92)'
  prefs: []
  type: TYPE_NORMAL
- en: '[countries](index_split_000.html#p92)'
  prefs: []
  type: TYPE_NORMAL
- en: attributes and relations
  prefs: []
  type: TYPE_NORMAL
- en: filtering by / [Filtering by attributes and relations](index_split_001.html#p212)
  prefs: []
  type: TYPE_NORMAL
- en: attributes values
  prefs: []
  type: TYPE_NORMAL
- en: obtaining / [Getting the attributes’ values](index_split_001.html#p191)
  prefs: []
  type: TYPE_NORMAL
- en: '**B**'
  prefs: []
  type: TYPE_NORMAL
- en: bands / [Processing remote sensing images and data](index_split_002.html#p286)
  prefs: []
  type: TYPE_NORMAL
- en: basic statistics, raster data
  prefs: []
  type: TYPE_NORMAL
- en: about / [Getting the basic statistics](index_split_002.html#p312)
  prefs: []
  type: TYPE_NORMAL
- en: data, preparing / [Preparing the data](index_split_002.html#p312)
  prefs: []
  type: TYPE_NORMAL
- en: simple information, printing / [Printing simple information](index_split_002.html#p312)
  prefs: []
  type: TYPE_NORMAL
- en: output information, formatting / [Formatting the output information](index_split_002.html#p312)
  prefs: []
  type: TYPE_NORMAL
- en: quartiles, calculating / [Calculating quartiles, histograms, and other statistics](index_split_002.html#p312)
  prefs: []
  type: TYPE_NORMAL
- en: histograms, calculating / [Calculating quartiles, histograms, and other statistics](index_split_002.html#p312)
  prefs: []
  type: TYPE_NORMAL
- en: '[other statistics, calculating / Calculating quartiles, histograms, and other](index_split_002.html#p312)'
  prefs: []
  type: TYPE_NORMAL
- en: '[statistics](index_split_002.html#p312)'
  prefs: []
  type: TYPE_NORMAL
- en: making, lazy property / [Making statistics a lazy property](index_split_002.html#p312)
  prefs: []
  type: TYPE_NORMAL
- en: block iteration
  prefs: []
  type: TYPE_NORMAL
- en: about / [Block iteration](#p430)
  prefs: []
  type: TYPE_NORMAL
- en: book project
  prefs: []
  type: TYPE_NORMAL
- en: creating / [Creating the book project](index_split_000.html#p84)
  prefs: []
  type: TYPE_NORMAL
- en: '**C**'
  prefs: []
  type: TYPE_NORMAL
- en: closest point
  prefs: []
  type: TYPE_NORMAL
- en: searching / [Finding the closest point](index_split_000.html#p134)
  prefs: []
  type: TYPE_NORMAL
- en: code comments
  prefs: []
  type: TYPE_NORMAL
- en: about / [Documenting your code](index_split_000.html#p103)
  prefs: []
  type: TYPE_NORMAL
- en: code profiling
  prefs: []
  type: TYPE_NORMAL
- en: about / [Code profiling](index_split_002.html#p354)
  prefs: []
  type: TYPE_NORMAL
- en: color classified images
  prefs: []
  type: TYPE_NORMAL
- en: creating / [Creating color classified images](index_split_002.html#p325)
  prefs: []
  type: TYPE_NORMAL
- en: right colors, selecting for map / [Choosing the right colors for a map](index_split_002.html#p325)
  prefs: []
  type: TYPE_NORMAL
- en: context manager / [Downloading data from a URL](index_split_000.html#p112)
  prefs: []
  type: TYPE_NORMAL
- en: coordinate system
  prefs: []
  type: TYPE_NORMAL
- en: '[transforming / Transforming the coordinate system and calculating the area
    of](index_split_000.html#p92)'
  prefs: []
  type: TYPE_NORMAL
- en: '[all countries](index_split_000.html#p92)'
  prefs: []
  type: TYPE_NORMAL
- en: countries
  prefs: []
  type: TYPE_NORMAL
- en: sorting, by area size / [Sort the countries by area size](index_split_000.html#p98)
  prefs: []
  type: TYPE_NORMAL
- en: current location
  prefs: []
  type: TYPE_NORMAL
- en: setting / [Setting your current location](index_split_000.html#p130)
  prefs: []
  type: TYPE_NORMAL
- en: '**D**'
  prefs: []
  type: TYPE_NORMAL
- en: data
  prefs: []
  type: TYPE_NORMAL
- en: making homogeneous / [Making data homogeneous](index_split_000.html#p148)
  prefs: []
  type: TYPE_NORMAL
- en: importing / [Generating the tables and importing data](index_split_002.html#p356)
  prefs: []
  type: TYPE_NORMAL
- en: filtering / [Filtering the data](index_split_002.html#p356)
  prefs: []
  type: TYPE_NORMAL
- en: searching for / [Searching for data and crossing information](#p385)
  prefs: []
  type: TYPE_NORMAL
- en: filtering, boundaries used / [Filtering using boundaries](#p385)
  prefs: []
  type: TYPE_NORMAL
- en: database
  prefs: []
  type: TYPE_NORMAL
- en: information, storing on / [Storing information on a database](index_split_002.html#p356)
  prefs: []
  type: TYPE_NORMAL
- en: populating, with real data / [Populating the database with real data](#p368)
  prefs: []
  type: TYPE_NORMAL
- en: database inserts
  prefs: []
  type: TYPE_NORMAL
- en: optimizing / [Optimizing database inserts](#p368)
  prefs: []
  type: TYPE_NORMAL
- en: data parsing
  prefs: []
  type: TYPE_NORMAL
- en: optimizing / [Optimizing data parsing](#p368)
  prefs: []
  type: TYPE_NORMAL
- en: digital elevation models (DEM)
  prefs: []
  type: TYPE_NORMAL
- en: about / [Processing remote sensing images and data](index_split_002.html#p286)
  prefs: []
  type: TYPE_NORMAL
- en: reference / [Processing remote sensing images and data](index_split_002.html#p286)
  prefs: []
  type: TYPE_NORMAL
- en: docstrings
  prefs: []
  type: TYPE_NORMAL
- en: about / [Documenting your code](index_split_000.html#p103)
  prefs: []
  type: TYPE_NORMAL
- en: '**E**'
  prefs: []
  type: TYPE_NORMAL
- en: ElementTree / [Populating the database with real data](#p368)
  prefs: []
  type: TYPE_NORMAL
- en: ESRI shapefile / [Representing geographic data](index_split_000.html#p142)
  prefs: []
  type: TYPE_NORMAL
- en: execution time
  prefs: []
  type: TYPE_NORMAL
- en: measuring / [Measuring execution time](index_split_002.html#p347)
  prefs: []
  type: TYPE_NORMAL
- en: '**F**'
  prefs: []
  type: TYPE_NORMAL
- en: file
  prefs: []
  type: TYPE_NORMAL
- en: opening / [Opening the file and getting its contents](index_split_000.html#p122)
  prefs: []
  type: TYPE_NORMAL
- en: contents, obtaining / [Opening the file and getting its contents](index_split_000.html#p122)
  prefs: []
  type: TYPE_NORMAL
- en: content, preparing for analysis / [Preparing the content for analysis](index_split_000.html#p122)
  prefs: []
  type: TYPE_NORMAL
- en: filters
  prefs: []
  type: TYPE_NORMAL
- en: chaining / [Chaining filters](index_split_001.html#p217)
  prefs: []
  type: TYPE_NORMAL
- en: first example
  prefs: []
  type: TYPE_NORMAL
- en: programming / [Programming and running your first example](index_split_000.html#p88)
  prefs: []
  type: TYPE_NORMAL
- en: running / [Programming and running your first example](index_split_000.html#p88)
  prefs: []
  type: TYPE_NORMAL
- en: function
  prefs: []
  type: TYPE_NORMAL
- en: combining, into application / [Combining functions into an application](index_split_000.html#p126)
  prefs: []
  type: TYPE_NORMAL
- en: '**G**'
  prefs: []
  type: TYPE_NORMAL
- en: GDAL
  prefs: []
  type: TYPE_NORMAL
- en: about / [Installing GDAL and OGR](index_split_000.html#p62)
  prefs: []
  type: TYPE_NORMAL
- en: installing, on Windows / [Windows](index_split_000.html#p62)
  prefs: []
  type: TYPE_NORMAL
- en: installing, on Ubuntu Linux / [Ubuntu Linux](index_split_000.html#p62)
  prefs: []
  type: TYPE_NORMAL
- en: geocache point
  prefs: []
  type: TYPE_NORMAL
- en: abstracting / [Abstracting the geocache point](index_split_000.html#p148)
  prefs: []
  type: TYPE_NORMAL
- en: geocaching app
  prefs: []
  type: TYPE_NORMAL
- en: basic application structure, building / [Building the basic application structure](index_split_000.html#p103)
  prefs: []
  type: TYPE_NORMAL
- en: application tree structure, creating / [Creating the application tree structure](index_split_000.html#p103)
  prefs: []
  type: TYPE_NORMAL
- en: functions / [Functions and methods](index_split_000.html#p103)
  prefs: []
  type: TYPE_NORMAL
- en: methods / [Functions and methods](index_split_000.html#p103)
  prefs: []
  type: TYPE_NORMAL
- en: code, documenting / [Documenting your code](index_split_000.html#p103)
  prefs: []
  type: TYPE_NORMAL
- en: application entry point, creating / [Creating the application entry point](index_split_000.html#p103)
  prefs: []
  type: TYPE_NORMAL
- en: geocaching data
  prefs: []
  type: TYPE_NORMAL
- en: downloading / [Downloading geocaching data](index_split_000.html#p112)
  prefs: []
  type: TYPE_NORMAL
- en: direct download / [Downloading geocaching data](index_split_000.html#p112)
  prefs: []
  type: TYPE_NORMAL
- en: REST API / [Downloading geocaching data](index_split_000.html#p112)
  prefs: []
  type: TYPE_NORMAL
- en: sources / [Geocaching data sources](index_split_000.html#p112)
  prefs: []
  type: TYPE_NORMAL
- en: information, fetching from REST API / [Fetching information from a REST API](index_split_000.html#p112)
  prefs: []
  type: TYPE_NORMAL
- en: downloading, from URL / [Downloading data from a URL](index_split_000.html#p112)
  prefs: []
  type: TYPE_NORMAL
- en: downloading manually / [Downloading data manually](index_split_000.html#p112)
  prefs: []
  type: TYPE_NORMAL
- en: download link / [Downloading data manually](index_split_000.html#p112)
  prefs: []
  type: TYPE_NORMAL
- en: abstracting / [Abstracting geocaching data](index_split_000.html#p148)
  prefs: []
  type: TYPE_NORMAL
- en: importing / [Importing geocaching data](index_split_000.html#p154)
  prefs: []
  type: TYPE_NORMAL
- en: GPX attributes, reading / [Reading GPX attributes](index_split_000.html#p154)
  prefs: []
  type: TYPE_NORMAL
- en: homogeneous data, returning / [Returning the homogeneous data](index_split_000.html#p154)
  prefs: []
  type: TYPE_NORMAL
- en: converting, into Geocache objects / [Converting the data into Geocache objects](index_split_000.html#p154)
  prefs: []
  type: TYPE_NORMAL
- en: multiple sources, merging / [Merging multiple sources of data](index_split_000.html#p154)
  prefs: []
  type: TYPE_NORMAL
- en: GeoDjango / [Creating an Object Relational Mapping](index_split_002.html#p356)
  prefs: []
  type: TYPE_NORMAL
- en: geographic data
  prefs: []
  type: TYPE_NORMAL
- en: representing / [Representing geographic data](index_split_000.html#p142)
  prefs: []
  type: TYPE_NORMAL
- en: geometries
  prefs: []
  type: TYPE_NORMAL
- en: representing / [Representing geometries](index_split_000.html#p142)
  prefs: []
  type: TYPE_NORMAL
- en: geometry relationships
  prefs: []
  type: TYPE_NORMAL
- en: about / [Geometry relationships](index_split_001.html#p203)
  prefs: []
  type: TYPE_NORMAL
- en: touches / [Touches](index_split_001.html#p203)
  prefs: []
  type: TYPE_NORMAL
- en: crosses / [Crosses](index_split_001.html#p203)
  prefs: []
  type: TYPE_NORMAL
- en: contains / [Contains](index_split_001.html#p203)
  prefs: []
  type: TYPE_NORMAL
- en: within / [Within](index_split_001.html#p203)
  prefs: []
  type: TYPE_NORMAL
- en: equals or almost equals / [Equals or almost equals](index_split_001.html#p203)
  prefs: []
  type: TYPE_NORMAL
- en: intersects / [Intersects](index_split_001.html#p203)
  prefs: []
  type: TYPE_NORMAL
- en: disjoint / [Disjoint](index_split_001.html#p203)
  prefs: []
  type: TYPE_NORMAL
- en: geo objects
  prefs: []
  type: TYPE_NORMAL
- en: exporting / [Exporting geo objects](index_split_001.html#p259)
  prefs: []
  type: TYPE_NORMAL
- en: global interpreter lock (GIL)
  prefs: []
  type: TYPE_NORMAL
- en: pan sharpening / [Multiprocessing basics](#p424)
  prefs: []
  type: TYPE_NORMAL
- en: GPX format / [Representing geographic data](index_split_000.html#p142)
  prefs: []
  type: TYPE_NORMAL
- en: '**H**'
  prefs: []
  type: TYPE_NORMAL
- en: hardware bottleneck / [Image resampling](#p436)
  prefs: []
  type: TYPE_NORMAL
- en: hill shading / [Creating a shaded relief image](index_split_002.html#p286)
  prefs: []
  type: TYPE_NORMAL
- en: histogram
  prefs: []
  type: TYPE_NORMAL
- en: for colorizing maps / [Using the histogram to colorize the image](index_split_002.html#p339)
  prefs: []
  type: TYPE_NORMAL
- en: '**I**'
  prefs: []
  type: TYPE_NORMAL
- en: IDE
  prefs: []
  type: TYPE_NORMAL
- en: about / [Installing an IDE](index_split_000.html#p80)
  prefs: []
  type: TYPE_NORMAL
- en: installing / [Installing an IDE](index_split_000.html#p80)
  prefs: []
  type: TYPE_NORMAL
- en: installing, on Windows / [Windows](index_split_000.html#p80)
  prefs: []
  type: TYPE_NORMAL
- en: installing, on Linux / [Linux](index_split_000.html#p80)
  prefs: []
  type: TYPE_NORMAL
- en: image compositions
  prefs: []
  type: TYPE_NORMAL
- en: creating / [Creating image compositions](#p412)
  prefs: []
  type: TYPE_NORMAL
- en: true color compositions / [True color compositions](#p412)
  prefs: []
  type: TYPE_NORMAL
- en: specific regions, processing / [Processing specific regions](#p412)
  prefs: []
  type: TYPE_NORMAL
- en: false color compositions / [False color compositions](#p412)
  prefs: []
  type: TYPE_NORMAL
- en: image processing pipeline
  prefs: []
  type: TYPE_NORMAL
- en: building / [Building an image processing pipeline](index_split_002.html#p300)
  prefs: []
  type: TYPE_NORMAL
- en: image resolution
  prefs: []
  type: TYPE_NORMAL
- en: improving / [Improving the image resolution](#p436)
  prefs: []
  type: TYPE_NORMAL
- en: image resampling / [Image resampling](#p436)
  prefs: []
  type: TYPE_NORMAL
- en: pan sharpening / [Pan sharpening](#p436)
  prefs: []
  type: TYPE_NORMAL
- en: images
  prefs: []
  type: TYPE_NORMAL
- en: representing / [Understanding how images are represented](index_split_002.html#p277)
  prefs: []
  type: TYPE_NORMAL
- en: opening, with OpenCV / [Opening images with OpenCV](index_split_002.html#p277)
  prefs: []
  type: TYPE_NORMAL
- en: numerical types / [Knowing numerical types](index_split_002.html#p277)
  prefs: []
  type: TYPE_NORMAL
- en: blending / [Blending images](index_split_002.html#p336)
  prefs: []
  type: TYPE_NORMAL
- en: memory usage / [Memory and images](#p399)
  prefs: []
  type: TYPE_NORMAL
- en: processing, by chunks / [Processing images in chunks](#p403)
  prefs: []
  type: TYPE_NORMAL
- en: opening, GDAL used / [Using GDAL to open images](#p403)
  prefs: []
  type: TYPE_NORMAL
- en: iterating through, whole image / [Iterating through the whole image](#p403)
  prefs: []
  type: TYPE_NORMAL
- en: iterables / [Iterating through the whole image](#p403)
  prefs: []
  type: TYPE_NORMAL
- en: iterator / [Iterating through the whole image](#p403)
  prefs: []
  type: TYPE_NORMAL
- en: '**J**'
  prefs: []
  type: TYPE_NORMAL
- en: Java Topology Suite (JTS)
  prefs: []
  type: TYPE_NORMAL
- en: about / [Using Shapely to handle geometries](index_split_001.html#p180)
  prefs: []
  type: TYPE_NORMAL
- en: JSON (JavaScript Object Notation) / [Representing geographic data](index_split_000.html#p142)
  prefs: []
  type: TYPE_NORMAL
- en: '**L**'
  prefs: []
  type: TYPE_NORMAL
- en: Landsat 8 images
  prefs: []
  type: TYPE_NORMAL
- en: about / [Getting Landsat 8 images](#p392)
  prefs: []
  type: TYPE_NORMAL
- en: obtaining / [Getting Landsat 8 images](#p392)
  prefs: []
  type: TYPE_NORMAL
- en: lazy evaluation / [Making statistics a lazy property](index_split_002.html#p312)
  prefs: []
  type: TYPE_NORMAL
- en: lines
  prefs: []
  type: TYPE_NORMAL
- en: importing / [Importing lines](index_split_001.html#p194)
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  prefs: []
  type: TYPE_NORMAL
- en: IDE, installing / [Linux](index_split_000.html#p80)
  prefs: []
  type: TYPE_NORMAL
- en: '**M**'
  prefs: []
  type: TYPE_NORMAL
- en: Map Maker app
  prefs: []
  type: TYPE_NORMAL
- en: creating / [Creating the Map Maker app](index_split_001.html#p263)
  prefs: []
  type: TYPE_NORMAL
- en: PythonDatasource, using / [Using PythonDatasource](index_split_001.html#p263)
  prefs: []
  type: TYPE_NORMAL
- en: using, with filtering / [Using the app with filtering](index_split_001.html#p263)
  prefs: []
  type: TYPE_NORMAL
- en: Mapnik
  prefs: []
  type: TYPE_NORMAL
- en: about / [Installing Mapnik](index_split_000.html#p68), [Windows,](index_split_000.html#p68)
    [Knowing Mapnik](index_split_001.html#p227)
  prefs: []
  type: TYPE_NORMAL
- en: installing / [Installing Mapnik](index_split_000.html#p68)
  prefs: []
  type: TYPE_NORMAL
- en: installing, on Windows / [Windows](index_split_000.html#p68)
  prefs: []
  type: TYPE_NORMAL
- en: installing, on Ubuntu Linux / [Ubuntu Linux](index_split_000.html#p68)
  prefs: []
  type: TYPE_NORMAL
- en: experiments, performing with / [Knowing Mapnik](index_split_001.html#p227)
  prefs: []
  type: TYPE_NORMAL
- en: map, making with pure Python / [Making a map with pure Python](index_split_001.html#p227)
  prefs: []
  type: TYPE_NORMAL
- en: map, making with style sheet / [Making a map with a style sheet](index_split_001.html#p227)
  prefs: []
  type: TYPE_NORMAL
- en: maps
  prefs: []
  type: TYPE_NORMAL
- en: styling / [Styling maps](index_split_001.html#p241)
  prefs: []
  type: TYPE_NORMAL
- en: style options / [Styling maps](index_split_001.html#p241)
  prefs: []
  type: TYPE_NORMAL
- en: layers, adding / [Adding layers to the map](index_split_001.html#p241)
  prefs: []
  type: TYPE_NORMAL
- en: massive data
  prefs: []
  type: TYPE_NORMAL
- en: importing / [Importing massive amount of data](#p368)
  prefs: []
  type: TYPE_NORMAL
- en: memoization / [Making statistics a lazy property](index_split_002.html#p312)
  prefs: []
  type: TYPE_NORMAL
- en: memorization / [Converting the spatial reference system and units](index_split_001.html#p198)
  prefs: []
  type: TYPE_NORMAL
- en: mosaicking / [Mosaicking images](index_split_002.html#p286)
  prefs: []
  type: TYPE_NORMAL
- en: multiple attributes
  prefs: []
  type: TYPE_NORMAL
- en: filtering by / [Filtering by multiple attributes](index_split_001.html#p217)
  prefs: []
  type: TYPE_NORMAL
- en: multiprocessing
  prefs: []
  type: TYPE_NORMAL
- en: basics / [Multiprocessing basics](#p424)
  prefs: []
  type: TYPE_NORMAL
- en: about / [Multiprocessing basics](#p424)
  prefs: []
  type: TYPE_NORMAL
- en: '**N**'
  prefs: []
  type: TYPE_NORMAL
- en: new functionality
  prefs: []
  type: TYPE_NORMAL
- en: integrating, into application / [Integrating new functionality into the application](index_split_001.html#p169)
  prefs: []
  type: TYPE_NORMAL
- en: Noun Project
  prefs: []
  type: TYPE_NORMAL
- en: reference / [Point styles](index_split_001.html#p241)
  prefs: []
  type: TYPE_NORMAL
- en: Numpy
  prefs: []
  type: TYPE_NORMAL
- en: about / [Installing NumPy](index_split_000.html#p58)
  prefs: []
  type: TYPE_NORMAL
- en: installing / [Installing NumPy](index_split_000.html#p58)
  prefs: []
  type: TYPE_NORMAL
- en: installing, on Windows / [Windows](index_split_000.html#p58)
  prefs: []
  type: TYPE_NORMAL
- en: installing, on Ubuntu Linux / [Ubuntu Linux](index_split_000.html#p58)
  prefs: []
  type: TYPE_NORMAL
- en: Numpy documentation
  prefs: []
  type: TYPE_NORMAL
- en: reference / [Mosaicking images](index_split_002.html#p286)
  prefs: []
  type: TYPE_NORMAL
- en: '**O**'
  prefs: []
  type: TYPE_NORMAL
- en: Object Relational Mapping (ORM)
  prefs: []
  type: TYPE_NORMAL
- en: creating / [Creating an Object Relational Mapping](index_split_002.html#p356)
  prefs: []
  type: TYPE_NORMAL
- en: environment, preparing / [Preparing the environment](index_split_002.html#p356)
  prefs: []
  type: TYPE_NORMAL
- en: models, changing / [Changing our models](index_split_002.html#p356)
  prefs: []
  type: TYPE_NORMAL
- en: manager, customizing / [Customizing a manager](index_split_002.html#p356)
  prefs: []
  type: TYPE_NORMAL
- en: OGR drivers
  prefs: []
  type: TYPE_NORMAL
- en: about / [Installing GDAL and OGR](index_split_000.html#p62)
  prefs: []
  type: TYPE_NORMAL
- en: Opencaching Nodes / [Geocaching data sources](index_split_000.html#p112)
  prefs: []
  type: TYPE_NORMAL
- en: Open Computer Vision (OpenCV) package / [Automatically previewing the map](index_split_001.html#p234)
  prefs: []
  type: TYPE_NORMAL
- en: OpenCV
  prefs: []
  type: TYPE_NORMAL
- en: about / [OpenCV](index_split_000.html#p53)
  prefs: []
  type: TYPE_NORMAL
- en: Open Geospatial Consortium (OGC)
  prefs: []
  type: TYPE_NORMAL
- en: about / [Knowing well-known text](index_split_001.html#p174)
  prefs: []
  type: TYPE_NORMAL
- en: OpenStreetMap / [Representing geometries](index_split_000.html#p142)
  prefs: []
  type: TYPE_NORMAL
- en: OpenStreetMap points of interest
  prefs: []
  type: TYPE_NORMAL
- en: importing / [Importing OpenStreetMap points of interest](#p368)
  prefs: []
  type: TYPE_NORMAL
- en: OpenStreetMap wiki
  prefs: []
  type: TYPE_NORMAL
- en: URL / [Searching for data and crossing information](#p385)
  prefs: []
  type: TYPE_NORMAL
- en: Operational Land Imager (OLI) / [Working with satellite images](#p392)
  prefs: []
  type: TYPE_NORMAL
- en: other packages
  prefs: []
  type: TYPE_NORMAL
- en: installing, from pip / [Installing other packages directly from pip](index_split_000.html#p76)
  prefs: []
  type: TYPE_NORMAL
- en: installing, on Windows / [Windows](index_split_000.html#p76)
  prefs: []
  type: TYPE_NORMAL
- en: installing, on Ubuntu Linux / [Ubuntu Linux](index_split_000.html#p76)
  prefs: []
  type: TYPE_NORMAL
- en: Overpass API / [Importing OpenStreetMap points of interest](#p368)
  prefs: []
  type: TYPE_NORMAL
- en: '**P**'
  prefs: []
  type: TYPE_NORMAL
- en: painter model / [Polygon style](index_split_001.html#p241)
  prefs: []
  type: TYPE_NORMAL
- en: pan sharpening / [Pan sharpening](#p436)
  prefs: []
  type: TYPE_NORMAL
- en: PEP-8
  prefs: []
  type: TYPE_NORMAL
- en: '[about / Transforming the coordinate system and calculating the area of all](index_split_000.html#p92)'
  prefs: []
  type: TYPE_NORMAL
- en: '[countries](index_split_000.html#p92)'
  prefs: []
  type: TYPE_NORMAL
- en: '[URL / Transforming the coordinate system and calculating the area of all](index_split_000.html#p92)'
  prefs: []
  type: TYPE_NORMAL
- en: '[countries](index_split_000.html#p92)'
  prefs: []
  type: TYPE_NORMAL
- en: pixel
  prefs: []
  type: TYPE_NORMAL
- en: about / [Understanding how images are represented](index_split_002.html#p277)
  prefs: []
  type: TYPE_NORMAL
- en: points of interest (POI) / [Importing OpenStreetMap points of interest](#p368)
  prefs: []
  type: TYPE_NORMAL
- en: polygons
  prefs: []
  type: TYPE_NORMAL
- en: working with / [Working with polygons](index_split_001.html#p174)
  prefs: []
  type: TYPE_NORMAL
- en: importing / [Importing polygons](index_split_001.html#p183)
  prefs: []
  type: TYPE_NORMAL
- en: Postgis extension / [Storing information on a database](index_split_002.html#p356)
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL
  prefs: []
  type: TYPE_NORMAL
- en: URL / [Storing information on a database](index_split_002.html#p356)
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL database / [Storing information on a database](index_split_002.html#p356)
  prefs: []
  type: TYPE_NORMAL
- en: Poços de Caldas / [Processing remote sensing images and data](index_split_002.html#p286)
  prefs: []
  type: TYPE_NORMAL
- en: processing pipeline / [Building an image processing pipeline](index_split_002.html#p300)
  prefs: []
  type: TYPE_NORMAL
- en: profiling / [Measuring execution time](index_split_002.html#p347)
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs: []
  type: TYPE_NORMAL
- en: installing / [Installing Python](index_split_000.html#p45)
  prefs: []
  type: TYPE_NORMAL
- en: installing, on Windows / [Windows](index_split_000.html#p45)
  prefs: []
  type: TYPE_NORMAL
- en: installing, on Ubuntu Linux / [Ubuntu Linux](index_split_000.html#p45)
  prefs: []
  type: TYPE_NORMAL
- en: Python glossary
  prefs: []
  type: TYPE_NORMAL
- en: reference / [Using Python objects as a source of data](index_split_001.html#p254)
  prefs: []
  type: TYPE_NORMAL
- en: Python objects
  prefs: []
  type: TYPE_NORMAL
- en: using, as source of data / [Using Python objects as a source of data](index_split_001.html#p254)
  prefs: []
  type: TYPE_NORMAL
- en: Python package
  prefs: []
  type: TYPE_NORMAL
- en: about / [Python packages and package manager](index_split_000.html#p50)
  prefs: []
  type: TYPE_NORMAL
- en: package manager / [Python packages and package manager](index_split_000.html#p50)
  prefs: []
  type: TYPE_NORMAL
- en: repository, for Windows / [The repository of Python packages for Windows](index_split_000.html#p50)
  prefs: []
  type: TYPE_NORMAL
- en: installing / [Installing packages and required software](index_split_000.html#p53)
  prefs: []
  type: TYPE_NORMAL
- en: required software / [Installing packages and required software](index_split_000.html#p53)
  prefs: []
  type: TYPE_NORMAL
- en: installation, for Windows / [Windows](index_split_000.html#p53)
  prefs: []
  type: TYPE_NORMAL
- en: installation, for Ubuntu Linux / [Ubuntu Linux](index_split_000.html#p53)
  prefs: []
  type: TYPE_NORMAL
- en: '**R**'
  prefs: []
  type: TYPE_NORMAL
- en: raster data
  prefs: []
  type: TYPE_NORMAL
- en: basic statistics / [Getting the basic statistics](index_split_002.html#p312)
  prefs: []
  type: TYPE_NORMAL
- en: RasterData class
  prefs: []
  type: TYPE_NORMAL
- en: creating / [Creating a RasterData class](index_split_002.html#p300)
  prefs: []
  type: TYPE_NORMAL
- en: relief shading / [Creating a shaded relief image](index_split_002.html#p286)
  prefs: []
  type: TYPE_NORMAL
- en: remote sensing images
  prefs: []
  type: TYPE_NORMAL
- en: processing / [Processing remote sensing images and data](index_split_002.html#p286)
  prefs: []
  type: TYPE_NORMAL
- en: mosaicking / [Mosaicking images](index_split_002.html#p286)
  prefs: []
  type: TYPE_NORMAL
- en: values, adjusting / [Adjusting the values of the images](index_split_002.html#p286)
  prefs: []
  type: TYPE_NORMAL
- en: cropping / [Cropping an image](index_split_002.html#p286)
  prefs: []
  type: TYPE_NORMAL
- en: shaded relief image, creating / [Creating a shaded relief image](index_split_002.html#p286)
  prefs: []
  type: TYPE_NORMAL
- en: REST (Representational State Transfer) / [Downloading geocaching data](index_split_000.html#p112)
  prefs: []
  type: TYPE_NORMAL
- en: reStructuredText
  prefs: []
  type: TYPE_NORMAL
- en: reference / [Documenting your code](index_split_000.html#p103)
  prefs: []
  type: TYPE_NORMAL
- en: '**S**'
  prefs: []
  type: TYPE_NORMAL
- en: satellite images
  prefs: []
  type: TYPE_NORMAL
- en: about / [Working with satellite images](#p392)
  prefs: []
  type: TYPE_NORMAL
- en: working with / [Working with satellite images](#p392)
  prefs: []
  type: TYPE_NORMAL
- en: Scalable Vector Graphics (SVG) file / [Point styles](index_split_001.html#p241)
  prefs: []
  type: TYPE_NORMAL
- en: Shapely
  prefs: []
  type: TYPE_NORMAL
- en: about / [Installing Shapely,](index_split_000.html#p72) [Using Shapely to handle
    geometries](index_split_001.html#p180)
  prefs: []
  type: TYPE_NORMAL
- en: installing, on Windows / [Windows](index_split_000.html#p72)
  prefs: []
  type: TYPE_NORMAL
- en: installing, on Ubuntu Linux / [Ubuntu Linux](index_split_000.html#p72)
  prefs: []
  type: TYPE_NORMAL
- en: for handling geometries / [Using Shapely to handle geometries](index_split_001.html#p180)
  prefs: []
  type: TYPE_NORMAL
- en: spaghetti data / [Representing geometries](index_split_000.html#p142)
  prefs: []
  type: TYPE_NORMAL
- en: Spatialite extension / [Storing information on a database](index_split_002.html#p356)
  prefs: []
  type: TYPE_NORMAL
- en: spatial reference system
  prefs: []
  type: TYPE_NORMAL
- en: units, converting / [Converting the spatial reference system and units](index_split_001.html#p198)
  prefs: []
  type: TYPE_NORMAL
- en: SpatiLite / [Representing geographic data](index_split_000.html#p142)
  prefs: []
  type: TYPE_NORMAL
- en: SQLite database / [Storing information on a database](index_split_002.html#p356)
  prefs: []
  type: TYPE_NORMAL
- en: statistics
  prefs: []
  type: TYPE_NORMAL
- en: showing, with colors / [Showing statistics with colors](index_split_002.html#p339)
  prefs: []
  type: TYPE_NORMAL
- en: style options, maps
  prefs: []
  type: TYPE_NORMAL
- en: map style / [Map style](index_split_001.html#p241)
  prefs: []
  type: TYPE_NORMAL
- en: polygon style / [Polygon style](index_split_001.html#p241)
  prefs: []
  type: TYPE_NORMAL
- en: line styles / [Line styles](index_split_001.html#p241)
  prefs: []
  type: TYPE_NORMAL
- en: text styles / [Text styles](index_split_001.html#p241)
  prefs: []
  type: TYPE_NORMAL
- en: point styles / [Point styles](index_split_001.html#p241)
  prefs: []
  type: TYPE_NORMAL
- en: SVG transformations
  prefs: []
  type: TYPE_NORMAL
- en: reference / [Point styles](index_split_001.html#p241)
  prefs: []
  type: TYPE_NORMAL
- en: '**T**'
  prefs: []
  type: TYPE_NORMAL
- en: tables
  prefs: []
  type: TYPE_NORMAL
- en: generating / [Generating the tables and importing data](index_split_002.html#p356)
  prefs: []
  type: TYPE_NORMAL
- en: test data
  prefs: []
  type: TYPE_NORMAL
- en: removing / [Removing the test data](#p368)
  prefs: []
  type: TYPE_NORMAL
- en: Thermal Infrared Sensor (TIRS) / [Working with satellite images](#p392)
  prefs: []
  type: TYPE_NORMAL
- en: TIFF format / [Block iteration](#p430)
  prefs: []
  type: TYPE_NORMAL
- en: '**U**'
  prefs: []
  type: TYPE_NORMAL
- en: U.S Geological Survey (USGS) EarthExplorer / [Getting Landsat 8 images](#p392)
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu
  prefs: []
  type: TYPE_NORMAL
- en: URL / [Storing information on a database](index_split_002.html#p356)
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu Linux
  prefs: []
  type: TYPE_NORMAL
- en: Python, installing / [Ubuntu Linux](index_split_000.html#p45)
  prefs: []
  type: TYPE_NORMAL
- en: Python package, installing / [Ubuntu Linux](index_split_000.html#p53)
  prefs: []
  type: TYPE_NORMAL
- en: Numpy, installing / [Ubuntu Linux](index_split_000.html#p58)
  prefs: []
  type: TYPE_NORMAL
- en: GDAL, installing / [Ubuntu Linux](index_split_000.html#p62)
  prefs: []
  type: TYPE_NORMAL
- en: Mapnik, installing / [Ubuntu Linux](index_split_000.html#p68)
  prefs: []
  type: TYPE_NORMAL
- en: Shapely, installing / [Ubuntu Linux](index_split_000.html#p72)
  prefs: []
  type: TYPE_NORMAL
- en: other packages, installing / [Ubuntu Linux](index_split_000.html#p76)
  prefs: []
  type: TYPE_NORMAL
- en: utility functions
  prefs: []
  type: TYPE_NORMAL
- en: creating, for generating maps / [Creating utility functions to generate maps](index_split_001.html#p234)
  prefs: []
  type: TYPE_NORMAL
- en: data source, changing at runtime / [Changing the data source at runtime](index_split_001.html#p234)
  prefs: []
  type: TYPE_NORMAL
- en: map, previewing automatically / [Automatically previewing the map](index_split_001.html#p234)
  prefs: []
  type: TYPE_NORMAL
- en: '**W**'
  prefs: []
  type: TYPE_NORMAL
- en: well-known binary (WKB)
  prefs: []
  type: TYPE_NORMAL
- en: about / [Knowing well-known text](index_split_001.html#p174)
  prefs: []
  type: TYPE_NORMAL
- en: well-known text (WKT)
  prefs: []
  type: TYPE_NORMAL
- en: about / [Knowing well-known text](index_split_001.html#p174)
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs: []
  type: TYPE_NORMAL
- en: Python, installing / [Windows](index_split_000.html#p45)
  prefs: []
  type: TYPE_NORMAL
- en: Python package, installing / [Windows](index_split_000.html#p53)
  prefs: []
  type: TYPE_NORMAL
- en: Numpy, installing / [Windows](index_split_000.html#p58)
  prefs: []
  type: TYPE_NORMAL
- en: GDAL, installing / [Windows](index_split_000.html#p62)
  prefs: []
  type: TYPE_NORMAL
- en: Mapnik, installing / [Windows](index_split_000.html#p68)
  prefs: []
  type: TYPE_NORMAL
- en: Shapely, installing / [Windows](index_split_000.html#p72)
  prefs: []
  type: TYPE_NORMAL
- en: other packages, installing / [Windows](index_split_000.html#p76)
  prefs: []
  type: TYPE_NORMAL
- en: IDE, installing / [Windows](index_split_000.html#p80)
  prefs: []
  type: TYPE_NORMAL
- en: Document Outline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Geospatial Development By Example with Python](index_split_000.html#p13)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Credits](index_split_000.html#p15)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[About the Author](index_split_000.html#p17)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[About the Reviewers](index_split_000.html#p19)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[www.PacktPub.com](index_split_000.html#p21)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Support files, eBooks, discount offers, and more](index_split_000.html#p23)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Why subscribe?](index_split_000.html#p24)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Free access for Packt account holders](index_split_000.html#p25)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Preface](index_split_000.html#p26)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[What this book covers](index_split_000.html#p28)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[What you need for this book](index_split_000.html#p30)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Who this book is for](index_split_000.html#p32)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Conventions](index_split_000.html#p34)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Reader feedback](index_split_000.html#p36)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Customer support](index_split_000.html#p38)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Downloading the example code](index_split_000.html#p40)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Downloading the color images of this book](index_split_000.html#p41)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Errata](index_split_000.html#p42)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Piracy](index_split_000.html#p43)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Questions](index_split_000.html#p44)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[1\. Preparing the Work Environment](index_split_000.html#p45)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Installing Python](index_split_000.html#p47)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Windows](index_split_000.html#p48)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Ubuntu Linux](index_split_000.html#p49)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Python packages and package manager](index_split_000.html#p50)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The repository of Python packages for Windows](index_split_000.html#p52)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Installing packages and required software](index_split_000.html#p53)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[OpenCV](index_split_000.html#p55)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Windows](index_split_000.html#p56)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Ubuntu Linux](index_split_000.html#p57)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Installing NumPy](index_split_000.html#p58)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Windows](index_split_000.html#p60)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Ubuntu Linux](index_split_000.html#p61)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Installing GDAL and OGR](index_split_000.html#p62)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Windows](index_split_000.html#p66)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Ubuntu Linux](index_split_000.html#p67)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Installing Mapnik](index_split_000.html#p68)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Windows](index_split_000.html#p70)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Ubuntu Linux](index_split_000.html#p71)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Installing Shapely](index_split_000.html#p72)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Windows](index_split_000.html#p74)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Ubuntu Linux](index_split_000.html#p75)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Installing other packages directly from pip](index_split_000.html#p76)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Windows](index_split_000.html#p78)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Ubuntu Linux](index_split_000.html#p79)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Installing an IDE](index_split_000.html#p80)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Windows](index_split_000.html#p82)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Linux](index_split_000.html#p83)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Creating the book project](index_split_000.html#p84)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Programming and running your first example](index_split_000.html#p88)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Transforming the coordinate system and calculating the area of all countries](index_split_000.html#p92)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Sort the countries by area size](index_split_000.html#p98)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_000.html#p101)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[2\. The Geocaching App](index_split_000.html#p103)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Building the basic application structure](index_split_000.html#p105)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Creating the application tree structure](index_split_000.html#p106)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Functions and methods](index_split_000.html#p107)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Documenting your code](index_split_000.html#p108)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Creating the application entry point](index_split_000.html#p109)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Downloading geocaching data](index_split_000.html#p112)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Geocaching data sources](index_split_000.html#p114)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Fetching information from a REST API](index_split_000.html#p115)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Downloading data from a URL](index_split_000.html#p117)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Downloading data manually](index_split_000.html#p119)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Opening the file and getting its contents](index_split_000.html#p122)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Preparing the content for analysis](index_split_000.html#p125)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Combining functions into an application](index_split_000.html#p126)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Setting your current location](index_split_000.html#p130)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Finding the closest point](index_split_000.html#p134)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_000.html#p140)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[3\. Combining Multiple Data Sources](index_split_000.html#p142)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Representing geographic data](index_split_000.html#p144)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Representing geometries](index_split_000.html#p146)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Making data homogeneous](index_split_000.html#p148)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The concept of abstraction](index_split_000.html#p150)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Abstracting the geocache point](index_split_000.html#p151)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Abstracting geocaching data](index_split_000.html#p153)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Importing geocaching data](index_split_000.html#p154)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Reading GPX attributes](index_split_000.html#p158)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Returning the homogeneous data](index_split_001.html#p163)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Converting the data into Geocache objects](index_split_001.html#p165)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Merging multiple sources of data](index_split_001.html#p167)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Integrating new functionality into the application](index_split_001.html#p169)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_001.html#p172)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[4\. Improving the App Search Capabilities](index_split_001.html#p174)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Working with polygons](index_split_001.html#p176)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Knowing well-known text](index_split_001.html#p177)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using Shapely to handle geometries](index_split_001.html#p180)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Importing polygons](index_split_001.html#p183)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Getting the attributes'' values](index_split_001.html#p191)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Importing lines](index_split_001.html#p194)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Converting the spatial reference system and units](index_split_001.html#p198)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Geometry relationships](index_split_001.html#p203)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Touches](index_split_001.html#p205)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Crosses](index_split_001.html#p206)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Contains](index_split_001.html#p207)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Within](index_split_001.html#p208)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Equals or almost equals](index_split_001.html#p209)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Intersects](index_split_001.html#p210)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Disjoint](index_split_001.html#p211)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Filtering by attributes and relations](index_split_001.html#p212)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Filtering by multiple attributes](index_split_001.html#p217)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chaining filters](index_split_001.html#p219)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Integrating with the app](index_split_001.html#p221)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_001.html#p225)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[5\. Making Maps](index_split_001.html#p227)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Knowing Mapnik](index_split_001.html#p229)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Making a map with pure Python](index_split_001.html#p230)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Making a map with a style sheet](index_split_001.html#p232)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Creating utility functions to generate maps](index_split_001.html#p234)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Changing the data source at runtime](index_split_001.html#p236)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Automatically previewing the map](index_split_001.html#p239)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Styling maps](index_split_001.html#p241)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Map style](index_split_001.html#p243)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Polygon style](index_split_001.html#p244)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Line styles](index_split_001.html#p246)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Text styles](index_split_001.html#p248)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Adding layers to the map](index_split_001.html#p249)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Point styles](index_split_001.html#p252)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using Python objects as a source of data](index_split_001.html#p254)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Exporting geo objects](index_split_001.html#p259)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Creating the Map Maker app](index_split_001.html#p263)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using PythonDatasource](index_split_002.html#p267)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using the app with filtering](index_split_002.html#p273)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_002.html#p275)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[6\. Working with Remote Sensing Images](index_split_002.html#p277)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Understanding how images are represented](index_split_002.html#p279)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Opening images with OpenCV](index_split_002.html#p282)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Knowing numerical types](index_split_002.html#p284)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Processing remote sensing images and data](index_split_002.html#p286)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Mosaicking images](index_split_002.html#p289)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Adjusting the values of the images](index_split_002.html#p294)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Cropping an image](index_split_002.html#p296)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Creating a shaded relief image](index_split_002.html#p298)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Building an image processing pipeline](index_split_002.html#p300)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Creating a RasterData class](index_split_002.html#p303)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_002.html#p310)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[7\. Extract Information from Raster Data](index_split_002.html#p312)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Getting the basic statistics](index_split_002.html#p314)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Preparing the data](index_split_002.html#p316)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Printing simple information](index_split_002.html#p317)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Formatting the output information](index_split_002.html#p319)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Calculating quartiles, histograms, and other statistics](index_split_002.html#p321)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Making statistics a lazy property](index_split_002.html#p323)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Creating color classified images](index_split_002.html#p325)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Choosing the right colors for a map](index_split_002.html#p329)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Blending images](index_split_002.html#p336)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Showing statistics with colors](index_split_002.html#p339)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using the histogram to colorize the image](index_split_002.html#p342)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_002.html#p345)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[8\. Data Miner App](index_split_002.html#p347)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Measuring execution time](index_split_002.html#p350)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Code profiling](index_split_002.html#p354)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Storing information on a database](index_split_002.html#p356)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Creating an Object Relational Mapping](index_split_002.html#p358)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Preparing the environment](index_split_002.html#p359)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Changing our models](index_split_002.html#p360)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Customizing a manager](index_split_002.html#p360)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Generating the tables and importing data](index_split_002.html#p365)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Filtering the data](index_split_002.html#p367)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Importing massive amount of data](index_split_003.html#p368)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Optimizing database inserts](index_split_003.html#p370)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Optimizing data parsing](index_split_003.html#p373)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Importing OpenStreetMap points of interest](index_split_003.html#p376)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Removing the test data](index_split_003.html#p380)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Populating the database with real data](index_split_003.html#p381)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Searching for data and crossing information](index_split_003.html#p385)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Filtering using boundaries](index_split_003.html#p388)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_003.html#p390)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[9\. Processing Big Images](index_split_003.html#p392)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Working with satellite images](index_split_003.html#p394)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Getting Landsat 8 images](index_split_003.html#p396)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Memory and images](index_split_003.html#p399)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Processing images in chunks](index_split_003.html#p403)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using GDAL to open images](index_split_003.html#p405)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Iterating through the whole image](index_split_003.html#p408)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Creating image compositions](index_split_003.html#p412)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[True color compositions](index_split_003.html#p414)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Processing specific regions](index_split_003.html#p417)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[False color compositions](index_split_003.html#p419)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_003.html#p422)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[10\. Parallel Processing](index_split_003.html#p424)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Multiprocessing basics](index_split_003.html#p426)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Block iteration](index_split_003.html#p430)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Improving the image resolution](index_split_003.html#p436)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Image resampling](index_split_003.html#p438)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Pan sharpening](index_split_003.html#p446)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_003.html#p450)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Index](index_split_003.html#p452)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
