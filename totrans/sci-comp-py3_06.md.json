["```py\nfrom matplotlib.pyplot import *\n```", "```py\n# plot sin(x) for some interval\nx = linspace(-2*pi,2*pi,200)\nplot(x,sin(x))\n\n# plot marker for every 4th point\nsamples = x[::4]\nplot(samples,sin(samples),'r*')\n\n# add title and grid lines\ntitle('Function sin(x) and some points plotted')\ngrid()\n```", "```py\n# —Polyfit example—\nx = range(5)\ny = [1,2,1,3,5]\np2 = polyfit(x,y,2)\np4 = polyfit(x,y,4)\n\n# plot the polynomials and points\nxx = linspace(-1,5,200) \nplot(xx, polyval(p2, xx), label='fitting polynomial of degree 2')\nplot(xx, polyval(p4, xx),\n                label='interpolating polynomial of degree 4') \nplot(x,y,'*')\n\n# set the axis and legend\naxis([-1,5,0,6])\nlegend(loc='upper left', fontsize='small')\n```", "```py\n# create random 2D points\nimport numpy\nx1 = 2*numpy.random.standard_normal((2,100))\nx2 = 0.8*numpy.random.standard_normal((2,100)) + array([[6],[2]])\nplot(x1[0],x1[1],'*')\nplot(x2[0],x2[1],'r*')\ntitle('2D scatter plot')\n```", "```py\n# log both x and y axis \nx = linspace(0,10,200) \nloglog(x,2*x**2, label = 'quadratic polynomial',\n                            linestyle = '-', linewidth = 3)\nloglog(x,4*x**4, label = '4th degree polynomial',\n                            linestyle = '-.', linewidth = 3)\nloglog(x,5*exp(x), label = 'exponential function', linewidth = 3)\ntitle('Logarithmic plots')\nlegend(loc = 'best')\n```", "```py\nk = 0.2\nx = [sin(2*n*k) for n in range(20)]\nplot(x, color='green', linestyle='dashed', marker='o', \n                       markerfacecolor='blue', markersize=12, linewidth=6)\n```", "```py\nplot(x,'go')\n```", "```py\n# random vector with normal distribution\nsigma, mu = 2, 10\nx = sigma*numpy.random.standard_normal(10000)+mu \nhist(x,50,normed=1)\nz = linspace(0,20,200)\nplot(z, (1/sqrt(2*pi*sigma**2))*exp(-(z-mu)**2/(2*sigma**2)),'g')\n# title with LaTeX formatting \ntitle('Histogram with '.format(mu,sigma))\n```", "```py\ndef avg(x):\n    \"\"\" simple running average \"\"\"\n    return (roll(x,1) + x + roll(x,-1)) / 3\n# sine function with noise\nx = linspace(-2*pi, 2*pi,200)\ny = sin(x) + 0.4*rand(200)\n\n# make successive subplots\nfor iteration in range(3):\n    subplot(3, 1, iteration + 1)\n    plot(x,y, label = '{:d} average{}'.format(iteration, 's' if iteration > 1 else ''))\n    yticks([])\n    legend(loc = 'lower left', frameon = False)\n    y = avg(y) #apply running average \nsubplots_adjust(hspace = 0.7)\n```", "```py\nsavefig('test.pdf')  # save to pdf\n```", "```py\nsavefig('test.svg')  # save to svg (editable format)\n```", "```py\nsavefig('test.pdf', transparent=True)\n```", "```py\nsavefig('test.pdf', bbox_inches='tight')\n```", "```py\nn = ... # number of discretization points along the x-axis\nm = ... # number of discretization points along the x-axis \nX,Y = meshgrid(linspace(a,b,n), linspace(c,d,m))\n```", "```py\nrosenbrockfunction = lambda x,y: (1-x)**2+100*(y-x**2)**2 \nX,Y = meshgrid(linspace(-.5,2.,100), linspace(-1.5,4.,100))\nZ = rosenbrockfunction(X,Y) \ncontour(X,Y,Z,logspace(-0.5,3.5,20,base=10),cmap='gray') \ntitle('Rosenbrock Function: ')\nxlabel('x')\nylabel('y')\n```", "```py\nimport scipy.optimize as so\nrosenbrockfunction = lambda x,y: (1-x)**2+100*(y-x**2)**2\nX,Y=meshgrid(linspace(-.5,2.,100),linspace(-1.5,4.,100))\nZ=rosenbrockfunction(X,Y)\ncs=contour(X,Y,Z,logspace(0,3.5,7,base=10),cmap='gray')\nrosen=lambda x: rosenbrockfunction(x[0],x[1])\nsolution, iterates = so.fmin_powell(rosen,x0=array([0,-0.7]),retall=True)\nx,y=zip(*iterates)\nplot(x,y,'ko') # plot black bullets\nplot(x,y,'k:',linewidth=1) # plot black dotted lines\ntitle(\"Steps of Powell's method to compute a  minimum\")\nclabel(cs)\n```", "```py\ndef mandelbrot(h,w, maxit=20):\n    X,Y = meshgrid(linspace(-2, 0.8, w), linspace(-1.4, 1.4, h))\n    c = X + Y*1j\n    z = c\n    exceeds = zeros(z.shape, dtype=bool)\n\n    for iteration in range(maxit):\n        z  = z**2 + c\n        exceeded = abs(z) > 4\n        exceeds_now = exceeded & (logical_not(exceeds))  \n        exceeds[exceeds_now] = True        \n        z[exceeded] = 2  # limit the values to avoid overflow\n    return exceeds\n\nimshow(mandelbrot(400,400),cmap='gray')\naxis('off')\n```", "```py\nimshow(mandelbrot(40,40),cmap='gray')\n```", "```py\nimshow(mandelbrot(40,40), interpolation='nearest', cmap='gray')\n```", "```py\nfig = figure()\nax = subplot(111)\n```", "```py\nfig = figure(1)\nax = subplot(111)\nx = linspace(0,2*pi,100) \n# We set up a function that modulates the amplitude of the sin function\namod_sin = lambda x: (1.-0.1*sin(25*x))*sin(x)\n# and plot both...\nax.plot(x,sin(x),label = 'sin') \nax.plot(x, amod_sin(x), label = 'modsin')\n```", "```py\nax.lines #[<matplotlib.lines.Line2D at ...>, <matplotlib.lines.Line2D at ...>]\n```", "```py\nfor il,line in enumerate(ax.lines):\n    if line.get_label() == 'sin':\n       break\n```", "```py\ndict_keys(['marker', 'markeredgewidth', 'data', 'clip_box', 'solid_capstyle', 'clip_on', 'rasterized', 'dash_capstyle', 'path', 'ydata', 'markeredgecolor', 'xdata', 'label', 'alpha', 'linestyle', 'antialiased', 'snap', 'transform', 'url', 'transformed_clip_path_and_affine', 'clip_path', 'path_effects', 'animated', 'contains', 'fillstyle', 'sketch_params', 'xydata', 'drawstyle', 'markersize', 'linewidth', 'figure', 'markerfacecolor', 'pickradius', 'agg_filter', 'dash_joinstyle', 'color', 'solid_joinstyle', 'picker', 'markevery', 'axes', 'children', 'gid', 'zorder', 'visible', 'markerfacecoloralt'])\n```", "```py\nax.lines[il].properties()\n```", "```py\nax.lines[il].set_linestyle('-.')\nax.lines[il].set_linewidth(2)\n```", "```py\nydata=ax.lines[il].get_ydata()\nydata[-1]=-0.5\nax.lines[il].set_ydata(ydata)\n```", "```py\nannot1=ax.annotate('amplitude modulated\\n curve', (2.1,1.0),(3.2,0.5),\n       arrowprops={'width':2,'color':'k', 'connectionstyle':'arc3,rad=+0.5', \n                   'shrink':0.05},\n       verticalalignment='bottom', horizontalalignment='left',fontsize=15, \n                   bbox={'facecolor':'gray', 'alpha':0.1, 'pad':10})\nannot2=ax.annotate('corrupted data', (6.3,-0.5),(6.1,-1.1),\n       arrowprops={'width':0.5,'color':'k','shrink':0.1},\n       horizontalalignment='center', fontsize=12)\n```", "```py\nannot1.remove()\n```", "```py\nax.fill_between(x,y1,y2)\n```", "```py\naxf = ax.fill_between(x, sin(x), amod_sin(x), facecolor='gray')\n```", "```py\naxf = ax.fill_between(x, sin(x), amod_sin(x),where=amod_sin(x)-sin(x) > 0, facecolor=’gray’)\n```", "```py\naxf.remove()\n```", "```py\nax.set_xticks(array([0,pi/2,pi,3/2*pi,2*pi]))\nax.set_xticklabels(('$0$','$\\pi/2$','$\\pi$','$3/2 \\pi$','$2 \\pi$'),fontsize=18)\nax.set_yticks(array([-1.,0.,1]))\nax.set_yticklabels(('$-1$','$0$','$1$'),fontsize=18)\n```", "```py\nfrom mpl_toolkits.mplot3d import axes3d\n\nfig = figure()\nax = fig.gca(projection='3d')\n# plot points in 3D\nclass1 = 0.6 * random.standard_normal((200,3))\nax.plot(class1[:,0],class1[:,1],class1[:,2],'o')\nclass2 = 1.2 * random.standard_normal((200,3)) + array([5,4,0])\nax.plot(class2[:,0],class2[:,1],class2[:,2],'o')\nclass3 = 0.3 * random.standard_normal((200,3)) + array([0,3,2])\nax.plot(class3[:,0],class3[:,1],class3[:,2],'o')\n```", "```py\nX,Y,Z = axes3d.get_test_data(0.05)\n\nfig = figure()\nax = fig.gca(projection='3d')\n# surface plot with transparency 0.5 \nax.plot_surface(X,Y,Z,alpha=0.5)\n```", "```py\nfig = figure()\nax = fig.gca(projection = '3d')\nax.plot_wireframe(X,Y,Z,rstride = 5,cstride = 5)\n\n# plot contour projection on each axis plane\nax.contour(X,Y,Z, zdir='z',offset = -100)\nax.contour(X,Y,Z, zdir='x',offset = -40)\nax.contour(X,Y,Z, zdir='y',offset = 40)\n\n# set axis limits\nax.set_xlim3d(-40,40)\nax.set_ylim3d(-40,40)\nax.set_zlim3d(-100,100)\n\n# set labels\nax.set_xlabel('X axis')\nax.set_ylabel('Y axis')\nax.set_zlabel('Z axis')\n```", "```py\nimport visvis.vvmovie as vv\n\n# create initial function values\nx = linspace(-255,255,511)\nX,Y = meshgrid(x,x)\nf = sqrt(X*X+Y*Y) - 40 #radius 40\n\n# evolve and store in a list\nimlist = []\nfor iteration in range(200):\n    imlist.append((f>0)*255)\n    f -= 1 # move outwards one pixel\nvv.images2swf.writeSwf('circle_evolution.swf',imlist)\n```", "```py\n# create initial function values\nx = linspace(-255,255,511)\nX,Y = meshgrid(x,x)\nf = sqrt(X*X+Y*Y) - 40 #radius 40\nfor iteration in range(200):\n    imshow((f>0)*255)\n    gray()\n    axis('off')\n    savefig('circle_evolution_{:d}.png'.format(iteration))\n    f -= 1\n```", "```py\nfrom scipy.misc import lena\nI = lena()\n```"]