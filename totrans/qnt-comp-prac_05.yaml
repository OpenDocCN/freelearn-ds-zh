- en: '*Chapter 5*: Touring the IBM Quantum® Hardware with Qiskit®'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we have mainly used built-in and local quantum computer
    simulators of various forms, but we also connected and ran some of our quantum
    programs on actual IBM quantum computers. In this chapter, we will take a closer
    look at these backends, down to the level of actual physical qubits.
  prefs: []
  type: TYPE_NORMAL
- en: We will take a quick tour of the IBM Quantum® lab by using both IBM Quantum
    Experience® and Qiskit® to access data about the available hardware. Among these
    things, we will look at the graphical view of the layout of the quantum chips,
    some physical aspects of quantum computers such as the T1 and T2 decoherence parameters,
    some basic and advanced error metrics, the way the available qubits can interact
    among themselves, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: What are the IBM Quantum® machines?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locating the available backends
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing backends
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding the least busy backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizing the backends
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring a selected backend using Qiskit®
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throughout this chapter, we will generally use the Bell state program that we
    have used before, in [*Chapter 4*](B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081),
    *Starting at the Ground Level with Terra*, as its ideal results, ![](img/Formula_05_001.png)
    and ![](img/Formula_05_002.png), are known to us, and we can use them to make
    comparisons between runs on different machines and different sets of qubits.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you begin working on the quantum programs in this chapter, make sure
    that you have completed all the steps in [*Chapter 1*](B14436_01_Final_PG_ePub.xhtml#_idTextAnchor021),
    *Preparing Your Environment*, especially the *Installing your API key and accessing
    your provider* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'The quantum programs that we discuss in this chapter can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter05](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter05).'
  prefs: []
  type: TYPE_NORMAL
- en: What are the IBM Quantum® machines?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is less of a recipe and rather more of a basic overview of the
    quantum components and processes that you will be encountering. If you'd rather
    jump ahead and start coding right away, then go to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Qiskit®, you can run your quantum programs on two types of quantum computers:
    `ibmq_qasm_simulator` – available online – lets you run fairly deep quantum programs
    on up to *32 qubits*. Your local simulator performance depends on your hardware;
    remember that simulating a quantum computer gets exponentially harder with each
    qubit added.'
  prefs: []
  type: TYPE_NORMAL
- en: The actual IBM quantum computer hardware is located in an IBM lab and is accessed
    through the cloud. There are good reasons for this, so let's walk through this
    recipe on how to set up and run a quantum computer with the superconducting qubits
    that IBM Quantum® provides.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Superconducting quantum computers are extremely sensitive to noise such as electromagnetic
    radiation, sound waves, and heat. An isolated environment equipped with cryogenic
    cooling provides a location with as little disturbance as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Quantum computers may use so-called **Josephson junctions** kept at cryogenic
    temperatures and manipulated by microwave pulses. Ordinary people do not possess
    this kind of hardware, so, in this book, we will use the freely available IBM
    quantum computers in the cloud for our quantum programming.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps are a very high-level description of the process of running
    your quantum program on an actual IBM quantum computer:'
  prefs: []
  type: TYPE_NORMAL
- en: Write a quantum program in your local Qiskit® environment or on IBM Quantum
    Experience®.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send your program through the cloud to be queued at IBM Quantum®.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The IBM cloud® model for quantum computing means that you will not have unrestricted
    access to the machines. This is a time-share system where everyone gets a some
    access sort of like a classical time-share system that used to be the norm in
    the early days of computing. The analogy is not too bad.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Your program now gets `u1`, `u2`, `u3`, `id`, and `cx`. It turns out that all
    quantum programs that you write can be expressed using only these gates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a part of the transpiling, your circuit might change size and depth somewhat,
    as single gates are converted into sets of gates depending on the backend that
    you run your program on. Simply speaking, the size of a circuit is the raw number
    of gates that are used, and the depth is the length of the circuit from left to
    right, which roughly translates into how many parallel operations the quantum
    computer has to do to run your program. Your original program structure might
    have to change to accommodate the physical layout of the chip that you are running
    on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The gates of your transpiled program are coded into wave packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that your code has been converted into components that can be run on the
    chip, these components are translated into microwave packages that can be sent
    down to the quantum chip. Each gate can be seen as a rotation of the qubit Bloch
    vector around three axes, and each angle can be coded as a microwave pulse at
    different frequencies and durations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The quantum chip is reset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before we can do any quantum computing on the chip, its qubits need to be reset
    to their ground states. This is done by sending a specific microwave pulse to
    each qubit, much like when sending your gates to the qubits, which is described
    in the next step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Your coded gates are then sent to the qubits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each gate is sent to its corresponding qubit as a *wave package* on top of a
    GHz carrier wave tuned exactly to the frequency of the receiving qubit. We now
    leave behind what is called the **room temperature electronics** and enter the
    cryogenic environment. The signal that encodes the gate travels down into the
    innards of the quantum computer through successively cooler layers, finally reaching
    the quantum chip at 15 millikelvin – much colder than outer space. By the end
    of the journey, the wave package finally ends up impinging the qubit through a
    microwave resonator to change the state of the qubit.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is repeated for each gate that you apply to each qubit and is what constitutes
    running the quantum program on the backend.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The qubit is now read.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And by the end of the program, a certain type of wave package interferes with
    the resonator, and the resulting package interference is then sent back up the
    stack, through successively warmer layers and then out into the room-temperature
    electronics.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The interference is interpreted as a `0` or `1`, and thus the result of your
    program is registered. At this state, the delicate balance of your resonating
    qubit has been destroyed – the qubit no longer behaves quantum mechanically and
    needs to be reset to ground state before we can use it again.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This whole process is repeated by the number of shots that you have ordered,
    and all results are stored in the cloud. Finally, your complete run is packaged
    and sent back to you, if you had the patience to wait, as well as being stored
    for later retrieval.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the steps mentioned earlier are highly automated. You only have to write
    your quantum programs and send them off, then IBM Quantum® will do the rest and
    your qubit measurements are returned as ones or zeros.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there are several steps where you can step in and dictate how
    things are done, for example, selecting the backend, picking the qubits to use
    based on qubit parameters, deciding the number of shots to run, and more. In this
    chapter, we will walk through how to dig out the hardware information and configuration
    parameters from the IBM Quantum® machines.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information about the IBM Quantum® hardware, see [https://www.research.ibm.com/ibm-q/technology/devices/](https://www.research.ibm.com/ibm-q/technology/devices/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also read this article on *Superconducting Qubits and the Physics of
    Josephson Junctions* by John M. Martinis and Kevin Osborne at NIST: [https://web.physics.ucsb.edu/~martinisgroup/classnotes/finland/LesHouchesJunctionPhysics.pdf](https://web.physics.ucsb.edu/~martinisgroup/classnotes/finland/LesHouchesJunctionPhysics.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also, here is a delightful Medium article on *QC – How to build a Quantum Computer
    with Superconducting Circuit?* by Jonathan Hui: [https://medium.com/@jonathan_hui/qc-how-to-build-a-quantum-computer-with-superconducting-circuit-4c30b1b296cd](https://medium.com/@jonathan_hui/qc-how-to-build-a-quantum-computer-with-superconducting-circuit-4c30b1b296cd)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locating the available backends
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Qiskit®, a backend represents the system on which you run your quantum program.
    A **backend** can be a simulator, like the local Aer simulator that we have used
    earlier. If you want to run your quantum programs on real quantum computers instead
    of on your local simulator, you must identify an IBM Quantum® machine as a backend
    to use, and then configure your quantum program to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the steps of what we''ll be doing:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by importing the required classes and methods and load your account information.
    In this case, we use the IBMQ class, which contains the main hardware-related
    functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take a look at the machines that are available to your account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a generally available backend.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create and run a Bell state quantum program on the selected backend.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a simulator backend and run the Bell state quantum program again for
    comparison.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will use the IBMQ `provider.backends()` method to identify
    and filter available backends to run your programs and then use the `provider.get_backend()`
    method to select the backend. In the example that follows, we will use the `ibmqx2`
    and `ibmq_qasm_simulator` backends. We will then run a small quantum program on
    one of the hardware backends, and then on the simulator backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python file in the following recipe can be downloaded from here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter05/ch5_r1_identifying_backends.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter05/ch5_r1_identifying_backends.py).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As always, we start by importing the Qiskit® classes and methods to use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before you can start using the `IBMQ` class and the backend methods (if not
    already set), you must set the provider that is associated with your account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `provider.backends()` method is used to locate the IBM Quantum® backends
    that are available to your IBM Quantum® account. With that information, you can
    later set the backend that you want to run your quantum program on by using the
    `provider.get_backend()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code might give an output similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, you can use complex filtering such as lambda functions:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are also only interested in backends that are not down for maintenance.
    To do this, we filter by the `operational` parameter:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Or else, you can use the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'So, with this in mind, when you want to run your quantum program on an IBM
    Quantum® machine, you need to specify the backend to run on, and for this, you
    can use the `get_backend()` method. Let''s manually select a backend from our
    previous list, for example, `ibmqx2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code should give the following result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, with a backend selected, you can execute jobs on the backend with the
    command `job = execute(<your_quantum_circuit>, backend)`. In this case, we will
    use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now create the circuit to test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The sample code should give a result similar to this:![Figure 5.1 – Output of
    the Bell quantum circuit on the selected backend](img/Figure_5.1_B14436.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 5.1 – Output of the Bell quantum circuit on the selected backend
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To select the IBM Quantum® simulator as the backend, and run the circuit on
    that one, you can do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code should give the following result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Output of the Bell quantum circuit on the ibmq_qasm_simulator
    backend](img/Figure_5.2_B14436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Output of the Bell quantum circuit on the ibmq_qasm_simulator backend
  prefs: []
  type: TYPE_NORMAL
- en: So, we have now identified the IBM Quantum® backends that are available to us
    and run a quantum program on a backend that we selected, and on a simulator backend.
    In the next recipe, *Comparing backends*, we will do a simple performance comparison
    of the available backends.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also use the `backends()` method to look at the simulator backends
    that you have at your disposal on your locally installed Qiskit® environment.
    First, start by importing the `Aer` simulator class and then use the `backends()`
    method to take a look at the available backends:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code should give the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'These are all simulators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''qasm_simulator''`: This simulator lets you run your quantum programs and
    get results returned as if you were running on a perfect quantum computer with
    no errors and no noise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''statevector_simulator''`: With this one, you can simulate what the statevector
    for your qubits looks like throughout your circuit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''unitary_simulator''`: This simulator lets you create the unitary matrix
    for your circuit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''pulse_simulator''`: This simulator lets you simulate sending discrete pulses
    to a qubit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have already seen `'qasm_simulator'` and `'statevector_simulator'` used in
    [*Chapter 4*](B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081), *Starting at the
    Ground Level with Terra*, and we will take a closer look at `'unitary_simulator'`
    as a part of [*Chapter 6*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156), *Understanding
    the Qiskit® Gate Library*.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information about the available IBM Quantum® systems: [https://www.ibm.com/quantum-computing/technology/systems/](https://www.ibm.com/quantum-computing/technology/systems/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also use Python help using `help(IBMQ)` and `help(provider.backends)`
    to find more information about these Qiskit® methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing backends
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The IBM Quantum® backends are all slightly different, from the number of qubits
    to the individual behavior and interaction between these. Depending on how you
    write your quantum program, you might want to run the code on a machine with certain
    characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: The backend information that is returned by IBMQ is just a plain Python list
    and you can juggle the returned data with any other list. For example, you can
    write a Python script that finds the available IBM Quantum® backends, then run
    a quantum program on each of the backends and compare the results in a diagram
    that shows a rough measure of the *quality* of the backends' qubits.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use a simple Python loop to run a succession of identical
    Bell-state quantum programs on the available IBM Quantum® backends to get a rough
    estimate of the performance of the backends.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The file required for this recipe can be downloaded from here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter05/ch5_r2_comparing_backends.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter05/ch5_r2_comparing_backends.py).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at how to compare backends:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we import the required classes and methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this case, we use the IBMQ library, which contains the main hardware-related
    functions. We also import the classes to build quantum circuits, monitor jobs,
    and display results. And then load the stored account API key and get the provider:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we will create the quantum program for which we know the expected results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, a Bell state program, which will give the results ![](img/Formula_05_003.png)
    and ![](img/Formula_05_004.png) only on a perfect quantum computer:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code should give the following result:![Figure 5.3 – A Bell state
    quantum circuit
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_5.3_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 5.3 – A Bell state quantum circuit
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we will get all available and operational backends, including the IBM
    Quantum® simulator to use as a benchmark:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Filtering out single-qubit backends
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See how we are using a filter here, to only include backends with more than
    1 qubit. The reason for this is that our code requires two operational qubits
    and the code will fail if we run it on a backend with just one. One of the available
    IBM Quantum® machines—`ibmq_armonk`—is a quantum computer with just 1 qubit; we
    do not want to use that one and use the filter to remove it from our list of backends.
    The purpose of the `ibmq_armonk` backend is to experiment with qubit pulse programming,
    which is beyond the scope of this book.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The preceding code might give the following result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we will run the simple quantum program on these backends in order. The
    resulting counts are stored in a dictionary that we call `counts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Get in line
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Running four quantum programs on several different machines might take a while,
    depending on the number of other users actively using the backends, and the number
    of jobs that are queued up. For example, running this program on eight backends
    and one simulator might take about an hour on a typical Sunday evening.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The preceding code might give the following result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that the jobs are running, we can print out and then plot the results using
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code might give the following result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'These raw results show how well each backend ran the program. The `ibmq-qasm-simulator`
    represents the ideal results on a simulated universal quantum computer; the other
    results show how the program ran on actual IBM Quantum® backends. A perfect quantum
    computer would get results similar to the simulator, resulting in values for ![](img/Formula_05_005.png)
    and ![](img/Formula_05_006.png) only:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Graphical view of the Bell results'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.4_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.4 – Graphical view of the Bell results
  prefs: []
  type: TYPE_NORMAL
- en: What we have created here is a simple comparison of the available IBM Quantum®
    backends using a *basic 2-qubit Bell state quantum program*. On a perfect quantum
    computer, we only expect the results – ![](img/Formula_05_007.png) and ![](img/Formula_05_008.png)
    – which is indeed what we see for `ibmq_qasm_simulator`. Like we discussed in
    [*Chapter 4*](B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081), *Starting at the
    Ground Level* *with Terra*, for real **Noisy Intermediate-Scale Quantum** (**NISQ**)
    machines, we expect some noise and a mixed result, consisting of ![](img/Formula_05_009.png),
    ![](img/Formula_05_010.png), ![](img/Formula_05_011.png), and ![](img/Formula_05_012.png)
    for the IBM Quantum® hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking, the smaller the ![](img/Formula_05_013.png) and ![](img/Formula_05_014.png)
    bars are, the better the backends perform, but there are many factors at play.
    These will be explored later in this chapter and in [*Chapter 8*](B14436_08_Final_PG_ePub.xhtml#_idTextAnchor220),
    *Cleaning Up Your Quantum Act with Ignis*.
  prefs: []
  type: TYPE_NORMAL
- en: Also, keep in mind that we are only comparing the default execution of your
    quantum programs here. Different qubit configurations, readout errors, qubit connection
    issues, and other errors that occur with real hardware play a part and make the
    results somewhat random.
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we ran our quantum program on almost all available backends.
    As you saw in the *Locating the available backends* recipe, you can also filter
    the backends. This recipe required at least two qubits to run, so we added a filter
    to include backends with more than one qubit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the filter capability for other reasons; for example, to run on
    only 5-qubit machines, filter by the number of qubits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You can now see how the available backends behave, and how busy some of them
    might be. Time to figure out a way to speed up your quantum program executions
    by finding the backend with the shortest queue.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the least busy backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you run your quantum program on an IBM Quantum® backend, you will quickly
    realize that you might not be the only one attempting to use that same backend
    at the same time. Depending on the time and day of the week, and the type and
    purpose of the quantum programs being run, not all IBM Quantum® machines are used
    to the same degree.
  prefs: []
  type: TYPE_NORMAL
- en: If you are not concerned with which machine you should run the code on, you
    can use the `least_busy` method to automatically find the best backend to run
    your programs on. The least busy status of a backend generally means that you
    have the least wait time, but this is not necessarily true. Some programs run
    longer than others, and queues (just like in the supermarket) might move at different
    speeds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by importing the required `IBMQ` and `least_busy` methods and load our
    account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `least_busy` method to automatically select the generally available
    least busy backend, and the least busy backend with 5 qubits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, let's display the overview data for all backends to verify that the
    backends that we selected are indeed the least busy backends.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `least_busy` method is convenient if we do not want to wait for our execution
    but might not be the best option. Qiskit® has given us the name of the least busy
    backend. We can now trust Qiskit® and run our quantum code on that backend, or,
    depending on our purposes, we might choose another backend to run on. It might
    turn out that the least busy backend is a machine with noisy qubits or short T1
    or T2 that doesn't suit our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The file required in the following recipe can be downloaded from here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter05/ch5_r3_least_busy.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter05/ch5_r3_least_busy.py).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What `least_busy` is looking for are backends that include a `pending_jobs`
    parameter. If you add additional filtering features that exclude the actual least
    busy backend, the method will return the backend with the least pending jobs that
    meet the filtering criteria.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by importing the required `IBMQ` and `least_busy` methods, and load our
    account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can ask IBM Quantum® which backend is least busy, and set our `backend`
    parameter accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code might give the following result:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example, the least busy backend turned out to be `ibmq_armonk`, which
    is a 1-qubit machine designed for pulse testing. This is not the backend that
    you want to run your multi-qubit circuits on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Filter the least busy results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can feed the `least_busy` method a filtered list of backends, for example,
    to only include 5-qubit machines, or just call the method with the unfiltered
    `provider.backends()` function, like in the following example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code might give the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There we go – this is the least busy backend with five qubits.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To check that the method selected the best backend, we can use the `backend_overview()`
    method to take a look at the number of pending jobs for the available backends:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code might give the following result:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.5 – All available backends with no filtering](img/Figure_5.5_B14436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – All available backends with no filtering
  prefs: []
  type: TYPE_NORMAL
- en: Keep an eye on the **Least busy** parameter. As you can see, the number of pending
    jobs is the smallest for the least busy backend.
  prefs: []
  type: TYPE_NORMAL
- en: So, the takeaway of this recipe is that you can automate which backend you run
    your quantum programs on, but that the returned backend might not be what you
    want if you need to run your program on a specific number of qubits. If this is
    the case, filter the search by the number of qubits to get the backend with the
    shortest queue.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing the backends
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have started poking at various parameters of the IBM Quantum® backends,
    it would be helpful to have a simple way of getting a visual overview of the quantum
    chips and various important parameters, such as how the qubits are interconnected,
    which connections are better than others, what the quality of each qubit is, and
    so on. Qiskit® comes with visualizations built in.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The file required in the following recipe can be downloaded from here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter05/ch5_r4_backend_vis.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter05/ch5_r4_backend_vis.py).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use three methods of the `qiskit.visualization` package to look over
    the backends: `plot_gate_map()`, `plot_error_map()`, and `plot_circuit_layout()`.
    For the last one, we also need to *transpile* a quantum circuit using the `transpile()`
    method to then display which qubits Qiskit® is mapping your gates to on the backend.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by importing the required `qiskit` and `qiskit.visualization` methods,
    and load our account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Grab and get all available IBM Quantum® backends that have more than 1 qubit
    and that are not simulators:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Select the backend that you want to take a look at:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s display the gate map and the error map for the backend:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This first visualization shows the logical layout of the backend, optionally
    with the permitted direction of communication between the qubits displayed (`plot_directed=True`).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Consider this example: `display(plot_gate_map(backend, plot_directed=True))`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The preceding code might give the following output for `ibmq_burlington`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.6 – The gate map for ibmq_burlington](img/Figure_5.6_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.6 – The gate map for ibmq_burlington
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With the error map visualization, you get a view of the readout error and CX
    error rates for the backend. This map gives you an indication of the quality of
    the qubits for providing accurate readout results, and for correctly executing
    on the **controlled-NOT** **(CX)** gates between two qubits:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.7 – The error map form ibmq_burlington](img/Figure_5.7_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.7 – The error map form ibmq_burlington
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'And finally, create a Bell circuit, transpile it, and use it to display the
    circuit layout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The circuit layout is a little bit more complex, as it not only takes a backend
    as input, but you must also feed it the transpiled quantum circuit that you want
    to run on it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For example, still on `ibmq_burlington`, we might want to run a Bell circuit.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The preceding code might give the following result:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.8 – A Bell quantum circuit with two qubits](img/Figure_5.8_B14436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – A Bell quantum circuit with two qubits
  prefs: []
  type: TYPE_NORMAL
- en: 'The transpiled circuit tells us that we will run the circuit on qubits 0 and
    1\. As we started out with a 2-qubit circuit, we gave the transpiler the option
    to assign any two qubits to our circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – The transpiled Bell circuit'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.9_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.9 – The transpiled Bell circuit
  prefs: []
  type: TYPE_NORMAL
- en: 'The circuit layout shows us the expected qubit assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – The CX gate in the Bell circuit is mapped from qubit 0 to qubit
    1'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.10_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.10 – The CX gate in the Bell circuit is mapped from qubit 0 to qubit
    1
  prefs: []
  type: TYPE_NORMAL
- en: The view illustrates what the physical chip looks like, in a symbolic way with
    no technical details.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen the visualization steps in Qiskit®. You can also get the same information
    in IBM Quantum Experience®.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to IBM Quantum Experience® at [https://quantum-computing.ibm.com](https://quantum-computing.ibm.com).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Welcome** page, on the right-hand side, you'll see a list of the available
    backends:![Figure 5.11 – The IBM Quantum Experience® home page](img/Figure_5.11_B14436.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 5.11 – The IBM Quantum Experience® home page
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the backend that you are interested in, for example, `ibmq_burlington`,
    to see the chip layout and additional information:![Figure 5.12 – Details of the
    ibmq_burlington chip](img/Figure_5.12_B14436.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 5.12 – Details of the ibmq_burlington chip
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a short list of the different pieces of data that you can see for the
    selected chip:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Online or offline**: Is the backend currently available?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The current queue**: How many people are using the backend at the moment?
    This number gives you a rough estimate of how busy the backend is, and how long
    it might take before your program will run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Providers**: This will be **open** for the freely available backends.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A blueprint view of the actual quantum chip**: The view illustrates what
    the physical chip looks like, in a symbolic way with no technical details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A connectivity map**: The arrows between the qubits illustrate how they can
    be connected using 2-qubit gates such as the **CNOT** (also known as **controlled-NOT**,
    or **CX**) gate. The connection can be made from the qubit where the arrow starts
    to the qubit where it ends.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Single-qubit error rate**: This is a measure of the quality of the qubit.
    It is a summary of the error rate of the qubit itself and the readout error. Basically,
    this is the probability that a qubit in one state will be read as the other state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CNOT error rate**: This is the measure of the quality of the qubit connection.
    It is the probability that two entangled qubits will read the opposite of the
    entanglement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Number of qubits**: The number of available qubits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Online since**: The date and time that the machine came online.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maximum shots**: The maximum number of shots you can run on the backend.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quantum volume**: The measured quantum volume for the backend. The quantum
    volume is IBM''s suggested benchmark for measuring the performance of today''s
    quantum computers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`u1`, `u2`, `u3`, `cx`, and `id`. With these gates, you can build all other
    quantum gates that are supported by Qiskit®.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use the visualized IBM Quantum® information as guidance for writing
    and executing your quantum programs, and also include aspects such as the qubit
    properties and error map to fine-tune your programs for a specific backend. However,
    in a pure, non-user interface Qiskit® environment, you might want to access this
    data without having to resort to a user interface. This is all covered in the
    next recipe, where we dig out this data directly in Qiskit®.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For a good overview and explanation of the quantum volume concept, see the
    Medium article: *What Is Quantum Volume, Anyway?* by Ryan F. Mandelbaum, senior
    technical writer, IBM Quantum® and Qiskit®: [https://medium.com/qiskit/what-is-quantum-volume-anyway-a4dff801c36f](https://medium.com/qiskit/what-is-quantum-volume-anyway-a4dff801c36f)'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring a selected backend using Qiskit®
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring backend data visually is a handy but strictly manual process. Sometimes
    you might want to include backend information in your program logic when running
    your programs, for example, to select the appropriate backend or dynamically apply
    your gates on the best qubits. To do this, we can pull this data directly from
    the available backend information by using Qiskit®.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use the `backend.configuration()`, `backend.status()`,
    and `backend.properties()` methods to retrieve and list the available and operational
    backends, with some important configuration data such as the number of qubits,
    the maximum number of experiments you can run, and the number of pending jobs
    in the queue. We will also dig out some important qubit parameters such as T1,
    T2, frequency, and readout error for a selected backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, let''s take a look at how it is done:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by importing the IBMQ class and load our account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get all available and operational backends.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fish out and print the backend criteria, such as the name, number of qubits,
    max number of experiments, and pending jobs to compare.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the least busy backend with five qubits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print out qubit properties for the selected backend.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can now take a closer look at the selected properties of the backend and,
    for example, use this information to decide which backend you want to run your
    programs on.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The file required in the following recipe can be downloaded from here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter05/ch5_r5_explore.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter05/ch5_r5_explore.py).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Depending on the type of quantum program that you are writing, certain aspects
    of the backend might be important to you, and you might want to include these
    directly when you code your program. For example, you might be interested in the
    qubits with the smallest gate errors and readout errors, or if you are running
    deep circuits, you might be interested in long T1 and T2 times:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Like always, let''s start by importing the IBMQ class and load our account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Get all available backends.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will use simple Python scripting to compare the available backends based
    on different criteria – the name, number of qubits, maximum allowed number of
    experiments per day, and number of pending jobs. First, we need a list of the
    available backends:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Fish out some backend parameters to compare.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To find the parameters, we loop through the list and print out four selected
    parameters for each backend – `name`, `n_qubits`, `max_experiments`, and `pending_jobs`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code might give the following result:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.13 – The available backends with selected parameters displayed'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_5.13_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 5.13 – The available backends with selected parameters displayed
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, we can dig in and take a look at some of the available qubit data for the
    least busy backend with five qubits, such as the T1 and T2 decoherence values,
    the frequency, and the readout error for the qubits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For this exercise, we can write another simple Python `for` loop that prints
    the properties of the backend's qubits, such as name, value, and unit for the
    relevant data entry.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will loop through the number of qubits of the backend (`least_busy_backend.configuration().n_qubits`)
    and then the number of property parameters for each qubit (`len(least_busy_backend.properties().qubits[0])`):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code should give a result similar to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.14 – Qubit details for a selected backend](img/Figure_5.14_B14436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.14 – Qubit details for a selected backend
  prefs: []
  type: TYPE_NORMAL
- en: With that, we all of a sudden know much more about our qubits. They are not
    just logical entities anymore, but concrete physical objects, albeit physical
    objects behaving quantum mechanically. In the *Comparing qubits on a chip* recipe
    of [*Chapter 8*](B14436_08_Final_PG_ePub.xhtml#_idTextAnchor220), *Cleaning Up
    Your Quantum Act with Ignis*, we will take a look at how you can use the `backend.properties().gates`
    information in your own programs.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we have looked at a selected subset of backend and qubit properties.
    With Qiskit®, you can dig out a lot more information by using the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`backend.configuration()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`backend_name`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`backend_version`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`n_qubits`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`basis_gates`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`gates`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`local`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`simulator`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`conditional`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`open_pulse`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`memory`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`max_shots`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`backend.status()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`backend_name`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`backend_version`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`operational`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`pending_jobs`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`status_msg`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`backend.properties()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`backend_name`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`backend_version`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`last_update_date`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`qubits`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`gates`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`general`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To print out the full list of value for each method, use the `to_dict()` parameter.
    For example: `backend.configuration().to_dict()`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Try to modify the sample code to look up specific parameters such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The backend name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basis gates available for the backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The qubit coupling map that specifies how the individual qubits can communicate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of the gates and their properties for the backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
