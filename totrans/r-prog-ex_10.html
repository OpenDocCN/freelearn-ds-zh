<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Adding Interactivity with Dashboards</h1>
                
            
            
                
<p class="calibre2">Shiny enables you to write powerful interactive web applications entirely in R. Using R, you can create a user interface and server, and Shiny will compiler your R code into the HTML, CSS, and JavaScript code needed to display your application on the web. What makes a Shiny application particularly powerful is that it can execute R code on the backend, so your application can perform any R calculation you can run on your desktop. You may want your application to process some data based on user inputs and provide some interactivity to make data analysis more intuitive.  In this chapter, we will show you how to accomplish this.<br class="title-page-name"/></p>
<p class="calibre2">Shiny implements the <em class="calibre19">functional reactive programming</em> paradigm that powers many of today's most modern web applications. We will explain what it is and how it works within Shiny. We will show how to work with streams of events coming from application users and how to react to them accordingly. To do so, we will work through an example that receives inputs from users and provides data and graphs in return. By the end of the chapter, you'll realize how easy it can be to create powerful web applications that take your R skills to the next level.</p>
<p class="calibre2">Some of the important topics covered in this chapter are as follows:</p>
<ul class="calibre11">
<li class="calibre12">The Shiny web applications architecture</li>
<li class="calibre12">The functional reactive programming paradigm</li>
<li class="calibre12">How reactivity is implemented within Shiny</li>
<li class="calibre12">Receiving inputs from users interactions</li>
<li class="calibre12">Sending outputs in responses to the web browser</li>
<li class="calibre12">Adding interactions to Shiny applications</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Required packages</h1>
                
            
            
                
<p class="calibre2">We have already worked with the first two packages, namely <kbd class="calibre9">ggplot2</kbd> and <kbd class="calibre9">lubridate.</kbd> The <kbd class="calibre9">shiny</kbd> package is used to build web applications directly from R, while the <kbd class="calibre9">shinythemes</kbd> and <kbd class="calibre9">ggthemr</kbd> packages are used to apply themes to style our web application. For more information, take a look at <a href="part0296.html#8Q96G0-f494c932c729429fb734ce52cafce730" class="calibre4">Appendix</a>, <em class="calibre19">Required Packages</em>. Required packages for this chapter are shown in the following table:</p>
<table class="calibre5">
<tbody class="calibre6">
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><strong class="calibre1">Package</strong></p>
</td>
<td class="calibre8">
<p class="calibre2"><strong class="calibre1">Reason</strong></p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">ggplot2</kbd></p>
</td>
<td class="calibre8">
<p class="calibre2">High-quality graphs</p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">lubridate</kbd></p>
</td>
<td class="calibre8">
<p class="calibre2">Easily transform dates</p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">shiny</kbd></p>
</td>
<td class="calibre8">
<p class="calibre2">Create modern web applications</p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">ggthemr</kbd></p>
</td>
<td class="calibre8">
<p class="calibre2">Apply themes to <kbd class="calibre9">ggplot2</kbd> plots</p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">shinythemes</kbd></p>
</td>
<td class="calibre8">
<p class="calibre2">Apply themes to Shiny applications</p>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Introducing the Shiny application architecture and reactivity</h1>
                
            
            
                
<p class="calibre2">In its simplest form, a Shiny application requires a server and a <strong class="calibre1">user interface</strong> (<strong class="calibre1">UI</strong>). These components form the basic architecture behind all Shiny applications. The <kbd class="calibre9">ui</kbd> object controls the layout and appearance of your application, and the <kbd class="calibre9">server</kbd> function contains the logic needed by the application. If you know how web applications work, you can think of them as the <em class="calibre19">frontend</em> and the <em class="calibre19">backend,</em> respectively. The <kbd class="calibre9">shinyApp()</kbd> function creates and launches a Shiny application from an explicit UI/server pair. It will compile R code into web-friendly languages HTML, JavaScript, and CSS.</p>
<p class="calibre2">Below we have the simplest possible Shiny application, which has an empty server and a UI with a basic message. If you are in an interactive R session, your web browser should launch and show the application. If it doesn't, you can navigate to the URL yourself, which is in the form <kbd class="calibre9">http://127.0.0.1:6924/</kbd>, where <kbd class="calibre9">127.0.0.1</kbd> is the IP of your own computer and <kbd class="calibre9">6924</kbd> is the port Shiny is using to listen for connections. As you can see in your web browser, it is nothing amazing, but it's a functioning web application created only using R:</p>
<pre class="mce-root">library(shiny)
server &lt;- function(input, output) { }
ui &lt;- fluidPage("This is a Shiny application.")
shinyApp(ui, server)</pre>
<p>Having a fixed port, instead of a randomly assigned port, which changes on every <kbd class="calibre21">shinyApp()</kbd> call, makes development easier. To use a fixed port, change the function call to <kbd class="calibre21">shinyApp(ui, server, options = list(port = 6924))</kbd> with a port of your preference.</p>
<p class="calibre2">Note that your R session will be busy while the application is active, so you will not be able to run any R commands. R is monitoring the application and executing the application's reactions. To get your R session back, press <em class="calibre19">Ctrl</em> + <em class="calibre19">C</em>, or if you are using RStudio, click on the stop sign icon.</p>
<p class="calibre2">For simplicity, we're creating our Shiny applications in a single file. However, with bigger applications, you will likely split the components into <kbd class="calibre9">ui.R</kbd> and <kbd class="calibre9">server.R</kbd> files (which are the standard files used for Shiny applications).</p>
<p class="calibre2">As we will see throughout the chapter, Shiny provides a great paradigm for developing web applications which is used in many cutting-edge systems nowadays. It's known as <em class="calibre19">functional reactive programming</em>. It's not a simple concept to grasp, but it's very powerful, and we will learn to use its fundamentals in this chapter. However, before we do, I will try to provide a simple explanation of what it is and how it works within Shiny.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">What is functional reactive programming and why is it useful?</h1>
                
            
            
                
<p class="calibre2">Let's start with the reactive programming part. <strong class="calibre1">Reactive programming</strong> is programming with <em class="calibre19">asynchronous data streams</em>. We start by defining these terms at a general level.</p>
<p class="calibre2">A <em class="calibre19">stream</em> is a sequence of ongoing events ordered in time. In reality, almost anything can be thought of as a stream, but simple examples are balls bouncing, where an <em class="calibre19">event</em> is considered every time a ball hits the floor. It can happen repeatedly many times, without specific patterns, stop for a while, then continue, and then stop again. Users clicking in a website is also a <em class="calibre19">stream</em>, where each click is an <em class="calibre19">event</em>. As you can imagine, there are <em class="calibre19">streams</em> everywhere around us.</p>
<p class="calibre2">The other term that needs to be defined is <em class="calibre19">asynchronous,</em> which literally means <em class="calibre19">without syncronization.</em> Normally, <em class="calibre19">synchronous</em> functions wait at the line of a function call until the function being called is finished executing, possibly returning a value. This is the way we have been programming so far. However, <em class="calibre19">asynchronous</em> functions don't necessarily wait for the functions they call to be finished. This means that our functions need to <em class="calibre19">react</em> to it whenever it arrives.</p>
<p class="calibre2">If we join these two terms, we can understand that programming with <em class="calibre19">asynchronous data streams</em> works by writing code that is able to react to <em class="calibre19">events</em> as they happen, continuously and randomly. In the case of this chapter, these <em class="calibre19">events</em> will be user interactions (clicks or keystrokes) with our application, which means that our R code will be responding directly to these clicks and keystrokes as they happen.</p>
<p class="calibre2">If it is still hard to get a grasp on the idea, think about it as a spreadsheet with formulas. When you change a value that other cells depend on or are listening to (analogous to receiving some input from a user in our application), then other cells react accordingly and present the newly computed value (which will be output change we show to the user). It's really that simple. The <em class="calibre19">listening</em> to the stream is called <strong class="calibre1">subscribing.</strong> The functions we are defining are <em class="calibre19">observers</em>, and the stream is the <em class="calibre19">observable</em> being <em class="calibre19">observed</em>. This is precisely the <em class="calibre19">Observer Design Pattern</em>. Take a look at Gamma, Helm, Johnson, and Vlissides's book <em class="calibre19">Design Patterns: Elements of Reusable Object-Oriented Software, by Addison-Wesley, 1994</em>.</p>
<p class="calibre2">On top of that, you are given a great set of tools that allows you to create, filter, and combine any of these <em class="calibre19">streams.</em> That's where the <em class="calibre19">functional programming</em> magic kicks in. Functional programing allows for composition, and that's exactly what we will use it for, to <em class="calibre19">compose streams</em>. A <em class="calibre19">stream</em> can be used as an input to another one. Even multiple <em class="calibre19">streams</em> can be used as inputs to many others. Furthermore, you may use any of these raw or transformed streams anywhere in your code. That's really what makes Shiny such a great tool.</p>
<p class="calibre2"><strong class="calibre1">Functional Reactive programming</strong> raises the level of abstraction of your code, so you can focus on the interdependence of events that define your application's logic, rather than having to constantly fiddle with a large amount of implementation details. <em class="calibre19">Functional-reactive</em> code is also likely to be more concise.</p>
<p class="calibre2">The benefit is more evident in modern applications that are highly interactive. Applications nowadays have an abundance of real-time events that enable a highly interactive experiences, and <em class="calibre19">functional reactive programming</em> is a great tool for that.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How is functional reactivity handled within Shiny?</h1>
                
            
            
                
<p class="calibre2">Reactivity is what makes your Shiny applications responsive. It seems like the application instantly updates itself whenever the user makes a change. However, in reality, Shiny is rerunning your R expressions in a carefully scheduled way every couple of microseconds, which creates the illusion of responsiveness. You don't need to know how reactivity occurs to use it, but understanding reactivity will make you a better Shiny programmer.</p>
<p class="calibre2">Remember that when we executed our very simple Shiny application in a previous section, the R console stopped being interactive? Well, that was happening because executing the <kbd class="calibre9">shinyApp()</kbd> function makes R busy by constantly monitoring and updating expressions as necessary, which is what creates the responsive experience for users.</p>
<p class="calibre2">Now, imagine you have a complex application with lots of interactivity, then running every expression every couple of microseconds would completely saturate your processor, and your users would have a terrible user experience. That's why Shiny needs to be smart enough to only update those expressions that require it. Whenever a user submits an action (<em class="calibre19">event</em>), expressions that handle such events become <em class="calibre19">invalidated,</em> effectively marking themselves as being in need of an <em class="calibre19">update,</em> and this behavior is propagated among all expressions that depend on them. When a few microseconds have passed, R will check which expressions are marked for being updated, and only update those.</p>
<p class="calibre2">The mechanism just described can reduce the number of expressions that are recomputed from thousands to none, in case there has not been any user action, and to a few at most, since it's very hard for a user to accomplish a lot in a few microseconds which in turn would result in a few required updates, instead of a full application update each time. This mechanism allows R to handle complex Shiny applications, and it's the key to reactivity. It allows the application to be updated as fast as possible, making input/output coordination almost instantly.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The building blocks for reactivity in Shiny</h1>
                
            
            
                
<p class="calibre2">The building blocks of reactivity in Shiny are built around three types of functions: input, output, and rendering functions. Input functions most of the time end with the <kbd class="calibre9">Input</kbd> string (not always) and I will refer to them as <kbd class="calibre9">Input()</kbd> functions. Output functions always end with the <kbd class="calibre9">Output</kbd> string and I will refer to them as <kbd class="calibre9">Output()</kbd> functions. Finally, rendering functions begin with the <kbd class="calibre9">render</kbd> string and similarly I will refer to them as <kbd class="calibre9">render*()</kbd> functions.</p>
<p class="calibre2"><kbd class="calibre9">Input*()</kbd> functions are used within the <kbd class="calibre9">ui</kbd> object and they generate <em class="calibre19">reactive values</em>, which are values received from an interaction through a web browser, and are passed through the <kbd class="calibre9">input</kbd> parameter in the <kbd class="calibre9">server</kbd> function. The <kbd class="calibre9">render*()</kbd> functions are used within the <kbd class="calibre9">server</kbd> function and make use of <em class="calibre19">reactive values</em> to produce <em class="calibre19">observables</em> that go back into the <kbd class="calibre9">ui</kbd> object, through the <kbd class="calibre9">server</kbd> function's <kbd class="calibre9">output</kbd> parameter. Finally, <kbd class="calibre9">*Output()</kbd> functions are used in the <kbd class="calibre9">ui</kbd> object to show the content of these observables in the web browser.</p>
<p class="calibre2"><em class="calibre19">Reactive values</em> are received in the <kbd class="calibre9">server()</kbd> function through the <kbd class="calibre9">input</kbd> parameter, which is a list whose elements contain elements that are <em class="calibre19">linked</em> with the <kbd class="calibre9">ui</kbd> object through strings that act as unique identifiers. The <kbd class="calibre9">output</kbd> parameter in the <kbd class="calibre9">server</kbd> function is also a list, but it's used to receive observables that will be sent to the web browser.</p>
<p class="calibre2">Functions that know how to deal with <em class="calibre19">reactive values</em> are known as <em class="calibre19">reactive functions</em>. Not every R function is a reactive function, and they need special construction mechanisms provided by Shiny, and if you try to use a <em class="calibre19">reactive value</em> in a <em class="calibre19">non-reactive function</em>, you will get an error (this is an easy mistake when starting to use Shiny). The <kbd class="calibre9">render*()</kbd> functions are used to create reactive functions. Another way of doing so is with the <kbd class="calibre9">reactive()</kbd> function we will explain later in the chapter.</p>
<p class="calibre2">Reactive functions are commonly used to generate observables that may be used by other reactive functions or by <kbd class="calibre9">render*()</kbd> functions. However, reactive functions can also produce side effects (for example, writing to a database). If reactive functions have <kbd class="calibre9">return</kbd> values, they are <em class="calibre19">cached</em> so that the function is not required to be re-executed if its corresponding <em class="calibre19">reactive values</em> have not changed.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The input, output, and rendering functions</h1>
                
            
            
                
<p class="calibre2">Each <kbd class="calibre9">*Input()</kbd> function requires several arguments. The first one is a string with the name for the widget, which will only be used by you. The second one is a label which will be shown to the user in your application. The remaining arguments for each <kbd class="calibre9">*Input()</kbd> function vary depending on its functionality. They include things like initial values, ranges, and increments. You can find the exact arguments needed by a widget on the widget function's help page, (for example, <kbd class="calibre9">? selectInput</kbd>). The following table shows all available <kbd class="calibre9">*Input()</kbd> functions with an indication of what they are used for:</p>
<table class="calibre5">
<tbody class="calibre6">
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><strong class="calibre1">The</strong> <kbd class="calibre9">Input*()</kbd> <strong class="calibre1">function</strong></p>
</td>
<td class="calibre8">
<p class="calibre2"><strong class="calibre1">Use</strong></p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">actionButton()</kbd></p>
</td>
<td class="calibre8">
<p class="calibre2">Action button</p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">checkboxGroupInput()</kbd></p>
</td>
<td class="calibre8">
<p class="calibre2">Group of checkboxes</p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">checkboxInput()</kbd></p>
</td>
<td class="calibre8">
<p class="calibre2">Single checkbox</p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">dateInput()</kbd></p>
</td>
<td class="calibre8">
<p class="calibre2">Date selection</p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">dateRangeInput()</kbd></p>
</td>
<td class="calibre8">
<p class="calibre2">Date range selection</p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">fileInput()</kbd></p>
</td>
<td class="calibre8">
<p class="calibre2">File upload</p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">helpText()</kbd></p>
</td>
<td class="calibre8">
<p class="calibre2">Help text for input forms</p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">numericInput()</kbd></p>
</td>
<td class="calibre8">
<p class="calibre2">Numeric input field</p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">radioButtons()</kbd></p>
</td>
<td class="calibre8">
<p class="calibre2">Set of options in radio buttons</p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">selectInput()</kbd></p>
</td>
<td class="calibre8">
<p class="calibre2">Set of options in drop-down</p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">sliderInput()</kbd></p>
</td>
<td class="calibre8">
<p class="calibre2">Numeric input slide bar</p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">submitButton()</kbd></p>
</td>
<td class="calibre8">
<p class="calibre2">Submit button</p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">textInput()</kbd></p>
</td>
<td class="calibre8">
<p class="calibre2">Text input field</p>
</td>
</tr>
</tbody>
</table>
<p class="calibre2"> </p>
<p class="calibre2">Each of the <kbd class="calibre9">*Output()</kbd> functions requires a single argument, which is a character string that Shiny will use to identify the corresponding <em class="calibre19">observer</em> from the <kbd class="calibre9">output</kbd> parameter in the <kbd class="calibre9">server</kbd> function. Users will not see this name, it will only be used by you. The following table shows the list of all the available <kbd class="calibre9">*Output()</kbd> functions with an indication of what they are used for. You may find more information about them using their corresponding help pages (for example, <kbd class="calibre9">? tableOutput</kbd>):</p>
<table class="calibre5">
<tbody class="calibre6">
<tr class="calibre7">
<td class="calibre8"><strong class="calibre1">The <kbd class="calibre41">*Output()</kbd> function</strong></td>
<td class="calibre8"><strong class="calibre1">Use</strong></td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">dataTableOutput()</kbd></p>
</td>
<td class="calibre8">
<p class="calibre2">Data table</p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">htmlOutput()</kbd></p>
</td>
<td class="calibre8">
<p class="calibre2">Raw HTML</p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">imageOutput()</kbd></p>
</td>
<td class="calibre8">
<p class="calibre2">Images</p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">plotOutput()</kbd></p>
</td>
<td class="calibre8">
<p class="calibre2">Graphs</p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">tableOutput()</kbd></p>
</td>
<td class="calibre8">
<p class="calibre2">Tables</p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">textOutput()</kbd></p>
</td>
<td class="calibre8">
<p class="calibre2">Text</p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">uiOutput()</kbd></p>
</td>
<td class="calibre8">
<p class="calibre2">Raw HTML</p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">verbatimTextOutput()</kbd></p>
</td>
<td class="calibre8">
<p class="calibre2">Verbatim text</p>
</td>
</tr>
</tbody>
</table>
<p class="calibre2">Finally, each <kbd class="calibre9">render*()</kbd> function takes a single argument, an R expression surrounded by braces (<kbd class="calibre9">{}</kbd>). These expressions can contain one simple line of text or they can involve many lines of code and function calls. The following table shows the list of all <kbd class="calibre9">render*()</kbd> functions with an indication of what they are used for. You guessed it, you may find more information about them using their corresponding help pages (for example, ? <kbd class="calibre9">renderText</kbd>):</p>
<table class="calibre5">
<tbody class="calibre6">
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><strong class="calibre1">The <kbd class="calibre9">render*()</kbd> function</strong></p>
</td>
<td class="calibre8">
<p class="calibre2"><strong class="calibre1">Use</strong></p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8"><kbd class="calibre41">renderDataTable()</kbd></td>
<td class="calibre8">Data table</td>
</tr>
<tr class="calibre7">
<td class="calibre8"><kbd class="calibre41">renderImage()</kbd></td>
<td class="calibre8">Image</td>
</tr>
<tr class="calibre7">
<td class="calibre8"><kbd class="calibre41">renderPlot()</kbd></td>
<td class="calibre8">Graph</td>
</tr>
<tr class="calibre7">
<td class="calibre8"><kbd class="calibre41">renderPrint()</kbd></td>
<td class="calibre8">Any printed output</td>
</tr>
<tr class="calibre7">
<td class="calibre8"><kbd class="calibre41">renderTable()</kbd></td>
<td class="calibre8">Data frame, matrix, or other table-like structure</td>
</tr>
<tr class="calibre7">
<td class="calibre8"><kbd class="calibre41">renderText()</kbd></td>
<td class="calibre8">String</td>
</tr>
<tr class="calibre7">
<td class="calibre8"><kbd class="calibre41">renderUI()</kbd></td>
<td class="calibre8">Shiny tag object or HTML</td>
</tr>
</tbody>
</table>
<p class="calibre2"> </p>
<p class="calibre2">Shiny applications combine the <kbd class="calibre9">*Input()</kbd>, <kbd class="calibre9">*Output()</kbd>, and <kbd class="calibre9">render*()</kbd> functions to produce powerful web applications. The simplest applications will be composed of only reactive values and observers, without too much logic between them. However, it's also possible to place as many expressions as we want between them, which allows for more complex applications.</p>
<p class="calibre2">There are many more ways to work with reactivity in Shiny. A very friendly introduction video can be found at RStudio's <em class="calibre19">Learn Shiny</em> video tutorials (<a href="https://shiny.rstudio.com/tutorial/" target="_blank" class="calibre4">https://shiny.rstudio.com/tutorial/</a>).</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Designing our high-level application structure</h1>
                
            
            
                
<p class="calibre2">That's enough theory, let's get to action building our own application. The application we will build will make use of the previous chapter, so if you haven't read that one, please do. The dashboard we will build will make more sense if you do. This dashboard will show graphs with the price data points from the previous chapter's data simulation, as well as the SMA calculations we developed. Furthermore, it will allow us to explore the price data using a dynamic table.. By <em class="calibre19">dynamic</em>, we mean that responds to user input.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Setting up a two-column distribution</h1>
                
            
            
                
<p class="calibre2">The layout you choose to use for your application depends on its objectives. In this case, a two-column layout will suffice. To accomplish this, we use the <kbd class="calibre9">fluidPage()</kbd> function and assign it to the <kbd class="calibre9">ui</kbd> object. This function adjusts content according to the web browser's dimensions:</p>
<div><img src="img/00067.gif" class="calibre67"/></div>
<p class="calibre2">Inside the <kbd class="calibre9">fluidPage()</kbd>, we use the <kbd class="calibre9">titlePanel()</kbd> function to provide a title for our application and the <kbd class="calibre9">sidebarLayout()</kbd> function to create a two-column layout. This last function requires two other functions to be called inside it to create the corresponding content for each column. These two functions are called <kbd class="calibre9">sidebarPanel()</kbd> and <kbd class="calibre9">mainPanel()</kbd>, and they receive the content we want to create inside of them as parameters. The column on the left will be used to display available options for users and the one on the right to show actual content as a result of the user inputs, so we use some strings as placeholders that describe exactly that:</p>
<pre class="mce-root">ui &lt;- fluidPage(
    titlePanel("Cryptocurrency Markets"),
    sidebarLayout(
        sidebarPanel("Options"),
        mainPanel("Content")
    )
)</pre>
<p>The <kbd class="calibre21">fluidPage</kbd> simply generates HTML, which is sent to the web browser. You may print the <kbd class="calibre21">ui</kbd> object in the R console as we progress along the chapter to see the HTML it created.</p>
<p class="calibre2">This code will create a very basic structure as the one shown in the next image. As we move along, we will make the application more and more complex, but we need to start somewhere.</p>
<p class="calibre2">As you can see, nesting function calls will be a common pattern in the <kbd class="calibre9">ui</kbd> object to structure the application. This can be tricky, and if for some reason, you miss a comma (",") somewhere, you may find a cryptic message as the one shown . If that's the case, making sure your commas are correctly placed is a good start for fixing this error:</p>
<pre class="mce-root">Error in tag("div", list(...)) : argument is missing, with no default
Calls: fluidPage ... tabsetPanel -&gt; tabPanel -&gt; div -&gt;  -&gt; tag</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Introducing sections with panels</h1>
                
            
            
                
<p class="calibre2">To show a section for graphs and a separate one for data tables, we will use the <kbd class="calibre9">tabsPanel()</kbd> function in conjunction with the <kbd class="calibre9">tabPanel()</kbd> function. The <kbd class="calibre9">tabsPanel()</kbd> function receives and arranges one or more <kbd class="calibre9">tablePanel()</kbd> function calls, where each of them receives the name for a tab and its actual content:</p>
<pre class="mce-root">ui &lt;- fluidPage(
    titlePanel("Cryptocurrency Markets"),
    sidebarLayout(
        sidebarPanel("Options"),
        mainPanel(
            tabsetPanel(
                tabPanel("Simple Moving Averages", "Content 1"),
                tabPanel("Data Overview", "Content 2")
            )
        )
    )
)</pre>
<p class="calibre2">Since we created two tabs with the titles, <em class="calibre19">Simple Moving Averages</em> and <em class="calibre19">Data Overview</em>, respectively, that's what we see as the tab names. If you are running the application yourself at this point, you may click on them and you will see the <kbd class="calibre9">Content 1</kbd> or <kbd class="calibre9">Content 2</kbd> strings, depending on which one you click on:</p>
<div><img src="img/00068.jpeg" class="calibre68"/></div>
<p class="calibre2">Note that the <kbd class="calibre9">tabsetPanel()</kbd> function took the place of the <kbd class="calibre9">"Content"</kbd> string we previously had in its place. This will be a common pattern. As we start introducing more and more elements to the application, they will replace previous placeholders. Once you get used to Shiny, you may completely avoid the creation of placeholders.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Inserting a dynamic data table</h1>
                
            
            
                
<p class="calibre2">Now we will add a dynamic table with the data we simulated in the previous chapter, so first of all, we need to bring that data into the application, and we do so with the line shown below. You should place this data-loading line above the <kbd class="calibre9">ui</kbd> object in your app. This way, it will only be run once, when starting up the Shiny application, as any code that would normally be run when executing an R script:</p>
<pre class="mce-root">ORIGINAL_DATA &lt;- <br class="title-page-name"/>read.csv("../chapter-09/data.csv", stringsAsFactors = FALSE)</pre>
<p class="calibre2">At this point, we need to introduce the <kbd class="calibre9">DT</kbd> package. It provides an easy way to create dynamic tables for Shiny applications. Since we will reference it through its package name, we don't need to load it with <kbd class="calibre9">library(DT)</kbd>. Referencing it by its package name helps us separate the native Shiny functions from those that come from external packages.</p>
<p class="calibre2">To implement this, we need to modify the <kbd class="calibre9">server</kbd> function we had not touched up to this point. We need to introduce some logic into it that will allow us to move data from R into the web interface. To accomplish this, we assign it to the <kbd class="calibre9">table</kbd> element in its <kbd class="calibre9">output</kbd> parameter, which will function as an observer. The element name we assign to it can be any valid list element we wish, but it's a good idea to just use names that describe the contents of the observer. Keep in mind that these names must be unique as Shiny will use them to identify what objects to pass back and forth between the <kbd class="calibre9">ui</kbd> object and the <kbd class="calibre9">server</kbd> function. The observer is created with the <kbd class="calibre9">renderDataTable()</kbd> function from the <kbd class="calibre9">DT</kbd> package. This function works as any other <kbd class="calibre9">render*()</kbd> function, it receives a single parameter, which is an expression that returns a value which will be the content of the observer.</p>
<p class="calibre2">In this case, the data table created with the <kbd class="calibre9">datatable()</kbd> function, again from the <kbd class="calibre9">DT</kbd> package. To create this data table, we are simply passing the <kbd class="calibre9">ORIGINAL_DATA</kbd> object we loaded previously. Now that the server-side adjustment is finished, we add a <kbd class="calibre9">fluidRow()</kbd> instead of <kbd class="calibre9">"Content 2"</kbd> in the <kbd class="calibre9">ui</kbd> object to introduce a row that will adjust its length according to the web browser's dimensions, and inside of it, we call the <kbd class="calibre9">dataTableOutput()</kbd> function from the <kbd class="calibre9">DT</kbd> package. Note that the string sent as the only parameter to this function is the name of the element we assigned to the <kbd class="calibre9">output</kbd> parameter in the <kbd class="calibre9">server</kbd> function. This is the mechanism that Shiny uses to move data from the <kbd class="calibre9">server</kbd> to the <kbd class="calibre9">ui</kbd>:</p>
<pre class="mce-root">ui &lt;- fluidPage(
    titlePanel("Cryptocurrency Markets"),
    sidebarLayout(
        sidebarPanel("Options"),
        mainPanel(
            tabsetPanel(
                tabPanel("Simple Moving Averages", <br class="title-page-name"/>                          "Content 1"),
                tabPanel("Data Overview", <br class="title-page-name"/>                          fluidRow(DT::dataTableOutput("table"))                                    <br class="title-page-name"/>                )
            )
        )
    )
)

server &lt;- function(input, output) {
    output$table &lt;- <br class="title-page-name"/>    DT::renderDataTable(DT::datatable({return(ORIGINAL_DATA)}))
}</pre>
<p class="calibre2">Now that our code is ready, we should see a table appear in the Data Overview tab. This table is dynamic in the sense that you may order its columns by clicking on the column titles, as well as change the number of observations shown, and search through its contents. Also note that a pagination mechanism was automatically added for us along with an observation counter. These tables are very easy to create, yet very useful, and we will see later in this chapter how to expand their functionality even more.</p>
<div><img src="img/00069.jpeg" class="calibre69"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Introducing interactivity with user input</h1>
                
            
            
                
<p class="calibre2">The interactivity we saw previously with the dynamic data table works within the web browser itself using JavaScript, and it does not need to go through the <kbd class="calibre9">server</kbd> function to provide the interactivity, only to pass the table itself. However, many interesting interactivity features need to go through the <kbd class="calibre9">server</kbd> so that we can provide custom responses for them. In this section, we show how to add various types of inputs to our application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Setting up static user inputs</h1>
                
            
            
                
<p class="calibre2">First, we will show how to filter the timestamps in the data to only show observations that fall within a range defined by the user. To do this, we need to first define four timestamps: the minimum, the initial left limit, the initial right limit, and the maximum. These four values will be used by our date range widget to define the allowed range for the user (the minimum and maximum values are used for this), as well as the initial date range (the initial left and right limits are used for this), which may be different from the limits of the allowed range.</p>
<p class="calibre2">Therefore, we need to extract such values, and we do so by making use of the <kbd class="calibre9">TimeStamp</kbd> class we created in <a target="_blank" href="part0178.html#59O440-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 8</a>, <em class="calibre19">Object-Oriented System to Track Cryptocurrencies</em>. Note that we use the <kbd class="calibre9">days()</kbd> function from the <kbd class="calibre9">lubridate</kbd> package (you should add the  <kbd class="calibre9">library(lubridate)</kbd> line at the top of your file), just as we did in the mentioned chapter.</p>
<p class="calibre2">Since we only need to create these objects once, they should go just below the code that is used to load the <kbd class="calibre9">ORIGINAL_DATA</kbd>, before the <kbd class="calibre9">ui</kbd> object definition:</p>
<pre class="mce-root">DATE_MIN &lt;- <br class="title-page-name"/>timestamp_to_date_string.TimeStamp(min(ORIGINAL_DATA$timestamp))
<br class="title-page-name"/>DATE_MAX &lt;- <br class="title-page-name"/>timestamp_to_date_string.TimeStamp(max(ORIGINAL_DATA$timestamp))
<br class="title-page-name"/>DATE_END &lt;- <br class="title-page-name"/>timestamp_to_date_string.TimeStamp(time_to_timestamp.TimeStamp(
    timestamp_to_time.TimeStamp(min(ORIGINAL_DATA$timestamp)) + days(2)))</pre>
<p class="calibre2">The <kbd class="calibre9">timestamp_to_date_string()</kbd> function in the <kbd class="calibre9">TimeStamp</kbd> class had not been created and we added it for this chapter. It is very simple and is shown in the following code. Its objective is to simply get the first 10 characters of a <kbd class="calibre9">TimeStamp</kbd>, which correspond to the format YYYY-MM-DD:</p>
<pre class="mce-root">timestamp_to_date_string.TimeStamp &lt;- function(timestamp) {
    return(substr(timestamp, 1, 10))
}</pre>
<p class="calibre2">Now that we have created these objects, we may use the following code to expand the <kbd class="calibre9">ui</kbd> object. What we did was replace the <kbd class="calibre9">"Options"</kbd> string with a function call to <kbd class="calibre9">dateRangeInput()</kbd>, which is the function used to create a date range, as the name implies. It receives as parameters the unique identifier that will be used to retrieve its <em class="calibre19">reactive values</em> within the <kbd class="calibre9">server</kbd> through the <kbd class="calibre9">input</kbd> parameter, the <kbd class="calibre9">label</kbd> shown to the user, the <kbd class="calibre9">start</kbd>, <kbd class="calibre9">end</kbd>, <kbd class="calibre9">min</kbd>, and <kbd class="calibre9">max</kbd> values mentioned earlier, the <kbd class="calibre9">separator</kbd> we want to use among the web browser input boxes, the date <kbd class="calibre9">format</kbd> we want to use, and what day of the week it is considered to start on (<kbd class="calibre9">0</kbd> for Sunday, <kbd class="calibre9">1</kbd> for Monday, and so on):</p>
<pre class="mce-root">ui &lt;- fluidPage(
    titlePanel("Cryptocurrency Markets"),
    sidebarLayout(
        sidebarPanel(
            dateRangeInput(
                "date_range",
                label = paste("Date range:"),
                start = DATE_MIN,
                end = DATE_END,
                min = DATE_MIN,
                max = DATE_MAX,
                separator = " to ",
                format = "yyyy-mm-dd",
                weekstart = 1
            )
        ),
        mainPanel(
            tabsetPanel(
                tabPanel("Simple Moving Averages", <br class="title-page-name"/>                         "Content 1"),
                tabPanel("Data Overview", <br class="title-page-name"/>                         fluidRow(DT::dataTableOutput("table"))<br class="title-page-name"/>                )
            )
        )
    )
)</pre>
<p class="calibre2">On the server side, we will add more logic within the <em class="calibre19">reactive experssion</em> passed as a parameter to the <kbd class="calibre9">datatable()</kbd> function. Instead of simply sending the raw <kbd class="calibre9">ORIGINAL_DATA</kbd> dataframe, we will filter it before we send it. To do so, we first assign a copy of it to the <kbd class="calibre9">data</kbd> object and extract the two date values from the widget we created in the <kbd class="calibre9">ui</kbd> object, using their references within the <kbd class="calibre9">input</kbd> parameter. Then, we check whether any of these is different from their initial values. In case they are, we update the <kbd class="calibre9">data</kbd> object with only those observations that are within the range specified, which we accomplish with a standard dataframe selection. Finally, we sent this filtered <kbd class="calibre9">data</kbd> to the <kbd class="calibre9">datatable()</kbd> function, and proceed as we did earlier.</p>
<p class="calibre2">The result of these changes to the <kbd class="calibre9">ui</kbd> and <kbd class="calibre9">server</kbd> is that we can now filter the dates allowed in the dynamic table shown in the Data Overview tab, which is something we could not do before. The date range widget in action is shown in the following screenshot. Try to change its dates and see how the dynamic table updates:</p>
<div><img src="img/00070.jpeg" class="calibre70"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Setting up dynamic options in a drop-down</h1>
                
            
            
                
<p class="calibre2">Now we will see how to add a drop-down input whose entries adapt to the tab the user is currently viewing. Specifically, we will add the possibility for the user to select which asset they want to use to filter the data. If you looked carefully, you may have noticed that the dynamic data table contains observations for both Bitcoin and Litecoin, which may be fine when we're just looking at the table, but it will be a problem when we attempt to show a price time-series because we will have data for more than one asset. We want to provide a mechanism to select only one of them, but we want to keep the option of looking at all of them together in the dynamic data table, just as we are doing now.</p>
<p class="calibre2">We start by creating the object that contains the unique asset names we currently have in the data. This is much better than hardcoding their names directly into code, since they will be automatically updated when our data changes, which would not be the case if we hardcoded them. This line should go just below the previous <em class="calibre19">global</em> objects, which only needs to be created once:</p>
<pre class="mce-root">DATA_ASSETS &lt;- unique(ORIGINAL_DATA$name)</pre>
<p class="calibre2">Since the input widget in this case has dynamic logic, we can't just create inside the <kbd class="calibre9">ui</kbd> object, we need to create it in the <kbd class="calibre9">server</kbd> function and pass it along to the <kbd class="calibre9">ui</kbd> object. The way to do it is by introducing a new observer into the <kbd class="calibre9">output</kbd> parameter, named <kbd class="calibre9">select_asset</kbd> in this case, which is created with the <kbd class="calibre9">renderUI()</kbd> function since it will contain a Shiny <kbd class="calibre9">*Input()</kbd> function. As we did with the <kbd class="calibre9">data</kbd> in the previous section, we will assign the <em class="calibre19">default</em> asset names, and only in the case that the user is the second tab which is the Data Overview tab (more on where this comes from below), will it also add the <kbd class="calibre9">All</kbd> option to the drop-down. Otherwise, it will just keep the asset names without the <kbd class="calibre9">All</kbd> option, which is what we want for the SMA graphs we will create later:</p>
<pre class="mce-root">server &lt;- function(input, output) {
    output$table &lt;- DT::renderDataTable(DT::datatable({
        data  &lt;- ORIGINAL_DATA
        start &lt;- input$date_range[1]
        end   &lt;- input$date_range[2]
        if (time_to_date_string.TimeStamp(start) != DATE_MIN |
            time_to_date_string.TimeStamp(end) != DATE_END) {
            data &lt;- data[
                data$timestamp &gt;= time_to_timestamp.TimeStamp(start) &amp;
                data$timestamp &lt;= time_to_timestamp.TimeStamp(end), ]
        }
        return(data)
    }))

    output$select_asset &lt;- renderUI({
        assets &lt;- DATA_ASSETS
        if (input$tab_selected == 2) {
            assets &lt;- c("All", assets)
        }
        return(selectInput("asset", "Asset:", assets))
    })
}</pre>
<p class="calibre2">To actually provide a mechanism for the <kbd class="calibre9">server</kbd> to understand what tab the user is currently viewing, the <kbd class="calibre9">ui</kbd> object needs to be adjusted so that the <kbd class="calibre9">tabsetPanel()</kbd> function receives an <kbd class="calibre9">id</kbd> parameter with the name of the object that contains the current tab number, <kbd class="calibre9">tab_selected</kbd> in this case (which is the name used to check in the <kbd class="calibre9">server</kbd> function). Also, each tab within must have a value assigned with the <kbd class="calibre9">value</kbd> parameter, as is shown. This way we make sure that the Data Overview tab is identified with the <kbd class="calibre9">2</kbd> value.</p>
<p class="calibre2">Also note that we added the <kbd class="calibre9">htmlOutput()</kbd> function call within the just introduced <kbd class="calibre9">wellPanel()</kbd> function call in the <kbd class="calibre9">sidePanel()</kbd> function. The <kbd class="calibre9">wellPanel()</kbd> visually groups panels to provide more intuitive interfaces for users, and the <kbd class="calibre9">htmlOutput()</kbd> function uses the name of an observer to know what to show in the web browser, the <kbd class="calibre9">select_asset</kbd> element of the <kbd class="calibre9">output</kbd> object in this case:</p>
<pre class="mce-root">ui &lt;- fluidPage(
    titlePanel("Cryptocurrency Markets"),
    sidebarLayout(
        sidebarPanel(
            wellPanel(
                dateRangeInput(
                    "date_range",
                    label = paste("Date range:"),
                    start = DATE_MIN,
                    end = DATE_END,
                    min = DATE_MIN,
                    max = DATE_MAX,
                    separator = " to ",
                    format = "yyyy-mm-dd",
                    weekstart = 1,
                    startview = "year"
                ),
                htmlOutput("select_asset")
            )
        ),
        mainPanel(
            tabsetPanel(
                id = "tab_selected",
                tabPanel(
                    "Simple Moving Averages",
                    value = 1,
                    "Content 1"
                ),
                tabPanel(
                    "Data Overview",
                    value = 2,
                    fluidRow(DT::dataTableOutput("table"))
                )
            )
        )
    )
)</pre>
<p class="calibre2">Having performed these changes, now we can see that our application shows an asset name drop-down with options <kbd class="calibre9">Bitcoin</kbd> and <kbd class="calibre9">Litecoin</kbd> when the user is in the Simple Moving Averages<em class="calibre19"> </em>tab, and which also includes the <kbd class="calibre9">All</kbd> option when they are in the Data Overview tab, just as we wanted and as can be seen in the following screenshot:</p>
<div><img src="img/00071.jpeg" class="calibre22"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Setting up dynamic input panels</h1>
                
            
            
                
<p class="calibre2">The final two inputs we will introduce will be used for the SMA graphs later on. The first one is used to select which SMA implementation the user wants to use. The options are the <kbd class="calibre9">sma_efficient_1()</kbd>, <kbd class="calibre9">sma_efficient_2()</kbd>, <kbd class="calibre9">sma_delegated_fortran()</kbd>, and <kbd class="calibre9">sma_delegated_cpp()</kbd> functions we created in the previous chapter. The second one is used to define the period used for the SMA calculation, and which is used as input in one of the previous functions.</p>
<p class="calibre2">Since code can start being too repetitive and taking too much space, and since you have most likely understood the nesting patterns used in the creation of the <kbd class="calibre9">ui</kbd>, I will avoid repeating the full <kbd class="calibre9">ui</kbd> object declaration, and simply point where changes need to be made.</p>
<p class="calibre2">In this case, we want to add the following code after the <kbd class="calibre9">wellPanel()</kbd> function has ended and before the <kbd class="calibre9">sidebarPanel()</kbd> function ends. The following code will be the second parameter to <kbd class="calibre9">sidebarPanel()</kbd>, so don't forget to add a comma (",") after the <kbd class="calibre9">wellPanel()</kbd> function finishes, otherwise you will get an error.</p>
<p class="calibre2">The <kbd class="calibre9">conditionalPanel()</kbd> function checks for a JavaScript condition, specified using a string, to decide whether or not a panel should be showed to the user. Since the <kbd class="calibre9">input</kbd> object is sent to the web browser through a JavaScript object conveniently named <kbd class="calibre9">input</kbd>, we can use that to get the value we're looking for, which is whether or not the user is looking at the first tab, <kbd class="calibre9">"Simple Moving Averages"</kbd>. If she is, then we will show the panel:</p>
<p>JavaScript uses the dot (".") notation to access elements instead of the <kbd class="calibre21">money</kbd> (<kbd class="calibre21">$</kbd>) notation used in R.</p>
<p class="calibre2">The panel shown is <kbd class="calibre9">wellPanel()</kbd> with two input objects inside: <kbd class="calibre9">radioButtons()</kbd> and <kbd class="calibre9">sliderInput()</kbd>. The first one receives the available options for the user in a list sent through the <kbd class="calibre9">choices</kbd> parameter (each element's name is what is shown to the user, while each element's value is used internally in R which are the SMA implementation names in this case), as well as the <kbd class="calibre9">selected</kbd> one by default. The second one receives the <kbd class="calibre9">min</kbd>, <kbd class="calibre9">max</kbd>, and default <kbd class="calibre9">value</kbd> for the numeric slider. Both receive the unique identifier and label as the first two arguments, as every other <kbd class="calibre9">*Input()</kbd> function does:</p>
<pre class="mce-root">conditionalPanel(
    condition = "input.tab_selected == 1",
    wellPanel(
        radioButtons(
            "sma_implementation",
            "Implementation:",
            choices = list(
                "C++" = "sma_delegated_cpp",
                "Fortran" = "sma_delegated_fortran",
                "Efficient 1" = "sma_efficient_1",
                "Efficient 2" = "sma_efficient_2"
            ),
            selected = "sma_delegated_cpp"
        ),
        sliderInput(
            "sma_period",
            "Period:",
            min = 5,
            max = 200,
            value = 30
        )
    )
)</pre>
<p class="calibre2">We will leave the actual graphs creations for later, so we don't need to change anything on the <kbd class="calibre9">server</kbd> side. At this point, the <em class="calibre19">reactive values</em> coming out of <kbd class="calibre9">input$sma_implementation</kbd> and <kbd class="calibre9">input$sma_period</kbd> will not be used. A screenshot showing how these inputs is shown as following. If you navigate to the Simple Moving Averages tab, they should be shown, but if you navigate to the Data Overview tab, they should be hidden:</p>
<div><img src="img/00072.jpeg" class="calibre22"/></div>
<p class="calibre2">As you can see, allowing users to interact with the application is not too hard, and is accomplished by using the <kbd class="calibre9">*Input()</kbd> functions in the <kbd class="calibre9">ui</kbd> object, whose <em class="calibre19">reactive values</em> in turn may be used in the <kbd class="calibre9">server</kbd> function.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Adding a summary table with shared data</h1>
                
            
            
                
<p class="calibre2">Now we will add a summary table on top of our dynamic data table. This summary table should be updated according to the assets selected (note the plural since we allow for the <kbd class="calibre9">All</kbd> case in this tab). Take a moment to try to think how you would implement this yourself? If you tried to replicate the pattern shown previously for the <kbd class="calibre9">data</kbd> object we showed before, you would have a correct but inefficient solution. The reason is that the logic to filter the data would be duplicated, which is unnecessary.</p>
<p class="calibre2">To avoid this pitfall we show next how to share streams among different <em class="calibre19">reactive functions</em> using the <kbd class="calibre9">reactive()</kbd> function, which is a function that used to prepare <em class="calibre19">reactive values</em> for other <em class="calibre19">reactive functions</em>. In this case, we move all the logic we had created before into the expression sent as a parameter to this function and assign it to the <kbd class="calibre9">data</kbd> object, which is now a <em class="calibre19">reactive function</em> itself. Note that we also added a bit of code to check whether the current asset selection is different from <kbd class="calibre9">All</kbd> and if it is, then use that value to filter the data, similarly to how we filter it using dates.</p>
<p class="calibre2">Once we have done that, we can replace the logic we had inside the <kbd class="calibre9">datatable()</kbd> function with a simple call to the <kbd class="calibre9">data()</kbd> reactive function, which will provide the expected dataframe. And now that we have extracted this logic, we can reuse the <kbd class="calibre9">data()</kbd> call in an other place, as we do in the <kbd class="calibre9">output$summary_table</kbd> observer created with the <kbd class="calibre9">renderTable()</kbd> function. As you can see, it's being passed a dataframe created with statistics for the minimum, median, mean, and maximum of the dataframe returned by the <kbd class="calibre9">data()</kbd> function. In this case, we can guarantee that the data used in the <kbd class="calibre9">output$table()</kbd> and <kbd class="calibre9">output$summary_table()</kbd> functions is the same:</p>
<pre class="mce-root">server &lt;- function(input, output) {

    data &lt;- reactive({
        data  &lt;- ORIGINAL_DATA
        start &lt;- input$date_range[1]
        end   &lt;- input$date_range[2]
        if (input$asset != "All") {
            data &lt;- data[data$name == input$asset, ]
        }
        if (time_to_date_string.TimeStamp(start) != DATE_MIN |
            time_to_date_string.TimeStamp(end) != DATE_MAX) {
            data &lt;- data[
                data$timestamp &gt;= time_to_timestamp.TimeStamp(start) &amp;
                data$timestamp &lt;= time_to_timestamp.TimeStamp(end), ]
        }
        return(data)
    })

    output$table &lt;- DT::renderDataTable(DT::datatable({return(data())}))

    output$select_asset &lt;- renderUI({
        assets &lt;- DATA_ASSETS
        if (input$tab_selected == 2) {
            assets &lt;- c("All", assets)
        }
        return(selectInput("asset", "Asset:", assets))
    })

    output$summary_table &lt;- renderTable(data.frame(
        Minimum = min(data()$price_usd),
        Median = mean(data()$price_usd),
        Mean = mean(data()$price_usd),
        Max = max(data()$price_usd)
    ))
}</pre>
<p>Be careful if you're using stochastic data (for example, random numbers) if you're duplicating data logic instead of using a <kbd class="calibre21">reactive()</kbd> function, since you will probably not end up with the same data in both places.</p>
<p class="calibre2">We also need to introduce the corresponding function call in the <kbd class="calibre9">ui</kbd> object, which we place in the corresponding <kbd class="calibre9">tabPanel()</kbd>. To place in this the dataframe we just created, we use the <kbd class="calibre9">tableOutput()</kbd> function with the corresponding <kbd class="calibre9">summary_table</kbd> string as parameter. The code is as follows (note that I omit the <kbd class="calibre9">ui</kbd> code around this snippet):</p>
<pre class="mce-root">tabPanel(
    "Data Overview",
    value = 2,
    fluidRow(tableOutput("summary_table")),
    fluidRow(DT::dataTableOutput("table"))
)</pre>
<p class="calibre2">After implementing these changes, you should see a summary table with the mentioned statistics on top of the dynamic data table, and they should update as different values are sent as inputs for dates and asset selection.</p>
<div><img src="img/00073.jpeg" class="calibre22"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Adding a simple moving average graph</h1>
                
            
            
                
<p class="calibre2">Now we will create our first <strong class="calibre1">simple moving average</strong> (<strong class="calibre1">SMA</strong>) graph. This graph will be created with the   package, and will show two lines. The black line will be the actual price data, and the blue line will be SMA.</p>
<p class="calibre2">Before we begin, and since <kbd class="calibre9">ggplot2</kbd> graphs which make use of dates are better created with actual dates instead of timestamp strings, we add the <kbd class="calibre9">time</kbd> column to the <kbd class="calibre9">ORIGINAL_DATA</kbd> dataframe with the corresponding dates. This should be placed immediately after having loaded the data:</p>
<pre class="mce-root">ORIGINAL_DATA$time &lt;- timestamp_to_time.TimeStamp(ORIGINAL_DATA$timestamp)</pre>
<p class="calibre2">Next we show how our <kbd class="calibre9">sma_graph()</kbd> function is implemented. As can be seen, it will receive two parameters, the <kbd class="calibre9">data</kbd> dataframe and the <kbd class="calibre9">sma</kbd> vector coming out of one of the SMA implementations mentioned before. The function is very simple, it creates a graph with <kbd class="calibre9">time</kbd> on the <em class="calibre19">x</em> axis and <kbd class="calibre9">price_usd</kbd> on the <em class="calibre19">y</em> axis, adds points and lines for such data, and then adds a second blue line with the values from the <kbd class="calibre9">sma</kbd> vector. The <kbd class="calibre9">group = 1</kbd> parameter is used to avoid any errors by telling the <kbd class="calibre9">ggplot()</kbd> function that there's a single group in that data, and the <kbd class="calibre9">size = 1</kbd> parameter is just to make the line stand out a little bit more.</p>
<p class="calibre2">Note that we return the graph object. Finally, you should keep in mind that using the <kbd class="calibre9">geom_line()</kbd> function introduces interpolation into the example, which may misrepresent the discrete data we have for prices, but it can also be helpful to understand the price dynamics, and that's why we use it:</p>
<pre class="mce-root">sma_graph &lt;- function(data, sma) {
    g &lt;- ggplot(data, aes(time, price_usd))
    g &lt;- g + geom_point()
    g &lt;- g + geom_line(group = 1)
    g &lt;- g + geom_line(aes_string(y = sma),
                       group = 1, color = "blue", size = 1)
    return(g)
}</pre>
<p class="calibre2">Now, to follow good practices, we place the SMA calculation in a <kbd class="calibre9">reactive()</kbd> function of its own (just below the <kbd class="calibre9">data</kbd> <em class="calibre19">reactive function</em> we created before). Note that it's a <em class="calibre19">reactive function</em> that depends on another <em class="calibre19">reactive function</em>, <kbd class="calibre9">data()</kbd> to be precise.</p>
<p class="calibre2">The following code (which omits the rest of the <kbd class="calibre9">server</kbd> function), shows that this <kbd class="calibre9">sma</kbd> definition makes use of the <kbd class="calibre9">do.call()</kbd> function to execute the implementation name we receive as a <em class="calibre19">reactive value</em> from the <kbd class="calibre9">input$sma_implementation</kbd> widget. The <kbd class="calibre9">do.call()</kbd> also receives a list as the second parameter, and this list contains the parameters that will be sent to the actual function we want to call. In this case, it's the <kbd class="calibre9">input$sma_period</kbd>, the <kbd class="calibre9">symbol</kbd> (which in this case will be a single one because we restricted data for this tab to have a single asset), and the actual data through the call to the <kbd class="calibre9">data()</kbd> <em class="calibre19">reactive function</em>:</p>
<pre class="mce-root">sma &lt;- reactive({
    return(do.call(
        input$sma_implementation,
        list(input$sma_period, data()[1, "symbol"], data())
    ))
})</pre>
<p class="calibre2">Having implemented this <kbd class="calibre9">sma()</kbd> reactive function, we can implement the observer <kbd class="calibre9">output$graph_top()</kbd> as follows (again, we omitted some code around):</p>
<pre class="mce-root">output$graph_top &lt;- renderPlot({
    return(sma_graph(data(), sma()))
})</pre>
<p class="calibre2">Finally, we need to update our <kbd class="calibre9">ui</kbd> object to replace the <kbd class="calibre9">"Content 1"</kbd> placeholder with a <kbd class="calibre9">fluidRow()</kbd> and a <kbd class="calibre9">ploutOutput()</kbd> inside. We send the <kbd class="calibre9">"graph_top"</kbd> unique identifier to the observer we are interested in:</p>
<pre class="mce-root">fluidRow(plotOutput("graph_top"))</pre>
<p class="calibre2">This was simple enough, wasn't it? Now we can run our application, and it should show us a graph for the first two days in the data, with a blue SMA(30) on top as the one shown in the following screenshot:</p>
<div><img src="img/00074.jpeg" class="calibre22"/></div>
<p class="calibre2">Note that you can change the options and the graph will update accordingly. For example, if we chose only the first day in the data and decide to graph only an SMA(5) on top of it.</p>
<div><img src="img/00075.jpeg" class="calibre22"/></div>
<p class="calibre2">Finally, if your computer can handle it, you may decide to show the full data (which is quite a bit of observations, so do be careful). In that case, the SMA would not be visible, but it will still be plotted for us. The result is shown in the following image:</p>
<div><img src="img/00076.jpeg" class="calibre22"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Adding interactivity with a secondary zoom-in graph</h1>
                
            
            
                
<p class="calibre2">Finally, we are going to add some interactivity to our graph by implementing another similar graph, which will exhibit a <em class="calibre19">zoom-in</em> effect on the one we created before. The idea is that we can select an area of the graph we just created and the one we will place below it will update to only show the specific area we have selected. Seems interesting, doesn't it?</p>
<p class="calibre2">To accomplish this, we need to modify the <kbd class="calibre9">plotOutput()</kbd> we inserted at the end of the previous section to include a <kbd class="calibre9">brush</kbd> parameter with a call to the <kbd class="calibre9">brushOpts()</kbd> function, which in turn receives the name of the unique identifier for the brush input we are creating. This parameter is used to create a special type of input, which retrieves a selected area from the graph shown in the web browser. We also add another <kbd class="calibre9">fluidRow()</kbd> with another <kbd class="calibre9">plotOutput()</kbd> just below it to contain the graph that will provide the <em class="calibre19">zoom-in</em> effect. The code is as follows:</p>
<pre class="mce-root">tabPanel(
    "Simple Moving Averages",
    value = 1,
    fluidRow(plotOutput("graph_top", brush = brushOpts("graph_brush"))),
    fluidRow(plotOutput("graph_bottom"))
)</pre>
<p class="calibre2">Now the <kbd class="calibre9">input$graph_brush</kbd> reactive value will contain a list with four elements inside <kbd class="calibre9">xmin</kbd>, <kbd class="calibre9">xmax</kbd>, <kbd class="calibre9">ymin</kbd>, and <kbd class="calibre9">ymax</kbd>, which are the coordinates that conform the area selected in the top graph. Our <kbd class="calibre9">ranges()</kbd> reactive function will use them to send the appropriate values as limits to the bottom graph. The way it works is that it will check whether <kbd class="calibre9">input$graph_brush</kbd> is <kbd class="calibre9">NULL</kbd>, and if it's not, meaning that an area is selected, then it will return a list with two elements, <kbd class="calibre9">x</kbd> and <kbd class="calibre9">y</kbd>, where each of these elements contains the appropriate coordinates. If <kbd class="calibre9">input$graph_brush</kbd> is <kbd class="calibre9">NULL</kbd>, then the <kbd class="calibre9">x</kbd> and <kbd class="calibre9">y</kbd> elements of the returned list will be <kbd class="calibre9">NULL</kbd>, which signals the <kbd class="calibre9">coord_cartesian()</kbd> function, which we will use on top of the <kbd class="calibre9">sma_graph()</kbd>, to avoid placing any constraints in the axes for the graph. The actual function is shown in the following code, and as other functions created with <kbd class="calibre9">reactive()</kbd>, it should be placed inside the <kbd class="calibre9">server</kbd> function.</p>
<p class="calibre2">Also note that we need to make a small transformation to the values for the <em class="calibre19">x</em> axis because they are returned as integers, and not dates which is the type of object being used by <kbd class="calibre9">ggplot()</kbd> for that axis. We simply use the <kbd class="calibre9">as.POSIXct()</kbd> function to transform such integers into valid dates, using the <kbd class="calibre9">oring = "1970-01-01"</kbd>, which is what <kbd class="calibre9">ggplot()</kbd> uses by default. If we don't make the transformation, we will get an error:</p>
<pre class="mce-root">ranges &lt;- reactive({
    if (!is.null(input$graph_brush)) {
        return(list(
            x = c(as.POSIXct(input$graph_brush$xmin, <br class="title-page-name"/>                             origin = "1970-01-01"),
                  as.POSIXct(input$graph_brush$xmax, <br class="title-page-name"/>                             origin = "1970-01-01")),
<br class="title-page-name"/>            y = c(input$graph_brush$ymin, <br class="title-page-name"/>                  input$graph_brush$ymax)
        ))
    }
    return(list(x = NULL, y = NULL))
})</pre>
<p class="calibre2">Now we are able to create the <kbd class="calibre9">output$bottom_graph</kbd> observer just as we created the previous graph, but in this case we will add the <kbd class="calibre9">coord_cartesian()</kbd> function on top of the graph object returned by <kbd class="calibre9">sma_graph()</kbd> to limit the axes values. Note that we use the <kbd class="calibre9">expand = FALSE</kbd> to enforce the limits coming from the <kbd class="calibre9">ranges()</kbd> reactive function, we just created in the preceding code:</p>
<pre class="mce-root">output$graph_bottom &lt;- renderPlot({
    return(sma_graph(data(), sma()) +
           coord_cartesian(xlim = ranges()$x,
                           ylim = ranges()$y, expand = FALSE))
})</pre>
<p class="calibre2">Having implemented these changes, we should have the desired effect. To test it, we can open the application and see the two identical plots one on top of the other, like the following screenshot shows:</p>
<div><img src="img/00077.jpeg" class="calibre22"/></div>
<p class="calibre2">However, if we select an area on the top graph, then the graph on the bottom should update showing only that specific part of the graph. Pretty cool, isn't it?</p>
<div><img src="img/00078.jpeg" class="calibre22"/></div>
<p class="calibre2">Finally, you should know that another way to introduce interactive graphics is to use well known JavaScript like <kbd class="calibre9">Plot.ly</kbd> (which we used in <a target="_blank" href="part0110.html#38STS0-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 5</a>, <em class="calibre19">Communicating Sales With Visualizations</em>). Shiny creates websites that use JavaScript in the background so this technique is a natural fit. However, this is an advanced technique and its use is more involved than what we have shown here, so we won't show it but you should know it's possible in case you want to pursue it yourself.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Styling our application with themes</h1>
                
            
            
                
<p class="calibre2">Up to this point, we have been using the theme provided by default by Shiny, but now that our application is finished, we want to stylize it with some tech-looking colors. In that case, we can use the <kbd class="calibre9">shinythemes</kbd> and <kbd class="calibre9">ggthemr</kbd> packages, which provide us with an easy way to apply themes to Shiny applications and <kbd class="calibre9">ggplot2</kbd> graphs, respectively.</p>
<p class="calibre2">All we need to do to apply the themes is to tell the <kbd class="calibre9">ggplot2</kbd> framework to apply the <em class="calibre19">flat dark</em> theme provided by the <kbd class="calibre9">ggthemr</kbd> package, and to make sure that the <em class="calibre19">outer</em> side of the graph is also stylized we use the <kbd class="calibre9">type = outer</kbd> parameter, as is shown here. The code should be placed wherever we placed our <kbd class="calibre9">ggplot2</kbd> code for cohesiveness, which is in the <kbd class="calibre9">functions.R</kbd> file for this chapter:</p>
<pre class="mce-root">library(ggthemr)
ggthemr('flat dark', type = 'outer')</pre>
<p class="calibre2">To stylize the Shiny application itself, we send the <kbd class="calibre9">theme</kbd> parameter, using the <kbd class="calibre9">shinytheme()</kbd> function, to the <kbd class="calibre9">fluidPage()</kbd> function just before our <kbd class="calibre9">titlePanel()</kbd> function call, as is shown here:</p>
<pre class="mce-root">ui &lt;- fluidPage(
    theme = shinytheme("superhero"),
    titlePanel("Cryptocurrency Markets"),
    ...
)</pre>
<p class="calibre2">We also change the SMA line in the graphs to white, which you already know how to do, and with these changes, now our application looks pretty high tech. The following shows the Simple Moving Average tab:</p>
<div><img src="img/00079.jpeg" class="calibre71"/></div>
<p class="calibre2">And here you can see a screenshot of the Data Overview tab:</p>
<div><img src="img/00080.jpeg" class="calibre22"/></div>
<p class="calibre2">To find other themes you can look at the <kbd class="calibre9">shinythemes</kbd> repository (<a href="http://rstudio.github.io/shinythemes/" target="_blank" class="calibre4">http://rstudio.github.io/shinythemes/</a>) and the <kbd class="calibre9">ggthemr</kbd> repository (<a href="https://github.com/cttobin/ggthemr" target="_blank" class="calibre4">https://github.com/cttobin/ggthemr</a>). To make sure the readers realize what the full code looks like at once, I place here the full code for the application as well as the function used for graphs:</p>
<pre class="mce-root">library(shiny)<br class="title-page-name"/>library(ggplot2)<br class="title-page-name"/>library(lubridate)<br class="title-page-name"/>library(shinythemes)<br class="title-page-name"/><br class="title-page-name"/>source("../chapter-08/cryptocurrencies/utilities/time-stamp.R")<br class="title-page-name"/>source("../chapter-09/sma-delegated.R", chdir = TRUE)<br class="title-page-name"/>source("../chapter-09/sma-efficient.R")<br class="title-page-name"/>source("./functions.R")<br class="title-page-name"/><br class="title-page-name"/>ORIGINAL_DATA &lt;- <br class="title-page-name"/>read.csv("../chapter-09/data.csv", stringsAsFactors = FALSE)<br class="title-page-name"/><br class="title-page-name"/>ORIGINAL_DATA$time &lt;- <br class="title-page-name"/>timestamp_to_time.TimeStamp(ORIGINAL_DATA$timestamp)<br class="title-page-name"/><br class="title-page-name"/>DATA_ASSETS &lt;- unique(ORIGINAL_DATA$name)<br class="title-page-name"/><br class="title-page-name"/>DATE_MIN &lt;- <br class="title-page-name"/>timestamp_to_date_string.TimeStamp(min(ORIGINAL_DATA$timestamp))<br class="title-page-name"/><br class="title-page-name"/>DATE_MAX &lt;- <br class="title-page-name"/>timestamp_to_date_string.TimeStamp(max(ORIGINAL_DATA$timestamp))<br class="title-page-name"/><br class="title-page-name"/>DATE_END &lt;- <br class="title-page-name"/>timestamp_to_date_string.TimeStamp(time_to_timestamp.TimeStamp(<br class="title-page-name"/>    timestamp_to_time.TimeStamp(min(ORIGINAL_DATA$timestamp)) + days(2)))<br class="title-page-name"/><br class="title-page-name"/>ui &lt;- fluidPage(<br class="title-page-name"/>    theme = shinytheme("superhero"),<br class="title-page-name"/>    titlePanel("Cryptocurrency Markets"),<br class="title-page-name"/>    sidebarLayout(<br class="title-page-name"/>        sidebarPanel(<br class="title-page-name"/>            "Options",<br class="title-page-name"/>            wellPanel(<br class="title-page-name"/>                dateRangeInput(<br class="title-page-name"/>                    "date_range",<br class="title-page-name"/>                    label = paste("Date range:"),<br class="title-page-name"/>                    start = DATE_MIN,<br class="title-page-name"/>                    end = DATE_END,<br class="title-page-name"/>                    min = DATE_MIN,<br class="title-page-name"/>                    max = DATE_MAX,<br class="title-page-name"/>                    separator = " to ",<br class="title-page-name"/>                    format = "yyyy-mm-dd",<br class="title-page-name"/>                    weekstart = 1,<br class="title-page-name"/>                    startview = "year"<br class="title-page-name"/>                ),<br class="title-page-name"/>                htmlOutput("select_asset")<br class="title-page-name"/>            ),<br class="title-page-name"/>            conditionalPanel(<br class="title-page-name"/>                condition = "input.tab_selected == 1",<br class="title-page-name"/>                wellPanel(<br class="title-page-name"/>                    radioButtons(<br class="title-page-name"/>                        "sma_implementation",<br class="title-page-name"/>                        "Implementation:",<br class="title-page-name"/>                        choices = list(<br class="title-page-name"/>                            "C++" = "sma_delegated_cpp",<br class="title-page-name"/>                            "Fortran" = "sma_delegated_fortran",<br class="title-page-name"/>                            "Efficient 1" = "sma_efficient_1",<br class="title-page-name"/>                            "Efficient 2" = "sma_efficient_2"<br class="title-page-name"/>                        ),<br class="title-page-name"/>                        selected = "sma_delegated_cpp"<br class="title-page-name"/>                    ),<br class="title-page-name"/>                    sliderInput(<br class="title-page-name"/>                        "sma_period",<br class="title-page-name"/>                        "Period:",<br class="title-page-name"/>                        min = 5,<br class="title-page-name"/>                        max = 200,<br class="title-page-name"/>                        value = 30<br class="title-page-name"/>                    )<br class="title-page-name"/>                )<br class="title-page-name"/>            )<br class="title-page-name"/>        ),<br class="title-page-name"/>        mainPanel(<br class="title-page-name"/>            tabsetPanel(<br class="title-page-name"/>                id = "tab_selected",<br class="title-page-name"/>                tabPanel(<br class="title-page-name"/>                    "Simple Moving Averages",<br class="title-page-name"/>                    value = 1,<br class="title-page-name"/>                    fluidRow(plotOutput("graph_top", <br class="title-page-name"/>                                         brush = brushOpts(<br class="title-page-name"/>                                         "graph_brush"))),<br class="title-page-name"/>                    fluidRow(plotOutput("graph_bottom"))<br class="title-page-name"/>                ),<br class="title-page-name"/>                tabPanel(<br class="title-page-name"/>                    "Data Overview",<br class="title-page-name"/>                    value = 2,<br class="title-page-name"/>                    fluidRow(tableOutput("summary_table")),<br class="title-page-name"/>                    fluidRow(DT::dataTableOutput("table"))<br class="title-page-name"/>                )<br class="title-page-name"/>            )<br class="title-page-name"/>        )<br class="title-page-name"/>    )<br class="title-page-name"/>)<br class="title-page-name"/><br class="title-page-name"/>server &lt;- function(input, output) {<br class="title-page-name"/><br class="title-page-name"/>    data &lt;- reactive({<br class="title-page-name"/>        data &lt;- ORIGINAL_DATA<br class="title-page-name"/>        start &lt;- input$date_range[1]<br class="title-page-name"/>        end &lt;- input$date_range[2]<br class="title-page-name"/>        if (input$asset != "All") {<br class="title-page-name"/>            data &lt;- data[data$name == input$asset, ]<br class="title-page-name"/>        }<br class="title-page-name"/>        if (time_to_date_string.TimeStamp(start) != DATE_MIN |<br class="title-page-name"/>            time_to_date_string.TimeStamp(end) != DATE_MAX) {<br class="title-page-name"/>            data &lt;- data[<br class="title-page-name"/>                data$timestamp &gt;= time_to_timestamp.TimeStamp(start) &amp;<br class="title-page-name"/>                data$timestamp &lt;= time_to_timestamp.TimeStamp(end), ]<br class="title-page-name"/>        }<br class="title-page-name"/>        return(data)<br class="title-page-name"/>    })<br class="title-page-name"/><br class="title-page-name"/>    sma &lt;- reactive({<br class="title-page-name"/>        return(do.call(<br class="title-page-name"/>            input$sma_implementation,<br class="title-page-name"/>            list(input$sma_period, data()[1, "symbol"], data())<br class="title-page-name"/>        ))<br class="title-page-name"/>    })<br class="title-page-name"/><br class="title-page-name"/>    ranges &lt;- reactive({<br class="title-page-name"/>        if (!is.null(input$graph_brush)) {<br class="title-page-name"/>            return(list(<br class="title-page-name"/>                x = c(as.POSIXct(input$graph_brush$xmin, <br class="title-page-name"/>                                 origin = "1970-01-01"),<br class="title-page-name"/>                      as.POSIXct(input$graph_brush$xmax, <br class="title-page-name"/>                                 origin = "1970-01-01")),<br class="title-page-name"/>                y = c(input$graph_brush$ymin, <br class="title-page-name"/>                      input$graph_brush$ymax)<br class="title-page-name"/>            ))<br class="title-page-name"/>        }<br class="title-page-name"/>        return(list(x = NULL, y = NULL))<br class="title-page-name"/>    })<br class="title-page-name"/><br class="title-page-name"/>    output$table &lt;- DT::renderDataTable(DT::datatable({<br class="title-page-name"/>        return(data())<br class="title-page-name"/>    }), style = "bootstrap")<br class="title-page-name"/><br class="title-page-name"/>    output$select_asset &lt;- renderUI({<br class="title-page-name"/>        assets &lt;- DATA_ASSETS<br class="title-page-name"/>        if (input$tab_selected == 2) {<br class="title-page-name"/>            assets &lt;- c("All", assets)<br class="title-page-name"/>        }<br class="title-page-name"/>        return(selectInput("asset", "Asset:", assets))<br class="title-page-name"/>    })<br class="title-page-name"/><br class="title-page-name"/>    output$summary_table &lt;- renderTable(data.frame(<br class="title-page-name"/>        Minimum = min(data()$price_usd),<br class="title-page-name"/>        Median = mean(data()$price_usd),<br class="title-page-name"/>        Mean = mean(data()$price_usd),<br class="title-page-name"/>        Max = max(data()$price_usd)<br class="title-page-name"/>    ))<br class="title-page-name"/><br class="title-page-name"/>    output$graph_top &lt;- renderPlot({<br class="title-page-name"/>        return(sma_graph(data(), sma()))<br class="title-page-name"/>    })<br class="title-page-name"/><br class="title-page-name"/>    output$graph_bottom &lt;- renderPlot({<br class="title-page-name"/>        return(sma_graph(data(), sma()) +<br class="title-page-name"/>               coord_cartesian(xlim = ranges()$x,<br class="title-page-name"/>                               ylim = ranges()$y, expand = FALSE))<br class="title-page-name"/>    })<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>shinyApp(ui, server, options = list(port = 6924))</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Other topics of interest</h1>
                
            
            
                
<p class="calibre2">When working with Shiny there are common tasks that can be used to customize your web applications. Some of these tasks are adding static images, HTML, and CSS. In the following sections we will briefly look into how these can be accomplished with Shiny. Finally, we will also mention some options you have to share your application with others, without having to setup your own web server, so that they can use it in their web browser, through an internet connection.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Adding static images</h1>
                
            
            
                
<p class="calibre2">Images can enhance the appearance of your application and help your users understand the content. Shiny looks for the <kbd class="calibre9">img()</kbd> function to place image files in your application. To insert an image, simply call with the <kbd class="calibre9">src</kbd> specifying the images location. You can also include other HTML friendly parameters such as height and width (they will be passed as <em class="calibre19">pixel values</em>):</p>
<pre class="mce-root">img(src = "image.png", height = 250, width = 250)</pre>
<p class="calibre2">The <kbd class="calibre9">image.png</kbd> file must be in a folder named <kbd class="calibre9">www</kbd> in the same directory as the <kbd class="calibre9">app.R</kbd> script. Shiny will share any file placed here with your user's web browser, which makes <kbd class="calibre9">www</kbd> a great place to put images, style sheets, and other things the browser will need to build the wap components of your Shiny application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Adding HTML to your web application</h1>
                
            
            
                
<p class="calibre2">It's easy to add HTML elements to your Shiny application using HTML tags. There are many elements you can add to your page using syntax like <kbd class="calibre9">tags$h1()</kbd> or <kbd class="calibre9">tags$p()</kbd> for a first-level heading and a paragraph, respectively. In the following piece of code, you can see how these would be used to create a page with one first-level heading, followed by a paragraph, a second-level heading, and then another paragraph.</p>
<p class="calibre2">The full list of HTML tags can be found in the Shiny HTML Tags Glossary (<a href="https://shiny.rstudio.com/articles/tag-glossary.html" target="_blank" class="calibre4">https://shiny.rstudio.com/articles/tag-glossary.html</a>):</p>
<pre class="mce-root">ui &lt;- fluidPage(
    tag$h1("This is a first level heading"),
    tag$p("This is a paragraph.)
    tag$h2("This is a second level heading"),
    tag$p("This is a another paragraph.)
)</pre>
<p class="calibre2">Sometimes, however, you may need more control on the HTML you want to use. In that case you can actually specify HTML directly into your application by using the <kbd class="calibre9">HTML()</kbd> function. In this case, Shiny will not perform any escaping on your behalf, and you will have full HTML powers, you simply need to pass it raw HTML as is shown here. Note that this raw HTML may be included in other tags, as is the case here, where it's wrapped by a <kbd class="calibre9">div</kbd> HTML tag:</p>
<pre class="mce-root">tags$div(
    HTML("<strong class="calibre1">Raw HTML</strong>")
)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Adding custom CSS styling</h1>
                
            
            
                
<p class="calibre2">Shiny uses the Bootstrap framework for structure and styling. If you're new to CSS <strong class="calibre1">Cascading Style Sheets</strong> (<strong class="calibre1">CSS</strong>) or are not familiar with Bootstrap, it would be a good idea to read the <em class="calibre19">Getting Started</em> guide (<a href="https://getbootstrap.com/docs/3.3/getting-started/" target="_blank" class="calibre4">https://getbootstrap.com/docs/3.3/getting-started/</a>) before attempting to apply your own styling.</p>
<p class="calibre2">To include your own CSS, you have a couple of options, but we will only show how to use the <kbd class="calibre9">includeCSS()</kbd> function and how to apply styles directly into HTML tags. The <kbd class="calibre9">includeCSS()</kbd> function is provided by Shiny and can be used to include a CSS file directly from the <kbd class="calibre9">www</kbd> directory mentioned in the previous section. Its usage is fairly simply.</p>
<p class="calibre2">Even though it's usually not a great idea because it's hard to find your styles and it's even harder to be consistent, sometimes it's useful to apply a style directly into a HTML tag. If you want to do so, you can send a <kbd class="calibre9">style</kbd> parameter to a specific tag.</p>
<p class="calibre2">Let's assume that you have a file called <kbd class="calibre9">style.css</kbd> in the <kbd class="calibre9">www</kbd> directory that provides all the styles you want, except the green color you want to apply to the <em class="calibre19">first-level</em> heading. Then, you may use the following code which includes both techniques:</p>
<pre class="mce-root">ui &lt;- fluidPage(
    includeCSS("style.css"),
    h1(style = "color: blue;", "A blue heading"),
)
server &lt;- function(input, output) { }
shinyApp(ui, server)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Sharing your newly created application</h1>
                
            
            
                
<p class="calibre2">Although Shiny applications end up as HTML files you can't simply copy them to your server. They require a Shiny server, just like the one we have been working with through this chapter. There are two ways to run Shiny applications (as any other application), locally or remotely. Locally means that you fire up an R installation with Shiny and the required dependencies, and run it just as we have been doing during this chapter. Remotely means that you can access it through a website, which can be very cool and convenient at times.</p>
<p class="calibre2">To run locally you need to have the files for the application in the computer that will execute them. There are many ways to do so, but the most common one is to upload them to a Git repository, download them from there, and follow the steps you already know. Furthermore, if your files are in a Git repository hosted in GitHub (<a href="https://www.github.com" target="_blank" class="calibre4">https://www.github.com</a>), you may use the <kbd class="calibre9">runGitHub()</kbd> function with the name of the repository and the username of the account that holds the repository. In that case, the downloading, unpacking, and execution will be done for you. For example, to run the application we developed through this chapter, you may use the following line:</p>
<pre class="mce-root">runGitHub("", "")</pre>
<p class="calibre2">If you want to provide remote access to your application, you have many options, but the main ones are three: ShinyApps, RStudio Connect, and Shiny Server. <strong class="calibre1">ShinyApps</strong> (<a href="https://www.shinyapps.io" target="_blank" class="calibre4">https://www.shinyapps.io</a>) offers this service for free for small applications with limited visits and can scale up in paid versions. <strong class="calibre1">RStudio Connect</strong> (<a href="https://www.rstudio.com/products/connect/" target="_blank" class="calibre4">https://www.rstudio.com/products/connect/</a>) is a publishing platform for Shiny applications and R Markdown reports. With it, you can publish directly from RStudio. Finally, <strong class="calibre1">Shiny Server</strong> (<a href="https://www.rstudio.com/products/shiny/shiny-server/" target="_blank" class="calibre4">https://www.rstudio.com/products/shiny/shiny-server/</a>) is an open source version of the Shiny server you've been using in this chapter, with the added benefit that you can run it in the Linux servers you control (of course, this includes servers from cloud providers). RStudio also sells a yearly subscription to Shiny Server Pro, which provides security, administration, and other enhancements when compared to the open source version.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            
                
<p class="calibre2">As we saw throughout the chapter, using the <em class="calibre19">functional reactive programming</em> paradigm to create powerful web applications using Shiny is not necessarily difficult. It only requires good concept understanding and a bit of exploration.</p>
<p class="calibre2">We showed how to provide inputs for users to be able to send <em class="calibre19">reactive values</em> to the backend, that is, the <kbd class="calibre9">server</kbd>, and have it respond adequately to such streams of events. We also showed how to add more sophisticated interactions such as the the two graphs with the zoom-in effect.</p>
<p class="calibre2">This is the final chapter for the book, and you saw how to use many of the tools provided by Shiny to create interactive applications. However, we have just scratched the surface of what is possible with Shiny and R in general. I hope you take what you have learned in this book and create amazing applications. Thank you for making it this far! I wish you the best of luck.</p>


            

            
        
    </body></html>