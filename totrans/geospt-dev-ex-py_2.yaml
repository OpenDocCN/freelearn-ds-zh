- en: 'def display_map(self):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Opens and displays a map image file.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param image_file: Path to the image.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: image = cv2.imread(self.output_image)
  prefs: []
  type: TYPE_NORMAL
- en: cv2.imshow('image', image)
  prefs: []
  type: TYPE_NORMAL
- en: cv2.waitKey(0)
  prefs: []
  type: TYPE_NORMAL
- en: cv2.destroyAllWindows()
  prefs: []
  type: TYPE_NORMAL
- en: This function now uses the output_image property to display the map and takes
    no arguments apart from the class instance (self) when called.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s work on the create_map function.
  prefs: []
  type: TYPE_NORMAL
- en: '8\. Copy the create_map function from the map_functions.py file and make the
    following changes to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import cv2
  prefs: []
  type: TYPE_NORMAL
- en: import mapnik
  prefs: []
  type: TYPE_NORMAL
- en: 'class MapMakerApp(object):'
  prefs: []
  type: TYPE_NORMAL
- en: def __init__(self, output_image="map.png",
  prefs: []
  type: TYPE_NORMAL
- en: style_file="map_maker/styles.xml",
  prefs: []
  type: TYPE_NORMAL
- en: 'map_size=(800, 600)):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Application class.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param output_image: Path to the image output of the map.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param style_file: Mapnik XML file containing only the style for the map.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param map_size: Size of the map in pixels.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: self.output_image = output_image
  prefs: []
  type: TYPE_NORMAL
- en: self.style_file = style_file
  prefs: []
  type: TYPE_NORMAL
- en: self.map_size = map_size
  prefs: []
  type: TYPE_NORMAL
- en: 'def display_map(self):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Opens and displays a map image file."""'
  prefs: []
  type: TYPE_NORMAL
- en: image = cv2.imread(self.output_image)
  prefs: []
  type: TYPE_NORMAL
- en: cv2.imshow('image', image)
  prefs: []
  type: TYPE_NORMAL
- en: cv2.waitKey(0)
  prefs: []
  type: TYPE_NORMAL
- en: cv2.destroyAllWindows()
  prefs: []
  type: TYPE_NORMAL
- en: 'def create_map(self):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Creates a map and writes it to a file."""'
  prefs: []
  type: TYPE_NORMAL
- en: map = mapnik.Map(*self.map_size)
  prefs: []
  type: TYPE_NORMAL
- en: mapnik.load_map(map, self.style_file)
  prefs: []
  type: TYPE_NORMAL
- en: layers = map.layers
  prefs: []
  type: TYPE_NORMAL
- en: map.zoom_all()
  prefs: []
  type: TYPE_NORMAL
- en: mapnik.render_to_file(map, self.output_image)
  prefs: []
  type: TYPE_NORMAL
- en: As we did with display_map, now the create_map function takes no arguments (except
    for self) and all parameters come from the instance attributes, the ones that
    were added to the __init__ method. We also improved the default values for those
    arguments.
  prefs: []
  type: TYPE_NORMAL
- en: All the layer and data source definitions were removed from create_map because
    in the next steps we will plug in the PythonDatasource that we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using PythonDatasource**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this type of data source and implement the ability to display any number
    of data sources on the map, we will make our app class take control of the organization
    of the layers and the data that they use, always following the premise that the
    application should have a high level of abstraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Include this import at the beginning of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: from map_maker.my_datasource import MapDatasource
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Modify the class __init__ method and create an add_layer method, as follows:
    class MapMakerApp(object):'
  prefs: []
  type: TYPE_NORMAL
- en: def __init__(self, output_image="map.png",
  prefs: []
  type: TYPE_NORMAL
- en: style_file="map_maker/styles.xml",
  prefs: []
  type: TYPE_NORMAL
- en: 'map_size=(800, 600)):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Application class.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param output_image: Path to the image output of the map.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param style_file: Mapnik XML file containing only the style for the map.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param map_size: Size of the map in pixels.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: self.output_image = output_image
  prefs: []
  type: TYPE_NORMAL
- en: self.style_file = style_file
  prefs: []
  type: TYPE_NORMAL
- en: self.map_size = map_size
  prefs: []
  type: TYPE_NORMAL
- en: self._layers = {}
  prefs: []
  type: TYPE_NORMAL
- en: def display_map(self):...
  prefs: []
  type: TYPE_NORMAL
- en: def create_map(self):...
  prefs: []
  type: TYPE_NORMAL
- en: 'def add_layer(self, geo_data, name, style=''style1''):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Add data to the map to be displayed in a layer with a given style.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param geo_data: a BaseGeoCollection subclass instance.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: data source = mapnik.Python(factory='MapDatasource',
  prefs: []
  type: TYPE_NORMAL
- en: data=geo_data)
  prefs: []
  type: TYPE_NORMAL
- en: 'layer = {"data source": data source,'
  prefs: []
  type: TYPE_NORMAL
- en: '"data": geo_data,'
  prefs: []
  type: TYPE_NORMAL
- en: '"style": style}'
  prefs: []
  type: TYPE_NORMAL
- en: self._layers[name] = layer
  prefs: []
  type: TYPE_NORMAL
- en: What we did here is use a private attribute (_layers) to keep track of the layers
    that we will use by their names. The add_layer method is responsible for instantiating
    the MapDatasource class and passing to it the data.
  prefs: []
  type: TYPE_NORMAL
- en: The data that we will use here is a subclass of BaseGeoCollection that we used
    in the previous chapters. With this, we will manipulate the map using only high-level
    objects, and also get all their functionality for free.
  prefs: []
  type: TYPE_NORMAL
- en: As we said before, *Python Datasource does not work on Windows*, so we need
    to
  prefs: []
  type: TYPE_NORMAL
- en: create a workaround to make things work despite the operating system. What we
    are going to do is save the data to a temporary file and then use Mapnik’s GeoJSON
  prefs: []
  type: TYPE_NORMAL
- en: plugin to create a data source.
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Add these imports to the beginning of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**import platform**'
  prefs: []
  type: TYPE_NORMAL
- en: '**import tempfile**'
  prefs: []
  type: TYPE_NORMAL
- en: '**from models import BoundaryCollection, PointCollection**'
  prefs: []
  type: TYPE_NORMAL
- en: import cv2
  prefs: []
  type: TYPE_NORMAL
- en: import mapnik
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Now let’s create a folder to hold our temporary files. Create a new folder
    named temp inside your Chapter5 folder.
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Modify the add_layer method to include the workaround:'
  prefs: []
  type: TYPE_NORMAL
- en: '#...'
  prefs: []
  type: TYPE_NORMAL
- en: 'def add_layer(self, geo_data, name, style=''style1''):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Add data to the map to be displayed in a layer with a given style.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param geo_data: a BaseGeoCollection subclass instance.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: 'if platform.system() == "Windows":'
  prefs: []
  type: TYPE_NORMAL
- en: print("Windows system")
  prefs: []
  type: TYPE_NORMAL
- en: temp_file, filename = tempfile.mkstemp(dir="temp") print temp_file, filename
  prefs: []
  type: TYPE_NORMAL
- en: geo_data.export_geojson(filename)
  prefs: []
  type: TYPE_NORMAL
- en: data source = mapnik.GeoJSON(file=filename)
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: data source = mapnik.Python(factory='MapDatasource',
  prefs: []
  type: TYPE_NORMAL
- en: data=geo_data)
  prefs: []
  type: TYPE_NORMAL
- en: 'layer = {"data source": data source,'
  prefs: []
  type: TYPE_NORMAL
- en: '"data": geo_data,'
  prefs: []
  type: TYPE_NORMAL
- en: '"style": style}'
  prefs: []
  type: TYPE_NORMAL
- en: self._layers[name] = layer
  prefs: []
  type: TYPE_NORMAL
- en: Here, we used platform.system() to detect whether the operating system is Windows.
    If so, instead of creating a Python DataSource, it creates a temporary file and
    exports geo_data to it. Then we use the GeoJSON plugin to open that file, creating
    a DataSource.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the workaround is complete, we need to go back to the MapDatasource
    definition and make it accept the data that we are passing to it.
  prefs: []
  type: TYPE_NORMAL
- en: '6\. In the my_datasource.py file, include the following __init__ method in
    the MapDatasource class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class MapDatasource(mapnik.PythonDatasource):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Implementation of Mapinik''s PythonDatasource."""'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, data):'
  prefs: []
  type: TYPE_NORMAL
- en: super(MapDatasource, self).__init__(envelope, geometry_type, data_type)
  prefs: []
  type: TYPE_NORMAL
- en: self.data = data
  prefs: []
  type: TYPE_NORMAL
- en: 'def features(self, query=None):'
  prefs: []
  type: TYPE_NORMAL
- en: raise NotImplementedError
  prefs: []
  type: TYPE_NORMAL
- en: Our subclass of PythonDatasource now takes one obligatory data argument. Since
    we are increasing the level of abstraction, we will make the MapDatasource class
    define all the other arguments automatically by inspecting the data it receives;
    with this change, we won’t need to worry about the geometry type or data type.
  prefs: []
  type: TYPE_NORMAL
- en: '7\. Make another change to the __init__ method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class MapDatasource(mapnik.PythonDatasource):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Implementation of Mapinik''s PythonDatasource."""'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, data):'
  prefs: []
  type: TYPE_NORMAL
- en: data_type = mapnik.DataType.vector
  prefs: []
  type: TYPE_NORMAL
- en: 'if isinstance(data, PointCollection):'
  prefs: []
  type: TYPE_NORMAL
- en: geometry_type = mapnik.GeometryType.Point
  prefs: []
  type: TYPE_NORMAL
- en: 'elif isinstance(data, BoundaryCollection):'
  prefs: []
  type: TYPE_NORMAL
- en: geometry_type = mapnik.GeometryType.Polygon
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: raise TypeError
  prefs: []
  type: TYPE_NORMAL
- en: super(MapDatasource, self).__init__(
  prefs: []
  type: TYPE_NORMAL
- en: envelope=None, geometry_type=geometry_type,
  prefs: []
  type: TYPE_NORMAL
- en: data_type=data_type)
  prefs: []
  type: TYPE_NORMAL
- en: self.data = data
  prefs: []
  type: TYPE_NORMAL
- en: 'def features(self, query=None):'
  prefs: []
  type: TYPE_NORMAL
- en: raise NotImplementedError
  prefs: []
  type: TYPE_NORMAL
- en: Here, isinstance() checks which type is data, and for each of the possible types
    it defines the corresponding geometry_type to be passed to the parent __init__
  prefs: []
  type: TYPE_NORMAL
- en: method.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, we only have one data type: the vector. Anyway, we will make this
    definition explicit (data_type = mapnik.DataType.vector) because in the next chapter,
    the raster type will be introduced.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we go any further, let’s test the app as it is.
  prefs: []
  type: TYPE_NORMAL
- en: '8\. Now edit the if __name__ == ''__main__'': block at the end of the file:
    if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: world_borders = BoundaryCollection(
  prefs: []
  type: TYPE_NORMAL
- en: '"../data/world_borders_simple.shp")'
  prefs: []
  type: TYPE_NORMAL
- en: map_app = MapMakerApp()
  prefs: []
  type: TYPE_NORMAL
- en: map_app.add_layer(world_borders, 'world')
  prefs: []
  type: TYPE_NORMAL
- en: map_app.create_map()
  prefs: []
  type: TYPE_NORMAL
- en: map_app.display_map()
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Note how Mapnik is completely abstracted; we now only deal with the high-level
  prefs: []
  type: TYPE_NORMAL
- en: functionality provided by our models and the app.
  prefs: []
  type: TYPE_NORMAL
- en: '9\. Run the code; you should see an empty map and an output like this in the
    console: File imported: ../data/world_borders_simple.shp'
  prefs: []
  type: TYPE_NORMAL
- en: Windows system
  prefs: []
  type: TYPE_NORMAL
- en: 'File exported: \geopy\Chapter5\temp\tmpfqv9ch'
  prefs: []
  type: TYPE_NORMAL
- en: 'The map is empty because two points are still missing: the features method,
    which is the glue between our geo data and the Mapnik data source, and making
    the create_map function use the layers that we have defined.'
  prefs: []
  type: TYPE_NORMAL
- en: '10\. Let’s start with the create_map method. Change its code so it can iterate
    over our layers and add them to the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '#...'
  prefs: []
  type: TYPE_NORMAL
- en: 'def create_map(self):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Creates a map and writes it to a file."""'
  prefs: []
  type: TYPE_NORMAL
- en: map = mapnik.Map(*self.map_size)
  prefs: []
  type: TYPE_NORMAL
- en: mapnik.load_map(map, self.style_file)
  prefs: []
  type: TYPE_NORMAL
- en: layers = map.layers
  prefs: []
  type: TYPE_NORMAL
- en: 'for name, layer in self._layers.iteritems():'
  prefs: []
  type: TYPE_NORMAL
- en: new_layer = mapnik.Layer(name)
  prefs: []
  type: TYPE_NORMAL
- en: new_layer.datasource = layer["data source"]
  prefs: []
  type: TYPE_NORMAL
- en: new_layer.stylers.append(layer['style'])
  prefs: []
  type: TYPE_NORMAL
- en: layers.append(new_layer)
  prefs: []
  type: TYPE_NORMAL
- en: map.zoom_all()
  prefs: []
  type: TYPE_NORMAL
- en: mapnik.render_to_file(map, self.output_image)
  prefs: []
  type: TYPE_NORMAL
- en: '11\. Now edit styles.xml in order to remove the extent restriction from it:'
  prefs: []
  type: TYPE_NORMAL
- en: <Map background-color="white">
  prefs: []
  type: TYPE_NORMAL
- en: <Style name="style1">
  prefs: []
  type: TYPE_NORMAL
- en: <Rule>
  prefs: []
  type: TYPE_NORMAL
- en: <PolygonSymbolizer fill="#f2eff9" />
  prefs: []
  type: TYPE_NORMAL
- en: <LineSymbolizer stroke="red" stroke-width="1.0" smooth="0.5" />
  prefs: []
  type: TYPE_NORMAL
- en: <TextSymbolizer face-name="DejaVu Sans Book" size="10"
  prefs: []
  type: TYPE_NORMAL
- en: fill="black" halo-fill= "white"
  prefs: []
  type: TYPE_NORMAL
- en: halo-radius="1" placement="interior"
  prefs: []
  type: TYPE_NORMAL
- en: allow-overlap="false">[NAME]
  prefs: []
  type: TYPE_NORMAL
- en: </TextSymbolizer>
  prefs: []
  type: TYPE_NORMAL
- en: </Rule>
  prefs: []
  type: TYPE_NORMAL
- en: </Style>
  prefs: []
  type: TYPE_NORMAL
- en: <Style name="style2">
  prefs: []
  type: TYPE_NORMAL
- en: <Rule>
  prefs: []
  type: TYPE_NORMAL
- en: <PointSymbolizer file="marker.svg" transform="scale(0.3)"/>
  prefs: []
  type: TYPE_NORMAL
- en: </Rule>
  prefs: []
  type: TYPE_NORMAL
- en: </Style>
  prefs: []
  type: TYPE_NORMAL
- en: </Map>
  prefs: []
  type: TYPE_NORMAL
- en: '12\. Now run the code again and look at the output. If you are using Windows,
    you should see a rendered map. If you are using Linux you should get an exception:
    Traceback (most recent call last):'
  prefs: []
  type: TYPE_NORMAL
- en: File … in <module>
  prefs: []
  type: TYPE_NORMAL
- en: raise NotImplementedError
  prefs: []
  type: TYPE_NORMAL
- en: NotImplementedError
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 1
  prefs: []
  type: TYPE_NORMAL
- en: If you got this exception (in Linux), it is because everything went fine and
    Mapnik called our unimplemented features method.
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s implement this method.
  prefs: []
  type: TYPE_NORMAL
- en: '13\. Go to the my_datasource.py file and edit our class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class MapDatasource(mapnik.PythonDatasource):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Implementation of Mapinik''s PythonDatasource."""'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, data):'
  prefs: []
  type: TYPE_NORMAL
- en: data_type = mapnik.DataType.Vector
  prefs: []
  type: TYPE_NORMAL
- en: 'if isinstance(data, PointCollection):'
  prefs: []
  type: TYPE_NORMAL
- en: geometry_type = mapnik.GeometryType.Point
  prefs: []
  type: TYPE_NORMAL
- en: 'elif isinstance(data, BoundaryCollection):'
  prefs: []
  type: TYPE_NORMAL
- en: geometry_type = mapnik.GeometryType.Polygon
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: raise TypeError
  prefs: []
  type: TYPE_NORMAL
- en: super(MapDatasource, self).__init__(
  prefs: []
  type: TYPE_NORMAL
- en: envelope=None, geometry_type=geometry_type,
  prefs: []
  type: TYPE_NORMAL
- en: data_type=data_type)
  prefs: []
  type: TYPE_NORMAL
- en: self.data = data
  prefs: []
  type: TYPE_NORMAL
- en: 'def features(self, query=None):'
  prefs: []
  type: TYPE_NORMAL
- en: keys = ['name',]
  prefs: []
  type: TYPE_NORMAL
- en: features = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for item in self.data.data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'features.append([item.geom.wkb, {''name'': item.name}])'
  prefs: []
  type: TYPE_NORMAL
- en: 'return mapnik.PythonDatasource.wkb_features(keys, features) 14\. Run the code
    again; now you should see the rendered map in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 38](img/index-272_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 39](img/index-273_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Using the app with filtering**'
  prefs: []
  type: TYPE_NORMAL
- en: Since the BaseGeoCollection class has filtering capabilities that were implemented
    before, it’s possible to filter the data before passing it to the map.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. In the map_maker_app.py file, edit the if __name__ == ''__main__'': block:
    if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: world_borders = BoundaryCollection(
  prefs: []
  type: TYPE_NORMAL
- en: '"../data/world_borders_simple.shp")'
  prefs: []
  type: TYPE_NORMAL
- en: my_country = world_borders.filter('name', 'Brazil')
  prefs: []
  type: TYPE_NORMAL
- en: map_app = MapMakerApp()
  prefs: []
  type: TYPE_NORMAL
- en: map_app.add_layer(my_country, 'countries')
  prefs: []
  type: TYPE_NORMAL
- en: map_app.create_map()
  prefs: []
  type: TYPE_NORMAL
- en: map_app.display_map()
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are using the filter function of the BaseGeoCollection class to filter
    the countries by name; feel free to try to filter by your country.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Run the code and you should see a map containing only one country (zoom
    should be active), as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Now try combining filters to show more than one country:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 40](img/index-274_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: world_borders = BoundaryCollection(
  prefs: []
  type: TYPE_NORMAL
- en: '"../data/world_borders_simple.shp")'
  prefs: []
  type: TYPE_NORMAL
- en: countries = world_borders.filter('name', 'China') +\
  prefs: []
  type: TYPE_NORMAL
- en: world_borders.filter('name', 'India') +\
  prefs: []
  type: TYPE_NORMAL
- en: world_borders.filter('name', 'Japan')
  prefs: []
  type: TYPE_NORMAL
- en: map_app = MapMakerApp()
  prefs: []
  type: TYPE_NORMAL
- en: map_app.add_layer(countries, 'countries')
  prefs: []
  type: TYPE_NORMAL
- en: map_app.create_map()
  prefs: []
  type: TYPE_NORMAL
- en: map_app.display_map()
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Run the code again and see the results.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we saw how Mapnik works and how maps are defined and styled
    using both Python and XML. Using Mapnik’s Python API, it was possible to define
    the map in XML and then alter it in Python, showing great flexibility for all
    kinds of needs.
  prefs: []
  type: TYPE_NORMAL
- en: As the app was structured, Mapnik was hidden behind high-level functionalities
    that enabled us to use the geographic data objects that we created before, allowing
    the application to filter the data to be displayed in the map.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will meet raster data for the first time; we will see
    how it works and display it in our maps.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter 6\. Working with Remote Sensing**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Images**'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start working with images—images that may come from
    a variety of sensors carried by satellites, drones, airplanes, and so on. These
    types of images, the ones collected from remote sensing devices, are images that
    contain pixels representing a spectral response from a given geographic region.
  prefs: []
  type: TYPE_NORMAL
- en: Besides just adding images to a map, it is important to prepare the images to
    be presented on the map. You may need to combine, cut, change the resolution,
    change values, and perform many other transformations in order to produce a visually
    appealing map or valuable information.
  prefs: []
  type: TYPE_NORMAL
- en: To perform these transformations on the images, we will go through a process
    of deduction that will result in a versatile and powerful software structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics covered here are:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how the images are represented
  prefs: []
  type: TYPE_NORMAL
- en: The relation of the images with the real world
  prefs: []
  type: TYPE_NORMAL
- en: Combining, cropping, and adjusting the values of the images Creating shaded
    relief maps from the elevation data
  prefs: []
  type: TYPE_NORMAL
- en: How to execute a sequence of processing steps
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 41](img/index-279_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Understanding how images are**'
  prefs: []
  type: TYPE_NORMAL
- en: '**represented**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to understand what images are in terms of computer representation
    and the data they contain, we are going to start with some examples. The first
    thing to do is to organize your project to follow this chapter’s code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. As before, inside your geopy project, make a copy of your Chapter5 folder
    and rename it to Chapter6\.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Inside Chapter6, navigate to the experiments folder and create a new file
    inside it named image_experiments.py. Open it for editing.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by inspecting a small sample image that has a structure similar
    to a large satellite image.
  prefs: []
  type: TYPE_NORMAL
- en: Nothing fancy, you will see four squares of different colors. But if we take
    a step further and add a grid to it, we can see a little bit more information.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 42](img/index-280_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The image was divided into 16 squares of equal size. Each one of these squares
    is a so-called **pixel**. A pixel is the smallest portion of information that
    an image (that is, raster data) contains. While talking about geoprocessing, the
    image as a whole comprehends a space in the real world and each pixel is a fraction
    of that space.
  prefs: []
  type: TYPE_NORMAL
- en: When we added the sample image to the map in the beginning of the chapter, we
    manually defined the extent of this image (that is, its bounding box). This information
    told Mapnik how the coordinates in the image relates to the real world coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have seen that our sample image has 16 pixels with a shape of 4 x
    4\. But how this image or any other raster data relates to a real world space
    depends on the information that may or may not be stored in the data itself.
  prefs: []
  type: TYPE_NORMAL
- en: The first information that states the relation is where the image is in the
    world. Images and raster data normally have their point of origin in the top left
    corner. If we assign a coordinate to the point of origin, we will be able to place
    the image on the world.
  prefs: []
  type: TYPE_NORMAL
- en: 'Secondly, we need information on the area that this image covers. And there
    are three ways this information can appear:'
  prefs: []
  type: TYPE_NORMAL
- en: The size of the pixels of the image
  prefs: []
  type: TYPE_NORMAL
- en: The size of the image
  prefs: []
  type: TYPE_NORMAL
- en: The coordinates of the bounding box of the image
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 43](img/index-281_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This information is related by the following equations:'
  prefs: []
  type: TYPE_NORMAL
- en: x_pixel_size = width / columns
  prefs: []
  type: TYPE_NORMAL
- en: y_pixel_size = height / lines
  prefs: []
  type: TYPE_NORMAL
- en: width = xmax – xmin
  prefs: []
  type: TYPE_NORMAL
- en: height = ymax – ymin
  prefs: []
  type: TYPE_NORMAL
- en: '**Opening images with OpenCV**'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a better understanding, we will open the sample image with OpenCV and inspect
    its contents as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. In your image_expriments.py file, type the following code: def open_raster_file(image):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Opens a raster file.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param image: Path of the raster file or np array.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: image = cv2.imread(image)
  prefs: []
  type: TYPE_NORMAL
- en: return image
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: image = open_raster_file('../../data/sample_image.tiff')
  prefs: []
  type: TYPE_NORMAL
- en: print(image)
  prefs: []
  type: TYPE_NORMAL
- en: print(type(image))
  prefs: []
  type: TYPE_NORMAL
- en: print(image.shape)
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Run the code. Since it’s the first time you have run this file, press *Alt*
    + *Shift* + *F10*
  prefs: []
  type: TYPE_NORMAL
- en: 'and choose image_experiments from the list. You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[[[ 0 0 255]'
  prefs: []
  type: TYPE_NORMAL
- en: '[ 0 0 255]'
  prefs: []
  type: TYPE_NORMAL
- en: '[ 0 255 0]'
  prefs: []
  type: TYPE_NORMAL
- en: '[ 0 255 0]]'
  prefs: []
  type: TYPE_NORMAL
- en: '[[ 0 0 255]'
  prefs: []
  type: TYPE_NORMAL
- en: '[ 0 0 255]'
  prefs: []
  type: TYPE_NORMAL
- en: '[ 0 255 0]'
  prefs: []
  type: TYPE_NORMAL
- en: '[ 0 255 0]]'
  prefs: []
  type: TYPE_NORMAL
- en: '[[255 0 0]'
  prefs: []
  type: TYPE_NORMAL
- en: '[255 0 0]'
  prefs: []
  type: TYPE_NORMAL
- en: '[100 100 100]'
  prefs: []
  type: TYPE_NORMAL
- en: '[100 100 100]]'
  prefs: []
  type: TYPE_NORMAL
- en: '[[255 0 0]'
  prefs: []
  type: TYPE_NORMAL
- en: '[255 0 0]'
  prefs: []
  type: TYPE_NORMAL
- en: '[100 100 100]'
  prefs: []
  type: TYPE_NORMAL
- en: '[100 100 100]]]'
  prefs: []
  type: TYPE_NORMAL
- en: <type 'numpy.ndarray'>
  prefs: []
  type: TYPE_NORMAL
- en: (4, 4, 3)
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: The expression print(type(image)) prints the type of the object that is stored
    in the image variable. As you can see, it’s a NumPy array with a shape of 4 x
    4 x 3\. OpenCV
  prefs: []
  type: TYPE_NORMAL
- en: opens the image and put its data inside an array, although for now, it is a
    little bit hard to visualize how the data is organized. The array contains the
    color information for each
  prefs: []
  type: TYPE_NORMAL
- en: pixel on the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For better visualization, I’m going to reorganize the print output for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[[[ 0 0 255] [ 0 0 255] [ 0 255 0] [ 0 255 0]]'
  prefs: []
  type: TYPE_NORMAL
- en: '[[ 0 0 255] [ 0 0 255] [ 0 255 0] [ 0 255 0]]'
  prefs: []
  type: TYPE_NORMAL
- en: '[[255 0 0] [255 0 0] [100 100 100] [100 100 100]]'
  prefs: []
  type: TYPE_NORMAL
- en: '[[255 0 0] [255 0 0] [100 100 100] [100 100 100]]]'
  prefs: []
  type: TYPE_NORMAL
- en: Now the shape of the array makes more sense. Notice that we have four *lines*
    and each line has four *columns* exactly as it is seen in the image. By its turn,
    each item has a set of three numbers that represents the values for the blue,
    green, and red channels.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that when you import a colored image with OpenCV, the order of the
    channels will be BGR (blue, green, and red).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, take the first pixel in the top left corner. It’s all red as we
    see in the image: Blue Green Red'
  prefs: []
  type: TYPE_NORMAL
- en: '[ 0 0 255]'
  prefs: []
  type: TYPE_NORMAL
- en: So, the first and the most important implication of the images being imported
    as NumPy arrays is that they behave like arrays and have all the functions and
    methods that any NumPy array has, opening the possibility of using the full power
    of NumPy while working with raster data.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 44](img/index-284_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Knowing numerical types**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each pixel in the previous topic has three channels: blue, green, and red.
    Each one has a value ranging from 0 to 255 (256 possible values). The combination
    of these channels result in a visible color. This range of values is not random;
    256 is the number of combinations that is possible to achieve with a single **byte**.'
  prefs: []
  type: TYPE_NORMAL
- en: A byte is the smallest portion of data that a computer can store and retrieve
    from the memory. It’s composed of 8 bits of zeros or ones.
  prefs: []
  type: TYPE_NORMAL
- en: This is important to us because the computer uses its memory to store the image
    and it will reserve a given space to store the value for each channel for each
    pixel. We must be sure that the space reserved is adequate for the data we want
    to store.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s make an abstraction. Think that you have 1 liter (1,000 ml) of water and
    you want to store it. If you choose a 250 ml cup to store this water, the excess
    will spill out. If you choose a water truck with 10,000 liter capacity, you can
    store the water, but it will be a huge waste of space. So, you may choose a 3
    liter bucket that would be sufficient to store the water. It’s not big as a truck
    and you will have some extra space if you want to store a little bit more water.
  prefs: []
  type: TYPE_NORMAL
- en: In computing, things work similarly. You need to choose the size of the container
    before you put things in it. In the previous example, OpenCV made this choice
    for us. You will see a number of instances in the future where the programs we
    use will help us in these choices. But a clear understanding on how this works
    is very important because if the water spills out (that is, overflows), you will
    end up with unexpected behavior in your program. Or, if you choose a too large
    recipient, you may run out of computer memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The needs for value storage may vary in the aspects of:'
  prefs: []
  type: TYPE_NORMAL
- en: Only positive or positive and negative numbers
  prefs: []
  type: TYPE_NORMAL
- en: Integers or fractions
  prefs: []
  type: TYPE_NORMAL
- en: Small or large numbers
  prefs: []
  type: TYPE_NORMAL
- en: Complex numbers
  prefs: []
  type: TYPE_NORMAL
- en: 'The available options and their sizes may vary with the computer architecture
    and software. For a common 64-bit desktop, NumPy will give you these possible
    numerical types:'
  prefs: []
  type: TYPE_NORMAL
- en: 'bool: Boolean (True or False) stored as a byte'
  prefs: []
  type: TYPE_NORMAL
- en: 'int8: Byte (-128 to 127)'
  prefs: []
  type: TYPE_NORMAL
- en: 'int16: Integer (-32768 to 32767)'
  prefs: []
  type: TYPE_NORMAL
- en: 'int32: Integer (-2147483648 to 2147483647) int64: Integer (-9223372036854775808
    to 9223372036854775807) uint8: Unsigned integer (0 to 255)'
  prefs: []
  type: TYPE_NORMAL
- en: 'uint16: Unsigned integer (0 to 65535)'
  prefs: []
  type: TYPE_NORMAL
- en: 'uint32: Unsigned integer (0 to 4294967295)'
  prefs: []
  type: TYPE_NORMAL
- en: 'uint64: Unsigned integer (0 to 18446744073709551615)'
  prefs: []
  type: TYPE_NORMAL
- en: 'float16: Half precision float: sign bit, 5 bits exponent, 10 bits mantissa
    float32: Single precision float: sign bit, 8 bits exponent, 23 bits mantissa float64:
    Double precision float: sign bit, 11 bits exponent, 52 bits mantissa complex64:
    Complex number represented by two 32-bit floats (real and imaginary components)'
  prefs: []
  type: TYPE_NORMAL
- en: 'complex128: Complex number represented by two 64-bit floats (real and imaginary
    components)'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we may expect that our sample image has the type uint8\. Let’s check whether
    it’s true:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Edit the if __name__ == ''__main__'': block:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: image = open_raster_file('../../data/sample_image.tiff')
  prefs: []
  type: TYPE_NORMAL
- en: print(type(image))
  prefs: []
  type: TYPE_NORMAL
- en: print(image.dtype)
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Run the code again. You should see an output matching our expectations:'
  prefs: []
  type: TYPE_NORMAL
- en: <type 'numpy.ndarray'>
  prefs: []
  type: TYPE_NORMAL
- en: uint8
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: '**Processing remote sensing images and**'
  prefs: []
  type: TYPE_NORMAL
- en: '**data**'
  prefs: []
  type: TYPE_NORMAL
- en: Satellite images come in a different format and serve different purposes. These
    images can be used to visualize features on Earth using real colors or they may
    be used to identify a variety of characteristics using parts of the spectrum invisible
    to the human eye.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw, our sample image had three channels (blue, green, and red) that were
    combined in a single file to compose a real color image. Different from the sample
    image, most satellite data comes with each channel separated into a file for each
    one of them.
  prefs: []
  type: TYPE_NORMAL
- en: These channels are called **bands** and comprise of a range of the electromagnetic
    spectrum visible or not to the human eye.
  prefs: []
  type: TYPE_NORMAL
- en: In the following examples, we are going to use the **digital elevation models**
    (**DEM**) generated with the data obtained by the **Advanced Spaceborne Thermal
    Emission and** **Reflection Radiometer** (**ASTER**).
  prefs: []
  type: TYPE_NORMAL
- en: These DEM have a resolution of approximately 90 m and the values are stored
    in the 16
  prefs: []
  type: TYPE_NORMAL
- en: bits signed integers representing the elevation in meters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dataset we are going to use is included in the data folder and is from
    a Brazilian city called *Poços de Caldas*. This city is inside a giant extinct
    volcano crater, a feature we hope to see during data processing. For didactic
    reasons and in order to cover a big region, four images will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: You can obtain more digital elevation models at [http://earthexplorer.usgs.gov/.](http://earthexplorer.usgs.gov/)
  prefs: []
  type: TYPE_NORMAL
- en: 1\. If want to download and use your own DEM, you need to extract the downloaded
    ZIP
  prefs: []
  type: TYPE_NORMAL
- en: file. Notice that each ZIP archive has two images. The one ending with _dem
    is the actual elevation data. The one ending with _num contains the quality assessment
    information. Take a look at the included README.pdf file for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Move or copy all the images to the data folder of your Chapter 6 code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each image represents a tile of 1 degree. The information on which tile the
    image covers is encoded in the name of the file, as seen in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 45](img/index-288_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Mosaicking images**'
  prefs: []
  type: TYPE_NORMAL
- en: Mapnik has the ability to read tiled data from the disk using the raster data
    source. But we are not going to use it, because the process of patching images
    together is very important and is worth learning.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next code will open the images, combine them, and save a single combined
    image in the disk. This process (with varying levels of complexity) is called
    **mosaicking**: 1\. Still in the image_experiments.py file, add a new function
    after the open_raster_file function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def combine_images(input_images):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Combine images in a mosaic.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param input_images: Path to the input images.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: images = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for item in input_images:'
  prefs: []
  type: TYPE_NORMAL
- en: images.append(open_raster_file(item))
  prefs: []
  type: TYPE_NORMAL
- en: print images
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Now, edit the if __name__ == ''__main__'': block so we can test the code:
    if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: elevation_data = [
  prefs: []
  type: TYPE_NORMAL
- en: '''../../data/ASTGTM2_S22W048_dem.tif'','
  prefs: []
  type: TYPE_NORMAL
- en: '''../../data/ASTGTM2_S22W047_dem.tif'','
  prefs: []
  type: TYPE_NORMAL
- en: '''../../data/ASTGTM2_S23W048_dem.tif'','
  prefs: []
  type: TYPE_NORMAL
- en: '''../../data/ASTGTM2_S23W047_dem.tif'']'
  prefs: []
  type: TYPE_NORMAL
- en: combine_images(elevation_data)
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Run the code and look at the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[array([[[1, 1, 1],'
  prefs: []
  type: TYPE_NORMAL
- en: '[1, 1, 1],'
  prefs: []
  type: TYPE_NORMAL
- en: '[2, 2, 2],'
  prefs: []
  type: TYPE_NORMAL
- en: '...,'
  prefs: []
  type: TYPE_NORMAL
- en: '[4, 4, 4],'
  prefs: []
  type: TYPE_NORMAL
- en: '[4, 4, 4],'
  prefs: []
  type: TYPE_NORMAL
- en: '[4, 4, 4]],'
  prefs: []
  type: TYPE_NORMAL
- en: . . .
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: You should see a list of four arrays. PyCharm will hide some values so it can
    fit in the console.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we should notice is that the order of the images in the input
    images argument is the same as the order of the arrays in the output list. This
    will be very important later.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, although the elevation data is a 16-bit signed integer (int16), the
    arrays representing the images still have three bands of an 8-bit unsigned integer.
    This is an error.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 46](img/index-290_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'OpenCV is converting the grayscale image to a color image. We are going to
    fix it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Change the open_raster_file function to accept a new argument. It will
    allow us to open the images without changing them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def open_raster_file(image, unchanged=True):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Opens a raster file.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param image: Path of the raster file or np array.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param unchanged: Set to true to keep the original format.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: flags = cv2.CV_LOAD_IMAGE_UNCHANGED if unchanged else -1
  prefs: []
  type: TYPE_NORMAL
- en: image = cv2.imread(image, flags=flags)
  prefs: []
  type: TYPE_NORMAL
- en: return image
  prefs: []
  type: TYPE_NORMAL
- en: The flags argument in cv2.imread allows us to tune how the images are opened
    and converted into arrays. If the flags are set to cv2.CV_LOAD_IMAGE_UNCHANGED,
    the image will open as it is without any conversion.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Since we set the default of unchanged to true, we will just run the code
    again and see the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[array([[ 508, 511, 514, ..., 1144, 1148, 1152],'
  prefs: []
  type: TYPE_NORMAL
- en: '[ 507, 510, 510, ..., 1141, 1144, 1150],'
  prefs: []
  type: TYPE_NORMAL
- en: '[ 510, 508, 506, ..., 1141, 1145, 1154],'
  prefs: []
  type: TYPE_NORMAL
- en: '...,'
  prefs: []
  type: TYPE_NORMAL
- en: '[ 805, 805, 803, ..., 599, 596, 593],'
  prefs: []
  type: TYPE_NORMAL
- en: '[ 802, 797, 803, ..., 598, 594, 590],'
  prefs: []
  type: TYPE_NORMAL
- en: '[ 797, 797, 800, ..., 603, 596, 593]], dtype=uint16)'
  prefs: []
  type: TYPE_NORMAL
- en: . . .
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: The values now are correct and they are the measured elevation in meters for
    each pixel.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have a list of arrays in the order that the input files are listed.
    To figure out the next step, we can imagine this list as if the images were mosaicked
    as a strip: Now, we must reorganize this, so the images are placed in their correct
    position.'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that NumPy arrays have a shape property. In a 2D array, it’s a tuple
    containing
  prefs: []
  type: TYPE_NORMAL
- en: the shape in columns and rows. NumPy arrays also have the reshape() method that
    performs a shape transformation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the NumPy documentation on the reshape method and function. Changing
    the shape of an array is a very powerful tool at
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.scipy.org/doc/numpy/reference/generated/numpy.reshape.html.](http://docs.scipy.org/doc/numpy/reference/generated/numpy.reshape.html)'
  prefs: []
  type: TYPE_NORMAL
- en: The reshape works by filling a row with the input values in order. When the
    row is full, the method jumps to the next row and continues until the end. So,
    if we pass the expected shape of the mosaic to the combine_images function, we
    can use this information to combine the images with respect to the proper positions.
  prefs: []
  type: TYPE_NORMAL
- en: 'But we need something else. We need to know the shape of the output image through
    the number of pixels, and this will be the product of the shape of each image
    by the shape of the mosaic. Let’s try a few changes in the code as follows: 1\.
    Edit the combine images function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def combine_images(input_images, shape, output_image):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Combine images in a mosaic.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param input_images: Path to the input images.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param shape: Shape of the mosaic in columns and rows.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param output_image: Path to the output image mosaic.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: 'if len(input_images) != shape[0] * shape[1]:'
  prefs: []
  type: TYPE_NORMAL
- en: raise ValueError(
  prefs: []
  type: TYPE_NORMAL
- en: '"Number of images doesn''t match the mosaic shape.") images = []'
  prefs: []
  type: TYPE_NORMAL
- en: 'for item in input_images:'
  prefs: []
  type: TYPE_NORMAL
- en: images.append(open_raster_file(item))
  prefs: []
  type: TYPE_NORMAL
- en: rows = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for row in range(shape[0]):'
  prefs: []
  type: TYPE_NORMAL
- en: start = (row * shape[1])
  prefs: []
  type: TYPE_NORMAL
- en: end = start + shape[1]
  prefs: []
  type: TYPE_NORMAL
- en: rows.append(np.concatenate(images[start:end], axis=1))
  prefs: []
  type: TYPE_NORMAL
- en: mosaic = np.concatenate(rows, axis=0)
  prefs: []
  type: TYPE_NORMAL
- en: print(mosaic)
  prefs: []
  type: TYPE_NORMAL
- en: print(mosaic.shape)
  prefs: []
  type: TYPE_NORMAL
- en: Now the function accepts two more arguments, the shape of the mosaic (the number
    of images in the row and columns and not the number of pixels) and the path of
    the output image for later use.
  prefs: []
  type: TYPE_NORMAL
- en: With this code, the list of images is separated into rows. Then, the rows are
    combined to form the complete mosaic.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Before you run the code, don’t forget to import NumPy at the beginning
    of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import cv2
  prefs: []
  type: TYPE_NORMAL
- en: import numpy as np
  prefs: []
  type: TYPE_NORMAL
- en: 'And edit the if __name__ == ''__main__'': block: if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: elevation_data = [
  prefs: []
  type: TYPE_NORMAL
- en: '''../../data/ASTGTM2_S22W048_dem.tif'','
  prefs: []
  type: TYPE_NORMAL
- en: '''../../data/ASTGTM2_S22W047_dem.tif'','
  prefs: []
  type: TYPE_NORMAL
- en: '''../../data/ASTGTM2_S23W048_dem.tif'','
  prefs: []
  type: TYPE_NORMAL
- en: '''../../data/ASTGTM2_S23W047_dem.tif'']'
  prefs: []
  type: TYPE_NORMAL
- en: combine_images(elevation_data, shape=(2, 2))
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Now run the code and see the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[[508 511 514…, 761 761 761]'
  prefs: []
  type: TYPE_NORMAL
- en: '[507 510 510…, 761 761 761]'
  prefs: []
  type: TYPE_NORMAL
- en: '[510 508 506…, 761 761 761]'
  prefs: []
  type: TYPE_NORMAL
- en: '...,'
  prefs: []
  type: TYPE_NORMAL
- en: '[514 520 517…, 751 745 739]'
  prefs: []
  type: TYPE_NORMAL
- en: '[517 524 517…, 758 756 753]'
  prefs: []
  type: TYPE_NORMAL
- en: '[509 509 510…, 757 759 760]]'
  prefs: []
  type: TYPE_NORMAL
- en: (7202, 7202)
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: It’s now a single array with 7202 x 7202 pixels. The remaining task is to save
    this array to the disk as an image.
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Just add two lines to the function and edit the if __name__ == ''__main__'':
    block: def combine_images(input_images, shape, output_image):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Combine images in a mosaic.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param input_images: Path to the input images.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param shape: Shape of the mosaic in columns and rows.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param output_image: Path to the output image mosaic.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: 'if len(input_images) != shape[0] * shape[1]:'
  prefs: []
  type: TYPE_NORMAL
- en: raise ValueError(
  prefs: []
  type: TYPE_NORMAL
- en: '"Number of images doesn''t match the mosaic shape.") images = []'
  prefs: []
  type: TYPE_NORMAL
- en: 'for item in input_images:'
  prefs: []
  type: TYPE_NORMAL
- en: images.append(open_raster_file(item))
  prefs: []
  type: TYPE_NORMAL
- en: rows = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for row in range(shape[0]):'
  prefs: []
  type: TYPE_NORMAL
- en: start = (row * shape[1])
  prefs: []
  type: TYPE_NORMAL
- en: end = start + shape[1]
  prefs: []
  type: TYPE_NORMAL
- en: rows.append(np.concatenate(images[start:end], axis=1))
  prefs: []
  type: TYPE_NORMAL
- en: mosaic = np.concatenate(rows, axis=0)
  prefs: []
  type: TYPE_NORMAL
- en: print(mosaic)
  prefs: []
  type: TYPE_NORMAL
- en: print(mosaic.shape)
  prefs: []
  type: TYPE_NORMAL
- en: cv2.imwrite(output_image, mosaic)
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: elevation_data = [
  prefs: []
  type: TYPE_NORMAL
- en: '''../../data/ASTGTM2_S22W048_dem.tif'','
  prefs: []
  type: TYPE_NORMAL
- en: '''../../data/ASTGTM2_S22W047_dem.tif'','
  prefs: []
  type: TYPE_NORMAL
- en: '''../../data/ASTGTM2_S23W048_dem.tif'','
  prefs: []
  type: TYPE_NORMAL
- en: '''../../data/ASTGTM2_S23W047_dem.tif'']'
  prefs: []
  type: TYPE_NORMAL
- en: combine_images(elevation_data, shape=(2, 2),
  prefs: []
  type: TYPE_NORMAL
- en: output_image="../output/mosaic.png")
  prefs: []
  type: TYPE_NORMAL
- en: '**Adjusting the values of the images**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the previous code, you will see a black image as an output. This
    happens because the value range that represents the actual data of this region
    is so narrow in comparison to the possible range of the 16-bit integer image that
    we can’t distinguish the shades of gray. For better understanding, let’s make
    a simple test as follows: 1\. Still in the image_experiments.py file, comment
    the if __name__ == ''__main__'': block and add this new one:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: image = open_raster_file("../output/mosaic.png")
  prefs: []
  type: TYPE_NORMAL
- en: print(image.min(), image.max())
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Run the code and look at the console output.
  prefs: []
  type: TYPE_NORMAL
- en: (423, 2026)
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: Precisely, the image ranges from -32768 to 32767 and the elevation of the region
    in it ranges from 423 to 2026\. So what we need to do to make the image visible
    is to scale the altitude range to the range of the data type.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are making a data representation intended for human visualization,
    we don’t need to use a big range of gray values. The researches vary, but some
    say that we can detect only 30 shades, so an 8-bit unsigned integer with 256 possible
    values should be more than enough for data visualization.
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Add this new function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def adjust_values(input_image, output_image, img_range=None):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Create a visualization of the data in the input_image by projecting a range
    of values into a grayscale image.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param input_image: Array containing the data'
  prefs: []
  type: TYPE_NORMAL
- en: or path to an image.
  prefs: []
  type: TYPE_NORMAL
- en: ':param output_image: The image path to write the output.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param img_range: specified range of values or None to use the range of the
    image (minimum and maximum).'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: image = open_raster_file(input_image)
  prefs: []
  type: TYPE_NORMAL
- en: 'if img_range:'
  prefs: []
  type: TYPE_NORMAL
- en: min = img_range[0]
  prefs: []
  type: TYPE_NORMAL
- en: max = img_range[1]
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: min = image.min()
  prefs: []
  type: TYPE_NORMAL
- en: max = image.max()
  prefs: []
  type: TYPE_NORMAL
- en: interval = max - min
  prefs: []
  type: TYPE_NORMAL
- en: factor = 256.0 / interval
  prefs: []
  type: TYPE_NORMAL
- en: output = image * factor
  prefs: []
  type: TYPE_NORMAL
- en: cv2.imwrite(output_image, output)
  prefs: []
  type: TYPE_NORMAL
- en: This function accepts either an array or the path to an image file. With this
    feature,
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 47](img/index-295_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: we can later use this function as a sub-step in other processing procedures.
    The range of values that you want to use is also optional. It can be set manually
    or can be extracted from the images minimum and maximum value.
  prefs: []
  type: TYPE_NORMAL
- en: '4\. To test the code, edit the if __name__ == ''__main__'': block: if __name__
    == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: Adjust.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: adjust_values('../output/mosaic.png',
  prefs: []
  type: TYPE_NORMAL
- en: '''../output/mosaic_grey.png'')'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the output image is now a png file. Since we are preparing the image
    for visualization, we can afford to lose information in data compression in exchange
    for a smaller file.
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Run the code and open the mosaic_grey.png file to see the results. You
    should see the following beautiful grayscale image now:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cropping an image**'
  prefs: []
  type: TYPE_NORMAL
- en: We made a big mosaic of images in order to cover the region of interest, and
    in the process, we ended up with an image much bigger than the one we needed.
    Now, it’s time to crop the image, so we end up with a smaller one comprising only
    of what we want to see, thus saving disk space and processing time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we are interested in the volcano crater. It’s the round object
    located on the right-hand side of the image. In order to obtain only that region
    of interest, we will write a function that can crop the image using a bounding
    box set of coordinates, as follows: 1\. Add the new function to the image_experiments.py
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def crop_image(input_image, image_extent, bbox, output_image):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Crops an image by a bounding box.'
  prefs: []
  type: TYPE_NORMAL
- en: 'bbox and image_extent format: (xmin, ymin, xmax, ymax).'
  prefs: []
  type: TYPE_NORMAL
- en: ':param input_image: Array containing the data'
  prefs: []
  type: TYPE_NORMAL
- en: or path to an image.
  prefs: []
  type: TYPE_NORMAL
- en: ':param image_extent: The geographic extent of the image.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param output_image: The image path to write the output.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param bbox: The bounding box of the region of interest.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: input_image = open_raster_file(input_image)
  prefs: []
  type: TYPE_NORMAL
- en: img_shape = input_image.shape
  prefs: []
  type: TYPE_NORMAL
- en: img_geo_width = abs(image_extent[2] - image_extent[0])
  prefs: []
  type: TYPE_NORMAL
- en: img_geo_height = abs(image_extent[3] - image_extent[1])
  prefs: []
  type: TYPE_NORMAL
- en: How much pixels are contained in one geographic unit.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pixel_width = img_shape[1] / img_geo_width
  prefs: []
  type: TYPE_NORMAL
- en: pixel_height = img_shape[0] / img_geo_height
  prefs: []
  type: TYPE_NORMAL
- en: Index of the pixel to cut.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: x_min = abs(bbox[0] - image_extent[0]) * pixel_width
  prefs: []
  type: TYPE_NORMAL
- en: x_max = abs(bbox[2] - image_extent[0]) * pixel_width
  prefs: []
  type: TYPE_NORMAL
- en: y_min = abs(bbox[1] - image_extent[1]) * pixel_height
  prefs: []
  type: TYPE_NORMAL
- en: y_max = abs(bbox[3] - image_extent[1]) * pixel_height
  prefs: []
  type: TYPE_NORMAL
- en: output = input_image[y_min:y_max, x_min:x_max]
  prefs: []
  type: TYPE_NORMAL
- en: cv2.imwrite(output_image, output)
  prefs: []
  type: TYPE_NORMAL
- en: Since we are dealing with NumPy arrays, the cropping itself is a simple array
    slicing.
  prefs: []
  type: TYPE_NORMAL
- en: The slicing of arrays is very similar to the Python lists’ slicing, but with
    additional dimensions. The statement input_image[y_min:y_max, x_min:x_max] tells
    that we want only the portion of the array contained within the specified cells
    (that is, pixels).
  prefs: []
  type: TYPE_NORMAL
- en: So, all the math involved is to convert geographic units into array indices.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Edit the if __name__ == ''__main__'': block to test the code: if __name__
    == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: Crop.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'roi = (-46.8, -21.7, -46.3, -22.1) # Region of interest.'
  prefs: []
  type: TYPE_NORMAL
- en: crop_image('../output/mosaic_grey.png',
  prefs: []
  type: TYPE_NORMAL
- en: (-48, -21, -46, -23), roi, "../output/cropped.png")
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 48](img/index-297_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 3\. Run the code and open the output image to see the results.
  prefs: []
  type: TYPE_NORMAL
- en: '4\. If you have missed any of the steps, you can run the whole process all
    at once. Just edit the if __name__ == ''__main__'' block:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: Combine.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: elevation_data = [
  prefs: []
  type: TYPE_NORMAL
- en: '''../../data/ASTGTM2_S22W048_dem.tif'','
  prefs: []
  type: TYPE_NORMAL
- en: '''../../data/ASTGTM2_S22W047_dem.tif'','
  prefs: []
  type: TYPE_NORMAL
- en: '''../../data/ASTGTM2_S23W048_dem.tif'','
  prefs: []
  type: TYPE_NORMAL
- en: '''../../data/ASTGTM2_S23W047_dem.tif'']'
  prefs: []
  type: TYPE_NORMAL
- en: combine_images(elevation_data, shape=(2, 2),
  prefs: []
  type: TYPE_NORMAL
- en: output_image="../output/mosaic.png")
  prefs: []
  type: TYPE_NORMAL
- en: Adjust.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: adjust_values('../output/mosaic.png',
  prefs: []
  type: TYPE_NORMAL
- en: '''../output/mosaic_grey.png'')'
  prefs: []
  type: TYPE_NORMAL
- en: Crop.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'roi = (-46.8, -21.7, -46.3, -22.1) # Region of interest.'
  prefs: []
  type: TYPE_NORMAL
- en: crop_image('../output/mosaic_grey.png',
  prefs: []
  type: TYPE_NORMAL
- en: (-48, -21, -46, -23), roi, "../output/cropped.png")
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 49](img/index-298_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Creating a shaded relief image**'
  prefs: []
  type: TYPE_NORMAL
- en: Our digital elevation model image has improved a lot after we processed it,
    but it is still not suitable for a map. Untrained eyes may find it difficult to
    understand the relief only by looking at the different shades of gray.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, there is a technique, called **hill shading** or **relief shading**,
    that transforms the elevation data into a simulated sun shading over the terrain.
    Look at the beautiful map in the following picture and note how much easier it
    is to understand the relief when it is presented as a shaded relief:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The process is simple and involves passing our image through a well-known algorithm
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Add the create_hillshade function to your image_experiments.py file: def
    create_hillshade(input_image, output_image,'
  prefs: []
  type: TYPE_NORMAL
- en: 'azimuth=90, angle_altitude=60):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Creates a shaded relief image from a digital elevation model.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param input_image: Array containing the data'
  prefs: []
  type: TYPE_NORMAL
- en: or path to an image.
  prefs: []
  type: TYPE_NORMAL
- en: ':param azimuth: Simulated sun azimuth.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param angle_altitude: Sun altitude angle.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: input_image = open_raster_file(input_image)
  prefs: []
  type: TYPE_NORMAL
- en: x, y = np.gradient(input_image)
  prefs: []
  type: TYPE_NORMAL
- en: slope = np.pi / 2 - np.arctan(np.sqrt(x * x + y * y))
  prefs: []
  type: TYPE_NORMAL
- en: aspect = np.arctan2(-x, y)
  prefs: []
  type: TYPE_NORMAL
- en: az_rad = azimuth * np.pi / 180
  prefs: []
  type: TYPE_NORMAL
- en: alt_rad = angle_altitude * np.pi / 180
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 50](img/index-299_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: a = np.sin(alt_rad) * np.sin(slope)
  prefs: []
  type: TYPE_NORMAL
- en: b = np.cos(alt_rad) * np.cos(slope) * np.cos(az_rad - aspect) output = 255 *
    (a + b + 1) / 2
  prefs: []
  type: TYPE_NORMAL
- en: cv2.imwrite(output_image, output)
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Now, alter the if __name__ == ''__main__'': block to test the code: if
    __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: create_hillshade("../output/cropped.png",
  prefs: []
  type: TYPE_NORMAL
- en: '"../output/hillshade.png")'
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Run the code and open the output image to see the results. If everything
    goes fine, you should see a shaded relief representation of your data.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 51](img/index-301_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Building an image processing pipeline**'
  prefs: []
  type: TYPE_NORMAL
- en: Image processing, be it for geographic applications or not, generally requires
    the execution of a sequence of transformations (that is, steps) in order to obtain
    the desired final result. In these sequences, the output of one step is the input
    of the next one. In computing, this is called **processing pipeline**.
  prefs: []
  type: TYPE_NORMAL
- en: This type of data manipulation is very versatile, because you have a range of
    functions or steps than can be arranged into numerous combinations to produce
    a wide range of results.
  prefs: []
  type: TYPE_NORMAL
- en: What we did so far, in this chapter’s examples, was we opened an image from
    the disk, performed a given operation, and saved the results to another image
    on the disk. Then, in the next step, we opened the result from the previous one
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite the steps are not yet connected, we can imagine the following image
    processing pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: Saving intermediary steps to the disk is useful when we want to use the images
    from them, or in other situations, when the pipeline uses parallel processing
    or other more complex methods.
  prefs: []
  type: TYPE_NORMAL
- en: For some cases, it would be more interesting just to pass data along the pipeline
    without touching the hard drive, only using the computer memory. With this, one
    should expect a noticeable gain in speed and a lesser production of residual files.
  prefs: []
  type: TYPE_NORMAL
- en: In order to conciliate these two situations, we can use type checks for our
    functions’
  prefs: []
  type: TYPE_NORMAL
- en: 'arguments, making them accept either arrays or file paths. Navigate to your
    open_raster_file function and alter its code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def open_raster_file(file_path, unchanged=True):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Opens a raster file.'
  prefs: []
  type: TYPE_NORMAL
- en: '**:param file_path: Path of the raster file or np array.**'
  prefs: []
  type: TYPE_NORMAL
- en: ':param unchanged: Set to true to keep the original format.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: '**if isinstance(file_path, np.ndarray):**'
  prefs: []
  type: TYPE_NORMAL
- en: '**return file_path**'
  prefs: []
  type: TYPE_NORMAL
- en: flags = cv2.CV_LOAD_IMAGE_UNCHANGED if unchanged else -1
  prefs: []
  type: TYPE_NORMAL
- en: image = cv2.imread(file_path, flags=flags)
  prefs: []
  type: TYPE_NORMAL
- en: return image
  prefs: []
  type: TYPE_NORMAL
- en: This function will now check the type of file_path. If it is already a NumPy
    array, it will be returned. This changes the behavior of all of our functions
    because they can now receive arrays as input.
  prefs: []
  type: TYPE_NORMAL
- en: If we add a return statement to all the functions and make them return the output
    arrays,
  prefs: []
  type: TYPE_NORMAL
- en: 'we would be able to combine the function as follows: create_hillshade('
  prefs: []
  type: TYPE_NORMAL
- en: crop_image(
  prefs: []
  type: TYPE_NORMAL
- en: adjust_values('mosaic.png'),
  prefs: []
  type: TYPE_NORMAL
- en: (-48, -21, -46, -23), roi), 'shaded.png')
  prefs: []
  type: TYPE_NORMAL
- en: You don’t need to type this code. This notation is hard to understand. The order
    in which the functions are called is unintuitive and it’s difficult to figure
    out of which function is each argument.
  prefs: []
  type: TYPE_NORMAL
- en: It would be much nicer if we could execute the pipeline by chaining the functions,
    like we did in the *Chaining filters* section in [Chapter 4,](index_split_001.html#p174)
    *Improving the App Search Capabilities*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, it would be great to use something with a notation as follows: adjust_values().crop_image().create_hillshade()'
  prefs: []
  type: TYPE_NORMAL
- en: As in [Chapter 4](index_split_001.html#p174), *Improving the App Search Capabilities*,
    the only thing we need is to have a class and the methods that return the same
    type of class. With these two things, there are no limits on how the steps can
    be combined. So, let’s do it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a RasterData class**'
  prefs: []
  type: TYPE_NORMAL
- en: Our RasterData class will follow the pattern used before with our vectors. When
    instantiated, the class will receive a file path or an array. As said before,
    in order to use method chaining to perform a processing pipeline, each processing
    method must return another instance of the RasterData class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start with class declaration and then fill it with the methods. To
    make it easier to cut and paste the work we have already done, we will do the
    following steps inside the image_experiments.py file:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. At the top of the image_experiments.py file, after the imports, create
    the class:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import cv2
  prefs: []
  type: TYPE_NORMAL
- en: import numpy as np
  prefs: []
  type: TYPE_NORMAL
- en: 'class RasterData(object):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, input_data, unchanged=True, shape=None):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Represents a raster data in the form of an array.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param input_data: Raster files or Numpy array.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param unchanged: True to keep the original format.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param shape: When using multiple input data, this param'
  prefs: []
  type: TYPE_NORMAL
- en: determines the shape of the composition.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: self.data = None
  prefs: []
  type: TYPE_NORMAL
- en: if isinstance(input_data, list) \
  prefs: []
  type: TYPE_NORMAL
- en: 'or isinstance(input_data, tuple):'
  prefs: []
  type: TYPE_NORMAL
- en: self.combine_images(input_data, shape)
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: self.import_data(input_data, unchanged)
  prefs: []
  type: TYPE_NORMAL
- en: The array will be stored in the data property, so we will initially set it to
    None.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few other changes to make this class consistent with the others
    and avoid redundancy in the names. The first one is to use an import_data method
    like before.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Cut and paste the open_raster_file function into the class, rename it to
    import_data, and change it to behave like a method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class RasterData(object):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, input_data, unchanged=True, shape=None):'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 'def import_data(self, image, unchanged=True):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Opens a raster file.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param image: Path of the raster file or np array.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param unchanged: True to keep the original format.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: 'if isinstance(image, np.ndarray):'
  prefs: []
  type: TYPE_NORMAL
- en: self.data = image
  prefs: []
  type: TYPE_NORMAL
- en: return image
  prefs: []
  type: TYPE_NORMAL
- en: flags = cv2.CV_LOAD_IMAGE_UNCHANGED if unchanged else -1
  prefs: []
  type: TYPE_NORMAL
- en: self.data = cv2.imread(image, flags=flags)
  prefs: []
  type: TYPE_NORMAL
- en: Instead of returning an array, it will now put the array in the data property.
  prefs: []
  type: TYPE_NORMAL
- en: Next, since we will be removing the obligation of writing the image to the disk
    from the steps, we will need a method to perform this action.
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Add the write_image method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class RasterData(object):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, input_data, unchanged=True, shape=None):'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 'def import_data(self, input_image, unchanged=True):'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 'def write_image(self, output_image):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Write the data to the disk as an image.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param output_image: Path and name of the output image.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: cv2.imwrite(output_image, self.data)
  prefs: []
  type: TYPE_NORMAL
- en: return self
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Following the examples’ order, cut and paste the combine_images function
    as a method to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class RasterData(object):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, input_data, unchanged=True, shape=None):'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 'def import_data(self, input_image, unchanged=True):'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 'def write_image(self, output_image):'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 'def combine_images(self, input_images, shape):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Combine images in a mosaic.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param input_images: Path to the input images.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param shape: Shape of the mosaic in columns and rows.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: 'if len(input_images) != shape[0] * shape[1]:'
  prefs: []
  type: TYPE_NORMAL
- en: raise ValueError("Number of images doesn't match the"
  prefs: []
  type: TYPE_NORMAL
- en: '" mosaic shape.")'
  prefs: []
  type: TYPE_NORMAL
- en: images = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for item in input_images:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if isinstance(item, RasterData):'
  prefs: []
  type: TYPE_NORMAL
- en: images.append(item.data)
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: images.append(RasterData(item).data)
  prefs: []
  type: TYPE_NORMAL
- en: rows = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for row in range(shape[0]):'
  prefs: []
  type: TYPE_NORMAL
- en: start = (row * shape[1])
  prefs: []
  type: TYPE_NORMAL
- en: end = start + shape[1]
  prefs: []
  type: TYPE_NORMAL
- en: rows.append(np.concatenate(images[start:end], axis=1))
  prefs: []
  type: TYPE_NORMAL
- en: mosaic = np.concatenate(rows, axis=0)
  prefs: []
  type: TYPE_NORMAL
- en: self.data = mosaic
  prefs: []
  type: TYPE_NORMAL
- en: return self
  prefs: []
  type: TYPE_NORMAL
- en: Now, it’s possible to create an empty RasterData instance and then populate
    it with a mosaic using this method. Or, you can create the instance with a list
    containing any combination of image paths, arrays, or even other RasterData instances
    as an argument. It will automatically combine them, put the result in the data
    property, and return itself.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you got the hang of it, let’s do the same transformation with the last
    three functions.
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Cut and paste the adjust_values, crop_image and create_hillshade functions
    as methods into the class. Your complete class should be as follows: class RasterData(object):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, input_data, unchanged=True, shape=None):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Represents a raster data in the form of an array.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param input_data: Raster files or Numpy array.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param unchanged: True to keep the original format.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param shape: When using multiple input data, this param'
  prefs: []
  type: TYPE_NORMAL
- en: determines the shape of the composition.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: self.data = None
  prefs: []
  type: TYPE_NORMAL
- en: if isinstance(input_data, list) \
  prefs: []
  type: TYPE_NORMAL
- en: 'or isinstance(input_data, tuple):'
  prefs: []
  type: TYPE_NORMAL
- en: self.combine_images(input_data, shape)
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: self.import_data(input_data, unchanged)
  prefs: []
  type: TYPE_NORMAL
- en: 'def import_data(self, image, unchanged=True):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Opens a raster file.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param image: Path of the raster file or np array.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param unchanged: True to keep the original format.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: 'if isinstance(image, np.ndarray):'
  prefs: []
  type: TYPE_NORMAL
- en: self.data = image
  prefs: []
  type: TYPE_NORMAL
- en: return image
  prefs: []
  type: TYPE_NORMAL
- en: flags = cv2.CV_LOAD_IMAGE_UNCHANGED if unchanged else -1
  prefs: []
  type: TYPE_NORMAL
- en: self.data = cv2.imread(image, flags=flags)
  prefs: []
  type: TYPE_NORMAL
- en: 'def write_image(self, output_image):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Write the data to the disk as an image.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param output_image: Path and name of the output image.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: cv2.imwrite(output_image, self.data)
  prefs: []
  type: TYPE_NORMAL
- en: return self
  prefs: []
  type: TYPE_NORMAL
- en: 'def combine_images(self, input_images, shape):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Combine images in a mosaic.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param input_images: Path to the input images.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param shape: Shape of the mosaic in columns and rows.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: 'if len(input_images) != shape[0] * shape[1]:'
  prefs: []
  type: TYPE_NORMAL
- en: raise ValueError("Number of images doesn't match the"
  prefs: []
  type: TYPE_NORMAL
- en: '" mosaic shape.")'
  prefs: []
  type: TYPE_NORMAL
- en: images = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for item in input_images:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if isinstance(item, RasterData):'
  prefs: []
  type: TYPE_NORMAL
- en: images.append(item.data)
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: images.append(RasterData(item).data)
  prefs: []
  type: TYPE_NORMAL
- en: rows = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for row in range(shape[0]):'
  prefs: []
  type: TYPE_NORMAL
- en: start = (row * shape[1])
  prefs: []
  type: TYPE_NORMAL
- en: end = start + shape[1]
  prefs: []
  type: TYPE_NORMAL
- en: rows.append(np.concatenate(images[start:end], axis=1))
  prefs: []
  type: TYPE_NORMAL
- en: mosaic = np.concatenate(rows, axis=0)
  prefs: []
  type: TYPE_NORMAL
- en: self.data = mosaic
  prefs: []
  type: TYPE_NORMAL
- en: return self
  prefs: []
  type: TYPE_NORMAL
- en: 'def adjust_values(self, img_range=None):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Create a visualization of the data in the input_image by projecting a range
    of values into a grayscale image.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param img_range: specified range of values'
  prefs: []
  type: TYPE_NORMAL
- en: or None to use the range of the image
  prefs: []
  type: TYPE_NORMAL
- en: (minimum and maximum).
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: image = self.data
  prefs: []
  type: TYPE_NORMAL
- en: 'if img_range:'
  prefs: []
  type: TYPE_NORMAL
- en: min = img_range[0]
  prefs: []
  type: TYPE_NORMAL
- en: max = img_range[1]
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: min = image.min()
  prefs: []
  type: TYPE_NORMAL
- en: max = image.max()
  prefs: []
  type: TYPE_NORMAL
- en: interval = max - min
  prefs: []
  type: TYPE_NORMAL
- en: factor = 256.0 / interval
  prefs: []
  type: TYPE_NORMAL
- en: output = image * factor
  prefs: []
  type: TYPE_NORMAL
- en: self.data = output
  prefs: []
  type: TYPE_NORMAL
- en: return self
  prefs: []
  type: TYPE_NORMAL
- en: 'def crop_image(self, image_extent, bbox):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Crops an image by a bounding box.'
  prefs: []
  type: TYPE_NORMAL
- en: 'bbox and image_extent format: (xmin, ymin, xmax, ymax).'
  prefs: []
  type: TYPE_NORMAL
- en: ':param input_image: Array containing the data'
  prefs: []
  type: TYPE_NORMAL
- en: or path to an image.
  prefs: []
  type: TYPE_NORMAL
- en: ':param image_extent: The geographic extent of the image.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param output_image: The image path to write the output.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param bbox: The bounding box of the region of interest.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: input_image = self.data
  prefs: []
  type: TYPE_NORMAL
- en: img_shape = input_image.shape
  prefs: []
  type: TYPE_NORMAL
- en: img_geo_width = abs(image_extent[2] - image_extent[0])
  prefs: []
  type: TYPE_NORMAL
- en: img_geo_height = abs(image_extent[3] - image_extent[1])
  prefs: []
  type: TYPE_NORMAL
- en: How much pixels are contained in one geographic unit.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pixel_width = img_shape[1] / img_geo_width
  prefs: []
  type: TYPE_NORMAL
- en: pixel_height = img_shape[0] / img_geo_height
  prefs: []
  type: TYPE_NORMAL
- en: Index of the pixel to cut.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: x_min = abs(bbox[0] - image_extent[0]) * pixel_width
  prefs: []
  type: TYPE_NORMAL
- en: x_max = abs(bbox[2] - image_extent[0]) * pixel_width
  prefs: []
  type: TYPE_NORMAL
- en: y_min = abs(bbox[1] - image_extent[1]) * pixel_height
  prefs: []
  type: TYPE_NORMAL
- en: y_max = abs(bbox[3] - image_extent[1]) * pixel_height
  prefs: []
  type: TYPE_NORMAL
- en: output = input_image[y_min:y_max, x_min:x_max]
  prefs: []
  type: TYPE_NORMAL
- en: self.data = output
  prefs: []
  type: TYPE_NORMAL
- en: return self
  prefs: []
  type: TYPE_NORMAL
- en: 'def create_hillshade(self, azimuth=90, angle_altitude=60):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Creates a shaded relief image from a digital elevation model.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param input_image: Array containing the data'
  prefs: []
  type: TYPE_NORMAL
- en: or path to an image.
  prefs: []
  type: TYPE_NORMAL
- en: ':param azimuth: Simulated sun azimuth.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param angle_altitude: Sun altitude angle.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: input_image = self.data
  prefs: []
  type: TYPE_NORMAL
- en: x, y = np.gradient(input_image)
  prefs: []
  type: TYPE_NORMAL
- en: slope = np.pi / 2 - np.arctan(np.sqrt(x * x + y * y))
  prefs: []
  type: TYPE_NORMAL
- en: aspect = np.arctan2(-x, y)
  prefs: []
  type: TYPE_NORMAL
- en: az_rad = azimuth * np.pi / 180
  prefs: []
  type: TYPE_NORMAL
- en: alt_rad = angle_altitude * np.pi / 180
  prefs: []
  type: TYPE_NORMAL
- en: a = np.sin(alt_rad) * np.sin(slope)
  prefs: []
  type: TYPE_NORMAL
- en: b = np.cos(alt_rad) * np.cos(slope)\
  prefs: []
  type: TYPE_NORMAL
- en: '* np.cos(az_rad - aspect)'
  prefs: []
  type: TYPE_NORMAL
- en: output = 255 * (a + b + 1) / 2
  prefs: []
  type: TYPE_NORMAL
- en: self.data = output
  prefs: []
  type: TYPE_NORMAL
- en: return self
  prefs: []
  type: TYPE_NORMAL
- en: The class is complete and we can make a pipeline to test it.
  prefs: []
  type: TYPE_NORMAL
- en: '6\. Edit and organize the if __name__ == ''__main__'': block to test the image
    processing pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: elevation_data = [
  prefs: []
  type: TYPE_NORMAL
- en: '''../../data/ASTGTM2_S22W048_dem.tif'','
  prefs: []
  type: TYPE_NORMAL
- en: '''../../data/ASTGTM2_S22W047_dem.tif'','
  prefs: []
  type: TYPE_NORMAL
- en: '''../../data/ASTGTM2_S23W048_dem.tif'','
  prefs: []
  type: TYPE_NORMAL
- en: '''../../data/ASTGTM2_S23W047_dem.tif'']'
  prefs: []
  type: TYPE_NORMAL
- en: 'roi = (-46.8, -21.7, -46.3, -22.1) # Region of interest.'
  prefs: []
  type: TYPE_NORMAL
- en: 'iex = (-48, -21, -46, -23) # Image extent.'
  prefs: []
  type: TYPE_NORMAL
- en: RasterData(elevation_data, shape=(2, 2)).adjust_values().\
  prefs: []
  type: TYPE_NORMAL
- en: crop_image(iex, roi).create_hillshade().\
  prefs: []
  type: TYPE_NORMAL
- en: write_image('../output/pipeline_output.png')
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 52](img/index-308_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Due to the width limitation of the book, the pipeline is broken into three lines,
    but you can type it in a single line in PyCharm if you wish.
  prefs: []
  type: TYPE_NORMAL
- en: 7\. Run the code and admire the result.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you have a fantastic accomplishment. I’m not talking about the
    shaded relief image, I’m talking about the ability to consistently develop processing
    steps and combine them into a processing pipeline in order to achieve the final
    result. The structure that we developed here can be used to do almost anything
    in terms of geoprocessing.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that the image generated by the pipeline is of a much superior quality
    than the one created before. This happened because the data was in the memory
    the whole time.
  prefs: []
  type: TYPE_NORMAL
- en: This avoided data loss due to compression when the data was saved to a file
    multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few remarks about the functionality of the structure as we implemented it
    are as follows: All the processing methods do two things in the end: they change
    the instance data and return the instance itself. The implication of this is that
    the class instance will mutate along the pipeline and the old data will be replaced
    by new ones as the process goes on. With this, Python’s garbage collector will
    eliminate old results from the memory and save space.'
  prefs: []
  type: TYPE_NORMAL
- en: If, at any step, you want to save the current state of processing, just insert
    a call to the write_image method (it will also return self and it can be piped).
    This is a powerful
  prefs: []
  type: TYPE_NORMAL
- en: tool for debugging and also can save time when you only want to repeat the steps
    later in a long pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: You can fork the pipeline. You can create a bifurcation where more than one
    result can be produced by following different paths. To do this, you can use the
    copy() function or you can write the result to the disk before the bifurcation.
    Later in the book we will see that, sometimes, while performing parallel processing,
    we will need these techniques too.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we understood how remote sensing images are represented inside
    the computer as arrays and how we can use this characteristic to process them.
    We saw that, in order to use images on a map, it is common that we need to transform
    them to achieve better results. Then, we wrote processing functions to process
    the digital elevation model images, ending with a beautiful shaded relief map.
    Finally, we created a RasterData class and transformed our functions into the
    methods of this class. With a few additional changes, we made it possible to chain
    these methods into a processing pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore the data in the images and obtain valuable
    information.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter 7\. Extract Information from**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Raster Data**'
  prefs: []
  type: TYPE_NORMAL
- en: More than just a resource for visual information, raster data are samples of
    a given spatial attribute, whose values can be analyzed in order to produce valuable
    information.
  prefs: []
  type: TYPE_NORMAL
- en: Is this chapter, we will extract information from raster data with special emphasis
    on statistical information. Following the previous examples, we will use the digital
    elevation model to obtain values such as the maximum and minimum altitude of a
    given region, separate altitude ranges into classes, and produce histograms and
    other statistical information. Going beyond simple numerical values, we will display
    all the information on beautifully colored maps.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics covered by this chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: How to obtain statistics from raster data
  prefs: []
  type: TYPE_NORMAL
- en: The use of programming techniques, such as lazy evaluation and memorization,
    to avoid unnecessary calculation
  prefs: []
  type: TYPE_NORMAL
- en: How to format tabular data output
  prefs: []
  type: TYPE_NORMAL
- en: How to colorize maps and choose suitable colors for them
  prefs: []
  type: TYPE_NORMAL
- en: How to blend color maps in order to produce colorized and shaded maps
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the basic statistics**'
  prefs: []
  type: TYPE_NORMAL
- en: As we have previously seen, images or raster data are arrays containing numerical
    values representing a given real world space. So, they are by consequence statistical
    samples and they can be used in statistical analysis.
  prefs: []
  type: TYPE_NORMAL
- en: When we import the data, it is converted into NumPy arrays. These arrays are
    packed with methods for basic statistical calculations. In this topic, we are
    going to obtain the results from these calculations and save them in a file.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the previous chapter, we made an image processing pipeline by
    combining steps that can be saved on the disk. Here, we will follow the same pattern.
    The statistical computation will be added as another step. Maintaining the same
    kind of organization allows the user to generate statistics at any point on the
    processing pipeline. It will be possible to save statistics from all the substeps
    if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by organizing our code:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. As we do at the beginning of every chapter, we will copy the code from the
    previous chapter. In your geopy project folder, copy the Chapter 6 folder ( *Ctrl*
    + *C*) and paste it ( *Ctrl* + *V*). Name the copied folder as Chapter7\.
  prefs: []
  type: TYPE_NORMAL
- en: In the last chapter, we finished the RasterData class inside the image_experiments.py
    file. Since our experiments are over, let’s move this class to a permanent and
    meaningful location.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Copy the file Chapter7/experiments/image_experiments.py ( *Ctrl* + *C*).
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Select the Chapter7 folder and paste the file there ( *Ctrl* + *V*).
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Rename the file to raster_data.py. To do this, right-click on the file and
    select **Refactor** | **Rename…** or select the file and press *Ctrl* + *F6*.
    The refactor dialog will appear. Change the name in the dialog and click on the
    **Refactor** button. There are two checkboxes in the dialog asking whether you
    want to search for this file’s references. If they are checked (on), PyCharm will
    search and automatically change these references, so the code will continue to
    work.
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Remove the image_experiments.py file, as it won’t be of use anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our code is organized, we are going to analyze a few aspects and review
    some points in order to plan our next step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take an instance of your RasterData class that has a base working pattern,
    as it is now:'
  prefs: []
  type: TYPE_NORMAL
- en: At the instancing moment, you can pass the data or you can import the data later.
  prefs: []
  type: TYPE_NORMAL
- en: After this, the data will be stored as a NumPy array in the data property.
  prefs: []
  type: TYPE_NORMAL
- en: When you run any method in the class, the operation is performed and the data
    is transformed if it’s the case and the instance itself is returned along with
    the new data.
  prefs: []
  type: TYPE_NORMAL
- en: No information is stored in the class, other than the data. And by consequence,
    some methods need to take manually defined parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The data property is a NumPy array, so it has all the NumPy array methods.
  prefs: []
  type: TYPE_NORMAL
- en: '**Preparing the data**'
  prefs: []
  type: TYPE_NORMAL
- en: The sample data that we will be using is composed of four images containing
    elevation data. The processing pipeline combines these images, adjusts the values
    to display on a map, cuts the image, and then generates the shaded relief image.
  prefs: []
  type: TYPE_NORMAL
- en: This pipeline is good for visualization, but data is lost in the moment we adjust
    the values.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this work, we don’t want that to happen. We want the original values in
    meters. So, the first thing we need to do is build a pipeline adequate for our
    needs, and in the end, save the results, so we don’t need to repeat all the steps
    in the following tests: 1\. Open the raster_data.py file for editing, and at the
    end of it, add the if __name__'
  prefs: []
  type: TYPE_NORMAL
- en: '== ''__main__'': block with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: elevation_data = [
  prefs: []
  type: TYPE_NORMAL
- en: '''../data/ASTGTM2_S22W048_dem.tif'','
  prefs: []
  type: TYPE_NORMAL
- en: '''../data/ASTGTM2_S22W047_dem.tif'','
  prefs: []
  type: TYPE_NORMAL
- en: '''../data/ASTGTM2_S23W048_dem.tif'','
  prefs: []
  type: TYPE_NORMAL
- en: '''../data/ASTGTM2_S23W047_dem.tif'']'
  prefs: []
  type: TYPE_NORMAL
- en: 'roi = (-46.8, -21.7, -46.3, -22.1) # Region of interest.'
  prefs: []
  type: TYPE_NORMAL
- en: 'iex = (-48, -21, -46, -23) # Image extent.'
  prefs: []
  type: TYPE_NORMAL
- en: data = RasterData(elevation_data, shape=(2, 2))
  prefs: []
  type: TYPE_NORMAL
- en: data.crop_image(iex, roi).write_image(
  prefs: []
  type: TYPE_NORMAL
- en: '''output/dem.tif'')'
  prefs: []
  type: TYPE_NORMAL
- en: This is very similar to what we did before, but the pipeline was simplified
    to combining the images and cropping and writing the results in the dem.tif file.
    It was chosen as a TIFF file, so the information isn’t lost due to data compression.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Run the code. Remember that because it’s a new file, you need to click
    on **Run** or press *Alt* + *Shift* + *F10* and choose raster_data. You should
    see an output telling you that everything went fine:'
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: From now on, we can use the prepared image in output/dem.tif for our tests.
    This is simply a matter of speeding up the process. What we are going to do could
    be done in any RasterData instance.
  prefs: []
  type: TYPE_NORMAL
- en: If, by any reason, you couldn’t generate dem.tif, copy the one provided with
    the sample data to your output folder.
  prefs: []
  type: TYPE_NORMAL
- en: '**Printing simple information**'
  prefs: []
  type: TYPE_NORMAL
- en: The first step for us to get some statistical output is to explore what NumPy
    has to offer.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we know, the data property of a RasterData instance is a NumPy array, so
    let’s see what we can get from it:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. First, check whether everything is working so far. Clean the if __name__
    ==
  prefs: []
  type: TYPE_NORMAL
- en: '''__main__'': block and add this new code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: raster_data = RasterData('output/dem.tif')
  prefs: []
  type: TYPE_NORMAL
- en: print raster_data.data
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Run the code with *Shift* + *F10*. You should see this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[[ 933 935 942…, 1077 1076 1078]'
  prefs: []
  type: TYPE_NORMAL
- en: '[ 936 939 945…, 1075 1079 1076]'
  prefs: []
  type: TYPE_NORMAL
- en: '[ 935 939 946…, 1064 1072 1075]'
  prefs: []
  type: TYPE_NORMAL
- en: '...,'
  prefs: []
  type: TYPE_NORMAL
- en: '[ 780 781 781…, 1195 1193 1193]'
  prefs: []
  type: TYPE_NORMAL
- en: '[ 781 784 782…, 1191 1189 1188]'
  prefs: []
  type: TYPE_NORMAL
- en: '[ 781 784 785…, 1187 1185 1184]]'
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: This is the array containing the data in meters. NumPy automatically suppressed
    some rows and columns to make the output smaller. You see this output because
    a NumPy array has a __repr__ method that tells what is to be shown when the print
    function is called.
  prefs: []
  type: TYPE_NORMAL
- en: As we did before with the vector data, we will customize the __repr__ method
    of our class, so it outputs some information from the data in it.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Edit the RasterData class and insert the __repr__ method right after the
    __init__
  prefs: []
  type: TYPE_NORMAL
- en: 'method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class RasterData(object):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, input_data, unchanged=True, shape=None):'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __repr__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: return "Hi, I'm a raster data!"
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Now, edit the if __name__ == ''__main__'': block and make it print the
    RasterData instance directly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: raster_data = RasterData('output/dem.tif')
  prefs: []
  type: TYPE_NORMAL
- en: print raster_data
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Run the code and see whether you get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: Hi, I'm a raster data!
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: OK, nothing fancy here. It’s just to remember that __repr__ takes no arguments
    except the instance (self) and should return only a string. Also, the method’s
    position in the class makes no difference. We are placing it after the __init__
    method for organization.
  prefs: []
  type: TYPE_NORMAL
- en: All the *magic* methods go together at the beginning of the class.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have everything set, let’s explore the NumPy array in the data property.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to avoid repetition, I’ll suppress the class’ declaration and the
    __init__ method in the code and replace it by #....'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Edit the __repr__ method to look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def __repr__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.data is None:'
  prefs: []
  type: TYPE_NORMAL
- en: return "No data to display!"
  prefs: []
  type: TYPE_NORMAL
- en: data = self.data
  prefs: []
  type: TYPE_NORMAL
- en: 'min = "Min: {}".format(data.min())'
  prefs: []
  type: TYPE_NORMAL
- en: 'mean = "Mean: {}".format(data.mean())'
  prefs: []
  type: TYPE_NORMAL
- en: 'max = "Max: {}".format(data.max())'
  prefs: []
  type: TYPE_NORMAL
- en: return "Hi, I'm a raster data!\n {} {} {}".format(
  prefs: []
  type: TYPE_NORMAL
- en: min, mean, max)
  prefs: []
  type: TYPE_NORMAL
- en: The first thing is to avoid an exception if the data is empty (None). In this
    case, the method prints a nice message telling that the instance has no data.
    If the instance has data, then it prepares three strings with the minimum, mean,
    and maximum values by calling the respective methods. In the end, a string is
    formatted to contain all the information.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Run the code with *Shift* + *F10*. You should see this output: Hi, I''m
    a raster data!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Min: 671 Mean: 1139.06559874 Max: 1798'
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: That’s great! Now, we have some statistical information on our data.
  prefs: []
  type: TYPE_NORMAL
- en: But this code is clumsy and if we want to add or remove information returned
    from __repr__, we need to do a lot of editing. So, before we proceed on to obtaining
    more statistics, we will make a few changes and automate the process of formatting
    the information that we want to display.
  prefs: []
  type: TYPE_NORMAL
- en: '**Formatting the output information**'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we are displaying three parameters in a simple string output.
    We want to improve this code, so we can easily add or remove parameters from the
    output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we modify the code, let’s think ahead and foresee that we may also need
    to output these statistics in other formats, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: To a file on the disk in a human-friendly format
  prefs: []
  type: TYPE_NORMAL
- en: To a file on the disk in a computer-friendly format, such as CSV or JSON
  prefs: []
  type: TYPE_NORMAL
- en: As parameters to be passed to the other function or method
  prefs: []
  type: TYPE_NORMAL
- en: 'So, a good way we can prepare the code to fulfill these requirements is to
    separate the statistic generation from the output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. First, separate the data verification from the __repr__ method. Create
    a new method to handle this task:'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def _check_data(self):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Check if has data and if it''s a Numpy array."""'
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.data is None:'
  prefs: []
  type: TYPE_NORMAL
- en: raise ValueError("No data defined.")
  prefs: []
  type: TYPE_NORMAL
- en: 'elif not isinstance(self.data, np.ndarray):'
  prefs: []
  type: TYPE_NORMAL
- en: raise TypeError("Wrong type of data.")
  prefs: []
  type: TYPE_NORMAL
- en: The verification is more rigorous and it raises different types of exceptions
    for each possible failure. This makes the code mode useful and safe, because it
    allows error-handling to be done in the other functions and because it stops the
    program’s execution if the exception is not properly caught.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Now, create a new method to calculate and collect the statistics that we
    have so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def _calculate_stats(self):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Calculate and return basic statistical information from the data.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: self._check_data()
  prefs: []
  type: TYPE_NORMAL
- en: data = self.data
  prefs: []
  type: TYPE_NORMAL
- en: stats = {
  prefs: []
  type: TYPE_NORMAL
- en: '"Minimum": data.min(),'
  prefs: []
  type: TYPE_NORMAL
- en: '"Mean": data.mean(),'
  prefs: []
  type: TYPE_NORMAL
- en: '"Maximum": data.max()}'
  prefs: []
  type: TYPE_NORMAL
- en: return stats
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the statistics are stored in a dictionary for two reasons: it allows
    the items to have readable names (including accents and spaces if you wish) and
    it avoids name collisions.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it lets us prepare a human-readable output with the statistics calculated.
    For this, we will use the tabulate module.
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Insert this import at the beginning of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import cv2
  prefs: []
  type: TYPE_NORMAL
- en: import numpy as np
  prefs: []
  type: TYPE_NORMAL
- en: from tabulate import tabulate
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Add this new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def _format_stats(self, stats, out_format=''human''):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Format the statistical data in a given output format.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param out_format: ''human'' or ''csv'''
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: table = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for key, value in stats.iteritems():'
  prefs: []
  type: TYPE_NORMAL
- en: table.append([key, value])
  prefs: []
  type: TYPE_NORMAL
- en: return tabulate(table)
  prefs: []
  type: TYPE_NORMAL
- en: The tabulate function takes a list of lists representing a table. It then prepares
    a string containing a well-formatted table with this data.
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Finally, edit the __repr__ method:'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def __repr__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: stats = self._calculate_stats()
  prefs: []
  type: TYPE_NORMAL
- en: stats = self._format_stats(stats)
  prefs: []
  type: TYPE_NORMAL
- en: 'return "Raster data - basic statistics.\n {}".format(stats) 6\. Now, run the
    code again with *Shift* + *F10*. You should see this output: Raster data - basic
    statistics.'
  prefs: []
  type: TYPE_NORMAL
- en: '------- -------'
  prefs: []
  type: TYPE_NORMAL
- en: Minimum 671
  prefs: []
  type: TYPE_NORMAL
- en: Maximum 1798
  prefs: []
  type: TYPE_NORMAL
- en: Mean 1139.07
  prefs: []
  type: TYPE_NORMAL
- en: '------- -------'
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: The presentation is much better now. If we want to add or remove elements, we
    just need to edit the dictionary in the _calculate_stats method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Calculating quartiles, histograms, and other** **statistics**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the minimum, maximum, and mean values for our data. In our case, it
    is the minimum, maximum, and mean elevation of the given region. In the next few
    steps, we will obtain more information from our data:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Edit the _calculate_stats method, adding more items to the dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def _calculate_stats(self):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Calculate and return basic statistical information from the data.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: self._check_data()
  prefs: []
  type: TYPE_NORMAL
- en: data = self.data
  prefs: []
  type: TYPE_NORMAL
- en: stats = {
  prefs: []
  type: TYPE_NORMAL
- en: '"Minimum": data.min(),'
  prefs: []
  type: TYPE_NORMAL
- en: '"Mean": data.mean(),'
  prefs: []
  type: TYPE_NORMAL
- en: '"Maximum": data.max(),'
  prefs: []
  type: TYPE_NORMAL
- en: '"Q1": np.percentile(data, 25),'
  prefs: []
  type: TYPE_NORMAL
- en: '"Median": np.median(data),'
  prefs: []
  type: TYPE_NORMAL
- en: '"Q3": np.percentile(data, 75),'
  prefs: []
  type: TYPE_NORMAL
- en: '"Variance": data.var(),'
  prefs: []
  type: TYPE_NORMAL
- en: '"Histogram": np.histogram(data)'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return stats
  prefs: []
  type: TYPE_NORMAL
- en: You can add any value to the dictionary. Maybe, you can obtain it from a NumPy
    function or method or from a function developed by you.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information on NumPy statistics in
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.scipy.org/doc/numpy/reference/routines.statistics.html](http://docs.scipy.org/doc/numpy/reference/routines.statistics.html)
    and'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.scipy.org/doc/numpy/reference/arrays.ndarray.html#array-methods](http://docs.scipy.org/doc/numpy/reference/arrays.ndarray.html#array-methods).'
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Run the code with *Shift* + *F10*. You should get more values as the output:
    Raster data - basic statistics.'
  prefs: []
  type: TYPE_NORMAL
- en: '---------'
  prefs: []
  type: TYPE_NORMAL
- en: Q1 992.0
  prefs: []
  type: TYPE_NORMAL
- en: Q3 1303.0
  prefs: []
  type: TYPE_NORMAL
- en: Minimum 671
  prefs: []
  type: TYPE_NORMAL
- en: Variance 37075.0925323
  prefs: []
  type: TYPE_NORMAL
- en: Histogram (array([ 83917, 254729, ..., 44225, 8279, 2068]), array([ 671\. ,
    783.7, ..., 1685.3, 1798.]))
  prefs: []
  type: TYPE_NORMAL
- en: Median 1140.0
  prefs: []
  type: TYPE_NORMAL
- en: Maximum 1798
  prefs: []
  type: TYPE_NORMAL
- en: Mean 1139.06559874
  prefs: []
  type: TYPE_NORMAL
- en: '--------- ---------------'
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: 'Note in the output that the histogram is composed of two arrays: one containing
    the number of occurrences and the other containing the top limit for each bin.
    Since we are dealing with geographic data, it would be better if this information
    came translated into the amount of area for each interval.'
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we just need to multiply the number of currencies (the number of
    pixels within a given range) by the area represented by each pixel. We will get
    to this after we prepare a few things in the next topics.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making statistics a lazy property**'
  prefs: []
  type: TYPE_NORMAL
- en: Our statistics is working fine and we will make an improvement now. Instead
    of calculating the statistics that we need all the time, we will calculate it
    only once and only when it’s needed for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use two very useful programming techniques: **lazy evaluation** and
    **memoization**.'
  prefs: []
  type: TYPE_NORMAL
- en: Lazy evaluation is when a process or calculation is delayed and only performed
    when needed. Memoization is when the results of an expensive process are stored
    for later use to avoid them being recalculated every time we may need them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Add a new _stats property to the __init__ method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class RasterData(object):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, input_data, unchanged=True, shape=None):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Represents a raster data in the form of an array.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param input_data: Raster files or Numpy array.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param unchanged: True to keep the original format.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param shape: When using multiple input data, this param'
  prefs: []
  type: TYPE_NORMAL
- en: determines the shape of the composition.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: self.data = None
  prefs: []
  type: TYPE_NORMAL
- en: self._stats = None
  prefs: []
  type: TYPE_NORMAL
- en: if isinstance(input_data, list) \
  prefs: []
  type: TYPE_NORMAL
- en: 'or isinstance(input_data, tuple):'
  prefs: []
  type: TYPE_NORMAL
- en: self.combine_images(input_data, shape)
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: self.import_data(input_data, unchanged)
  prefs: []
  type: TYPE_NORMAL
- en: The property name starts with an underscore. Remember that this notation shows
    that the property should only be accessed from the instance itself. This property
    will work as a cache to store the statistics.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Now add a property method that will return the statistics:'
  prefs: []
  type: TYPE_NORMAL
- en: '#...'
  prefs: []
  type: TYPE_NORMAL
- en: '@property'
  prefs: []
  type: TYPE_NORMAL
- en: 'def stats(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if self._stats is None:'
  prefs: []
  type: TYPE_NORMAL
- en: self._stats = self._calculate_stats()
  prefs: []
  type: TYPE_NORMAL
- en: return self._stats
  prefs: []
  type: TYPE_NORMAL
- en: When this property is accessed, it verifies that if _stats is None. If so, it
    calculates the statistics and stores the results into _stats. The next time we
    need it, it only returns what’s stored.
  prefs: []
  type: TYPE_NORMAL
- en: Making a property lazy and adding memoization to it is important when the process
    to obtain this information is costly. The processing power and time is used only
    once when the given property is needed.
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Now, change the __repr__ method to use this new functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def __repr__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: stats = self._format_stats(self.stats)
  prefs: []
  type: TYPE_NORMAL
- en: return "Raster data basic statistics.\n {}".format(stats)
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating color classified images**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to display image information on a map, we must prepare a visual
    output of what we got. A common and efficient form of visual representation is
    to separate values into classes and give each class a different color. In our
    case, we can split the data into altitude classes. NumPy makes it easy for us.
    Let’s write a method that can be called in the pipeline to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Add a new method to the RasterData class:'
  prefs: []
  type: TYPE_NORMAL
- en: '#...'
  prefs: []
  type: TYPE_NORMAL
- en: 'def colorize(self, style):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Produces an BGR image based on a style containing limits and colors.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param style: A list of limits and colors.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: shape = self.data.shape
  prefs: []
  type: TYPE_NORMAL
- en: limits = []
  prefs: []
  type: TYPE_NORMAL
- en: colors = []
  prefs: []
  type: TYPE_NORMAL
- en: Separate the limits and colors.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for item in style:'
  prefs: []
  type: TYPE_NORMAL
- en: limits.append(item[0])
  prefs: []
  type: TYPE_NORMAL
- en: colors.append(self._convert_color(item[1]))
  prefs: []
  type: TYPE_NORMAL
- en: colors = np.array(colors)
  prefs: []
  type: TYPE_NORMAL
- en: Put each color in its limits.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: flat_array = self.data.flatten()
  prefs: []
  type: TYPE_NORMAL
- en: di_array = np.digitize(flat_array, limits)
  prefs: []
  type: TYPE_NORMAL
- en: di_array = di_array.reshape((shape[0], shape[1], 1))
  prefs: []
  type: TYPE_NORMAL
- en: results = np.choose(di_array, colors)
  prefs: []
  type: TYPE_NORMAL
- en: Convert from RGB to BGR.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: results = np.asarray(results, dtype=np.uint8)
  prefs: []
  type: TYPE_NORMAL
- en: results = cv2.cvtColor(results, cv2.COLOR_RGB2BGR)
  prefs: []
  type: TYPE_NORMAL
- en: self.data = results
  prefs: []
  type: TYPE_NORMAL
- en: return self
  prefs: []
  type: TYPE_NORMAL
- en: In order to achieve what we want, two important things happen here. First, the
    data is indexed into classes by NumPy’s digitize function. Then, each class receives
    an RGB value with the defined color. This is done using the choose function.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method takes a style as an argument. This style is a list of limits and
    colors, like a map legend. For example, the style can be defined as: style = [[700,
    "#f6eff7"],'
  prefs: []
  type: TYPE_NORMAL
- en: '[900, "#bdc9e1"],'
  prefs: []
  type: TYPE_NORMAL
- en: '[1100, "#67a9cf"],'
  prefs: []
  type: TYPE_NORMAL
- en: '[1300, "#1c9099"],'
  prefs: []
  type: TYPE_NORMAL
- en: '[1800, "#016c59"]]'
  prefs: []
  type: TYPE_NORMAL
- en: This means that all the values below 700 will have the color "#f6eff7" and so
    on. The colors are expressed in hex notations. This notation is popular with web
    applications and is chosen here because it’s short and easy to type or copy.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, note that inside this method, we called the _convert_color method
    that will perform the conversion of the color notation. Let’s add this method
    to the class: 1\. Add the _convert_color method to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '#...'
  prefs: []
  type: TYPE_NORMAL
- en: 'def _convert_color(self, color_code):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Converts the color notation.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param color_code: A string containing the color in hex'
  prefs: []
  type: TYPE_NORMAL
- en: or JavaScript notation.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: 'if color_code[0] == "#":'
  prefs: []
  type: TYPE_NORMAL
- en: result = (int(color_code[1:3], 16),
  prefs: []
  type: TYPE_NORMAL
- en: int(color_code[3:5], 16),
  prefs: []
  type: TYPE_NORMAL
- en: int(color_code[5:7], 16))
  prefs: []
  type: TYPE_NORMAL
- en: 'elif color_code[:3] == "rgb":'
  prefs: []
  type: TYPE_NORMAL
- en: result = map(int, color_code[4:-1].split(','))
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: raise ValueError("Invalid color code.")
  prefs: []
  type: TYPE_NORMAL
- en: return result
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Finally, edit the if __name__ == ''__main__'': block to test our code:
    if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: raster_data = RasterData('output/dem.tif')
  prefs: []
  type: TYPE_NORMAL
- en: style = [[700, "#f6eff7"],
  prefs: []
  type: TYPE_NORMAL
- en: '[900, "#bdc9e1"],'
  prefs: []
  type: TYPE_NORMAL
- en: '[1100, "#67a9cf"],'
  prefs: []
  type: TYPE_NORMAL
- en: '[1300, "#1c9099"],'
  prefs: []
  type: TYPE_NORMAL
- en: '[1800, "#016c59"]]'
  prefs: []
  type: TYPE_NORMAL
- en: raster_data.colorize(style).write_image(
  prefs: []
  type: TYPE_NORMAL
- en: '''output/classified.png'')'
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Run the code and then open the output image to see the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 53](img/index-328_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 54](img/index-329_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Choosing the right colors for a map**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The choice of what colors to use in a map is one determining factor as to whether
    the map would be capable of correctly passing the desired information. In order
    to choose a good set of colors, some factors should be considered:'
  prefs: []
  type: TYPE_NORMAL
- en: The ability of the human eye to distinguish hues—the classes need to be visually
    distinguishable, otherwise the map may contain colors that may look the same to
    some people
  prefs: []
  type: TYPE_NORMAL
- en: The media that the map will be presented on (for example, paper or screen)—
  prefs: []
  type: TYPE_NORMAL
- en: depending on the media, the colors may suffer small changes that may compromise
    the readability of the map
  prefs: []
  type: TYPE_NORMAL
- en: Colorblind safety—this is an inclusion measure and it allows the information
    to be interpreted by a wider audience
  prefs: []
  type: TYPE_NORMAL
- en: The type of data (for example, sequential or qualitative)—use colors that match
    what you want to show
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of studies on this subject and the ones made by Cynthia Brewer
    are very practical and popular among modern map makers. She produced an extensive
    set of colors to be used in maps and made this information available for use under
    the name of ColorBrewer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change the colors of our map with the help of ColorBrewer: 1\. Access
    the [http://colorbrewer2.org/](http://colorbrewer2.org/) website. You should see
    this interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 55](img/index-330_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 2\. The left-hand side panel allows you to set the parameters to choose the
    color. At the top, change **Number of data classes** to **5** as in our data.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. About the nature of our data, two options would go well, sequential or diverging.
    I will choose diverging for this example.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Before choosing a color scheme, if you wish, you can filter the schemes
    by **colorblind safe**, **print friendly** and **photocopy safe**.
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Now, pick a color scheme that pleases you and note that the bottom right
    section of the panel and the map will change to show the colors of this scheme.
  prefs: []
  type: TYPE_NORMAL
- en: '6\. Let’s export this scheme in a practical way to it use in our code. Click
    on the **EXPORT** tab just to the right of the colors. A new panel will open as
    follows: 7\. Note that the **JavaScript** box contains a list of RGB values. We
    can easily parse this information in our code. So, we will select its contents
    and copy it.'
  prefs: []
  type: TYPE_NORMAL
- en: '8\. Go back to our code and paste the colors to a variable named colorbrewer
    in the if __name__ == ''__main__'': block:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: colorbrewer = ['rgb(202,0,32)','rgb(244,165,130)',
  prefs: []
  type: TYPE_NORMAL
- en: '''rgb(247,247,247)'',''rgb(146,197,222)'','
  prefs: []
  type: TYPE_NORMAL
- en: '''rgb(5,113,176)'']'
  prefs: []
  type: TYPE_NORMAL
- en: raster_data = RasterData('data/dem.tif')
  prefs: []
  type: TYPE_NORMAL
- en: style = [[700, "#f6eff7"],
  prefs: []
  type: TYPE_NORMAL
- en: '[900, "#bdc9e1"],'
  prefs: []
  type: TYPE_NORMAL
- en: '[1100, "#67a9cf"],'
  prefs: []
  type: TYPE_NORMAL
- en: '[1300, "#1c9099"],'
  prefs: []
  type: TYPE_NORMAL
- en: '[1800, "#016c59"]]'
  prefs: []
  type: TYPE_NORMAL
- en: raster_data.colorize(style).write_image(
  prefs: []
  type: TYPE_NORMAL
- en: '''output/classified.png'')'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, the style is not yet complete. There are two problems: the colors
    are in a format different from what we need and we don’t have the limits associated
    with them. Since we want the process to be as practical as possible, we will write
    the code to solve these two issues instead of manually converting the colors and
    associating them with the limits.'
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s implement the capability of our program to accept colors and limits
    separately.
  prefs: []
  type: TYPE_NORMAL
- en: '9\. Put the limits that were in the style definition into a different list:
    if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: colorbrewer = ['rgb(202,0,32)','rgb(244,165,130)',
  prefs: []
  type: TYPE_NORMAL
- en: '''rgb(247,247,247)'',''rgb(146,197,222)'','
  prefs: []
  type: TYPE_NORMAL
- en: '''rgb(5,113,176)'']'
  prefs: []
  type: TYPE_NORMAL
- en: limits = [700, 900, 1100, 1300, 1800]
  prefs: []
  type: TYPE_NORMAL
- en: raster_data = RasterData('data/dem.tif')
  prefs: []
  type: TYPE_NORMAL
- en: 'raster_data.colorize(style).write_image(''output/classified.png'') 10\. Now
    edit the colorize method:'
  prefs: []
  type: TYPE_NORMAL
- en: '#..'
  prefs: []
  type: TYPE_NORMAL
- en: 'def colorize(self, limits, raw_colors):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Produces an BGR image based on a style containing limits and colors.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param limits: A list of limits.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param raw_colors: A list of color codes. """'
  prefs: []
  type: TYPE_NORMAL
- en: shape = self.data.shape
  prefs: []
  type: TYPE_NORMAL
- en: colors = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for item in raw_colors:'
  prefs: []
  type: TYPE_NORMAL
- en: colors.append(self._convert_color(item))
  prefs: []
  type: TYPE_NORMAL
- en: colors = np.array(colors)
  prefs: []
  type: TYPE_NORMAL
- en: Put each color in its limits.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: flat_array = self.data.flatten()
  prefs: []
  type: TYPE_NORMAL
- en: di_array = np.digitize(flat_array, limits, right=True)
  prefs: []
  type: TYPE_NORMAL
- en: di_array = di_array.reshape((shape[0], shape[1], 1))
  prefs: []
  type: TYPE_NORMAL
- en: results = np.choose(di_array, colors)
  prefs: []
  type: TYPE_NORMAL
- en: Convert from RGB to BGR.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: results = np.asarray(results, dtype=np.uint8)
  prefs: []
  type: TYPE_NORMAL
- en: results = cv2.cvtColor(results, cv2.COLOR_RGB2BGR)
  prefs: []
  type: TYPE_NORMAL
- en: self.data = results
  prefs: []
  type: TYPE_NORMAL
- en: return self
  prefs: []
  type: TYPE_NORMAL
- en: This method now takes two arguments instead of just the style. The only task
    that remains is to convert this new color format.
  prefs: []
  type: TYPE_NORMAL
- en: '11\. Edit the _convert_color method:'
  prefs: []
  type: TYPE_NORMAL
- en: '#...'
  prefs: []
  type: TYPE_NORMAL
- en: 'def _convert_color(self, color_code):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Converts the color notation.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param color_code: A string containing the color in hex'
  prefs: []
  type: TYPE_NORMAL
- en: or JavaScript notation.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: 'if color_code[0] == "#": result = (int(color_code[1:3], 16),'
  prefs: []
  type: TYPE_NORMAL
- en: int(color_code[3:5], 16),
  prefs: []
  type: TYPE_NORMAL
- en: int(color_code[5:7], 16))
  prefs: []
  type: TYPE_NORMAL
- en: 'elif color_code[:3] == "rgb":'
  prefs: []
  type: TYPE_NORMAL
- en: result = map(int, color_code[4:-1].split(','))
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: raise ValueError("Invalid color code.")
  prefs: []
  type: TYPE_NORMAL
- en: return result
  prefs: []
  type: TYPE_NORMAL
- en: This method is now able to detect and convert the two color codes that we use.
    It can also raise an exception in case the color code is not recognized.
  prefs: []
  type: TYPE_NORMAL
- en: '12\. To test the code, edit the if __name__ == ''__main__'': block to be compliant
    with the new format:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: raster_data = RasterData('output/dem.tif')
  prefs: []
  type: TYPE_NORMAL
- en: colors = ['rgb(202,0,32)', 'rgb(244,165,130)',
  prefs: []
  type: TYPE_NORMAL
- en: '''rgb(247,247,247)'', ''rgb(146,197,222)'','
  prefs: []
  type: TYPE_NORMAL
- en: '''rgb(5,113,176)'']'
  prefs: []
  type: TYPE_NORMAL
- en: limits = [700, 900, 1100, 1300, 1800]
  prefs: []
  type: TYPE_NORMAL
- en: raster_data.colorize(limits, colors).write_image(
  prefs: []
  type: TYPE_NORMAL
- en: '''output/classified.png'')'
  prefs: []
  type: TYPE_NORMAL
- en: '13\. Finally, run the code with *Shift* + *F10* and check the output. The schema
    I chose produced the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 56](img/index-333_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Despite the fact that this is a beautiful image, there is a mistake in the choice
    of colors. The warm colors are representing lower altitudes. This could lead to
    confusions, since on most maps, the rule is warmer the color, higher is the value.
  prefs: []
  type: TYPE_NORMAL
- en: It’s only a mater of inverting the colors. Let’s add an option to our colorize
    method to do this.
  prefs: []
  type: TYPE_NORMAL
- en: '14\. Edit the colorize method:'
  prefs: []
  type: TYPE_NORMAL
- en: '#...'
  prefs: []
  type: TYPE_NORMAL
- en: 'def colorize(self, limits, raw_colors, invert_colors=False):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Produces an BGR image based on a style containing limits and colors.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param limits: A list of limits.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param raw_colors: A list of color codes.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param invert_colors: Invert the order of the colors.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: shape = self.data.shape
  prefs: []
  type: TYPE_NORMAL
- en: colors = []
  prefs: []
  type: TYPE_NORMAL
- en: 'if invert_colors:'
  prefs: []
  type: TYPE_NORMAL
- en: raw_colors = list(reversed(raw_colors))
  prefs: []
  type: TYPE_NORMAL
- en: Convert the colors.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![Image 57](img/index-334_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'for item in raw_colors:'
  prefs: []
  type: TYPE_NORMAL
- en: colors.append(self._convert_color(item))
  prefs: []
  type: TYPE_NORMAL
- en: colors = np.array(colors)
  prefs: []
  type: TYPE_NORMAL
- en: Put each color in its limits.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: flat_array = self.data.flatten()
  prefs: []
  type: TYPE_NORMAL
- en: di_array = np.digitize(flat_array, limits, right=True)
  prefs: []
  type: TYPE_NORMAL
- en: di_array = di_array.reshape((shape[0], shape[1], 1))
  prefs: []
  type: TYPE_NORMAL
- en: results = np.choose(di_array, colors)
  prefs: []
  type: TYPE_NORMAL
- en: Convert from RGB to BGR.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: results = np.asarray(results, dtype=np.uint8)
  prefs: []
  type: TYPE_NORMAL
- en: results = cv2.cvtColor(results, cv2.COLOR_RGB2BGR)
  prefs: []
  type: TYPE_NORMAL
- en: self.data = results
  prefs: []
  type: TYPE_NORMAL
- en: return self
  prefs: []
  type: TYPE_NORMAL
- en: '15\. Now, edit the if __name__ == ''__main__'': block again:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: raster_data = RasterData('output/dem.tif')
  prefs: []
  type: TYPE_NORMAL
- en: colors = ['rgb(202,0,32)', 'rgb(244,165,130)',
  prefs: []
  type: TYPE_NORMAL
- en: '''rgb(247,247,247)'', ''rgb(146,197,222)'','
  prefs: []
  type: TYPE_NORMAL
- en: '''rgb(5,113,176)'']'
  prefs: []
  type: TYPE_NORMAL
- en: limits = [700, 900, 1100, 1300, 1800]
  prefs: []
  type: TYPE_NORMAL
- en: raster_data.colorize(limits, colors, True).write_image(
  prefs: []
  type: TYPE_NORMAL
- en: '''output/classified.png'')'
  prefs: []
  type: TYPE_NORMAL
- en: '16\. Run the code and look at the new output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Blending images**'
  prefs: []
  type: TYPE_NORMAL
- en: We can make our results even more visually appealing and informative if we can
    combine the colorized image with the shaded relief image. Again, since we are
    dealing with arrays, we may deduce that this kind of composition can be achieved
    by performing an arithmetic operation between the two arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'In image processing, this is called **alpha blending**. Basically, a *transparency*
    is applied to both of the images and then they are blended into a new one. In
    the next steps, we are going to create a function that performs this operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. First, to avoid generating the shaded relief multiple times, let’s save
    it on the disk and edit the if __name__ == ''__main__'': block of the raster_data.py
    file: if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: raster_data = RasterData('output/dem.tif')
  prefs: []
  type: TYPE_NORMAL
- en: raster_data.adjust_values().create_hillshade(
  prefs: []
  type: TYPE_NORMAL
- en: 10, 60).write_image('output/shaded.png')
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Run the code and check whether the image was correctly written on the disk.
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Now, add the alpha_blend method to the RasterData class:'
  prefs: []
  type: TYPE_NORMAL
- en: '#...'
  prefs: []
  type: TYPE_NORMAL
- en: 'def alpha_blend(self, raster_data, alpha=0.5):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Blend this raster data with another one.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param raster_data: RasterData instance.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param alpha: Amount of transparency to apply.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: shade = cv2.cvtColor(raster_data.data, cv2.COLOR_GRAY2BGR)
  prefs: []
  type: TYPE_NORMAL
- en: result = (1-alpha) * self.data + alpha * shade
  prefs: []
  type: TYPE_NORMAL
- en: self.data = result
  prefs: []
  type: TYPE_NORMAL
- en: return self
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Finally, edit the if __name__ == ''__main__'': block again to test the
    code: if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: shaded = RasterData('output/shaded.png')
  prefs: []
  type: TYPE_NORMAL
- en: classified = RasterData('output/classified.png')
  prefs: []
  type: TYPE_NORMAL
- en: classified.alpha_blend(shaded).write_image(
  prefs: []
  type: TYPE_NORMAL
- en: '''output/color_shade.png'')'
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Run the code and check the image in the output folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 58](img/index-338_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You should see this beautiful output. Note how the combination of the shaded
    relief with the colorized image produces a map that transmits a lot of information
    even for untrained eyes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 59](img/index-340_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Showing statistics with colors**'
  prefs: []
  type: TYPE_NORMAL
- en: How the map is colorized is only a matter of defining the limits and colors
    in the style. So, if we want to translate statistical information into colors,
    we just need to associate the values that we want with a sequence of colors.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s try it with the quartiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Since everything is prepared in our class, we just need to change the code
    in the if __name__ == ''__main__'': block:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: dem = RasterData('output/dem.tif')
  prefs: []
  type: TYPE_NORMAL
- en: shaded = RasterData('output/shaded.png')
  prefs: []
  type: TYPE_NORMAL
- en: limits = [dem.stats['Q1'],
  prefs: []
  type: TYPE_NORMAL
- en: dem.stats['Q3'],
  prefs: []
  type: TYPE_NORMAL
- en: dem.stats['Maximum']]
  prefs: []
  type: TYPE_NORMAL
- en: colors = ["#fc8d59", "#ffffbf", "#91cf60"]
  prefs: []
  type: TYPE_NORMAL
- en: 'dem.colorize(limits, colors).write_image(''output/stats.png'') dem.alpha_blend(shaded).write_image(''output/shaded_stats.png'')
    The following image illustrates the colored output for the analyzed parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 60](img/index-341_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For this image you can start the lead-in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using the histogram to colorize the image** We can also use the histogram
    to colorize the maps. The histogram generated by NumPy is composed of two one-dimensional
    arrays. The first contains the number of occurrences in a given interval (that
    is, the number of pixels). The second one contains the *bins* or the limits. By
    default, the histogram is produced with 11 bins, so we also need 11 different
    colors to produce a map. Let’s change our tests to see how this works: 1\. Edit
    the if __name__ == ''__main__'': block:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: dem = RasterData('data/dem.tif')
  prefs: []
  type: TYPE_NORMAL
- en: shaded = RasterData('output/shaded.png')
  prefs: []
  type: TYPE_NORMAL
- en: colors = ['rgb(103,0,31)','rgb(178,24,43)','rgb(214,96,77)',
  prefs: []
  type: TYPE_NORMAL
- en: '''rgb(244,165,130)'',''rgb(253,219,199)'','
  prefs: []
  type: TYPE_NORMAL
- en: '''rgb(247,247,247)'',''rgb(209,229,240)'','
  prefs: []
  type: TYPE_NORMAL
- en: '''rgb(146,197,222)'',''rgb(67,147,195)'','
  prefs: []
  type: TYPE_NORMAL
- en: '''rgb(33,102,172)'',''rgb(5,48,97)'']'
  prefs: []
  type: TYPE_NORMAL
- en: limits = dem.stats['Histogram'][1]
  prefs: []
  type: TYPE_NORMAL
- en: dem.colorize(limits, colors, True).write_image('output/hist.png') dem.alpha_blend(shaded).write_image('output/shaded_hist.png')
    The colors here are also obtained from ColorBrewer. They are of a diverging nature
    from red to blue. The limits were taken from the histogram by simply using the
    stats property and the second array, which contains the bins.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Run the code and look at the output.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 61](img/index-343_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And the shaded result should look as the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 62](img/index-344_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using more classes resulted in a better representation of the altitude variation
    and it allowed us to clearly see the peaks with high altitudes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we took raw raster data, and with a series of techniques, we
    were able to extract statistical information from it and display it on high quality
    maps. These procedures took us to a high level of communication in terms of geospatial
    information because the material produced is easy to interpret, even for untrained
    eyes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will enter a new field and start taking care of the
    efficiency of our code in order to process massive geospatial datasets in a timely
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter 8\. Data Miner App**'
  prefs: []
  type: TYPE_NORMAL
- en: New challenges appear, to the extent that data size increases. Large sets of
    data bring problems related to excessive processing time and great memory consumption.
    These problems may turn data analysis into a painful process or may even make
    it completely impossible.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will create an application capable of processing huge datasets
    in an efficient way. We will review our code, implementing new tools and techniques
    that will make our analysis not only run faster, but also make better use of computer
    hardware, allowing virtually any amount of data to be processed.
  prefs: []
  type: TYPE_NORMAL
- en: In order to achieve those goals, we will learn how to use databases and how
    to stream the data into them, making the use of computing power constant and stable
    regardless of the amount of data.
  prefs: []
  type: TYPE_NORMAL
- en: These tools will also enable us to perform more advanced searches, calculations,
    and cross information from different sources, allowing you to mine the data for
    precious information.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What code efficiency is and how to measure it
  prefs: []
  type: TYPE_NORMAL
- en: How to import data into a spatial database
  prefs: []
  type: TYPE_NORMAL
- en: How to abstract database data into Python objects
  prefs: []
  type: TYPE_NORMAL
- en: Making queries and getting information from a spatial database Understanding
    code efficiency
  prefs: []
  type: TYPE_NORMAL
- en: 'What constitutes efficient code depends on the points that are being analyzed.
    When we talk about computational efficiency, there are four points that may be
    taken into consideration:'
  prefs: []
  type: TYPE_NORMAL
- en: The time the code takes to execute
  prefs: []
  type: TYPE_NORMAL
- en: How much memory it uses to run
  prefs: []
  type: TYPE_NORMAL
- en: How much disk space it uses
  prefs: []
  type: TYPE_NORMAL
- en: Whether the code uses all the available computing power
  prefs: []
  type: TYPE_NORMAL
- en: 'Good and efficient code is not only about computational efficiency; it’s also
    about writing code that brings these favorable qualities to the development process
    (to cite just a few of them):'
  prefs: []
  type: TYPE_NORMAL
- en: Clean and organized code
  prefs: []
  type: TYPE_NORMAL
- en: Readable code
  prefs: []
  type: TYPE_NORMAL
- en: Easy to maintain and debug
  prefs: []
  type: TYPE_NORMAL
- en: Generalized
  prefs: []
  type: TYPE_NORMAL
- en: Shielded against misuse
  prefs: []
  type: TYPE_NORMAL
- en: It’s obvious that some points are contradictory. Here are just a few examples.
    To speed up a process, you may need to use more memory. To use less memory, you
    may need more disk space. Alternatively, for faster code, you may need to give
    up on generalization and
  prefs: []
  type: TYPE_NORMAL
- en: write very specific functions.
  prefs: []
  type: TYPE_NORMAL
- en: It is the developer who determines the balance between antagonistic characteristics,
    based on the software requirements and the gains obtained by investing in one
    point or another.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if much cleaner code can be written with very little penalty in
    terms of execution time, the developer may opt for clean and maintainable code
    that will be easier for him and his team to understand.
  prefs: []
  type: TYPE_NORMAL
- en: The second block of good characteristics is prone to human evaluation, whereas
    the items in the first block can be measured and compared by the computer.
  prefs: []
  type: TYPE_NORMAL
- en: '**Measuring execution time**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to measure how fast a piece of code is executed, we need to measure
    its execution time. The time measured is relative and varies, depending on a number
    of factors: the operating system, whether there are other programs running, the
    hardware, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: For our efficiency tests, we will measure the execution time, make changes in
    the code, and measure it again. In this way, we will see if the changes improve
    the code efficiency or not.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with a simple example and measure how long it takes to run.
  prefs: []
  type: TYPE_NORMAL
- en: '1\. As before, make a copy of the previous chapter folder in your geopy project
    and rename it as Chapter8\. Your project structure should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: ├───Chapter1
  prefs: []
  type: TYPE_NORMAL
- en: ├───Chapter2
  prefs: []
  type: TYPE_NORMAL
- en: ├───Chapter3
  prefs: []
  type: TYPE_NORMAL
- en: ├───Chapter4
  prefs: []
  type: TYPE_NORMAL
- en: ├───Chapter5
  prefs: []
  type: TYPE_NORMAL
- en: ├───Chapter6
  prefs: []
  type: TYPE_NORMAL
- en: ├───Chapter7
  prefs: []
  type: TYPE_NORMAL
- en: ├───Chapter8
  prefs: []
  type: TYPE_NORMAL
- en: │ ├───experiments
  prefs: []
  type: TYPE_NORMAL
- en: │ ├───map_maker
  prefs: []
  type: TYPE_NORMAL
- en: │ ├───output
  prefs: []
  type: TYPE_NORMAL
- en: │ └───utils
  prefs: []
  type: TYPE_NORMAL
- en: └───data
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Click on your experiments folder and create a new Python file inside it.
    Name that file timing.py.
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Now add the following code to that file:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def make_list1(items_list):'
  prefs: []
  type: TYPE_NORMAL
- en: result = ""
  prefs: []
  type: TYPE_NORMAL
- en: 'for item in items_list:'
  prefs: []
  type: TYPE_NORMAL
- en: template = "I like {}. \n"
  prefs: []
  type: TYPE_NORMAL
- en: text = template.format(item)
  prefs: []
  type: TYPE_NORMAL
- en: result = result + text
  prefs: []
  type: TYPE_NORMAL
- en: return result
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: my_list = ['bacon', 'lasagna', 'salad', 'eggs', 'apples']
  prefs: []
  type: TYPE_NORMAL
- en: print(make_list1(my_list))
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Run the code. Press *Alt* + *Shift* + *F10* and select a timing from the
    list. You should get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: I like bacon.
  prefs: []
  type: TYPE_NORMAL
- en: I like lasagna.
  prefs: []
  type: TYPE_NORMAL
- en: I like salad.
  prefs: []
  type: TYPE_NORMAL
- en: I like eggs.
  prefs: []
  type: TYPE_NORMAL
- en: I like apples.
  prefs: []
  type: TYPE_NORMAL
- en: Nothing fancy, it’s a simple inefficient function to format texts and produce
    a printable list of things.
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Now we are going to measure how long it takes to execute. Modify your code:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from timeit import timeit
  prefs: []
  type: TYPE_NORMAL
- en: 'def make_list1(items_list):'
  prefs: []
  type: TYPE_NORMAL
- en: result = ""
  prefs: []
  type: TYPE_NORMAL
- en: 'for item in items_list:'
  prefs: []
  type: TYPE_NORMAL
- en: template = "I like {}. \n"
  prefs: []
  type: TYPE_NORMAL
- en: text = template.format(item)
  prefs: []
  type: TYPE_NORMAL
- en: result = result + text
  prefs: []
  type: TYPE_NORMAL
- en: return result
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: my_list = ['bacon', 'lasagna', 'salad', 'eggs', 'apples']
  prefs: []
  type: TYPE_NORMAL
- en: number = 100
  prefs: []
  type: TYPE_NORMAL
- en: execution_time = timeit('make_list1(my_list)',
  prefs: []
  type: TYPE_NORMAL
- en: setup='from __main__ import make_list1, my_list',
  prefs: []
  type: TYPE_NORMAL
- en: number=number)
  prefs: []
  type: TYPE_NORMAL
- en: print("It took {}s to execute the code {} times".format(
  prefs: []
  type: TYPE_NORMAL
- en: execution_time, number))
  prefs: []
  type: TYPE_NORMAL
- en: '6\. Run your code again with *Shift* + *F10* and look at the results: It took
    0.000379365835017s to execute the code 100 times'
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: Here we are using the timeit module to measure the execution time of our function.
  prefs: []
  type: TYPE_NORMAL
- en: Since some pieces of code run vary fast, we need to repeat the execution many
    times to get a more precise measurement and a more meaningful number. The number
    of times that the statement is repeated is given by the number parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '7\. Increase your number parameter to 1000000 and run the code again: It took
    3.66938576408s to execute the code 1000000 times'
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: Now we have a more consistent number to work with. If your computer is much
    faster than mine you can increase the number. If it’s slower, decrease it.
  prefs: []
  type: TYPE_NORMAL
- en: Grab a piece of paper and take note of that result. We are going to change the
    function and see if we make the code more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: '8\. Add another version of our function; name it make_list2: def make_list2(items_list):'
  prefs: []
  type: TYPE_NORMAL
- en: result = ""
  prefs: []
  type: TYPE_NORMAL
- en: template = "I like {}. \n"
  prefs: []
  type: TYPE_NORMAL
- en: 'for item in items_list:'
  prefs: []
  type: TYPE_NORMAL
- en: text = template.format(item)
  prefs: []
  type: TYPE_NORMAL
- en: result = result + text
  prefs: []
  type: TYPE_NORMAL
- en: return result
  prefs: []
  type: TYPE_NORMAL
- en: '9\. Also change your if __name__ == ''__main__'': block. We will make it clear
    which version of the function we are executing:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: my_list = ['bacon', 'lasagna', 'salad', 'eggs', 'apples']
  prefs: []
  type: TYPE_NORMAL
- en: number = 1000000
  prefs: []
  type: TYPE_NORMAL
- en: function_version = 2
  prefs: []
  type: TYPE_NORMAL
- en: statement = 'make_list{}(my_list)'.format(function_version) setup = 'from __main__
    import make_list{}, my_list'.format(
  prefs: []
  type: TYPE_NORMAL
- en: function_version)
  prefs: []
  type: TYPE_NORMAL
- en: execution_time = timeit(statement, setup=setup, number=number) print("Version
    {}.".format(function_version))
  prefs: []
  type: TYPE_NORMAL
- en: print("It took {}s to execute the code {} times".format(
  prefs: []
  type: TYPE_NORMAL
- en: execution_time, number))
  prefs: []
  type: TYPE_NORMAL
- en: '10\. Run the code again and see your results. On my computer, I got this: Version
    2\.'
  prefs: []
  type: TYPE_NORMAL
- en: It took 3.5384931206s to execute the code 1000000 times
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: That was a slight improvement in execution time. The only change that was made
    in version 2 was that we moved the template out of the for loop.
  prefs: []
  type: TYPE_NORMAL
- en: '11\. Make a third version of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def make_list3(items_list):'
  prefs: []
  type: TYPE_NORMAL
- en: result = ""
  prefs: []
  type: TYPE_NORMAL
- en: template = "I like "
  prefs: []
  type: TYPE_NORMAL
- en: 'for item in items_list:'
  prefs: []
  type: TYPE_NORMAL
- en: text = template + item + ". \n"
  prefs: []
  type: TYPE_NORMAL
- en: result = result + text
  prefs: []
  type: TYPE_NORMAL
- en: return result
  prefs: []
  type: TYPE_NORMAL
- en: '12\. Change your function_version variable to 3 and run the code again: Version
    3\.'
  prefs: []
  type: TYPE_NORMAL
- en: It took 1.88675713574s to execute the code 1000000 times
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: Now we changed how the string "I like " is formed. Instead of using string formatting,
    we added parts of the string and got code that ran almost twice as fast as the
    previous version.
  prefs: []
  type: TYPE_NORMAL
- en: You can find out which small changes will reduce the execution time by trial
    and error, by consulting articles on the Internet, or by experience. But there
    is a more assertive and powerful way to find out where your code spends more time;
    this is called **profiling**.
  prefs: []
  type: TYPE_NORMAL
- en: '**Code profiling**'
  prefs: []
  type: TYPE_NORMAL
- en: By trial, we found that the most expensive part of our code was the string formatting.
  prefs: []
  type: TYPE_NORMAL
- en: When your code gets more complex, finding bottlenecks by this method gets harder
    and at some point becomes impractical.
  prefs: []
  type: TYPE_NORMAL
- en: The solution is to break and analyze small pieces of code. To see how long they
    take to execute, make a profile of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Python comes with a good profiling tool that automates this process to a certain
    level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use it on our code to see what it tells us:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Add this import at the beginning of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: from timeit import timeit
  prefs: []
  type: TYPE_NORMAL
- en: '**import cProfile**'
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Edit your if __name__ == ''__main__'': block to use the profiler: if __name__
    == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: my_list = ['bacon', 'lasagna', 'salad', 'eggs', 'apples']
  prefs: []
  type: TYPE_NORMAL
- en: number = 1000000
  prefs: []
  type: TYPE_NORMAL
- en: profile = cProfile.Profile()
  prefs: []
  type: TYPE_NORMAL
- en: profile.enable()
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(number):'
  prefs: []
  type: TYPE_NORMAL
- en: make_list1(my_list)
  prefs: []
  type: TYPE_NORMAL
- en: profile.disable()
  prefs: []
  type: TYPE_NORMAL
- en: profile.print_stats(sort='cumulative')
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Run the code. You should see the profiler statistics on the console. (I
    suppressed some information for reasons of space):'
  prefs: []
  type: TYPE_NORMAL
- en: 6000002 function calls in 4.755 seconds
  prefs: []
  type: TYPE_NORMAL
- en: 'Ordered by: cumulative time'
  prefs: []
  type: TYPE_NORMAL
- en: ncalls tottime percall cumtime percall
  prefs: []
  type: TYPE_NORMAL
- en: 1000000 2.718 0.000 4.738 0.000 timing.py
  prefs: []
  type: TYPE_NORMAL
- en: 5000000 2.019 0.000 2.019 0.000 {'format' ...}
  prefs: []
  type: TYPE_NORMAL
- en: 1 0.017 0.017 0.017 0.017 {range}
  prefs: []
  type: TYPE_NORMAL
- en: 1 0.000 0.000 0.000 0.000 {'disable' ...}
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to execute the profiler. In our case, we instantiated the
    Profile class and used the enable and disable methods to tell the profiler where
    to start and stop collecting data. Again, the call to make_list1 was repeated
    1000000 times to generate bigger numbers.
  prefs: []
  type: TYPE_NORMAL
- en: In the output, we can see that make_list1 was called 1000000 times and the format
    method was called five million times, taking 2.019 seconds. Note that the profiler
    only gave information regarding methods and functions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Storing information on a database**'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapters, the basic workflow was to import all the data into
    memory as Python objects every time we ran the code. That’s perfectly fine and
    efficient when we work with small pieces of data.
  prefs: []
  type: TYPE_NORMAL
- en: At some point, you may have noticed that the performance of our code was debilitated,
    especially when we started importing country boundaries along with all the attributes.
    This happened because importing attributes is slow.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, although our filtering mechanisms worked pretty well, we may have
    problems when dealing with huge datasets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The formula to solve these problems is very simple and consists of only two
    basic ingredients:'
  prefs: []
  type: TYPE_NORMAL
- en: Get only what you need
  prefs: []
  type: TYPE_NORMAL
- en: Use indexed searches
  prefs: []
  type: TYPE_NORMAL
- en: The first point is about getting only the records you need, as well as getting
    only the attributes that are desired for a given analysis.
  prefs: []
  type: TYPE_NORMAL
- en: The second point is about how things are found. In our method, a loop tests
    every record for a condition until the desired one is found (that is, the test
    returns True). Alternatively, if the computer somehow had an idea of where the
    item was, the search would be much faster; this is indexing.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of trying to implement these features by ourselves, we can use a database
    to handle these mechanisms for us; they are state-of-the-art for this kind of
    job.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we have two options:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a **SQLite** database with the **Spatialite** extension, which is an open
    source, simple, and very efficient SQL database. It doesn’t require a server or
    installation, and Python comes bundled with a connector to it.
  prefs: []
  type: TYPE_NORMAL
- en: Use a **PostgreSQL** database with the **Postgis** extension. Also open source
    and powerful, this is a full-featured database server.
  prefs: []
  type: TYPE_NORMAL
- en: The choice is up to you and will have no influence on the code except for a
    small change in the settings.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs: []
  type: TYPE_NORMAL
- en: 'PostgreSQL can be download from: [http://www.postgresql.org/.](http://www.postgresql.org/)
    In order to enable Postgis, you just need to select it in the stack builder during
    the installation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using Ubuntu, you can find more details at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://wiki.ubuntu.com/UbuntuGIS.](https://wiki.ubuntu.com/UbuntuGIS)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating an Object Relational Mapping**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Object Relational Mapping** (**ORM**) is a method that we will use to convert
    the data stored in a database into Python objects. This no different from what
    we did before in our models.py file, where we made code that transformed data
    stored in geographic files (for example, a GPX shapefile) into Python objects.'
  prefs: []
  type: TYPE_NORMAL
- en: This time, we will close the circle by importing the data into the database,
    and then later retrieve data or information from it in the same elegant and intuitive
    manner as before.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL databases, such as SQLite, store the data in tables with row and columns.
    The following table illustrates how the geocaching data that we previously used
    would be represented in this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ID Geom Name**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Status**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Owner Hints**'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: (wkb) LaSalle Park Available John
  prefs: []
  type: TYPE_NORMAL
- en: Under sign
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: (wkb) Parking
  prefs: []
  type: TYPE_NORMAL
- en: Available Nina
  prefs: []
  type: TYPE_NORMAL
- en: Big tree
  prefs: []
  type: TYPE_NORMAL
- en: We can guess that this is incompatible with the premise of being able to import
    any type of data, because the type of column is fixed. If we have data with different
    attributes or more attributes, we need different tables or to add more columns
    to match every possibility.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome the limitation of this schema, we will use the relational capabilities
    of SQL
  prefs: []
  type: TYPE_NORMAL
- en: 'databases. We will store items and attributes in different tables and relate
    them: **Points**'
  prefs: []
  type: TYPE_NORMAL
- en: '**ID Geom**'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: 42.89 - 78.90
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: 43.00 - 78.0
  prefs: []
  type: TYPE_NORMAL
- en: '**Attributes**'
  prefs: []
  type: TYPE_NORMAL
- en: '**ID Key**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Value**'
  prefs: []
  type: TYPE_NORMAL
- en: '**point_id**'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: name LaSalle Park 1
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: status Available
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: owner John
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: hints
  prefs: []
  type: TYPE_NORMAL
- en: under sign
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: name Parking
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: status Available
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: owner Nina
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: hints
  prefs: []
  type: TYPE_NORMAL
- en: big tree
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: This key/value data model allows each point (or other objects) to have arbitrary
    numbers and types of attributes. Each attribute is attached to its owner by an
    ID.
  prefs: []
  type: TYPE_NORMAL
- en: You may have heard of Django, *batteries-included* Python web framework. It
    happens that Django has a fantastic ORM included in it, and it has very developed
    support for geospatial databases and geospatial operations (this part of Django
    is called **GeoDjango** and is included by default). You will also notice that
    the transition from our models to Django will be smooth and they will remain easy
    to use, as before.
  prefs: []
  type: TYPE_NORMAL
- en: '**Preparing the environment**'
  prefs: []
  type: TYPE_NORMAL
- en: In order to use Django’s ORM we need to setup a Django project. To do that we
    will prepare the minimum required structure, which consists of a few files and
    settings.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s set up our application to use Django.
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Inside your Chapter8 folder, create a new Python file named settings.py.
    If you are using PostgreSQL/Postgis, add the following code to the file: DATABASES
    = {'
  prefs: []
  type: TYPE_NORMAL
- en: '''default'': {'
  prefs: []
  type: TYPE_NORMAL
- en: '''ENGINE'': ''django.contrib.gis.db.backends.postgis'','
  prefs: []
  type: TYPE_NORMAL
- en: '''NAME'': ''postgres'','
  prefs: []
  type: TYPE_NORMAL
- en: '''USER'': ''postgres'','
  prefs: []
  type: TYPE_NORMAL
- en: '''PASSWORD'': ''mypassword'','
  prefs: []
  type: TYPE_NORMAL
- en: '''PORT'': 5432'
  prefs: []
  type: TYPE_NORMAL
- en: '}}'
  prefs: []
  type: TYPE_NORMAL
- en: The first item (DATABASES) is the database settings. If you have a default PostgreSQL/Postgis
    installation, this will work. Just change your password for the one you set during
    the installation.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. If you are using SQLite/Spatialite, use this configuration: DATABASES =
    {'
  prefs: []
  type: TYPE_NORMAL
- en: '''default'': {'
  prefs: []
  type: TYPE_NORMAL
- en: '''ENGINE'': ''django.contrib.gis.db.backends.spatialite'','
  prefs: []
  type: TYPE_NORMAL
- en: '''NAME'': ''mydatabase.db'''
  prefs: []
  type: TYPE_NORMAL
- en: '}}'
  prefs: []
  type: TYPE_NORMAL
- en: '3\. After the database configuration, add these items:'
  prefs: []
  type: TYPE_NORMAL
- en: INSTALLED_APPS = ('django.contrib.gis', 'geodata')
  prefs: []
  type: TYPE_NORMAL
- en: SECRET_KEY = 'abc'
  prefs: []
  type: TYPE_NORMAL
- en: The INSTALLED_APPS item tells Django where to look for models. SECRET_KEY is
    used for Django’s user management. Although we won’t use it, this needs to be
    set (you can use any value as the secret key).
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Now create a Python package that will be our Django app. Right-click the
    Chapter8
  prefs: []
  type: TYPE_NORMAL
- en: folder and select **New** | **Python Package**. Name it geodata.
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Create a new Python file inside Chapter8 and name it geodata_app.py.
  prefs: []
  type: TYPE_NORMAL
- en: '**Changing our models**'
  prefs: []
  type: TYPE_NORMAL
- en: We have the basic structure ready, now we need to adapt our models so they can
    use the database instead of storing all the information in memory. Django’s model
    definition is very similar to ours.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the new capabilities provided by Django, we will make one change in the
    choice of design: instead of one class for each type of object (geocaching, roads,
    boundaries, and so on) we will have only one class that can store data for all
    of them and any others that we can think of.'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Create a file models.py inside the geodata folder and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from django.contrib.gis.db import models
  prefs: []
  type: TYPE_NORMAL
- en: 'class GeoObject(models.Model):'
  prefs: []
  type: TYPE_NORMAL
- en: geom = models.GeometryField()
  prefs: []
  type: TYPE_NORMAL
- en: atype = models.CharField(max_length=20)
  prefs: []
  type: TYPE_NORMAL
- en: objects = models.GeoManager()
  prefs: []
  type: TYPE_NORMAL
- en: The GeoObject class represents a single object (a single row in a table). It
    can accept any kind of geometry (a point, polygon, and so on) in the geom field.
    The atype property represents the high-level type of the object. This property
    will tell us if it’s a geocaching point or something else (we are using atype
    and not type to avoid conflicts with the internal type() function).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the objects property represents the collection of GeoObject (the table
    in the database). In Django this is called a **manager**; don’t worry, we will
    see more about this later.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Now we need the tags for our GeoObject; the tags will contain every attribute.
    Add another class after the GeoObject class.
  prefs: []
  type: TYPE_NORMAL
- en: 'class Tag(models.Model):'
  prefs: []
  type: TYPE_NORMAL
- en: key = models.CharField(max_length=250)
  prefs: []
  type: TYPE_NORMAL
- en: value = models.CharField(max_length=250)
  prefs: []
  type: TYPE_NORMAL
- en: geo_object = models.ForeignKey(GeoObject, related_name='tags') Again, this class
    represents a single object, a single tag with a key and a value that is connected
    with a GeoObject by a foreign key. The result is that a Tag class has a GeoObject
    and a GeoObject has many tags.
  prefs: []
  type: TYPE_NORMAL
- en: '**Customizing a manager**'
  prefs: []
  type: TYPE_NORMAL
- en: As said before, a manager can be considered as something that represents a table
    in a database. It contains methods to retrieve records, add, delete, and many
    other operations.
  prefs: []
  type: TYPE_NORMAL
- en: Django comes with the GeoManager class that is used for tables that contain
    spatial objects. If we want to add more functionalities to our GeoData manager,
    we just need to inherit from GeoManager and then add a class property with an
    instance of it in the GeoObject class. Actually, we will just replace the instance
    in the objects property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s adapt our BaseGeoCollection class to be a manager for the GeoObject class:
    1\. Navigate to your Chapter8/models.py file (the one that we wrote in previous
    chapters) and rename it to Chapter8/old_models.py. With this, we avoid confusion
    about which model we are talking about.'
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Create a file named managers.py inside the geodata folder. Add this code
    to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from django.contrib.gis.db.models import GeoManager
  prefs: []
  type: TYPE_NORMAL
- en: from utils.geo_functions import open_vector_file
  prefs: []
  type: TYPE_NORMAL
- en: 'class GeoCollection(GeoManager):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""This class represents a collection of spatial data."""'
  prefs: []
  type: TYPE_NORMAL
- en: Pass
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the first step in migrating our BaseGeoCollection class. Note that
    we named it GeoCollection because it won’t be a base class anymore. We will simplify
    our code so this class will manage all types of geo objects. To do that, we will
    add the import_data method from the BaseGeoCollection class and combine it with
    the _parse_data method from the PointCollection class. Before we continue, let’s
    take a look at these methods as they are (you don’t need to type this code):'
  prefs: []
  type: TYPE_NORMAL
- en: '#...'
  prefs: []
  type: TYPE_NORMAL
- en: 'def import_data(self, file_path):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Opens an vector file compatible with OGR and parses the data.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param str file_path: The full path to the file.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: features, metadata = open_vector_file(file_path)
  prefs: []
  type: TYPE_NORMAL
- en: self._parse_data(features)
  prefs: []
  type: TYPE_NORMAL
- en: self.epsg = metadata['epsg']
  prefs: []
  type: TYPE_NORMAL
- en: 'print("File imported: {}".format(file_path))'
  prefs: []
  type: TYPE_NORMAL
- en: '#...'
  prefs: []
  type: TYPE_NORMAL
- en: 'def _parse_data(self, features):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Transforms the data into Geocache objects.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param features: A list of features.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: 'for feature in features:'
  prefs: []
  type: TYPE_NORMAL
- en: coords = feature['geometry']['coordinates']
  prefs: []
  type: TYPE_NORMAL
- en: point = Point(float(coords[1]), float(coords[0]))
  prefs: []
  type: TYPE_NORMAL
- en: attributes = feature['properties']
  prefs: []
  type: TYPE_NORMAL
- en: cache_point = Geocache(point, attributes=attributes)
  prefs: []
  type: TYPE_NORMAL
- en: self.data.append(cache_point)
  prefs: []
  type: TYPE_NORMAL
- en: Note that import_data opens the vector file and then sends the features to _parse_data,
    which iterates over the data, creating points and putting the feature properties
    into a dictionary. If we manage to import any kind of geometry and pass the feature
    properties to the tag model, we end with a piece of code that will serve any kind
    of geospatial object.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Edit the code in geodata/managers.py again. Whether you want to copy and
    edit the mentioned methods or type the new import_data method from scratch is
    up to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting code should be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from django.contrib.gis.db.models import GeoManager
  prefs: []
  type: TYPE_NORMAL
- en: from django.db import IntegrityError, DataError
  prefs: []
  type: TYPE_NORMAL
- en: from utils.geo_functions import open_vector_file
  prefs: []
  type: TYPE_NORMAL
- en: from shapely.geometry import shape
  prefs: []
  type: TYPE_NORMAL
- en: 'class GeoCollection(GeoManager):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""This class represents a collection of spatial data."""'
  prefs: []
  type: TYPE_NORMAL
- en: 'def import_data(self, file_path, atype):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Opens an vector file compatible with OGR and parses the data.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param str file_path: The full path to the file.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: features = open_vector_file(file_path)
  prefs: []
  type: TYPE_NORMAL
- en: 'for feature in features:'
  prefs: []
  type: TYPE_NORMAL
- en: geom = shape(feature['geometry'])
  prefs: []
  type: TYPE_NORMAL
- en: geo_object = self.model(geom=geom.wkt, atype=atype)
  prefs: []
  type: TYPE_NORMAL
- en: geo_object.save()
  prefs: []
  type: TYPE_NORMAL
- en: 'for key, value in feature[''properties''].iteritems():'
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: geo_object.tags.create(key=key, value=value)
  prefs: []
  type: TYPE_NORMAL
- en: 'except (IntegrityError, DataError):'
  prefs: []
  type: TYPE_NORMAL
- en: pass
  prefs: []
  type: TYPE_NORMAL
- en: 'print("File imported: {}".format(file_path))'
  prefs: []
  type: TYPE_NORMAL
- en: We used Shapley’s shape function to directly convert feature['geometry'], which
    is a GeoJSON geometry-like dictionary, into a shapely geometry of the correct
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Then we used that geometry to get a WKT representation of it.
  prefs: []
  type: TYPE_NORMAL
- en: The atype argument was included on the method, so we can use it to define the
    type of the GeoObject. Remember that atype is not a type of geometry; it represents
    the high-level type of the object (geocaching, boundary, road, river, waypoint,
    and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the statement geo_object = self.model(geom=geom.wkt, atype=atype), we see
    a great feature of Django managers: the same manager can be used by many models,
    and self.model contains a reference to the class that this manager was called
    from.'
  prefs: []
  type: TYPE_NORMAL
- en: If we had decided on another design pattern and used one class for each object
    type, we would still be able to use the same manager for all of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the sequence, the model is saved and then the properties dictionary is iterated
    and for every item a tag is created. We are catching exceptions here because we
    have two special conditions that may happen: if the value of a property is None
    it will raise an IntegrityError; if the length of the value is larger than 250,
    it will raise a DataError. If you are interested in long fields, such as the logs
    from the geocaching data, you can increase the field max_length or try a different
    field type.'
  prefs: []
  type: TYPE_NORMAL
- en: '4\. We are not using the metadata here, and reading it can cause an incompatibility
    error between libraries for Windows users. So we will remove it from the open_vector_file
    function. Edit your utils/geo_functions.py file to change this function. As a
    plus, let’s print the number of features read: def open_vector_file(file_path):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Opens an vector file compatible with OGR or a GPX file.'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a list of features and informations about the file.
  prefs: []
  type: TYPE_NORMAL
- en: ':param str file_path: The full path to the file.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: datasource = ogr.Open(file_path)
  prefs: []
  type: TYPE_NORMAL
- en: Check if the file was opened.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if not datasource:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if not os.path.isfile(file_path):'
  prefs: []
  type: TYPE_NORMAL
- en: message = "Wrong path."
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: message = "File format is invalid."
  prefs: []
  type: TYPE_NORMAL
- en: raise IOError('Error opening the file {}\n{}'.format(
  prefs: []
  type: TYPE_NORMAL
- en: file_path, message))
  prefs: []
  type: TYPE_NORMAL
- en: file_name, file_extension = os.path.splitext(file_path)
  prefs: []
  type: TYPE_NORMAL
- en: Check if it's a GPX and read it if so.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if file_extension in [''.gpx'', ''.GPX'']:'
  prefs: []
  type: TYPE_NORMAL
- en: features = read_gpx_file(file_path)
  prefs: []
  type: TYPE_NORMAL
- en: If not, use OGR to get the features.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: features = read_ogr_features(datasource.GetLayerByIndex(0)) print("{} features.".format(len(features)))
  prefs: []
  type: TYPE_NORMAL
- en: return features
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Finally, edit geodata/models.py to import and use the new manager:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from django.contrib.gis.db import models
  prefs: []
  type: TYPE_NORMAL
- en: from managers import GeoCollection
  prefs: []
  type: TYPE_NORMAL
- en: 'class GeoObject(models.Model):'
  prefs: []
  type: TYPE_NORMAL
- en: geom = models.GeometryField()
  prefs: []
  type: TYPE_NORMAL
- en: atype = models.CharField(max_length=20)
  prefs: []
  type: TYPE_NORMAL
- en: objects = GeoCollection()
  prefs: []
  type: TYPE_NORMAL
- en: 'class Tag(models.Model):'
  prefs: []
  type: TYPE_NORMAL
- en: key = models.CharField(max_length=250)
  prefs: []
  type: TYPE_NORMAL
- en: value = models.CharField(max_length=250)
  prefs: []
  type: TYPE_NORMAL
- en: 'geo_object = models.ForeignKey(GeoObject, related_name=''tags'') We are almost
    ready to begin testing. At this point, your Chapter 8 structure should be like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: +---Chapter8
  prefs: []
  type: TYPE_NORMAL
- en: '| geocaching_app.py'
  prefs: []
  type: TYPE_NORMAL
- en: '| geodata_app.py'
  prefs: []
  type: TYPE_NORMAL
- en: '| map_maker_app.py'
  prefs: []
  type: TYPE_NORMAL
- en: '| models_old.py'
  prefs: []
  type: TYPE_NORMAL
- en: '| raster_data.py'
  prefs: []
  type: TYPE_NORMAL
- en: '| settings.py'
  prefs: []
  type: TYPE_NORMAL
- en: '| settings.pyc'
  prefs: []
  type: TYPE_NORMAL
- en: '| __init__.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: +---experiments
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: +---geodata
  prefs: []
  type: TYPE_NORMAL
- en: '| | managers.py'
  prefs: []
  type: TYPE_NORMAL
- en: '| | models.py'
  prefs: []
  type: TYPE_NORMAL
- en: '| | __init__.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: +---map_maker
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: +---output
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: \---utils
  prefs: []
  type: TYPE_NORMAL
- en: check_plugins.py
  prefs: []
  type: TYPE_NORMAL
- en: data_transfer.py
  prefs: []
  type: TYPE_NORMAL
- en: geo_functions.py
  prefs: []
  type: TYPE_NORMAL
- en: '**Generating the tables and importing data** Now it’s time to make Django generate
    the database tables for us. Since our models are defined, we just need to call
    a pair of commands and Django will perform its magic.'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Go back to the geodata_app.py file and add some content to it:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import os
  prefs: []
  type: TYPE_NORMAL
- en: import django
  prefs: []
  type: TYPE_NORMAL
- en: os.environ.setdefault("DJANGO_SETTINGS_MODULE", "settings") django.setup()
  prefs: []
  type: TYPE_NORMAL
- en: from django.core.management import call_command
  prefs: []
  type: TYPE_NORMAL
- en: from geodata.models import *
  prefs: []
  type: TYPE_NORMAL
- en: 'def prepare_database():'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Call this to setup the database or any time you change your models.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: call_command('makemigrations', 'geodata')
  prefs: []
  type: TYPE_NORMAL
- en: call_command('migrate', 'geodata')
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: prepare_database()
  prefs: []
  type: TYPE_NORMAL
- en: After we import os and django we need to specify which settings file it should
    look for. After that, django.setup() initializes Django.
  prefs: []
  type: TYPE_NORMAL
- en: The prepare_database function calls two Django management commands responsible
    for database creation. We will need to call it every time we change our models.
    Internally, Django keeps a record of the changes made and automatically generates
    SQL queries that perform the modifications on the database.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Run your code now. If everything goes fine, you should see the database
    migration results in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Migrations for ''geodata'':'
  prefs: []
  type: TYPE_NORMAL
- en: '0001_initial.py:'
  prefs: []
  type: TYPE_NORMAL
- en: '- Create model GeoObject'
  prefs: []
  type: TYPE_NORMAL
- en: '- Create model Tag'
  prefs: []
  type: TYPE_NORMAL
- en: 'Operations to perform:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Apply all migrations: geodata'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running migrations:'
  prefs: []
  type: TYPE_NORMAL
- en: Rendering model states… DONE
  prefs: []
  type: TYPE_NORMAL
- en: Applying geodata.0001_initial… OK
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Now, edit geodata_app.py again to add a convenience function to import some
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will begin with the geocaching data as a test:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import os
  prefs: []
  type: TYPE_NORMAL
- en: import django
  prefs: []
  type: TYPE_NORMAL
- en: os.environ.setdefault("DJANGO_SETTINGS_MODULE", "settings") django.setup()
  prefs: []
  type: TYPE_NORMAL
- en: from django.core.management import call_command
  prefs: []
  type: TYPE_NORMAL
- en: from geodata.models import *
  prefs: []
  type: TYPE_NORMAL
- en: 'def prepare_database():'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Call this to setup the database or any time you change your models.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: call_command('makemigrations', 'geodata')
  prefs: []
  type: TYPE_NORMAL
- en: call_command('migrate', 'geodata')
  prefs: []
  type: TYPE_NORMAL
- en: 'def import_initial_data(input_file, atype):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Import new data into the database."""'
  prefs: []
  type: TYPE_NORMAL
- en: print("Importing {}...".format(atype))
  prefs: []
  type: TYPE_NORMAL
- en: GeoObject.objects.import_data(input_file, atype)
  prefs: []
  type: TYPE_NORMAL
- en: print("Done!")
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: prepare_database()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import_initial_data("../data/geocaching.gpx", 'geocaching') This new function
    is only a convenience function to reduce typing since we will import a lot of
    data very soon. We are commenting the prepare_database() statement because we
    will use it later.
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Run your code (make sure you run it only once to avoid duplicated entries).
    In your output you should see this:'
  prefs: []
  type: TYPE_NORMAL
- en: Importing geocaching…
  prefs: []
  type: TYPE_NORMAL
- en: 112 features.
  prefs: []
  type: TYPE_NORMAL
- en: Done!
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: '**Filtering the data**'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have some data in the database, it’s time to test it and see if
    we can filter some points as we did before.
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Edit your if __name__ == ''__main__'': block (remember to comment the previous
    commands):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: prepare_database()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import_initial_data("../data/geocaching.gpx", 'geocaching') points = GeoObject.objects.filter(atype='geocaching',
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: tags__key='status',
  prefs: []
  type: TYPE_NORMAL
- en: tags__value='Available')
  prefs: []
  type: TYPE_NORMAL
- en: print(len(points))
  prefs: []
  type: TYPE_NORMAL
- en: 'for tag in points[0].tags.all():'
  prefs: []
  type: TYPE_NORMAL
- en: print(tag.key, tag.value)
  prefs: []
  type: TYPE_NORMAL
- en: Here we are using the filter method inherited by our manager to filter the records
    of geocaching type. Plus we are accessing the related tags to filter only the
    available geocaches. This is done by using a double underscore after the property
    name. In the end, we print all the tags for the first of the points returned.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Run your code and you should see a list of tags like this: 224'
  prefs: []
  type: TYPE_NORMAL
- en: (u'type', u'Other')
  prefs: []
  type: TYPE_NORMAL
- en: (u'hints', u'under sign')
  prefs: []
  type: TYPE_NORMAL
- en: (u'time', u'2013-09-29T00:00:00Z')
  prefs: []
  type: TYPE_NORMAL
- en: (u'state', u'New York')
  prefs: []
  type: TYPE_NORMAL
- en: (u'country', u'United States')
  prefs: []
  type: TYPE_NORMAL
- en: (u'url', u'http://www.opencaching.us/viewcache.php?cacheid=1728') (u'name',
    u'LaSalle Park No 1')
  prefs: []
  type: TYPE_NORMAL
- en: (u'container', u'Virtual')
  prefs: []
  type: TYPE_NORMAL
- en: (u'src', u'www.opencaching.us')
  prefs: []
  type: TYPE_NORMAL
