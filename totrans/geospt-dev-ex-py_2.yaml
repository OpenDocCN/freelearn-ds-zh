- en: 'def display_map(self):'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: '"""Opens and displays a map image file.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: ':param image_file: Path to the image.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: image = cv2.imread(self.output_image)
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: cv2.imshow('image', image)
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: cv2.waitKey(0)
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: cv2.destroyAllWindows()
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: This function now uses the output_image property to display the map and takes
    no arguments apart from the class instance (self) when called.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s work on the create_map function.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '8\. Copy the create_map function from the map_functions.py file and make the
    following changes to the class:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import cv2
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: import mapnik
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'class MapMakerApp(object):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: def __init__(self, output_image="map.png",
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: style_file="map_maker/styles.xml",
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'map_size=(800, 600)):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '"""Application class.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: ':param output_image: Path to the image output of the map.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: ':param style_file: Mapnik XML file containing only the style for the map.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: ':param map_size: Size of the map in pixels.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: self.output_image = output_image
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: self.style_file = style_file
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: self.map_size = map_size
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'def display_map(self):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '"""Opens and displays a map image file."""'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: image = cv2.imread(self.output_image)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: cv2.imshow('image', image)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: cv2.waitKey(0)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: cv2.destroyAllWindows()
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'def create_map(self):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '"""Creates a map and writes it to a file."""'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: map = mapnik.Map(*self.map_size)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: mapnik.load_map(map, self.style_file)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: layers = map.layers
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: map.zoom_all()
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: mapnik.render_to_file(map, self.output_image)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: As we did with display_map, now the create_map function takes no arguments (except
    for self) and all parameters come from the instance attributes, the ones that
    were added to the __init__ method. We also improved the default values for those
    arguments.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: All the layer and data source definitions were removed from create_map because
    in the next steps we will plug in the PythonDatasource that we created earlier.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '**Using PythonDatasource**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this type of data source and implement the ability to display any number
    of data sources on the map, we will make our app class take control of the organization
    of the layers and the data that they use, always following the premise that the
    application should have a high level of abstraction:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Include this import at the beginning of the file:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: from map_maker.my_datasource import MapDatasource
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Modify the class __init__ method and create an add_layer method, as follows:
    class MapMakerApp(object):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: def __init__(self, output_image="map.png",
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: style_file="map_maker/styles.xml",
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'map_size=(800, 600)):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '"""Application class.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: ':param output_image: Path to the image output of the map.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: ':param style_file: Mapnik XML file containing only the style for the map.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: ':param map_size: Size of the map in pixels.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: self.output_image = output_image
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: self.style_file = style_file
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: self.map_size = map_size
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: self._layers = {}
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: def display_map(self):...
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: def create_map(self):...
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'def add_layer(self, geo_data, name, style=''style1''):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '"""Add data to the map to be displayed in a layer with a given style.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: ':param geo_data: a BaseGeoCollection subclass instance.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: data source = mapnik.Python(factory='MapDatasource',
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: data=geo_data)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'layer = {"data source": data source,'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '"data": geo_data,'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '"style": style}'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: self._layers[name] = layer
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: What we did here is use a private attribute (_layers) to keep track of the layers
    that we will use by their names. The add_layer method is responsible for instantiating
    the MapDatasource class and passing to it the data.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: The data that we will use here is a subclass of BaseGeoCollection that we used
    in the previous chapters. With this, we will manipulate the map using only high-level
    objects, and also get all their functionality for free.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: As we said before, *Python Datasource does not work on Windows*, so we need
    to
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: create a workaround to make things work despite the operating system. What we
    are going to do is save the data to a temporary file and then use Mapnik’s GeoJSON
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: plugin to create a data source.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Add these imports to the beginning of the file:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**import platform**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '**import tempfile**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '**from models import BoundaryCollection, PointCollection**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: import cv2
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: import mapnik
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Now let’s create a folder to hold our temporary files. Create a new folder
    named temp inside your Chapter5 folder.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Modify the add_layer method to include the workaround:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '#...'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'def add_layer(self, geo_data, name, style=''style1''):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '"""Add data to the map to be displayed in a layer with a given style.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: ':param geo_data: a BaseGeoCollection subclass instance.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'if platform.system() == "Windows":'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: print("Windows system")
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: temp_file, filename = tempfile.mkstemp(dir="temp") print temp_file, filename
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: geo_data.export_geojson(filename)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: data source = mapnik.GeoJSON(file=filename)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: data source = mapnik.Python(factory='MapDatasource',
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: data=geo_data)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'layer = {"data source": data source,'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '"data": geo_data,'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '"style": style}'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: self._layers[name] = layer
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Here, we used platform.system() to detect whether the operating system is Windows.
    If so, instead of creating a Python DataSource, it creates a temporary file and
    exports geo_data to it. Then we use the GeoJSON plugin to open that file, creating
    a DataSource.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Now that the workaround is complete, we need to go back to the MapDatasource
    definition and make it accept the data that we are passing to it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '6\. In the my_datasource.py file, include the following __init__ method in
    the MapDatasource class:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'class MapDatasource(mapnik.PythonDatasource):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '"""Implementation of Mapinik''s PythonDatasource."""'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, data):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: super(MapDatasource, self).__init__(envelope, geometry_type, data_type)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: self.data = data
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'def features(self, query=None):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: raise NotImplementedError
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Our subclass of PythonDatasource now takes one obligatory data argument. Since
    we are increasing the level of abstraction, we will make the MapDatasource class
    define all the other arguments automatically by inspecting the data it receives;
    with this change, we won’t need to worry about the geometry type or data type.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '7\. Make another change to the __init__ method:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'class MapDatasource(mapnik.PythonDatasource):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '"""Implementation of Mapinik''s PythonDatasource."""'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, data):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: data_type = mapnik.DataType.vector
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'if isinstance(data, PointCollection):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: geometry_type = mapnik.GeometryType.Point
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'elif isinstance(data, BoundaryCollection):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: geometry_type = mapnik.GeometryType.Polygon
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: raise TypeError
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: super(MapDatasource, self).__init__(
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: envelope=None, geometry_type=geometry_type,
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: data_type=data_type)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: self.data = data
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'def features(self, query=None):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: raise NotImplementedError
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Here, isinstance() checks which type is data, and for each of the possible types
    it defines the corresponding geometry_type to be passed to the parent __init__
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: method.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, we only have one data type: the vector. Anyway, we will make this
    definition explicit (data_type = mapnik.DataType.vector) because in the next chapter,
    the raster type will be introduced.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Before we go any further, let’s test the app as it is.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '8\. Now edit the if __name__ == ''__main__'': block at the end of the file:
    if __name__ == ''__main__'':'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: world_borders = BoundaryCollection(
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '"../data/world_borders_simple.shp")'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: map_app = MapMakerApp()
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: map_app.add_layer(world_borders, 'world')
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: map_app.create_map()
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: map_app.display_map()
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Note how Mapnik is completely abstracted; we now only deal with the high-level
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: functionality provided by our models and the app.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '9\. Run the code; you should see an empty map and an output like this in the
    console: File imported: ../data/world_borders_simple.shp'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Windows system
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'File exported: \geopy\Chapter5\temp\tmpfqv9ch'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'The map is empty because two points are still missing: the features method,
    which is the glue between our geo data and the Mapnik data source, and making
    the create_map function use the layers that we have defined.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '10\. Let’s start with the create_map method. Change its code so it can iterate
    over our layers and add them to the map:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '#...'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'def create_map(self):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '"""Creates a map and writes it to a file."""'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: map = mapnik.Map(*self.map_size)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: mapnik.load_map(map, self.style_file)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: layers = map.layers
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'for name, layer in self._layers.iteritems():'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: new_layer = mapnik.Layer(name)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: new_layer.datasource = layer["data source"]
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: new_layer.stylers.append(layer['style'])
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: layers.append(new_layer)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: map.zoom_all()
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: mapnik.render_to_file(map, self.output_image)
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '11\. Now edit styles.xml in order to remove the extent restriction from it:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: <Map background-color="white">
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: <Style name="style1">
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: <Rule>
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: <PolygonSymbolizer fill="#f2eff9" />
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: <LineSymbolizer stroke="red" stroke-width="1.0" smooth="0.5" />
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: <TextSymbolizer face-name="DejaVu Sans Book" size="10"
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: fill="black" halo-fill= "white"
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: halo-radius="1" placement="interior"
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: allow-overlap="false">[NAME]
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: </TextSymbolizer>
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: </Rule>
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: </Style>
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: <Style name="style2">
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: <Rule>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: <PointSymbolizer file="marker.svg" transform="scale(0.3)"/>
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: </Rule>
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: </Style>
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: </Map>
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '12\. Now run the code again and look at the output. If you are using Windows,
    you should see a rendered map. If you are using Linux you should get an exception:
    Traceback (most recent call last):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: File … in <module>
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: raise NotImplementedError
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: NotImplementedError
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 1
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: If you got this exception (in Linux), it is because everything went fine and
    Mapnik called our unimplemented features method.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s implement this method.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '13\. Go to the my_datasource.py file and edit our class:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'class MapDatasource(mapnik.PythonDatasource):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '"""Implementation of Mapinik''s PythonDatasource."""'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, data):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: data_type = mapnik.DataType.Vector
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'if isinstance(data, PointCollection):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: geometry_type = mapnik.GeometryType.Point
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'elif isinstance(data, BoundaryCollection):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: geometry_type = mapnik.GeometryType.Polygon
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: raise TypeError
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: super(MapDatasource, self).__init__(
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: envelope=None, geometry_type=geometry_type,
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: data_type=data_type)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: self.data = data
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'def features(self, query=None):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: keys = ['name',]
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: features = []
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'for item in self.data.data:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'features.append([item.geom.wkb, {''name'': item.name}])'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'return mapnik.PythonDatasource.wkb_features(keys, features) 14\. Run the code
    again; now you should see the rendered map in the output:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 38](img/index-272_1.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
- en: '![Image 39](img/index-273_1.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
- en: '**Using the app with filtering**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Since the BaseGeoCollection class has filtering capabilities that were implemented
    before, it’s possible to filter the data before passing it to the map.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try some examples:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '1\. In the map_maker_app.py file, edit the if __name__ == ''__main__'': block:
    if __name__ == ''__main__'':'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: world_borders = BoundaryCollection(
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '"../data/world_borders_simple.shp")'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: my_country = world_borders.filter('name', 'Brazil')
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: map_app = MapMakerApp()
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: map_app.add_layer(my_country, 'countries')
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: map_app.create_map()
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: map_app.display_map()
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are using the filter function of the BaseGeoCollection class to filter
    the countries by name; feel free to try to filter by your country.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Run the code and you should see a map containing only one country (zoom
    should be active), as in the following screenshot:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Now try combining filters to show more than one country:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 40](img/index-274_1.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
- en: 'if __name__ == ''__main__'':'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: world_borders = BoundaryCollection(
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '"../data/world_borders_simple.shp")'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: countries = world_borders.filter('name', 'China') +\
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: world_borders.filter('name', 'India') +\
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: world_borders.filter('name', 'Japan')
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: map_app = MapMakerApp()
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: map_app.add_layer(countries, 'countries')
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: map_app.create_map()
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: map_app.display_map()
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Run the code again and see the results.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we saw how Mapnik works and how maps are defined and styled
    using both Python and XML. Using Mapnik’s Python API, it was possible to define
    the map in XML and then alter it in Python, showing great flexibility for all
    kinds of needs.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: As the app was structured, Mapnik was hidden behind high-level functionalities
    that enabled us to use the geographic data objects that we created before, allowing
    the application to filter the data to be displayed in the map.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will meet raster data for the first time; we will see
    how it works and display it in our maps.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter 6\. Working with Remote Sensing**'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '**Images**'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start working with images—images that may come from
    a variety of sensors carried by satellites, drones, airplanes, and so on. These
    types of images, the ones collected from remote sensing devices, are images that
    contain pixels representing a spectral response from a given geographic region.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Besides just adding images to a map, it is important to prepare the images to
    be presented on the map. You may need to combine, cut, change the resolution,
    change values, and perform many other transformations in order to produce a visually
    appealing map or valuable information.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: To perform these transformations on the images, we will go through a process
    of deduction that will result in a versatile and powerful software structure.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics covered here are:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how the images are represented
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: The relation of the images with the real world
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Combining, cropping, and adjusting the values of the images Creating shaded
    relief maps from the elevation data
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: How to execute a sequence of processing steps
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 41](img/index-279_1.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
- en: '**Understanding how images are**'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '**represented**'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to understand what images are in terms of computer representation
    and the data they contain, we are going to start with some examples. The first
    thing to do is to organize your project to follow this chapter’s code as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 1\. As before, inside your geopy project, make a copy of your Chapter5 folder
    and rename it to Chapter6\.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Inside Chapter6, navigate to the experiments folder and create a new file
    inside it named image_experiments.py. Open it for editing.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: We will start by inspecting a small sample image that has a structure similar
    to a large satellite image.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Nothing fancy, you will see four squares of different colors. But if we take
    a step further and add a grid to it, we can see a little bit more information.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 42](img/index-280_1.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
- en: The image was divided into 16 squares of equal size. Each one of these squares
    is a so-called **pixel**. A pixel is the smallest portion of information that
    an image (that is, raster data) contains. While talking about geoprocessing, the
    image as a whole comprehends a space in the real world and each pixel is a fraction
    of that space.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: When we added the sample image to the map in the beginning of the chapter, we
    manually defined the extent of this image (that is, its bounding box). This information
    told Mapnik how the coordinates in the image relates to the real world coordinates.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have seen that our sample image has 16 pixels with a shape of 4 x
    4\. But how this image or any other raster data relates to a real world space
    depends on the information that may or may not be stored in the data itself.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: The first information that states the relation is where the image is in the
    world. Images and raster data normally have their point of origin in the top left
    corner. If we assign a coordinate to the point of origin, we will be able to place
    the image on the world.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'Secondly, we need information on the area that this image covers. And there
    are three ways this information can appear:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: The size of the pixels of the image
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: The size of the image
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: The coordinates of the bounding box of the image
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 43](img/index-281_1.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
- en: 'This information is related by the following equations:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: x_pixel_size = width / columns
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: y_pixel_size = height / lines
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: width = xmax – xmin
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: height = ymax – ymin
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '**Opening images with OpenCV**'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'For a better understanding, we will open the sample image with OpenCV and inspect
    its contents as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '1\. In your image_expriments.py file, type the following code: def open_raster_file(image):'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '"""Opens a raster file.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: ':param image: Path of the raster file or np array.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: image = cv2.imread(image)
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: return image
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: image = open_raster_file('../../data/sample_image.tiff')
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: print(image)
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: print(type(image))
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: print(image.shape)
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Run the code. Since it’s the first time you have run this file, press *Alt*
    + *Shift* + *F10*
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'and choose image_experiments from the list. You should see the following output:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[[[ 0 0 255]'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[ 0 0 255]'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[ 0 255 0]'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[ 0 255 0]]'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[[ 0 0 255]'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[ 0 0 255]'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[ 0 255 0]'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[ 0 255 0]]'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[[255 0 0]'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[255 0 0]'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[100 100 100]'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[100 100 100]]'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[[255 0 0]'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[255 0 0]'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[100 100 100]'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[100 100 100]]]'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: <type 'numpy.ndarray'>
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: (4, 4, 3)
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: The expression print(type(image)) prints the type of the object that is stored
    in the image variable. As you can see, it’s a NumPy array with a shape of 4 x
    4 x 3\. OpenCV
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: opens the image and put its data inside an array, although for now, it is a
    little bit hard to visualize how the data is organized. The array contains the
    color information for each
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: pixel on the image.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'For better visualization, I’m going to reorganize the print output for you:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[[[ 0 0 255] [ 0 0 255] [ 0 255 0] [ 0 255 0]]'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[[ 0 0 255] [ 0 0 255] [ 0 255 0] [ 0 255 0]]'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[[255 0 0] [255 0 0] [100 100 100] [100 100 100]]'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[[255 0 0] [255 0 0] [100 100 100] [100 100 100]]]'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Now the shape of the array makes more sense. Notice that we have four *lines*
    and each line has four *columns* exactly as it is seen in the image. By its turn,
    each item has a set of three numbers that represents the values for the blue,
    green, and red channels.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Remember that when you import a colored image with OpenCV, the order of the
    channels will be BGR (blue, green, and red).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, take the first pixel in the top left corner. It’s all red as we
    see in the image: Blue Green Red'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[ 0 0 255]'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: So, the first and the most important implication of the images being imported
    as NumPy arrays is that they behave like arrays and have all the functions and
    methods that any NumPy array has, opening the possibility of using the full power
    of NumPy while working with raster data.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 44](img/index-284_1.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
- en: '**Knowing numerical types**'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'Each pixel in the previous topic has three channels: blue, green, and red.
    Each one has a value ranging from 0 to 255 (256 possible values). The combination
    of these channels result in a visible color. This range of values is not random;
    256 is the number of combinations that is possible to achieve with a single **byte**.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: A byte is the smallest portion of data that a computer can store and retrieve
    from the memory. It’s composed of 8 bits of zeros or ones.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: This is important to us because the computer uses its memory to store the image
    and it will reserve a given space to store the value for each channel for each
    pixel. We must be sure that the space reserved is adequate for the data we want
    to store.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Let’s make an abstraction. Think that you have 1 liter (1,000 ml) of water and
    you want to store it. If you choose a 250 ml cup to store this water, the excess
    will spill out. If you choose a water truck with 10,000 liter capacity, you can
    store the water, but it will be a huge waste of space. So, you may choose a 3
    liter bucket that would be sufficient to store the water. It’s not big as a truck
    and you will have some extra space if you want to store a little bit more water.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: In computing, things work similarly. You need to choose the size of the container
    before you put things in it. In the previous example, OpenCV made this choice
    for us. You will see a number of instances in the future where the programs we
    use will help us in these choices. But a clear understanding on how this works
    is very important because if the water spills out (that is, overflows), you will
    end up with unexpected behavior in your program. Or, if you choose a too large
    recipient, you may run out of computer memory.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 'The needs for value storage may vary in the aspects of:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Only positive or positive and negative numbers
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Integers or fractions
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Small or large numbers
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Complex numbers
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'The available options and their sizes may vary with the computer architecture
    and software. For a common 64-bit desktop, NumPy will give you these possible
    numerical types:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'bool: Boolean (True or False) stored as a byte'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'int8: Byte (-128 to 127)'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'int16: Integer (-32768 to 32767)'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'int32: Integer (-2147483648 to 2147483647) int64: Integer (-9223372036854775808
    to 9223372036854775807) uint8: Unsigned integer (0 to 255)'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'uint16: Unsigned integer (0 to 65535)'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: 'uint32: Unsigned integer (0 to 4294967295)'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: 'uint64: Unsigned integer (0 to 18446744073709551615)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'float16: Half precision float: sign bit, 5 bits exponent, 10 bits mantissa
    float32: Single precision float: sign bit, 8 bits exponent, 23 bits mantissa float64:
    Double precision float: sign bit, 11 bits exponent, 52 bits mantissa complex64:
    Complex number represented by two 32-bit floats (real and imaginary components)'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'complex128: Complex number represented by two 64-bit floats (real and imaginary
    components)'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we may expect that our sample image has the type uint8\. Let’s check whether
    it’s true:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Edit the if __name__ == ''__main__'': block:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: image = open_raster_file('../../data/sample_image.tiff')
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: print(type(image))
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: print(image.dtype)
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Run the code again. You should see an output matching our expectations:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: <type 'numpy.ndarray'>
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: uint8
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '**Processing remote sensing images and**'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '**data**'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: Satellite images come in a different format and serve different purposes. These
    images can be used to visualize features on Earth using real colors or they may
    be used to identify a variety of characteristics using parts of the spectrum invisible
    to the human eye.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: As we saw, our sample image had three channels (blue, green, and red) that were
    combined in a single file to compose a real color image. Different from the sample
    image, most satellite data comes with each channel separated into a file for each
    one of them.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: These channels are called **bands** and comprise of a range of the electromagnetic
    spectrum visible or not to the human eye.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: In the following examples, we are going to use the **digital elevation models**
    (**DEM**) generated with the data obtained by the **Advanced Spaceborne Thermal
    Emission and** **Reflection Radiometer** (**ASTER**).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: These DEM have a resolution of approximately 90 m and the values are stored
    in the 16
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: bits signed integers representing the elevation in meters.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: 'The dataset we are going to use is included in the data folder and is from
    a Brazilian city called *Poços de Caldas*. This city is inside a giant extinct
    volcano crater, a feature we hope to see during data processing. For didactic
    reasons and in order to cover a big region, four images will be used:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: You can obtain more digital elevation models at [http://earthexplorer.usgs.gov/.](http://earthexplorer.usgs.gov/)
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: 1\. If want to download and use your own DEM, you need to extract the downloaded
    ZIP
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: file. Notice that each ZIP archive has two images. The one ending with _dem
    is the actual elevation data. The one ending with _num contains the quality assessment
    information. Take a look at the included README.pdf file for more information.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Move or copy all the images to the data folder of your Chapter 6 code.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'Each image represents a tile of 1 degree. The information on which tile the
    image covers is encoded in the name of the file, as seen in the following image:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 45](img/index-288_1.jpg)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
- en: '**Mosaicking images**'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Mapnik has the ability to read tiled data from the disk using the raster data
    source. But we are not going to use it, because the process of patching images
    together is very important and is worth learning.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: 'The next code will open the images, combine them, and save a single combined
    image in the disk. This process (with varying levels of complexity) is called
    **mosaicking**: 1\. Still in the image_experiments.py file, add a new function
    after the open_raster_file function:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: 'def combine_images(input_images):'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '"""Combine images in a mosaic.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: ':param input_images: Path to the input images.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: images = []
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: 'for item in input_images:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: images.append(open_raster_file(item))
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: print images
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Now, edit the if __name__ == ''__main__'': block so we can test the code:
    if __name__ == ''__main__'':'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: elevation_data = [
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '''../../data/ASTGTM2_S22W048_dem.tif'','
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '''../../data/ASTGTM2_S22W047_dem.tif'','
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '''../../data/ASTGTM2_S23W048_dem.tif'','
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '''../../data/ASTGTM2_S23W047_dem.tif'']'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: combine_images(elevation_data)
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Run the code and look at the output:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '[array([[[1, 1, 1],'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '[1, 1, 1],'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '[2, 2, 2],'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '...,'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[4, 4, 4],'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[4, 4, 4],'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[4, 4, 4]],'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: . . .
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: You should see a list of four arrays. PyCharm will hide some values so it can
    fit in the console.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we should notice is that the order of the images in the input
    images argument is the same as the order of the arrays in the output list. This
    will be very important later.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, although the elevation data is a 16-bit signed integer (int16), the
    arrays representing the images still have three bands of an 8-bit unsigned integer.
    This is an error.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 46](img/index-290_1.jpg)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
- en: 'OpenCV is converting the grayscale image to a color image. We are going to
    fix it as follows:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Change the open_raster_file function to accept a new argument. It will
    allow us to open the images without changing them:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: 'def open_raster_file(image, unchanged=True):'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '"""Opens a raster file.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: ':param image: Path of the raster file or np array.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: ':param unchanged: Set to true to keep the original format.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: flags = cv2.CV_LOAD_IMAGE_UNCHANGED if unchanged else -1
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: image = cv2.imread(image, flags=flags)
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: return image
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: The flags argument in cv2.imread allows us to tune how the images are opened
    and converted into arrays. If the flags are set to cv2.CV_LOAD_IMAGE_UNCHANGED,
    the image will open as it is without any conversion.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Since we set the default of unchanged to true, we will just run the code
    again and see the results:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[array([[ 508, 511, 514, ..., 1144, 1148, 1152],'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '[ 507, 510, 510, ..., 1141, 1144, 1150],'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[ 510, 508, 506, ..., 1141, 1145, 1154],'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '...,'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '[ 805, 805, 803, ..., 599, 596, 593],'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '[ 802, 797, 803, ..., 598, 594, 590],'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '[ 797, 797, 800, ..., 603, 596, 593]], dtype=uint16)'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: . . .
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: The values now are correct and they are the measured elevation in meters for
    each pixel.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have a list of arrays in the order that the input files are listed.
    To figure out the next step, we can imagine this list as if the images were mosaicked
    as a strip: Now, we must reorganize this, so the images are placed in their correct
    position.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: Remember that NumPy arrays have a shape property. In a 2D array, it’s a tuple
    containing
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: the shape in columns and rows. NumPy arrays also have the reshape() method that
    performs a shape transformation.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the NumPy documentation on the reshape method and function. Changing
    the shape of an array is a very powerful tool at
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.scipy.org/doc/numpy/reference/generated/numpy.reshape.html.](http://docs.scipy.org/doc/numpy/reference/generated/numpy.reshape.html)'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: The reshape works by filling a row with the input values in order. When the
    row is full, the method jumps to the next row and continues until the end. So,
    if we pass the expected shape of the mosaic to the combine_images function, we
    can use this information to combine the images with respect to the proper positions.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: 'But we need something else. We need to know the shape of the output image through
    the number of pixels, and this will be the product of the shape of each image
    by the shape of the mosaic. Let’s try a few changes in the code as follows: 1\.
    Edit the combine images function:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: 'def combine_images(input_images, shape, output_image):'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '"""Combine images in a mosaic.'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: ':param input_images: Path to the input images.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: ':param shape: Shape of the mosaic in columns and rows.'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: ':param output_image: Path to the output image mosaic.'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: 'if len(input_images) != shape[0] * shape[1]:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: raise ValueError(
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '"Number of images doesn''t match the mosaic shape.") images = []'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: 'for item in input_images:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: images.append(open_raster_file(item))
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: rows = []
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: 'for row in range(shape[0]):'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: start = (row * shape[1])
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: end = start + shape[1]
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: rows.append(np.concatenate(images[start:end], axis=1))
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: mosaic = np.concatenate(rows, axis=0)
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: print(mosaic)
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: print(mosaic.shape)
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: Now the function accepts two more arguments, the shape of the mosaic (the number
    of images in the row and columns and not the number of pixels) and the path of
    the output image for later use.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: With this code, the list of images is separated into rows. Then, the rows are
    combined to form the complete mosaic.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Before you run the code, don’t forget to import NumPy at the beginning
    of the file:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  id: totrans-453
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import cv2
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: import numpy as np
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: 'And edit the if __name__ == ''__main__'': block: if __name__ == ''__main__'':'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: elevation_data = [
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '''../../data/ASTGTM2_S22W048_dem.tif'','
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '''../../data/ASTGTM2_S22W047_dem.tif'','
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '''../../data/ASTGTM2_S23W048_dem.tif'','
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '''../../data/ASTGTM2_S23W047_dem.tif'']'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: combine_images(elevation_data, shape=(2, 2))
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Now run the code and see the results:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '[[508 511 514…, 761 761 761]'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '[507 510 510…, 761 761 761]'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: '[510 508 506…, 761 761 761]'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '...,'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '[514 520 517…, 751 745 739]'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '[517 524 517…, 758 756 753]'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '[509 509 510…, 757 759 760]]'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: (7202, 7202)
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: It’s now a single array with 7202 x 7202 pixels. The remaining task is to save
    this array to the disk as an image.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Just add two lines to the function and edit the if __name__ == ''__main__'':
    block: def combine_images(input_images, shape, output_image):'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: '"""Combine images in a mosaic.'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: ':param input_images: Path to the input images.'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: ':param shape: Shape of the mosaic in columns and rows.'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: ':param output_image: Path to the output image mosaic.'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: 'if len(input_images) != shape[0] * shape[1]:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: raise ValueError(
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: '"Number of images doesn''t match the mosaic shape.") images = []'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: 'for item in input_images:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: images.append(open_raster_file(item))
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: rows = []
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: 'for row in range(shape[0]):'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: start = (row * shape[1])
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: end = start + shape[1]
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: rows.append(np.concatenate(images[start:end], axis=1))
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: mosaic = np.concatenate(rows, axis=0)
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: print(mosaic)
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: print(mosaic.shape)
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: cv2.imwrite(output_image, mosaic)
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: elevation_data = [
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: '''../../data/ASTGTM2_S22W048_dem.tif'','
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: '''../../data/ASTGTM2_S22W047_dem.tif'','
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: '''../../data/ASTGTM2_S23W048_dem.tif'','
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: '''../../data/ASTGTM2_S23W047_dem.tif'']'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: combine_images(elevation_data, shape=(2, 2),
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: output_image="../output/mosaic.png")
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: '**Adjusting the values of the images**'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the previous code, you will see a black image as an output. This
    happens because the value range that represents the actual data of this region
    is so narrow in comparison to the possible range of the 16-bit integer image that
    we can’t distinguish the shades of gray. For better understanding, let’s make
    a simple test as follows: 1\. Still in the image_experiments.py file, comment
    the if __name__ == ''__main__'': block and add this new one:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: image = open_raster_file("../output/mosaic.png")
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: print(image.min(), image.max())
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Run the code and look at the console output.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: (423, 2026)
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: Precisely, the image ranges from -32768 to 32767 and the elevation of the region
    in it ranges from 423 to 2026\. So what we need to do to make the image visible
    is to scale the altitude range to the range of the data type.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: Since we are making a data representation intended for human visualization,
    we don’t need to use a big range of gray values. The researches vary, but some
    say that we can detect only 30 shades, so an 8-bit unsigned integer with 256 possible
    values should be more than enough for data visualization.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Add this new function:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: 'def adjust_values(input_image, output_image, img_range=None):'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: '"""Create a visualization of the data in the input_image by projecting a range
    of values into a grayscale image.'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: ':param input_image: Array containing the data'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: or path to an image.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: ':param output_image: The image path to write the output.'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: ':param img_range: specified range of values or None to use the range of the
    image (minimum and maximum).'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: image = open_raster_file(input_image)
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: 'if img_range:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: min = img_range[0]
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: max = img_range[1]
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: min = image.min()
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: max = image.max()
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: interval = max - min
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: factor = 256.0 / interval
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: output = image * factor
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: cv2.imwrite(output_image, output)
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: This function accepts either an array or the path to an image file. With this
    feature,
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 47](img/index-295_1.jpg)'
  id: totrans-532
  prefs: []
  type: TYPE_IMG
- en: we can later use this function as a sub-step in other processing procedures.
    The range of values that you want to use is also optional. It can be set manually
    or can be extracted from the images minimum and maximum value.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: '4\. To test the code, edit the if __name__ == ''__main__'': block: if __name__
    == ''__main__'':'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: Adjust.
  id: totrans-535
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: adjust_values('../output/mosaic.png',
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: '''../output/mosaic_grey.png'')'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: Note that the output image is now a png file. Since we are preparing the image
    for visualization, we can afford to lose information in data compression in exchange
    for a smaller file.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Run the code and open the mosaic_grey.png file to see the results. You
    should see the following beautiful grayscale image now:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: '**Cropping an image**'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: We made a big mosaic of images in order to cover the region of interest, and
    in the process, we ended up with an image much bigger than the one we needed.
    Now, it’s time to crop the image, so we end up with a smaller one comprising only
    of what we want to see, thus saving disk space and processing time.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we are interested in the volcano crater. It’s the round object
    located on the right-hand side of the image. In order to obtain only that region
    of interest, we will write a function that can crop the image using a bounding
    box set of coordinates, as follows: 1\. Add the new function to the image_experiments.py
    file:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: 'def crop_image(input_image, image_extent, bbox, output_image):'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: '"""Crops an image by a bounding box.'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: 'bbox and image_extent format: (xmin, ymin, xmax, ymax).'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: ':param input_image: Array containing the data'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: or path to an image.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: ':param image_extent: The geographic extent of the image.'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: ':param output_image: The image path to write the output.'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: ':param bbox: The bounding box of the region of interest.'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: input_image = open_raster_file(input_image)
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: img_shape = input_image.shape
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: img_geo_width = abs(image_extent[2] - image_extent[0])
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: img_geo_height = abs(image_extent[3] - image_extent[1])
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: How much pixels are contained in one geographic unit.
  id: totrans-556
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pixel_width = img_shape[1] / img_geo_width
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: pixel_height = img_shape[0] / img_geo_height
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: Index of the pixel to cut.
  id: totrans-559
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: x_min = abs(bbox[0] - image_extent[0]) * pixel_width
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: x_max = abs(bbox[2] - image_extent[0]) * pixel_width
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: y_min = abs(bbox[1] - image_extent[1]) * pixel_height
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: y_max = abs(bbox[3] - image_extent[1]) * pixel_height
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: output = input_image[y_min:y_max, x_min:x_max]
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: cv2.imwrite(output_image, output)
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: Since we are dealing with NumPy arrays, the cropping itself is a simple array
    slicing.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: The slicing of arrays is very similar to the Python lists’ slicing, but with
    additional dimensions. The statement input_image[y_min:y_max, x_min:x_max] tells
    that we want only the portion of the array contained within the specified cells
    (that is, pixels).
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: So, all the math involved is to convert geographic units into array indices.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Edit the if __name__ == ''__main__'': block to test the code: if __name__
    == ''__main__'':'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: Crop.
  id: totrans-570
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'roi = (-46.8, -21.7, -46.3, -22.1) # Region of interest.'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: crop_image('../output/mosaic_grey.png',
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: (-48, -21, -46, -23), roi, "../output/cropped.png")
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 48](img/index-297_1.jpg)'
  id: totrans-574
  prefs: []
  type: TYPE_IMG
- en: 3\. Run the code and open the output image to see the results.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: '4\. If you have missed any of the steps, you can run the whole process all
    at once. Just edit the if __name__ == ''__main__'' block:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: Combine.
  id: totrans-578
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: elevation_data = [
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: '''../../data/ASTGTM2_S22W048_dem.tif'','
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: '''../../data/ASTGTM2_S22W047_dem.tif'','
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: '''../../data/ASTGTM2_S23W048_dem.tif'','
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: '''../../data/ASTGTM2_S23W047_dem.tif'']'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: combine_images(elevation_data, shape=(2, 2),
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: output_image="../output/mosaic.png")
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: Adjust.
  id: totrans-586
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: adjust_values('../output/mosaic.png',
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: '''../output/mosaic_grey.png'')'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: Crop.
  id: totrans-589
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'roi = (-46.8, -21.7, -46.3, -22.1) # Region of interest.'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: crop_image('../output/mosaic_grey.png',
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: (-48, -21, -46, -23), roi, "../output/cropped.png")
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 49](img/index-298_1.jpg)'
  id: totrans-593
  prefs: []
  type: TYPE_IMG
- en: '**Creating a shaded relief image**'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: Our digital elevation model image has improved a lot after we processed it,
    but it is still not suitable for a map. Untrained eyes may find it difficult to
    understand the relief only by looking at the different shades of gray.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, there is a technique, called **hill shading** or **relief shading**,
    that transforms the elevation data into a simulated sun shading over the terrain.
    Look at the beautiful map in the following picture and note how much easier it
    is to understand the relief when it is presented as a shaded relief:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: 'The process is simple and involves passing our image through a well-known algorithm
    as follows:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Add the create_hillshade function to your image_experiments.py file: def
    create_hillshade(input_image, output_image,'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: 'azimuth=90, angle_altitude=60):'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: '"""Creates a shaded relief image from a digital elevation model.'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: ':param input_image: Array containing the data'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: or path to an image.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: ':param azimuth: Simulated sun azimuth.'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: ':param angle_altitude: Sun altitude angle.'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: input_image = open_raster_file(input_image)
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: x, y = np.gradient(input_image)
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: slope = np.pi / 2 - np.arctan(np.sqrt(x * x + y * y))
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: aspect = np.arctan2(-x, y)
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: az_rad = azimuth * np.pi / 180
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: alt_rad = angle_altitude * np.pi / 180
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 50](img/index-299_1.jpg)'
  id: totrans-612
  prefs: []
  type: TYPE_IMG
- en: a = np.sin(alt_rad) * np.sin(slope)
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: b = np.cos(alt_rad) * np.cos(slope) * np.cos(az_rad - aspect) output = 255 *
    (a + b + 1) / 2
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: cv2.imwrite(output_image, output)
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Now, alter the if __name__ == ''__main__'': block to test the code: if
    __name__ == ''__main__'':'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: create_hillshade("../output/cropped.png",
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: '"../output/hillshade.png")'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Run the code and open the output image to see the results. If everything
    goes fine, you should see a shaded relief representation of your data.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 51](img/index-301_1.jpg)'
  id: totrans-620
  prefs: []
  type: TYPE_IMG
- en: '**Building an image processing pipeline**'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: Image processing, be it for geographic applications or not, generally requires
    the execution of a sequence of transformations (that is, steps) in order to obtain
    the desired final result. In these sequences, the output of one step is the input
    of the next one. In computing, this is called **processing pipeline**.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: This type of data manipulation is very versatile, because you have a range of
    functions or steps than can be arranged into numerous combinations to produce
    a wide range of results.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: What we did so far, in this chapter’s examples, was we opened an image from
    the disk, performed a given operation, and saved the results to another image
    on the disk. Then, in the next step, we opened the result from the previous one
    and so on.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite the steps are not yet connected, we can imagine the following image
    processing pipeline:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: Saving intermediary steps to the disk is useful when we want to use the images
    from them, or in other situations, when the pipeline uses parallel processing
    or other more complex methods.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: For some cases, it would be more interesting just to pass data along the pipeline
    without touching the hard drive, only using the computer memory. With this, one
    should expect a noticeable gain in speed and a lesser production of residual files.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: In order to conciliate these two situations, we can use type checks for our
    functions’
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: 'arguments, making them accept either arrays or file paths. Navigate to your
    open_raster_file function and alter its code:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: 'def open_raster_file(file_path, unchanged=True):'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: '"""Opens a raster file.'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: '**:param file_path: Path of the raster file or np array.**'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: ':param unchanged: Set to true to keep the original format.'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: '**if isinstance(file_path, np.ndarray):**'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: '**return file_path**'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: flags = cv2.CV_LOAD_IMAGE_UNCHANGED if unchanged else -1
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: image = cv2.imread(file_path, flags=flags)
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: return image
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: This function will now check the type of file_path. If it is already a NumPy
    array, it will be returned. This changes the behavior of all of our functions
    because they can now receive arrays as input.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: If we add a return statement to all the functions and make them return the output
    arrays,
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: 'we would be able to combine the function as follows: create_hillshade('
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: crop_image(
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: adjust_values('mosaic.png'),
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: (-48, -21, -46, -23), roi), 'shaded.png')
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: You don’t need to type this code. This notation is hard to understand. The order
    in which the functions are called is unintuitive and it’s difficult to figure
    out of which function is each argument.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: It would be much nicer if we could execute the pipeline by chaining the functions,
    like we did in the *Chaining filters* section in [Chapter 4,](index_split_001.html#p174)
    *Improving the App Search Capabilities*.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, it would be great to use something with a notation as follows: adjust_values().crop_image().create_hillshade()'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: As in [Chapter 4](index_split_001.html#p174), *Improving the App Search Capabilities*,
    the only thing we need is to have a class and the methods that return the same
    type of class. With these two things, there are no limits on how the steps can
    be combined. So, let’s do it.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a RasterData class**'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: Our RasterData class will follow the pattern used before with our vectors. When
    instantiated, the class will receive a file path or an array. As said before,
    in order to use method chaining to perform a processing pipeline, each processing
    method must return another instance of the RasterData class.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start with class declaration and then fill it with the methods. To
    make it easier to cut and paste the work we have already done, we will do the
    following steps inside the image_experiments.py file:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: '1\. At the top of the image_experiments.py file, after the imports, create
    the class:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  id: totrans-654
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import cv2
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: import numpy as np
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: 'class RasterData(object):'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, input_data, unchanged=True, shape=None):'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: '"""Represents a raster data in the form of an array.'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: ':param input_data: Raster files or Numpy array.'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: ':param unchanged: True to keep the original format.'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: ':param shape: When using multiple input data, this param'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: determines the shape of the composition.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: self.data = None
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: if isinstance(input_data, list) \
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: 'or isinstance(input_data, tuple):'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: self.combine_images(input_data, shape)
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: self.import_data(input_data, unchanged)
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: The array will be stored in the data property, so we will initially set it to
    None.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: There are a few other changes to make this class consistent with the others
    and avoid redundancy in the names. The first one is to use an import_data method
    like before.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Cut and paste the open_raster_file function into the class, rename it to
    import_data, and change it to behave like a method:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: 'class RasterData(object):'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, input_data, unchanged=True, shape=None):'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: 'def import_data(self, image, unchanged=True):'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: '"""Opens a raster file.'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: ':param image: Path of the raster file or np array.'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: ':param unchanged: True to keep the original format.'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: 'if isinstance(image, np.ndarray):'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: self.data = image
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: return image
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: flags = cv2.CV_LOAD_IMAGE_UNCHANGED if unchanged else -1
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: self.data = cv2.imread(image, flags=flags)
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: Instead of returning an array, it will now put the array in the data property.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: Next, since we will be removing the obligation of writing the image to the disk
    from the steps, we will need a method to perform this action.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Add the write_image method:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: 'class RasterData(object):'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, input_data, unchanged=True, shape=None):'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: 'def import_data(self, input_image, unchanged=True):'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: 'def write_image(self, output_image):'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: '"""Write the data to the disk as an image.'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: ':param output_image: Path and name of the output image.'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: cv2.imwrite(output_image, self.data)
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: return self
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Following the examples’ order, cut and paste the combine_images function
    as a method to the class:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: 'class RasterData(object):'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, input_data, unchanged=True, shape=None):'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: 'def import_data(self, input_image, unchanged=True):'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: 'def write_image(self, output_image):'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: 'def combine_images(self, input_images, shape):'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: '"""Combine images in a mosaic.'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: ':param input_images: Path to the input images.'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: ':param shape: Shape of the mosaic in columns and rows.'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: 'if len(input_images) != shape[0] * shape[1]:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: raise ValueError("Number of images doesn't match the"
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: '" mosaic shape.")'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: images = []
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: 'for item in input_images:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: 'if isinstance(item, RasterData):'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: images.append(item.data)
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
- en: images.append(RasterData(item).data)
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: rows = []
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: 'for row in range(shape[0]):'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
- en: start = (row * shape[1])
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
- en: end = start + shape[1]
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: rows.append(np.concatenate(images[start:end], axis=1))
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
- en: mosaic = np.concatenate(rows, axis=0)
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
- en: self.data = mosaic
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: return self
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: Now, it’s possible to create an empty RasterData instance and then populate
    it with a mosaic using this method. Or, you can create the instance with a list
    containing any combination of image paths, arrays, or even other RasterData instances
    as an argument. It will automatically combine them, put the result in the data
    property, and return itself.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
- en: Now that you got the hang of it, let’s do the same transformation with the last
    three functions.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Cut and paste the adjust_values, crop_image and create_hillshade functions
    as methods into the class. Your complete class should be as follows: class RasterData(object):'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, input_data, unchanged=True, shape=None):'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
- en: '"""Represents a raster data in the form of an array.'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: ':param input_data: Raster files or Numpy array.'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
- en: ':param unchanged: True to keep the original format.'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: ':param shape: When using multiple input data, this param'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
- en: determines the shape of the composition.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: self.data = None
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: if isinstance(input_data, list) \
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: 'or isinstance(input_data, tuple):'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
- en: self.combine_images(input_data, shape)
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: self.import_data(input_data, unchanged)
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
- en: 'def import_data(self, image, unchanged=True):'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: '"""Opens a raster file.'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
- en: ':param image: Path of the raster file or np array.'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: ':param unchanged: True to keep the original format.'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: 'if isinstance(image, np.ndarray):'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
- en: self.data = image
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: return image
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: flags = cv2.CV_LOAD_IMAGE_UNCHANGED if unchanged else -1
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
- en: self.data = cv2.imread(image, flags=flags)
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: 'def write_image(self, output_image):'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
- en: '"""Write the data to the disk as an image.'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
- en: ':param output_image: Path and name of the output image.'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: cv2.imwrite(output_image, self.data)
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
- en: return self
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
- en: 'def combine_images(self, input_images, shape):'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
- en: '"""Combine images in a mosaic.'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: ':param input_images: Path to the input images.'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
- en: ':param shape: Shape of the mosaic in columns and rows.'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
- en: 'if len(input_images) != shape[0] * shape[1]:'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
- en: raise ValueError("Number of images doesn't match the"
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: '" mosaic shape.")'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
- en: images = []
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: 'for item in input_images:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
- en: 'if isinstance(item, RasterData):'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
- en: images.append(item.data)
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
- en: images.append(RasterData(item).data)
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
- en: rows = []
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: 'for row in range(shape[0]):'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
- en: start = (row * shape[1])
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: end = start + shape[1]
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: rows.append(np.concatenate(images[start:end], axis=1))
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
- en: mosaic = np.concatenate(rows, axis=0)
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
- en: self.data = mosaic
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
- en: return self
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: 'def adjust_values(self, img_range=None):'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
- en: '"""Create a visualization of the data in the input_image by projecting a range
    of values into a grayscale image.'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: ':param img_range: specified range of values'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: or None to use the range of the image
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
- en: (minimum and maximum).
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
- en: image = self.data
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: 'if img_range:'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
- en: min = img_range[0]
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
- en: max = img_range[1]
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
- en: min = image.min()
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
- en: max = image.max()
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
- en: interval = max - min
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
- en: factor = 256.0 / interval
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: output = image * factor
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
- en: self.data = output
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
- en: return self
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
- en: 'def crop_image(self, image_extent, bbox):'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
- en: '"""Crops an image by a bounding box.'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: 'bbox and image_extent format: (xmin, ymin, xmax, ymax).'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
- en: ':param input_image: Array containing the data'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
- en: or path to an image.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
- en: ':param image_extent: The geographic extent of the image.'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
- en: ':param output_image: The image path to write the output.'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
- en: ':param bbox: The bounding box of the region of interest.'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
- en: input_image = self.data
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
- en: img_shape = input_image.shape
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
- en: img_geo_width = abs(image_extent[2] - image_extent[0])
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
- en: img_geo_height = abs(image_extent[3] - image_extent[1])
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
- en: How much pixels are contained in one geographic unit.
  id: totrans-816
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pixel_width = img_shape[1] / img_geo_width
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
- en: pixel_height = img_shape[0] / img_geo_height
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
- en: Index of the pixel to cut.
  id: totrans-819
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: x_min = abs(bbox[0] - image_extent[0]) * pixel_width
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
- en: x_max = abs(bbox[2] - image_extent[0]) * pixel_width
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
- en: y_min = abs(bbox[1] - image_extent[1]) * pixel_height
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
- en: y_max = abs(bbox[3] - image_extent[1]) * pixel_height
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
- en: output = input_image[y_min:y_max, x_min:x_max]
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
- en: self.data = output
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
- en: return self
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
- en: 'def create_hillshade(self, azimuth=90, angle_altitude=60):'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
- en: '"""Creates a shaded relief image from a digital elevation model.'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
- en: ':param input_image: Array containing the data'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
- en: or path to an image.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: ':param azimuth: Simulated sun azimuth.'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
- en: ':param angle_altitude: Sun altitude angle.'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
- en: input_image = self.data
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
- en: x, y = np.gradient(input_image)
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
- en: slope = np.pi / 2 - np.arctan(np.sqrt(x * x + y * y))
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
- en: aspect = np.arctan2(-x, y)
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
- en: az_rad = azimuth * np.pi / 180
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
- en: alt_rad = angle_altitude * np.pi / 180
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
- en: a = np.sin(alt_rad) * np.sin(slope)
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
- en: b = np.cos(alt_rad) * np.cos(slope)\
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
- en: '* np.cos(az_rad - aspect)'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
- en: output = 255 * (a + b + 1) / 2
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
- en: self.data = output
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
- en: return self
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
- en: The class is complete and we can make a pipeline to test it.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
- en: '6\. Edit and organize the if __name__ == ''__main__'': block to test the image
    processing pipeline:'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
- en: elevation_data = [
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
- en: '''../../data/ASTGTM2_S22W048_dem.tif'','
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
- en: '''../../data/ASTGTM2_S22W047_dem.tif'','
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
- en: '''../../data/ASTGTM2_S23W048_dem.tif'','
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
- en: '''../../data/ASTGTM2_S23W047_dem.tif'']'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
- en: 'roi = (-46.8, -21.7, -46.3, -22.1) # Region of interest.'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
- en: 'iex = (-48, -21, -46, -23) # Image extent.'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
- en: RasterData(elevation_data, shape=(2, 2)).adjust_values().\
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
- en: crop_image(iex, roi).create_hillshade().\
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
- en: write_image('../output/pipeline_output.png')
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 52](img/index-308_1.jpg)'
  id: totrans-859
  prefs: []
  type: TYPE_IMG
- en: Due to the width limitation of the book, the pipeline is broken into three lines,
    but you can type it in a single line in PyCharm if you wish.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
- en: 7\. Run the code and admire the result.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you have a fantastic accomplishment. I’m not talking about the
    shaded relief image, I’m talking about the ability to consistently develop processing
    steps and combine them into a processing pipeline in order to achieve the final
    result. The structure that we developed here can be used to do almost anything
    in terms of geoprocessing.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that the image generated by the pipeline is of a much superior quality
    than the one created before. This happened because the data was in the memory
    the whole time.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
- en: This avoided data loss due to compression when the data was saved to a file
    multiple times.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
- en: 'A few remarks about the functionality of the structure as we implemented it
    are as follows: All the processing methods do two things in the end: they change
    the instance data and return the instance itself. The implication of this is that
    the class instance will mutate along the pipeline and the old data will be replaced
    by new ones as the process goes on. With this, Python’s garbage collector will
    eliminate old results from the memory and save space.'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
- en: If, at any step, you want to save the current state of processing, just insert
    a call to the write_image method (it will also return self and it can be piped).
    This is a powerful
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
- en: tool for debugging and also can save time when you only want to repeat the steps
    later in a long pipeline.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
- en: You can fork the pipeline. You can create a bifurcation where more than one
    result can be produced by following different paths. To do this, you can use the
    copy() function or you can write the result to the disk before the bifurcation.
    Later in the book we will see that, sometimes, while performing parallel processing,
    we will need these techniques too.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we understood how remote sensing images are represented inside
    the computer as arrays and how we can use this characteristic to process them.
    We saw that, in order to use images on a map, it is common that we need to transform
    them to achieve better results. Then, we wrote processing functions to process
    the digital elevation model images, ending with a beautiful shaded relief map.
    Finally, we created a RasterData class and transformed our functions into the
    methods of this class. With a few additional changes, we made it possible to chain
    these methods into a processing pipeline.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore the data in the images and obtain valuable
    information.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter 7\. Extract Information from**'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
- en: '**Raster Data**'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
- en: More than just a resource for visual information, raster data are samples of
    a given spatial attribute, whose values can be analyzed in order to produce valuable
    information.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
- en: Is this chapter, we will extract information from raster data with special emphasis
    on statistical information. Following the previous examples, we will use the digital
    elevation model to obtain values such as the maximum and minimum altitude of a
    given region, separate altitude ranges into classes, and produce histograms and
    other statistical information. Going beyond simple numerical values, we will display
    all the information on beautifully colored maps.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics covered by this chapter are:'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
- en: How to obtain statistics from raster data
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
- en: The use of programming techniques, such as lazy evaluation and memorization,
    to avoid unnecessary calculation
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
- en: How to format tabular data output
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
- en: How to colorize maps and choose suitable colors for them
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
- en: How to blend color maps in order to produce colorized and shaded maps
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the basic statistics**'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
- en: As we have previously seen, images or raster data are arrays containing numerical
    values representing a given real world space. So, they are by consequence statistical
    samples and they can be used in statistical analysis.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
- en: When we import the data, it is converted into NumPy arrays. These arrays are
    packed with methods for basic statistical calculations. In this topic, we are
    going to obtain the results from these calculations and save them in a file.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the previous chapter, we made an image processing pipeline by
    combining steps that can be saved on the disk. Here, we will follow the same pattern.
    The statistical computation will be added as another step. Maintaining the same
    kind of organization allows the user to generate statistics at any point on the
    processing pipeline. It will be possible to save statistics from all the substeps
    if needed.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by organizing our code:'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
- en: 1\. As we do at the beginning of every chapter, we will copy the code from the
    previous chapter. In your geopy project folder, copy the Chapter 6 folder ( *Ctrl*
    + *C*) and paste it ( *Ctrl* + *V*). Name the copied folder as Chapter7\.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
- en: In the last chapter, we finished the RasterData class inside the image_experiments.py
    file. Since our experiments are over, let’s move this class to a permanent and
    meaningful location.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Copy the file Chapter7/experiments/image_experiments.py ( *Ctrl* + *C*).
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Select the Chapter7 folder and paste the file there ( *Ctrl* + *V*).
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Rename the file to raster_data.py. To do this, right-click on the file and
    select **Refactor** | **Rename…** or select the file and press *Ctrl* + *F6*.
    The refactor dialog will appear. Change the name in the dialog and click on the
    **Refactor** button. There are two checkboxes in the dialog asking whether you
    want to search for this file’s references. If they are checked (on), PyCharm will
    search and automatically change these references, so the code will continue to
    work.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Remove the image_experiments.py file, as it won’t be of use anymore.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
- en: Now that our code is organized, we are going to analyze a few aspects and review
    some points in order to plan our next step.
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take an instance of your RasterData class that has a base working pattern,
    as it is now:'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
- en: At the instancing moment, you can pass the data or you can import the data later.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
- en: After this, the data will be stored as a NumPy array in the data property.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
- en: When you run any method in the class, the operation is performed and the data
    is transformed if it’s the case and the instance itself is returned along with
    the new data.
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
- en: No information is stored in the class, other than the data. And by consequence,
    some methods need to take manually defined parameters.
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
- en: The data property is a NumPy array, so it has all the NumPy array methods.
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
- en: '**Preparing the data**'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
- en: The sample data that we will be using is composed of four images containing
    elevation data. The processing pipeline combines these images, adjusts the values
    to display on a map, cuts the image, and then generates the shaded relief image.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
- en: This pipeline is good for visualization, but data is lost in the moment we adjust
    the values.
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
- en: 'For this work, we don’t want that to happen. We want the original values in
    meters. So, the first thing we need to do is build a pipeline adequate for our
    needs, and in the end, save the results, so we don’t need to repeat all the steps
    in the following tests: 1\. Open the raster_data.py file for editing, and at the
    end of it, add the if __name__'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
- en: '== ''__main__'': block with the following code:'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
- en: elevation_data = [
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
- en: '''../data/ASTGTM2_S22W048_dem.tif'','
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
- en: '''../data/ASTGTM2_S22W047_dem.tif'','
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
- en: '''../data/ASTGTM2_S23W048_dem.tif'','
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
- en: '''../data/ASTGTM2_S23W047_dem.tif'']'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
- en: 'roi = (-46.8, -21.7, -46.3, -22.1) # Region of interest.'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
- en: 'iex = (-48, -21, -46, -23) # Image extent.'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
- en: data = RasterData(elevation_data, shape=(2, 2))
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
- en: data.crop_image(iex, roi).write_image(
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
- en: '''output/dem.tif'')'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
- en: This is very similar to what we did before, but the pipeline was simplified
    to combining the images and cropping and writing the results in the dem.tif file.
    It was chosen as a TIFF file, so the information isn’t lost due to data compression.
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Run the code. Remember that because it’s a new file, you need to click
    on **Run** or press *Alt* + *Shift* + *F10* and choose raster_data. You should
    see an output telling you that everything went fine:'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
- en: From now on, we can use the prepared image in output/dem.tif for our tests.
    This is simply a matter of speeding up the process. What we are going to do could
    be done in any RasterData instance.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
- en: If, by any reason, you couldn’t generate dem.tif, copy the one provided with
    the sample data to your output folder.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
- en: '**Printing simple information**'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
- en: The first step for us to get some statistical output is to explore what NumPy
    has to offer.
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
- en: 'As we know, the data property of a RasterData instance is a NumPy array, so
    let’s see what we can get from it:'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
- en: 1\. First, check whether everything is working so far. Clean the if __name__
    ==
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
- en: '''__main__'': block and add this new code:'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
- en: raster_data = RasterData('output/dem.tif')
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
- en: print raster_data.data
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Run the code with *Shift* + *F10*. You should see this output:'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
- en: '[[ 933 935 942…, 1077 1076 1078]'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
- en: '[ 936 939 945…, 1075 1079 1076]'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
- en: '[ 935 939 946…, 1064 1072 1075]'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
- en: '...,'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
- en: '[ 780 781 781…, 1195 1193 1193]'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
- en: '[ 781 784 782…, 1191 1189 1188]'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
- en: '[ 781 784 785…, 1187 1185 1184]]'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
- en: This is the array containing the data in meters. NumPy automatically suppressed
    some rows and columns to make the output smaller. You see this output because
    a NumPy array has a __repr__ method that tells what is to be shown when the print
    function is called.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
- en: As we did before with the vector data, we will customize the __repr__ method
    of our class, so it outputs some information from the data in it.
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Edit the RasterData class and insert the __repr__ method right after the
    __init__
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
- en: 'method:'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
- en: 'class RasterData(object):'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, input_data, unchanged=True, shape=None):'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
- en: 'def __repr__(self):'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
- en: return "Hi, I'm a raster data!"
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Now, edit the if __name__ == ''__main__'': block and make it print the
    RasterData instance directly:'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
- en: raster_data = RasterData('output/dem.tif')
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
- en: print raster_data
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Run the code and see whether you get this output:'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
- en: Hi, I'm a raster data!
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
- en: OK, nothing fancy here. It’s just to remember that __repr__ takes no arguments
    except the instance (self) and should return only a string. Also, the method’s
    position in the class makes no difference. We are placing it after the __init__
    method for organization.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
- en: All the *magic* methods go together at the beginning of the class.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have everything set, let’s explore the NumPy array in the data property.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to avoid repetition, I’ll suppress the class’ declaration and the
    __init__ method in the code and replace it by #....'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Edit the __repr__ method to look as follows:'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-959
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def __repr__(self):'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.data is None:'
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
- en: return "No data to display!"
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
- en: data = self.data
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
- en: 'min = "Min: {}".format(data.min())'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
- en: 'mean = "Mean: {}".format(data.mean())'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
- en: 'max = "Max: {}".format(data.max())'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
- en: return "Hi, I'm a raster data!\n {} {} {}".format(
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
- en: min, mean, max)
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
- en: The first thing is to avoid an exception if the data is empty (None). In this
    case, the method prints a nice message telling that the instance has no data.
    If the instance has data, then it prepares three strings with the minimum, mean,
    and maximum values by calling the respective methods. In the end, a string is
    formatted to contain all the information.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Run the code with *Shift* + *F10*. You should see this output: Hi, I''m
    a raster data!'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
- en: 'Min: 671 Mean: 1139.06559874 Max: 1798'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
- en: That’s great! Now, we have some statistical information on our data.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
- en: But this code is clumsy and if we want to add or remove information returned
    from __repr__, we need to do a lot of editing. So, before we proceed on to obtaining
    more statistics, we will make a few changes and automate the process of formatting
    the information that we want to display.
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
- en: '**Formatting the output information**'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we are displaying three parameters in a simple string output.
    We want to improve this code, so we can easily add or remove parameters from the
    output.
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we modify the code, let’s think ahead and foresee that we may also need
    to output these statistics in other formats, for example:'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
- en: To a file on the disk in a human-friendly format
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
- en: To a file on the disk in a computer-friendly format, such as CSV or JSON
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
- en: As parameters to be passed to the other function or method
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
- en: 'So, a good way we can prepare the code to fulfill these requirements is to
    separate the statistic generation from the output as follows:'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
- en: '1\. First, separate the data verification from the __repr__ method. Create
    a new method to handle this task:'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-983
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def _check_data(self):'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
- en: '"""Check if has data and if it''s a Numpy array."""'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.data is None:'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
- en: raise ValueError("No data defined.")
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
- en: 'elif not isinstance(self.data, np.ndarray):'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
- en: raise TypeError("Wrong type of data.")
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
- en: The verification is more rigorous and it raises different types of exceptions
    for each possible failure. This makes the code mode useful and safe, because it
    allows error-handling to be done in the other functions and because it stops the
    program’s execution if the exception is not properly caught.
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Now, create a new method to calculate and collect the statistics that we
    have so far:'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-992
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def _calculate_stats(self):'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
- en: '"""Calculate and return basic statistical information from the data.'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
- en: self._check_data()
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
- en: data = self.data
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
- en: stats = {
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
- en: '"Minimum": data.min(),'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
- en: '"Mean": data.mean(),'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
- en: '"Maximum": data.max()}'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
- en: return stats
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the statistics are stored in a dictionary for two reasons: it allows
    the items to have readable names (including accents and spaces if you wish) and
    it avoids name collisions.'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it lets us prepare a human-readable output with the statistics calculated.
    For this, we will use the tabulate module.
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Insert this import at the beginning of the file:'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  id: totrans-1006
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import cv2
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
- en: import numpy as np
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
- en: from tabulate import tabulate
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Add this new method:'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-1011
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def _format_stats(self, stats, out_format=''human''):'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
- en: '"""Format the statistical data in a given output format.'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
- en: ':param out_format: ''human'' or ''csv'''
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
- en: table = []
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
- en: 'for key, value in stats.iteritems():'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
- en: table.append([key, value])
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
- en: return tabulate(table)
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
- en: The tabulate function takes a list of lists representing a table. It then prepares
    a string containing a well-formatted table with this data.
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Finally, edit the __repr__ method:'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-1022
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def __repr__(self):'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
- en: stats = self._calculate_stats()
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
- en: stats = self._format_stats(stats)
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
- en: 'return "Raster data - basic statistics.\n {}".format(stats) 6\. Now, run the
    code again with *Shift* + *F10*. You should see this output: Raster data - basic
    statistics.'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
- en: '------- -------'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
- en: Minimum 671
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
- en: Maximum 1798
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
- en: Mean 1139.07
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
- en: '------- -------'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
- en: The presentation is much better now. If we want to add or remove elements, we
    just need to edit the dictionary in the _calculate_stats method.
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
- en: '**Calculating quartiles, histograms, and other** **statistics**'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the minimum, maximum, and mean values for our data. In our case, it
    is the minimum, maximum, and mean elevation of the given region. In the next few
    steps, we will obtain more information from our data:'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Edit the _calculate_stats method, adding more items to the dictionary:'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-1037
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def _calculate_stats(self):'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
- en: '"""Calculate and return basic statistical information from the data.'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
- en: self._check_data()
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
- en: data = self.data
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
- en: stats = {
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
- en: '"Minimum": data.min(),'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
- en: '"Mean": data.mean(),'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
- en: '"Maximum": data.max(),'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
- en: '"Q1": np.percentile(data, 25),'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
- en: '"Median": np.median(data),'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
- en: '"Q3": np.percentile(data, 75),'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
- en: '"Variance": data.var(),'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
- en: '"Histogram": np.histogram(data)'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
- en: return stats
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
- en: You can add any value to the dictionary. Maybe, you can obtain it from a NumPy
    function or method or from a function developed by you.
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information on NumPy statistics in
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.scipy.org/doc/numpy/reference/routines.statistics.html](http://docs.scipy.org/doc/numpy/reference/routines.statistics.html)
    and'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.scipy.org/doc/numpy/reference/arrays.ndarray.html#array-methods](http://docs.scipy.org/doc/numpy/reference/arrays.ndarray.html#array-methods).'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Run the code with *Shift* + *F10*. You should get more values as the output:
    Raster data - basic statistics.'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
- en: '---------'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
- en: Q1 992.0
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
- en: Q3 1303.0
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
- en: Minimum 671
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
- en: Variance 37075.0925323
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
- en: Histogram (array([ 83917, 254729, ..., 44225, 8279, 2068]), array([ 671\. ,
    783.7, ..., 1685.3, 1798.]))
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
- en: Median 1140.0
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
- en: Maximum 1798
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
- en: Mean 1139.06559874
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
- en: '--------- ---------------'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
- en: 'Note in the output that the histogram is composed of two arrays: one containing
    the number of occurrences and the other containing the top limit for each bin.
    Since we are dealing with geographic data, it would be better if this information
    came translated into the amount of area for each interval.'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we just need to multiply the number of currencies (the number of
    pixels within a given range) by the area represented by each pixel. We will get
    to this after we prepare a few things in the next topics.
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
- en: '**Making statistics a lazy property**'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
- en: Our statistics is working fine and we will make an improvement now. Instead
    of calculating the statistics that we need all the time, we will calculate it
    only once and only when it’s needed for the first time.
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use two very useful programming techniques: **lazy evaluation** and
    **memoization**.'
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
- en: Lazy evaluation is when a process or calculation is delayed and only performed
    when needed. Memoization is when the results of an expensive process are stored
    for later use to avoid them being recalculated every time we may need them.
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how it works:'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Add a new _stats property to the __init__ method:'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
- en: 'class RasterData(object):'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, input_data, unchanged=True, shape=None):'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
- en: '"""Represents a raster data in the form of an array.'
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
- en: ':param input_data: Raster files or Numpy array.'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
- en: ':param unchanged: True to keep the original format.'
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
- en: ':param shape: When using multiple input data, this param'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
- en: determines the shape of the composition.
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
- en: self.data = None
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
- en: self._stats = None
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
- en: if isinstance(input_data, list) \
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
- en: 'or isinstance(input_data, tuple):'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
- en: self.combine_images(input_data, shape)
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
- en: self.import_data(input_data, unchanged)
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
- en: The property name starts with an underscore. Remember that this notation shows
    that the property should only be accessed from the instance itself. This property
    will work as a cache to store the statistics.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Now add a property method that will return the statistics:'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
- en: '#...'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
- en: '@property'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
- en: 'def stats(self):'
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
- en: 'if self._stats is None:'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
- en: self._stats = self._calculate_stats()
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
- en: return self._stats
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
- en: When this property is accessed, it verifies that if _stats is None. If so, it
    calculates the statistics and stores the results into _stats. The next time we
    need it, it only returns what’s stored.
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
- en: Making a property lazy and adding memoization to it is important when the process
    to obtain this information is costly. The processing power and time is used only
    once when the given property is needed.
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Now, change the __repr__ method to use this new functionality:'
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-1105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def __repr__(self):'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
- en: stats = self._format_stats(self.stats)
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
- en: return "Raster data basic statistics.\n {}".format(stats)
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating color classified images**'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to display image information on a map, we must prepare a visual
    output of what we got. A common and efficient form of visual representation is
    to separate values into classes and give each class a different color. In our
    case, we can split the data into altitude classes. NumPy makes it easy for us.
    Let’s write a method that can be called in the pipeline to get started:'
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Add a new method to the RasterData class:'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
- en: '#...'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
- en: 'def colorize(self, style):'
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
- en: '"""Produces an BGR image based on a style containing limits and colors.'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
- en: ':param style: A list of limits and colors.'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
- en: shape = self.data.shape
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
- en: limits = []
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
- en: colors = []
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
- en: Separate the limits and colors.
  id: totrans-1120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for item in style:'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
- en: limits.append(item[0])
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
- en: colors.append(self._convert_color(item[1]))
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
- en: colors = np.array(colors)
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
- en: Put each color in its limits.
  id: totrans-1125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: flat_array = self.data.flatten()
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
- en: di_array = np.digitize(flat_array, limits)
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
- en: di_array = di_array.reshape((shape[0], shape[1], 1))
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
- en: results = np.choose(di_array, colors)
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
- en: Convert from RGB to BGR.
  id: totrans-1130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: results = np.asarray(results, dtype=np.uint8)
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
- en: results = cv2.cvtColor(results, cv2.COLOR_RGB2BGR)
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
- en: self.data = results
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
- en: return self
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
- en: In order to achieve what we want, two important things happen here. First, the
    data is indexed into classes by NumPy’s digitize function. Then, each class receives
    an RGB value with the defined color. This is done using the choose function.
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
- en: 'This method takes a style as an argument. This style is a list of limits and
    colors, like a map legend. For example, the style can be defined as: style = [[700,
    "#f6eff7"],'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
- en: '[900, "#bdc9e1"],'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
- en: '[1100, "#67a9cf"],'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
- en: '[1300, "#1c9099"],'
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
- en: '[1800, "#016c59"]]'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
- en: This means that all the values below 700 will have the color "#f6eff7" and so
    on. The colors are expressed in hex notations. This notation is popular with web
    applications and is chosen here because it’s short and easy to type or copy.
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, note that inside this method, we called the _convert_color method
    that will perform the conversion of the color notation. Let’s add this method
    to the class: 1\. Add the _convert_color method to the class:'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
- en: '#...'
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
- en: 'def _convert_color(self, color_code):'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
- en: '"""Converts the color notation.'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
- en: ':param color_code: A string containing the color in hex'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
- en: or JavaScript notation.
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
- en: 'if color_code[0] == "#":'
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
- en: result = (int(color_code[1:3], 16),
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
- en: int(color_code[3:5], 16),
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
- en: int(color_code[5:7], 16))
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
- en: 'elif color_code[:3] == "rgb":'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
- en: result = map(int, color_code[4:-1].split(','))
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
- en: raise ValueError("Invalid color code.")
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
- en: return result
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Finally, edit the if __name__ == ''__main__'': block to test our code:
    if __name__ == ''__main__'':'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
- en: raster_data = RasterData('output/dem.tif')
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
- en: style = [[700, "#f6eff7"],
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
- en: '[900, "#bdc9e1"],'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
- en: '[1100, "#67a9cf"],'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
- en: '[1300, "#1c9099"],'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
- en: '[1800, "#016c59"]]'
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
- en: raster_data.colorize(style).write_image(
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
- en: '''output/classified.png'')'
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Run the code and then open the output image to see the results:'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 53](img/index-328_1.jpg)'
  id: totrans-1168
  prefs: []
  type: TYPE_IMG
- en: '![Image 54](img/index-329_1.jpg)'
  id: totrans-1169
  prefs: []
  type: TYPE_IMG
- en: '**Choosing the right colors for a map**'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
- en: 'The choice of what colors to use in a map is one determining factor as to whether
    the map would be capable of correctly passing the desired information. In order
    to choose a good set of colors, some factors should be considered:'
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
- en: The ability of the human eye to distinguish hues—the classes need to be visually
    distinguishable, otherwise the map may contain colors that may look the same to
    some people
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
- en: The media that the map will be presented on (for example, paper or screen)—
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
- en: depending on the media, the colors may suffer small changes that may compromise
    the readability of the map
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
- en: Colorblind safety—this is an inclusion measure and it allows the information
    to be interpreted by a wider audience
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
- en: The type of data (for example, sequential or qualitative)—use colors that match
    what you want to show
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of studies on this subject and the ones made by Cynthia Brewer
    are very practical and popular among modern map makers. She produced an extensive
    set of colors to be used in maps and made this information available for use under
    the name of ColorBrewer.
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change the colors of our map with the help of ColorBrewer: 1\. Access
    the [http://colorbrewer2.org/](http://colorbrewer2.org/) website. You should see
    this interface:'
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 55](img/index-330_1.jpg)'
  id: totrans-1179
  prefs: []
  type: TYPE_IMG
- en: 2\. The left-hand side panel allows you to set the parameters to choose the
    color. At the top, change **Number of data classes** to **5** as in our data.
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
- en: 3\. About the nature of our data, two options would go well, sequential or diverging.
    I will choose diverging for this example.
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Before choosing a color scheme, if you wish, you can filter the schemes
    by **colorblind safe**, **print friendly** and **photocopy safe**.
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Now, pick a color scheme that pleases you and note that the bottom right
    section of the panel and the map will change to show the colors of this scheme.
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
- en: '6\. Let’s export this scheme in a practical way to it use in our code. Click
    on the **EXPORT** tab just to the right of the colors. A new panel will open as
    follows: 7\. Note that the **JavaScript** box contains a list of RGB values. We
    can easily parse this information in our code. So, we will select its contents
    and copy it.'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
- en: '8\. Go back to our code and paste the colors to a variable named colorbrewer
    in the if __name__ == ''__main__'': block:'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
- en: colorbrewer = ['rgb(202,0,32)','rgb(244,165,130)',
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
- en: '''rgb(247,247,247)'',''rgb(146,197,222)'','
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
- en: '''rgb(5,113,176)'']'
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
- en: raster_data = RasterData('data/dem.tif')
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
- en: style = [[700, "#f6eff7"],
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
- en: '[900, "#bdc9e1"],'
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
- en: '[1100, "#67a9cf"],'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
- en: '[1300, "#1c9099"],'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
- en: '[1800, "#016c59"]]'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
- en: raster_data.colorize(style).write_image(
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
- en: '''output/classified.png'')'
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, the style is not yet complete. There are two problems: the colors
    are in a format different from what we need and we don’t have the limits associated
    with them. Since we want the process to be as practical as possible, we will write
    the code to solve these two issues instead of manually converting the colors and
    associating them with the limits.'
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s implement the capability of our program to accept colors and limits
    separately.
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
- en: '9\. Put the limits that were in the style definition into a different list:
    if __name__ == ''__main__'':'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
- en: colorbrewer = ['rgb(202,0,32)','rgb(244,165,130)',
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
- en: '''rgb(247,247,247)'',''rgb(146,197,222)'','
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
- en: '''rgb(5,113,176)'']'
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
- en: limits = [700, 900, 1100, 1300, 1800]
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
- en: raster_data = RasterData('data/dem.tif')
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
- en: 'raster_data.colorize(style).write_image(''output/classified.png'') 10\. Now
    edit the colorize method:'
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
- en: '#..'
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
- en: 'def colorize(self, limits, raw_colors):'
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
- en: '"""Produces an BGR image based on a style containing limits and colors.'
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
- en: ':param limits: A list of limits.'
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
- en: ':param raw_colors: A list of color codes. """'
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
- en: shape = self.data.shape
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
- en: colors = []
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
- en: 'for item in raw_colors:'
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
- en: colors.append(self._convert_color(item))
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
- en: colors = np.array(colors)
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
- en: Put each color in its limits.
  id: totrans-1217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: flat_array = self.data.flatten()
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
- en: di_array = np.digitize(flat_array, limits, right=True)
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
- en: di_array = di_array.reshape((shape[0], shape[1], 1))
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
- en: results = np.choose(di_array, colors)
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
- en: Convert from RGB to BGR.
  id: totrans-1222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: results = np.asarray(results, dtype=np.uint8)
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
- en: results = cv2.cvtColor(results, cv2.COLOR_RGB2BGR)
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
- en: self.data = results
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
- en: return self
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
- en: This method now takes two arguments instead of just the style. The only task
    that remains is to convert this new color format.
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
- en: '11\. Edit the _convert_color method:'
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
- en: '#...'
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
- en: 'def _convert_color(self, color_code):'
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
- en: '"""Converts the color notation.'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
- en: ':param color_code: A string containing the color in hex'
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
- en: or JavaScript notation.
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
- en: 'if color_code[0] == "#": result = (int(color_code[1:3], 16),'
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
- en: int(color_code[3:5], 16),
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
- en: int(color_code[5:7], 16))
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
- en: 'elif color_code[:3] == "rgb":'
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
- en: result = map(int, color_code[4:-1].split(','))
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
- en: raise ValueError("Invalid color code.")
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
- en: return result
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
- en: This method is now able to detect and convert the two color codes that we use.
    It can also raise an exception in case the color code is not recognized.
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
- en: '12\. To test the code, edit the if __name__ == ''__main__'': block to be compliant
    with the new format:'
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
- en: raster_data = RasterData('output/dem.tif')
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
- en: colors = ['rgb(202,0,32)', 'rgb(244,165,130)',
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
- en: '''rgb(247,247,247)'', ''rgb(146,197,222)'','
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
- en: '''rgb(5,113,176)'']'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
- en: limits = [700, 900, 1100, 1300, 1800]
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
- en: raster_data.colorize(limits, colors).write_image(
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
- en: '''output/classified.png'')'
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
- en: '13\. Finally, run the code with *Shift* + *F10* and check the output. The schema
    I chose produced the following result:'
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 56](img/index-333_1.jpg)'
  id: totrans-1254
  prefs: []
  type: TYPE_IMG
- en: Despite the fact that this is a beautiful image, there is a mistake in the choice
    of colors. The warm colors are representing lower altitudes. This could lead to
    confusions, since on most maps, the rule is warmer the color, higher is the value.
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
- en: It’s only a mater of inverting the colors. Let’s add an option to our colorize
    method to do this.
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
- en: '14\. Edit the colorize method:'
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
- en: '#...'
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
- en: 'def colorize(self, limits, raw_colors, invert_colors=False):'
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
- en: '"""Produces an BGR image based on a style containing limits and colors.'
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
- en: ':param limits: A list of limits.'
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
- en: ':param raw_colors: A list of color codes.'
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
- en: ':param invert_colors: Invert the order of the colors.'
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
- en: shape = self.data.shape
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
- en: colors = []
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
- en: 'if invert_colors:'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
- en: raw_colors = list(reversed(raw_colors))
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
- en: Convert the colors.
  id: totrans-1269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![Image 57](img/index-334_1.jpg)'
  id: totrans-1270
  prefs: []
  type: TYPE_IMG
- en: 'for item in raw_colors:'
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
- en: colors.append(self._convert_color(item))
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
- en: colors = np.array(colors)
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
- en: Put each color in its limits.
  id: totrans-1274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: flat_array = self.data.flatten()
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
- en: di_array = np.digitize(flat_array, limits, right=True)
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
- en: di_array = di_array.reshape((shape[0], shape[1], 1))
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
- en: results = np.choose(di_array, colors)
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
- en: Convert from RGB to BGR.
  id: totrans-1279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: results = np.asarray(results, dtype=np.uint8)
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
- en: results = cv2.cvtColor(results, cv2.COLOR_RGB2BGR)
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
- en: self.data = results
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
- en: return self
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
- en: '15\. Now, edit the if __name__ == ''__main__'': block again:'
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
- en: raster_data = RasterData('output/dem.tif')
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
- en: colors = ['rgb(202,0,32)', 'rgb(244,165,130)',
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
- en: '''rgb(247,247,247)'', ''rgb(146,197,222)'','
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
- en: '''rgb(5,113,176)'']'
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
- en: limits = [700, 900, 1100, 1300, 1800]
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
- en: raster_data.colorize(limits, colors, True).write_image(
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
- en: '''output/classified.png'')'
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
- en: '16\. Run the code and look at the new output:'
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
- en: '**Blending images**'
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
- en: We can make our results even more visually appealing and informative if we can
    combine the colorized image with the shaded relief image. Again, since we are
    dealing with arrays, we may deduce that this kind of composition can be achieved
    by performing an arithmetic operation between the two arrays.
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
- en: 'In image processing, this is called **alpha blending**. Basically, a *transparency*
    is applied to both of the images and then they are blended into a new one. In
    the next steps, we are going to create a function that performs this operation:'
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
- en: '1\. First, to avoid generating the shaded relief multiple times, let’s save
    it on the disk and edit the if __name__ == ''__main__'': block of the raster_data.py
    file: if __name__ == ''__main__'':'
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
- en: raster_data = RasterData('output/dem.tif')
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
- en: raster_data.adjust_values().create_hillshade(
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
- en: 10, 60).write_image('output/shaded.png')
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Run the code and check whether the image was correctly written on the disk.
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Now, add the alpha_blend method to the RasterData class:'
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
- en: '#...'
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
- en: 'def alpha_blend(self, raster_data, alpha=0.5):'
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
- en: '"""Blend this raster data with another one.'
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
- en: ':param raster_data: RasterData instance.'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
- en: ':param alpha: Amount of transparency to apply.'
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
- en: shade = cv2.cvtColor(raster_data.data, cv2.COLOR_GRAY2BGR)
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
- en: result = (1-alpha) * self.data + alpha * shade
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
- en: self.data = result
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
- en: return self
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Finally, edit the if __name__ == ''__main__'': block again to test the
    code: if __name__ == ''__main__'':'
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
- en: shaded = RasterData('output/shaded.png')
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
- en: classified = RasterData('output/classified.png')
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
- en: classified.alpha_blend(shaded).write_image(
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
- en: '''output/color_shade.png'')'
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Run the code and check the image in the output folder:'
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 58](img/index-338_1.jpg)'
  id: totrans-1319
  prefs: []
  type: TYPE_IMG
- en: You should see this beautiful output. Note how the combination of the shaded
    relief with the colorized image produces a map that transmits a lot of information
    even for untrained eyes.
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 59](img/index-340_1.jpg)'
  id: totrans-1321
  prefs: []
  type: TYPE_IMG
- en: '**Showing statistics with colors**'
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
- en: How the map is colorized is only a matter of defining the limits and colors
    in the style. So, if we want to translate statistical information into colors,
    we just need to associate the values that we want with a sequence of colors.
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s try it with the quartiles:'
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Since everything is prepared in our class, we just need to change the code
    in the if __name__ == ''__main__'': block:'
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
- en: dem = RasterData('output/dem.tif')
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
- en: shaded = RasterData('output/shaded.png')
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
- en: limits = [dem.stats['Q1'],
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
- en: dem.stats['Q3'],
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
- en: dem.stats['Maximum']]
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
- en: colors = ["#fc8d59", "#ffffbf", "#91cf60"]
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
- en: 'dem.colorize(limits, colors).write_image(''output/stats.png'') dem.alpha_blend(shaded).write_image(''output/shaded_stats.png'')
    The following image illustrates the colored output for the analyzed parameters:'
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 60](img/index-341_1.jpg)'
  id: totrans-1334
  prefs: []
  type: TYPE_IMG
- en: 'For this image you can start the lead-in this way:'
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
- en: '**Using the histogram to colorize the image** We can also use the histogram
    to colorize the maps. The histogram generated by NumPy is composed of two one-dimensional
    arrays. The first contains the number of occurrences in a given interval (that
    is, the number of pixels). The second one contains the *bins* or the limits. By
    default, the histogram is produced with 11 bins, so we also need 11 different
    colors to produce a map. Let’s change our tests to see how this works: 1\. Edit
    the if __name__ == ''__main__'': block:'
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
- en: dem = RasterData('data/dem.tif')
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
- en: shaded = RasterData('output/shaded.png')
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
- en: colors = ['rgb(103,0,31)','rgb(178,24,43)','rgb(214,96,77)',
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
- en: '''rgb(244,165,130)'',''rgb(253,219,199)'','
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
- en: '''rgb(247,247,247)'',''rgb(209,229,240)'','
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
- en: '''rgb(146,197,222)'',''rgb(67,147,195)'','
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
- en: '''rgb(33,102,172)'',''rgb(5,48,97)'']'
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
- en: limits = dem.stats['Histogram'][1]
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
- en: dem.colorize(limits, colors, True).write_image('output/hist.png') dem.alpha_blend(shaded).write_image('output/shaded_hist.png')
    The colors here are also obtained from ColorBrewer. They are of a diverging nature
    from red to blue. The limits were taken from the histogram by simply using the
    stats property and the second array, which contains the bins.
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Run the code and look at the output.
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 61](img/index-343_1.jpg)'
  id: totrans-1348
  prefs: []
  type: TYPE_IMG
- en: 'And the shaded result should look as the following image:'
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 62](img/index-344_1.jpg)'
  id: totrans-1350
  prefs: []
  type: TYPE_IMG
- en: Using more classes resulted in a better representation of the altitude variation
    and it allowed us to clearly see the peaks with high altitudes.
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we took raw raster data, and with a series of techniques, we
    were able to extract statistical information from it and display it on high quality
    maps. These procedures took us to a high level of communication in terms of geospatial
    information because the material produced is easy to interpret, even for untrained
    eyes.
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will enter a new field and start taking care of the
    efficiency of our code in order to process massive geospatial datasets in a timely
    manner.
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter 8\. Data Miner App**'
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
- en: New challenges appear, to the extent that data size increases. Large sets of
    data bring problems related to excessive processing time and great memory consumption.
    These problems may turn data analysis into a painful process or may even make
    it completely impossible.
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will create an application capable of processing huge datasets
    in an efficient way. We will review our code, implementing new tools and techniques
    that will make our analysis not only run faster, but also make better use of computer
    hardware, allowing virtually any amount of data to be processed.
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
- en: In order to achieve those goals, we will learn how to use databases and how
    to stream the data into them, making the use of computing power constant and stable
    regardless of the amount of data.
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
- en: These tools will also enable us to perform more advanced searches, calculations,
    and cross information from different sources, allowing you to mine the data for
    precious information.
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
- en: What code efficiency is and how to measure it
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
- en: How to import data into a spatial database
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
- en: How to abstract database data into Python objects
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
- en: Making queries and getting information from a spatial database Understanding
    code efficiency
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
- en: 'What constitutes efficient code depends on the points that are being analyzed.
    When we talk about computational efficiency, there are four points that may be
    taken into consideration:'
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
- en: The time the code takes to execute
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
- en: How much memory it uses to run
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
- en: How much disk space it uses
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
- en: Whether the code uses all the available computing power
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
- en: 'Good and efficient code is not only about computational efficiency; it’s also
    about writing code that brings these favorable qualities to the development process
    (to cite just a few of them):'
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
- en: Clean and organized code
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
- en: Readable code
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
- en: Easy to maintain and debug
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
- en: Generalized
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
- en: Shielded against misuse
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
- en: It’s obvious that some points are contradictory. Here are just a few examples.
    To speed up a process, you may need to use more memory. To use less memory, you
    may need more disk space. Alternatively, for faster code, you may need to give
    up on generalization and
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
- en: write very specific functions.
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
- en: It is the developer who determines the balance between antagonistic characteristics,
    based on the software requirements and the gains obtained by investing in one
    point or another.
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
- en: For example, if much cleaner code can be written with very little penalty in
    terms of execution time, the developer may opt for clean and maintainable code
    that will be easier for him and his team to understand.
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
- en: The second block of good characteristics is prone to human evaluation, whereas
    the items in the first block can be measured and compared by the computer.
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
- en: '**Measuring execution time**'
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to measure how fast a piece of code is executed, we need to measure
    its execution time. The time measured is relative and varies, depending on a number
    of factors: the operating system, whether there are other programs running, the
    hardware, and so on.'
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
- en: For our efficiency tests, we will measure the execution time, make changes in
    the code, and measure it again. In this way, we will see if the changes improve
    the code efficiency or not.
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with a simple example and measure how long it takes to run.
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
- en: '1\. As before, make a copy of the previous chapter folder in your geopy project
    and rename it as Chapter8\. Your project structure should look like this:'
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
- en: ├───Chapter1
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
- en: ├───Chapter2
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
- en: ├───Chapter3
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
- en: ├───Chapter4
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
- en: ├───Chapter5
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
- en: ├───Chapter6
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
- en: ├───Chapter7
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
- en: ├───Chapter8
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
- en: │ ├───experiments
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
- en: │ ├───map_maker
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
- en: │ ├───output
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
- en: │ └───utils
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
- en: └───data
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Click on your experiments folder and create a new Python file inside it.
    Name that file timing.py.
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Now add the following code to that file:'
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  id: totrans-1401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def make_list1(items_list):'
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
- en: result = ""
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
- en: 'for item in items_list:'
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
- en: template = "I like {}. \n"
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
- en: text = template.format(item)
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
- en: result = result + text
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
- en: return result
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
- en: my_list = ['bacon', 'lasagna', 'salad', 'eggs', 'apples']
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
- en: print(make_list1(my_list))
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Run the code. Press *Alt* + *Shift* + *F10* and select a timing from the
    list. You should get this output:'
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
- en: I like bacon.
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
- en: I like lasagna.
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
- en: I like salad.
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
- en: I like eggs.
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
- en: I like apples.
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
- en: Nothing fancy, it’s a simple inefficient function to format texts and produce
    a printable list of things.
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Now we are going to measure how long it takes to execute. Modify your code:'
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  id: totrans-1420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from timeit import timeit
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
- en: 'def make_list1(items_list):'
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
- en: result = ""
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
- en: 'for item in items_list:'
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
- en: template = "I like {}. \n"
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
- en: text = template.format(item)
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
- en: result = result + text
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
- en: return result
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
- en: my_list = ['bacon', 'lasagna', 'salad', 'eggs', 'apples']
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
- en: number = 100
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
- en: execution_time = timeit('make_list1(my_list)',
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
- en: setup='from __main__ import make_list1, my_list',
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
- en: number=number)
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
- en: print("It took {}s to execute the code {} times".format(
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
- en: execution_time, number))
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
- en: '6\. Run your code again with *Shift* + *F10* and look at the results: It took
    0.000379365835017s to execute the code 100 times'
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
- en: Here we are using the timeit module to measure the execution time of our function.
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
- en: Since some pieces of code run vary fast, we need to repeat the execution many
    times to get a more precise measurement and a more meaningful number. The number
    of times that the statement is repeated is given by the number parameter.
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
- en: '7\. Increase your number parameter to 1000000 and run the code again: It took
    3.66938576408s to execute the code 1000000 times'
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
- en: Now we have a more consistent number to work with. If your computer is much
    faster than mine you can increase the number. If it’s slower, decrease it.
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
- en: Grab a piece of paper and take note of that result. We are going to change the
    function and see if we make the code more efficient.
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
- en: '8\. Add another version of our function; name it make_list2: def make_list2(items_list):'
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
- en: result = ""
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
- en: template = "I like {}. \n"
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
- en: 'for item in items_list:'
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
- en: text = template.format(item)
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
- en: result = result + text
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
- en: return result
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
- en: '9\. Also change your if __name__ == ''__main__'': block. We will make it clear
    which version of the function we are executing:'
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
- en: my_list = ['bacon', 'lasagna', 'salad', 'eggs', 'apples']
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
- en: number = 1000000
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
- en: function_version = 2
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
- en: statement = 'make_list{}(my_list)'.format(function_version) setup = 'from __main__
    import make_list{}, my_list'.format(
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
- en: function_version)
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
- en: execution_time = timeit(statement, setup=setup, number=number) print("Version
    {}.".format(function_version))
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
- en: print("It took {}s to execute the code {} times".format(
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
- en: execution_time, number))
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
- en: '10\. Run the code again and see your results. On my computer, I got this: Version
    2\.'
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
- en: It took 3.5384931206s to execute the code 1000000 times
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
- en: That was a slight improvement in execution time. The only change that was made
    in version 2 was that we moved the template out of the for loop.
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
- en: '11\. Make a third version of the function:'
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
- en: 'def make_list3(items_list):'
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
- en: result = ""
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
- en: template = "I like "
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
- en: 'for item in items_list:'
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
- en: text = template + item + ". \n"
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
- en: result = result + text
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
- en: return result
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
- en: '12\. Change your function_version variable to 3 and run the code again: Version
    3\.'
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
- en: It took 1.88675713574s to execute the code 1000000 times
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
- en: Now we changed how the string "I like " is formed. Instead of using string formatting,
    we added parts of the string and got code that ran almost twice as fast as the
    previous version.
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
- en: You can find out which small changes will reduce the execution time by trial
    and error, by consulting articles on the Internet, or by experience. But there
    is a more assertive and powerful way to find out where your code spends more time;
    this is called **profiling**.
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
- en: '**Code profiling**'
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
- en: By trial, we found that the most expensive part of our code was the string formatting.
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
- en: When your code gets more complex, finding bottlenecks by this method gets harder
    and at some point becomes impractical.
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
- en: The solution is to break and analyze small pieces of code. To see how long they
    take to execute, make a profile of the code.
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
- en: Python comes with a good profiling tool that automates this process to a certain
    level.
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use it on our code to see what it tells us:'
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Add this import at the beginning of the file:'
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
- en: from timeit import timeit
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
- en: '**import cProfile**'
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Edit your if __name__ == ''__main__'': block to use the profiler: if __name__
    == ''__main__'':'
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
- en: my_list = ['bacon', 'lasagna', 'salad', 'eggs', 'apples']
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
- en: number = 1000000
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
- en: profile = cProfile.Profile()
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
- en: profile.enable()
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(number):'
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
- en: make_list1(my_list)
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
- en: profile.disable()
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
- en: profile.print_stats(sort='cumulative')
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Run the code. You should see the profiler statistics on the console. (I
    suppressed some information for reasons of space):'
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
- en: 6000002 function calls in 4.755 seconds
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
- en: 'Ordered by: cumulative time'
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
- en: ncalls tottime percall cumtime percall
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
- en: 1000000 2.718 0.000 4.738 0.000 timing.py
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
- en: 5000000 2.019 0.000 2.019 0.000 {'format' ...}
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
- en: 1 0.017 0.017 0.017 0.017 {range}
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
- en: 1 0.000 0.000 0.000 0.000 {'disable' ...}
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to execute the profiler. In our case, we instantiated the
    Profile class and used the enable and disable methods to tell the profiler where
    to start and stop collecting data. Again, the call to make_list1 was repeated
    1000000 times to generate bigger numbers.
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
- en: In the output, we can see that make_list1 was called 1000000 times and the format
    method was called five million times, taking 2.019 seconds. Note that the profiler
    only gave information regarding methods and functions.
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
- en: '**Storing information on a database**'
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapters, the basic workflow was to import all the data into
    memory as Python objects every time we ran the code. That’s perfectly fine and
    efficient when we work with small pieces of data.
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
- en: At some point, you may have noticed that the performance of our code was debilitated,
    especially when we started importing country boundaries along with all the attributes.
    This happened because importing attributes is slow.
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, although our filtering mechanisms worked pretty well, we may have
    problems when dealing with huge datasets.
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
- en: 'The formula to solve these problems is very simple and consists of only two
    basic ingredients:'
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
- en: Get only what you need
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
- en: Use indexed searches
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
- en: The first point is about getting only the records you need, as well as getting
    only the attributes that are desired for a given analysis.
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
- en: The second point is about how things are found. In our method, a loop tests
    every record for a condition until the desired one is found (that is, the test
    returns True). Alternatively, if the computer somehow had an idea of where the
    item was, the search would be much faster; this is indexing.
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
- en: Instead of trying to implement these features by ourselves, we can use a database
    to handle these mechanisms for us; they are state-of-the-art for this kind of
    job.
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we have two options:'
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
- en: Use a **SQLite** database with the **Spatialite** extension, which is an open
    source, simple, and very efficient SQL database. It doesn’t require a server or
    installation, and Python comes bundled with a connector to it.
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
- en: Use a **PostgreSQL** database with the **Postgis** extension. Also open source
    and powerful, this is a full-featured database server.
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
- en: The choice is up to you and will have no influence on the code except for a
    small change in the settings.
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
- en: 'PostgreSQL can be download from: [http://www.postgresql.org/.](http://www.postgresql.org/)
    In order to enable Postgis, you just need to select it in the stack builder during
    the installation.'
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using Ubuntu, you can find more details at:'
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
- en: '[https://wiki.ubuntu.com/UbuntuGIS.](https://wiki.ubuntu.com/UbuntuGIS)'
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating an Object Relational Mapping**'
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
- en: '**Object Relational Mapping** (**ORM**) is a method that we will use to convert
    the data stored in a database into Python objects. This no different from what
    we did before in our models.py file, where we made code that transformed data
    stored in geographic files (for example, a GPX shapefile) into Python objects.'
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
- en: This time, we will close the circle by importing the data into the database,
    and then later retrieve data or information from it in the same elegant and intuitive
    manner as before.
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL databases, such as SQLite, store the data in tables with row and columns.
    The following table illustrates how the geocaching data that we previously used
    would be represented in this format:'
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
- en: '**ID Geom Name**'
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
- en: '**Status**'
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
- en: '**Owner Hints**'
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
- en: (wkb) LaSalle Park Available John
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
- en: Under sign
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
- en: (wkb) Parking
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
- en: Available Nina
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
- en: Big tree
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
- en: We can guess that this is incompatible with the premise of being able to import
    any type of data, because the type of column is fixed. If we have data with different
    attributes or more attributes, we need different tables or to add more columns
    to match every possibility.
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
- en: To overcome the limitation of this schema, we will use the relational capabilities
    of SQL
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
- en: 'databases. We will store items and attributes in different tables and relate
    them: **Points**'
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
- en: '**ID Geom**'
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
- en: 42.89 - 78.90
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
- en: 43.00 - 78.0
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
- en: '**Attributes**'
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
- en: '**ID Key**'
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
- en: '**Value**'
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
- en: '**point_id**'
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
- en: name LaSalle Park 1
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
- en: status Available
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
- en: owner John
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
- en: hints
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
- en: under sign
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
- en: name Parking
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
- en: status Available
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
- en: owner Nina
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
- en: hints
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
- en: big tree
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
- en: This key/value data model allows each point (or other objects) to have arbitrary
    numbers and types of attributes. Each attribute is attached to its owner by an
    ID.
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
- en: You may have heard of Django, *batteries-included* Python web framework. It
    happens that Django has a fantastic ORM included in it, and it has very developed
    support for geospatial databases and geospatial operations (this part of Django
    is called **GeoDjango** and is included by default). You will also notice that
    the transition from our models to Django will be smooth and they will remain easy
    to use, as before.
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
- en: '**Preparing the environment**'
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
- en: In order to use Django’s ORM we need to setup a Django project. To do that we
    will prepare the minimum required structure, which consists of a few files and
    settings.
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s set up our application to use Django.
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Inside your Chapter8 folder, create a new Python file named settings.py.
    If you are using PostgreSQL/Postgis, add the following code to the file: DATABASES
    = {'
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
- en: '''default'': {'
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
- en: '''ENGINE'': ''django.contrib.gis.db.backends.postgis'','
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
- en: '''NAME'': ''postgres'','
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
- en: '''USER'': ''postgres'','
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
- en: '''PASSWORD'': ''mypassword'','
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
- en: '''PORT'': 5432'
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
- en: '}}'
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
- en: The first item (DATABASES) is the database settings. If you have a default PostgreSQL/Postgis
    installation, this will work. Just change your password for the one you set during
    the installation.
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
- en: '2\. If you are using SQLite/Spatialite, use this configuration: DATABASES =
    {'
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
- en: '''default'': {'
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
- en: '''ENGINE'': ''django.contrib.gis.db.backends.spatialite'','
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
- en: '''NAME'': ''mydatabase.db'''
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
- en: '}}'
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
- en: '3\. After the database configuration, add these items:'
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
- en: INSTALLED_APPS = ('django.contrib.gis', 'geodata')
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
- en: SECRET_KEY = 'abc'
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
- en: The INSTALLED_APPS item tells Django where to look for models. SECRET_KEY is
    used for Django’s user management. Although we won’t use it, this needs to be
    set (you can use any value as the secret key).
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Now create a Python package that will be our Django app. Right-click the
    Chapter8
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
- en: folder and select **New** | **Python Package**. Name it geodata.
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Create a new Python file inside Chapter8 and name it geodata_app.py.
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
- en: '**Changing our models**'
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
- en: We have the basic structure ready, now we need to adapt our models so they can
    use the database instead of storing all the information in memory. Django’s model
    definition is very similar to ours.
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the new capabilities provided by Django, we will make one change in the
    choice of design: instead of one class for each type of object (geocaching, roads,
    boundaries, and so on) we will have only one class that can store data for all
    of them and any others that we can think of.'
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Create a file models.py inside the geodata folder and add this code:'
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  id: totrans-1606
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from django.contrib.gis.db import models
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
- en: 'class GeoObject(models.Model):'
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
- en: geom = models.GeometryField()
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
- en: atype = models.CharField(max_length=20)
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
- en: objects = models.GeoManager()
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
- en: The GeoObject class represents a single object (a single row in a table). It
    can accept any kind of geometry (a point, polygon, and so on) in the geom field.
    The atype property represents the high-level type of the object. This property
    will tell us if it’s a geocaching point or something else (we are using atype
    and not type to avoid conflicts with the internal type() function).
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the objects property represents the collection of GeoObject (the table
    in the database). In Django this is called a **manager**; don’t worry, we will
    see more about this later.
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Now we need the tags for our GeoObject; the tags will contain every attribute.
    Add another class after the GeoObject class.
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
- en: 'class Tag(models.Model):'
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
- en: key = models.CharField(max_length=250)
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
- en: value = models.CharField(max_length=250)
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
- en: geo_object = models.ForeignKey(GeoObject, related_name='tags') Again, this class
    represents a single object, a single tag with a key and a value that is connected
    with a GeoObject by a foreign key. The result is that a Tag class has a GeoObject
    and a GeoObject has many tags.
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
- en: '**Customizing a manager**'
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
- en: As said before, a manager can be considered as something that represents a table
    in a database. It contains methods to retrieve records, add, delete, and many
    other operations.
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
- en: Django comes with the GeoManager class that is used for tables that contain
    spatial objects. If we want to add more functionalities to our GeoData manager,
    we just need to inherit from GeoManager and then add a class property with an
    instance of it in the GeoObject class. Actually, we will just replace the instance
    in the objects property.
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s adapt our BaseGeoCollection class to be a manager for the GeoObject class:
    1\. Navigate to your Chapter8/models.py file (the one that we wrote in previous
    chapters) and rename it to Chapter8/old_models.py. With this, we avoid confusion
    about which model we are talking about.'
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Create a file named managers.py inside the geodata folder. Add this code
    to the file:'
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  id: totrans-1624
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from django.contrib.gis.db.models import GeoManager
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
- en: from utils.geo_functions import open_vector_file
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
- en: 'class GeoCollection(GeoManager):'
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
- en: '"""This class represents a collection of spatial data."""'
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
- en: Pass
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the first step in migrating our BaseGeoCollection class. Note that
    we named it GeoCollection because it won’t be a base class anymore. We will simplify
    our code so this class will manage all types of geo objects. To do that, we will
    add the import_data method from the BaseGeoCollection class and combine it with
    the _parse_data method from the PointCollection class. Before we continue, let’s
    take a look at these methods as they are (you don’t need to type this code):'
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
- en: '#...'
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
- en: 'def import_data(self, file_path):'
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
- en: '"""Opens an vector file compatible with OGR and parses the data.'
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
- en: ':param str file_path: The full path to the file.'
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
- en: features, metadata = open_vector_file(file_path)
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
- en: self._parse_data(features)
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
- en: self.epsg = metadata['epsg']
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
- en: 'print("File imported: {}".format(file_path))'
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
- en: '#...'
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
- en: 'def _parse_data(self, features):'
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
- en: '"""Transforms the data into Geocache objects.'
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
- en: ':param features: A list of features.'
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
- en: 'for feature in features:'
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
- en: coords = feature['geometry']['coordinates']
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
- en: point = Point(float(coords[1]), float(coords[0]))
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
- en: attributes = feature['properties']
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
- en: cache_point = Geocache(point, attributes=attributes)
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
- en: self.data.append(cache_point)
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
- en: Note that import_data opens the vector file and then sends the features to _parse_data,
    which iterates over the data, creating points and putting the feature properties
    into a dictionary. If we manage to import any kind of geometry and pass the feature
    properties to the tag model, we end with a piece of code that will serve any kind
    of geospatial object.
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Edit the code in geodata/managers.py again. Whether you want to copy and
    edit the mentioned methods or type the new import_data method from scratch is
    up to you.
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting code should be the following:'
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  id: totrans-1654
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from django.contrib.gis.db.models import GeoManager
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
- en: from django.db import IntegrityError, DataError
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
- en: from utils.geo_functions import open_vector_file
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
- en: from shapely.geometry import shape
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
- en: 'class GeoCollection(GeoManager):'
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
- en: '"""This class represents a collection of spatial data."""'
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
- en: 'def import_data(self, file_path, atype):'
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
- en: '"""Opens an vector file compatible with OGR and parses the data.'
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
- en: ':param str file_path: The full path to the file.'
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
- en: features = open_vector_file(file_path)
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
- en: 'for feature in features:'
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
- en: geom = shape(feature['geometry'])
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
- en: geo_object = self.model(geom=geom.wkt, atype=atype)
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
- en: geo_object.save()
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
- en: 'for key, value in feature[''properties''].iteritems():'
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
- en: geo_object.tags.create(key=key, value=value)
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
- en: 'except (IntegrityError, DataError):'
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
- en: pass
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
- en: 'print("File imported: {}".format(file_path))'
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
- en: We used Shapley’s shape function to directly convert feature['geometry'], which
    is a GeoJSON geometry-like dictionary, into a shapely geometry of the correct
    type.
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
- en: Then we used that geometry to get a WKT representation of it.
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
- en: The atype argument was included on the method, so we can use it to define the
    type of the GeoObject. Remember that atype is not a type of geometry; it represents
    the high-level type of the object (geocaching, boundary, road, river, waypoint,
    and so on).
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
- en: 'In the statement geo_object = self.model(geom=geom.wkt, atype=atype), we see
    a great feature of Django managers: the same manager can be used by many models,
    and self.model contains a reference to the class that this manager was called
    from.'
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
- en: If we had decided on another design pattern and used one class for each object
    type, we would still be able to use the same manager for all of them.
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
- en: 'In the sequence, the model is saved and then the properties dictionary is iterated
    and for every item a tag is created. We are catching exceptions here because we
    have two special conditions that may happen: if the value of a property is None
    it will raise an IntegrityError; if the length of the value is larger than 250,
    it will raise a DataError. If you are interested in long fields, such as the logs
    from the geocaching data, you can increase the field max_length or try a different
    field type.'
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
- en: '4\. We are not using the metadata here, and reading it can cause an incompatibility
    error between libraries for Windows users. So we will remove it from the open_vector_file
    function. Edit your utils/geo_functions.py file to change this function. As a
    plus, let’s print the number of features read: def open_vector_file(file_path):'
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
- en: '"""Opens an vector file compatible with OGR or a GPX file.'
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
- en: Returns a list of features and informations about the file.
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
- en: ':param str file_path: The full path to the file.'
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
- en: datasource = ogr.Open(file_path)
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
- en: Check if the file was opened.
  id: totrans-1688
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if not datasource:'
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
- en: 'if not os.path.isfile(file_path):'
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
- en: message = "Wrong path."
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
- en: message = "File format is invalid."
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
- en: raise IOError('Error opening the file {}\n{}'.format(
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
- en: file_path, message))
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
- en: file_name, file_extension = os.path.splitext(file_path)
  id: totrans-1696
  prefs: []
  type: TYPE_NORMAL
- en: Check if it's a GPX and read it if so.
  id: totrans-1697
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if file_extension in [''.gpx'', ''.GPX'']:'
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
- en: features = read_gpx_file(file_path)
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
- en: If not, use OGR to get the features.
  id: totrans-1700
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
- en: features = read_ogr_features(datasource.GetLayerByIndex(0)) print("{} features.".format(len(features)))
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
- en: return features
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Finally, edit geodata/models.py to import and use the new manager:'
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  id: totrans-1705
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from django.contrib.gis.db import models
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
- en: from managers import GeoCollection
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
- en: 'class GeoObject(models.Model):'
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
- en: geom = models.GeometryField()
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
- en: atype = models.CharField(max_length=20)
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
- en: objects = GeoCollection()
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
- en: 'class Tag(models.Model):'
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
- en: key = models.CharField(max_length=250)
  id: totrans-1713
  prefs: []
  type: TYPE_NORMAL
- en: value = models.CharField(max_length=250)
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
- en: 'geo_object = models.ForeignKey(GeoObject, related_name=''tags'') We are almost
    ready to begin testing. At this point, your Chapter 8 structure should be like
    this:'
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
- en: +---Chapter8
  id: totrans-1716
  prefs: []
  type: TYPE_NORMAL
- en: '| geocaching_app.py'
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
- en: '| geodata_app.py'
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
- en: '| map_maker_app.py'
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
- en: '| models_old.py'
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
- en: '| raster_data.py'
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
- en: '| settings.py'
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
- en: '| settings.pyc'
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
- en: '| __init__.py'
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
- en: +---experiments
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
- en: +---geodata
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
- en: '| | managers.py'
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
- en: '| | models.py'
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
- en: '| | __init__.py'
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
- en: +---map_maker
  id: totrans-1733
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
- en: +---output
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
- en: \---utils
  id: totrans-1737
  prefs: []
  type: TYPE_NORMAL
- en: check_plugins.py
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
- en: data_transfer.py
  id: totrans-1739
  prefs: []
  type: TYPE_NORMAL
- en: geo_functions.py
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
- en: '**Generating the tables and importing data** Now it’s time to make Django generate
    the database tables for us. Since our models are defined, we just need to call
    a pair of commands and Django will perform its magic.'
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Go back to the geodata_app.py file and add some content to it:'
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  id: totrans-1743
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import os
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
- en: import django
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
- en: os.environ.setdefault("DJANGO_SETTINGS_MODULE", "settings") django.setup()
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
- en: from django.core.management import call_command
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
- en: from geodata.models import *
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
- en: 'def prepare_database():'
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
- en: '"""Call this to setup the database or any time you change your models.'
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
- en: call_command('makemigrations', 'geodata')
  id: totrans-1752
  prefs: []
  type: TYPE_NORMAL
- en: call_command('migrate', 'geodata')
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
- en: prepare_database()
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
- en: After we import os and django we need to specify which settings file it should
    look for. After that, django.setup() initializes Django.
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
- en: The prepare_database function calls two Django management commands responsible
    for database creation. We will need to call it every time we change our models.
    Internally, Django keeps a record of the changes made and automatically generates
    SQL queries that perform the modifications on the database.
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Run your code now. If everything goes fine, you should see the database
    migration results in the output:'
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
- en: 'Migrations for ''geodata'':'
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
- en: '0001_initial.py:'
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
- en: '- Create model GeoObject'
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
- en: '- Create model Tag'
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
- en: 'Operations to perform:'
  id: totrans-1763
  prefs: []
  type: TYPE_NORMAL
- en: 'Apply all migrations: geodata'
  id: totrans-1764
  prefs: []
  type: TYPE_NORMAL
- en: 'Running migrations:'
  id: totrans-1765
  prefs: []
  type: TYPE_NORMAL
- en: Rendering model states… DONE
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
- en: Applying geodata.0001_initial… OK
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Now, edit geodata_app.py again to add a convenience function to import some
    data.
  id: totrans-1769
  prefs: []
  type: TYPE_NORMAL
- en: 'We will begin with the geocaching data as a test:'
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  id: totrans-1771
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import os
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
- en: import django
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
- en: os.environ.setdefault("DJANGO_SETTINGS_MODULE", "settings") django.setup()
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
- en: from django.core.management import call_command
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
- en: from geodata.models import *
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
- en: 'def prepare_database():'
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
- en: '"""Call this to setup the database or any time you change your models.'
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
- en: call_command('makemigrations', 'geodata')
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
- en: call_command('migrate', 'geodata')
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
- en: 'def import_initial_data(input_file, atype):'
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
- en: '"""Import new data into the database."""'
  id: totrans-1783
  prefs: []
  type: TYPE_NORMAL
- en: print("Importing {}...".format(atype))
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
- en: GeoObject.objects.import_data(input_file, atype)
  id: totrans-1785
  prefs: []
  type: TYPE_NORMAL
- en: print("Done!")
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-1787
  prefs: []
  type: TYPE_NORMAL
- en: prepare_database()
  id: totrans-1788
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import_initial_data("../data/geocaching.gpx", 'geocaching') This new function
    is only a convenience function to reduce typing since we will import a lot of
    data very soon. We are commenting the prepare_database() statement because we
    will use it later.
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Run your code (make sure you run it only once to avoid duplicated entries).
    In your output you should see this:'
  id: totrans-1790
  prefs: []
  type: TYPE_NORMAL
- en: Importing geocaching…
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
- en: 112 features.
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
- en: Done!
  id: totrans-1793
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
- en: '**Filtering the data**'
  id: totrans-1795
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have some data in the database, it’s time to test it and see if
    we can filter some points as we did before.
  id: totrans-1796
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Edit your if __name__ == ''__main__'': block (remember to comment the previous
    commands):'
  id: totrans-1797
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
- en: prepare_database()
  id: totrans-1799
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import_initial_data("../data/geocaching.gpx", 'geocaching') points = GeoObject.objects.filter(atype='geocaching',
  id: totrans-1800
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从'../data/geocaching.gpx'导入初始数据('geocaching') points = GeoObject.objects.filter(atype='geocaching',
- en: tags__key='status',
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
  zh: tags__key='状态',
- en: tags__value='Available')
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
  zh: tags__value='可用')
- en: print(len(points))
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
  zh: 打印(points的长度)
- en: 'for tag in points[0].tags.all():'
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
  zh: 对于points[0].tags.all()中的每个tag：
- en: print(tag.key, tag.value)
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
  zh: 打印(tag.key, tag.value)
- en: Here we are using the filter method inherited by our manager to filter the records
    of geocaching type. Plus we are accessing the related tags to filter only the
    available geocaches. This is done by using a double underscore after the property
    name. In the end, we print all the tags for the first of the points returned.
  id: totrans-1806
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用我们的管理器继承的过滤方法来过滤地理藏宝类型的相关记录。此外，我们通过在属性名后使用双下划线来访问相关的标签，以过滤仅可用的地理藏宝。这是通过打印返回的第一个点的所有标签来完成的。
- en: '2\. Run your code and you should see a list of tags like this: 224'
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 运行你的代码，你应该会看到一个类似这样的标签列表：224
- en: (u'type', u'Other')
  id: totrans-1808
  prefs: []
  type: TYPE_NORMAL
  zh: (u'类型', u'其他')
- en: (u'hints', u'under sign')
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
  zh: (u'提示', u'在签名下')
- en: (u'time', u'2013-09-29T00:00:00Z')
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
  zh: (u'时间', u'2013-09-29T00:00:00Z')
- en: (u'state', u'New York')
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
  zh: (u'州', u'纽约')
- en: (u'country', u'United States')
  id: totrans-1812
  prefs: []
  type: TYPE_NORMAL
  zh: (u'国家', u'美国')
- en: (u'url', u'http://www.opencaching.us/viewcache.php?cacheid=1728') (u'name',
    u'LaSalle Park No 1')
  id: totrans-1813
  prefs: []
  type: TYPE_NORMAL
  zh: (u'URL', u'http://www.opencaching.us/viewcache.php?cacheid=1728') (u'名称', u'LaSalle
    Park No 1')
- en: (u'container', u'Virtual')
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
  zh: (u'容器', u'虚拟')
- en: (u'src', u'www.opencaching.us')
  id: totrans-1815
  prefs: []
  type: TYPE_NORMAL
  zh: (u'来源', u'www.opencaching.us')
