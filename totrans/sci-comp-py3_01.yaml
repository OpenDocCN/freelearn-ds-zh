- en: Chapter 1. Getting Started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will give a brief overview of the principal syntactical
    elements of Python. Readers who have just started learning programming are guided
    through the book in this chapter. Every topic is presented here in a *how-to*
    way and will be explained later in the book in a deeper conceptual manner and
    will also be enriched with many applications and extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Readers who are already familiar with another programming language will come
    across, in this chapter, the Python way of doing classical language constructs.
    It offers them a quick start to Python programming.
  prefs: []
  type: TYPE_NORMAL
- en: Both types of readers are encouraged to take this chapter as a brief guideline
    when zigzagging through the book. However, before we start we have to make sure
    that everything is in place and you have the correct version of Python installed
    together with the main modules for Scientific Computing and tools, such as a good
    editor and a shell, which helps in code developing and testing.
  prefs: []
  type: TYPE_NORMAL
- en: Read the following section, even if you already have access to a computer with
    Python installed. You might want to adjust things to have a working environment
    conforming to the presentation in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Installation and configuration instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before diving into the subject of the book you should have all the relevant
    tools installed on your computer. We will give you some advice and recommend tools
    that you might want to use. We only describe public domain and free tools.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are currently two major versions of Python; the *2.x* branch and the new
    *3.x* branch. There are language incompatibilities between these branches and
    one has to be aware of which one to use. This book is based on the *3.x* branch,
    considering the language up to release *3.5*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this book you need to install the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The interpreter: Python *3.5* (or later)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The modules for scientific computing: SciPy with NumPy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The module for graphical representation of mathematical results: matplotlib'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The shell: IPython'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A Python related editor: Spyder (refer to the following *Figure 1.1*, *Spyder*),
    Geany'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The installation of these is eased by the so-called distribution packages.
    We recommend that you use Anaconda. The default screen of Spyder consists of an
    editor window on left, a console window in the lower right corner which gives
    access to an IPython shell and a help window in the upper right corner as shown
    in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installation](img/spyder.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1: The default screen of Spyder consists of an editor window on left,
    a console window in the lower right corner which gives access to an IPython shell
    and a help window in the upper right corner.'
  prefs: []
  type: TYPE_NORMAL
- en: Anaconda
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even if you have Python pre-installed on your computer, we recommend that you
    create your personal Python environment that allows you to work without the risk
    of accidentally affecting the software on which your computer's functionality
    might depend. With a virtual environment, such as Anaconda, you are free to change
    language versions and install packages without the unintended side-effects.
  prefs: []
  type: TYPE_NORMAL
- en: If the worst happens and you screw things up totally, just delete the Anaconda
    directory and start again. Running the Anaconda installer will install Python,
    a Python development environment and editor (Spyder), the shell IPython, and the
    most important packages for numerical computations, for example SciPy, NumPy,
    and matplotlib.
  prefs: []
  type: TYPE_NORMAL
- en: You can install additional packages with `conda install` within your virtual
    environment created by Anaconda (refer for official documentation from[[2]](apa.html
    "Appendix . References")).
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most Python codes will be collected in files. We recommend that you use the
    following header in all your Python files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With this, you make sure that all standard modules and functions used in this
    book, such as SciPy, are imported. Without this step, most of the examples in
    the book would raise errors. Many editors, such as Spyder, provide the possibility
    to create a template for your files. Look for this feature and put the preceding header
    into a template.
  prefs: []
  type: TYPE_NORMAL
- en: Python Shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Python shell is good but not optimal for interactive scripting. We therefore
    recommend using IPython instead (refer to [[26]](apa.html "Appendix . References")
    for the official documentation). IPython can be started in different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: In a terminal shell by running the following command:`ipython`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By directly clicking on an icon called Jupyter QT Console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Python Shell](img/jupyter.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When working with Spyder you should use an IPython console (refer to *Figure
    1.1*, *Spyder*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You often want to execute the contents of a file. Depending on the location
    of the file on your computer, it is necessary to navigate to the correct location
    before executing the contents of a file.
  prefs: []
  type: TYPE_NORMAL
- en: Use the command `cd` in IPython in order to move to the directory where your
    file is located.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To execute the contents of a file named `myfile.py`, just run the following
    command in the IPython shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Getting Help
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some tips on how to use IPython:'
  prefs: []
  type: TYPE_NORMAL
- en: To get help on an object, just type `?` after the object's name and then `return`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the arrow keys to reuse the last executed commands.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may use the *Tab* key for completion (that is, you write the first letter
    of a variable or method and IPython shows you a menu with all the possible completions).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use *Ctrl+D* to quit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use IPython's magic functions. You can find a list and explanations by applying 
    `%magic`  on the command prompt.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find out more about IPython in its online documentation, [[15]](apa.html
    "Appendix . References")*.*
  prefs: []
  type: TYPE_NORMAL
- en: Jupyter – Python notebook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Jupyter notebook is a fantastic tool for demonstrating your work. Students
    might want to use it to make and document homework and exercises and teachers
    can prepare lectures with it, even slides and web pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have installed Python via Anaconda, you already have everything for
    Jupyter in place. You can invoke the notebook by running the following command
    in the terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: A browser window will open and you can interact with Python through your web
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: Program and program flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A program is a sequence of statements that are executed in a top-down order.
    This linear execution order has some important exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: There might be a conditional execution of alternative groups of statements (blocks),
    which we refer to as branching.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are blocks that are executed repetitively, which is called looping (refer
    to the following *Figure 1.2*, *Program flow*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are function calls that are references to another piece of code, which
    is executed before the main program flow is resumed. A function call breaks the
    linear execution and pauses the execution of a program unit while it passes the
    control to another unit-a function. When this gets completed, its control is returned
    to the calling unit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Program and program flow](img/Program_Flow.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.2: Program flow'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python uses a special syntax to mark blocks of statements: a keyword, a colon,
    and an indented sequence of statements, which belong to the block (refer to the
    following *Figure 1.3*,  *Block command*).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Program and program flow](img/Example_of_a_block_command.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.3: Block command'
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If a line in a program contains the symbol `#`, everything following on the
    same line is considered as a comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Line joining
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A backslash `\` at the end of the line marks the next line as a continuation
    line, that is, explicit line joining. If the line ends before all the parentheses
    are closed, the following line will automatically be recognized as a continuation
    line, that is, implicit line joining.
  prefs: []
  type: TYPE_NORMAL
- en: Basic types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's go over the basic data types that you will encounter in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A number may be an integer, a real number, or a complex number. The usual operations
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: addition and subtraction, `+` and `-`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: multiplication and division, `*` and `/`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: power, `**`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**The symbol for complex numbers**'
  prefs: []
  type: TYPE_NORMAL
- en: '`j`  is a symbol to denote the imaginary part of a complex number. It is a
    syntactic element and should not be confused with multiplication by a variable.
    More on complex numbers can be found in section *Numeric Types* of [Chapter 2](ch02.html
    "Chapter 2. Variables and Basic Types"), *Variables and Basic Types*.'
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Strings are sequences of characters, enclosed by simple or double quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use triple quotes for strings that have multiple lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A variable is a reference to an object. An object may have several references.
    One uses the assignment operator `=` to assign a value to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of a variable can be displayed by the `print` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Lists are a very useful construction and one of the basic types in Python.
    A Python list is an ordered list of objects enclosed by square brackets. One can
    access the elements of a list using zero-based indexes inside square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Indexing of the elements starts at zero. One can put objects of any type inside
    a list, even other lists. Some basic list functions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`list(range(n))}` creates a list with `n` elements, starting with zero:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`len` gives the length of a list:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`append` is used to append an element to a list:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Operations on lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The operator `+` concatenates two lists:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As one might expect, multiplying a list with an integer concatenates the list
    with itself several times:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`n*L` is equivalent to making *n* additions.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Boolean expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A Boolean expression is an expression that may have the value `True` or `False`.
    Some common operators that yield conditional expressions are as follow:'
  prefs: []
  type: TYPE_NORMAL
- en: Equal, `==`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not equal, `!=`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Less than, Less than or equal to, `<` , `<=`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Greater than, Greater than or equal to, `>` , `>=`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One combines different Boolean values with `or` and `and`. The keyword `not`
    , gives the logical negation of the expression that follows. Comparisons can be
    chained so that, for example, `x < y < z` is equivalent to `x < y and y < z`.
    The difference is that `y` is only evaluated once in the first example. In both
    cases, `z` is not evaluated at all when the first condition, `x < y`, evaluates
    to `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Precedence rules**'
  prefs: []
  type: TYPE_NORMAL
- en: The `<`, `>`, `<=`, `>=`, `!=`, and `==` operators have higher precedence than
    `not.`  The operators `and`, `or` have the lowest precedence. Operators with higher
    precedence rules are evaluated before those with lower.
  prefs: []
  type: TYPE_NORMAL
- en: Repeating statements with loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Loops are used to repetitively execute a sequence of statements while changing
    a variable from iteration to iteration. This variable is called the index variable.
    It is successively assigned to the elements of a list, (refer to [Chapter 9](ch09.html
    "Chapter 9. Iterating"), *Iterating)* :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The part to be repeated in the `for` loop has to be properly indented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Repeating a task
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One typical use of a `for` loop is to repeat a certain task a fixed number
    of times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Break and else
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `for` statement has two important keywords: `break` and `else`. `break`
    quits the `for` loop even if the list we are iterating is not exhausted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The finalizing `else` checks whether the `for` loop was `broken` with the `break`
    keyword. If it was not broken, the block following the `else` keyword is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Conditional statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section covers how to use conditions for branching, breaking, or otherwise
    controlling your code. A conditional statement delimits a block that will be executed
    if the condition is true. An optional block, started with the keyword `else` 
    will be executed if the condition is not fulfilled (refer to *Figure 1.3*, *Block
    command* diagram). We demonstrate this by printing `|x|`, the absolute value of
    *x*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Conditional statements](img/B05511_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The Python equivalent is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Any object can be tested for the truth value, for use in an `if` or `while`
    statement. The rules for how the truth values are obtained are explained in section
    Boolean of [Chapter 2](ch02.html "Chapter 2. Variables and Basic Types"), *Variables
    and Basic Types*.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulating code with functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functions are useful for gathering similar pieces of code in one place. Consider
    the following mathematical function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Encapsulating code with functions](img/B05511_01_03-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The Python equivalent is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In Figure 1.4 *Anatomy of a function* the  elements of a function block are
    explained.
  prefs: []
  type: TYPE_NORMAL
- en: The keyword `def`   tells Python we are defining a function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`f` is the name of the function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x` is the argument, or input of the function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is after `return` is called the output of the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Encapsulating code with functions](img/Anatomy_of_a_function.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.4: Anatomy of a function'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the function is defined, it can be called using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Scripts and modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A collection of statements in a file (which usually has a `py` extension),
    is called a script. Suppose we put the contents of the following code into a file
    named `smartscript.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In a Python or IPython shell, such a script can then be executed with the `exec`
    command after opening and reading the file. Written as a one-liner it reads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The IPython shell provides the magic command `%run` as a handy alternative
    way to execute a script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Simple modules - collecting functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Often one collects functions in a script. This creates a module with additional
    Python functionality. To demonstrate this, we create a module by collecting functions
    in a single file, for example `smartfunctions.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: These functions can now be used by any external script or directly in the IPython
    environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions within the module can depend on each other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grouping functions with a common theme or purpose gives modules that can be
    shared and used by others.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Again, the command `exec(open('smartfunctions.py').read())` makes these functions
    available to your IPython shell (note that there is also the IPython magic function
    `run`). In Python terminology, one says that they are put into the actual namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Using modules and namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Alternatively, the modules  can be imported by the command `import`. It creates
    a named namespace*.* The command `from` puts the functions into the general namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Import**'
  prefs: []
  type: TYPE_NORMAL
- en: The commands `import` and `from`  import the functions only once into the respective
    namespace. Changing the functions after the import has no effect for the current
    Python session. More on modules can be found in section *Modules* of [Chapter
    11](ch11.html "Chapter 11. Namespaces, Scopes, and Modules"), *Namespaces, Scopes
    and Modules.*
  prefs: []
  type: TYPE_NORMAL
- en: Interpreter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Python interpreter executes the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, run the syntax.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then execute the code line by line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code inside a function or class declaration is *not* executed (but checked for
    syntax).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You can run the preceding program because there are no syntactical errors. You
    get an error only when you call the function `f`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we briefly addressed the main language elements of Python without
    going into detail. You should now be able to start playing with small pieces of
    code and to test different program constructs. All this is intended as an appetizer
    for the following chapters in which we will give you the details, examples, exercises,
    and more background information.
  prefs: []
  type: TYPE_NORMAL
