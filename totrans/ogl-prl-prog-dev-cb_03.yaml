- en: Chapter 3. Understanding OpenCL Data Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 理解OpenCL数据类型
- en: 'In this chapter, we are going to cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Initializing the OpenCL scalar data types
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化OpenCL标量数据类型
- en: Initializing the OpenCL vector data types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化OpenCL向量数据类型
- en: Using OpenCL scalar types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OpenCL标量类型
- en: Understanding OpenCL vector types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解OpenCL向量类型
- en: Vector and scalar address spaces
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量和标量地址空间
- en: Configuring your OpenCL projects to enable the double data type
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置你的OpenCL项目以启用双精度数据类型
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: OpenCL supports a wide range of data types derived from the C programming language.
    They are widely classified into two groups called scalars and vectors. Scalars
    are basically elemental values, whereas vectors are a collection of elemental
    values and a good thing about vectors is that many OpenCL SDK vendors have provided
    automated vectorization which allows the values to be loaded into wide, that is,
    128-bit, 256-bit, or 512-bit registers for consumption.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCL支持从C编程语言派生出的广泛的数据类型。它们被广泛分为两组，称为标量和向量。标量基本上是基本值，而向量是一组基本值，向量好的一点是许多OpenCL
    SDK供应商已经提供了自动化向量化，这使得值可以被加载到宽的，即128位、256位或512位寄存器中进行消费。
- en: OpenCL scalar integral data types consists of the signed and unsigned types
    of `bool`, `char`, `short`, `int`, `long`, `uchar`, `ushort`, `uint`, and `ulong`
    respectively; for floating-point values there are `float`, `half`, and `double`.
    To represent those types in your host program, you have to just prepend the letters
    `cl_` to each type, which the OpenCL compiler will understand.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCL标量整型数据类型包括`bool`、`char`、`short`、`int`、`long`、`uchar`、`ushort`、`uint`和`ulong`的符号和无符号类型；对于浮点值，有`float`、`half`和`double`。要在你的主机程序中表示这些类型，你只需在每个类型前加上字母`cl_`，OpenCL编译器就会理解。
- en: OpenCL vector data types consists of a multiple of scalar data integral and
    floating-point data types and they are `char<N>`, `short<N>`, `int<N>`, `long<N>`,
    `uchar<N>`, `ushort<N>`, `uint<N>`, `ulong<N>`, and `float<N>` where `<N>` represents
    a value of 2, 3, 4, 8, or 16\. Similarly, you will represent those types in your
    host program by prepending the letters `cl_` to the data types.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCL向量数据类型由多个标量整型和浮点数据类型组成，它们是`char<N>`、`short<N>`、`int<N>`、`long<N>`、`uchar<N>`、`ushort<N>`、`uint<N>`、`ulong<N>`和`float<N>`，其中`<N>`代表2、3、4、8或16的值。同样，你将在主机程序中通过在每个数据类型前加上字母`cl_`来表示这些类型。
- en: In both the cases, if you prefer the explicit form of an `unsigned` type, then
    you can replace the letter `u` in the data types with the keyword `unsigned`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，如果你更喜欢无符号类型的显式形式，那么你可以将数据类型中的字母`u`替换为关键字`unsigned`。
- en: Initializing the OpenCL scalar data types
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化OpenCL标量数据类型
- en: In this recipe, we are going to demonstrate various ways to initialize scalar
    types, and most of the techniques will make a lot of sense if you already have
    programmed using the C programming language.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将演示初始化标量类型的各种方法，如果你已经使用C编程语言进行编程，那么大多数技术都会非常有意义。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In addition to the regular data types defined in C which works in OpenCL, the
    standard have added a few more data types in addition to the ones we have mentioned
    in the previous section, and the following table illustrates them:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在OpenCL中定义的常规数据类型外，标准还添加了一些我们在上一节中提到之外的数据类型，以下表格展示了它们：
- en: '| Type | Description |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `half` | It is a 16-bit floating-point. The `half` data type must conform
    to the IEEE 754-2008 `half precision` storage format. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `half` | 它是一个16位浮点数。`half`数据类型必须符合IEEE 754-2008 `half精度`存储格式。 |'
- en: '| `bool` | It is a conditional data type that evaluates to true or false. The
    value true expands to an integer 1 while false expands to 0. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `bool` | 它是一个条件数据类型，其值评估为真或假。true扩展为整数1，而false扩展为0。 |'
- en: '| `size_t` | It is the unsigned integer type of the result of the sizeof operator.
    This can be a 32-bit or 64-bit unsigned integer. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `size_t` | 它是sizeof运算符的结果的无符号整型。这可以是一个32位或64位无符号整型。 |'
- en: '| `ptrdiff_t` | It is a 32-bit or 64-bit signed integer and usually it is used
    to represent the result of subtracting two points |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `ptrdiff_t` | 它是一个32位或64位有符号整数，通常用于表示两个点相减的结果 |'
- en: '| `intptr_t` | It is a 32-bit or 64-bit signed integer with the property that
    any valid point to avoid can be converted to this type, and then converted back
    to point to void and the result will compare equal to the original pointer. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `intptr_t` | 它是一个32位或64位的有符号整数，具有任何有效指针都可以转换为该类型的属性，然后可以转换回指向void，并且结果将与原始指针比较相等。|'
- en: '| `uintptr_t` | It is a 32-bit or 64-bit unsigned integer that has got the
    same property as `intptr_t`. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `uintptr_t` | 它是一个32位或64位的无符号整数，具有与`intptr_t`相同的属性。|'
- en: 'OpenCL allows the following data types to be used interchangeably in your source
    codes:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCL允许在源代码中使用以下数据类型进行互换：
- en: '| Type in OpenCL | Type in application |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| OpenCL中的类型 | 应用程序中的类型 |'
- en: '| --- | --- |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `bool` | `n/a` |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `bool` | `n/a` |'
- en: '| `char` | `cl_char` |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `char` | `cl_char` |'
- en: '| `unsigned char` `, uchar` | `cl_uchar` |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned char` `, uchar` | `cl_uchar` |'
- en: '| `short` | `cl_short` |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `short` | `cl_short` |'
- en: '| `unsigned short` `, ushort` | `cl_ushort` |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned short` `, ushort` | `cl_ushort` |'
- en: '| `int` | `cl_int` |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `int` | `cl_int` |'
- en: '| `unsigned int` `, uint` | `cl_uint` |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned int` `, uint` | `cl_uint` |'
- en: '| `long` | `cl_long` |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `long` | `cl_long` |'
- en: '| `unsigned long` `, ulong` | `cl_ulong` |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned long` `, ulong` | `cl_ulong` |'
- en: '| `float` | `cl_float` |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `float` | `cl_float` |'
- en: '| `double` | `cl_double` |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `double` | `cl_double` |'
- en: '| `half` | `cl_half` |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `half` | `cl_half` |'
- en: '| `size_t` | `n/a` |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `size_t` | `n/a` |'
- en: '| `ptrdiff_t` | `n/a` |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `ptrdiff_t` | `n/a` |'
- en: '| `intptr_t` | `n/a` |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `intptr_t` | `n/a` |'
- en: '| `uintptr_t` | `n/a` |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `uintptr_t` | `n/a` |'
- en: '| `void` | `void` |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `void` | `void` |'
- en: 'So following are a few examples on how you can possibly declare and define
    scalar data types in your source code in the kernels and host:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下是一些示例，说明您如何在内核和主机源代码中声明和定义标量数据类型：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the previous chapter, *Understanding OpenCL Data Transfer and Partitioning*,
    we spent some time discussing about data types and how alignment works or in other
    words, how data misalignment can affect the performance. Scalar data types are
    always aligned to the size of the data type in bytes. Built-in data types whose
    sizes are not a power of two must be aligned to the next larger power of two.
    That is, a `char` variable will be aligned a 1-byte boundary, a `float` variable
    will be aligned to a 4-byte boundary.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章*理解OpenCL数据传输和分区*中，我们花了一些时间讨论数据类型以及对齐是如何工作的，或者说，数据对齐如何影响性能。标量数据类型始终对齐到数据类型的大小（以字节为单位）。大小不是2的幂的内置数据类型必须对齐到下一个更大的2的幂。也就是说，`char`变量将对齐到1字节边界，`float`变量将对齐到4字节边界。
- en: How to do it…
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: If your application needs user-defined data types, then you need to place `__attribute__((aligned))`
    to those types; refer to the [Chapter 2](ch02.html "Chapter 2. Understanding OpenCL
    Data Transfer and Partitioning"), *Understanding OpenCL Data Transfer and Partitioning*
    for more details.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序需要用户定义的数据类型，那么您需要将这些类型放置在`__attribute__((aligned))`中；有关更多详细信息，请参阅[第2章](ch02.html
    "第2章。理解OpenCL数据传输和分区")，*理解OpenCL数据传输和分区*。
- en: 'In OpenCL, several operators convert operand values from one type to another,
    and this is commonly referred to as implicit conversions; another way is to apply
    a cast operation on operands or on the result of a binary operation. Implicit
    conversions between scalar built-in types are supported with the exception of
    `void` and `half` data types. What it means is shown in the following code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenCL中，有几个运算符可以将操作数的值从一种类型转换为另一种类型，这通常被称为隐式转换；另一种方式是在操作数或二元运算的结果上应用类型转换操作。除了`void`和`half`数据类型外，支持标量内置类型之间的隐式转换。这可以通过以下代码说明：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Or
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can use both forms in your application code. You can coerce a data type
    to another data type in OpenCL too, just as you can do in the C programming language.
    Refer to the following example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在应用程序代码中使用这两种形式。在OpenCL中，您也可以将一种数据类型强制转换为另一种数据类型，就像在C编程语言中做的那样。请参考以下示例：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can also coerce a scalar data type to a vector data type in OpenCL with
    the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用以下代码在OpenCL中将标量数据类型强制转换为向量数据类型：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Initializing the OpenCL vector data types
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化OpenCL向量数据类型
- en: Vectors are extremely powerful to an OpenCL programmer because it allows the
    hardware to bulk load/store data to/from memory; such computations typically take
    advantage of the algorithms spatial and temporal locality properties. In this
    recipe, we are going to familiarize ourselves with creating various types of vectors.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 向量对于OpenCL程序员来说非常强大，因为它允许硬件批量加载/存储数据到/从内存；这类计算通常利用算法的空间和时间局部性属性。在本食谱中，我们将熟悉创建各种类型的向量。
- en: Getting ready
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You can initialize a vector in two primary manners and they are as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过两种主要方式初始化一个向量，如下所示：
- en: Vector literal
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量字面量
- en: Vector composition
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量组合
- en: 'Creating a vector literal simply means that you can construct your vector of
    whatever type you wish as shown in the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个向量字面量简单地说就是你可以构造你想要的任何类型的向量，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Another way to initialize a vector is to do it via a scalar value as shown
    in the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化向量的另一种方式是通过标量值，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can also create vectors in the following fashion:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以以下这种方式创建向量：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The data type on the left-hand-side and right-hand-side must be same or the
    OpenCL compiler will issue a complaint.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧和右侧的数据类型必须相同，否则 OpenCL 编译器将发出警告。
- en: How to do it…
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Vectors have another remarkable property, and that is, you can access the individual
    components through indexes, that is to say if you wish to access each component
    of a `float4` vector, `v`, then you would do so via `v.x`, `v.y`, `v.z`, `v.w`
    respectively, and for larger vectors of 8 or 16 elements we would access those
    individual elements via `v.s0`, `v.s1` through to `v.s7`, and `v.s0`, `v.s1`,
    `v.sa` through to `v.sf` respectively. Hence, vectors of type `char2`, `uchar2`,
    `short2`, `ushort2`, `int2`, `uint2`, `long2`, `ulong2`, and `float2` can access
    their `.xy` elements.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 向量还有一个显著特性，那就是你可以通过索引访问单个分量，也就是说，如果你想访问 `float4` 向量 `v` 的每个分量，那么你会通过 `v.x`、`v.y`、`v.z`、`v.w`
    分别进行，对于更大型的8或16元素向量，我们会通过 `v.s0`、`v.s1` 到 `v.s7`，以及 `v.s0`、`v.s1`、`v.sa` 到 `v.sf`
    分别访问这些单个元素。因此，`char2`、`uchar2`、`short2`、`ushort2`、`int2`、`uint2`、`long2`、`ulong2`
    和 `float2` 类型的向量可以访问它们的 `.xy` 元素。
- en: 'Following is another way of creating vectors and that is through composition:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是通过组合创建向量的另一种方式：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works…
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'On a similar note, you can use numerical indexes to reference the components
    in your vector and create vectors in turn. The following table shows a list of
    indexes for the various vector data types:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在类似的情况下，你也可以使用数值索引来引用向量中的分量，并依次创建向量。以下表格显示了各种向量数据类型的索引列表：
- en: '| Vector components | Numeric indexes that can be used |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 向量分量 | 可以使用的数值索引 |'
- en: '| --- | --- |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 2-component | `0, 1` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 2-分量 | `0, 1` |'
- en: '| 3-component | `0, 1, 2` |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 3-分量 | `0, 1, 2` |'
- en: '| 4-component | `0, 1, 2, 3` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 4-分量 | `0, 1, 2, 3` |'
- en: '| 8-component | `0, 1, 2, 3, 4, 5, 6, 7` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 8-分量 | `0, 1, 2, 3, 4, 5, 6, 7` |'
- en: '| 16-component | `0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, A, b, B, c, C, d, D, e,
    E, f, F` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 16-分量 | `0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, A, b, B, c, C, d, D, e, E, f, F`
    |'
- en: 'To use these numerical indexes, you have to precede by the letter *s* or *S*,
    and following are a few quick examples on how to create vectors:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这些数值索引，你必须以字母 *s* 或 *S* 开头，以下是一些如何创建向量的快速示例：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There's more…
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Lastly, vector data types can use the `.lo` (or `.even`) and `.hi` (or `.odd`)
    suffixes to compose new vector types, or to combine smaller vector types to a
    larger vector type. Multiple levels of `.lo` (or `.even`) and `.hi` (or `.odd`)
    suffixes can be used until they refer to a scalar term. The `.lo` and `.hi` suffix
    refers to the lower and upper halves of a vector. The `.even` and `.odd` suffixes
    of a vector refer to the even and odd elements of a vector. Following are the
    examples of vector creation via composition:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，向量数据类型可以使用 `.lo`（或 `.even`）和 `.hi`（或 `.odd`）后缀来组合新的向量类型，或者将较小的向量类型组合成较大的向量类型。可以使用多级的
    `.lo`（或 `.even`）和 `.hi`（或 `.odd`）后缀，直到它们指代一个标量项。`.lo` 和 `.hi` 后缀指的是向量的下半部分，而向量的
    `.even` 和 `.odd` 后缀指的是向量的偶数和奇数元素。以下是通过组合创建向量的示例：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Vectors are disallowed from implicit conversions so you cannot perform the
    following operation:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 向量不允许隐式转换，因此你不能执行以下操作：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Explicit casts between vector types are also disallowed, and in fact the only
    form of explicit cast to a vector type is when you''re initializing a vector with
    a scalar:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 向量类型之间的显式转换也是不允许的，实际上，唯一可以显式转换为向量类型的情况是在使用标量初始化向量时：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you were to extract components of a 3-component vector type via the suffixes
    `.lo` (or `.even`), `.hi` (or `.odd`), then the 3-component vector type would
    behave as if it is a 4-component vector type with the exception that the `w` component
    would be undefined.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过后缀 `.lo`（或 `.even`）、`.hi`（或 `.odd`）提取3分量向量类型的分量，那么3分量向量类型会表现得像4分量向量类型，除了
    `w` 分量是未定义的。
- en: Using OpenCL scalar types
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 OpenCL 矢量类型
- en: The scalar data types are quite similar to what you would expect if you were
    programming in the C language. However, two topics deserve more attention and
    we'll touch on that in this recipe; we'll look at the `half` data type and examine
    how OpenCL devices might order their data.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 标量数据类型与你在用C语言编程时预期的相当相似。然而，有两个主题值得更多关注，我们将在本食谱中涉及；我们将查看`half`数据类型，并检查OpenCL设备可能如何排序他们的数据。
- en: Getting ready
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Many of the OpenCL compliant devices are actually little-endian architectures,
    and developers need to ensure that their kernels are tested on both big-endian
    and little-endian devices to ensure source compatibility with current and future
    devices. Let's use a simple example to illustrate endian-ness.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 许多符合OpenCL规范的设备实际上都是小端架构，开发者需要确保他们的内核在大小端设备上都被测试过，以确保与当前和未来设备的源代码兼容性。让我们用一个简单的例子来说明字节序。
- en: How to do it…
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Consider a variable `x` that holds the value `0x01234567` and the address of
    `x` starts at `0x100`. In computer architecture terminology, the value `0x01`
    is the **most significant byte** ( **MSB**) and `0x67` is the **least significant
    byte** ( **LSB**). Big-endian storage scheme stores the MSB first till it meets
    the LSB and little-endian storage schemes stores the LSB first till it meets the
    MSB.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个变量`x`，它持有值`0x01234567`，且`x`的地址从`0x100`开始。在计算机体系结构术语中，值`0x01`是**最高有效字节**（**MSB**），而`0x67`是**最低有效字节**（**LSB**）。大端存储方案首先存储MSB直到遇到LSB，而小端存储方案首先存储LSB直到遇到MSB。
- en: Big-endian
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 大端
- en: '| **Address** | 0x100 | 0x101 | 0x102 | 0x103 |   |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| **地址** | 0x100 | 0x101 | 0x102 | 0x103 |   |'
- en: '| **Values** | 0x01 | 0x23 | 0x45 | 0x67 | … |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| **值** | 0x01 | 0x23 | 0x45 | 0x67 | … |'
- en: Little-endian
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 小端
- en: '| **Address** | 0x100 | 0x101 | 0x102 | 0x103 |   |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| **地址** | 0x100 | 0x101 | 0x102 | 0x103 |   |'
- en: '| **Values** | 0x67 | 0x45 | 0x23 | 0x01 | … |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| **值** | 0x67 | 0x45 | 0x23 | 0x01 | … |'
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Review the full code listed in `Ch3/byte_ordering/show_bytes.c`, compile the
    code by running the commands `cmake` and `make` in that order; that will generate
    a binary named `ShowBytes`, and then run that program to see its output. This
    code will print out a series of output, and depending on the endian-ness of the
    architecture, you will notice different byte orderings.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 查看列在`Ch3/byte_ordering/show_bytes.c`中的完整代码，按照顺序运行`cmake`和`make`命令来编译代码；这将生成一个名为`ShowBytes`的二进制文件，然后运行该程序以查看其输出。此代码将打印出一系列输出，并且根据架构的字节序，你会注意到不同的字节序。
- en: 'Refer to the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下代码：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Since you''ve understood how byte ordering affects the way data (scalar) is
    being read and written; let''s take a look at how the ordering affects vector
    data types in OpenCL. With vector data types, both, the order of the bytes within
    each value and the order of the values with respect to one another are reversed.
    Using an example of a `uint4` vector which contains the values `0x000102030405060708090A0B0C0D0E0F`,
    at address `0x100`, following table shows how a little-endian storage scheme would
    look:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你已经理解了字节序如何影响数据（标量）的读取和写入方式；让我们看看字节序如何影响OpenCL中的向量数据类型。在向量数据类型中，每个值内字节的顺序以及值之间的顺序都被反转。以一个包含值`0x000102030405060708090A0B0C0D0E0F`的`uint4`向量为例，地址为`0x100`，以下表格显示了小端存储方案的外观：
- en: '| 0x100 | 0x104 | 0x108 | 0x1b0 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 0x100 | 0x104 | 0x108 | 0x1b0 |'
- en: '| 0x0F0E0D0C | 0x0B0A0908 | 0x07060504 | 0x3020100 |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 0x0F0E0D0C | 0x0B0A0908 | 0x07060504 | 0x3020100 |'
- en: Awareness of this fact is important if you are working with data compression
    and computer-imaging algorithms since these two classes of algorithms have a significant
    amount of byte-level operations and you don't want to be bitten by these issues.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在处理数据压缩和计算机图像算法，了解这一事实非常重要，因为这两类算法在字节级操作方面有大量的操作，你不想被这些问题困扰。
- en: How it works…
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `half-precision` data type, conveniently called `half` actually has half
    the storage and precision of a regular `float` type. The `half` type is IEEE754-2008
    compliant and was first introduced by NVIDIA, and Industrial Light and Magic.
    The only thing you can do with this type is to declare a pointer to a buffer that
    contains `half` values; those values must be finite and normal numbers, de-normalized
    numbers, infinities, and NaN.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 被方便地称为`half`的`half-precision`数据类型实际上具有常规`float`类型一半的存储和精度。`half`类型符合IEEE754-2008标准，并由NVIDIA和工业光魔公司首次引入。你可以用这种类型做的唯一一件事是声明一个指向包含`half`值的缓冲区的指针；这些值必须是有限数、正常数、非规范化数、无穷大和NaN。
- en: You can choose to use the vector load and store functions such as `vload_half`,
    `vload_halfn`, `vstore_half`, and so on. However, bear in mind that the load/store
    operation will create an intermediate floating -point value.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择使用向量加载和存储函数，例如 `vload_half`、`vload_halfn`、`vstore_half` 等。然而，请记住，加载/存储操作将创建一个中间的浮点值。
- en: Note
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `load` function read the `half` values from memory and converts it to a
    regular `float` value. The `store` functions take a `float` as an input, convert
    it to a `half` value and store that value into memory.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`load` 函数从内存中读取 `half` 值并将其转换为常规的 `float` 值。`store` 函数接受一个 `float` 作为输入，将其转换为
    `half` 值并将其存储到内存中。'
- en: 'To determine if your device supports this, you can run the program in `Ch2/device_extension/device_extensions`,
    and the output should contain `cl_khr_fp16`; alternatively you can query the device
    by passing the parameter `CL_DEVICE_EXTENSIONS` to `clGetDeviceInfo`. Following
    is the code snippet from `Ch2/device_extensions/device_extensions.c`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定您的设备是否支持此功能，您可以在 `Ch2/device_extension/device_extensions` 目录中运行程序，输出应包含 `cl_khr_fp16`；或者，您可以通过传递参数
    `CL_DEVICE_EXTENSIONS` 到 `clGetDeviceInfo` 来查询设备。以下是从 `Ch2/device_extensions/device_extensions.c`
    的代码片段：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Understanding OpenCL vector types
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 OpenCL 向量类型
- en: When you start working through your OpenCL project you are inevitably going
    to use both the scalar and vector data types to model the algorithm. Scalars work
    like any variable declaration/definition you may have come across in most of the
    programming languages, and you should think of vectors as a wide container that
    can deliver all items in that container in parallel, and the one thing that differentiates
    scalars and vectors is the fact that when an operation is applied to a scalar,
    it affects just a single value while the same operation applied to a vector affects
    all items in it in parallel.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始处理您的 OpenCL 项目时，您不可避免地会使用标量和向量数据类型来模拟算法。标量的工作方式类似于您在大多数编程语言中遇到的任何变量声明/定义，您应该将向量视为一个宽容器，可以并行地提供该容器中的所有项目，而区分标量和向量的唯一一点是，当对一个标量应用操作时，它只影响单个值，而当对向量应用相同的操作时，它并行地影响其中的所有项目。
- en: In the modern processors, there exist a specialized hardware unit that processes
    more data per cycle and they are often termed as **Single Instruction Multiple
    Data** (**SIMD**) or known as **Streaming SIMD Extensions** (**SSE**) which is
    intel's implementation of SIMD. The advantage that SIMD instructions provide is
    that they allow multiple values to be operated upon in a large register in a cycle;
    quite often there are many such units, thus increasing performance of the program.
    We should be clear that SIMD describes a mechanism that allows parallelism to
    occur gleaned from Flynn's taxonomy, while SSE describes how two CPU processor
    manufacturers namely, Intel and AMD implemented SIMD.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代处理器中，存在一个专门的硬件单元，每个周期可以处理更多数据，它们通常被称为 **单指令多数据**（**SIMD**）或称为 **流式 SIMD 扩展**（**SSE**），这是英特尔对
    SIMD 的实现。SIMD 指令提供的优势是它们允许在一个大寄存器中在一个周期内操作多个值；通常有很多这样的单元，从而提高程序的性能。我们应该清楚，SIMD
    描述的是一个允许并行性发生的机制，这是从弗林分类法中获得的，而 SSE 描述了两个 CPU 处理器制造商，即英特尔和 AMD 如何实现 SIMD。
- en: The first part of the story is to tell you how OpenCL kernels run on the CPUs
    before we reveal how it would work on the GPU, and for now we place our attention
    on the Intel CPU architecture. On these architectures, OpenCL sees a single device
    with multiple compute units and if you are guessing each core is a compute unit
    then you're correct and hence, your kernels run on all compute units unless you
    are using the device fission extension, which is new in OpenCL 1.2.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在揭示 OpenCL 内核如何在 GPU 上工作之前，故事的第一部分是告诉您 OpenCL 内核在 CPU 上是如何运行的，目前我们将注意力放在英特尔
    CPU 架构上。在这些架构上，OpenCL 看到一个具有多个计算单元的单个设备，如果您猜测每个核心都是一个计算单元，那么您是对的，因此，除非您使用 OpenCL
    1.2 中新引入的设备分裂扩展，否则您的内核将在所有计算单元上运行。
- en: Note
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Device fission (`cl_khr_device_fission`) which is new in OpenCL 1.2 is currently
    supported by multicore CPUs by Intel, AMD, and IBM Cell Broadband. GPUs are currently
    not supported.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCL 1.2 中引入的设备分裂（`cl_khr_device_fission`）目前由英特尔、AMD 和 IBM Cell Broadband
    的多核 CPU 支持。GPU 目前不支持。
- en: The next part of the story is to describe, how OpenCL kernels would run on GPUs
    manufactured by AMD, and we focus on the AMD GPU we used for this book which is
    based on AMD's Southern Island Architecture which includes their Radeon HD 7900,
    7800, and 7700 GPUs; on a side note, you might wish to consult NVIDIA's website
    for more product details pertaining to their GPUs at [www.nvidia.com](http://www.nvidia.com).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 故事的下一段是描述OpenCL内核如何在AMD制造的GPU上运行，我们关注的是本书中使用的基于AMD南方群岛架构的AMD GPU，该架构包括他们的Radeon
    HD 7900、7800和7700 GPU；顺便提一下，你可能希望查阅NVIDIA的网站以获取有关其GPU的更多产品细节，网址为[www.nvidia.com](http://www.nvidia.com)。
- en: Kernels basically execute instructions that are either scalar-based or vector-based,
    and work is assigned to a compute unit in blocks of 64 work items, which is termed
    as wavefront. A wavefront has a single program counter, and is considered as a
    small unit of work and what that means is that they execute in lock-step.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 内核基本上执行基于标量或向量的指令，工作负载以64个工作项的块分配给计算单元，这被称为波前。波前有一个单独的程序计数器，被视为一个小的工作单元，这意味着它们以同步的方式执行。
- en: When your application passes workloads to the GPU, it must first compile the
    kernel and load it into memory. It must also bind buffers for the source and result
    data, and finally it would decide how to execute the given workload on the GPU.
    When the workload is to be executed, the GPU divides the input domain into blocks
    of 64 threads aka wavefronts and dispatches them to the **compute unit** (**CU**).
    The kernel is next fetched into the instruction cache and the compute unit begins
    dispatching instructions to the execution units; each compute unit can work on
    multiple wavefronts in parallel, simultaneously processing vector and scalar ALU
    computations, as well as memory accesses. The wavefront continues executing until
    the end of the kernel is reached, when the wavefront is terminated and a new one
    can take its place on the GPU.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的应用程序将工作负载传递给GPU时，它必须首先编译内核并将其加载到内存中。它还必须绑定源数据和结果数据的缓冲区，最后它将决定如何在GPU上执行给定的工作负载。当工作负载要执行时，GPU将输入域划分为64线程的块，称为波前（wavefronts），并将它们调度到**计算单元**（compute
    unit，简称**CU**）。接下来，内核被检索到指令缓存中，计算单元开始向执行单元调度指令；每个计算单元可以并行处理多个波前，同时处理向量算术逻辑单元（ALU）计算以及内存访问。波前将继续执行，直到内核的末尾，此时波前将被终止，新的波前可以接替其在GPU上的位置。
- en: Taking into account the fact that memory accesses by wavefronts happens in parallel,
    you will expect some sort of latency to occur and the processor is pretty clever
    in dealing with that situation, and what it does is executing many wavefronts
    in parallel and it works such that if one wavefront is waiting for results from
    the memory, other wavefronts can issue memory requests, and they can execute ALU
    operations in parallel with outstanding memory requests if and only if they are
    independent calculations. Factors that increase the amount of parallelism that
    can be extracted from the program varies, but one of them would be the actual
    number of hardware units available for parallel computation and in OpenCL terminology,
    it is known as the CU and in both CPUs and GPUs they are basically the processor.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到波前对内存的访问是并行的，你可能会期望出现某种延迟，处理器在处理这种情况时相当聪明，它所做的就是并行执行许多波前，并且它的工作方式是，如果一个波前正在等待从内存中获取结果，其他波前可以发出内存请求，并且如果它们是独立的计算，它们可以在挂起的内存请求与并行执行ALU操作之间进行并行处理。可以从程序中提取的并行程度增加的因素各不相同，但其中之一就是可用于并行计算的硬件单元的实际数量，在OpenCL术语中，它被称为CU，在CPU和GPU中，它们基本上是处理器。
- en: 'A compute unit is the basis of parallel computation, and in the Southern Island
    Architecture which hosts other products, the number of compute units varies and
    each compute unit basically contains the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 计算单元是并行计算的基础，在南方群岛架构中，该架构支持其他产品，计算单元的数量会有所不同，每个计算单元基本上包含以下内容：
- en: Scalar ALU and scalar **GPRs** (**General-Purpose Registers**) aka **SGPRs**
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标量算术逻辑单元（Scalar ALU）和标量**通用寄存器**（General-Purpose Registers，简称**GPRs**）也称为**SGPRs**
- en: Four SIMDs, each consisting of a vector ALU and vector GPRs, aka VGPRs
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 四个SIMD（单指令多数据），每个由一个向量算术逻辑单元（vector ALU）和向量通用寄存器（vector GPRs，简称VGPRs）组成
- en: Local memory
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地内存
- en: Read/write access to vector memory through a Level-1 cache
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过一级缓存对向量内存进行读写访问
- en: Instruction cache, which is shared by four CUs, that is, compute units
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指令缓存，由四个计算单元共享，即计算单元
- en: Constant cache, which is shared by four CUs, that is, compute units
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量缓存，由四个计算单元（compute units，简称CUs）共享，即计算单元
- en: Now we will focus on the vector operations on GPUs, which include ALU and memory
    operations. Each of the four SIMDs contains a vector-ALU that operates on wavefronts
    over four cycles; each SIMD also can host ten wavefronts in flight, that is, one
    CU can have forty wavefronts executing in parallel. In the AMD GPU based on the
    Southern Island Architecture used for this book which is the AMD HD 7870, we have
    20 compute units and we know now that each CU holds four SIMDs and each SIMD would
    execute a wavefront means that we can have 20 x 4 x 10 x 64 = 51,200 work items
    at any one time, and if you were to imagine that each work item is at the stage
    of executing vector operations then the parallelism offered by GPUs is considerably
    larger than that of the CPU; the specific CPU we are referring to is the Intel
    Xeon Phi which has 60 cores and each core hosts 4 work items which provides 60
    x 4 = 240 work items; be aware that we're not stating that GPUs are superior to
    CPUs since each device has its niche but we illustrate these numbers to demonstrate
    a simple fact that GPU has a higher throughput than the CPU.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将专注于GPU上的向量操作，这包括ALU和内存操作。每个四路SIMD包含一个在四个周期内对波前进行操作的向量-ALU；每个SIMD还可以托管十个正在飞行的波前，即一个CU可以并行执行四十个波前。在本书中使用的基于南方群岛架构的AMD
    GPU（AMD HD 7870）上，我们有20个计算单元，我们知道每个CU包含四个SIMD，每个SIMD执行一个波前意味着在任何时候我们都可以有20 x 4
    x 10 x 64 = 51,200个工作项，如果您想象每个工作项都处于执行向量操作的阶段，那么GPU提供的并行性将远远大于CPU；我们指的是具有60个核心的Intel
    Xeon Phi，每个核心托管4个工作项，这提供了60 x 4 = 240个工作项；请注意，我们并不是说GPU优于CPU，因为每个设备都有其特定的领域，但我们展示这些数字是为了说明一个简单的事实，即GPU的吞吐量高于CPU。
- en: 'Having said all that, we are going to see an example soon but first recall
    that vector operations are component-wise and that vectors can be accessed via
    numeric indexes, and each index can be combined into larger group of indices to
    perform a store/load to/from memory. Refer to the following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 说了这么多，我们很快将看到一个例子，但首先请记住，向量操作是按组件进行的，并且可以通过数字索引访问向量，每个索引可以组合成更大的索引组以执行内存的存储/加载操作。请参考以下代码：
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The component-wise manner in which vectors can be aggregated to perform an operation
    without code verbosity actually helps the programmer in their daily work and increases
    productivity. Next, we can a dive into how vector types are translated to utilize
    your hardware.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 向量可以通过组件方式聚合以执行操作，而不需要代码冗余，这种方式实际上有助于程序员在日常工作中提高工作效率。接下来，我们可以深入了解向量类型是如何转换为利用您的硬件的。
- en: Getting ready
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The demonstration we are going to describe has two parts in it. First, we are
    going to use the Intel OpenCL compiler on Windows to demonstrate the implicit
    vectorization of the kernel code; secondly, we are going to demonstrate how to
    enable native vector type notation in your code to express the desire to generate
    vectorized code using the AMD APP SDK v2.7 or v2.8 on Linux.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要描述的演示有两个部分。首先，我们将使用Windows上的Intel OpenCL编译器来演示内核代码的隐式向量化；其次，我们将演示如何在您的代码中启用原生向量类型表示法，以表达使用Linux上的AMD
    APP SDK v2.7或v2.8生成向量化代码的愿望。
- en: We combined these two approaches with the intention to solve the problem of
    transferring a large input array from one part of the device memory to another
    part of the device memory, and finally we extract and compare them for equality.
    As before, we would prepare the data structures for transfers on the host code
    and write a suitable OpenCL kernel to actually transfer the memory contents across.
    The source can be found in `Ch3/vectorization`, and we build the program using
    the AMD APP SDK.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们结合这两种方法，旨在解决将大输入数组从设备内存的一部分传输到另一部分的问题，最终我们提取并比较它们以检查是否相等。与之前一样，我们会在主机代码中准备传输的数据结构，并编写一个合适的OpenCL内核来实际传输内存内容。源代码可以在`Ch3/vectorization`中找到，我们使用AMD
    APP SDK构建程序。
- en: Note
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Readers who are interested in the OpenCL code generation for AMD CPU and GPU
    platforms should consult the `AMD CodeXL` product as the AMD APP Kernel Analyzer
    has been retired. You may wish to consult the AMD Intermediate Language Manual
    in conjunction when you study the intermediate language output.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于对AMD CPU和GPU平台的OpenCL代码生成感兴趣的读者，应咨询`AMD CodeXL`产品，因为AMD APP内核分析器已经停用。当您研究中间语言输出时，可能还需要查阅AMD中间语言手册。
- en: 'Implicit vectorization is a required feature that is supported by all the compliant
    OpenCL compiler implementations, and the reason we chose to demonstrate this feature
    with the Intel OpenCL compiler is the fact that the generated SIMD instructions
    are more likely to be recognized by the reader than would the intermediate code
    generated by other compiler implementations such as AMD or NVIDIA''s. The kernel
    code we have for you can be found in `Ch3/vectorization/vectorization.cl`, and
    we reveal it as in the following code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式向量化是所有符合OpenCL编译器实现要求的必备功能，我们选择使用Intel OpenCL编译器来演示此功能的原因是生成的SIMD指令更有可能被读者识别，而不是其他编译器实现（如AMD或NVIDIA的）生成的中间代码。我们提供的内核代码可以在`Ch3/vectorization/vectorization.cl`中找到，如下所示：
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This kernel's main action is to transfer the contents from one place to another,
    and it does this by transporting it in parallel using two vectors of eight floats
    each and you will notice that we use the vector component notation to state these
    memory transfers explicitly.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此内核的主要操作是将内容从一个地方传输到另一个地方，它是通过使用两个包含八个浮点数的向量并行传输来实现的，你将注意到我们使用向量分量符号来明确表示这些内存传输。
- en: In the next demonstration, we swing from the kernel code back to the host code
    assuming that the developer has a desire to control the code generation in a more
    explicit manner; and this can be done through the native vector type notation.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的演示中，我们将从内核代码回到主机代码，假设开发者希望以更明确的方式控制代码生成；这可以通过原生向量类型符号来实现。
- en: 'We ask the reader to refer to the section *There''s more…* for details, but
    the demonstration here rests on the assumption that the developer would like to
    hand tune the procedure that handles data validation once the memory transfers
    have been completed in the device, and this function can be found in `Ch3/vectorization/vectorization.c`
    named `valuesOK` and the following code is how it is implemented:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要求读者参考*更多内容…*部分以获取详细信息，但这里的演示基于开发者希望在设备内存传输完成后手动调整处理数据验证的程序的假设，这个函数可以在`Ch3/vectorization/vectorization.c`中找到，命名为`valuesOK`，以下是如何实现的代码：
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How to do it…
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Implicit vectorization through the Intel OpenCL compiler is relatively easy
    and the purpose of this simple example, we have chosen to install it on the Windows
    operating system. You can download the compiler from [http://software.intel.com/en-us/vcsource/tools/opencl](http://software.intel.com/en-us/vcsource/tools/opencl).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Intel OpenCL编译器实现隐式向量化相对简单，在这个简单的例子中，我们选择在Windows操作系统上安装它。你可以从[http://software.intel.com/en-us/vcsource/tools/opencl](http://software.intel.com/en-us/vcsource/tools/opencl)下载编译器。
- en: 'To witness how the implicit vectorization can be achieved through this compiler,
    you would copy and paste the kernel code (the previous code) into the editor pane
    of the GUI and start the compilation. Once compiled, you would be able to view
    the generated code by clicking on the **ASM** or **LLVM** buttons on the GUI.
    An example of this is shown in the following screenshot:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要见证如何通过此编译器实现隐式向量化，你需要将内核代码（前面的代码）复制粘贴到GUI的编辑面板中，并开始编译。一旦编译完成，你可以通过点击GUI上的**ASM**或**LLVM**按钮来查看生成的代码。以下是一个示例截图：
- en: '![How to do it…](img/4520OT_03_01.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作…](img/4520OT_03_01.jpg)'
- en: The next item is to hand-tune our data validation code, `valuesOK`, to exhibit
    vectorization. This example is only meant to illustrate how one would go about
    accomplishing something similar to this and you don't have to do anything besides
    invoking `make` in the directory `Ch3/vectorization`, and an executable vectorization
    will be dropped into the filesystem to which we'll next dissect it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是手动调整我们的数据验证代码`valuesOK`以展示向量化。这个例子只是为了说明如何完成类似的事情，你不需要做任何事情，只需在`Ch3/vectorization`目录中调用`make`，一个可执行的向量化程序将被放入文件系统中，我们将在下一部分对其进行剖析。
- en: Note
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are running OpenCL 1.1 on Mac OSX 10.7, then passing the flag `–cl-auto-vectorizer-enable`
    to `clBuildProgram` as a build option will vectorize the kernels that will execute
    on the CPU. The SIMD instructions will be similar to the ones you see in this
    recipe.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在Mac OSX 10.7上运行OpenCL 1.1，那么将标志`–cl-auto-vectorizer-enable`传递给`clBuildProgram`作为构建选项，将使CPU上将要执行的内核进行向量化。SIMD指令将与你在本食谱中看到的大致相同。
- en: 'Hand-tuning your code in such a manner basically turns implicit vectorization
    off, and you will need to judge for your scenario whether the effort justifies
    with respects to the complexity of the issue. To view the generated SIMD code,
    it would be best to put the program under a debugger, and on Linux the best debugger
    will be the GNU GDB. You basically load the program into the debugger and issue
    the command `disassemble /m valuesOK` to verify that the SIMD instructions were
    indeed generated. Following is a sample `gdb` session where the disassembly is
    interleaved with the source code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式手动调整你的代码基本上是关闭了隐式向量化，你将需要根据你的场景判断这种努力是否值得，与问题的复杂性相比。要查看生成的 SIMD 代码，最好的做法是将程序放在调试器下，在
    Linux 上，最好的调试器将是 GNU GDB。你基本上是将程序加载到调试器中，并发出命令 `disassemble /m valuesOK` 以验证是否确实生成了
    SIMD 指令。以下是一个示例 `gdb` 会话，其中反汇编与源代码交织在一起：
- en: '[PRE18]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works…
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Implicit vectorization is a piece of complicated software written into the compiler
    provided by the implementation, and is definitely hardware dependent and often
    represented by an **intermediate language** (**IL**) that's proprietary to the
    processor manufacturer and to our disappointment, not very well documented so
    we like to focus on how native vector type notation works in more detail.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式向量化是写入实现提供的编译器中的复杂软件的一部分，并且肯定与硬件相关，通常由处理器制造商的专有 **中间语言**（**IL**）表示，但遗憾的是，文档并不完善，所以我们更愿意关注更详细地了解原生向量类型表示法的工作方式。
- en: Note
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The interested reader is however invited to explore the ILs developed by AMD
    and NVIDIA, which are known as AMD IL, and NVIDIA's PTX respectively.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，感兴趣的读者被邀请去探索由 AMD 和 NVIDIA 开发的 IL，分别被称为 AMD IL 和 NVIDIA 的 PTX。
- en: This method of hand-tuning allows the developer to reference the built-in vector
    data type of the platform they're working on instead of relying on the OpenCL
    compiler to auto-vectorize the code, and may bring about performance benefits.
    The manner in which it is being done in OpenCL so far is to abstract these differences
    into platform dependent macros in the file `cl_platform.h`. Let's work out how
    this would work in our example.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这种手动调整的方法允许开发者引用他们正在工作的平台内置的向量化数据类型，而不是依赖于 OpenCL 编译器自动向量化代码，并且可能会带来性能上的好处。到目前为止，在
    OpenCL 中实现这一点的做法是将这些差异抽象成文件 `cl_platform.h` 中的平台相关宏。让我们来看看在我们的示例中这是如何工作的。
- en: 'The example, we saw previously, was tested on the Ubuntu Linux 12.04 operating
    system with an Intel Core i7 CPU and an AMD Radeon HD 7870 GPU, but since our
    example focuses on explicit vectorization on the host code, it implies that we
    need to know the width of SIMD vectors based on the Intel instruction set. We
    know this to be 128-bits and what this means is as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到的示例是在 Ubuntu Linux 12.04 操作系统上，使用英特尔酷睿 i7 CPU 和 AMD Radeon HD 7870 GPU
    进行测试的，但鉴于我们的示例专注于主机代码的显式向量化，这意味着我们需要根据英特尔指令集知道 SIMD 向量的宽度。我们知道这是 128 位，这意味着如下：
- en: '[PRE19]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding code gets translated to the following C code snippet:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码被转换成以下 C 代码片段：
- en: '[PRE20]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The function `__mm_add_ps` is the SIMD function for adding two vectors by adding
    their single precision floating-point values component-wise in this manner and
    at first hand, it will look like syntax sugar but this is one of the many ways
    in which OpenCL provides cross platform compatibility and removes the pain of
    delivering customized vectorized code for various processor architectures so in
    this way a façade is actually a good thing.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `__mm_add_ps` 是 SIMD 函数，通过逐个添加它们的单精度浮点值来添加两个向量，最初看起来像是一种语法糖，但实际上这是 OpenCL
    提供跨平台兼容性的许多方法之一，并且消除了为各种处理器架构提供定制化向量化代码的痛苦，因此以这种方式，一个门面实际上是一件好事。
- en: Coming back to the problem we are trying to solve, which is to vectorize the
    procedure for performing data validation for the input and output arrays. In our
    example, we chose arrays or rather vectors that can contain 8 floats and what
    we will like to do is to examine them and compare them for equality. Using the
    native vector type notation in OpenCL, we know that the vector-of-8 can be decomposed
    into vector-of-4 elements because, OpenCL stipulates that if a platform can support
    a native vector type then the macro is identified in the `cl_platform.h` file
    by the name `__CL_<TYPEN>`, where `<TYPEN>` can be `UCHAR16`, `CHAR16`, `INT4`,
    `FLOAT4`, that is, the vectorized primitive types and in general, you can access
    the native components using the `.v<N>` subvector notation where `<N>` is the
    number of elements in the subvector.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们试图解决的问题，即对输入和输出数组进行数据验证的过程进行向量化。在我们的例子中，我们选择了可以包含8个浮点数的数组或向量，我们想要做的是检查它们并比较它们是否相等。使用OpenCL的本地向量类型表示法，我们知道8元素向量可以分解成4元素向量，因为OpenCL规定，如果一个平台可以支持本地向量类型，那么该宏在`cl_platform.h`文件中以`__CL_<TYPEN>`命名，其中`<TYPEN>`可以是`UCHAR16`、`CHAR16`、`INT4`、`FLOAT4`，即向量化的原始数据类型。一般来说，你可以使用`.v<N>`子向量表示法来访问本地组件，其中`<N>`是子向量中的元素数量。
- en: 'Using this newly found information, we can dissect the program we saw previously
    with the fact that the memory content of the original host memory is represented
    by the `cl_float8 *` to while the copied memory contents from host to device are
    held by the `cl_float8*` from:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个新发现的信息，我们可以分析之前看到的程序，其中原始主机内存的内容由`cl_float8 *`表示，而主机到设备复制的内存内容由`cl_float8*`持有：
- en: '[PRE21]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We need to iterate through the vectors in both input and output arrays and
    proceed to extract the first and second vector-of-4s from the host pointer as
    follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要遍历输入和输出数组中的向量，并按照以下方式从主机指针中提取第一个和第二个4元素向量：
- en: '[PRE22]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then we extract the first and second vector-of-4s from the device pointer as
    follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们按照以下方式从设备指针中提取第一个和第二个4元素向量：
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, we compare each of the halves by using the SSE API `__mm_cmp_neq_ps`,
    and keep the result of each test into the variables test and test2 as shown in
    the following code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用SSE API `__mm_cmp_neq_ps`比较每一半，并将每个测试的结果保存在变量test和test2中，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, we compare those results as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们按照以下方式比较这些结果：
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There's more…
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Another part of the vectorization story that we wanted to tell you is that you,
    the developer, has the option of controlling the auto-vectorization by providing
    an explicit compiler hint to the kernel code. This can be useful if you want to
    hand-tune the vectorization of your code.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想要告诉你的向量化故事的一部分是，作为开发人员，你有权通过向内核代码提供显式的编译器提示来控制自动向量化。如果你想要手动调整代码的向量化，这可能很有用。
- en: 'The compiler hint we are referring to is the `vec_type_hint(<type>)` where
    `<type>` is any of the built-in scalar or vector data types we mentioned previously.
    The attribute `vec_type_hint(<type>)` represents the computation width of the
    kernel and if it''s not specified, the kernel is assumed to have the `vec_type_hint(int)`
    qualifier applied to the kernel, that is, 4-bytes wide. The following code snippets
    illustrate how the computation width of the kernel changes from 16-bytes to 8-bytes
    and finally to 4-bytes which happens to be the default:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所提到的编译器提示是`vec_type_hint(<type>)`，其中`<type>`是我们之前提到的任何内置标量或向量数据类型。属性`vec_type_hint(<type>)`表示内核的计算宽度，如果没有指定，则假定内核应用了`vec_type_hint(int)`限定符，即4字节宽。以下代码片段说明了内核的计算宽度如何从16字节变为8字节，最后变为4字节，这恰好是默认值：
- en: '[PRE26]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For you, the developer, to be able to use this, you will need to know the width
    of the vector units in your platform which could be running on a CPU or GPU. In
    the next diagram, we have two scenarios where we assume that both the `__kernel`
    functions are declared with `__attribute_((vec_type_hint(float4)))` and `__attribute_((vec_type_hint(char4)))`
    respectively. Furthermore, we assumed that the kernel is running on 256-bit wide
    registers and how the auto-vectorizer might choose to run one or more work items
    so that the register''s usage is maximized; this is of course dependent on the
    compiler''s implementation. The following figure is a conceptual view of how the
    OpenCL compiler might generate work items to consume the data in the wide registers:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于您，开发者来说，要能够使用这个功能，您需要知道您平台中向量单元的宽度，这可能是在CPU或GPU上运行的。在下一张图中，我们展示了两种场景，我们假设两个`__kernel`函数分别使用`__attribute_((vec_type_hint(float4)))`和`__attribute_((vec_type_hint(char4)))`声明。此外，我们还假设内核正在256位宽的寄存器上运行，以及自动向量化器如何选择运行一个或多个工作项以最大化寄存器的使用；这当然取决于编译器的实现。以下图展示了OpenCL编译器可能如何生成工作项以消耗宽寄存器中的数据：
- en: '![There''s more…](img/4520OT_03_02.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多…](img/4520OT_03_02.jpg)'
- en: In the native vector type notation method for explicit vectorization, we mentioned
    that native vector types are identified in `cl_platform.h` by the `__CL_<TYPEN>__`
    preprocessor symbols aka C macros but, we haven't told you how we came to use
    the SSE instructions in the code example. Let's now find out why, and we need
    to reference the `cl_platform.h` defined by the OpenCL 1.2 standard (which you
    can download from [http://www.khronos.org/registry/cl/api/1.2/cl_platform.h](http://www.khronos.org/registry/cl/api/1.2/cl_platform.h))
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在原生向量类型表示法中进行显式向量化的原生向量类型方法中，我们提到原生向量类型通过`cl_platform.h`中的`__CL_<TYPEN>__`预处理符号（也称为C宏）在`cl_platform.h`中标识，但我们还没有告诉您我们如何在代码示例中使用SSE指令。现在让我们找出原因，我们需要参考OpenCL
    1.2标准定义的`cl_platform.h`（您可以从[http://www.khronos.org/registry/cl/api/1.2/cl_platform.h](http://www.khronos.org/registry/cl/api/1.2/cl_platform.h)下载）。
- en: The code example was tested on the Ubuntu Linux 12.04 64-bit operating system
    with an Intel Core i7 CPU and a AMD Radeon HD 7870 GPU, and we should ignore the
    presence of the GPU as it has no relevance other than to inform you the machine
    setup.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 代码示例在Ubuntu Linux 12.04 64位操作系统上进行了测试，该系统配备英特尔酷睿i7 CPU和AMD Radeon HD 7870 GPU，我们应该忽略GPU的存在，因为它除了通知您机器配置外没有其他相关性。
- en: 'What this setup tells us is that we have a SSE-capable instruction set and
    as a convention adopted by the UNIX and GCC community in general, is to look for
    the `__SSE__` preprocessor symbol and we indeed do that as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设置告诉我们，我们有一个支持SSE的指令集，并且按照UNIX和GCC社区的一般惯例，我们应该寻找`__SSE__`预处理符号，我们确实是这样做的，如下所示：
- en: '[PRE27]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: From the preceding code snippet, we know we should be focusing on the statement
    1 as it has provided us the indicative width of the SIMD vectors, and we also
    know that by convention `__m128` indicates that its vector's width is 128-bits;
    other values includes 64-bits and 256-bits. We should also be careful to contain
    the explicit vectorization within the preprocessor guard, as a best practice,
    that is, `#ifdef __CL_FLOAT4__`.Using this understanding, we can proceed to search
    for the appropriate SSE APIs that allows us to manipulate data values of the desired
    width. The interested reader is invited to check the Intel Developer Manuals and
    AMD Developer Manuals, and explore how these ISAs compare and most importantly
    where they differ.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码片段中，我们知道我们应该关注语句1，因为它为我们提供了SIMD向量的指示性宽度，我们还知道按照惯例`__m128`表示其向量的宽度为128位；其他值包括64位和256位。我们还应该注意将显式向量化包含在预处理器的保护中，这是一个最佳实践，即`#ifdef
    __CL_FLOAT4__`。利用这种理解，我们可以继续寻找允许我们操作所需宽度数据值的适当SSE API。感兴趣的读者可以查阅英特尔开发者手册和AMD开发者手册，并探索这些ISA如何比较以及最重要的是它们在哪里不同。
- en: Vector and scalar address spaces
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量和标量地址空间
- en: 'Now that we have understood how to use scalars and vectors in OpenCL, it''s
    time to examine the OpenCL''s defined four address spaces: `__global`, `__local`,
    `__constant`, and `__private` in which vectors and scalars can exist in. These
    spaces are mapped to the memory units and hence, limited by the actual resource
    on the device and define how work items can access memory.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何在OpenCL中使用标量和向量，是时候检查OpenCL定义的四个地址空间了：`__global`、`__local`、`__constant`和`__private`，在这些地址空间中，向量和标量可以存在。这些空间映射到内存单元，因此受设备实际资源的限制，并定义了工作项如何访问内存。
- en: Getting ready
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Following is a conceptual diagram of the various memory domains:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对各种内存域的概念图：
- en: '![Getting ready](img/4520OT_03_03.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/4520OT_03_03.jpg)'
- en: The **Global Memory** and **Constant Memory** found in the lower-half of the
    preceding diagram corresponds to the `__global` and `__constant` domain. The **Local
    Memory** associated with each compute unit in OpenCL (that executes the kernel
    code) will have a memory space that's shared by all work items in the block which
    corresponds to the `__local` memory space while each processing element will have
    its own namespace to store data and, it is represented by the `__private` memory
    space. Be aware that there is no way in which a work item can access the (`__private`)
    memory space of another work item regardless of whether they're in the same work
    group or not, the same can be said of shared memory, that is, `__local` memory
    where no two work groups can inspect the other's memory.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个图的下半部分中找到的**全局内存**和**常量内存**对应于`__global`和`__constant`域。与OpenCL中每个计算单元（执行内核代码）关联的**局部内存**将有一个由块中所有工作项共享的内存空间，这对应于`__local`内存空间，而每个处理元素将拥有自己的命名空间来存储数据，它由`__private`内存空间表示。请注意，工作项无法以任何方式访问另一个工作项的（`__private`）内存空间，无论它们是否在同一个工作组中，同样适用于共享内存，即`__local`内存，因为没有任何两个工作组可以检查对方的内存。
- en: Each compute unit in the device has a certain number of processing elements
    which executes work items and the compute unit as a whole would access the local,
    constant, or global memory space as determined by the computation. Each processing
    element (work group or work item), stores its own private variables in its private
    memory space.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 设备中的每个计算单元都有一定数量的处理元素，这些处理元素执行工作项，并且计算单元作为一个整体会根据计算需要访问局部、常量或全局内存空间。每个处理元素（工作组或工作项）在其私有内存空间中存储自己的私有变量。
- en: How to do it…
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The `__global` address space name is used to refer to memory objects allocated
    from the global memory pool. To determine the actual amount of resources available
    on the device, you need to pass the parameter `CL_DEVICE_GLOBAL_MEM_SIZE` to `clGetDeviceInfo`.
    The following snippet is drawn from `Ch2/device_details/device_details.c`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`__global`地址空间名称用于引用从全局内存池分配的内存对象。为了确定设备上实际可用的资源量，你需要传递参数`CL_DEVICE_GLOBAL_MEM_SIZE`到`clGetDeviceInfo`。以下代码片段来自`Ch2/device_details/device_details.c`：'
- en: '[PRE28]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `__local` address space name is used to describe variables that need to
    be allocated in the local memory and shared by all work items of a work group.
    You can determine the maximum size of this space by passing the parameter `CL_DEVICE_MAX_LOCAL_MEM_SIZE`
    to `clGetDeviceInfo`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`__local`地址空间名称用于描述需要在局部内存中分配并共享工作组中所有工作项的变量。你可以通过传递参数`CL_DEVICE_MAX_LOCAL_MEM_SIZE`到`clGetDeviceInfo`来确定这个空间的最大大小。'
- en: The `__constant` address space name is used to describe non-mutable variables
    that need to be allocated as read-only in global memory, and can be read by all
    work items during the kernel's execution. You can determine the maximum size of
    this space by passing the parameter `CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE` to `clGetDeviceInfo`.
    This address space is useful if there is a specific value that does not change
    and is needed by the kernel functions.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`__constant`地址空间名称用于描述需要作为只读分配到全局内存中的不可变变量，并且在内核执行期间可以被所有工作项读取。你可以通过传递参数`CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE`到`clGetDeviceInfo`来确定这个空间的最大大小。这个地址空间在存在特定值且内核函数需要时非常有用，这个值不会改变。'
- en: 'The `__private` address space is used to describe objects private-only distinct
    work items; hence work items cannot inspect one another''s variables if they were
    marked by `__private`. By default, variables inside a kernel function not declared
    with any address space qualifiers such as: `__global`, `__local`, or `__constant`
    are marked `__private`; this includes all variables in the non-kernel functions
    and function arguments. The following kernel code from `Ch3/vectorization/vectorization.cl`
    will illustrate the global and private memory spaces whereby the variables `id`,
    `index`, and `t` are in the private memory space and hence not visible across
    other work items, therefore, free from interference, whereas the variables `in`
    and `out` exist in the global memory space and are visible by all work items:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`__private` 地址空间用于描述仅对特定工作项私有的对象；因此，如果它们被标记为 `__private`，则工作项无法检查彼此的变量。默认情况下，内核函数内部未声明任何地址空间限定符（如：`__global`、`__local`
    或 `__constant`）的变量被标记为 `__private`；这包括所有非内核函数和函数参数中的所有变量。以下来自 `Ch3/vectorization/vectorization.cl`
    的内核代码将说明全局和私有内存空间，其中变量 `id`、`index` 和 `t` 位于私有内存空间，因此对其他工作项不可见，因此不受干扰，而变量 `in`
    和 `out` 位于全局内存空间，对所有工作项可见：'
- en: '[PRE29]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works…
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The following diagram illustrates the OpenCL programming model:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示说明了 OpenCL 编程模型：
- en: '![How it works…](img/4520OT_03_04.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/4520OT_03_04.jpg)'
- en: Let's use the preceding diagram to understand how your kernel will function
    in OpenCL. Imagine you have a kernel named `doCompute` that takes several arguments
    that reference the global, constant, local, or private memory spaces. Work and
    data is divided among the kernels across the compute units represented by the
    W[0…4]; they would represent either work groups (collection of work items) or
    work items.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用前面的图示来了解您的内核在 OpenCL 中的工作方式。想象您有一个名为 `doCompute` 的内核，它接受几个参数，这些参数引用全局、常量、局部或私有内存空间。工作和数据在由
    W[0…4] 表示的计算单元之间的内核中划分；它们将代表工作组（工作项集合）或工作项。
- en: Typically, computing in OpenCL often either involves individual work items performing
    the computation independently via the global, private, or constant spaces, or
    collecting these work items to form a work group so that they can load and store
    data more efficiently via utilizing the local memory space since that space allows
    sharing of data across all work items in the work group hence, preventing multiple
    memory loads from device memory.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在 OpenCL 中的计算通常涉及单个工作项通过全局、私有或常量空间独立执行计算，或者收集这些工作项以形成一个工作组，这样它们就可以通过利用局部内存空间更有效地加载数据和存储数据，因为该空间允许工作组中所有工作项之间共享数据，从而防止从设备内存进行多次内存加载。
- en: Configuring your OpenCL projects to enable the double data type
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置您的 OpenCL 项目以启用双精度数据类型
- en: Today's modern processors from Intel, AMD, and ARM have their floating-point
    units (FPUs) IEEE 754 compliant; however, ARM has both hardware and software support
    for half-precision numbers in addition to single-precision and double-precision
    numbers. Hence this implies that your OpenCL programs can actually utilize half-precision
    on ARM-based processors and this raise a question on how can one determine what
    sort of floating-point support does the device have.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，来自 Intel、AMD 和 ARM 的现代处理器都拥有符合 IEEE 754 标准的浮点单元（FPUs）；然而，ARM 除了支持单精度和双精度数字外，还支持硬件和软件对半精度数字的支持。因此，这意味着您的
    OpenCL 程序实际上可以在基于 ARM 的处理器上利用半精度，这引发了一个问题：如何确定设备具有哪种类型的浮点支持。
- en: 'The answer to that question is to query the device via the `clGetDeviceInfo`
    API and passing in any of the following parameters: `CL_DEVICE_SINGLE_FP_CONFIG`,
    `CL_DEVICE_DOUBLE_FP_CONFIG`, and `CL_DEVICE_HALF_FP_CONFIG` which identifies
    whether the device supports single-precision, double-precision, or half-precision
    number operations.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的答案是，通过 `clGetDeviceInfo` API 查询设备，并传递以下任何参数：`CL_DEVICE_SINGLE_FP_CONFIG`、`CL_DEVICE_DOUBLE_FP_CONFIG`
    和 `CL_DEVICE_HALF_FP_CONFIG`，这些参数标识设备是否支持单精度、双精度或半精度数字操作。
- en: Tip
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '`CL_DEVICE_HALF_FP_CONFIG` and `CL_DEVICE_DOUBLE_FP_CONFIG` are not supported
    on Mac OSX 10.6 for OpenCL 1.0.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`CL_DEVICE_HALF_FP_CONFIG` 和 `CL_DEVICE_DOUBLE_FP_CONFIG` 在 OpenCL 1.0 的 Mac
    OSX 10.6 上不受支持。'
- en: The result of API invocation returns an object of `cl_device_fp_config` type.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: API 调用结果返回一个 `cl_device_fp_config` 类型的对象。
- en: Tip
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: At the time of this writing, `CL_FP_SOFT_FLOAT` was not available on Mac OSX
    10.6, but available on AMD APP SDK v2.7 and Intel OpenCL SDK.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，`CL_FP_SOFT_FLOAT` 在 Mac OSX 10.6 上不可用，但在 AMD APP SDK v2.7 和 Intel OpenCL
    SDK 中可用。
- en: In the case of the double-precision floating-point values, the OpenCL device
    extension, `cl_khr_fp64`, needs to be present before you can utilize the `double`
    data type in the kernel. As of OpenCL 1.2, the developer no longer has to query
    the device's extensions to verify the existence of the double-precision floating-point
    support, and we'll explain what you'll need to do in this case in the later part
    of this recipe.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在双精度浮点值的情况下，OpenCL设备扩展 `cl_khr_fp64` 必须存在，你才能在内核中使用 `double` 数据类型。截至OpenCL 1.2，开发者不再需要查询设备的扩展来验证双精度浮点数支持的存在，我们将在本食谱的后续部分解释在这种情况下你需要做什么。
- en: Tip
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: As of OpenCL 1.1, the working committee does not mandate the support of the
    `double` data type except through the OpenCL 1.1 device extension `cl_khr_fp64`.
    If you are using AMD devices, you should know that AMD provides an extension that
    implements a subset of `cl_khr_fp64` and is known as `cl_amd_fp64`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 OpenCL 1.1，工作委员会没有强制要求通过 OpenCL 1.1 设备扩展 `cl_khr_fp64` 支持双精度数据类型。如果你使用AMD设备，你应该知道AMD提供了一个实现
    `cl_khr_fp64` 子集的扩展，称为 `cl_amd_fp64`。
- en: Let's understand this with a simple example.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个简单的例子来理解这一点。
- en: Getting ready
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In the upcoming example, the goal of the example is to illustrate the use of
    a `double` data type to hold the intermediate result of adding two `floats`, after
    which we send this `double` to be stored as a `float` in a result array. Take
    note that you cannot use the `double` type in the kernel code if the extension
    `cl_khr_fp64` or `cl_amd_fp64` (for AMD devices) is enabled.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在即将到来的例子中，例子的目标是说明使用 `double` 数据类型来保存两个 `float` 相加的中间结果，然后我们将这个 `double` 发送到结果数组中作为
    `float` 存储起来。请注意，如果启用了扩展 `cl_khr_fp64` 或 `cl_amd_fp64`（对于AMD设备），则不能在内核代码中使用 `double`
    类型。
- en: The two test machines involved have `cl_khr_fp64` supported on the Intel Core
    i7 processor and a NVIDIA GPU but the ATI 6870x2 GPU doesn't support `cl_khr_fp64`
    or `cl_amd_fp64`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及的两个测试机器在英特尔酷睿i7处理器和NVIDIA GPU上支持 `cl_khr_fp64`，但ATI 6870x2 GPU不支持 `cl_khr_fp64`
    或 `cl_amd_fp64`。
- en: How to do it…
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Following is the code excerpt from `Ch3/double_support/double_support.cl`,
    which illustrates the kernel code:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从 `Ch3/double_support/double_support.cl` 文件中摘录的代码片段，它说明了内核代码：
- en: '[PRE30]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, is the code snippet from `Ch3/double_support/double_support.c`, where
    it shows how to set the kernel arguments to the function `add3`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，是从 `Ch3/double_support/double_support.c` 文件中摘录的代码片段，其中展示了如何将内核参数设置到 `add3`
    函数中：
- en: '[PRE31]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: To build the program with `CMake`, navigate to the directory `Ch3/double_support`,
    and enter `make`. It should drop a nice binary named `DoubleSupport` upon which
    you can execute it to observe the results. On both the test machines, the results
    for a small run, that is, 64-floating-point values are good with the runs on CPU
    and GPU.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `CMake` 构建程序，请导航到 `Ch3/double_support` 目录，并输入 `make`。它应该会生成一个名为 `DoubleSupport`
    的二进制文件，你可以执行它来观察结果。在两个测试机器上，小规模运行的结果，即64个浮点值，在CPU和GPU上的运行都是好的。
- en: '[PRE32]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The code in this example was constructed in such a manner that even if `double`
    wasn't supported the program will run. Upon inspecting the code, you will realize
    that its use case was to hold the result of adding two `float` values (which by
    intention will not overflow) but in other situations, you might want to use `double`s,
    and the conditional-directives, that is, `#ifdef`, `#else`, and `#endif` used
    to check for the presence of double floating-point support for the device and
    it is a standard technique.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，代码的构建方式是这样的，即使不支持 `double`，程序也能运行。在检查代码时，你会发现它的用例是保存两个 `float` 值相加的结果（有意不会溢出），但在其他情况下，你可能想使用
    `double`，即使用条件指令，也就是 `#ifdef`、`#else` 和 `#endif` 来检查设备是否支持双精度浮点数，这是一个标准技术。
- en: How it works...
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The type, `cl_device_fp_config` is actually composed of several values (shown
    in the following table) and you can determine whether a particular feature is
    supported or not by performing a bitwise-AND operation and for example, if we
    wish to determine which rounding modes are supported in double-precision operations
    then, we will have the following code:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 `cl_device_fp_config` 实际上由几个值组成（如下表所示），你可以通过执行位与操作来确定某个特性是否受支持。例如，如果我们想确定双精度操作中支持哪些舍入模式，那么我们将有以下的代码：
- en: '[PRE33]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '| Parameter | float | double | half |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | float | double | half |'
- en: '| --- | --- | --- | --- |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `CL_FP_DENORM` | Optional | Supported | Optional |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `CL_FP_DENORM` | 可选 | 支持 | 可选 |'
- en: '| `CL_FP_INF_NAN` | Supported | Supported | Supported |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `CL_FP_INF_NAN` | 支持 | 支持 | 支持 |'
- en: '| `CL_FP_ROUND_TO_NEAREST` | Supported | Supported | Optional |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `CL_FP_ROUND_TO_NEAREST` | 支持 | 支持 | 可选 |'
- en: '| `CL_FP_ROUND_TO_ZERO` | Optional | Supported | Supported |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `CL_FP_ROUND_TO_ZERO` | 可选 | 支持 | 支持 |'
- en: '| `CL_FP_ROUND_TO_INF` | Optional | Supported | Supported |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `CL_FP_ROUND_TO_INF` | 可选 | 支持 | 支持 |'
- en: '| `CL_FP_FMA` | Optional | Supported | Optional |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `CL_FP_FMA` | 可选 | 支持 | 可选 |'
- en: '| `CL_FP_SOFT_FLOAT` | Optional | Optional | Optional |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `CL_FP_SOFT_FLOAT` | 可选 | 可选 | 可选 |'
- en: 'For those who are inclined to use OpenCL 1.2, the specification has made double-precision
    an optional feature instead of an extension, and this means that instead of checking
    for the existence of the extensions `cl_khr_fp64` or `cl_amd_fp64` in the device,
    you will simply check that the returned value of the call to `clGetDeviceInfo`
    when passed the parameter `CL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE` and `CL_DEVICE_NATIVE_VECTOR_WIDTH`
    must be equal to `1` if the device were to support double-precision. The following
    code snippet illustrates how to check for the preferred native vector width size
    for built-in scalar types that can be put into vectors:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 对于倾向于使用 OpenCL 1.2 的人来说，规范已将双精度作为一个可选特性而不是扩展，这意味着你不需要检查设备是否存在扩展 `cl_khr_fp64`
    或 `cl_amd_fp64`，你只需检查当传递参数 `CL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE` 和 `CL_DEVICE_NATIVE_VECTOR_WIDTH`
    给 `clGetDeviceInfo` 函数时返回的值，如果设备支持双精度，则该值必须等于 `1`。以下代码片段说明了如何检查内置标量类型可以放入向量的首选原生向量宽度大小：
- en: '[PRE34]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
