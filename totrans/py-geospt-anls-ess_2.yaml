- en: Chapter 2. Geospatial Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will focus on the data used for geospatial analysis. You
    will learn more about the nature of geospatial data, and discover some of the
    major websites you can use to obtain geospatial datasets for free. We will then
    look at the ways in which you can read and write geospatial data using Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, this chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why having high quality geospatial data is important
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The various types of geospatial data you are likely to encounter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Major sources of freely-available geospatial datasets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to read and write geospatial data using the GDAL/OGR library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to work with Spatial Reference Systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Geospatial data errors and how to fix them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by looking at why having high-quality geospatial data is important.
  prefs: []
  type: TYPE_NORMAL
- en: Geospatial data quality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine that you are writing a program where you need to display the location
    of each city and town on top of a raster basemap. You dutifully obtain a nice
    raster datasource to use for the basemap, and then search the Internet for a source
    of city and town data. You choose the **National Geospatial Intelligence Service**
    (**NGIS**) website to download a database of place names, which you then draw
    onto your map. This database includes, among other things, the latitude and longitude
    of each place name:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Location | Latitude | Longitude |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Abache | 7.3551 | 7.6407 |'
  prefs: []
  type: TYPE_TB
- en: '| Abacheke | 5.50372 | 6.729519 |'
  prefs: []
  type: TYPE_TB
- en: '| Abacher | 13.816667 | 20.816667 |'
  prefs: []
  type: TYPE_TB
- en: '| Abacheri | 14.183333 | 41.5 |'
  prefs: []
  type: TYPE_TB
- en: '| Abachi | 7.3551 | 7.6407 |'
  prefs: []
  type: TYPE_TB
- en: '| ...and so on |   |   |'
  prefs: []
  type: TYPE_TB
- en: 'So far so good, but when your program is complete, the locations look suspiciously
    regular when the user zooms in on your map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Geospatial data quality](img/B04102_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you were to draw a grid on top of this map, you can see exactly what the
    problem is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Geospatial data quality](img/B04102_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the locations are regularly spaced—despite there being lots
    of precision in the latitude and longitude values, they are actually only accurate
    to about two decimal places. In the previous image, which shows part of the Netherlands,
    this can misplace the location by almost a kilometer.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is just one example of the type of thing that can go wrong if you don''t
    use high-quality geospatial data. Another example often crops up when performing
    **point-in-polygon** calculations—that is, when attempting to decide if a given
    point is inside or outside a given polygon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Geospatial data quality](img/B04102_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If the polygon represents, for example, the outline of a country, then you can
    use a point-in-polygon calculation to see if the given location is inside the
    country's border. This is often used to **geolocate** a given point (that is,
    match a point with one or more known locations).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when you attempt to geolocate a point that is close to the edge of the
    polygon, you can easily end up with geolocation errors if your polygons are not
    sufficiently detailed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Geospatial data quality](img/B04102_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding image, the dot represents a point to be geolocated. This point
    is a valid location within San Francisco, but because the polygon is not detailed
    enough, the point is outside the San Francisco city polygon, and so the geolocation
    fails.
  prefs: []
  type: TYPE_NORMAL
- en: This problem is particularly acute when using polygons that cover larger areas,
    such as state or country outlines. Because of the size of the polygon in these
    cases, precision is often sacrificed.
  prefs: []
  type: TYPE_NORMAL
- en: You might think that the answer to this problem is to have a more detailed polygon—that
    is, to use more points to make up the polygon's outline so that it more accurately
    represents the desired outline (in this case, the San Francisco coastline). However,
    more detail is not always better. The more detailed a polygon is, the longer it
    will take to process—and if there are too many points, your program might crash
    because of the excessive amount of data that you are trying to process.
  prefs: []
  type: TYPE_NORMAL
- en: There are ways to solve this problem; for example, by breaking large polygons
    into smaller pieces, or by **buffering** the polygon to include points close to
    the edge. But the important thing to realize is that high-quality data does not
    always mean highly precise data; it means data that is *appropriate* to the purpose
    you want to use it for.
  prefs: []
  type: TYPE_NORMAL
- en: We will now continue our exploration of geospatial concepts by looking at the
    various types of geospatial data you are likely to encounter.
  prefs: []
  type: TYPE_NORMAL
- en: Types of geospatial data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked briefly at some of the more common formats
    used to store and transfer raster and vector geospatial data. Let's now look at
    some of the more important types of geospatial data you are likely to encounter.
  prefs: []
  type: TYPE_NORMAL
- en: Shapefiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we saw in the previous chapter, a shapefile is a collection of files on
    disk, which together hold a set of geospatial features along with their attributes
    and geometries. For example, the following illustration shows the data stored
    in a typical shapefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shapefiles](img/B04102_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because the shapefile format has been around for many years, and dates back
    to the dBase days, a single shapefile is made up of several individual files.
    Typically, these files are combined into a ZIP archive for distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Shapefiles are hugely popular because they make it so easy to store and distribute
    geospatial data. Practically every GIS system and library that works with geospatial
    data is able to understand the shapefile format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Shapefiles, however, do have some disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike almost every other geospatial data format, the names of the attributes
    within a shapefile are case sensitive. This can cause problems when your code
    works with data in another format (for example, in a database), but suddenly stops
    when you attempt to access the attributes within a shapefile.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the geometries stored in a single shapefile must be of the same type. This
    means, for example, that you can't have some features represented by a line while
    other features are represented by points. More seriously, this causes problems
    when working with composite geometries such as MultiLines or MultiPolygons, or
    when attempting to store geometry collections within a shapefile.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While shapefiles allow you to read through the features sequentially, there
    is generally no support for spatial indexing. This means that you cannot perform
    searches based on a feature's position on the Earth's surface. For example, answering
    questions such as "which countries are within 1,000 km of London?" requires you
    to check each feature in turn, which is not particularly efficient.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Well-known text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **well-known text** (**WKT**) format is not generally used to store geospatial
    data. Instead, it is used to transfer geometries from one format to another. We
    saw an example of this in the previous chapter, where we extracted a geometry
    using the OGR library, and then converted it into WKT so that we could recreate
    it as a Shapely geometry object.
  prefs: []
  type: TYPE_NORMAL
- en: 'WKT is a very compact and easy-to-use format. For example, the following WKT
    string defines a point geometry in the middle of Central Park in New York City:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the point is represented as an *x* (longitude) value, a single
    space, and then the *y* (latitude) value. The same general format is used to represent
    the coordinates of a polygon. For example, the following is a polygon in WKT format,
    this time defining the approximate outline of Central Park:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Apart from using WKT to transfer data between different systems and libraries,
    you will also find WKT strings handy when you need to quickly hardwire a geometry
    into your Python code. For example, the following code shows how you could quickly
    create a Shapely polygon for testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The WKT format is also useful if you want to store geometry data in a text file,
    for example to temporarily save the output of your analysis to disk so you can
    load it into another program for further processing.
  prefs: []
  type: TYPE_NORMAL
- en: Well-known binary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **well-known binary** (**WKB**) format is the binary equivalent of WKT.
    WKB is generally only used to transfer and store geospatial data within a database.
    In the WKB format, the coordinates are stored as double-precision floating-point
    numbers, and numeric codes are used to represent the type of geometry. This format
    is quicker for a computer to read and write than WKT, though of course the format
    can't be comprehended easily by a human.
  prefs: []
  type: TYPE_NORMAL
- en: Spatial databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just as ordinary databases are used to store large amounts of data and let users
    make efficient queries against that data, a **spatial database** is a database
    which is designed to store geometries and perform efficient queries based on each
    geometry's position in space. For example, you could quickly find all road traffic
    incidents that occurred within 20 miles of a given point, or find the closest
    island to your current location.
  prefs: []
  type: TYPE_NORMAL
- en: '![Spatial databases](img/B04102_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting up and using a spatial database is a rather complex task. There are
    several different types of spatial database available. Among the freely available
    options, the lightweight **SpatiaLite** database and the powerful-but-complex
    **PostGIS** database are the most popular choices.
  prefs: []
  type: TYPE_NORMAL
- en: After creating a database, you will have to configure the database to work with
    spatial data. You will also need to use the database's own syntax to store and
    query your spatial data—how you do this will vary depending on which database
    you use.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of the type of database you are using, attempting to retrieve a spatial
    geometry will generally return either a WKT format string, or raw binary data
    in WKB format. You can then convert these into a different format (for example,
    a Shapely geometry object) for processing.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, with the power available in a spatial database, and particularly
    the spatial manipulation and query functions built into PostGIS, you may not need
    to do any spatial analysis beyond what is possible within the database itself.
    For example, once you have asked the database to identify all the road traffic
    incidents within a given radius, you would generally just retrieve non-spatial
    information about each of these incidents. All of the spatial processing is done
    within the database itself, and once you have found the desired set of records,
    you would retrieve and work with the results just like you would in a non-spatial
    database.
  prefs: []
  type: TYPE_NORMAL
- en: We will return to the topic of spatial databases in [Chapter 3](ch03.html "Chapter 3. Spatial
    Databases"), *Spatial Databases*.
  prefs: []
  type: TYPE_NORMAL
- en: Geospatial microformats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The so-called **geospatial microformats** are typically used by APIs to send
    and receive geospatial data. Various companies and organizations have defined
    their own standards for transmitting geospatial data, and so a number of common
    formats have been developed over time. If you use an API that uses one of these
    microformats, you will need to become familiar with these data formats.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two geospatial microformats that we will look at here: **GeoJSON**
    and **GML**.'
  prefs: []
  type: TYPE_NORMAL
- en: GeoJSON
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'GeoJSON ([http://geojson.org](http://geojson.org)) is an open standard used
    to represent geospatial data structures as **JavaScript Object Notation** (**JSON**)
    objects. For example, the following GeoJSON-format string is used to represent
    a point geometry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Because GeoJSON is built on top of the JSON standard, you can use the `json`
    standard Python library to convert between GeoJSON-formatted strings and Python
    dictionaries. This makes it particularly easy to use GeoJSON in your Python programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The GeoJSON standard includes support for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Representing any standard geometry object (Point, LineString, Polygon, MultiPoint,
    MultiLineString, MultiPolygon and GeometryCollection) as a GeoJSON string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing a feature as a GeoJSON string, including the feature's geometry, any
    number of attributes (called **properties** in GeoJSON), and an optional spatial
    reference system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using existing XML schemas and processing tools. Because the GML format is based
    on XML, you can use existing XML parsers and validators to process GML data. You
    can also create an application-specific XML schema, defining your own extensions
    to the GML standard, and then use existing XML libraries to work with that schema.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GeoJSON format is widely supported by software that works with geospatial
    data. Indeed, the GDAL/OGR library includes support for reading and writing GeoJSON-format
    data, as does the Mapnik library we will be using later on to generate maps.
  prefs: []
  type: TYPE_NORMAL
- en: GML
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Geography Markup Language** (**GML**) is an XML-based format to store geometries
    and features in textual form. GML is a complex and sophisticated standard. Because
    it is based on XML, GML-formatted data tends to be quite verbose. For example,
    the following GML string represents a minimal point geometry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'GML includes support for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Representing point, LineString, and polygon geometries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Version 3.0 of the GML standard adds support for raster-format data.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Defining features, and storing attributes for each feature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Associating more than one geometry with each feature; for example, a feature
    may have an outline, a bounding box, and a centroid, all defined as geometries
    associated with the feature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the spatial reference system used by the geometry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profiles that allow you to use a subset of the GML standard for particular sets
    of data; for example, the GML Simple Features Profile limits the data to representing
    geometries and their associated properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using existing XML schemas and processing tools because the GML format is based
    on XML; for example, you could define an application-specific XML schema defining
    your own extensions to the GML standard, and then use XML parsers and validators
    on your GML data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GML standard was developed by the **Open Geospatial Consortium** (**OGC**),
    and has now been accepted as an ISO standard. GML is heavily used by the various
    web standards defined by the OGC, and you will use GML whenever you want to access
    an API that follows one of these standards, such as the Web Features Service.
  prefs: []
  type: TYPE_NORMAL
- en: Digital elevation models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **Digital Elevation Model** (**DEM**) is a fascinating way of representing
    the curves and contours of the Earth''s surface as raster-format data. As we mentioned
    in the previous chapter, raster-format geospatial data divides the world up into
    **cells** and associates information with each cell. In a DEM, each cell contains
    information about the elevation of the Earth''s surface at that point. For example,
    consider the following elevation data, taken from a typical DEM file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This data is extracted from a DEM file for Forked Horn Butte, Oregon. Each
    number measures the elevation above sea level, in feet. If these elevation values
    are plotted in three dimensions, the shape of the Earth''s surface is revealed,
    as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Digital elevation models](img/B04102_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is only a tiny part of the overall DEM file, but it does show you how DEM
    files encode the shape of the Earth's surface.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: DEM files also have what is called a **no-data value**. This is a special height
    value that indicates that there is no elevation value at that point. No-data values
    are used where you don't want to record or show an elevation value for certain
    parts of the DEM. For example, a country-specific DEM file would use the no-data
    value for all areas beyond that country's border.
  prefs: []
  type: TYPE_NORMAL
- en: 'A digital elevation model is often used as a building-block to construct useful
    images of the Earth''s surface. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: Different colors can be associated with different height bands, using a technique
    called **color mapping**. If the right set of colors is selected, the result can
    almost look like a photograph showing different bands of vegetation, bare earth,
    rock, and snow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **shaded relief** image can be generated from the elevation data. This mimics
    the effect of having a light source (such as the sun) shine onto the Earth's surface,
    revealing depth and creating shadows and highlights so that the generated image
    looks almost like a photograph of the Earth taken from space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Contour lines** can be generated by smoothing the DEM data and running it
    through a program such as `gdal_contour`, which is provided as part of the GDAL
    library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Often, several of these generated images are merged to produce a more realistic-looking
    effect. These derived images are then used as background maps upon which geospatial
    data is overlaid.
  prefs: []
  type: TYPE_NORMAL
- en: Raster basemaps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rather than constructing your images from a DEM file, you can use pre-generated
    images for your basemaps. These basemaps are often very sophisticated. For example,
    underwater areas may be drawn using a color map in varying shades of blue to indicate
    the depth of the water, while the area above sea level is drawn using shaded relief
    imagery combined with vegetation and elevation-based coloring to produce a realistic-looking
    effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows a typical basemap of this type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Raster basemaps](img/B04102_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: These basemaps are simply image files with associated georeferencing information.
    The georeferencing information identifies the area of the Earth covered by the
    basemap. This is often done by specifying the latitude and longitude for the top-left
    and bottom-right corners of the image. Using these points, it is possible to position
    the image accurately on the Earth's surface, allowing geospatial data to be drawn
    in the correct position on top of the basemap, and also allowing the correct part
    of the basemap to be drawn based on which area of the Earth's surface you wish
    to display.
  prefs: []
  type: TYPE_NORMAL
- en: Multiband raster files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned in the previous chapter, raster-format geospatial data can store
    more than just images. The raster information might consist of values such as
    the elevation (as we saw earlier in the section on Digital Elevation Models),
    soil type, average rainfall, population density, and the like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Raster-format data files are not limited to storing just one piece of information.
    A single file can hold multiple **bands** of raster data, as shown in the following
    illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Multiband raster files](img/B04102_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Every band has a value for each cell, so for a given (x, y) location, band 1
    will hold a value, band 2 will hold a value, and so on. The meaning of the values
    stored in each band depends entirely on the raster file you are using; you will
    need to refer to the documentation for that raster file to see what is being stored
    in each band.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, the multiple bands can be combined to produce a color. For example,
    you can download raster data captured by Landsat satellites (see [http://landsatlook.usgs.gov](http://landsatlook.usgs.gov)
    for details) that includes a red, green and blue color component in three separate
    bands. Additional bands contain infrared and *panchromatic* values, which can
    also be useful in certain circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: Sources of freely available geospatial data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you understand the importance of having the appropriate geospatial
    data and have learned about the major types of data that you will want to use,
    let's look at some of the places where you can obtain the data you'll need.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some situations where you may need to purchase geospatial datasets.
    One example of this is when looking for ZIP code boundaries in the USA; this information
    is proprietary to the US Postal Service (USPS), and accurate versions can only
    be obtained by purchasing a suitable dataset from a vendor licensed by the USPS
    to sell this data. However, this is the exception: in almost every other case,
    you can obtain, modify, and use geospatial data for free.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's now take a look at some of the major websites you will want to use when
    looking for geospatial data.
  prefs: []
  type: TYPE_NORMAL
- en: Natural Earth Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Natural Earth Data website ([http://naturalearthdata.com](http://naturalearthdata.com))
    is a comprehensive source of high-quality and freely available geospatial data.
    In terms of vector-format data, files are provided in high, medium, and low resolutions.
    Two different types of vector data are provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cultural data**: This includes polygons for country, state or province, urban
    areas, and park outlines, as well as point and LineString data for populated places,
    roads, and railways.![Natural Earth Data](img/4102_02_10.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Physical data**: This includes polygons and LineStrings for land masses,
    coastlines, oceans, minor islands, reefs, rivers, and lakes.![Natural Earth Data](img/B04102_02_11.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In terms of raster-format data, Natural Earth Data provides five different types
    of raster basemaps at both 1:10 million and 1:50 million scale.
  prefs: []
  type: TYPE_NORMAL
- en: '![Natural Earth Data](img/B04102_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: These image files are provided as georeferenced TIFF images, making it easy
    to use them as raster basemaps in your Python programs.
  prefs: []
  type: TYPE_NORMAL
- en: OpenStreetMap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'OpenStreetMap ([http://openstreetmap.org](http://openstreetmap.org)) is a huge
    collaborative effort to create and make available geospatial map data. The website
    describes it as a "free editable map of the whole world made by people like you".
    It has positioned itself as a direct competitor to Google Maps. The following
    image shows part of the street map for the city of Rotorua, New Zealand, based
    on data from OpenStreetMap:'
  prefs: []
  type: TYPE_NORMAL
- en: '![OpenStreetMap](img/B04102_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Unfortunately, OpenStreetMap uses its own XML-based format to store geospatial
    data. If you want, you can download the entire OpenStreetMap database, called
    `Planet.osm`, and then use a spatial database to access this information. In most
    cases, however, you will want to use an extract from the OpenStreetMap database,
    already converted into a more standard format such as a shapefile.
  prefs: []
  type: TYPE_NORMAL
- en: You can find a list of sites that provide OpenStreetMap data extracts at [http://wiki.openstreetmap.org/wiki/Planet.osm#Country_and_area_extracts](http://wiki.openstreetmap.org/wiki/Planet.osm#Country_and_area_extracts).
  prefs: []
  type: TYPE_NORMAL
- en: OpenStreetMap can be very useful if you want to manipulate street maps, or use
    a street map as the backdrop to display other geospatial data.
  prefs: []
  type: TYPE_NORMAL
- en: US Census Bureau
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The United States Census Bureau has made available a large amount of geospatial
    data under the name **TIGER** (**Topologically Integrated Geographic Encoding
    and Referencing System**). The TIGER datasets include streets, railways, rivers,
    lakes, geographic boundaries, and legal and statistical areas, such as states,
    school districts, and urban boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: TIGER data is available in shapefile format, and can be downloaded from [http://www.census.gov/geo/maps-data/data/tiger.html](http://www.census.gov/geo/maps-data/data/tiger.html).
  prefs: []
  type: TYPE_NORMAL
- en: Because it is produced by the US Government, TIGER data only covers the United
    States and its protectorates (that is, Puerto Rico, American Samoa, the Northern
    Mariana Islands, Guam, and the US Virgin Islands). For these areas, however, TIGER
    is an excellent source of accurate geospatial data.
  prefs: []
  type: TYPE_NORMAL
- en: World Borders Dataset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We used this dataset in the previous chapter. While it is very simple, the World
    Borders Dataset ([http://thematicmapping.org/downloads/world_borders.php](http://thematicmapping.org/downloads/world_borders.php))
    provides useful country outlines in the form of a shapefile. The shapefile includes
    attributes for the name of the country, relevant ISO, FIPS, and UN identification
    codes, a UN-based region and subregion classification, and the country's population
    and land area.
  prefs: []
  type: TYPE_NORMAL
- en: The simplicity of the World Borders Dataset makes it an attractive choice for
    many geospatial applications that need a basic map of the entire world.
  prefs: []
  type: TYPE_NORMAL
- en: GLOBE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Global Land One-Kilometer Base Elevation** (**GLOBE**) dataset is an international
    effort to produce high-quality, medium-resolution DEM data covering the entire
    world. Each cell within the raster DEM file represents the elevation of a square
    on the Earth's surface which is 30 arc-seconds of longitude and 30 arc-seconds
    of latitude. This equates to a square measuring approximately one kilometer on
    each side.
  prefs: []
  type: TYPE_NORMAL
- en: The main website of the GLOBE project can be found at [http://www.ngdc.noaa.gov/mgg/topo/globe.html](http://www.ngdc.noaa.gov/mgg/topo/globe.html).
    Note that if you download one of the premade "tiles" covering an area of the Earth's
    surface, you will also need to download the associated header (`.hdr`) file that
    georeferences the DEM data. These header files can be downloaded from [http://www.ngdc.noaa.gov/mgg/topo/elev/esri/hdr](http://www.ngdc.noaa.gov/mgg/topo/elev/esri/hdr).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since we are going to need some sample DEM data later in this chapter, go ahead
    and download the `E` tile now. Then go to the link provided to download the associated
    header file. You should end up with two files, named `e10g` and `e10g.hdr`.
  prefs: []
  type: TYPE_NORMAL
- en: National Elevation Dataset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The National Elevation Dataset ([http://ned.usgs.gov](http://ned.usgs.gov))
    provides high-resolution DEM data for the Continental United States, Alaska, Hawaii,
    and other US territories. Depending on the area you are looking at, each cell
    in the DEM dataset corresponds to an area of between 3 and 60 meters square. This
    is much higher resolution than the 1 kilometer squares used by the GLOBE project.
  prefs: []
  type: TYPE_NORMAL
- en: The National Elevation Dataset is an excellent choice if you want to produce
    your own shaded relief basemaps for the USA. All the files are available in a
    variety of formats, including GeoTIFF and ArcGRID, both of which can be processed
    using GDAL.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing geospatial data using Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we will be using the GDAL/OGR library to access geospatial data, let's
    take a closer look at how you can read and write both vector-format and raster-format
    data using this library.
  prefs: []
  type: TYPE_NORMAL
- en: Reading vector data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous chapter, we wrote a simple program that reads the features
    out of a shapefile. Here is a copy of that program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a closer look at how this program works, and more generally, how
    to read vector-format data using the OGR library.
  prefs: []
  type: TYPE_NORMAL
- en: 'When reading geospatial data, the `osgeo.ogr.Open()` function takes just a
    single parameter: the name of the dataset to open. The OGR library loops through
    all of the different drivers it supports until it finds one that is able to read
    this dataset. The driver then creates a new `OGRDataSource` object that provides
    access to the contents of that dataset, and the `Open()` function returns this
    object to the caller.'
  prefs: []
  type: TYPE_NORMAL
- en: All of this has the effect of setting the `shapefile` variable to the OGR datasource.
    The OGR datasource consists of one or more **layers**, each representing a distinct
    set of data. For example, a **Countries** datasource may have a layer for the
    country's terrain, a layer containing roads, another layer with the country's
    city boundaries, another for regional borders, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that shapefiles can only have a single layer. To represent these different
    pieces of information using shapefiles, you would have to have a separate shapefile
    for each of these different pieces of data.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding code sample, you use the `GetLayer()` method
    to retrieve a layer from the datasource; the returned object is an instance of
    the `OGRLayer` class. There is also a handy `GetLayerCount()` method which returns
    the number of layers in the datasource.
  prefs: []
  type: TYPE_NORMAL
- en: Each layer has a **spatial reference system** that tells you how to interpret
    the individual coordinates within the layer, as well as a list of **features**
    containing the actual data. Don't worry if you don't know what a spatial reference
    system is; you will learn all about this in the *Dealing with spatial reference
    systems* section later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We can iterate over the various features within the layer using the `GetFeatureCount()`
    and `GetFeature()` methods. As you might expect, each feature is represented by
    an instance of the `ogr.Feature` class.
  prefs: []
  type: TYPE_NORMAL
- en: Each feature has a unique **ID**, which can be retrieved using the `GetFID()`
    method, as well as a **geometry** and a list of **attributes**. We retrieve the
    geometry (an instance of `OGRGeometry`) using the `GetGeometryRef()` method, and
    we can access the feature's attributes using the `GetField()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using these various classes and methods, you can iterate over the various features
    within a vector datasource, retrieving the geometry and attributes (as well as
    the ID) for each feature in turn. The wonderful thing about all this, though,
    is that it doesn''t matter what format your data is in: you use exactly the same
    process to read data out of a shapefile as you would use to read it from a spatial
    database using the OGR library''s PostGIS database driver. The OGR library hides
    all the details of how to read different data formats, and gives you a simple
    high-level interface to read vector-format data from any datasource.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing vector data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Writing geospatial data to a vector-format file is almost as simple as reading
    it. There are, however, a couple of extra steps you have to take. Let's write
    a simple Python program that creates a shapefile and then saves some example data
    into it. This program will teach you all the things you need to know about writing
    vector-format data using OGR.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a vector-format dataset using OGR involves the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create the destination file by selecting an OGR driver and telling
    that driver to create the new datasource:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then create a **spatial reference** object that defines how the coordinates
    in the dataset should be interpreted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we use the `osr` module to define a spatial reference, and then
    set it to the "well-known" spatial reference with the code `WGS84`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: WGS84 is the standard used for latitude and longitude values. We will look at
    this in detail in the section on *Dealing with spatial reference systems* later
    in this chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We then add a layer to the destination file to hold the layer''s data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, each layer has its own spatial reference, so we have to pass
    the spatial reference we defined earlier when we create the layer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is to define the various attributes that the destination file
    will store for each feature. Let''s define a field called `NAME`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that we define the field name in uppercase. This is because we are writing
    to a shapefile, which has case-sensitive attribute names and typically defines
    the attributes in uppercase. Using the uppercase attribute names in shapefiles
    will help avoid problems later on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This completes the creation of the file itself. Now let''s make up some example
    data and save it into the file. This involves the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define a simple polygon to represent the feature''s geometry. We''ll
    use the WKT format to make this easy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We next create the OGR `Feature` object that will represent the feature, and
    set the geometry and attributes as desired:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can then add the feature to the layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice the call to `feature.Destroy()`. This may seem odd, but this releases
    the memory used by the feature, which also happens to write the feature's details
    into the shapefile.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we close the destination file by calling the `Destroy()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This closes the destination file and makes sure that everything has been saved
    to disk.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As with reading vector-format data, this code isn't limited to just creating
    a shapefile. OGR allows you to create geospatial data in many different formats,
    and you use the same classes and method names no matter what format you are using.
  prefs: []
  type: TYPE_NORMAL
- en: Reading raster data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To read raster-format geospatial data, you use the GDAL library. Let's see how
    this is done using the DEM data from the `E` tile we downloaded earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure the `e10g` and `e10g.hdr` files are both in a convenient directory,
    and then create a Python script in the same directory. We''ll start by entering
    the following in this script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we use the `gdal.Open()` function to open the raster data file.
    As we mentioned earlier, a raster datasource can consist of multiple bands of
    data. To see how many bands there are in the file, you can use `RasterCount`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'For this DEM file, there is only one band; we''ll get a reference to this band
    using the `GetRasterBand()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that band numbers start at 1, rather than the usual 0\. The result is
    a `gdal.Band` object. While you can use various methods of the Band class to read
    the contents of the raster band as raw sequences of bytes, the easiest way to
    extract the data from the raster band is to convert it into a NumPy array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NumPy is automatically installed if you use the Mac OS X installer for GDAL.
    On other platforms, you may need to install it yourself. NumPy can be found at
    [http://numpy.org](http://numpy.org).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then use the NumPy array-handling methods to extract the data from
    this array. To see how this is done, let''s read through the array and calculate
    a histogram of elevation values from the DEM data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, reading data out of a NumPy array is quite easy.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is one small part of our program that may be confusing. Note that we
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As well as extracting the elevation from the NumPy array, we also typecast it
    to an integer. We do this because `data` is a NumPy array that returns a `numpy.uint16`
    value for each entry in the array. NumPy will automatically convert this into
    an integer as necessary, but doing this slows our program down. Since these values
    are integers already, we simply convert the elevation to a regular integer right
    away. This improves the speed of our program by about an order of magnitude—which
    is important when you are dealing with large amounts of data as we are here.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run this program, you''ll see a list of the unique elevation values
    and how often that elevation occurred within the DEM file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Notice the negative elevation values. Most of these are because certain areas
    of the USA (for example Death Valley) are below sea level. However, there is one
    elevation value, `-500`, that is not a real elevation value. This is the **no-data
    value** that we mentioned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can avoid adding this to the histogram by adding the following highlighted
    lines to your program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Using NumPy in this way, it is relatively straightforward to read through the
    contents of a raster-format datasource. Let's now see what is involved in writing
    raster-format data.
  prefs: []
  type: TYPE_NORMAL
- en: Writing raster data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To write raster-format data, we need to generate some sample data, tell GDAL
    how to georeference each cell within the data to a point on the Earth's surface,
    and then save the data to disk. Let's work through this one step at a time.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by creating the raster-format data file. We'll use the `EHdr` format,
    which is shorthand for an ESRI header-labeled file—this is the same file format
    we used when we read through the DEM data earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: As usual, GDAL makes it easy to work with different data formats; the same code
    will work no matter what format you select.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here is the code to create the EHdr-format raster data file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The parameters to the `Create()` method are the name of the file, the number
    of cells across and down, the number of raster bands, and the type of data to
    store in each cell.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We next need to tell GDAL which spatial reference system to use for the file.
    In this case, we''ll use the same `WGS84` reference system we encountered earlier;
    if you remember, this means that our coordinates are made up of latitude and longitude
    values. Here is the relevant code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll next need to georeference the raster data onto the surface of the Earth.
    This is done using a **georeferencing transform**. There are many options you
    can use when defining a georeferencing transform, allowing you to do sophisticated
    things such as flipping the raster data or rotating it. In this case, however,
    all we need to do is tell GDAL where the top-left cell should be positioned, and
    how large each cell is going to be:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example code, we have set the top-left cell to be at `latitude=90`,
    `longitude=-180`, and have defined each cell to cover 1/4 of a degree of latitude
    and longitude.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We''re now ready to create our raster-format data and save it to the file.
    Let''s generate an array of 360 rows and 180 columns, where each value is a random
    number between 1 and 100:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can then convert this array into a NumPy array, where each entry in the
    array is a 16-bit signed integer:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This data can then be saved into the file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let''s define a no-data value, and close the file to save everything
    to disk:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Running this program will create a new raster-format file on disk, complete
    with a header (`.hdr`) file and information about how to georeference our (random)
    data onto the surface of the Earth. Except for the addition of a spatial reference
    system and a georeferencing transform, the process of writing geospatial data
    is almost as simple as reading it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can actually use both a spatial reference system and a geotransform when
    reading raster data from a file too—we just skipped that step to keep it simple.
    Later on, when we want to position cells exactly onto a point on the Earth's surface,
    we'll use both of these concepts while reading raster-format data.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with spatial reference systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the things that can be quite confusing when you start working with geospatial
    data is the notion of a **spatial reference system**. Imagine that you''re running
    a search-and-rescue operation, and are given the location of a plane crash as
    a coordinate, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: What do these numbers mean? Are these values a latitude and longitude, or are
    they perhaps a number of kilometers away from a given reference point? Without
    understanding how these coordinates translate to a point on the Earth's surface,
    you'd have no way of knowing where to send your rescuers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Spatial reference systems are sometimes referred to as coordinate reference
    systems. Don''t worry: these two terms refer to the same thing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand the concept of spatial reference systems, you first need to learn
    a bit about mapping theory. Maps are an attempt to draw the three-dimensional
    surface of the Earth on a two-dimensional Cartesian plane:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dealing with spatial reference systems](img/B04102_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To convert the Earth''s surface into a two-dimensional plane, you need to use
    a mathematical process known as **projection**. The thing is, it is mathematically
    impossible to have a perfect projection: shapes are going to be distorted, areas
    will be misrepresented, or the distance between points will be incorrect.'
  prefs: []
  type: TYPE_NORMAL
- en: Because of this imperfection, a large number of different map projections have
    been developed over the years. Some map projections are quite accurate for certain
    areas of the world, but are inaccurate elsewhere. Other map projections preserve
    the shape of the continents while misrepresenting distance and areas, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever you work with geospatial data, you will need to have answers to the
    following three questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Which mathematical model has been used to define the shape of the Earth?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have the coordinates been projected onto a map?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If so, what projection has been used?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knowing the answers to these three questions will allow you to know the exact
    location that a given set of coordinates refers to. As you can imagine, knowing
    the answers to these questions is vital to the success of any geospatial analysis.
  prefs: []
  type: TYPE_NORMAL
- en: A spatial reference system encapsulates the answers to these three questions.
    Let's take a look at a couple of common spatial reference systems to see how they
    work.
  prefs: []
  type: TYPE_NORMAL
- en: WGS84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**WGS84** stands for World Geodetic System 1984, and is a global standard used
    to represent points on the surface of the Earth. It uses an accurate mathematical
    model of the Earth''s shape, along with standards that define coordinates in terms
    of what we call latitude and longitude. Taken together, the WGS84 spatial reference
    system provides a complete system to describe points on the Earth''s surface.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a closer look at how WGS84 defines the latitude and longitude values.
    Given a point on the Earth''s surface, the latitude and longitude are calculated
    by drawing an imaginary line from the center of the Earth out to the desired point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![WGS84](img/B04102_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can then measure the latitude as the angle in the north-south direction
    between this line and a line going out to the equator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![WGS84](img/B04102_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, the longitude can be calculated as the angle between this line in
    the east-west direction and a line going out to zero degrees (which is based on
    the location of Greenwich, England):'
  prefs: []
  type: TYPE_NORMAL
- en: '![WGS84](img/B04102_02_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, longitude and latitude values are based on the desired point's
    position on the Earth's surface. WGS84 is the prototypical example of an **unprojected**
    coordinate system. It's a very common format for geospatial data, and in many
    cases you will only be working with data in this format.
  prefs: []
  type: TYPE_NORMAL
- en: Universal Transverse Mercator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Universal Transverse Mercator** (**UTM**) is a very common standard used
    to represent coordinates on a flat Cartesian plane. UTM is not a single map projection,
    but is rather a sequence of sixty different projections called **zones**, where
    each zone covers a narrow slice of the Earth''s surface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Universal Transverse Mercator](img/B04102_02_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For any given UTM zone, the coordinates are measured as "northing" and "easting"
    values, which correspond to the number of meters north or east of a given reference
    point. The reference point is calculated so that the northing and easting values
    will always be positive.
  prefs: []
  type: TYPE_NORMAL
- en: Because the UTM projections are based on a two-dimensional map, these are examples
    of a **projected** coordinate system.
  prefs: []
  type: TYPE_NORMAL
- en: Describing spatial reference systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever you work with geospatial data, you need to know which spatial reference
    system you are using. Often, when generating maps or reading and writing geospatial
    data, you will need to build an `osr.SpatialReference` object or its equivalent
    to describe the spatial reference system you are using.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the easiest ways to describe a spatial reference system is by name.
    We saw this earlier when we created a spatial reference object using the well-known
    name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Another common way to describe a spatial reference system is to use the **EPSG**
    code. EPSG is a standards body that maintains a database of all known spatial
    reference systems, and assigns a unique numeric code to each one. You can find
    the EPSG website at [http://www.epsg-registry.org](http://www.epsg-registry.org).
    For example, the EPSG code for WGS84 is 4326, so you could also create a WGS84
    spatial reference object using the following Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can use the WKT format string to define a spatial reference system.
    The GDAL/OGR library makes it easy to import and export spatial reference systems
    using WKT. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: There is also an `ImportFromWkt()` method, which lets you define a spatial reference
    object using a WKT definition string.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming coordinates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As well as knowing which spatial reference system you are using, it is also
    important at times to be able to transform geospatial data from one spatial reference
    system to another. For example, if you want to use Shapely to calculate the intersection
    between two polygons, and the polygons use different spatial reference systems,
    you are going to need to convert them into the same spatial reference system before
    the intersection will work.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that Shapely is a *geometry* manipulation library. It doesn't know
    about spatial reference systems, so you need to deal with this yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'To transform a geometry from one spatial reference system to another, you can
    use the `osr.CoordinateTransformation` class. Let''s see how this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You first define the two spatial reference systems, and then create the coordinate
    transformation to convert from one to the other. Then you can simply call the
    `Transform()` method to convert the geometry from the source spatial reference
    system into the destination spatial reference system.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating lengths and areas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we understand the basics of spatial reference systems and how to transform
    data from one spatial reference system to another, we can finally solve the problem
    we encountered in [Chapter 1](ch01.html "Chapter 1. Geospatial Analysis and Techniques"),
    *Geospatial Analysis and Techniques*. If you remember, while looking at the calculations
    we could do with the Shapely library, we found that we could not accurately calculate
    lengths and areas for geospatial data that used longitude and latitude values.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take another look at this problem, and how we can use coordinate transformations
    to solve these problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define a simple polygon that defines the approximate outline of Central
    Park in New York:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We used this polygon as an example in the section on well-known text earlier
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to ask Shapely to calculate the area of this geometry, it would
    calculate the mathematical area covered by this polygon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, the resulting number is in "square degrees", which is a meaningless
    number. This is because Shapely doesn''t know about map projections—it simply
    treats each coordinate value as a number. To calculate the area of this polygon
    in real units, we have to convert from unprojected lat/long coordinates into what
    is called an "equal area" map projection that measures coordinates in meters.
    We can then ask Shapely to calculate the area, and the result will be in square
    meters. Let''s see how we can do this using a combination of OGR and Shapely:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First off, we create an OGR geometry object using the WKT definition for our
    outline:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We next need to define a coordinate transformation from WGS84 into a projected
    coordinate system that uses meters. We will use the **World Mollweide** projection
    (EPSG code 54009), which is an equal-area projection that is fairly accurate worldwide:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can then transform the OGR geometry from WGS84 into World Mollweide projection,
    convert it back into a Shapely geometry, and finally ask Shapely to calculate
    the polygon''s area:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The result is an accurate figure for the area of Central Park (as accurate as
    the original polygon outline will allow), measured in square meters. You could
    then convert this area into square miles or any other unit you wished to use.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we used an equal-area projection. To accurately calculate lengths,
    you would have to use an equidistant map projection covering the area of the Earth
    that you are interested in. Alternatively, you can make use of the `PyProj` library
    to calculate distances for unprojected coordinates; we will look at `PyProj` in
    detail in [Chapter 5](ch05.html "Chapter 5. Analyzing Geospatial Data"), *Analyzing
    Geospatial Data*.
  prefs: []
  type: TYPE_NORMAL
- en: Geospatial data errors and how to fix them
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you start working with geospatial data, you will soon discover that things
    don't always work the way you expect them to. OGR may crash when attempting to
    save a geometry into a shapefile, or Shapely may cause a system error when calculating
    the intersection of two polygons. While this can be frustrating, there are ways
    to solve these problems once you understand what causes them.
  prefs: []
  type: TYPE_NORMAL
- en: Geospatial data, and libraries such as GDAL/OGR and Shapely, are based around
    a mathematical model of how a geometry should be structured. Problems occur when
    your geospatial data doesn't meet this mathematical ideal. Let's take a look at
    what a mathematically-correct geometry looks like.
  prefs: []
  type: TYPE_NORMAL
- en: Points
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While a coordinate is simply a pair of numbers, the range of acceptable values
    is limited. Imagine, for example, the following point geometries, which use WGS84
    (that is, latitude and longitude coordinates):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: These points are supposed to represent the location of the Tower of London,
    the Eiffel Tower, and the Moscone Center in San Francisco. However, the third
    Point geometry has been defined incorrectly, by swapping the latitude and longitude.
    This location has been set to longitude=37.784 and latitude=-122.402\. But latitude
    values can only be in the range -90 to +90, and so this Point geometry is invalid.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, all geometries are made up of coordinates, and so a polygon, for
    example, might have just one out-of-range coordinate, which could cause your program
    to crash. When constructing or manipulating geometries, you will sometimes need
    to add code to check that the coordinates are all valid, and adjust the geometry
    if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: LineStrings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A LineString geometry consists of a list of coordinates, with a straight line
    segment drawn from one coordinate to the next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![LineStrings](img/B04102_02_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: However, if you try to define a LineString with only one coordinate, or a LineString
    with two coordinates that happen to be the same, then your LineString geometry
    will be mathematically invalid and can cause your program to crash.
  prefs: []
  type: TYPE_NORMAL
- en: Linear Rings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A Linear Ring is a LineString where the starting and ending points are the
    same:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Linear Rings](img/B04102_02_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Linear Rings are used to enclose an area of space, and are the building blocks
    of polygon geometries. For a Linear Ring to be valid, it must have at least three
    coordinates, and the line segments cannot touch or cross.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following illustration shows two examples of mathematically invalid Linear
    Rings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Linear Rings](img/B04102_02_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Polygons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A polygon geometry is made up of one or more Linear Rings: the first Linear
    Ring defines the outline of the Polygon, while additional Linear Rings define
    holes within the Polygon''s interior. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Polygons](img/B04102_02_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: However, this mathematically-ideal representation of a polygon breaks down if
    the interior rings overlap, touch each other, or touch the polygon's exterior.
    If any of these things happen, your polygon becomes invalid and your program may
    well crash.
  prefs: []
  type: TYPE_NORMAL
- en: MultiPolygons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A MultiPolygon geometry, as the name suggests, is a collection of two or more
    polygons. MultiPolygons are mathematically invalid if two of their polygons touch
    along an edge—in this case, the two polygons should have been merged into one
    larger polygon, and so the MultiPolygon is considered to be invalid.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing invalid geometries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even if your geometry data is valid to start with, geometries can become invalid
    when you manipulate them. For example, if you attempt to split a polygon in two,
    or merge LineString geometries together, the result can sometimes be invalid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you understand the ways in which a geometry can be invalid, let''s
    look at some tricks to fix them. First off, you can ask Shapely if it thinks the
    geometry is valid or not by checking the `is_valid` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, you can use the `IsValid()` method to check if an OGR geometry object
    is valid or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, these two validity checks are not perfect: sometimes you''ll
    find that a geometry is identified as valid even though it isn''t. When this happens,
    you''ll have to add a `try...except` clause to your program to catch a crash,
    and then try to fix the geometries yourself before trying again.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When a geometry is not valid, your first port of call will be the `buffer(0)`
    technique. The `buffer()` operation is one which expands a geometry to include
    all points within a certain distance of the original geometry, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fixing invalid geometries](img/B04102_02_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By calling `buffer(0)`, you are telling Shapely (or OGR) to construct a new
    copy of the geometry that includes all points within a zero distance of the geometry.
    This effectively rebuilds the geometry from scratch, and will often turn an invalid
    geometry back into a valid one.
  prefs: []
  type: TYPE_NORMAL
- en: 'This doesn''t always work, unfortunately. There are times when `buffer()` is
    unable to rebuild a complex geometry without crashing. In that case, you may need
    to split the geometry into individual pieces, and then check each piece in turn
    to see if it was the cause of the crash. You can then exclude the misbehaving
    piece from the geometry when you rebuild it. The following is an example piece
    of Python code that attempts to repair an invalid Shapely geometry using this
    technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that this code works with Shapely geometries. If you have an OGR geometry,
    you can convert it into a Shapely geometry using `shapely.wkt.loads(ogrGeometry.ExportToWkt())`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked more closely at the data used for geospatial analysis.
    We saw why having high-quality geospatial data is important, the various types
    of geospatial data you are likely to encounter, and the major websites which provide
    quality geospatial data for free. We then looked at how to read and write both
    vector and raster format geospatial data using GDAL and OGR, and learned about
    spatial reference systems. Finally, we looked at the ways in which geospatial
    data can become invalid, and how to fix it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at spatial databases and how they can be used
    as a powerful tool for geospatial analysis.
  prefs: []
  type: TYPE_NORMAL
