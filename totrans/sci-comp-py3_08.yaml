- en: Chapter 8. Classes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 类
- en: 'In mathematics, when we write sin, we refer to a mathematical object for which
    we know many methods from elementary calculus. For example:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，当我们写 sin 时，我们指的是一个我们知道许多初等微积分方法的数学对象。例如：
- en: We might want to evaluate sin *x* at *x=*0.5, that is, compute sin(0.5), which
    returns a real number
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能想要计算 *x* 在 *x=0.5* 时的正弦值，即计算 sin(0.5)，它返回一个实数
- en: We might want to compute its derivative, which gives us another mathematical
    object, cos
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能想要计算它的导数，这将给我们另一个数学对象，cos
- en: We might want to compute the first three coefficients of its Taylor polynomial
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能想要计算其泰勒多项式的第一个三个系数
- en: These methods may be applied not only to sin but also to other sufficiently
    smooth functions. There are, however, other mathematical objects (for example,
    the number *5*) for which these methods make no sense. Objects that have the same
    methods are grouped together in abstract classes, for example, functions. Every
    statement and every method that can be applied to functions applies in particular
    to sin or cos. Other examples for such classes might be a rational number, for
    which a denominator and numerator method exist; an interval, which has a left
    and right boundary method; an infinite sequence, for which we can ask whether it
    has a limit, and so on.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法不仅可以应用于正弦函数，还可以应用于其他足够平滑的函数。然而，对于其他数学对象（例如，数字 *5*），这些方法没有意义。具有相同方法的对象被分组到抽象类中，例如，函数。可以应用于函数的每个语句和每个方法特别适用于正弦或余弦。此类类的其他例子可能包括有理数，它有一个分子和分母方法；区间，它有左边界和右边界方法；无限序列，我们可以询问它是否有极限，等等。
- en: In this case, sin is called an instance of the class. The mathematical phrase
    *Let g be a function...* is, in this context, called instantiation. Here, *g*
    is the name of the function; one of many attributes that can be assigned to it.
    Another attribute might be its domain.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，sin 被称为类的实例。数学短语 *设 g 为一个函数...* 在这个上下文中被称为实例化。在这里，*g* 是函数的名称；可以分配给它许多属性之一。另一个属性可能是它的定义域。
- en: The mathematical object *p(x) = 2x²- 5* is just like the sine function. Every
    function method applies to *p*, but we can also define special methods for *p*.
    We might, for instance, ask for *p*’s coefficients. These methods can be used
    to define the class of polynomials. As polynomials are functions, they additionally
    inherit all methods of the function class.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 数学对象 *p(x) = 2x²- 5* 就像正弦函数一样。每个函数方法都适用于 *p*，但我们也可以为 *p* 定义特殊方法。例如，我们可以要求 *p*
    的系数。这些方法可以用来定义多项式的类。因为多项式是函数，它们还继承了函数类的所有方法。
- en: 'In mathematics, we often use the same operator symbol for completely different
    operations. For instance, in  5+4 and sin *+* cos, the operator symbol + has different
    meanings. By using the same symbol, one tries to express the similarities of mathematical
    operations. We have introduced these terms from object-oriented programming by
    applying them to mathematical examples:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，我们经常使用相同的运算符符号来表示完全不同的操作。例如，在 5+4 和 sin *+* cos 中，运算符符号 + 有不同的含义。通过使用相同的符号，人们试图表达数学操作的相似性。我们通过将它们应用于数学示例来从面向对象编程中引入了这些术语：
- en: Classes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: Instance and instantiation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例和实例化
- en: Inheritance
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承
- en: Methods
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法
- en: Attributes
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性
- en: Operator overloading
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算符重载
- en: In this chapter, we will show how these concepts are used in Python.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将展示这些概念在Python中的应用。
- en: Introduction to classes
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类介绍
- en: We will illustrate the concept of classes with an example of rational numbers,
    that is, numbers of the form *q= q*[N] *⁄ q*[D], where *q*[N] and *q*[D] are integers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过有理数的例子来说明类的概念，即形式为 *q= q*[N] *⁄ q*[D] 的数，其中 *q*[N] 和 *q*[D] 是整数。
- en: '![Introduction to classes](img/class_anatomy-2.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![类介绍](img/class_anatomy-2.jpg)'
- en: 'Figure 8.1: An example of a class declaration'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：类声明的示例
- en: We use rational numbers here only as an example for the class concept. For future
    work in Python with rational numbers use the *fractions* module (refer to [[6]](apa.html
    "Appendix . References")).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用有理数只是为了作为类概念的示例。对于Python中未来的有理数工作，请使用 *fractions* 模块（参考 [[6]](apa.html
    "附录 . 参考文献")）。
- en: Class syntax
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类语法
- en: 'The definition of a class is made by a block command with the `class` keyword,
    the name of the class, and some statements in the block (refer to *Figure 8.1*):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 类的定义是通过一个带有 `class` 关键字、类名和块中的某些语句的命令块来完成的（参考 *图8.1*）：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: An instance of this class (or in other words, an object of the type `RationalNumber`)
    is created by
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这个类的实例（或者换句话说，创建`RationalNumber`类型的对象）是通过
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'and a query `type(a)` returns the answer,  `<class''__main__.RationalNumber''>`.
    If we want to investigate whether an object is an instance of this class, we can
    use this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 并且一个查询`type(a)`返回答案是，`<class'__main__.RationalNumber'>`。如果我们想调查一个对象是否是这个类的实例，我们可以使用这个：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: So far we've generated an object of the `RationalNumber` type, which has no
    data yet. Furthermore, there are no methods defined to perform operations with
    these objects. This will be the subject of the next sections.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经生成了一个`RationalNumber`类型的对象，它还没有数据。此外，还没有定义用于对这些对象执行操作的方法。这将是下一节的主题。
- en: The __init__ method
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`__init__`方法'
- en: 'Now we provide our example class with some attributes; that is, we give it
    defining data. In our case, this data will be the values of the denominator and
    the numerator. To this end, we have to define a method, `__init__`, used to initialize
    the class with these values:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们为我们提供的示例类添加一些属性；也就是说，我们给它定义数据。在我们的情况下，这些数据将是分母和分子的值。为此，我们必须定义一个方法，`__init__`，用于使用这些值初始化类：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Before we explain the special `__init__` function, which we added to the class,
    we demonstrate the instantiation of a `RationalNumber` object:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们解释我们添加到类中的特殊`__init__`函数之前，我们演示了`RationalNumber`对象的实例化：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A new object of type `RationalNumber` is created by using the class name as
    if it was a function. This statement does two things:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用类名作为函数来创建`RationalNumber`类型的新对象。这个语句做了两件事：
- en: It first creates an empty object, `q`.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它首先创建一个空对象，`q`。
- en: Then it applies the `__init__` function to it; that is, `q.__init__(10, 20)`
    is executed.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后它将`__init__`函数应用于它；也就是说，执行`q.__init__(10, 20)`。
- en: The first parameter of `__init__` refers to the new object itself. On function
    call, this first parameter is replaced by the object’s instance. This applies
    to all methods of the class and not only to the special method `__init__`. The
    special role of this first parameter is reflected by the convention to name it
    `self`. In the  previous example, the `__init__` function defines two attributes
    of the new object, `numerator` and `denominator`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__`的第一个参数指的是新对象本身。在函数调用时，这个第一个参数被对象实例所替换。这适用于类的所有方法，而不仅仅是特殊的`__init__`方法。这个第一个参数的特殊作用体现在将其命名为`self`的约定上。在先前的例子中，`__init__`函数定义了新对象的两个属性，`numerator`和`denominator`。'
- en: Attributes and methods
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性和方法
- en: 'One of the main reasons for working with classes is that objects can be grouped
    together and bound to a common object. We saw this already when looking at rational
    numbers; denominator and numerator are two objects which we bound to an instance
    of the `RationalNumber` class. They are called attributes of the instance. The
    fact that an object is an attribute of a class instance becomes apparent from
    the way they are referenced, which we have used tacitly before:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 与类一起工作的一个主要原因是对象可以被分组并绑定到一个公共对象上。我们在查看有理数时已经看到了这一点；分母和分子是两个绑定到`RationalNumber`类实例上的对象。它们被称为实例的属性。一个对象是类实例的属性的事实，从它们被引用的方式中变得明显，这是我们之前已经隐含使用过的：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here are some examples of instantiation and attribute reference:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些实例化和属性引用的例子：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once an instance is defined we can set, change or delete attributes of that
    particular instance. The syntax is the same as for regular variables:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了实例，我们就可以设置、更改或删除该特定实例的属性。语法与常规变量相同：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Changing or deleting an attribute may have undesired side effects, which might
    even render the object useless. We will be learning more on this in the section
    *Attributes that depend on each other*. As functions are objects too, we can also
    use functions as attributes; they are called methods of the instance:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 修改或删除属性可能会产生不期望的副作用，甚至可能使对象变得无用。我们将在*相互依赖的属性*这一节中了解更多这方面的内容。由于函数也是对象，我们也可以将函数用作属性；它们被称为实例的方法：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For example, let us add a method to the class `RationalNumber` that converts
    the number to a float:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们向`RationalNumber`类添加一个将数字转换为浮点数的方法：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Again, this method takes as its first (and only) argument, `self`, the reference
    to the object itself. We use this method with a regular function call:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这个方法将其第一个（也是唯一一个）参数，`self`，作为对对象本身的引用。我们使用这个方法进行常规的函数调用：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is equivalent to the following call:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于以下调用：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Note again that the object instance is inserted as the first argument of the
    function. This use of the first argument explains the error message that would
    occur if this particular method were used with additional arguments:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，对象实例被插入为函数的第一个参数。这种对第一个参数的使用解释了如果使用此特定方法时出现额外参数将产生的错误信息：
- en: 'The `q.convert2float(15)` call provokes this error message:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `q.convert2float(15)` 会导致以下错误信息：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The reason this does not work is that `q.convert2float(15)` is precisely equivalent
    to `RationalNumber.convert2float(q,15)`, which fails because `RationalNumber.convert2float`
    takes only one argument.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以不工作，是因为 `q.convert2float(15)` 与 `RationalNumber.convert2float(q,15)` 完全等价，而后者失败，因为
    `RationalNumber.convert2float` 只接受一个参数。
- en: Special methods
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊方法
- en: 'The special method `__repr__` gives us the ability to define the way the object
    is represented in a Python interpreter. For rational numbers, a possible definition
    of this method could be as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊方法 `__repr__` 给我们定义了在 Python 解释器中对象表示方式的能力。对于有理数，此方法的一个可能定义如下：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With this method defined, just typing `q` returns 10 / 20.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了此方法后，只需键入 `q` 就会返回 10 / 20。
- en: 'We would like to have a method that performs addition of two rational numbers.
    A first attempt could result in a method like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望有一个方法来执行两个有理数的加法。一个初步尝试可能得到如下方法：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'A call to this method takes the following form:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此方法的形式如下：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It would be much nicer if we could write `q + p` instead. But so far, the plus
    sign is not defined for the `RationalNumber` type. This is done by using the `__add__` special
    method. So, just renaming `add` to `__add__` allows for using the plus sign for
    rational numbers:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以写 `q + p` 会更好。但到目前为止，加号对 `RationalNumber` 类型尚未定义。这是通过使用 `__add__` 特殊方法来完成的。因此，只需将
    `add` 重命名为 `__add__`，就可以使用有理数的加号：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The expression `q + p` is in fact an alias for the expression `q.__add__(p)`.
    In the table (*Table 8.1)*, you will find the special methods for binary operators,
    such as `+`, `-`, or `*`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式 `q + p` 实际上是 `q.__add__(p)` 的别名。在表 (*表 8.1*) 中，你可以找到二元运算符的特殊方法，如 `+`、`-`
    或 `*`。
- en: '| **Operator** | **Method** | **Operator** | **Method** |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **方法** | **运算符** | **方法** |'
- en: '| `+` | `__add__` | `+=` | `__iadd__` |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `+` | `__add__` | `+=` | `__iadd__` |'
- en: '| `*` | `__mul__` | `*=` | `__imul__` |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `*` | `__mul__` | `*=` | `__imul__` |'
- en: '| `-` | `__sub__` | `-=` | `__isub__` |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `-` | `__sub__` | `-=` | `__isub__` |'
- en: '| `/` | `__truediv__` | `/=` | `__itruediv__` |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `/` | `__truediv__` | `/=` | `__itruediv__` |'
- en: '| `//` | `__floordiv__` | `//=` | `__ifloordiv__` |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `//` | `__floordiv__` | `//=` | `__ifloordiv__` |'
- en: '| `**` | `__pow__` |  |  |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `**` | `__pow__` |  |  |'
- en: '| `==` | `__eq__` | `!=` | `__ne__` |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `==` | `__eq__` | `!=` | `__ne__` |'
- en: '| `<=` | `__le__` | `<` | `__lt__` |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `<=` | `__le__` | `<` | `__lt__` |'
- en: '| `>=` | `__ge__` | `>` | `__gt__` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `>=` | `__ge__` | `>` | `__gt__` |'
- en: '| `()` | `__call__` | `[]` | `__getitem__` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `()` | `__call__` | `[]` | `__getitem__` |'
- en: 'Table 8.1: Some Python operators & corresponding class methods, you can find
    the complete list [[31]](apa.html "Appendix . References")'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8.1：一些 Python 运算符及其对应的类方法，完整列表请见 [[31]](apa.html "附录。参考文献")
- en: 'The implementation of those operators for a new class is called operator overloading.
    Another example of operator overloading is a method for examining whether two
    rational numbers are the same:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为新类实现这些运算符的过程称为运算符重载。运算符重载的另一个例子是检查两个有理数是否相同的方法：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It is used like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 它的使用方式如下：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Operations between objects belonging to different classes need special care:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 不同类对象之间的操作需要特别注意：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: By default, the `+` operator invokes the left operand’s method, `__add__`. We
    programmed it so that it allows both, objects of type `int` and objects of type
    `RationalNumber`. In the statement `5 + p`, the operands are commuted and the
    `__add__` method of the build-in `int` type is invoked. This method returns an
    error as it does not know how to handle rational numbers. This case can be handled
    by the method `__radd__`, with which we will equip the `RationalNumber` class
    now. The method `__radd__` is called reverse addition.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`+` 运算符调用左操作数的 `__add__` 方法。我们编程使其允许 `int` 类型和 `RationalNumber` 类型的对象。在语句
    `5 + p` 中，操作数交换，并调用内置 `int` 类型的 `__add__` 方法。由于该方法不知道如何处理有理数，因此返回错误。此情况可以通过 `__radd__`
    方法来处理，我们现在将为 `RationalNumber` 类添加此方法。`__radd__` 方法称为逆加法。
- en: Reverse operations
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逆操作
- en: If operations like `+` are applied to two operands of different types, the corresponding
    method (in this case, `__add__`) of the left operand is invoked first. If this
    raises an exception, the reverse method (here, `__radd__`) of the right operand
    is called. If this method does not exist, a `TypeError` exception is raised.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将`+`等操作应用于不同类型的两个操作数，则首先调用左操作数的相应方法（在这种情况下，`__add__`）。如果这引发异常，则调用右操作数的反向方法（在这里，`__radd__`）。如果此方法不存在，则引发`TypeError`异常。
- en: 'Consider an example of reverse operation. In order to enable the operation
    5+*p* where *p* is an instance of `RationalNumber`, we define this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个逆操作的例子。为了使操作5+*p*（其中*p*是`RationalNumber`的实例）成为可能，我们定义如下：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that `__radd__` interchanges the order of the arguments; `self` is the
    object of type `RationalNumber` while other is the object that has to be converted.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`__radd__`交换了参数的顺序；`self`是类型为`RationalNumber`的对象，而`other`是要转换的对象。
- en: 'Using a class instance together with brackets*,* ( *,* ) or [ , ] invokes a
    call to one of the special methods `__call__` or `__getitem__`, giving the instance
    the behavior of a function or of an iterable (refer to the T*able 8.1* for these
    and other special methods):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '使用类实例与括号* *（* *）或[ , ]一起调用，会调用特殊方法`__call__`或`__getitem__`之一，使实例具有函数或可迭代对象的行为（有关这些和其他特殊方法，请参阅表8.1）。 '
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Which now may be used as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以这样使用：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `__getitem__` special method makes sense if the class provides an iterator
    (It is recommended to refer section *Iterators* in [Chapter 9](ch09.html "Chapter 9. Iterating"),
    *Iterating* before you consider the following example).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类提供了一个迭代器，则`__getitem__`特殊方法是有意义的（在考虑以下示例之前，建议您查阅第9章的*迭代器*部分[Chapter 9](ch09.html
    "Chapter 9. Iterating")，*迭代*）。
- en: 'The recursion *u[i+1] = a*[1]*u[i]*+ *a*[0]*u[i]*[-1]is called a three*-*term
    recursion. It plays an important role in applied mathematics, in particular in
    the construction of orthogonal polynomials. We can set up a three-term recursion
    as a class in the following way:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 递归*u[i+1] = a*[1]*u[i]*+ *a*[0]*u[i]*[-1]被称为三*-*项递归。它在应用数学中起着重要作用，特别是在正交多项式的构造中。我们可以以下面的方式将三项递归设置为一个类：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, the `__iter__` method defines a generator object, which allows us to
    use an instance of the class as an iterator:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`__iter__`方法定义了一个生成器对象，这使得我们可以将类的实例用作迭代器：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `__getitem__` method enables us to directly access the iterates as if `r3`
    were a list:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`__getitem__`方法使我们能够直接访问迭代器，就像`r3`是一个列表一样：'
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note that we used `itertools.islice` when coding the `__getitem__` method (refer
    to section *Iterators* of [Chapter 9](ch09.html "Chapter 9. Iterating"), *Iterating*,
    for more information). An example of the use of `__getitem__` together with slices
    and the function `ogrid` is given in the section *Function with two variables*
    in [Chapter 5](ch05.html "Chapter 5. Advanced Array Concepts"), *Advance Array
    Concepts*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在编写`__getitem__`方法时使用了`itertools.islice`（有关更多信息，请参阅第9章的*迭代器*部分[Chapter
    9](ch09.html "Chapter 9. Iterating")，*迭代*）。在[第5章](ch05.html "Chapter 5. Advanced
    Array Concepts")的*高级数组概念*部分中，给出了使用`__getitem__`与切片和函数`ogrid`的示例。
- en: Attributes that depend on each other
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相互依赖的属性
- en: 'Attributes of an instance can be changed (or created) by simply assigning them
    a value. However, if other attributes depend on the one just changed, it is desirable
    to change these simultaneously:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 实例的属性可以通过简单地分配它们一个值来更改（或创建）。然而，如果其他属性依赖于刚刚更改的属性，则同时更改这些属性是可取的：
- en: 'Let us consider a class that defines an object for planar triangles from three
    given points. A first attempt to set up such a class could be as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个类，它从三个给定的点定义一个平面三角形对象。设置这样一个类的第一次尝试可能如下所示：
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'An instance of this triangle is created by this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下方式创建此三角形的实例：
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And its area is computed by this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 其面积是通过以下方式计算的：
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If we change an attribute, say point *B*, the corresponding edges *a* and *c* are
    not automatically updated and the computed area is wrong:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们更改一个属性，例如点*B*，则相应的边*a*和*c*不会自动更新，并且计算出的面积是错误的：
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: A remedy is to define a method that is executed when an attribute is changed;
    such a method is called a setter method. Correspondingly, one might ask for a
    method that is executed when a value of an attribute is requested; such a method
    is called a getter method.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一种补救方法是定义一个在属性更改时执行的方法；这样的方法称为setter方法。相应地，人们可能会要求一个在请求属性值时执行的方法；这样的方法称为getter方法。
- en: The property function
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性函数
- en: 'The function `property`  links an attribute to such a getter, setter, and deleter
    method. It might also be used to assign a documentation string to an attribute:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `property` 将一个属性链接到这样的获取器、设置器和删除器方法。它也可以用来为属性分配文档字符串：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We continue with the previous example with a setter method and consider the `Trinagle` class
    again. If the following statement is included in `Triangle`
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续使用之前的例子，带有设置器方法，再次考虑 `Trinagle` 类。如果在 `Triangle` 中包含以下语句
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: a command
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一个命令
- en: '[PRE32]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: invokes the setter method, `set_B`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 调用设置器方法，`set_B`。
- en: 'Let us modify the Triangle class:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改三角形类：
- en: '[PRE33]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If the attribute `B` is changed, then the method `set_B` stores the new value
    in the internal attribute `_B` and changes all depending attributes:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果属性 `B` 发生变化，那么 `set_B` 方法会将新值存储在内部属性 `_B` 中，并改变所有依赖属性：
- en: '[PRE34]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The way the `deleter` method is used here is to prevent deletion of attributes:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用 `deleter` 方法的目的是防止删除属性：
- en: '[PRE35]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The use of an underscore as a prefix of attribute names is a convention used
    to indicate attributes that are not designed to be accessed directly. They are
    intended to hold data for attributes handled by setters and getters. These attributes
    are not private in the sense of other programming languages; they are just not
    intended to be accessed directly.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 将下划线用作属性名称的前缀是一种约定，用于指示这些属性不是设计为直接访问的。它们旨在为由设置器和获取器处理的属性持有数据。这些属性在其他编程语言中不是私有的；它们只是不打算直接访问。
- en: Bound and unbound methods
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定和非绑定方法
- en: 'We will now take a closer look at attributes that are methods. Let us consider
    an example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将更详细地研究那些是方法的属性。让我们考虑一个例子：
- en: '[PRE36]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'A little inspection shows us how the nature of `func` changes after creating
    an instance:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微检查一下，我们可以看到在创建实例后 `func` 的性质如何改变：
- en: '[PRE37]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Calling, for example,  `A.func(3)` would result in an error message such as
    this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，调用 `A.func(3)` 将会得到如下错误信息：
- en: '[PRE38]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`instA.func(3)` is executed as expected. Upon creation of an instance, the
    `func` method is bound to the instance. The `self` argument gets the instance
    assigned as its value. Binding a method to an instance makes the method usable
    as a function. Before that, it is of no use. Class methods, which we will consider
    later, are different in this aspect.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`instA.func(3)` 如预期执行。在创建实例时，`func` 方法被绑定到该实例。`self` 参数被分配给实例作为其值。将方法绑定到实例使得该方法可以作为函数使用。在此之前，它没有任何用处。我们稍后会考虑的类方法在这方面是不同的。'
- en: Class attributes
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类属性
- en: 'Attributes specified in the class declaration are called class attributes.
    Consider the following example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在类声明中指定的属性称为类属性。考虑以下示例：
- en: '[PRE39]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Class attributes are useful for simulating default values and can be used if
    values have to be reset:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 类属性对于模拟默认值很有用，如果需要重置值，可以使用：
- en: '[PRE40]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Both instances have an attribute, `tol`, with the value initialized in the
    class definition:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 两个实例都有一个属性 `tol`，其值在类定义中初始化：
- en: '[PRE41]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Altering the class attribute automatically affects all the corresponding attributes
    of all instances:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 修改类属性会自动影响所有实例的相应属性：
- en: '[PRE42]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Altering `tol` for one instance does not affect the other instance:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 修改一个实例的 `tol` 不会影响其他实例：
- en: '[PRE43]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'But now `N2.tol` is detached from the class attribute. Changing `Newton.tol`
    no longer has any effect on `N2.tol`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在 `N2.tol` 已经与类属性分离。改变 `Newton.tol` 对 `N2.tol` 不再有任何影响：
- en: '[PRE44]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Class methods
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类方法
- en: We saw in the previous section on *Bound and unbound methods* how methods are
    either bound to an instance of a class or remain in a state as unbound methods.
    Class methods are different. They are always bound methods. They are bound to
    the class itself.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节关于*绑定和非绑定方法*中，我们看到了方法要么绑定到类的实例上，要么保持非绑定状态。类方法不同，它们总是绑定方法。它们绑定到类本身。
- en: 'We will first describe the syntactic details and then give some examples to
    show what these methods can be used for. To indicate that a method is a class
    method the decorator line precedes the method definition:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先描述语法细节，然后给出一些示例来展示这些方法可以用作什么。为了表明一个方法是类方法，装饰器行位于方法定义之前：
- en: '[PRE45]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: While standard methods make a reference to an instance by the use of their first
    argument, the first argument of a class method refers to the class itself. By
    convention the first argument is called `self` for standard methods and `cls`
    for class methods.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然标准方法通过使用它们的第一个参数来引用实例，但类方法的第一个参数引用的是类本身。按照惯例，第一个参数在标准方法中称为 `self`，在类方法中称为
    `cls`。
- en: 'Standard case:'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准情况：
- en: '[PRE46]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Class method case:'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类方法示例：
- en: '[PRE47]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In practice, class methods may be useful for executing commands before an instance
    is created, for instance, in a preprocessing step. See the following example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，类方法可能在创建实例之前执行命令时很有用，例如，在预处理步骤中。请参见以下示例：
- en: 'In this example we show how class methods can be used to prepare data before
    creating an instance:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们展示了如何使用类方法在创建实例之前准备数据：
- en: '[PRE48]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The class is designed so, that a polynomial object is created by specifying
    its coefficients. Alternatively, the `by_points` class method allows us to define
    a polynomial by interpolation points. We can transform the interpolation data
    to the polynomial coefficients even when no instance of Polynomial is available:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 类的设计是这样的，通过指定其系数来创建一个多项式对象。或者，`by_points`类方法允许我们通过插值点定义一个多项式。即使没有Polynomial的实例，我们也可以将插值数据转换为多项式系数：
- en: '[PRE49]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Another example of a class method is presented in an example later in this chapter.
    In that example, a class method is used to access information related to several
    (or all) instances from this class.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 本章后面的例子中提供了一个类方法的另一个示例。在那个例子中，类方法被用来访问与这个类中的几个（或所有）实例相关的信息。
- en: Subclassing and inheritance
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子类化和继承
- en: 'In this section, we will introduce some central concepts from object-oriented
    programming: abstract classes, subclasses, and inheritance. To guide you through
    these concepts, we consider another mathematical example: one-step methods for
    solving a differential equation. The generic form of an ordinary initial value
    problem is'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍面向对象编程的一些核心概念：抽象类、子类和继承。为了帮助您理解这些概念，我们考虑另一个数学例子：求解微分方程的一步方法。普通初值问题的通用形式是
- en: '![Subclassing and inheritance](img/ode.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![子类化和继承](img/ode.jpg)'
- en: The data is the right-hand side function *f*, the initial value *x[0]*, and
    the interval of interest [*t*[0]*, t*[e]]. The solution of this problem is a function
    ![Subclassing and inheritance](img/realvaluedfunction.jpg). A numerical algorithm
    gives this solution as a vector *u* of discrete values *u[i]* being approximations
    to *x*(*t[i]*). Here, ![Subclassing and inheritance](img/B05511_08_02.jpg)are
    discretized values of the independent variable *t*, which in physical models often
    represents time.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 数据是右手边函数*f*、初始值*x[0]*和感兴趣的区间[*t*[0]*, t*[e]]。这个问题的解是一个函数![子类化和继承](img/realvaluedfunction.jpg)。数值算法将这个解作为一个离散值向量*u*，其中*u[i]*是*x*(*t[i]*)的近似。在这里，![子类化和继承](img/B05511_08_02.jpg)是独立变量*t*的离散化值，在物理模型中通常代表时间。
- en: 'A one-step method constructs the solution values *u[i]* by the recursion steps:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一步方法通过递归步骤构建解值*u[i]*：
- en: '![Subclassing and inheritance](img/onestep.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![子类化和继承](img/onestep.jpg)'
- en: 'Here, Φ is a step function that characterizes the individual methods (refer
    to [[28]](apa.html "Appendix . References")):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，Φ是一个步进函数，它表征了各个方法（参见[[28]](apa.html "附录 . 参考文献"))：
- en: '**Explicit Euler**:   ![Subclassing and inheritance](img/B05511_08_03.jpg)'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显式欧拉法**: ![子类化和继承](img/B05511_08_03.jpg)'
- en: '**Midpoint Rule**:   ![Subclassing and inheritance](img/B05511_08_04.jpg)'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中点法**: ![子类化和继承](img/B05511_08_04.jpg)'
- en: '**Runge–Kutta 4**:  ![Subclassing and inheritance](img/B05511_08_05.jpg) with 
    ![Subclassing and inheritance](img/B05511_08_06.jpg)'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**龙格-库塔4法**: ![子类化和继承](img/B05511_08_05.jpg)与![子类化和继承](img/B05511_08_06.jpg)'
- en: 'What we did here is the typical way of describing a mathematical algorithm.
    We first described a method by its idea, giving its steps in an abstract way.
    To actually use it, we have to fill in the parameters of a concrete method, in
    this example, the function Φ. This is also the way things are explained in object-oriented
    programming. First, we set up a class with the abstract description of the method:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是描述数学算法的典型方式。我们首先通过其思想描述了一个方法，以抽象的方式给出其步骤。为了实际使用它，我们必须填写一个具体方法的参数，在这个例子中，是函数Φ。这也是面向对象编程中解释事物的方式。首先，我们设置一个具有方法抽象描述的类：
- en: '[PRE50]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This abstract class, with its methods, is used as a template for the individual
    methods:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个具有方法的抽象类被用作各个方法的模板：
- en: '[PRE51]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Note that in the class definitions, the name of the abstract class that we
    used as a template,  `OneStepMethod`, is given as an extra argument:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在类定义中，我们用作模板的抽象类`OneStepMethod`的名称被作为一个额外的参数给出：
- en: '[PRE52]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'That class is called the parent class. All methods and attributes of the parent
    class are inherited by the subclasses as long as they are not overridden. They
    are overridden if they are redefined in the subclass. The `step` method is redefined
    in the subclasses, while the method `generate` is generic for the entire family
    and therefore inherited from the parent. Before considering further details, we
    will demonstrate how these three classes can be used:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 那个类被称为父类。只要它们没有被覆盖，父类的所有方法和属性都会被子类继承。如果它们在子类中被重新定义，它们就会被覆盖。`step` 方法在子类中被重新定义，而
    `generate` 方法对整个家族来说是通用的，因此从父类继承。在考虑更多细节之前，我们将演示如何使用这三个类：
- en: '[PRE53]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You can avoid the repetition of common parameter lists by using the star operator
    (refer to section *Variable Number of Argument* in [Chapter 7](ch07.html "Chapter 7. Functions"),
    *Functions* for more details):'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用星号运算符（请参阅第 7 章 *可变数量参数* 中的 *变量数量参数* 部分，*函数* 以获取更多详细信息）来避免重复常见的参数列表：
- en: '[PRE54]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note that the abstract class has never been used to create an instance. As the
    `step` method was not completely defined, calling it raises an exception of type
    `NotImplementedError`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，抽象类从未被用来创建实例。由于 `step` 方法没有完全定义，调用它将引发类型为 `NotImplementedError` 的异常。
- en: 'Sometimes one has to access the methods or attributes of a parent class. This
    is done using the command `super`. This is useful when the child class uses its
    own `__init__` method in order to extend the parent’s `__init__`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 有时必须访问父类的方法或属性。这是通过命令 `super` 来完成的。当子类使用自己的 `__init__` 方法来扩展父类时，这很有用：
- en: 'For example let us assume that we want to give every solver class a string
    variable with the solver’s name. To this end, we provide the solver with an `__init__`
    method as it overrides the parent’s `__init__` method. In the case that both methods
    should be used, we have to refer to the parent’s method by the command `super`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要给每个求解器类提供一个带有求解器名称的字符串变量。为此，我们提供了一个 `__init__` 方法，因为它覆盖了父类的 `__init__`
    方法。如果两种方法都应该使用，我们必须通过命令 `super` 来引用父类的方法：
- en: '[PRE55]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note that one could use the name of the parent class explicitly. The use of
    `super` instead allows us to change the name of the parent class without having
    to change all the references to the parent class.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，可以使用父类的名称。使用 `super` 而不是这样做允许我们更改父类的名称，而无需更改对父类的所有引用。
- en: Encapsulation
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装
- en: 'Sometimes the use of inheritance is impractical or even impossible. This motivates
    the use of encapsulation. We will explain the concept of encapsulation by considering
    Python functions, that is, objects of the Python type `function`, which we encapsulate
    in a new class, `Function`, and provide with some relevant methods:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 有时使用继承是不切实际的，甚至是不可能的。这促使我们使用封装。我们将通过考虑 Python 函数来解释封装的概念，即 Python 类型 `function`
    的对象，我们将它们封装在一个新的类 `Function` 中，并为其提供一些相关的方法：
- en: '[PRE56]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Note that the `__add__` and `__mul__` operations should return an instance
    of the same class. This is achieved by the `return type(self)(sum)` statement,
    which in this case is a more general form of writing `return Function(sum)`. We
    can now derive subclasses by inheritance:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`__add__` 和 `__mul__` 操作应该返回同一类的实例。这是通过 `return type(self)(sum)` 语句实现的，在这种情况下，这是一种更通用的写法
    `return Function(sum)`。我们现在可以通过继承来派生子类：
- en: 'Consider as an example  Chebyshev polynomials which can be computed in the
    interval [1,-1] by:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以 Chebyshev 多项式为例，这些多项式可以在区间 [1,-1] 内通过以下方式计算：
- en: '![Encapsulation](img/cheby2.jpg).'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '![封装](img/cheby2.jpg).'
- en: 'We construct a Chebyshev polynomial as an instance of the `Function` class:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建一个 Chebyshev 多项式作为 `Function` 类的一个实例：
- en: '[PRE57]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Chebyshev polynomials are orthogonal in the sense:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，Chebyshev 多项式是正交的：
- en: '![Encapsulation](img/cheby1-1.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![封装](img/cheby1-1.jpg)'
- en: 'This can easily be checked using this construction:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过以下构造轻松检查：
- en: '[PRE58]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Without encapsulation multiplying functions as simply as writing  `weight *
    T5 * T6` would not have been possible.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 没有封装，我们不能像写 `weight * T5 * T6` 这样简单地乘以函数。
- en: Classes as decorators
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类作为装饰器
- en: In section *Function as decorators* in [Chapter 7](ch07.html "Chapter 7. Functions"),
    *Functions* , we saw how functions can be modified by applying another function
    as a decorator. In previous examples, we saw how classes can be made to behave
    as functions as long as they are provided with the `__call__` method. We will
    use this here to show how classes can be used as decorators.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7章的*函数作为装饰器*部分中，我们看到了如何通过应用另一个函数作为装饰器来修改函数。在之前的例子中，我们看到了如何使类表现得像函数一样，只要它们提供了`__call__`方法。我们将在这里使用这个方法来展示如何使用类作为装饰器。
- en: 'Let us assume that we want to change the behavior of some functions in such
    a way that before the function is invoked, all input parameters are printed. This
    could be useful for debugging purposes. We take this situation as an example to
    explain the use of a decorator class:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要以某种方式改变一些函数的行为，即在函数被调用之前，打印所有输入参数。这可能在调试目的上很有用。我们将这种情况作为一个例子来解释装饰器类的使用：
- en: '[PRE59]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We use this class to decorate function definitions,
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这个类来装饰函数定义，
- en: '[PRE60]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: and call the function as usual,
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后像平常一样调用函数，
- en: '[PRE61]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'On the second call, we obtain the following output:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次调用时，我们得到以下输出：
- en: '[PRE62]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This example shows that both classes and functions can be used as decorators.
    Classes allow for more possibilities, as they can be used to collect data as well.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子表明，类和函数都可以用作装饰器。类允许更多的可能性，因为它们可以用来收集数据。
- en: 'Indeed, we observe that:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们观察到：
- en: Every decorated function creates a new instance of the decorator class.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个装饰过的函数都会创建装饰器类的一个新实例。
- en: Data collected by one instance can be saved and made accessible to another instance
    by class attributes (refer section *Attributes* in [Chapter 8](ch08.html "Chapter 8. Classes"),
    *Classes)*.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过一个实例收集的数据可以通过类属性（参考第8章的*属性*部分，[Chapter 8](ch08.html "Chapter 8. Classes")，*类*）保存并使另一个实例可访问。
- en: The last point emphasizes the difference with function decorators. We show this
    now by a decorator that counts function calls and stores the result in a dictionary
    with the function as key.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点强调了与函数装饰器的区别。我们现在通过一个装饰器来展示这一点，该装饰器计算函数调用次数并将结果存储在一个以函数为键的字典中。
- en: In order to analyze the performance of algorithms, it might be useful to count
    the calls of particular functions. We can get counter information without changing
    the function definition. The code is a slight modification of an example given
    in [[4]](apa.html "Appendix . References") .
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分析算法的性能，可能需要计算特定函数的调用次数。我们可以在不更改函数定义的情况下获取计数器信息。这是对[[4]](apa.html "附录. 参考文献")中给出的示例的轻微修改。
- en: '[PRE63]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Here, we use the class attribute `CountCalls.instances`  to store the counters
    for each individual instance. Let us see how this decorator works:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用类属性`CountCalls.instances`来存储每个单独实例的计数器。让我们看看这个装饰器是如何工作的：
- en: '[PRE64]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Summary
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: One of the most important programming concepts in modern computer science is
    object-oriented programming. We learned in this chapter how to define objects
    as instances of classes, which we provide with methods and attributes. The first
    parameter of methods, usually denoted by `self`, plays an important and special
    role. You saw methods that can be used to define basic operations such as `+`
    and `*` for your own classes.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现代计算机科学中最重要的编程概念之一是面向对象编程。在本章中，我们学习了如何将对象定义为类的实例，我们为这些类提供了方法和属性。方法的第一参数，通常表示为`self`，扮演着重要和特殊的角色。你看到了可以用于定义基本操作的方法，例如为你的类定义`+`和`*`。
- en: While in other programming languages attributes and methods can be protected
    against unintended use, Python allows a technique to hide attributes and access
    these hidden attributes through special getter and setter methods. To this end,
    you met an important function, `property`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在其他编程语言中，属性和方法可以防止意外使用，但Python允许一种技术来隐藏属性并通过特殊的getter和setter方法访问这些隐藏的属性。为此，你遇到了一个重要的函数，`property`。
- en: Exercises
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: '**Ex. 1** → Write a method `simplify` to the class `RationalNumber`. This method
    should return the simplified version of the fraction as a tuple.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**例1** → 向类`RationalNumber`中编写一个`simplify`方法。该方法应返回分数的简化版本作为元组。'
- en: '**Ex. 2** → To provide results with confidence intervals a special calculus,
    so-called interval arithmetic is introduced in numerical mathematics; (refer to
    [[3, 14]](apa.html "Appendix . References")*)*. Define a class called `Interval`
    and provide it with methods for addition, subtraction, division, multiplication,
    and power (with positive integers only). These operations obey the following rules:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**例2** → 为了提供带有置信区间的结果，在数值数学中引入了一种特殊的微积分，称为区间算术；（参考 [[3, 14]](apa.html "附录。参考文献")*)*.
    定义一个名为 `Interval` 的类，并为其提供加法、减法、除法、乘法和幂（仅限正整数）的方法。这些操作遵循以下规则：'
- en: '![Exercises](img/B05511_08_01.jpg).'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '![练习](img/B05511_08_01.jpg).'
- en: 'Provide this class with methods that allow operations of the type *a* + *I,
    a I, I* + *a, I a*, where *I* is an interval and *a* an integer or float. Convert
    an integer or float to an interval `[a,a]` first. (Hint: you may want to use function
    decorators for this; (refer to section *Function as decorators* in [Chapter 7](ch07.html
    "Chapter 7. Functions"), *Functions*). Furthermore, implement the `__contains__`
    method, which enables you to check if a given number belongs to the interval using
    the syntax `x in I` for an object `I` of type Interval. Test your class by applying
    a polynomial `f=lambda x: 25*x**2-4*x+1` to an interval.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '为这个类提供方法，允许进行类型为 *a* + *I, a I, I* + *a, I a* 的操作，其中 *I* 是一个区间，*a* 是一个整数或浮点数。首先将整数或浮点数转换为区间
    `[a,a]`。（提示：你可能想为此使用函数装饰器；（参考第7章中的 *函数作为装饰器* 部分，[第7章](ch07.html "第7章。函数")，*函数*）。此外，实现
    `__contains__` 方法，它允许你使用 `x in I` 语法检查给定的数字是否属于区间 `I`，其中 `I` 是类型为区间的对象。通过将多项式
    `f=lambda x: 25*x**2-4*x+1` 应用到区间来测试你的类。'
- en: '**Ex. 3** → Consider the example under section *Classes as decorators*. Extend
    this example to obtain a *function decorator* that counts how often a certain
    function is called.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**例3** → 考虑在 *类作为装饰器* 部分下的示例。扩展这个示例以获得一个 *函数装饰器*，它统计某个函数被调用的次数。'
- en: '**Ex. 4** → Compare the two ways to implement a method for reverse addition
    `__radd__` in the class `RationalNumber`: the one given in the example in section
    *Special methods* and the one given here:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**例4** → 比较在 `RationalNumber` 类中实现 `__radd__` 方法两种方式的效果：一种是在 *特殊方法* 部分的示例中给出的，另一种是这里给出的：'
- en: '[PRE65]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Do you expect an error in this version? What is the error and how do you explain
    it? Test your answer by executing:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你期望在这个版本中出错吗？错误是什么，你是如何解释的？通过执行以下命令来测试你的答案：
- en: '[PRE66]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '**Ex. 4** → Consider the decorator class `CountCalls` as in example in section
    *Classes as decorators*. Provide this class with a method, `reset`, which sets
    the counters of all functions in the dictionary, `CountCalls.instances`, to zero.
    What would happen if the dictionary were replaced by an empty dictionary instead?'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**例4** → 考虑在 *类作为装饰器* 部分中的示例。为这个类提供一个方法，`reset`，它将字典 `CountCalls.instances`
    中所有函数的计数器设置为零。如果将字典替换为空字典会发生什么？'
