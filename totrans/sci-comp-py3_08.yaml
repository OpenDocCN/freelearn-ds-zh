- en: Chapter 8. Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In mathematics, when we write sin, we refer to a mathematical object for which
    we know many methods from elementary calculus. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: We might want to evaluate sin *x* at *x=*0.5, that is, compute sin(0.5), which
    returns a real number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We might want to compute its derivative, which gives us another mathematical
    object, cos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We might want to compute the first three coefficients of its Taylor polynomial
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These methods may be applied not only to sin but also to other sufficiently
    smooth functions. There are, however, other mathematical objects (for example,
    the number *5*) for which these methods make no sense. Objects that have the same
    methods are grouped together in abstract classes, for example, functions. Every
    statement and every method that can be applied to functions applies in particular
    to sin or cos. Other examples for such classes might be a rational number, for
    which a denominator and numerator method exist; an interval, which has a left
    and right boundary method; an infinite sequence, for which we can ask whether it
    has a limit, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, sin is called an instance of the class. The mathematical phrase
    *Let g be a function...* is, in this context, called instantiation. Here, *g*
    is the name of the function; one of many attributes that can be assigned to it.
    Another attribute might be its domain.
  prefs: []
  type: TYPE_NORMAL
- en: The mathematical object *p(x) = 2x²- 5* is just like the sine function. Every
    function method applies to *p*, but we can also define special methods for *p*.
    We might, for instance, ask for *p*’s coefficients. These methods can be used
    to define the class of polynomials. As polynomials are functions, they additionally
    inherit all methods of the function class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In mathematics, we often use the same operator symbol for completely different
    operations. For instance, in  5+4 and sin *+* cos, the operator symbol + has different
    meanings. By using the same symbol, one tries to express the similarities of mathematical
    operations. We have introduced these terms from object-oriented programming by
    applying them to mathematical examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instance and instantiation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operator overloading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will show how these concepts are used in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will illustrate the concept of classes with an example of rational numbers,
    that is, numbers of the form *q= q*[N] *⁄ q*[D], where *q*[N] and *q*[D] are integers.
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to classes](img/class_anatomy-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: An example of a class declaration'
  prefs: []
  type: TYPE_NORMAL
- en: We use rational numbers here only as an example for the class concept. For future
    work in Python with rational numbers use the *fractions* module (refer to [[6]](apa.html
    "Appendix . References")).
  prefs: []
  type: TYPE_NORMAL
- en: Class syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The definition of a class is made by a block command with the `class` keyword,
    the name of the class, and some statements in the block (refer to *Figure 8.1*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: An instance of this class (or in other words, an object of the type `RationalNumber`)
    is created by
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'and a query `type(a)` returns the answer,  `<class''__main__.RationalNumber''>`.
    If we want to investigate whether an object is an instance of this class, we can
    use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: So far we've generated an object of the `RationalNumber` type, which has no
    data yet. Furthermore, there are no methods defined to perform operations with
    these objects. This will be the subject of the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: The __init__ method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we provide our example class with some attributes; that is, we give it
    defining data. In our case, this data will be the values of the denominator and
    the numerator. To this end, we have to define a method, `__init__`, used to initialize
    the class with these values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we explain the special `__init__` function, which we added to the class,
    we demonstrate the instantiation of a `RationalNumber` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'A new object of type `RationalNumber` is created by using the class name as
    if it was a function. This statement does two things:'
  prefs: []
  type: TYPE_NORMAL
- en: It first creates an empty object, `q`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then it applies the `__init__` function to it; that is, `q.__init__(10, 20)`
    is executed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first parameter of `__init__` refers to the new object itself. On function
    call, this first parameter is replaced by the object’s instance. This applies
    to all methods of the class and not only to the special method `__init__`. The
    special role of this first parameter is reflected by the convention to name it
    `self`. In the  previous example, the `__init__` function defines two attributes
    of the new object, `numerator` and `denominator`.
  prefs: []
  type: TYPE_NORMAL
- en: Attributes and methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the main reasons for working with classes is that objects can be grouped
    together and bound to a common object. We saw this already when looking at rational
    numbers; denominator and numerator are two objects which we bound to an instance
    of the `RationalNumber` class. They are called attributes of the instance. The
    fact that an object is an attribute of a class instance becomes apparent from
    the way they are referenced, which we have used tacitly before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some examples of instantiation and attribute reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once an instance is defined we can set, change or delete attributes of that
    particular instance. The syntax is the same as for regular variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Changing or deleting an attribute may have undesired side effects, which might
    even render the object useless. We will be learning more on this in the section
    *Attributes that depend on each other*. As functions are objects too, we can also
    use functions as attributes; they are called methods of the instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, let us add a method to the class `RationalNumber` that converts
    the number to a float:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, this method takes as its first (and only) argument, `self`, the reference
    to the object itself. We use this method with a regular function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This is equivalent to the following call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Note again that the object instance is inserted as the first argument of the
    function. This use of the first argument explains the error message that would
    occur if this particular method were used with additional arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `q.convert2float(15)` call provokes this error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The reason this does not work is that `q.convert2float(15)` is precisely equivalent
    to `RationalNumber.convert2float(q,15)`, which fails because `RationalNumber.convert2float`
    takes only one argument.
  prefs: []
  type: TYPE_NORMAL
- en: Special methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The special method `__repr__` gives us the ability to define the way the object
    is represented in a Python interpreter. For rational numbers, a possible definition
    of this method could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: With this method defined, just typing `q` returns 10 / 20.
  prefs: []
  type: TYPE_NORMAL
- en: 'We would like to have a method that performs addition of two rational numbers.
    A first attempt could result in a method like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'A call to this method takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'It would be much nicer if we could write `q + p` instead. But so far, the plus
    sign is not defined for the `RationalNumber` type. This is done by using the `__add__` special
    method. So, just renaming `add` to `__add__` allows for using the plus sign for
    rational numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The expression `q + p` is in fact an alias for the expression `q.__add__(p)`.
    In the table (*Table 8.1)*, you will find the special methods for binary operators,
    such as `+`, `-`, or `*`.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Method** | **Operator** | **Method** |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | `__add__` | `+=` | `__iadd__` |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | `__mul__` | `*=` | `__imul__` |'
  prefs: []
  type: TYPE_TB
- en: '| `-` | `__sub__` | `-=` | `__isub__` |'
  prefs: []
  type: TYPE_TB
- en: '| `/` | `__truediv__` | `/=` | `__itruediv__` |'
  prefs: []
  type: TYPE_TB
- en: '| `//` | `__floordiv__` | `//=` | `__ifloordiv__` |'
  prefs: []
  type: TYPE_TB
- en: '| `**` | `__pow__` |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `==` | `__eq__` | `!=` | `__ne__` |'
  prefs: []
  type: TYPE_TB
- en: '| `<=` | `__le__` | `<` | `__lt__` |'
  prefs: []
  type: TYPE_TB
- en: '| `>=` | `__ge__` | `>` | `__gt__` |'
  prefs: []
  type: TYPE_TB
- en: '| `()` | `__call__` | `[]` | `__getitem__` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 8.1: Some Python operators & corresponding class methods, you can find
    the complete list [[31]](apa.html "Appendix . References")'
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of those operators for a new class is called operator overloading.
    Another example of operator overloading is a method for examining whether two
    rational numbers are the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'It is used like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Operations between objects belonging to different classes need special care:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: By default, the `+` operator invokes the left operand’s method, `__add__`. We
    programmed it so that it allows both, objects of type `int` and objects of type
    `RationalNumber`. In the statement `5 + p`, the operands are commuted and the
    `__add__` method of the build-in `int` type is invoked. This method returns an
    error as it does not know how to handle rational numbers. This case can be handled
    by the method `__radd__`, with which we will equip the `RationalNumber` class
    now. The method `__radd__` is called reverse addition.
  prefs: []
  type: TYPE_NORMAL
- en: Reverse operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If operations like `+` are applied to two operands of different types, the corresponding
    method (in this case, `__add__`) of the left operand is invoked first. If this
    raises an exception, the reverse method (here, `__radd__`) of the right operand
    is called. If this method does not exist, a `TypeError` exception is raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider an example of reverse operation. In order to enable the operation
    5+*p* where *p* is an instance of `RationalNumber`, we define this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note that `__radd__` interchanges the order of the arguments; `self` is the
    object of type `RationalNumber` while other is the object that has to be converted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a class instance together with brackets*,* ( *,* ) or [ , ] invokes a
    call to one of the special methods `__call__` or `__getitem__`, giving the instance
    the behavior of a function or of an iterable (refer to the T*able 8.1* for these
    and other special methods):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Which now may be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `__getitem__` special method makes sense if the class provides an iterator
    (It is recommended to refer section *Iterators* in [Chapter 9](ch09.html "Chapter 9. Iterating"),
    *Iterating* before you consider the following example).
  prefs: []
  type: TYPE_NORMAL
- en: 'The recursion *u[i+1] = a*[1]*u[i]*+ *a*[0]*u[i]*[-1]is called a three*-*term
    recursion. It plays an important role in applied mathematics, in particular in
    the construction of orthogonal polynomials. We can set up a three-term recursion
    as a class in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `__iter__` method defines a generator object, which allows us to
    use an instance of the class as an iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `__getitem__` method enables us to directly access the iterates as if `r3`
    were a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note that we used `itertools.islice` when coding the `__getitem__` method (refer
    to section *Iterators* of [Chapter 9](ch09.html "Chapter 9. Iterating"), *Iterating*,
    for more information). An example of the use of `__getitem__` together with slices
    and the function `ogrid` is given in the section *Function with two variables*
    in [Chapter 5](ch05.html "Chapter 5. Advanced Array Concepts"), *Advance Array
    Concepts*.
  prefs: []
  type: TYPE_NORMAL
- en: Attributes that depend on each other
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Attributes of an instance can be changed (or created) by simply assigning them
    a value. However, if other attributes depend on the one just changed, it is desirable
    to change these simultaneously:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us consider a class that defines an object for planar triangles from three
    given points. A first attempt to set up such a class could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'An instance of this triangle is created by this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'And its area is computed by this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If we change an attribute, say point *B*, the corresponding edges *a* and *c* are
    not automatically updated and the computed area is wrong:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: A remedy is to define a method that is executed when an attribute is changed;
    such a method is called a setter method. Correspondingly, one might ask for a
    method that is executed when a value of an attribute is requested; such a method
    is called a getter method.
  prefs: []
  type: TYPE_NORMAL
- en: The property function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The function `property`  links an attribute to such a getter, setter, and deleter
    method. It might also be used to assign a documentation string to an attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We continue with the previous example with a setter method and consider the `Trinagle` class
    again. If the following statement is included in `Triangle`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: a command
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: invokes the setter method, `set_B`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us modify the Triangle class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If the attribute `B` is changed, then the method `set_B` stores the new value
    in the internal attribute `_B` and changes all depending attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The way the `deleter` method is used here is to prevent deletion of attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The use of an underscore as a prefix of attribute names is a convention used
    to indicate attributes that are not designed to be accessed directly. They are
    intended to hold data for attributes handled by setters and getters. These attributes
    are not private in the sense of other programming languages; they are just not
    intended to be accessed directly.
  prefs: []
  type: TYPE_NORMAL
- en: Bound and unbound methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now take a closer look at attributes that are methods. Let us consider
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'A little inspection shows us how the nature of `func` changes after creating
    an instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling, for example,  `A.func(3)` would result in an error message such as
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '`instA.func(3)` is executed as expected. Upon creation of an instance, the
    `func` method is bound to the instance. The `self` argument gets the instance
    assigned as its value. Binding a method to an instance makes the method usable
    as a function. Before that, it is of no use. Class methods, which we will consider
    later, are different in this aspect.'
  prefs: []
  type: TYPE_NORMAL
- en: Class attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Attributes specified in the class declaration are called class attributes.
    Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Class attributes are useful for simulating default values and can be used if
    values have to be reset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Both instances have an attribute, `tol`, with the value initialized in the
    class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Altering the class attribute automatically affects all the corresponding attributes
    of all instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Altering `tol` for one instance does not affect the other instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'But now `N2.tol` is detached from the class attribute. Changing `Newton.tol`
    no longer has any effect on `N2.tol`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Class methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw in the previous section on *Bound and unbound methods* how methods are
    either bound to an instance of a class or remain in a state as unbound methods.
    Class methods are different. They are always bound methods. They are bound to
    the class itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first describe the syntactic details and then give some examples to
    show what these methods can be used for. To indicate that a method is a class
    method the decorator line precedes the method definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: While standard methods make a reference to an instance by the use of their first
    argument, the first argument of a class method refers to the class itself. By
    convention the first argument is called `self` for standard methods and `cls`
    for class methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Standard case:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Class method case:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In practice, class methods may be useful for executing commands before an instance
    is created, for instance, in a preprocessing step. See the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example we show how class methods can be used to prepare data before
    creating an instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The class is designed so, that a polynomial object is created by specifying
    its coefficients. Alternatively, the `by_points` class method allows us to define
    a polynomial by interpolation points. We can transform the interpolation data
    to the polynomial coefficients even when no instance of Polynomial is available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Another example of a class method is presented in an example later in this chapter.
    In that example, a class method is used to access information related to several
    (or all) instances from this class.
  prefs: []
  type: TYPE_NORMAL
- en: Subclassing and inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will introduce some central concepts from object-oriented
    programming: abstract classes, subclasses, and inheritance. To guide you through
    these concepts, we consider another mathematical example: one-step methods for
    solving a differential equation. The generic form of an ordinary initial value
    problem is'
  prefs: []
  type: TYPE_NORMAL
- en: '![Subclassing and inheritance](img/ode.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The data is the right-hand side function *f*, the initial value *x[0]*, and
    the interval of interest [*t*[0]*, t*[e]]. The solution of this problem is a function
    ![Subclassing and inheritance](img/realvaluedfunction.jpg). A numerical algorithm
    gives this solution as a vector *u* of discrete values *u[i]* being approximations
    to *x*(*t[i]*). Here, ![Subclassing and inheritance](img/B05511_08_02.jpg)are
    discretized values of the independent variable *t*, which in physical models often
    represents time.
  prefs: []
  type: TYPE_NORMAL
- en: 'A one-step method constructs the solution values *u[i]* by the recursion steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Subclassing and inheritance](img/onestep.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, Φ is a step function that characterizes the individual methods (refer
    to [[28]](apa.html "Appendix . References")):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Explicit Euler**:   ![Subclassing and inheritance](img/B05511_08_03.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Midpoint Rule**:   ![Subclassing and inheritance](img/B05511_08_04.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Runge–Kutta 4**:  ![Subclassing and inheritance](img/B05511_08_05.jpg) with 
    ![Subclassing and inheritance](img/B05511_08_06.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What we did here is the typical way of describing a mathematical algorithm.
    We first described a method by its idea, giving its steps in an abstract way.
    To actually use it, we have to fill in the parameters of a concrete method, in
    this example, the function Φ. This is also the way things are explained in object-oriented
    programming. First, we set up a class with the abstract description of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This abstract class, with its methods, is used as a template for the individual
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that in the class definitions, the name of the abstract class that we
    used as a template,  `OneStepMethod`, is given as an extra argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'That class is called the parent class. All methods and attributes of the parent
    class are inherited by the subclasses as long as they are not overridden. They
    are overridden if they are redefined in the subclass. The `step` method is redefined
    in the subclasses, while the method `generate` is generic for the entire family
    and therefore inherited from the parent. Before considering further details, we
    will demonstrate how these three classes can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'You can avoid the repetition of common parameter lists by using the star operator
    (refer to section *Variable Number of Argument* in [Chapter 7](ch07.html "Chapter 7. Functions"),
    *Functions* for more details):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Note that the abstract class has never been used to create an instance. As the
    `step` method was not completely defined, calling it raises an exception of type
    `NotImplementedError`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes one has to access the methods or attributes of a parent class. This
    is done using the command `super`. This is useful when the child class uses its
    own `__init__` method in order to extend the parent’s `__init__`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example let us assume that we want to give every solver class a string
    variable with the solver’s name. To this end, we provide the solver with an `__init__`
    method as it overrides the parent’s `__init__` method. In the case that both methods
    should be used, we have to refer to the parent’s method by the command `super`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Note that one could use the name of the parent class explicitly. The use of
    `super` instead allows us to change the name of the parent class without having
    to change all the references to the parent class.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes the use of inheritance is impractical or even impossible. This motivates
    the use of encapsulation. We will explain the concept of encapsulation by considering
    Python functions, that is, objects of the Python type `function`, which we encapsulate
    in a new class, `Function`, and provide with some relevant methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `__add__` and `__mul__` operations should return an instance
    of the same class. This is achieved by the `return type(self)(sum)` statement,
    which in this case is a more general form of writing `return Function(sum)`. We
    can now derive subclasses by inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider as an example  Chebyshev polynomials which can be computed in the
    interval [1,-1] by:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Encapsulation](img/cheby2.jpg).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We construct a Chebyshev polynomial as an instance of the `Function` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Chebyshev polynomials are orthogonal in the sense:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Encapsulation](img/cheby1-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This can easily be checked using this construction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Without encapsulation multiplying functions as simply as writing  `weight *
    T5 * T6` would not have been possible.
  prefs: []
  type: TYPE_NORMAL
- en: Classes as decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In section *Function as decorators* in [Chapter 7](ch07.html "Chapter 7. Functions"),
    *Functions* , we saw how functions can be modified by applying another function
    as a decorator. In previous examples, we saw how classes can be made to behave
    as functions as long as they are provided with the `__call__` method. We will
    use this here to show how classes can be used as decorators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us assume that we want to change the behavior of some functions in such
    a way that before the function is invoked, all input parameters are printed. This
    could be useful for debugging purposes. We take this situation as an example to
    explain the use of a decorator class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We use this class to decorate function definitions,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: and call the function as usual,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'On the second call, we obtain the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This example shows that both classes and functions can be used as decorators.
    Classes allow for more possibilities, as they can be used to collect data as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Indeed, we observe that:'
  prefs: []
  type: TYPE_NORMAL
- en: Every decorated function creates a new instance of the decorator class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data collected by one instance can be saved and made accessible to another instance
    by class attributes (refer section *Attributes* in [Chapter 8](ch08.html "Chapter 8. Classes"),
    *Classes)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last point emphasizes the difference with function decorators. We show this
    now by a decorator that counts function calls and stores the result in a dictionary
    with the function as key.
  prefs: []
  type: TYPE_NORMAL
- en: In order to analyze the performance of algorithms, it might be useful to count
    the calls of particular functions. We can get counter information without changing
    the function definition. The code is a slight modification of an example given
    in [[4]](apa.html "Appendix . References") .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we use the class attribute `CountCalls.instances`  to store the counters
    for each individual instance. Let us see how this decorator works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important programming concepts in modern computer science is
    object-oriented programming. We learned in this chapter how to define objects
    as instances of classes, which we provide with methods and attributes. The first
    parameter of methods, usually denoted by `self`, plays an important and special
    role. You saw methods that can be used to define basic operations such as `+`
    and `*` for your own classes.
  prefs: []
  type: TYPE_NORMAL
- en: While in other programming languages attributes and methods can be protected
    against unintended use, Python allows a technique to hide attributes and access
    these hidden attributes through special getter and setter methods. To this end,
    you met an important function, `property`.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Ex. 1** → Write a method `simplify` to the class `RationalNumber`. This method
    should return the simplified version of the fraction as a tuple.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 2** → To provide results with confidence intervals a special calculus,
    so-called interval arithmetic is introduced in numerical mathematics; (refer to
    [[3, 14]](apa.html "Appendix . References")*)*. Define a class called `Interval`
    and provide it with methods for addition, subtraction, division, multiplication,
    and power (with positive integers only). These operations obey the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercises](img/B05511_08_01.jpg).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Provide this class with methods that allow operations of the type *a* + *I,
    a I, I* + *a, I a*, where *I* is an interval and *a* an integer or float. Convert
    an integer or float to an interval `[a,a]` first. (Hint: you may want to use function
    decorators for this; (refer to section *Function as decorators* in [Chapter 7](ch07.html
    "Chapter 7. Functions"), *Functions*). Furthermore, implement the `__contains__`
    method, which enables you to check if a given number belongs to the interval using
    the syntax `x in I` for an object `I` of type Interval. Test your class by applying
    a polynomial `f=lambda x: 25*x**2-4*x+1` to an interval.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 3** → Consider the example under section *Classes as decorators*. Extend
    this example to obtain a *function decorator* that counts how often a certain
    function is called.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 4** → Compare the two ways to implement a method for reverse addition
    `__radd__` in the class `RationalNumber`: the one given in the example in section
    *Special methods* and the one given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Do you expect an error in this version? What is the error and how do you explain
    it? Test your answer by executing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '**Ex. 4** → Consider the decorator class `CountCalls` as in example in section
    *Classes as decorators*. Provide this class with a method, `reset`, which sets
    the counters of all functions in the dictionary, `CountCalls.instances`, to zero.
    What would happen if the dictionary were replaced by an empty dictionary instead?'
  prefs: []
  type: TYPE_NORMAL
