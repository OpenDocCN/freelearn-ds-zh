- en: Working with pgRouting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 pgRouting
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Startup – Dijkstra routing
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动 – Dijkstra 路由
- en: Loading data from OpenStreetMap and finding the shortest path using A*
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 OpenStreetMap 加载数据并使用 A* 寻找最短路径
- en: Calculating the driving distance/service area
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算驾驶距离/服务区域
- en: Calculating the driving distance with demographics
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用人口统计数据计算驾驶距离
- en: Extracting the centerlines of polygons
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取多边形的中心线
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'So far, we have used PostGIS as a vector and raster tool, using relatively
    simple relationships between objects and simple structures. In this chapter, we
    review an additional PostGIS-related extension: **pgRouting**. pgRouting allows
    us to interrogate graph structures in order to answer questions such as "What
    is the shortest route from where I am to where I am going?" This is an area that
    is heavily occupied by the existing web APIs (such as Google, Bing, MapQuest,
    and others) and services, but it can be better served by *rolling our own* services
    for many use cases. Which cases? It might be a good idea to create our own services
    in situations where we are trying to answer questions that aren''t answered by
    the existing services; where the data available to us is better or more applicable;
    or where we need or want to avoid the terms of service conditions for these APIs.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已将 PostGIS 作为矢量工具和栅格工具使用，使用相对简单的对象关系和简单结构。在本章中，我们将回顾一个额外的与 PostGIS 相关的扩展：**pgRouting**。pgRouting
    允许我们查询图结构，以回答诸如“我从哪里到我要去的最短路线是什么？”等问题。这是一个现有网络 API（如 Google、Bing、MapQuest 等）和服务高度占据的领域，但我们可以通过*自己构建*服务来更好地服务于许多用例。哪些用例？在尝试回答现有服务未解决的问题、我们拥有的数据更好或更适用，或者我们需要或希望避免这些
    API 的服务条款的情况下，创建自己的服务可能是个好主意。
- en: Startup – Dijkstra routing
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动 – Dijkstra 路由
- en: pgRouting is a separate extension used in addition to PostGIS, which is now
    available in the PostGIS bundle on the Application Stack Builder (recommended
    for Windows). It can also be downloaded and installed by DEB, RPM, and macOS X
    packages and Windows binaries available at [http://pgrouting.org/download.html](http://pgrouting.org/download.html).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: pgRouting 是一个独立的扩展，除了 PostGIS 之外还可以使用，现在它已经包含在 Application Stack Builder 上的
    PostGIS 套件中（推荐用于 Windows）。它也可以通过 DEB、RPM、macOS X 软件包和 Windows 可执行文件进行下载和安装，这些文件可在
    [http://pgrouting.org/download.html](http://pgrouting.org/download.html) 找到。
- en: For macOS users, it is recommended that you use the source packages available
    on Git ([https://github.com/pgRouting/pgrouting/releases](https://github.com/pgRouting/pgrouting/releases)),
    and use CMake, available at [https://cmake.org/download/](https://cmake.org/download/),
    to make the installation build.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 macOS 用户，建议您使用 Git 上的源代码包（[https://github.com/pgRouting/pgrouting/releases](https://github.com/pgRouting/pgrouting/releases)），并使用
    CMake 进行构建安装，CMake 可在 [https://cmake.org/download/](https://cmake.org/download/)
    找到。
- en: Packages for Linux Ubuntu users can be found at [http://trac.osgeo.org/postgis/wiki/UsersWikiPostGIS22UbuntuPGSQL95Apt](http://trac.osgeo.org/postgis/wiki/UsersWikiPostGIS22UbuntuPGSQL95Apt).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Linux Ubuntu 用户的软件包可以在 [http://trac.osgeo.org/postgis/wiki/UsersWikiPostGIS22UbuntuPGSQL95Apt](http://trac.osgeo.org/postgis/wiki/UsersWikiPostGIS22UbuntuPGSQL95Apt)
    找到。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'pgRouting doesn''t deal well with nondefault schemas, so before we begin, we
    will set the schema in our user preferences using the following command:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: pgRouting 不太擅长处理非默认模式，因此在我们开始之前，我们将使用以下命令设置我们的用户首选项中的模式：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we need to add the `pgrouting` extension to our database. If PostGIS
    is not already installed on the database, we''ll need to add it as an extension
    as well:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将 `pgrouting` 扩展添加到我们的数据库中。如果 PostGIS 还未安装到数据库中，我们需要将其作为扩展添加：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We will start by loading a test dataset. You can get some really basic sample
    data from [http://docs.pgrouting.org/latest/en/sampledata.html](http://docs.pgrouting.org/latest/en/sampledata.html).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先加载一个测试数据集。您可以从 [http://docs.pgrouting.org/latest/en/sampledata.html](http://docs.pgrouting.org/latest/en/sampledata.html)
    获取一些非常基本的样本数据。
- en: This sample data consists of a small grid of streets in which any functions
    can be run.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个样本数据由一个小街道网格组成，其中可以运行任何功能。
- en: 'Then, run the create table and data insert scripts available at the dataset
    website. You should make adjustments to preserve the schema structure for `chp06`—for
    example:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行数据集网站上的创建表和数据插入脚本。您应该调整以保留 `chp06` 的模式结构——例如：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now that the data is loaded, let''s build topology on the table (if you haven''t
    already done this during the data-load process):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数据已加载，让我们在表上构建拓扑（如果您在数据加载过程中还没有这样做）：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Building a topology creates a new node table—`chp06.edge_table_vertices_pgr`—for
    us to view. This table will aid us in developing queries.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 构建拓扑为我们创建了一个新的节点表—`chp06.edge_table_vertices_pgr`—以便我们查看。这个表将帮助我们开发查询。
- en: How to do it...
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Now that the data is loaded, we can run a quick test. We'll use a simple algorithm
    called Dijkstra to calculate the shortest path from node 5 to node 12.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数据已加载，我们可以进行快速测试。我们将使用一个简单的算法Dijkstra来计算从节点5到节点12的最短路径。
- en: Dijkstra's algorithm is an effective and simple routing algorithm that runs
    a search on all available paths from point A to point B in a network, also known
    as the **graph structure**. It is not the most efficient routing algorithm, but
    will always find the best route. For more information on Dijkstra's algorithm,
    refer to Wikipedia, which has a good explanation, with illustrations, at [http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm](http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm).
    The animation at [http://en.wikipedia.org/wiki/File:Dijkstras_progress_animation.gif](http://en.wikipedia.org/wiki/File:Dijkstras_progress_animation.gif)
    is particularly helpful.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Dijkstra算法是一种有效且简单的路由算法，它在网络中从点A到点B的所有可用路径上运行搜索，也称为**图结构**。它不是最有效的路由算法，但总是会找到最佳路线。有关Dijkstra算法的更多信息，请参考维基百科，它有很好的解释，并配有插图，请参阅[http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm](http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)。[http://en.wikipedia.org/wiki/File:Dijkstras_progress_animation.gif](http://en.wikipedia.org/wiki/File:Dijkstras_progress_animation.gif)中的动画特别有帮助。
- en: 'An important point to note is that the nodes created in pgRouting during the
    topology creation process are created unintentionally for some versions. This
    has been patched in future versions, but for some versions of pgRouting, this
    means that your node numbers will not be the same as those we use here in the
    book. View your data in an application to determine which nodes to use or whether
    you should use a k-nearest neighbors search for the node nearest to a static geographic
    point. See [Chapter 11](e708d3c0-02ba-49ec-aaa1-b65693dee5ed.xhtml), *Using Desktop
    Clients*, for more information on viewing PostGIS data and [Chapter 4](68182eea-7041-4488-9f05-188b0a493ba5.xhtml),
     *Working with Vector Data – Advanced Recipes*, for approaches to finding the
    nearest node automatically:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一个重要点是，在pgRouting拓扑创建过程中创建的节点在某些版本中是不经意间创建的。这在未来的版本中已经得到了修复，但对于某些版本的pgRouting来说，这意味着您的节点编号将不会与本书中使用的节点编号相同。在应用程序中查看您的数据以确定要使用哪些节点，或者您是否应该使用k-最近邻搜索来找到最近的静态地理点。有关查看PostGIS数据的更多信息，请参阅[第11章](e708d3c0-02ba-49ec-aaa1-b65693dee5ed.xhtml)，*使用桌面客户端*，以及有关自动查找最近节点的方法的[第4章](68182eea-7041-4488-9f05-188b0a493ba5.xhtml)，*处理矢量数据
    - 高级食谱*：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding query will result in the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 上述查询将产生以下结果：
- en: '**![](img/fb6e007f-aa22-4b3f-9fe6-e7588dc042d7.png)**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](img/fb6e007f-aa22-4b3f-9fe6-e7588dc042d7.png)**'
- en: 'When we ask for a route using Dijkstra and other routing algorithms, the result
    often comes in the following form:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用Dijkstra和其他路由算法请求路线时，结果通常以下列形式出现：
- en: '`seq`: This returns the sequence number so we can maintain the order of the
    output'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seq`：这返回序列号，以便我们可以保持输出的顺序'
- en: '`node`: This is the node ID'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`node`：这是节点ID'
- en: '`edge`: This is the edge ID'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`edge`：这是边ID'
- en: '`cost`: This is the cost for the route traversal (often, the distance)'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cost`：这是路线遍历的成本（通常是距离）'
- en: '`agg_cost`: This is the aggregated cost for the route from the starting node'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`agg_cost`：这是从起始节点到路线的聚合成本'
- en: 'For example, to get the geometry back, we need to rejoin the edge IDs with
    the original table. To make this approach work transparently, we will use the
    `WITH` common table expression to create a temporary table to which we will join
    our geometry:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要获取几何形状，我们需要将边ID与原始表重新连接。为了使这种方法透明地工作，我们将使用`WITH`公共表表达式创建一个临时表，然后我们将将其与我们的几何形状连接：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding code will give the following output:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将给出以下输出：
- en: '**![](img/1d23b34b-b5eb-4c36-a988-79cb0fb39b1f.png)**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](img/1d23b34b-b5eb-4c36-a988-79cb0fb39b1f.png)**'
- en: 'Congratulations! You have just completed a route in pgRouting. The following
    diagram illustrates this scenario:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您刚刚在pgRouting中完成了一条路线。以下图表说明了这一场景：
- en: '![](img/60b29bbe-fcaa-46e6-9992-76e19fb05d40.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/60b29bbe-fcaa-46e6-9992-76e19fb05d40.png)'
- en: Loading data from OpenStreetMap and finding the shortest path using A*
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从OpenStreetMap加载数据并使用A*算法找到最短路径
- en: Test data is great for understanding how algorithms work, but the real data
    is often more interesting. A good source for real data worldwide is **OpenStreetMap**
    (**OSM**), a worldwide, accessible, wiki-style, geospatial dataset. What is wonderful
    about using OSM in conjunction with pgRouting is that it is inherently a topological
    model, meaning that it follows the same kinds of rules in its construction as
    we do in graph traversal within pgRouting. Because of the way editing and community
    participation works in OSM, it is often an equally good or better data source
    than commercial ones and is, of course, quite compatible with our open source
    model.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 测试数据对于理解算法的工作原理非常有用，但真实数据通常更有趣。全球真实数据的良好来源是**OpenStreetMap**（**OSM**），这是一个全球性的、可访问的、维基风格的地理空间数据集。使用OSM与pgRouting结合的奇妙之处在于，它本质上是一个拓扑模型，这意味着它在构建时遵循与我们在pgRouting中的图遍历相同的规则。由于OSM中的编辑和社区参与方式，它通常与商业数据源一样好，甚至更好，并且当然与我们的开源模式非常兼容。
- en: Another great feature is that there is free and open source software to ingest
    OSM data and import it into a routing database—`osm2pgrouting`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很棒的功能是，有免费的开源软件可以导入OSM数据并将其导入到路由数据库中——`osm2pgrouting`。
- en: Getting ready
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: It is recommended that you get the downloadable files from the example dataset
    that we have provided, available at [http://www.packtpub.com/support](http://www.packtpub.com/support).
    You will be using the XML OSM data. You can also get custom extracts directly
    from the web interface at [http://www.openstreetmap.org/](http://www.openstreetmap.org/)or
    by using the overpass turbo interface to access OSM data ([https://overpass-turbo.eu/](https://overpass-turbo.eu/)),
    but this could limit the area we would be able to extract.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 建议您从我们提供的示例数据集中下载可下载的文件，该数据集可在[http://www.packtpub.com/support](http://www.packtpub.com/support)找到。您将使用XML
    OSM数据。您也可以直接从网页界面[http://www.openstreetmap.org/](http://www.openstreetmap.org/)或通过使用overpass
    turbo界面访问OSM数据([https://overpass-turbo.eu/](https://overpass-turbo.eu/))来获取定制提取，但这可能会限制我们能够提取的区域。
- en: Once we have the data, we need to unzip it using our favorite compression utility.
    Double-clicking on the file to unzip it will typically work on Windows and macOS
    machines. Two good utilities for unzipping on Linux are `bunzip2` and `zip`. What
    will remain is an XML extract of the data we want for routing. In our use case,
    we are downloading the data for the greater Cleveland area.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了数据，我们需要使用我们喜欢的压缩工具解压它。在Windows和macOS机器上，双击文件通常可以解压。Linux上解压的两个好工具是`bunzip2`和`zip`。剩下的就是我们想要的用于路由的XML数据提取。在我们的用例中，我们正在下载克利夫兰地区的相关数据。
- en: Now we need a utility for placing this data into a routable database. An example
    of one such tool is `osm2pgrouting`, which can be downloaded and compiled using
    the instructions at [http://github.com/pgRouting/osm2pgrouting](http://github.com/pgRouting/osm2pgrouting).
    Use CMake from [https://cmake.org/download/](https://cmake.org/download/) to make
    the installation build in macOS. For Linux Ubuntu users there is an available
    package at [https://packages.ubuntu.com/artful/osm2pgrouting](https://packages.ubuntu.com/artful/osm2pgrouting).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个工具将数据放入可路由的数据库中。一个这样的工具示例是`osm2pgrouting`，可以通过[http://github.com/pgRouting/osm2pgrouting](http://github.com/pgRouting/osm2pgrouting)上的说明进行下载和编译。使用[https://cmake.org/download/](https://cmake.org/download/)中的CMake在macOS上构建安装。对于Linux
    Ubuntu用户，有一个可用的包[https://packages.ubuntu.com/artful/osm2pgrouting](https://packages.ubuntu.com/artful/osm2pgrouting)。
- en: How to do it...
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'When `osm2pgrouting` is run without anything set, the output shows us the options
    that are required and available to use with `osm2pgrouting`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当`osm2pgrouting`在没有设置任何内容的情况下运行时，输出会显示`osm2pgrouting`所需的和可用的选项：
- en: '![](img/e6584ad6-f42a-4618-869f-52d5d075c430.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e6584ad6-f42a-4618-869f-52d5d075c430.png)'
- en: 'To run the `osm2pgrouting` command, we have a small number of required parameters.
    Double-check the paths pointing to `mapconfig.xml` and `cleveland.osm` before
    running the following command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行`osm2pgrouting`命令，我们需要一些必要的参数。在运行以下命令之前，请仔细检查指向`mapconfig.xml`和`cleveland.osm`的路径：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Our dataset may be quite large, and could take some time to process and import—be
    patient. The end of the output should say something like the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据集可能相当大，处理和导入可能需要一些时间——请耐心等待。输出结果的结尾应该类似于以下内容：
- en: '![](img/6c33f9d8-6827-4a6e-ae5d-88269e323bad.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6c33f9d8-6827-4a6e-ae5d-88269e323bad.png)'
- en: Our new vector table, by default, is named `cleveland_ways`. If no `-prefix`
    flag was used, the table name would just be `ways`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新向量表默认命名为 `cleveland_ways`。如果没有使用 `-prefix` 标志，表名就只是 `ways`。
- en: 'You should have the created following tables:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该创建了以下表：
- en: '![](img/e3055d46-dc72-432f-b043-06e109fa52ee.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e3055d46-dc72-432f-b043-06e109fa52ee.png)'
- en: How it works...
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`osm2pgrouting` is a powerful tool that handles a lot of the translation of
    OSM data into a format that can be used in pgRouting. In this case, it creates
    eight tables from our input file. Of those eight, we''ll address the two primary
    tables: the `ways` table and the `nodes` table.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`osm2pgrouting` 是一个强大的工具，它处理将 OSM 数据转换为可用于 pgRouting 的格式的许多翻译工作。在这种情况下，它从我们的输入文件中创建八个表。在这八个表中，我们将关注两个主要表：`ways`
    表和 `nodes` 表。'
- en: Our `ways` table is a table of the lines that represent all our streets, roads,
    and trails that are in OSM. The nodes table contains all the intersections. This
    helps us identify the beginning and end points for routing.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `ways` 表代表所有在 OSM 中的街道、道路和小径的线条表。节点表包含所有交叉口。这有助于我们识别路由的起点和终点。
- en: Let's apply an *A* ("A star")* routing approach to this problem.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们应用 *A*（“A 星”）路由方法来解决这个问题。
- en: '*A** is an extension of Dijkstra''s algorithm which uses a heuristic to speed
    up the search for the shortest path, at the cost of occasionally not finding the
    optimum route. See [http://en.wikipedia.org/wiki/A*](http://en.wikipedia.org/wiki/A*)
    and [http://en.wikipedia.org/wiki/File:Astar_progress_animation.gif](http://en.wikipedia.org/wiki/File:Astar_progress_animation.gif)
    for more information.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*A* 是迪杰斯特拉算法的一个扩展，它使用启发式方法来加速最短路径的搜索，但偶尔可能无法找到最优路径。有关更多信息，请参阅 [http://en.wikipedia.org/wiki/A*](http://en.wikipedia.org/wiki/A*)
    和 [http://en.wikipedia.org/wiki/File:Astar_progress_animation.gif](http://en.wikipedia.org/wiki/File:Astar_progress_animation.gif)。'
- en: 'You will recognize the following syntax from Dijkstra:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从迪杰斯特拉算法中识别出以下语法：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following screenshot shows the results displayed on a map (map tiles by
    *Stamen Design, under CC BY 3.0*; data by *OpenStreetMap, under CC BY SA*):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在地图上显示的结果（地图瓦片由 *Stamen Design 提供，根据 CC BY 3.0 许可；数据由 *OpenStreetMap
    提供，根据 CC BY SA 许可））：
- en: '![](img/dc488ec7-e796-40fa-9241-0bb1c210d78d.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc488ec7-e796-40fa-9241-0bb1c210d78d.png)'
- en: Sample calculated route with pgRouting visualized in QGIS
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 pgRouting 在 QGIS 中可视化的示例计算路线
- en: Calculating the driving distance/service area
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算驾驶距离/服务区域
- en: Driving distance (`pgr_drivingDistance`) is a query that calculates all nodes
    within the specified driving distance of a starting node. This is an optional
    function compiled with pgRouting; so if you compile pgRouting yourself, make sure
    that you enable it and include the CGAL library, an optional dependency for `pgr_drivingDistance`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 驾驶距离（`pgr_drivingDistance`）是一个查询，它计算从起始节点到指定驾驶距离内的所有节点。这是一个可选的 pgRouting 函数；因此，如果你自己编译
    pgRouting，请确保启用它并包含 CGAL 库，这是 `pgr_drivingDistance` 的一个可选依赖项。
- en: Driving distance is useful when *user sheds* are needed that give realistic
    driving distance estimates, for example, for all customers with five miles driving,
    biking, or walking distance. These estimates can be contrasted with buffering
    techniques, which assume no barrier to travelling and are useful for revealing
    the underlying structures of our transportation networks relative to individual
    locations.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 驾驶距离在需要提供真实驾驶距离估计时很有用，例如，对于所有距离五英里以驾驶、骑行或步行方式到达的客户。这些估计可以与缓冲技术进行对比，缓冲技术假设没有旅行障碍，并且对于揭示与个人位置相关的交通网络的基本结构很有用。
- en: Getting ready
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will load the same dataset that we used in the *Startup – Dijkstra routing*
    recipe. Refer to this recipe to import data.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将加载与 *Startup – Dijkstra 路由* 菜单中使用的相同数据集。请参考此菜谱以导入数据。
- en: How to do it...
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In the following example, we will look at all users within a distance of three
    units from our starting point—that is, a proposed bike shop at node 2:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将查看距离起点三单位距离内的所有用户——即节点 2 处的一个提议的自行车店：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding command gives the following output:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令给出了以下输出：
- en: '![](img/20daab54-0c5d-4db5-b929-b7eb6bcc2979.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/20daab54-0c5d-4db5-b929-b7eb6bcc2979.png)'
- en: 'As usual, we just get a list from the `pgr_drivingDistance` table that, in
    this case, comprises sequence, node, edge cost, and aggregate cost. PgRouting,
    like PostGIS, gives us low-level functionality; we need to reconstruct what geometries
    we need from that low-level functionality. We can use that node ID to extract
    the geometries of all of our nodes by executing the following script:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们只是从 `pgr_drivingDistance` 表中获取一个列表，在这个例子中，它包括序列、节点、边成本和总成本。PgRouting，就像PostGIS一样，给我们提供了低级功能；我们需要从这些低级功能中重建我们需要的几何形状。我们可以使用那个节点ID来执行以下脚本，从而提取所有节点的几何形状：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding command gives the following output:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令给出了以下输出：
- en: '![](img/cc260d04-52fb-4d83-8b8f-45e3958351e4.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cc260d04-52fb-4d83-8b8f-45e3958351e4.png)'
- en: 'But the output seen is just a cluster of points. Normally, when we think of
    driving distance, we visualize a polygon. Fortunately, we have the `pgr_alphaShape`
    function that provides us that functionality. This function expects `id`, `x`,
    and `y` values for input, so we will first change our previous query to convert
    to `x` and `y` from the geometries in `edge_table_vertices_pgr`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们看到的是只是一个点簇。通常，当我们想到驾驶距离时，我们会将其可视化为一个多边形。幸运的是，我们有 `pgr_alphaShape` 函数提供了这个功能。这个函数期望输入
    `id`、`x` 和 `y` 值，因此我们首先将之前的查询更改为我们之前在 `edge_table_vertices_pgr` 中的几何形状转换为 `x`
    和 `y`：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/e6c051cc-4aeb-4127-8f5d-2406e1888ee4.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e6c051cc-4aeb-4127-8f5d-2406e1888ee4.png)'
- en: 'Now we can wrap the preceding script up in the `alphashape` function:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将前面的脚本包裹在 `alphashape` 函数中：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So first, we will get our cluster of points. As we did earlier, we will explicitly
    convert the text to geometric points:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先，我们将获取我们的点簇。正如我们之前所做的那样，我们将明确地将文本转换为几何点：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now that we have points, we can create a line by connecting them:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了点，我们可以通过连接它们来创建一条线：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, we construct the line as a polygon using `ST_MakePolygon`. This requires
    adding the start point by executing `ST_StartPoint` in order to properly close
    the polygon. The complete code is as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `ST_MakePolygon` 将线构造为多边形。这需要通过执行 `ST_StartPoint` 来添加起点，以便正确地闭合多边形。完整的代码如下：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Our first driving distance calculation can be better understood in the context
    of the following diagram, where we can reach nodes 9, 11, 13 from node 2 with
    a driving distance of 3:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第一次的驾驶距离计算可以通过以下图表更好地理解，其中我们可以从节点2以3英里的驾驶距离到达节点9、11、13：
- en: '![](img/77d41e55-eeb2-45b5-b776-41efc1129e64.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/77d41e55-eeb2-45b5-b776-41efc1129e64.jpg)'
- en: See also
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Calculating the driving distance with demographics* recipe
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用人口统计数据计算驾驶距离* 菜单'
- en: Calculating the driving distance with demographics
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用人口统计数据计算驾驶距离
- en: In the *Using polygon overlays for proportional census estimates* recipe in
    [Chapter 2](dec6904b-477f-4c16-a90f-7563a36c4652.xhtml), *Structures That Work*,
    we employed a simple buffer around a trail alignment in conjunction with the census
    data to get estimates of what the demographics were of the people within walking
    distance of the trail, estimated as a mile long. The problem with this approach,
    of course, is that it assumes that it is an "as the crow flies" estimate. In reality,
    rivers, large roads, and roadless stretches serve as real barriers to people's
    movement through space. Using pgRouting's `pgr_drivingDistance` function, we can
    realistically simulate people's movement on the routable networks and get better
    estimates. For our use case, we'll keep the simulation a bit simpler than a trail
    alignment—we'll consider the demographics of a park facility, say, the Cleveland
    Metroparks Zoo, and potential bike users within 4 miles of it, which adds up approximately
    to a 15-minute bike ride.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第2章](dec6904b-477f-4c16-a90f-7563a36c4652.xhtml) 的 *Using polygon overlays
    for proportional census estimates* 菜单中，我们在 *Structures That Work* 中使用了一个围绕小径对齐的简单缓冲区，结合人口统计数据来估计小径周围步行距离内的人们的统计数据，估计为1英里长。当然，这种方法的问题在于它假设这是一个“直线距离”的估计。实际上，河流、大型道路和没有道路的路段是人们穿越空间的真正障碍。使用
    pgRouting 的 `pgr_drivingDistance` 函数，我们可以在可路由网络上现实地模拟人们的移动，并获得更好的估计。对于我们的用例，我们将保持模拟比小径对齐简单一些——我们将考虑一个公园设施的人口统计数据，比如克利夫兰都会动物园，以及在其4英里范围内的潜在自行车使用者，这大约相当于15分钟的自行车骑行时间。
- en: Getting ready
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For our analysis, we will use the `proportional_sum` function from [Chapter
    2](dec6904b-477f-4c16-a90f-7563a36c4652.xhtml), *Structures That Work*, so if
    you have not added this to your PostGIS tool belt, run the following commands:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的分析，我们将使用[第2章](dec6904b-477f-4c16-a90f-7563a36c4652.xhtml)，*有效结构*中的`proportional_sum`函数，所以如果你还没有将其添加到你的PostGIS工具包中，请运行以下命令：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `proportional_sum` function will take our input geometry into account and
    the `count` value of the population and return an estimate of the proportional
    population.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`proportional_sum`函数将考虑我们的输入几何形状和人口计数值，并返回比例人口估计。'
- en: 'Now we need to load our census data. Use the following command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要加载我们的普查数据。使用以下命令：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Also, if you have not yet loaded the data mentioned in the *Loading data from
    OpenStreetMap and finding the shortest path A** recipe, take the time to do so
    now.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你还没有加载*从OpenStreetMap加载数据并找到最短路径A*配方中提到的数据，请现在花时间加载。
- en: Once all the data is entered, we can proceed with the analysis.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有数据都输入完毕，我们就可以进行分析了。
- en: How to do it...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The `pgr_drivingdistance` polygon we created is the first step in the demographic
    analysis. Refer to the *Driving distance/service area calculation* recipe if you
    need to familiarize yourself with its use. In this case, we''ll consider the cycling
    distance. The nearest node to the Cleveland Metroparks Zoo is 24746, according
    to our loaded dataset; so we''ll use that as the center point for our `pgr_drivingdistance`
    calculation and we''ll use approximately 6 kilometers as our distance, as we want
    to know the number of zoo visitors within this distance of the Cleveland Metroparks
    Zoo. However, since our data is using 4326 EPSG, the distance we will give the
    function will be in degrees, so 0.05 will give us an approximate distance of 6
    km that will work with the `pgr_drivingDistance` function:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的`pgr_drivingdistance`多边形是人口分析的第一步。如果你需要熟悉其使用，请参考*行驶距离/服务区域计算*配方。在这种情况下，我们将考虑骑行距离。根据我们加载的数据集，克利夫兰市立动物园最近的节点是24746；因此，我们将使用该点作为`pgr_drivingdistance`计算的中心点，并使用大约6公里作为我们的距离，因为我们想知道在克利夫兰市立动物园这个距离内的动物园游客数量。然而，由于我们的数据使用的是4326
    EPSG，我们将给函数提供的距离将以度为单位，因此0.05将给我们大约6公里的距离，这将与`pgr_drivingDistance`函数兼容：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding script gives us a very interesting shape (map tiles by *Stamen
    Design, under CC BY 3.0*; data by *OpenStreetMap, under CC BY SA*). See the following
    screenshot:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的脚本给我们一个非常有趣的形状（由*Stamen Design*设计，根据CC BY 3.0许可；数据由*OpenStreetMap*提供，根据CC
    BY SA许可）。请看以下截图：
- en: '![](img/1663b115-c4ac-4372-b671-21349efd1837.jpg)![](img/eeb3d160-d7f7-4f11-bdb9-55653d832832.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1663b115-c4ac-4372-b671-21349efd1837.jpg)![](img/eeb3d160-d7f7-4f11-bdb9-55653d832832.jpg)'
- en: 'In the previous screenshot, we can see the difference between the cycling distance
    across the real road network, shaded in blue, and the equivalent 4-mile buffer
    or as-the-crow-flies distance. Let''s apply this to our demographic analysis using
    the following script:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们可以看到实际道路网络中骑行的距离（用蓝色阴影表示）与等效的4英里缓冲区或直线距离之间的差异。让我们使用以下脚本将此应用于我们的人口分析：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output is as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/e4d7d9dd-e926-4266-86ca-0e3bc32f69ce.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e4d7d9dd-e926-4266-86ca-0e3bc32f69ce.png)'
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: So, how does the preceding output compare to what we would get if we look at
    the buffered distance?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，前面的输出与如果我们查看缓冲距离我们会得到什么相比如何？
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**![](img/be372de8-b81c-4f5c-9c50-3457da9f22b2.png)**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](img/be372de8-b81c-4f5c-9c50-3457da9f22b2.png)**'
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding output shows a difference of more than 60,000 people. In other
    words, using a buffer overestimates the population compared to using `pgr_drivingdistance`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出显示了超过60,000人的差异。换句话说，使用缓冲区比使用`pgr_drivingdistance`高估了人口。
- en: Extracting the centerlines of polygons
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提取多边形的中心线
- en: In several recipes in [Chapter 4](68182eea-7041-4488-9f05-188b0a493ba5.xhtml),
    *Working with Vector Data – Advanced Recipes*, we explored extracting Voronoi
    polygons from sets of points. In this recipe, we'll use the Voronoi function employed
    in the *Using external scripts to embed new functionality to calculate Voronoi
    polygons* section to serve as the first step in extracting the centerline of a
    polygon. One could also use the *Using external scripts to embed new functionality
    to calculate Voronoi polygons—advanced* recipe, which would run faster on large
    datasets. For this recipe, we will use the simpler but slower approach.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](68182eea-7041-4488-9f05-188b0a493ba5.xhtml)，“*处理矢量数据 - 高级食谱*”中的几个食谱中，我们探讨了从点集提取Voronoi多边形。在这个食谱中，我们将使用在“*使用外部脚本来嵌入新功能以计算Voronoi多边形*”部分中使用的Voronoi函数，作为提取多边形中心线的第一步。也可以使用“*使用外部脚本来嵌入新功能以计算Voronoi多边形
    - 高级*”食谱，它在大数据集上运行得更快。对于这个食谱，我们将使用更简单但更慢的方法。
- en: One additional dependency is that we will be using the `chp02.polygon_to_line(geometry)`
    function from the *Normalizing internal overlays* recipe in [Chapter 2](dec6904b-477f-4c16-a90f-7563a36c4652.xhtml),
    *Structures That Work*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个附加的依赖项是我们将使用来自[第2章](dec6904b-477f-4c16-a90f-7563a36c4652.xhtml)，“*正常化内部叠加*”食谱中的`chp02.polygon_to_line(geometry)`函数。
- en: 'What do we mean by the centerline of a polygon? Imagine a digitized stream
    flowing between its pair of banks, as shown in the following screenshot:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所说的多边形中心线是什么意思？想象一下一条数字化的河流在其两侧之间流动，如下面的截图所示：
- en: '![](img/f00a4afe-12be-4343-82aa-27ea584ad382.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/f00a4afe-12be-4343-82aa-27ea584ad382.png)'
- en: 'If we wanted to find the center of this in order to model the water flow, we
    could extract it using a skeletonization approach, as shown in the following screenshot:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要找到这个区域的中心以便模拟水流，我们可以使用骨架化方法来提取它，如下面的截图所示：
- en: '![](img/d7e6ef05-b751-40dc-a57e-116bdbe080da.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/d7e6ef05-b751-40dc-a57e-116bdbe080da.png)'
- en: The difficulty with skeletonization approaches, as we'll soon see, is that they
    are often subject to noise, which is something that natural features such as our
    stream make plenty of. This means that typical skeletonization, which could be
    done simply with a Voronoi approach, is therefore inherently inadequate for our
    purposes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们很快就会看到的，骨架化方法的困难在于它们通常容易受到噪声的影响，而自然特征，如我们的河流，会产生大量的噪声。这意味着典型的骨架化，如果简单地使用Voronoi方法就可以完成，因此对于我们的目的来说本质上是不够的。
- en: This brings us to the reason why skeletonization is included in this chapter.
    Routing is a way for us to simplify skeletons derived from the Voronoi method.
    It allows us to trace from one end of a major feature to the other and skip all
    the noise in between.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这就带我们来到了为什么骨架化方法被包含在本章中的原因。路由是我们简化由Voronoi方法得到的骨架的一种方式。它允许我们从主要特征的一端追踪到另一端，并跳过中间的所有噪声。
- en: Getting ready
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: As we will be using the Voronoi calculations from the *Calculating Voronoi Diagram*
    recipe in [Chapter 4](68182eea-7041-4488-9f05-188b0a493ba5.xhtml), *Working with
    Vector Data – Advanced Recipes*, you should refer to that recipe to prepare yourself
    for the functions used in this recipe.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用[第4章](68182eea-7041-4488-9f05-188b0a493ba5.xhtml)，“*处理矢量数据 - 高级食谱*”中“*使用外部脚本来嵌入新功能以计算Voronoi多边形*”食谱中的Voronoi计算，你应该参考那个食谱来准备使用本食谱中使用的函数。
- en: 'We will use a stream dataset found in this book''s source package under the
    hydrology folder. To load it, use the following command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用本书源包中水文文件夹下找到的流数据集。要加载它，请使用以下命令：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The streams we create will look as shown in the following screenshot:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的河流将如下截图所示：
- en: '![](img/226e58e6-292d-4c14-80fe-86414225a226.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/226e58e6-292d-4c14-80fe-86414225a226.png)'
- en: How to do it...
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: In order to perform the basic skeletonization, we'll calculate the Voronoi polygons
    on the nodes that make up the original stream polygon. By default, the edges of
    the Voronoi polygons find the line that demarcates the midpoint between points.
    We will leverage this tendency by treating our lines like points—adding extra
    points to the lines and then converting the lines to a point set. This approach,
    in combination with the Voronoi approach, will provide an initial estimate of
    the polygon's centerline.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行基本的骨架化，我们将计算组成原始河流多边形的节点上的Voronoi多边形。默认情况下，Voronoi多边形的边缘找到点之间的中点所界定的线。我们将利用这种趋势，将我们的线条视为点——向线条添加额外的点，然后将线条转换为点集。这种方法与Voronoi方法相结合，将提供多边形中心线的初始估计。
- en: 'We will add extra points to our input geometries using the `ST_Segmentize`
    function and then convert the geometries to points using `ST_DumpPoints`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`ST_Segmentize`函数向我们的输入几何体添加额外的点，然后使用`ST_DumpPoints`将几何体转换为点：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following screenshot shows our polygons as a set of points if we view it
    on a desktop GIS:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在桌面GIS上查看，以下截图显示了我们的多边形作为一组点：
- en: '![](img/cb567a7d-7c5e-4730-a771-716f88083209.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cb567a7d-7c5e-4730-a771-716f88083209.png)'
- en: 'The set of points in the preceding screenshot is what we feed into our Voronoi
    calculation:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图中的点集是我们输入到Voronoi计算中的：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following screenshot shows a Voronoi diagram derived from our points:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了从我们的点派生出的Voronoi图：
- en: '![](img/98524ae2-9061-4745-bc65-6addf7a8db89.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/98524ae2-9061-4745-bc65-6addf7a8db89.png)'
- en: 'If you look closely at the preceding screenshot, you will see the basic centerline
    displayed in our new data. Now we will take the first step toward extracting it.
    We should index our inputs and then intersect the Voronoi output with the original
    stream polygon in order to clean the data back to something reasonable. In the
    extraction process, we''ll also extract the edges from the polygons and remove
    the edges along the original polygon in order to remove any excess lines before
    our routing step. This is implemented in the following script:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细观察前面的截图，您将看到我们新数据中显示的基本中心线。现在我们将迈出第一步来提取它。我们应该对我们的输入进行索引，然后将Voronoi输出与原始流多边形相交，以便将数据清理回合理的状态。在提取过程中，我们还将从多边形中提取边缘，并移除原始多边形上的边缘，以便在我们的路由步骤之前移除任何多余的线条。这已在以下脚本中实现：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now we have a second-level approximatio of the skeleton (shown in the following
    screenshot). It is messy, but it starts to highlight the centerline that we seek:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了骨骼的第二级近似（如下面的截图所示）。它很杂乱，但它开始突出我们寻求的中心线：
- en: '![](img/68de608f-7d5d-4709-a43f-48fa042db042.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/68de608f-7d5d-4709-a43f-48fa042db042.png)'
- en: There's more...
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Now we are nearly ready for routing. The centerline calculation we have is
    a good approximation of a straight skeleton, but is still subject to the noisiness
    of the natural world. We''d like to eliminate that noisiness by choosing our features
    and emphasizing them through routing. First, we need to prepare the table to allow
    for routing calculations, as shown in the following commands:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们几乎准备好进行路由了。我们拥有的中心线计算是对直线骨骼的良好近似，但仍然受到自然世界噪声的影响。我们希望通过选择我们的特征并通过路由强调它们来消除这种噪声。首先，我们需要准备表格以允许进行路由计算，如下面的命令所示：
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, to create a routable network from our skeleton, enter the following commands:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要从我们的骨骼创建可路由的网络，输入以下命令：
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now we can route along the primary centerline of our polygon using the following
    commands:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下命令沿着我们多边形的主要中心线进行路由：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If we look at the detail of this routing, we see the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看这个路由的细节，我们会看到以下内容：
- en: '![](img/6d461f56-bdcc-45a3-97f8-2bfc9ab985a6.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6d461f56-bdcc-45a3-97f8-2bfc9ab985a6.png)'
- en: 'Now we can compare the original polygon with the trace of its centerline:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将原始多边形与其中心线的轨迹进行比较：
- en: '![](img/99455e9d-a4f8-4256-b5ae-c8db0248139e.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/99455e9d-a4f8-4256-b5ae-c8db0248139e.png)'
- en: The preceding screenshot shows the original geometry of the stream in contrast
    to our centerline or skeleton. It is an excellent output that vastly simplifies
    our input geometry while retaining its relevant features.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示了流的原几何形状与我们的中心线或骨骼的对比。这是一个非常优秀的输出，它极大地简化了我们的输入几何形状，同时保留了其相关特征。
