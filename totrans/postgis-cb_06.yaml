- en: Working with pgRouting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Startup – Dijkstra routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading data from OpenStreetMap and finding the shortest path using A*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating the driving distance/service area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating the driving distance with demographics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting the centerlines of polygons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have used PostGIS as a vector and raster tool, using relatively
    simple relationships between objects and simple structures. In this chapter, we
    review an additional PostGIS-related extension: **pgRouting**. pgRouting allows
    us to interrogate graph structures in order to answer questions such as "What
    is the shortest route from where I am to where I am going?" This is an area that
    is heavily occupied by the existing web APIs (such as Google, Bing, MapQuest,
    and others) and services, but it can be better served by *rolling our own* services
    for many use cases. Which cases? It might be a good idea to create our own services
    in situations where we are trying to answer questions that aren''t answered by
    the existing services; where the data available to us is better or more applicable;
    or where we need or want to avoid the terms of service conditions for these APIs.'
  prefs: []
  type: TYPE_NORMAL
- en: Startup – Dijkstra routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pgRouting is a separate extension used in addition to PostGIS, which is now
    available in the PostGIS bundle on the Application Stack Builder (recommended
    for Windows). It can also be downloaded and installed by DEB, RPM, and macOS X
    packages and Windows binaries available at [http://pgrouting.org/download.html](http://pgrouting.org/download.html).
  prefs: []
  type: TYPE_NORMAL
- en: For macOS users, it is recommended that you use the source packages available
    on Git ([https://github.com/pgRouting/pgrouting/releases](https://github.com/pgRouting/pgrouting/releases)),
    and use CMake, available at [https://cmake.org/download/](https://cmake.org/download/),
    to make the installation build.
  prefs: []
  type: TYPE_NORMAL
- en: Packages for Linux Ubuntu users can be found at [http://trac.osgeo.org/postgis/wiki/UsersWikiPostGIS22UbuntuPGSQL95Apt](http://trac.osgeo.org/postgis/wiki/UsersWikiPostGIS22UbuntuPGSQL95Apt).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'pgRouting doesn''t deal well with nondefault schemas, so before we begin, we
    will set the schema in our user preferences using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to add the `pgrouting` extension to our database. If PostGIS
    is not already installed on the database, we''ll need to add it as an extension
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We will start by loading a test dataset. You can get some really basic sample
    data from [http://docs.pgrouting.org/latest/en/sampledata.html](http://docs.pgrouting.org/latest/en/sampledata.html).
  prefs: []
  type: TYPE_NORMAL
- en: This sample data consists of a small grid of streets in which any functions
    can be run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, run the create table and data insert scripts available at the dataset
    website. You should make adjustments to preserve the schema structure for `chp06`—for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the data is loaded, let''s build topology on the table (if you haven''t
    already done this during the data-load process):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Building a topology creates a new node table—`chp06.edge_table_vertices_pgr`—for
    us to view. This table will aid us in developing queries.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the data is loaded, we can run a quick test. We'll use a simple algorithm
    called Dijkstra to calculate the shortest path from node 5 to node 12.
  prefs: []
  type: TYPE_NORMAL
- en: Dijkstra's algorithm is an effective and simple routing algorithm that runs
    a search on all available paths from point A to point B in a network, also known
    as the **graph structure**. It is not the most efficient routing algorithm, but
    will always find the best route. For more information on Dijkstra's algorithm,
    refer to Wikipedia, which has a good explanation, with illustrations, at [http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm](http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm).
    The animation at [http://en.wikipedia.org/wiki/File:Dijkstras_progress_animation.gif](http://en.wikipedia.org/wiki/File:Dijkstras_progress_animation.gif)
    is particularly helpful.
  prefs: []
  type: TYPE_NORMAL
- en: 'An important point to note is that the nodes created in pgRouting during the
    topology creation process are created unintentionally for some versions. This
    has been patched in future versions, but for some versions of pgRouting, this
    means that your node numbers will not be the same as those we use here in the
    book. View your data in an application to determine which nodes to use or whether
    you should use a k-nearest neighbors search for the node nearest to a static geographic
    point. See [Chapter 11](e708d3c0-02ba-49ec-aaa1-b65693dee5ed.xhtml), *Using Desktop
    Clients*, for more information on viewing PostGIS data and [Chapter 4](68182eea-7041-4488-9f05-188b0a493ba5.xhtml),
     *Working with Vector Data – Advanced Recipes*, for approaches to finding the
    nearest node automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding query will result in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](img/fb6e007f-aa22-4b3f-9fe6-e7588dc042d7.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we ask for a route using Dijkstra and other routing algorithms, the result
    often comes in the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '`seq`: This returns the sequence number so we can maintain the order of the
    output'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`node`: This is the node ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`edge`: This is the edge ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cost`: This is the cost for the route traversal (often, the distance)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`agg_cost`: This is the aggregated cost for the route from the starting node'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, to get the geometry back, we need to rejoin the edge IDs with
    the original table. To make this approach work transparently, we will use the
    `WITH` common table expression to create a temporary table to which we will join
    our geometry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](img/1d23b34b-b5eb-4c36-a988-79cb0fb39b1f.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Congratulations! You have just completed a route in pgRouting. The following
    diagram illustrates this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/60b29bbe-fcaa-46e6-9992-76e19fb05d40.png)'
  prefs: []
  type: TYPE_IMG
- en: Loading data from OpenStreetMap and finding the shortest path using A*
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test data is great for understanding how algorithms work, but the real data
    is often more interesting. A good source for real data worldwide is **OpenStreetMap**
    (**OSM**), a worldwide, accessible, wiki-style, geospatial dataset. What is wonderful
    about using OSM in conjunction with pgRouting is that it is inherently a topological
    model, meaning that it follows the same kinds of rules in its construction as
    we do in graph traversal within pgRouting. Because of the way editing and community
    participation works in OSM, it is often an equally good or better data source
    than commercial ones and is, of course, quite compatible with our open source
    model.
  prefs: []
  type: TYPE_NORMAL
- en: Another great feature is that there is free and open source software to ingest
    OSM data and import it into a routing database—`osm2pgrouting`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is recommended that you get the downloadable files from the example dataset
    that we have provided, available at [http://www.packtpub.com/support](http://www.packtpub.com/support).
    You will be using the XML OSM data. You can also get custom extracts directly
    from the web interface at [http://www.openstreetmap.org/](http://www.openstreetmap.org/)or
    by using the overpass turbo interface to access OSM data ([https://overpass-turbo.eu/](https://overpass-turbo.eu/)),
    but this could limit the area we would be able to extract.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the data, we need to unzip it using our favorite compression utility.
    Double-clicking on the file to unzip it will typically work on Windows and macOS
    machines. Two good utilities for unzipping on Linux are `bunzip2` and `zip`. What
    will remain is an XML extract of the data we want for routing. In our use case,
    we are downloading the data for the greater Cleveland area.
  prefs: []
  type: TYPE_NORMAL
- en: Now we need a utility for placing this data into a routable database. An example
    of one such tool is `osm2pgrouting`, which can be downloaded and compiled using
    the instructions at [http://github.com/pgRouting/osm2pgrouting](http://github.com/pgRouting/osm2pgrouting).
    Use CMake from [https://cmake.org/download/](https://cmake.org/download/) to make
    the installation build in macOS. For Linux Ubuntu users there is an available
    package at [https://packages.ubuntu.com/artful/osm2pgrouting](https://packages.ubuntu.com/artful/osm2pgrouting).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When `osm2pgrouting` is run without anything set, the output shows us the options
    that are required and available to use with `osm2pgrouting`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6584ad6-f42a-4618-869f-52d5d075c430.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To run the `osm2pgrouting` command, we have a small number of required parameters.
    Double-check the paths pointing to `mapconfig.xml` and `cleveland.osm` before
    running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Our dataset may be quite large, and could take some time to process and import—be
    patient. The end of the output should say something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c33f9d8-6827-4a6e-ae5d-88269e323bad.png)'
  prefs: []
  type: TYPE_IMG
- en: Our new vector table, by default, is named `cleveland_ways`. If no `-prefix`
    flag was used, the table name would just be `ways`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should have the created following tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e3055d46-dc72-432f-b043-06e109fa52ee.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`osm2pgrouting` is a powerful tool that handles a lot of the translation of
    OSM data into a format that can be used in pgRouting. In this case, it creates
    eight tables from our input file. Of those eight, we''ll address the two primary
    tables: the `ways` table and the `nodes` table.'
  prefs: []
  type: TYPE_NORMAL
- en: Our `ways` table is a table of the lines that represent all our streets, roads,
    and trails that are in OSM. The nodes table contains all the intersections. This
    helps us identify the beginning and end points for routing.
  prefs: []
  type: TYPE_NORMAL
- en: Let's apply an *A* ("A star")* routing approach to this problem.
  prefs: []
  type: TYPE_NORMAL
- en: '*A** is an extension of Dijkstra''s algorithm which uses a heuristic to speed
    up the search for the shortest path, at the cost of occasionally not finding the
    optimum route. See [http://en.wikipedia.org/wiki/A*](http://en.wikipedia.org/wiki/A*)
    and [http://en.wikipedia.org/wiki/File:Astar_progress_animation.gif](http://en.wikipedia.org/wiki/File:Astar_progress_animation.gif)
    for more information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will recognize the following syntax from Dijkstra:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the results displayed on a map (map tiles by
    *Stamen Design, under CC BY 3.0*; data by *OpenStreetMap, under CC BY SA*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc488ec7-e796-40fa-9241-0bb1c210d78d.png)'
  prefs: []
  type: TYPE_IMG
- en: Sample calculated route with pgRouting visualized in QGIS
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the driving distance/service area
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Driving distance (`pgr_drivingDistance`) is a query that calculates all nodes
    within the specified driving distance of a starting node. This is an optional
    function compiled with pgRouting; so if you compile pgRouting yourself, make sure
    that you enable it and include the CGAL library, an optional dependency for `pgr_drivingDistance`.
  prefs: []
  type: TYPE_NORMAL
- en: Driving distance is useful when *user sheds* are needed that give realistic
    driving distance estimates, for example, for all customers with five miles driving,
    biking, or walking distance. These estimates can be contrasted with buffering
    techniques, which assume no barrier to travelling and are useful for revealing
    the underlying structures of our transportation networks relative to individual
    locations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will load the same dataset that we used in the *Startup – Dijkstra routing*
    recipe. Refer to this recipe to import data.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following example, we will look at all users within a distance of three
    units from our starting point—that is, a proposed bike shop at node 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/20daab54-0c5d-4db5-b929-b7eb6bcc2979.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As usual, we just get a list from the `pgr_drivingDistance` table that, in
    this case, comprises sequence, node, edge cost, and aggregate cost. PgRouting,
    like PostGIS, gives us low-level functionality; we need to reconstruct what geometries
    we need from that low-level functionality. We can use that node ID to extract
    the geometries of all of our nodes by executing the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cc260d04-52fb-4d83-8b8f-45e3958351e4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'But the output seen is just a cluster of points. Normally, when we think of
    driving distance, we visualize a polygon. Fortunately, we have the `pgr_alphaShape`
    function that provides us that functionality. This function expects `id`, `x`,
    and `y` values for input, so we will first change our previous query to convert
    to `x` and `y` from the geometries in `edge_table_vertices_pgr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6c051cc-4aeb-4127-8f5d-2406e1888ee4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we can wrap the preceding script up in the `alphashape` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'So first, we will get our cluster of points. As we did earlier, we will explicitly
    convert the text to geometric points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have points, we can create a line by connecting them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we construct the line as a polygon using `ST_MakePolygon`. This requires
    adding the start point by executing `ST_StartPoint` in order to properly close
    the polygon. The complete code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Our first driving distance calculation can be better understood in the context
    of the following diagram, where we can reach nodes 9, 11, 13 from node 2 with
    a driving distance of 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/77d41e55-eeb2-45b5-b776-41efc1129e64.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Calculating the driving distance with demographics* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating the driving distance with demographics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Using polygon overlays for proportional census estimates* recipe in
    [Chapter 2](dec6904b-477f-4c16-a90f-7563a36c4652.xhtml), *Structures That Work*,
    we employed a simple buffer around a trail alignment in conjunction with the census
    data to get estimates of what the demographics were of the people within walking
    distance of the trail, estimated as a mile long. The problem with this approach,
    of course, is that it assumes that it is an "as the crow flies" estimate. In reality,
    rivers, large roads, and roadless stretches serve as real barriers to people's
    movement through space. Using pgRouting's `pgr_drivingDistance` function, we can
    realistically simulate people's movement on the routable networks and get better
    estimates. For our use case, we'll keep the simulation a bit simpler than a trail
    alignment—we'll consider the demographics of a park facility, say, the Cleveland
    Metroparks Zoo, and potential bike users within 4 miles of it, which adds up approximately
    to a 15-minute bike ride.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For our analysis, we will use the `proportional_sum` function from [Chapter
    2](dec6904b-477f-4c16-a90f-7563a36c4652.xhtml), *Structures That Work*, so if
    you have not added this to your PostGIS tool belt, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `proportional_sum` function will take our input geometry into account and
    the `count` value of the population and return an estimate of the proportional
    population.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to load our census data. Use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Also, if you have not yet loaded the data mentioned in the *Loading data from
    OpenStreetMap and finding the shortest path A** recipe, take the time to do so
    now.
  prefs: []
  type: TYPE_NORMAL
- en: Once all the data is entered, we can proceed with the analysis.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `pgr_drivingdistance` polygon we created is the first step in the demographic
    analysis. Refer to the *Driving distance/service area calculation* recipe if you
    need to familiarize yourself with its use. In this case, we''ll consider the cycling
    distance. The nearest node to the Cleveland Metroparks Zoo is 24746, according
    to our loaded dataset; so we''ll use that as the center point for our `pgr_drivingdistance`
    calculation and we''ll use approximately 6 kilometers as our distance, as we want
    to know the number of zoo visitors within this distance of the Cleveland Metroparks
    Zoo. However, since our data is using 4326 EPSG, the distance we will give the
    function will be in degrees, so 0.05 will give us an approximate distance of 6
    km that will work with the `pgr_drivingDistance` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding script gives us a very interesting shape (map tiles by *Stamen
    Design, under CC BY 3.0*; data by *OpenStreetMap, under CC BY SA*). See the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1663b115-c4ac-4372-b671-21349efd1837.jpg)![](img/eeb3d160-d7f7-4f11-bdb9-55653d832832.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the previous screenshot, we can see the difference between the cycling distance
    across the real road network, shaded in blue, and the equivalent 4-mile buffer
    or as-the-crow-flies distance. Let''s apply this to our demographic analysis using
    the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e4d7d9dd-e926-4266-86ca-0e3bc32f69ce.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: So, how does the preceding output compare to what we would get if we look at
    the buffered distance?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '**![](img/be372de8-b81c-4f5c-9c50-3457da9f22b2.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The preceding output shows a difference of more than 60,000 people. In other
    words, using a buffer overestimates the population compared to using `pgr_drivingdistance`.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting the centerlines of polygons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In several recipes in [Chapter 4](68182eea-7041-4488-9f05-188b0a493ba5.xhtml),
    *Working with Vector Data – Advanced Recipes*, we explored extracting Voronoi
    polygons from sets of points. In this recipe, we'll use the Voronoi function employed
    in the *Using external scripts to embed new functionality to calculate Voronoi
    polygons* section to serve as the first step in extracting the centerline of a
    polygon. One could also use the *Using external scripts to embed new functionality
    to calculate Voronoi polygons—advanced* recipe, which would run faster on large
    datasets. For this recipe, we will use the simpler but slower approach.
  prefs: []
  type: TYPE_NORMAL
- en: One additional dependency is that we will be using the `chp02.polygon_to_line(geometry)`
    function from the *Normalizing internal overlays* recipe in [Chapter 2](dec6904b-477f-4c16-a90f-7563a36c4652.xhtml),
    *Structures That Work*.
  prefs: []
  type: TYPE_NORMAL
- en: 'What do we mean by the centerline of a polygon? Imagine a digitized stream
    flowing between its pair of banks, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f00a4afe-12be-4343-82aa-27ea584ad382.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we wanted to find the center of this in order to model the water flow, we
    could extract it using a skeletonization approach, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7e6ef05-b751-40dc-a57e-116bdbe080da.png)'
  prefs: []
  type: TYPE_IMG
- en: The difficulty with skeletonization approaches, as we'll soon see, is that they
    are often subject to noise, which is something that natural features such as our
    stream make plenty of. This means that typical skeletonization, which could be
    done simply with a Voronoi approach, is therefore inherently inadequate for our
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the reason why skeletonization is included in this chapter.
    Routing is a way for us to simplify skeletons derived from the Voronoi method.
    It allows us to trace from one end of a major feature to the other and skip all
    the noise in between.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we will be using the Voronoi calculations from the *Calculating Voronoi Diagram*
    recipe in [Chapter 4](68182eea-7041-4488-9f05-188b0a493ba5.xhtml), *Working with
    Vector Data – Advanced Recipes*, you should refer to that recipe to prepare yourself
    for the functions used in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use a stream dataset found in this book''s source package under the
    hydrology folder. To load it, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The streams we create will look as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/226e58e6-292d-4c14-80fe-86414225a226.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to perform the basic skeletonization, we'll calculate the Voronoi polygons
    on the nodes that make up the original stream polygon. By default, the edges of
    the Voronoi polygons find the line that demarcates the midpoint between points.
    We will leverage this tendency by treating our lines like points—adding extra
    points to the lines and then converting the lines to a point set. This approach,
    in combination with the Voronoi approach, will provide an initial estimate of
    the polygon's centerline.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add extra points to our input geometries using the `ST_Segmentize`
    function and then convert the geometries to points using `ST_DumpPoints`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows our polygons as a set of points if we view it
    on a desktop GIS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb567a7d-7c5e-4730-a771-716f88083209.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The set of points in the preceding screenshot is what we feed into our Voronoi
    calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows a Voronoi diagram derived from our points:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98524ae2-9061-4745-bc65-6addf7a8db89.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you look closely at the preceding screenshot, you will see the basic centerline
    displayed in our new data. Now we will take the first step toward extracting it.
    We should index our inputs and then intersect the Voronoi output with the original
    stream polygon in order to clean the data back to something reasonable. In the
    extraction process, we''ll also extract the edges from the polygons and remove
    the edges along the original polygon in order to remove any excess lines before
    our routing step. This is implemented in the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have a second-level approximatio of the skeleton (shown in the following
    screenshot). It is messy, but it starts to highlight the centerline that we seek:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/68de608f-7d5d-4709-a43f-48fa042db042.png)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we are nearly ready for routing. The centerline calculation we have is
    a good approximation of a straight skeleton, but is still subject to the noisiness
    of the natural world. We''d like to eliminate that noisiness by choosing our features
    and emphasizing them through routing. First, we need to prepare the table to allow
    for routing calculations, as shown in the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to create a routable network from our skeleton, enter the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can route along the primary centerline of our polygon using the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at the detail of this routing, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d461f56-bdcc-45a3-97f8-2bfc9ab985a6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we can compare the original polygon with the trace of its centerline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99455e9d-a4f8-4256-b5ae-c8db0248139e.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows the original geometry of the stream in contrast
    to our centerline or skeleton. It is an excellent output that vastly simplifies
    our input geometry while retaining its relevant features.
  prefs: []
  type: TYPE_NORMAL
