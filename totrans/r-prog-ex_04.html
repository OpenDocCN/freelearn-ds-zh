<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Simulating Sales Data and Working with Databases</h1>
                
            
            <article>
                
<p class="calibre2">The Food Factory example is about a fictitious company called <strong class="calibre1">The Food Factory</strong>. They sell custom meals for people looking for healthy food. They allow their customers to choose the macronutrients combinations they want, as well as their protein sources. Macronutrients are the base for any diet, and they are composed of carbohydrates, proteins, and fats. Customers can choose the percentage of each macronutrient, as well as their protein source (fish, chicken, beef, or vegetarian); then, The Food Factory will come up with a tasty meal which fulfills their diet specifications. They have found some great combinations this way, and if they continue to do as well as they have, they will add more meal options, as well as fixed recipes, according to what their customers like most.</p>
<p class="calibre2">The Food Factory has done a good job so far and they have a system in place that allows them to collect a good amount of data across their five store locations, as well as keep track of customer messages. Our job in this example will be to analyze the data to diagnose the current state of the business and propose ways to improve it. To do so, we will use lots of visualizations in <a href="part0110.html#38STS0-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 5</a>, <em class="calibre19">Communicating Sales with Visualizations;</em> perform text analysis on customer reviews in <a href="part0129.html#3R0OI0-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 6</a>, <em class="calibre19">Understanding Reviews with Text Analysis;</em> and provide automatic diagnosis of the current state of the business in <a href="part0147.html#4C62M0-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 7</a>, <em class="calibre19">Developing Automatic Presentations</em>. Sounds good, right? However, before we can do all of that, we need to get a hold of the data, and we don't have it yet. We're going to simulate it! This chapter will show you how to design a non-trivial data simulation to produce the data for the example. Furthermore, The Food Factory, as well as many organizations, doesn't always make our lives easier by providing CSV files, and they often have databases we need to work with. This chapter will also show you how to work with such databases.</p>
<p class="calibre2">Some of the important topics covered in this chapter are:</p>
<ul class="calibre11">
<li class="calibre12">Designing and implementing non-trivial simulations</li>
<li class="calibre12">Simulating numbers, categories, strings, and dates</li>
<li class="calibre12">Function signatures with parameter objects</li>
<li class="calibre12">Reusing functions in different contexts</li>
<li class="calibre12">Mixing internal and external data</li>
<li class="calibre12">Working with relational databases</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Required packages</h1>
                
            
            <article>
                
<p class="calibre2">The only package required for this chapter is <kbd class="calibre9">RMySQL</kbd>. However, to be able to fully replicate the code shown towards the end of the chapter, you will need a working installation of the MySQL database (<a href="https://www.mysql.com/" class="calibre4">https://www.mysql.com/</a>). Specific instructions for Linux and Mac can be found in <a href="part0296.html#8Q96G0-f494c932c729429fb734ce52cafce730" class="calibre4">Appendix</a>, <em class="calibre19">Required Packages.</em></p>
<table class="calibre5">
<tbody class="calibre6">
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><strong class="calibre1">Package</strong></p>
</td>
<td class="calibre8">
<p class="calibre2"><strong class="calibre1">Reason</strong></p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">RMySQL</kbd></p>
</td>
<td class="calibre8">
<p class="calibre2">Interface to MySQL database</p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Designing our data tables</h1>
                
            
            <article>
                
<p class="calibre2">It's always a good practice to design with paper and a pencil before starting to program. If you do, you'll find that your code is much better because you'll contemplate scenarios that you may not see if you start programming right away, and, instead of hacking your way around what you have already programmed, you'll be able to design solutions beforehand. It's an easy investment that very often pays off, so that's what we will do in this section, we will design our data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The basic variables</h1>
                
            
            <article>
                
<p class="calibre2">Let's start from the most simple scenario we can imagine and try to find any potential problems we may encounter. For each sale, we would like to have the following variables, the sales <kbd class="calibre9">DATE</kbd>, the <kbd class="calibre9">COST</kbd> for producing that type of food, the <kbd class="calibre9">QUANTITY</kbd> bought, the <kbd class="calibre9">PRICE</kbd> for the type food, whether or not we applied a <kbd class="calibre9">DISCOUNT</kbd>, the macronutrient percentages for <kbd class="calibre9">CARBS</kbd> (carbohydrates), <kbd class="calibre9">PROTEIN</kbd>, and <kbd class="calibre9">FAT</kbd>, the <kbd class="calibre9">PROTEIN_SOURCE</kbd> of the food (either <kbd class="calibre9">FISH</kbd>, <kbd class="calibre9">CHICKEN</kbd>, <kbd class="calibre9">BEEF</kbd>, or <kbd class="calibre9">VEGETARIAN</kbd>, if the person does not eat meat), the <kbd class="calibre9">STORE</kbd> where it was sold, the <kbd class="calibre9">DELIVERY</kbd> method (either send <kbd class="calibre9">TO LOCATION</kbd> or deliver <kbd class="calibre9">IN STORE</kbd>), the <kbd class="calibre9">STATUS</kbd> of the sale, which can be <kbd class="calibre9">PENDING</kbd>, <kbd class="calibre9">DELIVERED</kbd>, <kbd class="calibre9">RETURNED</kbd>, or <kbd class="calibre9">CANCELLED</kbd> (a sale can't have two statuses at the same time), whether or not it has been <kbd class="calibre9">PAID</kbd>, the client's <kbd class="calibre9">BIRTH_DATE</kbd> and <kbd class="calibre9">GENDER</kbd>, how many <kbd class="calibre9">STARS</kbd> they awarded to the company, the <kbd class="calibre9">CUSTOMER_SINCE</kbd> date, and how many messages they sent us related to their order, as well as the <kbd class="calibre9">DATE</kbd>, <kbd class="calibre9">STARS</kbd>, and actual <kbd class="calibre9">MESSAGE</kbd> for each one.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Simplifying assumptions</h1>
                
            
            <article>
                
<p class="calibre2">We can complicate the example as much as we want, but to keep the simulation simple (although not trivial), we are going to assume a couple of things upfront. First, we assume that each sale record contains a single type of food. If a person buys two or more different types of foods, then each of those types will produce a different sale record. However, each sale can contain as many portions of the foods as we want, as long as they are the same type (combination of macronutrients and protein sources). This is the most important simplification, since company sales orders normally have various items per sale, but it will allow us to focus on the programming side of things.</p>
<p class="calibre2">Second, we will not worry about the relation among food types and costs (or prices) being continuous in the mathematical sense. This means that we may find a food type with some combination of macronutrients and protein sources that is very similar to another food's combination, but their production costs, as well as their prices, are very different. Similarly, we assume that each food type has its unique cost and price, and it can vary for different sales (the same food type can have different costs and prices for different sales). This is not a realistic assumption, as most companies have standardized products (including costs and prices), but we can think of The Food Factory as being a craft shop, where each food is unique, and that can generate the differences in costs and prices. If anything, it's adding complexity (fun) to the analysis.</p>
<p class="calibre2">Third, we will not worry about the relation among sales dates and sale statuses, or among sales dates and whether or not a sale has been paid. This means that we may actually find sales that have been delivered and are old, but were not paid. This is something that does happen in some real-life cases, so there's no problem assuming it.</p>
<p class="calibre2">Fourth, the fact that a customer's messages related to a specific sale are rated high or low, does not affect the overall score they gave to The Food Factory. There are two <kbd class="calibre9">STARS</kbd> columns, one for overall rating of The Food Factory, and one that will be sent with each message related to an order. This means that a client who in general likes The Food Factory can have a bad experience, and it will not affect how much they continue to like the store. Conversely, a customer who in general does not like The Food Factory, will not start liking it because they had a good experience with it one day. This assumption holds true for people with fixed preferences, but does not hold true in general. If we wanted to, we could include mechanisms in the simulation that take these dynamics into account. As a matter of fact, I encourage you to try to implement some of these mechanisms yourself. It will be good practice.</p>
<p class="calibre2">Fifth, we won't worry about the macronutrients making sense, including the combination with protein sources. A common diet would include approximately 50% protein, 35% carbohydrates, and 15% fat, but we won't worry about our numbers making nutritional sense. That means, please don't think any of these simulated food orders are realistic, or are actually healthy.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Potential pitfalls</h1>
                
            
            <article>
                
<p class="calibre2">Now that we understand the general data structure, we need to find potential pitfalls that should be avoided. We can think about this data structure as a standard table structure (a data frame or a spreadsheet) where each column represents a variable and each row represents an observation (a sales record, in our case).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The too-much-empty-space problem</h1>
                
            
            <article>
                
<p class="calibre2">Let's say we have a sales record; what happens if we get a message related to that order from our customer? Well, we simply add the data to the corresponding columns <kbd class="calibre9">DATE</kbd>, <kbd class="calibre9">STARS</kbd>, and <kbd class="calibre9">MESSAGE</kbd>. What happens if we get another message related to the same order? Well, a possible solution would be to add a new combination of <kbd class="calibre9">DATE</kbd>, <kbd class="calibre9">STARS</kbd>, and <kbd class="calibre9">MESSAGE</kbd> for the new message, but names would collapse.</p>
<p class="calibre2">How would we differentiate among them? Well, we can append a number indicating the actual message number. Then, we would have <kbd class="calibre9">DATE_1</kbd>, <kbd class="calibre9">STARS_1</kbd>, and <kbd class="calibre9">MESSAGE_1</kbd> for the first message, and <kbd class="calibre9">DATE_2</kbd>, <kbd class="calibre9">STARS_2</kbd>, and <kbd class="calibre9">MESSAGE_2</kbd> for the second message. That would fix it, wouldn't it? What happens if we get a third, or more, messages related to the order? Well, we would end up with a lot of variables in our data frame. Specifically, we would have as many combinations as the maximum number of messages that were sent to a single order. What would be the content of the cells for the orders that did not have such a big number of messages? They would be empty. That would be a lot of wasted space! Plus, the general structure for the data would feel awkward. There must be a better way.</p>
<p class="calibre2">If you think about it, it feels like the messages and the sales are two different things and that they should be kept separate, doesn't it? If you think about it that way, you are right. So let's imagine that, let's keep one data frame for the sales orders and another for the messages. There is another problem. Can you see it? How are we going to tell which messages belong to which sales orders? Identifiers to the rescue! We can add <kbd class="calibre9">SALE_ID</kbd> to the sales data frame, where it should be unique, and we can add the same <kbd class="calibre9">SALE_ID</kbd> to the messages data frame, where it will not be unique because there can be multiple messages related to the same sales order. This means we have a one-to-many relation. With this in mind, the sales data frame would have all the variables we mentioned earlier, minus the <kbd class="calibre9">DATE</kbd>, <kbd class="calibre9">STARS</kbd>, and <kbd class="calibre9">MESSAGE</kbd> variable for the messages (don't confuse the sales order <kbd class="calibre9">DATE</kbd> with the <kbd class="calibre9">DATE</kbd> for each message), and those three variables would conform to the separate messages data frame. Both data frames would have a <kbd class="calibre9">SALE_ID</kbd> variable. Great; we're past that one.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The too-much-repeated-data problem</h1>
                
            
            <article>
                
<p class="calibre2">What variable do we still have in the sales data frame? Well, to phrase it in such a way as to make the problem very obvious, we still have the sales variables and the customer's variables. So, what might the problem be? Well, each time a customer makes a new purchase, we save her <kbd class="calibre9">BIRTH_DATE</kbd>, <kbd class="calibre9">CLIENT_SINCE</kbd>, <kbd class="calibre9">GENDER</kbd>, and <kbd class="calibre9">STARS</kbd> information again. What if a frequent customer has 100 different purchases with The Food Factory? Well, her information will be repeated 100 times! We need to fix that. How might we do it? We do the same thing we did before, separate things that are different. That's right. We create a separate data frame for the customer data, and we already know how to link the customers with the sales since we used that same technique in the previous problem, we create identifiers in both data frames. This is a many-to-one relation (from the point of view of the sales data towards the customers' data). I'm sure you can figure out which variables belong to which data frames.</p>
<div class="packt_tip">By eliminating the repeated data, we're also eliminating the possibility of accidentally changing some of those repeated values and then being confused about which ones are correct.</div>
<p class="calibre2">To recapitulate, what we have done is break up a huge initial table that contained all the information in a single place into three different tables that are linked through identifiers, in such a way that we represent different things in each table (sales, clients, and client messages), while eliminating a lot of wasted space and repeated values. To get more intuition on how is organized after these adjustments, we can take a look at the following image which shows what data attributes belong to which entities, and how they are related among each other:</p>
<div class="cdpaligncenter"><img src="../images/00028.jpeg" class="calibre44"/></div>
<div class="mce-root2">Data entities and attributes for the simulation</div>
<p class="calibre2">These techniques, together with many others, are called <strong class="calibre1">database normalization</strong>, which can be useful in certain scenarios. There are times, however, that we will not want our data to be fully normalized because of performance issues, but those are advanced cases that we won't cover in this book. For the interested reader, I'd recommend looking at Silberschatz, Korth, and Sudarshan's, <em class="calibre19">Database System Concepts, 2010</em> for advanced concepts and examples.</p>
<p class="calibre2">Finally, keep in mind that although we are creating our own unique identifiers in this chapter, in real-world applications you will be better off using a well established tool for such a task. The <kbd class="calibre9">uuid</kbd> package is specially designed to generate and handle <strong class="calibre1">Universally Unique Identifiers</strong> (<strong class="calibre1">UUIDs</strong>). You can find more information about it in its CRAN page (<a href="https://cran.r-project.org/web/packages/uuid/index.html" class="calibre4">https://cran.r-project.org/web/packages/uuid/index.html</a>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Simulating the sales data</h1>
                
            
            <article>
                
<p class="calibre2">Enough concepts; let's start programming. To get a clear idea of where we're heading, we start by initializing the <kbd class="calibre9">sales</kbd> data frame we will be using, with zero observations for now. We do so by defining the available categories for each factor variable, and defining empty values with the data type we need for each variable. As you can see, it has the identifiers <kbd class="calibre9">SALE_ID</kbd> and <kbd class="calibre9">CLIENT_ID</kbd>, which will allow us to link this data with the one from <kbd class="calibre9">clients</kbd> and <kbd class="calibre9">client_messages</kbd>. To understand this, let's have a look at the following code:</p>
<pre class="mce-root">status_levels &lt;- c("PENDING", "DELIVERED", "RETURNED", "CANCELLED")<br class="title-page-name"/>protein_source_levels &lt;- c("BEEF", "FISH", "CHICKEN", "VEGETARIAN")<br class="title-page-name"/>continent_levels &lt;- c("AMERICA", "EUROPE", "ASIA")<br class="title-page-name"/>delivery_levels &lt;- c("IN STORE", "TO LOCATION")<br class="title-page-name"/>paid_levels &lt;- c("YES", "NO")<br class="title-page-name"/><br class="title-page-name"/>sales &lt;- data.frame(<br class="title-page-name"/>    SALE_ID = character(),<br class="title-page-name"/>    CLIENT_ID = character(),<br class="title-page-name"/>    DATE = as.Date(character()),<br class="title-page-name"/>    QUANTITY = integer(),<br class="title-page-name"/>    COST = numeric(),<br class="title-page-name"/>    PRICE = numeric(),<br class="title-page-name"/>    DISCOUNT = numeric(),<br class="title-page-name"/>    PROTEIN = numeric(),<br class="title-page-name"/>    CARBS = numeric(),<br class="title-page-name"/>    FAT = numeric(),<br class="title-page-name"/>    PROTEIN_SOURCE = factor(levels = protein_source_levels),<br class="title-page-name"/>    CONTINENT = factor(levels = continent_levels),<br class="title-page-name"/>    DELIVERY = factor(levels = delivery_levels),<br class="title-page-name"/>    STATUS = factor(levels = status_levels),<br class="title-page-name"/>    PAID = factor(levels = paid_levels)<br class="title-page-name"/>)</pre>
<p class="calibre2">This way of initializing an empty data frame, as opposed to many other methods you may find elsewhere, is safer, since you'll have the correct column types from the beginning. If your code relies on some column type checking (as we will do), it will work even with a data frame with zero rows (as is the case here).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Simulating numeric data according to distribution assumptions</h1>
                
            
            <article>
                
<p class="calibre2">We will generate the data for each column separately and then we'll recreate the data frame with it. We want to start with the easy parts first, so we'll take a look at the simulation for <kbd class="calibre9">QUANTITY</kbd>, <kbd class="calibre9">COST</kbd>, <kbd class="calibre9">PRICE</kbd>, and <kbd class="calibre9">DISCOUNT</kbd>. The easy way would be to just simulate some random numbers and make sure they are within some range by multiplying or dividing them accordingly. We could also use the <kbd class="calibre9">round()</kbd> function to make sure <kbd class="calibre9">QUANTITY</kbd> is not fractional. However, if we want to do it the correct way, then we must consider the underlying assumptions in each of those numbers. An image showing the distributions mentioned in the following paragraphs is shown below.</p>
<div class="cdpaligncenter"><img src="../images/00029.jpeg" class="calibre45"/></div>
<div class="mce-root2">Distributions for COST, PRICE, QUANTITY and DISCOUNT</div>
<p class="calibre2">The <kbd class="calibre9">COST</kbd> and <kbd class="calibre9">PRICE</kbd> value follow a normal distribution because they are real numbers. On average, <kbd class="calibre9">COST</kbd> should be lower than <kbd class="calibre9">PRICE</kbd>, so we will set their respective mean parameters accordingly. Note that this allows for the possibility of some foods being sold for less than their production cost, which sometimes happens when companies are trying to minimize losses. <kbd class="calibre9">DISCOUNT</kbd> follows an exponential distribution because we want most discounts to be zero, or low (compared to the price). This means that we don't give out discounts often, and when we do, they will be small. <kbd class="calibre9">QUANTITY</kbd> follows a <em class="calibre19">Poisson distribution</em> because it needs to be an integer. A good resource is Sean Owen's <em class="calibre19">Common Probability Distributions: The Data Scientist's Crib Sheet, <span>2015</span></em> ( <a href="https://blog.cloudera.com/blog/2015/12/common-probability-distributions-the-data-scientists-crib-sheet/" class="calibre4">https://blog.cloudera.com/blog/2015/12/common-probability-distributions-the-data-scientists-crib-sheet/</a>).</p>
<p class="calibre2">Given these assumptions, we will create three functions. <kbd class="calibre9">COST</kbd> and <kbd class="calibre9">PRICE</kbd> are simulated with the <kbd class="calibre9">random_values()</kbd> function, while <kbd class="calibre9">QUANTITY</kbd> and <kbd class="calibre9">DISCOUNT</kbd> have their own functions. The <kbd class="calibre9">random_values()</kbd> function uses the <kbd class="calibre9">rnorm()</kbd> function to simulate <kbd class="calibre9">n</kbd> values (where <kbd class="calibre9">n</kbd> is the number of rows we want in the data frame) using the normal distribution, with a specific <kbd class="calibre9">mean</kbd> and standard deviation (<kbd class="calibre9">sqrt(variance)</kbd>). We then take these values and round them to two decimal places using the <kbd class="calibre9">round()</kbd> function as shown in the following:</p>
<pre class="mce-root">random_values &lt;- function(n, mean, variance) {<br class="title-page-name"/>    return(round(rnorm(n, mean, sqrt(variance)), 2))<br class="title-page-name"/>}</pre>
<p class="calibre2">The <kbd class="calibre9">random_discounts()</kbd> function uses the <kbd class="calibre9">rexp()</kbd> function to simulate <kbd class="calibre9">n</kbd> values using the exponential distribution with the <kbd class="calibre9">lambda</kbd> parameter, and, as we did before, we use the <kbd class="calibre9">round()</kbd> function to round the values to two decimal places. When we use this function, we'll use a very high <kbd class="calibre9">lambda</kbd> parameter (100) to heavily skew the distribution to the right so that we get a lot of zeros in the simulation. However, this will make our values be very small (for example, 0.021). If we use these values directly, our discounts will be of a couple of cents, which is not realistic. Therefore, we multiply these values by 100 to get discounts that are a couple of dollars. Note that if we first round and then multiply by 100, we get full dollar discounts (for example, $2), but if we first multiply by 100 and then round, we get discounts that include cents (for example, $2.1), which is something we prefer to avoid, but it would work just as well. Let's have a look at the following code to understand this:</p>
<pre class="mce-root">random_discounts &lt;- function(n, lambda) {<br class="title-page-name"/>    return(round(rexp(n, lambda), 2) * 100)<br class="title-page-name"/>}</pre>
<p class="calibre2">The <kbd class="calibre9">random_quantities()</kbd> function uses the <kbd class="calibre9">rpois()</kbd> function to simulate <kbd class="calibre9">n</kbd> values using the <em class="calibre19">Poisson distribution</em> with the <kbd class="calibre9">lambda</kbd> parameter. In this case, we don't need to round, because the values will already be integers. However, we do add <kbd class="calibre9">1</kbd> to each value, because we might get zero as a quantity, and having a sales order with zero foods would not make sense. Adding <kbd class="calibre9">1</kbd>  guarantees we have at least one food in each sales order:</p>
<pre class="mce-root">random_quantities &lt;- function(n, lambda) {<br class="title-page-name"/>    return(rpois(n, lambda) + 1)<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Simulating categorical values using factors</h1>
                
            
            <article>
                
<p class="calibre2">The <kbd class="calibre9">random_levels()</kbd> function simulates <kbd class="calibre9">n</kbd> categorical values by sampling the <kbd class="calibre9">levels</kbd> provided with replacement (controlled by the third parameter, which is sent as <kbd class="calibre9">TRUE</kbd>). You can think about the <kbd class="calibre9">levels</kbd> as an array of strings, each of which is a possible value for the simulation. These <kbd class="calibre9">levels</kbd> will come from the categories defined for factor variables in the data frame (<kbd class="calibre9">PROTEIN_SOURCE</kbd>, <kbd class="calibre9">STORE</kbd>, <kbd class="calibre9">DELIVERY</kbd>, <kbd class="calibre9">STATUS</kbd>, and <kbd class="calibre9">PAID</kbd>). A sample with replacement means that every time we pick one of the values from the <kbd class="calibre9">levels</kbd> object, we return it so that we can pick it again later. Sampling without replacement only makes sense when you want a number of samples that is smaller than the total amount of values available, which is not the case here, since we want to simulate thousands of rows and we won't have that many <kbd class="calibre9">levels</kbd>.</p>
<p class="calibre2">There's a third parameter that we have not mentioned, the <kbd class="calibre9">probabilities</kbd> parameter. As you can see, by default it's set to <kbd class="calibre9">NULL</kbd>, but we do send an object there; it must be a vector of numbers between 0 and 1, such that they sum to 1 and they represent the probability of picking a specific category. The order of this <kbd class="calibre9">probabilities</kbd> object must be the same as in the <kbd class="calibre9">levels</kbd> object. For example, if we have three possible levels and we send the <kbd class="calibre9">probabilities</kbd> object as <kbd class="calibre9">c(0.2, 0.3, 0.5)</kbd>, the first level will have a 20% probability of being picked, while the second and third levels will have probabilities of 30% and 50%, respectively. Note that the probabilities add up to one. Let's have a look at the code:</p>
<pre class="mce-root">random_levels &lt;- function(n, levels, probabilities = NULL) {<br class="title-page-name"/>    return(sample(levels, n, TRUE, probabilities))<br class="title-page-name"/>}</pre>
<div class="packt_tip">Note that we don't check whether the <kbd class="calibre21">probabilities</kbd> object is being sent as <kbd class="calibre21">NULL</kbd> before we pass it along to the <kbd class="calibre21">sample()</kbd> function. This can be done because the corresponding parameter in the <kbd class="calibre21">sample()</kbd> function also uses <kbd class="calibre21">NULL</kbd> as a default, and interprets it as using equal probabilities for all the values. You can check this in the function's documentation.</div>
<p class="calibre2">To test that the probabilities are being implemented correctly, we can simulate 100 values and then create a table with the results to see the amount of values produced for each of the categories. As you can see, if we simulate <kbd class="calibre9">100</kbd> values of the categories <kbd class="calibre9">A</kbd>, <kbd class="calibre9">B</kbd>, and <kbd class="calibre9">C</kbd>, with 20%, 30%, and 50% probabilities, we get 18%, 37%, and 45% proportions, respectively. These results are close enough to our specifications, and thus, correct. Note that you will get different values every time you re-execute the code, and they will almost never be the exact values you specified, which is natural in simulations. However, they should almost always be close to the specifications:</p>
<pre class="mce-root">results &lt;- random_levels(100, c("A", "B", "C"), c(0.2, 0.3, 0.5))
table(results)
<strong class="calibre1">#&gt; results
#&gt;  A  B  C
#&gt; 18 37 45</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Simulating dates within a range</h1>
                
            
            <article>
                
<p class="calibre2">The <kbd class="calibre9">random_dates_in_range()</kbd> function uses the same <kbd class="calibre9">sample()</kbd> function we used before, but instead of receiving a list of strings as categories from factor variables, it will receive a list of dates. To generate the full set of valid dates for the simulation, we use the <kbd class="calibre9">seq()</kbd> function. This function will generate all values from the <kbd class="calibre9">start</kbd> to the <kbd class="calibre9">end</kbd> by a specific interval. If we want to generate all odd numbers between 1 and 10, we will use <kbd class="calibre9">seq(1, 10, 2)</kbd>, which means that it will take <kbd class="calibre9">1</kbd> and add <kbd class="calibre9">2</kbd> to it sequentially until <kbd class="calibre9">10</kbd> is reached. In our case, we want the increment to be a full day, and, conveniently, the <kbd class="calibre9">seq()</kbd> function provides this capability when sending date objects by sending the increment as the string <kbd class="calibre9">"day"</kbd>:</p>
<pre class="mce-root">random_dates_in_range &lt;- function(n, start, end, increasing_prob = FALSE) {<br class="title-page-name"/>    sequence &lt;- seq(start, end, "day")<br class="title-page-name"/>    if (increasing_prob) {<br class="title-page-name"/>        probabilities &lt;- seq(1, length(sequence))^2<br class="title-page-name"/>        probabilities &lt;- probabilities / sum(probabilities)<br class="title-page-name"/>        return(sample(sequence, n, TRUE, probabilities))<br class="title-page-name"/>    } else {<br class="title-page-name"/>        return(sample(sequence, n, TRUE))<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Note that this will only work when sending <em class="calibre19">date</em> objects. If you try to test this function with strings, you will get an error saying that <kbd class="calibre9">'from' cannot be NA, NaN, or infinite</kbd>. Instead, you should convert those strings to dates with the <kbd class="calibre9">as.Date()</kbd> function:</p>
<pre class="mce-root">seq("2017-01-01", "2017-02-01", "day")                    <strong class="calibre1"># Error</strong>
seq(as.Date("2017-01-01"), as.Date("2017-02-01"), "day")  <strong class="calibre1"># Valid</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Simulating numbers under shared restrictions</h1>
                
            
            <article>
                
<p class="calibre2">As you may remember, The Food Factory creates their foods by receiving a macronutrient specification. Customers can specify whatever combination of percentages they want for each one, as long as they add up to 1. Now we are going to simulate these macronutrient percentages. This will require a little more work than the previous cases.</p>
<p class="calibre2">First, we create a function that will return numeric triples, where each number is between 0 and 1, and together they add up to 1. To accomplish this, we will use two random numbers and make the third one dependent on the first two. We will use the following mathematical fact:</p>
<div class="cdpaligncenter"><img class="fm-editor-equation1" src="../images/00030.jpeg"/></div>
<p class="calibre2">This tells us to take one number as <em class="calibre19">1 - max(a, b)</em>, another as <em class="calibre19">min(a, b)</em>, and the last one as <em class="calibre19">abs(a, b)</em>; which is exactly what we do in the <kbd class="calibre9">random_triple()</kbd> function. Doing so mathematically guarantees that we will get three random numbers between 0 and 1 that together add up to 1. Note that the <kbd class="calibre9">random_triple()</kbd> is one of the few functions we have created which does not require any arguments at all, which makes sense, since we don't need <em class="calibre19">external</em> information to simulate the triple:</p>
<pre class="mce-root">random_triple &lt;- function() {<br class="title-page-name"/>    a &lt;- runif(1, 0, 1)<br class="title-page-name"/>    b &lt;- runif(1, 0, 1)<br class="title-page-name"/>    PROTEIN &lt;- 1 - max(a, b)<br class="title-page-name"/>    CARBS &lt;- abs(a - b)<br class="title-page-name"/>    FAT &lt;- min(a, b)<br class="title-page-name"/>    return(c(PROTEIN, CARBS, FAT))<br class="title-page-name"/>}</pre>
<p class="calibre2">We can test that it's working simply by using <kbd class="calibre9">sum()</kbd> over the result:</p>
<pre class="mce-root">triple &lt;- random_triple()
triple
<strong class="calibre1">#&gt; [1] 0.05796599 0.76628032 0.17575370</strong>

sum(triple)
<strong class="calibre1">#&gt; 1</strong></pre>
<p class="calibre2">Now we want to generate <kbd class="calibre9">n</kbd> of these triples. To do so, we use the <kbd class="calibre9">replicate()</kbd> function to produce <kbd class="calibre9">n</kbd> triples. The <kbd class="calibre9">TRUE</kbd> argument corresponds to the <kbd class="calibre9">simplify</kbd> argument of the function, which will reduce a list of triples to matrix form, which is easier to work with in this particular case. When we are testing the code and look at the results of <kbd class="calibre9">replicate(n, random_triple(), TRUE)</kbd>, we will find that the resulting structure is the transpose of what we want, meaning that it has three rows and <kbd class="calibre9">n</kbd> columns, where each row represents a macronutrient percentage and each column represents an observation. We want to transpose this structure to get the macronutrient percentages as columns and the observations as rows; to do so, we simply use the <kbd class="calibre9">t()</kbd> function. After that, we simply create a data frame with the corresponding values for each macronutrient:</p>
<pre class="mce-root">random_composition &lt;- function(n) {<br class="title-page-name"/>    matrix &lt;- t(replicate(n, random_triple(), TRUE))<br class="title-page-name"/>    return(data.frame(PROTEIN = matrix[, 1], <br class="title-page-name"/>                      CARBS = matrix[, 2], <br class="title-page-name"/>                      FAT = matrix[, 3]))<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Simulating strings for complex identifiers</h1>
                
            
            <article>
                
<p class="calibre2">It's time for the most complex part of the simulation, the identifiers. We want to produce <kbd class="calibre9">n</kbd> identifiers, and, depending on what identifiers we are simulating, we may want them to be unique. Client identifiers in the client data must be unique, because we don't want two distinct clients with the same identifier, and our clients' data will not have repeated records by design. On the other hand, we don't want unique client identifiers in the sales data, because we want <em class="calibre19">repeated</em> clients to appear in there.</p>
<p class="calibre2">We could create two distinct functions that take care of these cases independently, but it's easy enough to combine them into a single function by just using a <kbd class="calibre9">reduction</kbd> parameter that specifies the percentage of unique identifiers. If the <kbd class="calibre9">reduction</kbd> parameter is sent as 0 (the default), we assume that full unique identifiers are requested. We will assume that identifiers are composed of a group of letters followed by a group of digits, and each group's length should be specified separately. That's what the <kbd class="calibre9">n_letters</kbd> and <kbd class="calibre9">n_digits</kbd> are for. Our implementation will work by creating the letters and digits groups separately and then combining them.</p>
<p class="calibre2">First, we will create the letter combinations by taking a sample from the <kbd class="calibre9">LETTERS</kbd> group (an internal R object which contains all ASCII letters in the capitalized form) of size <kbd class="calibre9">n</kbd> with replacement (we may have repeated letters in each identifier). Then, we are going to replicate this sample for <kbd class="calibre9">n_letters</kbd>, which is the amount of letters we need in each identifier, and we won't simplify the structure, which is why we send the <kbd class="calibre9">FALSE</kbd> parameter. This will return a list with <kbd class="calibre9">n_letters</kbd> elements, where each element is a vector of <kbd class="calibre9">n</kbd> letters. Now we want to paste these objects together. To do so, we use the <kbd class="calibre9">paste0()</kbd> function (which is a shortcut for the <kbd class="calibre9">paste()</kbd> function that collapses everything together, if you just use <kbd class="calibre9">paste()</kbd>, you will get spaces between the letters). However, we can't send our construction to <kbd class="calibre9">paste0()</kbd> because we will get some garbage out. We need to use the <kbd class="calibre9">do.call()</kbd> function to this properly. To understand what is going on, let's assume that <kbd class="calibre9">n_letters</kbd> is 5, and see how the code behaves.</p>
<pre class="mce-root">n_letters &lt;- 5<br class="title-page-name"/>letters &lt;- do.call(paste0, replicate(<br class="title-page-name"/>           n_letters, sample(LETTERS, n, TRUE), FALSE))
letters
<strong class="calibre1">#&gt; [1] "KXSVT" "HQASE" "DDEOG" "ERIMD" "CQBOY"</strong></pre>
<p class="calibre2">Now we will focus on the digit combinations. Our objective is to get a number between zero and the number formed of <kbd class="calibre9">n_digits</kbd> nines. For example, if <kbd class="calibre9">n_digits</kbd> is 5, we want numbers between 0 and 99,999. This will be broken into two steps. First, create the dynamic right-extreme number composed of only nines. Then, make sure that it has exactly <kbd class="calibre9">n_digit</kbd> digits, even if the natural way of representing the number does not. This means that if <kbd class="calibre9">n_digits</kbd> is 5 and the number we end up sampling is 123, we need to use 00123 as the result, since we need to ensure <kbd class="calibre9">n_digit</kbd> digits.</p>
<p class="calibre2">To accomplish the first part, we use <kbd class="calibre9">replicate()</kbd> to repeat the string <strong class="calibre1">9</strong> <kbd class="calibre9">n_digits</kbd> times. Then we use <kbd class="calibre9">paste()</kbd> with <kbd class="calibre9">collapse = ""</kbd> to put all the strings together, resulting in a string such as <strong class="calibre1">99999</strong>. Then we convert that string into a number by using the <kbd class="calibre9">as.numeric()</kbd> function. We end up with the desired number of nines in the <kbd class="calibre9">max_number</kbd> object.</p>
<p class="calibre2">Then we use the <kbd class="calibre9">sprintf()</kbd> function to make sure we have <kbd class="calibre9">n_digits</kbd> when using the number. To do so, we specify the <kbd class="calibre9">format</kbd> with a pre-fill of zeros (using the <kbd class="calibre9">"%0"</kbd> syntax), such that we have <kbd class="calibre9">n_digits</kbd> (using the <kbd class="calibre9">n_digits</kbd> followed by the <kbd class="calibre9">d</kbd> letter for digits). We put this inside a <kbd class="calibre9">paste()</kbd> function because the <kbd class="calibre9">format</kbd> string will be created dynamically. Following the example stated before, it would be <kbd class="calibre9">"%05d"</kbd> for 5 digits. For more information on how to use the <kbd class="calibre9">sprintf()</kbd> function, take a look at <a href="part0022.html#KVCC0-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 1</a>, <em class="calibre19">Introduction to R</em>. These lines combined give us:</p>
<pre class="mce-root">max_number &lt;- as.numeric(paste(replicate(n_digits, 9), collapse = ""))
format &lt;- paste("%0", n_digits, "d", sep = "")
digits &lt;- sprintf(format, sample(max_number, n, TRUE))
digits
<strong class="calibre1">#&gt; [1] "84150" "88603" "88640" "24548" "06355"</strong></pre>
<p class="calibre2">Now we need to paste the <kbd class="calibre9">letters</kbd> and <kbd class="calibre9">digits</kbd> objects together by using the <kbd class="calibre9">paste0()</kbd> function again. Since this is a vectorized operation, we will end up with a single array of <kbd class="calibre9">n</kbd> identifiers. Note that even though we have not enforced uniqueness, the probability of the sampling procedures producing repeated identifiers is so extremely low that we won't worry about it here.</p>
<div class="packt_tip">Real-world problems have a surprising ability to produce these extremely low probability cases, making careless code fail. If you are developing critical applications, always make sure you check for these cases explicitly.</div>
<p class="calibre2">Finally, if <kbd class="calibre9">reduction</kbd> is greater than zero, meaning that we want to use only the <kbd class="calibre9">reduction</kbd> percentage of the identifiers created so far to generate the total of <kbd class="calibre9">n</kbd> identifiers, we will use the <kbd class="calibre9">sample()</kbd> function to get <kbd class="calibre9">n</kbd> identifiers from the first <kbd class="calibre9">reduction</kbd> percentage identifiers, which is computed as an array from 1 to the floor of the percentage (must be an integer) of the <kbd class="calibre9">ids</kbd>, and we will do it with replacement (hence the <kbd class="calibre9">TRUE</kbd> parameter). If <kbd class="calibre9">reduction</kbd> is zero, we simply send the <kbd class="calibre9">ids</kbd> we have created so far without any modifications:</p>
<pre class="mce-root">random_strings &lt;- function(n, n_letters, n_digits, reduction = 0) {<br class="title-page-name"/>    letters &lt;- do.call(paste0, replicate(<br class="title-page-name"/>                       n_letters, sample(LETTERS, n, TRUE), FALSE))<br class="title-page-name"/>    max_number &lt;- as.numeric(paste(replicate(n_digits, 9), <br class="title-page-name"/>                                   collapse = ""))<br class="title-page-name"/>    format &lt;- paste("%0", n_digits, "d", sep = "")<br class="title-page-name"/>    digits &lt;- sprintf(format, sample(max_number, n, TRUE))<br class="title-page-name"/>    ids &lt;- paste0(letters, digits)<br class="title-page-name"/>    if (reduction &gt; 0) {<br class="title-page-name"/>        ids &lt;- sample(ids[1:floor(reduction * length(ids))], n, TRUE)<br class="title-page-name"/>    }<br class="title-page-name"/>    return(ids)<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Putting everything together</h1>
                
            
            <article>
                
<p class="calibre2">Now that we have done the hard work of creating all our simulation functions, we can just assemble them inside a general function that will use them to easily simulate the data for us. The first thing we note is that there are a lot of parameters that we need to control, and if we create a function signature that contains all of these parameters explicitly, we will be constraining ourselves by having a rigid signature that is hard to work with. We don't want to deal with these parameters by hand because it will make it cumbersome to work with the code. What if we could pass a single parameter that would mutate for us as we require? Well, we can do that! Parameter objects exist for this reason. They are a simple concept to grasp and provide a lot of flexibility. They are lists that are packed before being sent to the function and are unpacked inside the function to be used as needed inside nested functions. This is a form of <em class="calibre19">encapsulation</em>. We will look deeper into encapsulation in <a href="part0178.html#59O440-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 8</a>, <em class="calibre19">Object-Oriented System to Track Cryptocurrencies</em>.</p>
<p class="calibre2">Next, we note that since these simulations are stochastic processes, meaning we may get different results every time we execute them, we may lose the reproducibility of our results. To avoid this, we simply set the seed at the beginning of the simulations to make sure we get the same results every time, just as we did in <a href="part0076.html#28FAO0-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 3</a>, <em class="calibre19">Predicting Votes with Linear Models</em>.</p>
<p class="calibre2">The rest of the code is simply calling the functions we have already created with the appropriate arguments, which come from the parameters object we unpack at the beginning. There are three things worth noting. First, we can’t simply use the <kbd class="calibre9">random_composition()</kbd> function directly into one of the variables in the data frame we create because the resulting object contains data for three different variables in the data frame. Therefore we need to store an intermediate object with the results, <kbd class="calibre9">composition</kbd>, and then use it to extract the information for each macronutrient. Second, we use the <kbd class="calibre9">stringsAsFactors</kbd> argument of the <kbd class="calibre9">data.frame()</kbd> function as <kbd class="calibre9">FALSE</kbd> to make sure that <kbd class="calibre9">SALE_ID</kbd> and <kbd class="calibre9">CLIENT_ID</kbd> are not treated as factors (since they are strings). When factors start having many categories inside, processing data frames becomes slower, and we can avoid that by treating them as simple strings since we will have lots of unique identifiers. Third, since we are treating all strings as non-factors and we may not get all of the possible categories in our sample when using <kbd class="calibre9">random_levels()</kbd> the factor variable may be defined without some of the factors we previously specified. To make sure this doesn’t happen we explicitly define the levels inside the <kbd class="calibre9">factor()</kbd> function to be the levels in the original sales data frame sent to the function which contains the data from our initial definition:</p>
<pre class="mce-root">random_sales_data &lt;- function(sales, parameters) {<br class="title-page-name"/>    n &lt;- parameters[["n"]]<br class="title-page-name"/>    n_letters &lt;- parameters[["n_letters"]]<br class="title-page-name"/>    n_digits &lt;- parameters[["n_digits"]]<br class="title-page-name"/>    reduction &lt;- parameters[["reduction"]]<br class="title-page-name"/>    date_start &lt;- parameters[["date_start"]]<br class="title-page-name"/>    date_end &lt;- parameters[["date_end"]]<br class="title-page-name"/>    quantity_lambda &lt;- parameters[["quantity_lambda"]]<br class="title-page-name"/>    price_mean &lt;- parameters[["price_mean"]]<br class="title-page-name"/>    price_variance &lt;- parameters[["price_variance"]]<br class="title-page-name"/>    cost_mean &lt;- parameters[["cost_mean"]]<br class="title-page-name"/>    cost_variance &lt;- parameters[["cost_variance"]]<br class="title-page-name"/>    discount_lambda &lt;- parameters[["discount_lambda"]]<br class="title-page-name"/>    protein_source_pbs &lt;- parameters[["protein_source_probabilities"]]<br class="title-page-name"/>    continent_pbs &lt;- parameters[["continent_probabilities"]]<br class="title-page-name"/>    delivery_pbs &lt;- parameters[["deliver_probabilities"]]<br class="title-page-name"/>    status_pbs &lt;- parameters[["status_probabilities"]]<br class="title-page-name"/>    paid_pbs &lt;- parameters[["paid_probabilities"]]<br class="title-page-name"/>  <br class="title-page-name"/>    set.seed(12345)<br class="title-page-name"/><br class="title-page-name"/>    composition = random_composition(n)<br class="title-page-name"/><br class="title-page-name"/>    sales &lt;- data.frame(<br class="title-page-name"/>        SALE_ID = random_strings(n, n_letters, n_digits),<br class="title-page-name"/>        CLIENT_ID = random_strings(n, n_letters, n_digits, reduction),<br class="title-page-name"/>        DATE = random_dates_in_range(n, date_start, date_end),<br class="title-page-name"/>        QUANTITY = random_quantities(n, quantity_lambda),<br class="title-page-name"/>        COST = random_values(n, cost_mean, cost_variance),<br class="title-page-name"/>        PRICE = random_values(n, price_mean, price_variance),<br class="title-page-name"/>        DISCOUNT = random_discounts(n, discount_lambda),<br class="title-page-name"/>        PROTEIN = composition$PROTEIN,<br class="title-page-name"/>        CARBS = composition$CARBS,<br class="title-page-name"/>        FAT = composition$FAT,<br class="title-page-name"/>        PROTEIN_SOURCE = factor(<br class="title-page-name"/>            random_levels(n, <br class="title-page-name"/>                          levels(sales$PROTEIN_SOURCE), <br class="title-page-name"/>                          protein_source_pbs),<br class="title-page-name"/>            levels = levels(sales$PROTEIN_SOURCE)<br class="title-page-name"/>        ),<br class="title-page-name"/>        CONTINENT = factor(<br class="title-page-name"/>            random_levels(n, levels(sales$CONTINENT), continent_pbs),<br class="title-page-name"/>            levels = levels(sales$CONTINENT)<br class="title-page-name"/>        ),<br class="title-page-name"/>        DELIVERY = factor(<br class="title-page-name"/>            random_levels(n, levels(sales$DELIVERY), delivery_pbs),<br class="title-page-name"/>            levels = levels(sales$DELIVERY)<br class="title-page-name"/>        ),<br class="title-page-name"/>        STATUS = factor(<br class="title-page-name"/>            random_levels(n, levels(sales$STATUS), status_pbs),<br class="title-page-name"/>            levels = levels(sales$STATUS)<br class="title-page-name"/>        ),<br class="title-page-name"/>        PAID = factor(<br class="title-page-name"/>            random_levels(n, levels(sales$PAID), paid_pbs),<br class="title-page-name"/>            levels = levels(sales$PAID)<br class="title-page-name"/>        ),<br class="title-page-name"/>        stringsAsFactors = FALSE<br class="title-page-name"/>    )<br class="title-page-name"/>    sales &lt;- skew_sales_data(sales)<br class="title-page-name"/>    return(sales)<br class="title-page-name"/>}</pre>
<p class="calibre2">Finally, to create our simulation, we create the <kbd class="calibre9">parameters</kbd> object with the necessary information, and update our <kbd class="calibre9">sales</kbd> object using the <kbd class="calibre9">random_sales_data()</kbd> function. In this case we are going to simulate 10,000 sales orders between January 2015 (<kbd class="calibre9">date_start</kbd>) and today's date (<kbd class="calibre9">date_end</kbd>, using the <kbd class="calibre9">Sys.Date()</kbd> function to generate the date for today). We require our identifiers to have five letters (<kbd class="calibre9">n_letters</kbd>) followed by five digits (<kbd class="calibre9">n_digits</kbd>), and we want our <kbd class="calibre9">CLIENT_ID</kbd> to use only the first 25% of the generated identifiers to allow for repeated customers (<kbd class="calibre9">reduction</kbd>).</p>
<p class="calibre2">We want five foods per sales order on average (<kbd class="calibre9">quantity_lambda</kbd>), with production costs with a mean of 30 (<kbd class="calibre9">cost_mean</kbd>) and variance of 10 (<kbd class="calibre9">cost_variance</kbd>), and prices with a mean of 50 (<kbd class="calibre9">price_mean</kbd>) and a variance of 10 (<kbd class="calibre9">price_variance</kbd>). We also want discounts around 1 or 2 USD (<kbd class="calibre9">discount_lambda</kbd>; remember the transformation we did inside the corresponding function). Finally, we want the probabilities of <kbd class="calibre9">PENDING</kbd>, <kbd class="calibre9">DELIVERED</kbd>, <kbd class="calibre9">RETURNED</kbd>, and <kbd class="calibre9">CANCELLED</kbd> as <kbd class="calibre9">STATUS</kbd> to be 20%, 60%, 10%, and 10%, respectively. Similarly, we want the probabilities of an order being paid to be 90%:</p>
<pre class="mce-root">parameters &lt;- list(<br class="title-page-name"/>    n = 10000,<br class="title-page-name"/>    n_letters = 5,<br class="title-page-name"/>    n_digits = 5,<br class="title-page-name"/>    reduction = 0.25,<br class="title-page-name"/>    date_start = as.Date("2015-01-01"),<br class="title-page-name"/>    date_end = Sys.Date(),<br class="title-page-name"/>    quantity_lambda = 2,<br class="title-page-name"/>    cost_mean = 12,<br class="title-page-name"/>    cost_variance = 1,<br class="title-page-name"/>    price_mean = 15,<br class="title-page-name"/>    price_variance = 2,<br class="title-page-name"/>    discount_lambda = 100,<br class="title-page-name"/>    protein_source_probabilities = c(0.6, 0.2, 0.1, 0.1),<br class="title-page-name"/>    continent_probabilities = c(0.5, 0.3, 0.2),<br class="title-page-name"/>    delivery_probabilities = c(0.7, 0.3),<br class="title-page-name"/>    status_probabilities = c(0.2, 0.6, 0.1, 0.1),<br class="title-page-name"/>    paid_probabilities = c(0.9, 0.1)<br class="title-page-name"/>)<br class="title-page-name"/>sales &lt;- random_sales_data(sales, parameters)</pre>
<p class="calibre2">You can have fun with these parameters and simulate many different kinds of scenarios. For example, if you want to simulate a company that has been doing very badly with thin margins or even losses, you can bring the means of costs and prices together, and maybe even increase their respective variances to make sure there are a lot of crossovers, meaning losses per sale order.</p>
<p class="calibre2">Congratulations! You now know how to produce non-trivial data simulations. With this knowledge, you can have a lot of fun simulating many kinds of data. We encourage you to expand this example and play around with its analysis using the knowledge from the following chapters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Simulating the client data</h1>
                
            
            <article>
                
<p class="calibre2">Now that we have gone through the sales data simulation and we have the necessary fundamentals, the rest of the data simulation will be much easier. Furthermore, we will use many of the functions we created before to simulate the client and client messages data, which is great! Reusing functions like this is very efficient, and over time you will get into the habit of doing so. You will build your own collection of reusable code, which will make you increasingly more efficient when programming.</p>
<p class="calibre2">We start by defining the data frame we will use, just as we did before. In this case we will have the <kbd class="calibre9">CLIENT_ID</kbd>, <kbd class="calibre9">BIRTH_DATE</kbd>, <kbd class="calibre9">CLIENT_SINCE</kbd>, <kbd class="calibre9">GENDER</kbd>, and <kbd class="calibre9">STARS</kbd> variables. The <kbd class="calibre9">STARS</kbd> represent a rating between <kbd class="calibre9">1</kbd> (bad) and <kbd class="calibre9">5</kbd> (excellent):</p>
<pre class="mce-root">gender_levels &lt;- c("FEMALE", "MALE")<br class="title-page-name"/>star_levels &lt;- c("1", "2", "3", "4", "5")<br class="title-page-name"/><br class="title-page-name"/>clients &lt;- data.frame(<br class="title-page-name"/>    CLIENT_ID = character(),<br class="title-page-name"/>    BIRTH_DATE = as.Date(character()),<br class="title-page-name"/>    CLIENT_SINCE = as.Date(character()),<br class="title-page-name"/>    GENDER = factor(levels = gender_levels),<br class="title-page-name"/>    STARS = factor(levels = star_levels)<br class="title-page-name"/>)</pre>
<p class="calibre2">The first thing we note is that the <kbd class="calibre9">CLIENT_ID</kbd> information should not be simulated again, because we will get different client identifiers from the ones we already have in the sales data. We want unique client identifiers in the sales data to correspond to a record in the client data, which we accomplish by sending them as the <kbd class="calibre9">client_ids</kbd> parameter and assigning them directly into the <kbd class="calibre9">CLIENT_ID</kbd> variable in the <kbd class="calibre9">clients</kbd> data frame. In this case, <kbd class="calibre9">n</kbd> will correspond to the number of unique client identifiers we get, which we get by using the <kbd class="calibre9">length()</kbd> function. The other parameters we extract as we normally would with parameter objects. Specifically, we need the range of dates which are valid for our client's birth dates (they must be at least 18 years old), as well as the valid range of dates since they were clients (they couldn't have been a client before the company started operations in January 2015; see the parameters for the sales data simulation). The rest of the code is very similar to what we saw in the sales data simulation, so we won't explain it again. To understand this, let's have a look at the following code:</p>
<pre class="mce-root">random_clients_data &lt;- function(clients, client_ids, parameters) {<br class="title-page-name"/>    n &lt;- length(client_ids)<br class="title-page-name"/>    bd_start &lt;- parameters[["birth_date_start"]]<br class="title-page-name"/>    bd_end &lt;- parameters[["birth_date_end"]]<br class="title-page-name"/>    cs_start &lt;- parameters[["client_since_start"]]<br class="title-page-name"/>    cs_end &lt;- parameters[["client_since_end"]]<br class="title-page-name"/>    stars_pbs &lt;- parameters[["stars_probabilities"]]<br class="title-page-name"/>    <br class="title-page-name"/>    set.seed(12345)<br class="title-page-name"/><br class="title-page-name"/>    clients &lt;- data.frame(<br class="title-page-name"/>        CLIENT_ID = client_ids,<br class="title-page-name"/>        BIRTH_DATE = random_dates_in_range(n, bd_start, bd_end, TRUE),<br class="title-page-name"/>        CLIENT_SINCE = random_dates_in_range(n, cs_start, cs_end, TRUE),<br class="title-page-name"/>        GENDER = factor(<br class="title-page-name"/>            random_levels(n, levels(clients$GENDER)),<br class="title-page-name"/>            levels = levels(clients$GENDER)<br class="title-page-name"/>        ),<br class="title-page-name"/>        STARS = factor(<br class="title-page-name"/>            random_levels(n, levels(clients$STARS), stars_pbs),<br class="title-page-name"/>            levels = levels(clients$STARS)<br class="title-page-name"/>        ),<br class="title-page-name"/>        stringsAsFactors = FALSE<br class="title-page-name"/>    )<br class="title-page-name"/>    return(clients)<br class="title-page-name"/>}</pre>
<p class="calibre2">To simulate the client data, we simply create the corresponding parameters inside the parameters object and send that to the <kbd class="calibre9">random_clients_data()</kbd> function to update the <kbd class="calibre9">clients</kbd> data frame:</p>
<pre class="mce-root">parameters &lt;- list(<br class="title-page-name"/>    birth_date_start = as.Date("1950-01-01"),<br class="title-page-name"/>    birth_date_end = as.Date("1997-01-01"),<br class="title-page-name"/>    client_since_start = as.Date("2015-01-01"),<br class="title-page-name"/>    client_since_end = Sys.Date(),<br class="title-page-name"/>    stars_probabilities = c(0.05, 0.1, 0.15, 0.2, 0.5)<br class="title-page-name"/>)<br class="title-page-name"/><br class="title-page-name"/>clients &lt;- random_clients_data(clients, <br class="title-page-name"/>                               unique(sales$CLIENT_ID), <br class="title-page-name"/>                               parameters)</pre>
<p class="calibre2">Did you notice how easy this was? This is because we created our fundamentals in the previous section, and they drastically simplified following applications of the same concepts. As you increase your programming skills, this will happen more often.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Simulating the client messages data</h1>
                
            
            <article>
                
<p class="calibre2">Simulating text messages that actually make sense is very hard, and we won't attempt it here. Instead, what we'll do is leverage a dataset that was published about food reviews on Amazon. The dataset was published as part of the paper published by McAuley and Leskovec, <em class="calibre19">From amateurs to connoisseurs: modeling the evolution of user expertise through online reviews, 2013</em>. You can find the dataset in Kaggle (<a href="https://www.kaggle.com/snap/amazon-fine-food-reviews" class="calibre4">https://www.kaggle.com/snap/amazon-fine-food-reviews</a>). We won't show the code that prepared the data for this example, but basically, what it does is rename the variables we want <kbd class="calibre9">STARS</kbd>, <kbd class="calibre9">SUMMARY</kbd>, and <kbd class="calibre9">MESSAGE</kbd>, delete the rest, and save the data frame into the <kbd class="calibre9">reviews.csv</kbd> file. For the interested reader, the code that accomplishes this task, as well as the original and processed data, is inside the code repository for this book (<a href="https://github.com/PacktPublishing/R-Programming-By-Example" class="calibre4">https://github.com/PacktPublishing/R-Programming-By-Example</a>).</p>
<p class="calibre2">The idea is that since it's hard to simulate this data, we will leverage an already existing dataset with real reviews and sample it to get the messages we want for our example. As before, we start by defining the <kbd class="calibre9">client_messages</kbd> data frame we will use with the <kbd class="calibre9">SALE_ID</kbd>, <kbd class="calibre9">DATE</kbd>, <kbd class="calibre9">STARS</kbd>, <kbd class="calibre9">SUMMARY</kbd>, and <kbd class="calibre9">MESSAGE</kbd> variables as shown in the following code:</p>
<pre class="mce-root">client_messages &lt;- data.frame(<br class="title-page-name"/>    SALE_ID = character(),<br class="title-page-name"/>    DATE = as.Date(character()),<br class="title-page-name"/>    STARS = factor(levels = star_levels),<br class="title-page-name"/>    SUMMARY = character(),<br class="title-page-name"/>    MESSAGE = character(),<br class="title-page-name"/>    LAT = numeric(),<br class="title-page-name"/>    LNG = numeric()<br class="title-page-name"/>)</pre>
<p class="calibre2">As we have done before, in our <kbd class="calibre9">random_client_messages_data()</kbd> function, we first unpack the parameter object and set the seed. The next step is to actually retrieve the reviews sample we want with the <kbd class="calibre9">random_reviews()</kbd> function we will create next. Assuming we have the reviews data ready, we create the <kbd class="calibre9">client_messages</kbd> data frame by taking a random sample from the <kbd class="calibre9">sale_ids</kbd> from the sales data so that we can generate a connection among messages and sales orders, and we do so in a way that we can generate various messages for a single sales order, since we use the <kbd class="calibre9">replace</kbd> argument as <kbd class="calibre9">TRUE</kbd>. The other parts of the code are similar to what we have seen before. Let's have a look at the following code:</p>
<pre class="mce-root">random_client_messages_data &lt;- function(client_messages, sales, parameters) {<br class="title-page-name"/>    n &lt;- parameters[["n"]]<br class="title-page-name"/>    date_start &lt;- parameters[["date_start"]]<br class="title-page-name"/>    date_end &lt;- parameters[["date_end"]]<br class="title-page-name"/>    reviews_file &lt;- parameters[["reviews_file"]]<br class="title-page-name"/>    locations &lt;- parameters[["locations"]]<br class="title-page-name"/><br class="title-page-name"/>    set.seed(12345)<br class="title-page-name"/><br class="title-page-name"/>    reviews &lt;- random_reviews(n, reviews_file)<br class="title-page-name"/><br class="title-page-name"/>    client_messages &lt;- data.frame(<br class="title-page-name"/>        SALE_ID = sample(unique(sales$SALE_ID), n, TRUE),<br class="title-page-name"/>        DATE = random_dates_in_range(n, date_start, date_end),<br class="title-page-name"/>        STARS = factor(reviews$STARS, <br class="title-page-name"/>                       levels = levels(client_messages$STARS)),<br class="title-page-name"/>        SUMMARY = reviews$SUMMARY,<br class="title-page-name"/>        MESSAGE = reviews$MESSAGE,<br class="title-page-name"/>        LAT = numeric(n),<br class="title-page-name"/>        LNG = numeric(n),<br class="title-page-name"/>        stringsAsFactors = FALSE<br class="title-page-name"/>    )<br class="title-page-name"/>    client_messages &lt;- add_coordinates(client_messages, <br class="title-page-name"/>                                       sales, <br class="title-page-name"/>                                       locations)<br class="title-page-name"/>    return(client_messages)<br class="title-page-name"/>}</pre>
<p class="calibre2">The <kbd class="calibre9">random_reviews()</kbd> function takes the CSV file path as an argument in <kbd class="calibre9">reviews_file</kbd> and uses it to load the data into the <kbd class="calibre9">reviews</kbd> object. Then it takes a sample of the row indexes without replacement, because we don't want to use the same review twice, and we have enough reviews to make sure that doesn't happen (there are over 5,00,000 reviews in the data). We simply return this subset of the data frame back to be used in the final <kbd class="calibre9">client_messages</kbd> data frame:</p>
<pre class="mce-root">random_reviews &lt;- function(n, reviews_file) {<br class="title-page-name"/>    reviews &lt;- readRDS(reviews_file)<br class="title-page-name"/>    return(reviews[sample(1:nrow(reviews), n, FALSE), ])<br class="title-page-name"/>}</pre>
<p class="calibre2">Finally, we create the parameters object with the necessary information, and pass it along to the <kbd class="calibre9">random_client_messages_data()</kbd> to update the <kbd class="calibre9">client_messages</kbd> data frame with the simulated data. Make sure you change the <kbd class="calibre9">reviews_file</kbd> path to the one appropriate for your setup (<kbd class="calibre9">./</kbd> means that it's in the same directory). Let's have a look at the following code:</p>
<pre class="mce-root">parameters &lt;- list(<br class="title-page-name"/>    n = 1000,<br class="title-page-name"/>    date_start = as.Date("2015-01-01"),<br class="title-page-name"/>    date_end = Sys.Date(),<br class="title-page-name"/>    reviews_file = "./reviews/data/reviews.rds",<br class="title-page-name"/>    locations = list(<br class="title-page-name"/>        "AMERICA" = list(<br class="title-page-name"/>            list(LAT = 35.982915, LNG = -119.028006),<br class="title-page-name"/>            list(LAT = 29.023053, LNG = -81.762383),<br class="title-page-name"/>            list(LAT = 41.726658, LNG = -74.731133),<br class="title-page-name"/>            list(LAT = 19.256493, LNG = -99.292577),<br class="title-page-name"/>            list(LAT = -22.472499, LNG = -43.348329)<br class="title-page-name"/>        ),<br class="title-page-name"/>        "EUROPE" = list(<br class="title-page-name"/>            list(LAT = 40.436888, LNG = -3.863850),<br class="title-page-name"/>            list(LAT = 48.716026, LNG = 2.350955),<br class="title-page-name"/>            list(LAT = 52.348010, LNG = 13.351161),<br class="title-page-name"/>            list(LAT = 42.025875, LNG = 12.418940),<br class="title-page-name"/>            list(LAT = 51.504122, LNG = -0.364277)<br class="title-page-name"/>        ),<br class="title-page-name"/>        "ASIA" = list(<br class="title-page-name"/>            list(LAT = 31.074426, LNG = 121.125328),<br class="title-page-name"/>            list(LAT = 22.535733, LNG = 113.830406),<br class="title-page-name"/>            list(LAT = 37.618251, LNG = 127.135865),<br class="title-page-name"/>            list(LAT = 35.713791, LNG = 139.489820),<br class="title-page-name"/>            list(LAT = 19.134907, LNG = 73.000993)<br class="title-page-name"/>        )<br class="title-page-name"/>    )<br class="title-page-name"/>)<br class="title-page-name"/>client_messages &lt;- random_client_messages_data(client_messages, sales, parameters)</pre>
<p class="calibre2">We're done! Now we should have a full simulation for sales data, as well as data for clients and their messages for their respective sales orders. Not every sales order will have a message, and some of them may have more than one, and this is by design. Remember that the reviews we used for the example are not necessarily for foods, but the idea was to show how these techniques can be used to simulate new data using already existing datasets.</p>
<p class="calibre2">A look at the three datasets we have simulated should put a smile on our face. Note that we omit the <kbd class="calibre9">client_messages</kbd> data because it was too large to be shown here, but you should see it just fine on your computer:</p>
<pre class="mce-root">head(sales)
<strong class="calibre1">#&gt;      SALE_ID  CLIENT_ID       DATE QUANTITY  COST PRICE DISCOUNT    PROTEIN
#&gt; 1 OKRLL75596 EAWPJ80001 2015-01-27        3 27.58 50.79        1 0.12422681
#&gt; 2 ZVTFG64065 WQGVB74605 2015-05-26        7 30.78 51.09        3 0.11387543
#&gt; 3 SPRZD12587 XVRAM64230 2017-01-07        8 33.66 54.46        1 0.54351904
#&gt; 4 YGOLB67346 PDVDC58438 2015-01-12        5 34.85 53.06        1 0.49077566
#&gt; 5 CDQRA43926 VJCXI94728 2017-06-21        9 27.35 50.57        0 0.01026306
#&gt;
#&gt;       CARBS        FAT PROTEIN_SOURCE   STORE    DELIVERY    STATUS PAID
#&gt; 1 0.1548693 0.72090390        CHICKEN STORE 4    IN STORE DELIVERED  YES
#&gt; 2 0.1251422 0.76098233        CHICKEN STORE 3 TO LOCATION DELIVERED  YES
#&gt; 3 0.2901092 0.16637179     VEGETARIAN STORE 1 TO LOCATION   PENDING  YES
#&gt; 4 0.1841289 0.32509539        CHICKEN STORE 2 TO LOCATION DELIVERED  YES
#&gt; 5 0.2620317 0.72770525     VEGETARIAN STORE 1 TO LOCATION DELIVERED  YES
(Truncated output)

</strong>head(clients)<strong class="calibre1">
#&gt;    CLIENT_ID BIRTH_DATE CLIENT_SINCE GENDER STARS
#&gt; 1 EAWPJ80001 1974-09-04   2015-05-21   MALE     4
#&gt; 2 WQGVB74605 1987-01-24   2015-12-05 FEMALE     2
#&gt; 3 XVRAM64230 1977-11-18   2017-06-26 FEMALE     2
#&gt; 4 PDVDC58438 1987-11-23   2015-12-20   MALE     2
#&gt; 5 VJCXI94728 1953-07-09   2016-05-03 FEMALE     3
(Truncated output)</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Working with relational databases</h1>
                
            
            <article>
                
<p class="calibre2">Now that we have the data we need for the rest of the example, we're going to learn how to work with it using databases. In this section, we will learn how to save our data into a relational database, as well as how to read it back. We won't go too deep into advanced operations or workflows. We will only look into the basics, and this section may be skipped if you are not interested in this topic. It's not critical to know this to reproduce the rest of the example in the following chapters.</p>
<p class="calibre2">The first thing we must do is install the <kbd class="calibre9">RMySQL</kbd> package. There are various packages for working with databases, and they work almost the same. We chose the <kbd class="calibre9">RMySQL</kbd> package because it's designed for the MySQL database, which is very popular and easy to work with in almost all operating systems. To be able to reproduce this code, you will need a MySQL database set up properly in your computer, and we won't go into the details of how to do so here. You can find many good resources online. From this point on, we'll assume you have your database ready:</p>
<pre class="mce-root">install.packages("RMySQL")</pre>
<p class="calibre2">The first thing we need to do to work with databases is to connect and disconnect from them. To do so, we use the <kbd class="calibre9">dbConnect()</kbd> and <kbd class="calibre9">dbDisconnect()</kbd> functions. The <kbd class="calibre9">dbConnect()</kbd> function returns an object that contains the connection to the database, and which must be used in all following actions regarding the database. We will call this object <kbd class="calibre9">db</kbd> to remind us that it represents the database we're working with:</p>
<pre class="mce-root">db &lt;- dbConnect(MySQL(), user = &lt;YOUR_USER&gt;, password = &lt;YOUR_PASSWORD&gt;, host = "localhost")
dbDisconnect(db)
<strong class="calibre1">#&gt; [1] TRUE</strong></pre>
<p class="calibre2">If you're using a database that is not operating on the same computer you're using R from, then you can use the corresponding IP address in the <kbd class="calibre9">host</kbd> parameters as you normally would with any SQL remote connection. There's a fifth parameter that we need to use when we know the name of the database we're connecting (a single MySQL server can have multiple databases inside). When you see the <kbd class="calibre9">TRUE</kbd> value after trying to disconnect from the database, it means that everything executed correctly.</p>
<p class="calibre2">To send a query into the database server, we use the <kbd class="calibre9">dbSendQuery()</kbd> function after having connected to it again. We create the fresh <kbd class="calibre9">sales</kbd> database (which will contain our <kbd class="calibre9">sales</kbd>, <kbd class="calibre9">clients</kbd>, and <kbd class="calibre9">client_messages</kbd> tables) in our MySQL server by executing:</p>
<pre class="mce-root">dbSendQuery(db, "DROP DATABASE IF EXISTS sales;")
dbSendQuery(db, "CREATE DATABSE sales;")</pre>
<p class="calibre2">Since MySQL syntax requires "<kbd class="calibre9">;</kbd>" at the end of each query, depending on your setup, you may get an error if you don't put them in. Now we will disconnect and reconnect to the server, but this time, we will specify which particular database we want to work with (the <kbd class="calibre9">sales</kbd> database we just created):</p>
<pre class="mce-root">dbDisconnect(db)
db &lt;- dbConnect(
    MySQL(),
    user = &lt;YOUR_USER&gt;,
    password = &lt;YOUR_PASSWORD&gt;,
    host = "localhost",
    dbname = "sales"
)</pre>
<p class="calibre2">Now we're going to write the data we simulated into the MySQL server. To do so, we use the <kbd class="calibre9">dbWriteTable()</kbd> function. The first argument is the database connection object, the second argument is the name of the table we want to store the data in, the third argument is the data frame that contains the data we want to store, and the fourth argument, as the name suggests, will overwrite (as opposed to append) any data already present in the database.</p>
<p class="calibre2">To read a full table from the MySQL server into R, we use the <kbd class="calibre9">dbReadTable()</kbd> function. However, note that when we do, any information regarding factors is lost, and the data frame only knows it contains strings, which is the way the data is stored within the MySQL server. To verify this, you can look into the structure of the data being read from the MySQL server with the <kbd class="calibre9">str()</kbd> function. We won't show the output here to preserve space, but you will find that <kbd class="calibre9">sales</kbd> does have the factor information, while <kbd class="calibre9">sales_from_db</kbd> does not:</p>
<pre class="mce-root">sales_from_db &lt;- dbReadTable(db, "sales")
str(sales)
str(sales_from_db)</pre>
<p class="calibre2">Not fixing this metadata problem about the factor variables will have implications when we create our visualizations in the next chapter. We can deal with it now or later, but since this chapter is about working with data, we will show how to do so here. First, we will create the <kbd class="calibre9">read_table()</kbd> function that will wrap the <kbd class="calibre9">dbReadTable()</kbd> function. This <kbd class="calibre9">read_table()</kbd> function will check which table is being read and apply the appropriate metadata by calling <kbd class="calibre9">add_sales_metadata()</kbd>, <kbd class="calibre9">add_clients_metadata()</kbd>, or <kbd class="calibre9">add_client_messages_metadata()</kbd>. Note that if the table being read is not one of those three, we will not know what metadata to add for now, so we will just return the table directly:</p>
<pre class="mce-root">read_table &lt;- function(db, table) {<br class="title-page-name"/>    data &lt;- dbReadTable(db, table)<br class="title-page-name"/>    if (table == "sales") {<br class="title-page-name"/>        return(add_sales_metadata(data))<br class="title-page-name"/>    } else if (table == "clients") {<br class="title-page-name"/>        return(add_clients_metadata(data))<br class="title-page-name"/>    } else if (table == "client_messages") {<br class="title-page-name"/>        return(add_client_messages_metadata(data))<br class="title-page-name"/>    } else {<br class="title-page-name"/>        return(data)<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">The way we add metadata to each case is by redefining the factor variables as we did before, as well as transforming the date objects, which are also received as strings. We don't have to change anything else in the data:</p>
<pre class="mce-root">add_sales_metadata &lt;- function(data) {<br class="title-page-name"/>    status_levels &lt;- c("PENDING", "DELIVERED", "RETURNED", "CANCELLED")<br class="title-page-name"/>    protein_source_levels &lt;- c("BEEF", "FISH", "CHICKEN", "VEGETARIAN")<br class="title-page-name"/>    continent_levels &lt;- c("AMERICA", "EUROPE", "ASIA")<br class="title-page-name"/>    delivery_levels &lt;- c("IN STORE", "TO LOCATION")<br class="title-page-name"/>    paid_levels &lt;- c("YES", "NO")<br class="title-page-name"/>    data$DATE &lt;- as.Date(data$DATE)<br class="title-page-name"/>    data$PROTEIN_SOURCE &lt;- <br class="title-page-name"/>    factor(data$PROTEIN_SOURCE, levels = protein_source_levels)<br class="title-page-name"/><br class="title-page-name"/>    data$CONTINENT &lt;- factor(data$CONTINENT, levels = continent_levels)<br class="title-page-name"/>    data$DELIVERY &lt;- factor(data$DELIVERY, levels = delivery_levels)<br class="title-page-name"/>    data$STATUS &lt;- factor(data$STATUS, levels = status_levels)<br class="title-page-name"/>    data$PAID &lt;- factor(data$PAID, levels = paid_levels)<br class="title-page-name"/>    return(data)<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>add_clients_metadata &lt;- function(data) {<br class="title-page-name"/>    gender_levels &lt;- c("FEMALE", "MALE")<br class="title-page-name"/>    star_levels &lt;- c("1", "2", "3", "4", "5")<br class="title-page-name"/>    data$BIRTH_DATE &lt;- as.Date(data$BIRTH_DATE)<br class="title-page-name"/>    data$CLIENT_SINCE &lt;- as.Date(data$CLIENT_SINCE)<br class="title-page-name"/>    data$GENDER &lt;- factor(data$GENDER, levels = gender_levels)<br class="title-page-name"/>    data$STARS &lt;- factor(data$STARS, levels = star_levels)<br class="title-page-name"/>    return(data)<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>add_client_messages_metadata &lt;- function(data) {<br class="title-page-name"/>    star_levels &lt;- c("1", "2", "3", "4", "5")<br class="title-page-name"/>    data$DATE &lt;- as.Date(data$DATE)<br class="title-page-name"/>    data$STARS &lt;- factor(data$STARS, levels = star_levels)<br class="title-page-name"/>    return(data)<br class="title-page-name"/>}</pre>
<p class="calibre2">Now we can see that both <kbd class="calibre9">sales</kbd> and <kbd class="calibre9">sales_from_db</kbd> contain the same metadata. Again, we don't show the output to preserve space, but you'll see that the factor metadata is now preserved when reading from the MySQL server:</p>
<pre class="mce-root">sales_from_db &lt;- read_table(db, "sales")
str(sales)
str(sales_from_db)</pre>
<p class="calibre2">Since they have the same data and metadata, it's now safe to completely read the data from the MySQL server whenever we need to work with this data. Just remember to use the <kbd class="calibre9">read_table()</kbd> function instead of the <kbd class="calibre9">dbReadTable()</kbd> function.</p>
<div class="packt_tip">Reading full tables from the MySQL server with the <kbd class="calibre21">dbReadTable()</kbd> is only practical when the tables are not too large. If you're working with a database in a real problem, that's probably not the case. If the data you're trying to read is too large, use a combination of the <kbd class="calibre21">dbSendQuery()</kbd> and <kbd class="calibre21">fetch()</kbd> functions.</div>
<p class="calibre2">If you want to know what data type will be used in the MySQL server to store the data you're sending, you can use the <kbd class="calibre9">dbDataType()</kbd> function with the <kbd class="calibre9">MySQL()</kbd> argument, as well as the data type whose server type you want to find out:</p>
<pre class="mce-root">dbDataType(MySQL(), "a")
<strong class="calibre1">#&gt; [1] "text"</strong>
dbDataType(MySQL(), 1.5)
<strong class="calibre1">#&gt; [1] "double"</strong></pre>
<p class="calibre2">Finally, you may use the <kbd class="calibre9">dbListTables()</kbd> and <kbd class="calibre9">dbListFields()</kbd> functions to find out the tables available in the database and the fields available for a specific table, respectively. If you followed the example this far, you should see the following:</p>
<pre class="mce-root">dbListTables(db)
<strong class="calibre1">#&gt; [1] "client_messages" "clients" "sales"</strong>

dbListFields(db, "sales")
<strong class="calibre1">#&gt;  [1] "row_names"      "SALE_ID"        "CLIENT_ID"      "DATE"
#&gt;  [5] "QUANTITY"       "COST"           "PRICE"          "DISCOUNT"
#&gt;  [9] "PROTEIN"        "CARBS"          "FAT"            "PROTEIN_SOURCE"
#&gt; [13] "STORE"          "DELIVERY"       "STATUS"         "PAID"</strong>

dbListFields(db, "clients")
<strong class="calibre1">#&gt; [1] "row_names"    "CLIENT_ID"    "BIRTH_DATE"    "CLIENT_SINCE" "GENDER"
#&gt; [6] "STARS"</strong>

dbListFields(db, "client_messages")
<strong class="calibre1">#&gt; [1] "row_names" "SALE_ID"   "DATE"      "STARS"     "SUMMARY"   "MESSAGE"</strong></pre>
<div class="packt_tip">Note that you see the <kbd class="calibre21">row.names</kbd> field because it's necessary for MySQL functionality, but when you actually read the data from the database, you won't get that field. You will get all other fields shown (the ones in capital letters).</div>
<p class="calibre2">These are the basics of working with a MySQL server using R. For the interested reader, a good, concise resource that showcases many other <kbd class="calibre9">RMySQL</kbd> features are Squared Academy's <em class="calibre19">RMySQL Tutorial for Beginners, 2016</em> slides (<a href="https://www.slideshare.net/RsquaredIn/rmysql-tutorial-for-beginners" class="calibre4">https://www.slideshare.net/RsquaredIn/rmysql-tutorial-for-beginners</a>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, we established the fundamentals of the food sales example by presenting the general scenario for The Food Factory: what they do, what they want to accomplish, and, most importantly, how to simulate the data we will need for the rest of the example. We went over various techniques to simulate different kinds of data, like numbers, categories, strings, and dates. The approach we showed is flexible enough to allow you to simulate many different kinds of data in modular and incremental ways. We also showed how to allow flexibility for different assumptions about the simulation to easily take place by using parameter objects. We learned how to create functions that are useful for different scenarios, and how to mix our simulated data with data coming from external sources. Finally, we learned how to work with external MySQL databases.</p>
<p class="calibre2">We are ready to take on the analysis part of the example. In the next chapter, <a href="part0110.html#38STS0-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 5</a>, <em class="calibre19">Communicating Sales with Visualization</em>, we will use the data we just simulated to create many visualizations that will allow us to get a good idea of the current status of The Food Factory, as well as its areas for improvement.</p>


            </article>

            
        </section>
    </body></html>