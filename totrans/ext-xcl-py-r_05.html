<html><head></head><body>
		<div id="_idContainer043">
			<h1 id="_idParaDest-91" class="chapter-number"><a id="_idTextAnchor099"/>5</h1>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor100"/>Formatting Your Excel Sheet</h1>
			<p>In this chapter, we are going to go over two different libraries in R and various libraries in Python that can be used to format tables and data in an <span class="No-Break">Excel worksheet.</span></p>
			<p>There are several packages in R that we will be discussing, including <span class="No-Break">the following:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">styledTables</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">basictabler</strong></span></li>
			</ul>
			<p>We are going to create some fictitious data along with using one of R’s built-in datasets, Iris, and then we are going to apply styling to it from the aforementioned packages. Each package will have its methods to apply this styling, so it’s good to go over them and see which type of workflow you prefer. </p>
			<p>In the Python section of this chapter, we will explore the advanced options available in <strong class="source-inline">pandas</strong> and <strong class="source-inline">openpyxl</strong> to create beautiful tables and pivot tables from Python in Excel. In particular, we will use <strong class="source-inline">pandas</strong>, <strong class="source-inline">openpyxl</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">pywin32</strong></span><span class="No-Break">.</span></p>
			<p>In this chapter, we will understand the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Installing and using <strong class="source-inline">styledTables</strong> <span class="No-Break">in R</span></li>
				<li>Advanced options for formatting <span class="No-Break">with Python</span></li>
			</ul>
			<p>By the end of this chapter, you will have a deep understanding of cell formatting, conditional formatting, and pivot tables. So, without further delay, let’s get <span class="No-Break">into them.</span></p>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor101"/>Technical requirements</h1>
			<p>The code for this chapter can be found on GitHub at the following link:  <a href="https://github.com/PacktPublishing/Extending-Excel-with-Python-and-R/tree/main/Chapter5"><span class="No-Break">https://github.com/PacktPublishing/Extending-Excel-with-Python-and-R/tree/main/Chapter5</span></a><span class="No-Break">.</span></p>
			<p>As mentioned previously, we are going to be working with a few different packages in the R section. The <strong class="source-inline">styledTables</strong> package can only be installed from GitHub via the <span class="No-Break"><strong class="source-inline">devtools</strong></span><span class="No-Break"> package.</span></p>
			<p>For the Python section, you will need one new package (specifically for the formatting tasks with <span class="No-Break"><strong class="source-inline">pandas</strong></span><span class="No-Break">): </span><span class="No-Break"><strong class="source-inline">jinja2==3.1.2</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor102"/>Installing and using styledTables in R</h1>
			<p>As we have done before, we<a id="_idIndexMarker281"/> will need<a id="_idIndexMarker282"/> to install<a id="_idIndexMarker283"/> the necessary packages<a id="_idIndexMarker284"/> before we can use them. In this section, we are going to install the <strong class="source-inline">styledTables</strong> package. Because <strong class="source-inline">styledTables</strong> is not on CRAN, we cannot install it using the typical method of using the <strong class="source-inline">install.packages()</strong>function, so we will need to install this package from GitHub. This will require us to also install the <strong class="source-inline">devtools</strong> package, which has the functionality to do this very sort <span class="No-Break">of thing.</span></p>
			<p>Here is the full code you’ll need to install <span class="No-Break">the package:</span></p>
			<pre class="source-code">
install.packages("devtools")
# Install development version from GitHub
devtools::install_github(
'R-package/styledTables',
build_vignettes = TRUE
)</pre>			<p>After running the preceding code, we can call the library into the current session in the typical fashion by issuing <strong class="source-inline">library(styledtables)</strong> in the console. Now that we have loaded the library in, we can go ahead and create our first script, which will style a table based on a simple criterion. Let’s <span class="No-Break">get started:</span></p>
			<pre class="source-code">
library(TidyDensity)
library(styledTables)
library(xlsx)
st &lt;- tidy_normal() |&gt;
  styled_table(keep_header = TRUE) |&gt;
  set_border_position("all", row_id = 1) |&gt;
  set_bold(row_id = 1) |&gt;
  set_fill_color("#00FF00", col_id = 3,
                 condition = X &gt;= 0.5)
# open new xlsx workbook and create a worksheet
wb &lt;- createWorkbook()
sheet &lt;- createSheet(wb, "tidy_normal")
# insert the styled table in the worksheet
write_excel(sheet, st)
# save the workbook
saveWorkbook(wb, "chapter5/styledTables_test.xlsx")</pre>			<p>This R code uses<a id="_idIndexMarker285"/> several<a id="_idIndexMarker286"/> libraries (<strong class="source-inline">TidyDensity</strong>, <strong class="source-inline">styledTables</strong>, and <strong class="source-inline">xlsx</strong>) to create<a id="_idIndexMarker287"/> a styled table<a id="_idIndexMarker288"/> from a dataset, save it to an Excel file, and apply some formatting to it. Let’s break down the code step <span class="No-Break">by step:</span></p>
			<ol>
				<li>First, we load the required libraries – <strong class="source-inline">TidyDensity</strong> for creating a table of randomly generated data from a Gaussian distribution, <strong class="source-inline">styledTables</strong> for styling tables, and <strong class="source-inline">xlsx</strong> for working with <span class="No-Break">Excel files.</span></li>
				<li>Then, we create and style the table. This code creates a styled table, <strong class="source-inline">st</strong>, from the output of the <strong class="source-inline">tidy_normal()</strong> function. The <strong class="source-inline">tidy_normal()</strong> function generates some data from a Gaussian distribution and presents it in a tibble format. The table is then styled using the <strong class="source-inline">styled_table()</strong> function with <strong class="source-inline">keep_header = TRUE</strong>, which means the header row will be retained and styled separately from the data rows. The next three lines of code apply specific styles to the first row (header row) of the table. It sets a border around all cells in the first row, makes the text bold in the first row, and sets a fill color (<strong class="source-inline">#00FF00</strong>, which is green) to cells in the third column if the corresponding value (denoted by <strong class="source-inline">X</strong>) in that column is greater than or equal <span class="No-Break">to 0.5.</span></li>
				<li>Then, we create a new Excel workbook and worksheet using the <strong class="source-inline">xlsx</strong> package by creating a new workbook with the <strong class="source-inline">createWorkbook()</strong> function. Once this workbook has been created, we use the <strong class="source-inline">createSheet()</strong> function to create the sheet in the workbook with a sheet name <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">tidy_normal</strong></span><span class="No-Break">.</span></li>
				<li>Next, we insert the styled table into the worksheet by using the <strong class="source-inline">write_excel()</strong> function from the <strong class="source-inline">styledTables</strong> library. This takes the styled table, <strong class="source-inline">st</strong>, and places it into the <span class="No-Break"><strong class="source-inline">tidy_normal</strong></span><span class="No-Break"> worksheet.</span></li>
				<li>Finally, we save the workbook to an Excel file with the <strong class="source-inline">saveWorkbook()</strong> XLSX function, where we tell it to save the <strong class="source-inline">wb</strong> workbook into an Excel file named <strong class="source-inline">styledTables_test.xlsx</strong> in a subdirectory <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">chapter5</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p>In summary, this R code generates<a id="_idIndexMarker289"/> a styled table<a id="_idIndexMarker290"/> from some<a id="_idIndexMarker291"/> data (obtained from <strong class="source-inline">tidy_normal()</strong>), applies specific<a id="_idIndexMarker292"/> formatting to the header row and cells in the third column, saves the styled table in an Excel file, and places it in a worksheet named <strong class="source-inline">tidy_normal</strong>. The resulting Excel file will contain the styled table with the <span class="No-Break">specified formatting.</span></p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor103"/>Installing and using basictabler in R</h2>
			<p>The <strong class="source-inline">basictabler</strong> R package provides<a id="_idIndexMarker293"/> an easy way to create<a id="_idIndexMarker294"/> rich tables<a id="_idIndexMarker295"/> from <strong class="source-inline">DataFrame</strong><a id="_idIndexMarker296"/> or matrices. The tables can be rendered as HTML, HTML widgets, or <span class="No-Break">Excel spreadsheets.</span></p>
			<p>To create a <strong class="source-inline">basictabler</strong> object, you need to create a <strong class="source-inline">DataFrame</strong> or matrix. Once you have your data, you can create a <strong class="source-inline">basictabler</strong> object by calling the <strong class="source-inline">qhtbl()</strong> function. The <strong class="source-inline">qhtbl()</strong> function takes two arguments: the <strong class="source-inline">DataFrame</strong> or matrix, and a list of formatting options. We are going to spend time on the <strong class="source-inline">qhtbl()</strong> function and the <strong class="source-inline">BasicTable()</strong> function. The <strong class="source-inline">qhtbl()</strong> function is a quick way to generate a table, while the <strong class="source-inline">BasicTable()</strong> function is a way to build it piece by piece. First, we are going to create a very basic example using the <strong class="source-inline">qhtbl()</strong> function, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
# Load in the library
library(basictabler)
# Create a data frame
data &lt;- data.frame(
  name = c("John Doe", "Jane Doe"),
  age = c(30, 25),
  salary = c(100000, 50000))
# Create a Plain table
table_plain &lt;- qhtbl(data, theme = "largeplain")
table_plain</pre>			<p>Here is the output of <span class="No-Break">the code:</span></p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/B19142_05_1.jpg" alt="Figure 5.1 – Using basictabler to create a plain table"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – Using basictabler to create a plain table</p>
			<p>Now that we <a id="_idIndexMarker297"/>can see what<a id="_idIndexMarker298"/> it looks like, let’s go<a id="_idIndexMarker299"/> over what just<a id="_idIndexMarker300"/> happened. First, we created a dataset named <strong class="source-inline">data</strong>. This was a small simple dataset purely to help illustrate the use of the <strong class="source-inline">basictabler</strong> package. Once the data has been created, we simply call the <strong class="source-inline">ghtbl()</strong> function on the data, give it a theme of <strong class="source-inline">largeplain</strong>, and then assign it to the <strong class="source-inline">table_plain</strong> variable. This only makes the table – it does not send it to Excel. We will go over that later. </p>
			<p>Now, let’s look at another example that is a little bit <span class="No-Break">more involved:</span></p>
			<pre class="source-code">
# Create a basictabler object
table &lt;- qhtbl(data,
  theme = "largeplain",
  tableStyle = list("border-color" = "maroon"),
  headingStyle = list(
    "color" = "cornsilk", "background-color" = "maroon",
    "font-style" = "italic", "border-color" = "maroon"
  ),
  cellStyle = list(
    "color" = "maroon", "background-color" = "cornsilk",
    "border-color" = "maroon"
  )
)
# Render the table to HTML
table</pre>			<p>This piece of code will produce<a id="_idIndexMarker301"/> a table that consists of the same data. However, the difference<a id="_idIndexMarker302"/> here is that<a id="_idIndexMarker303"/> this one will have<a id="_idIndexMarker304"/> some styling. Let’s go over the styling options we used; then, we will see the <span class="No-Break">finished product.</span></p>
			<p>The first difference is that we used the <strong class="source-inline">tableStyle</strong> option. This option in the function takes in as its argument a list object of CSS style declarations that will be applied to the table. For this option, we provided a value of <strong class="source-inline">"border-color" = "</strong><span class="No-Break"><strong class="source-inline">maroon"</strong></span><span class="No-Break">.</span></p>
			<p>The next option that we used is <strong class="source-inline">headingStyle</strong>, which also takes a list object of CSS style declarations that get applied to the headings of the table. In the preceding code, we used four different options inside the list. First, we chose to use the <strong class="source-inline">color</strong> option with a value of <strong class="source-inline">cornsilk</strong> and then we chose <strong class="source-inline">background-color</strong> with a value of <strong class="source-inline">maroon</strong>. The next option we chose was <strong class="source-inline">font-style</strong> for <strong class="source-inline">italics</strong> and then finally <strong class="source-inline">border-color</strong> with <strong class="source-inline">maroon</strong>. Let’s see what this <span class="No-Break">looks like:</span></p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/B19142_05_2.jpg" alt="Figure 5.2 – A second basictabler example using some different styling"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – A second basictabler example using some different styling</p>
			<p>Now, let’s walk through a longer<a id="_idIndexMarker305"/> example that <a id="_idIndexMarker306"/>will use some different<a id="_idIndexMarker307"/> features of <a id="_idIndexMarker308"/>the <strong class="source-inline">basictabler</strong> package to map styles according to some sort of logic that we dictate. Refer to the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
# A longer example
library(TidyDensity)
tn &lt;- tidy_normal(.n = 10)</pre>			<p><strong class="source-inline">library(TidyDensity)</strong> imports the <strong class="source-inline">TidyDensity</strong> package into the R environment. This package provides tools for visualizing and summarizing distributions. We use it specifically to generate a tibble of a normal distribution with 10 points. We do not need to call in <strong class="source-inline">basictabler</strong> because it is already loaded at <span class="No-Break">this point.</span></p>
			<p>Next, we assign <strong class="source-inline">tn &lt;- tidy_normal(.n = 10)</strong>. This line creates a dataset called <strong class="source-inline">tn</strong> by generating 10 random points from a standard normal distribution. The function also creates the density of the data (<strong class="source-inline">dx</strong>, <strong class="source-inline">dy</strong>), along with <strong class="source-inline">pnorm</strong> and <strong class="source-inline">qnorm</strong>, as columns of <span class="No-Break">the table:</span></p>
			<pre class="source-code">
tbl &lt;- BasicTable$new()
# formatting values (explained in the introduction vignette)
columnFormats &lt;- list(
  NULL, NULL, "%.4f", "%.4f", "%.4f", "%.4f", "%.4f"
)</pre>			<p><strong class="source-inline">tbl &lt;- BasicTable$new()</strong> creates a new instance of a <strong class="source-inline">BasicTable</strong> object called <strong class="source-inline">tbl</strong>. The <strong class="source-inline">BasicTable</strong> class is an <strong class="source-inline">R6</strong> class object<a id="_idIndexMarker309"/> from the <strong class="source-inline">basictabler</strong> package. This function<a id="_idIndexMarker310"/> has many different<a id="_idIndexMarker311"/> public methods associated<a id="_idIndexMarker312"/> with it. These methods help create the table itself, as well as <span class="No-Break">its styling:</span></p>
			<pre class="source-code">
tbl$addData(tn,
  firstColumnAsRowHeaders = TRUE,
  explicitColumnHeaders = c(
"Simulation", "x", "y", "dx", "dy", "p", "q"
  ),
  columnFormats = columnFormats
)</pre>			<p>From the preceding code snippet, we understand <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">tbl$addData(tn, ...)</strong>: This line adds the data from the <strong class="source-inline">tn</strong> dataset to the <strong class="source-inline">tbl</strong> table object. It also sets some options for how the data should be displayed, such as using the first column as row headers and explicitly setting the <span class="No-Break">column headers.</span></li>
				<li><strong class="source-inline">columnFormats &lt;- list(...)</strong>: Here, a list named <strong class="source-inline">columnFormats</strong> is created, which contains formats for each column of the table. The formats that are specified are for the second to the seventh column (index 1 to 6) and are represented using <strong class="source-inline">strings.tbl$renderTable()</strong>. Here, we <span class="No-Break">used </span><span class="No-Break"><strong class="source-inline">%.4f</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">tbl$renderTable()</strong>: This line renders the table based on the data and formatting provided earlier and displays it in the R environment. This gives us the necessary table pre-styling so that we can see a base table versus what we’ve done <span class="No-Break">to it.</span></li>
			</ul>
			<p>Next, we have the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
# Add some conditional formatting
cells &lt;- tbl$getCells(
rowNumbers = 2:11,
columnNumbers = 3:7,
matchMode = "combinations"
)</pre>			<p>Here, the <strong class="source-inline">cells &lt;- tbl$getCells(...)</strong> line retrieves<a id="_idIndexMarker313"/> a subset of cells<a id="_idIndexMarker314"/> from the <strong class="source-inline">tbl</strong> table object. It selects cells<a id="_idIndexMarker315"/> from rows 2 to 11 and<a id="_idIndexMarker316"/> columns 3 to 7 (<strong class="source-inline">y</strong>, <strong class="source-inline">dx</strong>, <strong class="source-inline">dy</strong>, <strong class="source-inline">p</strong>, <strong class="source-inline">q</strong>) using the <span class="No-Break"><strong class="source-inline">getCells()</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
tbl$mapStyling(
  cells = cells,
  styleProperty = "background-color",
  valueType = "color",
  mapType = "logic",
  mappings = list(
    "v&lt;=-3", "red",
    "-3&lt;v&lt;=-2", "orange",
    "-2&lt;v&lt;=-1", "pink",
    "-1&lt;v&lt;= 0", "white",
    "0&lt;v&lt;=1", "white",
    "1&lt;v&lt;=2", "lightgreen",
    "2&lt;v&lt;=3", "lightblue",
    "3&lt;v", "green"
  )
)</pre>			<p>The <strong class="source-inline">tbl$mapStyling(...)</strong> line applies conditional formatting to the selected cells. The <strong class="source-inline">mapStyling()</strong> method is used to map styles (such as background color) to cell values based on <span class="No-Break">certain conditions:</span></p>
			<pre class="source-code">
tbl$renderTable()</pre>			<p>After applying conditional formatting, the <strong class="source-inline">tbl$renderTable()</strong> line renders the updated table with the formatted cells, and it will be displayed in the R <span class="No-Break">environment again.</span></p>
			<p>To summarize, the preceding<a id="_idIndexMarker317"/> R code imports a package, creates a dataset of random<a id="_idIndexMarker318"/> numbers, generates<a id="_idIndexMarker319"/> a table with formatted<a id="_idIndexMarker320"/> data, displays the table, applies conditional formatting to specific cells, and finally displays the table again with the formatted cells. Conditional formatting assigns different background colors to cells based on the values in the <span class="No-Break">specified columns.</span></p>
			<p>Now, let’s look at what we created. Remember that the data may be different for you as the values are random. First, we will look at the plain table, and then the <span class="No-Break">styled table:</span></p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/B19142_05_3.jpg" alt="Figure 5.3 –  BasicTable R6 plain table"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 –  BasicTable R6 plain table</p>
			<p>The following is the styled table according to the logic created in the <span class="No-Break"><strong class="source-inline">mapStyling()</strong></span><span class="No-Break"> function:</span></p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/B19142_05_4.jpg" alt="Figure 5.4 – BasicTable R6 styled table"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – BasicTable R6 styled table</p>
			<p>Now that we have made<a id="_idIndexMarker321"/> the tables, let’s see how we can use the <strong class="source-inline">basictabler</strong> package<a id="_idIndexMarker322"/> to save them to an Excel file. First, we are going<a id="_idIndexMarker323"/> to rely on a package<a id="_idIndexMarker324"/> that was introduced earlier: <strong class="source-inline">openxlsx</strong>. </p>
			<p>Here’s the script we are going to use; you will notice that the <strong class="source-inline">chapter5</strong> directory has been used as it was <span class="No-Break">created first:</span></p>
			<pre class="source-code">
# Write styled table out to Excel
library(openxlsx)
# Create Workbook
wb &lt;- createWorkbook()
# Add a sheet called Data
addWorksheet(wb, "Data")
# Use basictabler to write the tbl to excel
tbl$writeToExcelWorksheet(
  wb = wb,
  wsName = "Data",
  topRowNumber = 1,
  leftMostColumnNumber = 1,
  applyStyles = TRUE
  )
# Use openxlsx to save the file
saveWorkbook(
  wb,
  file="chapter5/basictabler_excel.xlsx",
  overwrite = TRUE
)</pre>			<p>Here, we used the public method of <strong class="source-inline">writeToExcelWorksheet()</strong> from the <strong class="source-inline">basictabler</strong> package. While it does not directly write to an Excel file, it does get the object into<a id="_idIndexMarker325"/> a format that can<a id="_idIndexMarker326"/> be written to Excel<a id="_idIndexMarker327"/> using a package<a id="_idIndexMarker328"/> such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">openxlsx</strong></span><span class="No-Break">.</span></p>
			<p>Now that you’ve learned about some of the possibilities to write in R, let’s have a look at similar tools in Python. Once again, we will go over how to format cells and tables for Excel. For more details, you can take a look at so<a id="_idTextAnchor104"/>me extra packages, such as <strong class="source-inline">gt</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">gtextras</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor105"/>Advanced options for formatting with Python</h1>
			<p>The Python section of this chapter<a id="_idIndexMarker329"/> is organized into the following <span class="No-Break">three sections:</span></p>
			<ul>
				<li><em class="italic">Cell formatting</em>: Cell formatting is crucial for presenting<a id="_idIndexMarker330"/> data in a visually appealing and organized manner. We will demonstrate how to apply various formatting styles to cells, such as setting font properties (for example, size, color, bold, and italic), adjusting cell background colors, and aligning text within cells. You will learn how to create professional-looking tables with well-formatted cells that enhance <span class="No-Break">data readability.</span></li>
				<li><em class="italic">Conditional formatting</em>: Conditional formatting allows you to dynamically<a id="_idIndexMarker331"/> format cells based on specific conditions. We will walk you through the process of applying conditional formatting to highlight important data points, visualize trends, and identify outliers. You will discover how to use <strong class="source-inline">pandas</strong> and <strong class="source-inline">openpyxl</strong> to implement various conditional formatting rules, such as color scales, data bars, and icon sets, making your data stand out in the <span class="No-Break">Excel sheet.</span></li>
				<li><em class="italic">Pivot tables</em>: Pivot tables are powerful tools<a id="_idIndexMarker332"/> for summarizing and analyzing data in Excel. We will show you how to create pivot tables using <strong class="source-inline">pywin32</strong>, as well as how to adjust subtotals and grand totals and customize labels <span class="No-Break">and styles.</span></li>
			</ul>
			<p>Throughout this chapter, we will provide practical examples and detailed explanations to guide you through the process of formatting your Excel sheets effectively. By mastering cell formatting, conditional formatting, and pivot tables, you will be able to present your data professionally and make it visually compelling, facilitating better insights and <span class="No-Break">data an<a id="_idTextAnchor106"/>alysis.</span></p>
			<p>Let’s get started with <span class="No-Break">cell formatting!</span></p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor107"/>Cell formatting</h2>
			<p>Cell formatting is a crucial aspect<a id="_idIndexMarker333"/> of presenting data effectively in Excel. With <strong class="source-inline">pandas</strong> and <strong class="source-inline">openpyxl</strong>, you have<a id="_idIndexMarker334"/> powerful tools at your disposal to customize the appearance of cells. You can apply a wide range of formatting styles to make your tables visually appealing and enhance <span class="No-Break">data readability.</span></p>
			<p>To get started with cell formatting, you will learn how to set various font properties, such as font size, color, boldness, and italics. These adjustments allow you to emphasize certain data points and create a consistent visual hierarchy in <span class="No-Break">your tables.</span></p>
			<p>Additionally, you can control the background color of cells to group related data or highlight specific values. By setting cell background colors, you can create clear demarcations between different sections of your table, making it easier for readers to interpret <span class="No-Break">the data.</span></p>
			<p>Aligning text within cells is another important formatting technique. With <strong class="source-inline">pandas</strong> and <strong class="source-inline">openpyxl</strong>, you can align text horizontally and vertically, ensuring that your data is presented in a tidy and <span class="No-Break">organized manner.</span></p>
			<p>In this section, we will walk you through practical examples of cell formatting using both <strong class="source-inline">pandas</strong> and <strong class="source-inline">openpyxl</strong>. You will learn how to apply different formatting styles, adjust font properties, change cell background colors, and align text within cells. Armed with these skills, you will be able to create professional-looking tables that eff<a id="_idTextAnchor108"/>ectively convey your data’s message <span class="No-Break">and insights.</span></p>
			<h3>Setting font properties</h3>
			<p>Let’s start by exploring<a id="_idIndexMarker335"/> how to set font properties<a id="_idIndexMarker336"/> for cells using both <strong class="source-inline">pandas</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">openpyxl</strong></span><span class="No-Break">.</span></p>
			<p>In <strong class="source-inline">pandas</strong>, for more advanced styling, including custom CSS-like styles, we can use the <strong class="source-inline">Styler.apply</strong> method, along with custom functions to format the cells, to apply the font properties to suit our preferences, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
# import pandas
import pandas as pd
data = {'Name': ['John', 'Alice', 'Michael'],
        'Age': [25, 30, 22],
        'City': ['New York', 'London', 'Paris']}
df = pd.DataFrame(data)
# Define a function to apply font properties
def apply_font_properties(value):
    return 'font-weight: bold; font-size: 14px; font-style: italic; color: blue'
# Applying font properties
styled_df = df.style.applymap(apply_font_properties, subset='Name')
# Save the styled DataFrame to an Excel file
styled_df.to_excel('styled_table_pandas.xlsx', index=False)</pre>			<p>The resulting Excel sheet<a id="_idIndexMarker337"/> is available in this chapter’s <span class="No-Break">GitHub</span><span class="No-Break"><a id="_idIndexMarker338"/></span><span class="No-Break"> repository.</span></p>
			<p>In <strong class="source-inline">openpyxl</strong>, you can use the <strong class="source-inline">Font</strong> class to set font properties. For instance, to make text bold, you can set the <strong class="source-inline">bold</strong> attribute of the font object to <strong class="source-inline">True</strong>. You can also adjust other font properties, such as <strong class="source-inline">size</strong> and <strong class="source-inline">color</strong>, to achieve the desired formatting. Refer to the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
# OpenPyXL example for setting font properties
from openpyxl import Workbook
from openpyxl.styles import Font
wb = Workbook()
ws = wb.active
# Applying font properties
font = Font(size=14, bold=True, italic=True, color='0000FF')
ws['A1'].font = font
ws['A1'] = 'Name'
ws['B1'] = 'Age'
ws<a id="_idTextAnchor109"/>['C1'] = 'City'
wb.save('styled_table_openpyxl.xlsx')</pre>			<h3>Cell background colors</h3>
			<p>Changing the background color of cells<a id="_idIndexMarker339"/> is another formatting<a id="_idIndexMarker340"/> technique that can help you visually distinguish different parts of your table. In <strong class="source-inline">pandas</strong>, you can set the <strong class="source-inline">background-color</strong> CSS style using the <strong class="source-inline">Styler</strong> object, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
# Pandas example for cell background colors
import pandas as pd
data = {'Name': ['John', 'Alice', 'Michael'],
        'Age': [25, 30, 22],
        'City': ['New York', 'London', 'Paris']}
df = pd.DataFrame(data)
# Create a styler object
styled_df = df.style
# Define the style for the cells
styled_df = styled_df.applymap( \
    lambda _: 'background-color: yellow', \
    subset=pd.IndexSlice[0, ['Name', 'Age']])
# Save the styled DataFrame to an Excel file
styled_df.to_excel('colored_table_pandas.xlsx', index=False)</pre>			<p>The preceding code demonstrates how to use <strong class="source-inline">pandas</strong> to create a <strong class="source-inline">DataFrame</strong> containing some sample data and then apply cell background colors to specific cells in the <strong class="source-inline">DataFrame</strong>. The <strong class="source-inline">DataFrame</strong> contains information about individuals’ names, ages, and cities. By using the <strong class="source-inline">pandas</strong> <strong class="source-inline">Styler</strong> object, we can define the background color for specific cells. In this example, the first row’s <strong class="source-inline">Name</strong> and <strong class="source-inline">Age</strong> columns are highlighted with a yellow background color. Finally, the styled <strong class="source-inline">DataFrame</strong> is saved to an Excel file named <strong class="source-inline">colored_table_pandas.xlsx</strong>. This technique allows for easy and flexible cell formatting when exporting data from Python <span class="No-Break">to Excel.</span></p>
			<p>Now, let’s have a look at how we can achieve something similar <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">openpyxl</strong></span><span class="No-Break">!</span></p>
			<p>In <strong class="source-inline">openpyxl</strong>, you can set<a id="_idIndexMarker341"/> the background<a id="_idIndexMarker342"/> color of cells using the <strong class="source-inline">Fill</strong> class, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
# openpyxl example for cell background colors
from openpyxl import Workbook
from openpyxl.styles import PatternFill
wb = Workbook()
ws = wb.active
# Applying cell background colors
yellow_fill = PatternFill(start_color='FFFF00', end_color='FFFF00', fill_type='solid')
ws['A1'].fill = yellow_fill
ws['A1'] = 'Name'
ws['B1'] = 'Age'<a id="_idTextAnchor110"/>
ws['C1'] = 'City'
wb.save('colored_table_openpyxl.xlsx')</pre>			<h3>Aligning text within cells</h3>
			<p>Properly aligning text within<a id="_idIndexMarker343"/> cells can significantly improve<a id="_idIndexMarker344"/> the table’s visual presentation. In <strong class="source-inline">pandas</strong>, you can use the <strong class="source-inline">Styler</strong> object to apply text <span class="No-Break">alignment styles:</span></p>
			<pre class="source-code">
# Pandas example for aligning text within cells
import pandas as pd
data = {'Name': ['John', 'Alice', 'Michael'],
        'Age': [25, 30, 22],
        'City': ['New York', 'London', 'Paris']}
df = pd.DataFrame(data)
# Applying text alignment
alignment_styles = {'text-align': 'center'}
styled_df = df.style.set_properties( \
    subset=['Name', 'Age', 'City'], **alignment_styles)
styled_df.to_excel('aligned_table_pandas.xlsx', index=False)</pre>			<p>With this code, the text in the specified columns of the <strong class="source-inline">DataFrame</strong> will be aligned to the center. This code uses the <strong class="source-inline">set_properties</strong> method to apply the text alignment to the specified columns. The resulting <strong class="source-inline">DataFrame</strong> is then saved to an Excel file <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">aligned_table_pandas.xlsx</strong></span><span class="No-Break">.</span></p>
			<p>In <strong class="source-inline">openpyxl</strong>, you can set text alignment using the <strong class="source-inline">Alignment</strong> class, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
# OpenPyXL example for aligning text within cells
from openpyxl import Workbook
from openpyxl.styles import Alignment
wb = Workbook()
ws = wb.active
# Applying text alignment
alignment = Alignment(horizontal='center', vertical='center')
ws['A1'].alignment = alignment
ws['A1'] = 'Name'
ws['B1'] = 'Age'
ws['C1'] = 'City'
wb.save('aligned_table_openpyxl.xlsx')</pre>			<p>With these examples, you have learned how to customize cell formatting, set font properties, change cell background colors, and align text within cells using both <strong class="source-inline">pandas</strong> and <strong class="source-inline">openpyxl</strong>. By utilizing these formatting<a id="_idIndexMarker345"/> options, you can create visually appealing and informative tables to present<a id="_idIndexMarker346"/> your data effectively <span class="No-Break">in Excel<a id="_idTextAnchor111"/>.</span></p>
			<p>Now, we continue our deep dive with <span class="No-Break">conditional formatting.</span></p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor112"/>Conditional formatting</h2>
			<p>Conditional formatting is a powerful feature<a id="_idIndexMarker347"/> in Excel that allows you to automatically<a id="_idIndexMarker348"/> apply formatting to cells based on specific conditions. It enables you to visually highlight important data, identify trends, and make your Excel sheets more interactive. In this chapter, we will explore how to implement conditional formatting using <strong class="source-inline">openpyxl</strong>. We’ll cover various scenarios, such as highlighting cells based on value ranges, text, and date criteria. Additionally, we’ll demonstrate how to create custom conditional formatting rules to suit your <span class="No-Break">specific needs.</span></p>
			<p>By the end of this chapter, you’ll have the skills to add dynamic and visually appealing conditional formatting<a id="_idIndexMarker349"/> to your Excel sheets directly from Python. Let’s dive in and le<a id="_idTextAnchor113"/>arn how to make your data stand<a id="_idIndexMarker350"/> out with <span class="No-Break">conditional formatting!</span></p>
			<h3>Visualizing data with conditional formatting</h3>
			<p>By applying conditional formatting<a id="_idIndexMarker351"/> to your Excel sheets, you can<a id="_idIndexMarker352"/> effectively visualize your data and gain valuable insights at a glance. For example, you can highlight the highest and lowest values in a column, color cells based on specific categories, or emphasize significant changes <span class="No-Break">over time.</span></p>
			<p>Conditional formatting is particularly useful when dealing with large datasets as it allows you to quickly identify key information and make <span class="No-Break">data-driven decisions.</span></p>
			<p><strong class="source-inline">openpyxl</strong> provides functionalities to implement conditional formatting in Excel sheets. The library offers a range of options to apply different formatting styles based on specific conditions. The process of using <strong class="source-inline">openpyxl</strong> for conditional formatting involves the <span class="No-Break">following steps:</span></p>
			<ol>
				<li>Import the required modules from <strong class="source-inline">openpyxl</strong> and load your data into a <span class="No-Break">workbook object.</span></li>
				<li>Create a conditional formatting rule <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">openpyxl.formatting.rule</strong></span><span class="No-Break">.</span></li>
				<li>Define the rule’s conditions, such as applying styles based on cell values, text, or <span class="No-Break">date criteria.</span></li>
				<li>Apply the rule to the desired range of cells <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">openpyxl.worksheet.conditional.ConditionalFormatting.add()</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p>With <strong class="source-inline">openpyxl</strong>, you can easily implement conditional formatting rules and add visual cues to your Excel sheets, enhancing the presentation of your data and facilitating <span class="No-Break">data analysis.</span></p>
			<p>Let’s have a look at some code <a id="_idIndexMarker353"/>that implements the <span class="No-Break">preceding</span><span class="No-Break"><a id="_idIndexMarker354"/></span><span class="No-Break"> concepts:</span></p>
			<pre class="source-code">
import pandas as pd
import openpyxl
from openpyxl.formatting.rule import ColorScaleRule, CellIsRule
# Create some sample data
data = {'Name': ['John', 'Alice', 'Michael', 'Emily'],
        'Age': [25, 30, 22, 28],
        'City': ['New York', 'London', 'Paris', 'Sydney'],
        'Sales': [1000, 800, 1200, 900]}
df = pd.DataFrame(data)
# Write the DataFrame to a worksheet
df.to_excel("conditional_formatting.xlsx", index=False)
# Load the workbook
wb = openpyxl.load_workbook('conditional_formatting.xlsx')
ws = wb.active
# Define conditional formatting rule for red text
red_text_rule = CellIsRule( \
    operator="lessThan", formula=["1000"], stopIfTrue=True, \
    font=openpyxl.styles.Font(color="FF0000"))
ws.conditional_formatting.add(f"D2:D{len(df)+1}", red_text_rule)
# Define the condition for the green fill color scale
min_sales = min(df['Age'])
max_sales = max(df['Age'])
green_fill_rule = ColorScaleRule( \
    start_type='num', start_value=min_sales, start_color='0000FF00', \
    end_type='num', end_value=max_sales, end_color='00FFFF00')
ws.conditional_formatting.add(f"B2:B{len(df)+1}", green_fill_rule)
# Save the Excel workbook
wb.save('conditional_formatting.xlsx')</pre>			<p>In this code, we create an Excel workbook from a <strong class="source-inline">pandas</strong> <strong class="source-inline">DataFrame</strong>. Then, we define two conditional formatting rules: red text if the <strong class="source-inline">Sales</strong> value is less than <strong class="source-inline">1000</strong> while <strong class="source-inline">green_fill_rule</strong> uses the minimum and maximum age values from the <strong class="source-inline">Age</strong> column to set up the color scale condition. This way, the cells in the <strong class="source-inline">Age</strong> column will be filled with green colors based on their relative values within the minimum and maximum values. These rules are added to the worksheet’s <strong class="source-inline">conditional_formatting</strong> property. Finally, we save the Excel workbook, and conditional formatting will be applied when you open the Excel file with <span class="No-Break">Microsoft Excel.</span></p>
			<p>Custom conditional formatting<a id="_idIndexMarker355"/> rules provide you with precise control <a id="_idIndexMarker356"/>over how your data is displayed, making it easier to identify patterns, trends, and outliers in your <span class="No-Break">Excel sheets.</span></p>
			<p>Next, we’ll cover a case <a id="_idTextAnchor114"/>study where conditional formatting can really shine: a <span class="No-Break">dynamic heatmap!</span></p>
			<h3>Case study – using a dynamic heatmap with conditional formatting</h3>
			<p>To further demonstrate the power<a id="_idIndexMarker357"/> of conditional formatting, we’ll walk<a id="_idIndexMarker358"/> through a case study where we create a dynamic heatmap using Python and Excel. We’ll use conditional formatting to color cells in the heatmap based on the data’s magnitude, enabling us to visualize the data’s intensity<a id="_idIndexMarker359"/> and patterns effectively. What’s created here is also called a <strong class="bold">highlight table</strong>, given there is an annotation (numbers) in the table and not just the <span class="No-Break">heatmap colors.</span></p>
			<p>Let’s have a look at the implementation of such <span class="No-Break">a heatmap:</span></p>
			<pre class="source-code">
import pandas as pd
import openpyxl
from openpyxl.utils.dataframe import dataframe_to_rows
from openpyxl.formatting.rule import ColorScaleRule
# Sample data for the heatmap
data = {
    'Category': ['A', 'B', 'C', 'D'],
    'Jan': [10, 20, 30, 40],
    'Feb': [15, 25, 35, 45],
    'Mar': [12, 22, 32, 42],
    'Apr': [18, 28, 38, 48]
}
# Convert data to a pandas DataFrame
df = pd.DataFrame(data)
# Write the DataFrame to a worksheet
df.to_excel("heatmap_with_conditional_formatting.xlsx", index=False)
# Load the workbook
wb = openpyxl.load_workbook( \
    'heatmap_with_conditional_formatting.xlsx')
ws = wb.active
# Define the range for conditional formatting (excluding the 'Category' column)
data_range = f'B2:E{len(df) + 1}'  # Adjust the range based on the DataFrame size
# Apply color scale conditional formatting to the range
color_scale_rule = ColorScaleRule(start_type='min', \
    start_color='FFFFFF', end_type='max', end_color='FF0000')
ws.conditional_formatting.add(data_range, color_scale_rule)
# Save the workbook
wb.save('heatmap_with_conditional_formatting.xlsx')</pre>			<p>Conditional formatting is a valuable tool for enhancing the visual representation of data in Excel. Whether you’re using <strong class="source-inline">pandas</strong> or <strong class="source-inline">openpyxl</strong>, you can easily implement conditional formatting rules to dynamically format cells based on specified conditions. By incorporating conditional formatting<a id="_idIndexMarker360"/> into your Excel sheets, you can create compelling visualizations and better understand<a id="_idIndexMarker361"/> your <a id="_idTextAnchor115"/>data, making data analysis and decision-making more efficient <span class="No-Break">and effective.</span></p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor116"/>Pivot tables</h2>
			<p>Pivot tables are powerful tools in Excel <a id="_idIndexMarker362"/>that allow you to summarize and analyze large datasets<a id="_idIndexMarker363"/> quickly. They provide a flexible way to aggregate, group, and calculate data, enabling you to gain valuable insights from your data with just a few clicks. In this section, we will explore how to create and manipulate pivot tables from Python using <strong class="source-inline">pywin32</strong>. Additionally, we will cover some techniqu<a id="_idTextAnchor117"/>es for adjusting subtotals and grand totals and customizing labels <span class="No-Break">and styles.</span></p>
			<h3>Creating pivot tables with pywin32</h3>
			<p><strong class="source-inline">pywin32</strong> allows you to interact<a id="_idIndexMarker364"/> with Microsoft Excel<a id="_idIndexMarker365"/> via the COM interface. With this library, you can control Excel’s features, including creating <span class="No-Break">pivot tables.</span></p>
			<p>To create a pivot table with <strong class="source-inline">win32com.client</strong> in Python, you can use the code snippets provided in <span class="No-Break">this section.</span></p>
			<p>First, set everything up by importing the required module, starting an Excel instance as we did in <a href="B19142_03.xhtml#_idTextAnchor055"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, and getting a sheet we can <span class="No-Break">work with:</span></p>
			<pre class="source-code">
# Import the required modules from the `win32com.client` package:
import win32com.client as win32
import os.path
# Create a new instance of Excel and make it visible:
excel = win32.Dispatch('Excel.Application')
excel.Visible = True
# Create a new workbook or open an existing one:
workbook = excel.Workbooks.Add()  # Create a new workbook
# Or to open an existing workbook:
# workbook = excel.Workbooks.Open('path/to/your/workbook.xlsx')
# Get the reference to the sheet where you want to create the Pivot Table:
sheet = workbook.ActiveSheet  # Get the active sheet
# Or specify the sheet by its name:
# sheet = workbook.Sheets('Sheet1')</pre>			<p>Next, generate some sample<a id="_idIndexMarker366"/> data and write it to the<a id="_idIndexMarker367"/> sheet (this is optional; that is, only do this if you have data <span class="No-Break">to analyze):</span></p>
			<pre class="source-code">
# Sample data
data = [
    ['Product', 'Category', 'Sales'],
    ['Product A', 'Category 1', 100],
    ['Product B', 'Category 2', 200],
    ['Product C', 'Category 1', 150],
    ['Product D', 'Category 2', 50],
    # Add more data rows here...
]
# Write the data to the sheet
for row_index, row in enumerate(data, start=1):
    for col_index, value in enumerate(row, start=1):
        sheet.Cells(row_index, col_index).Value = value</pre>			<p class="callout-heading">Fun fact</p>
			<p class="callout">You can watch the workbook populate with values when this nested <strong class="source-inline">for</strong> <span class="No-Break">loop runs!</span></p>
			<p>Now, we can start on the actual pivot table! We’ll begin by creating a new sheet where the pivot <span class="No-Break">will go:</span></p>
			<pre class="source-code">
# Add a new worksheet to the workbook to hold the Pivot Table:
pivot_table_sheet = workbook.Worksheets.Add()
pivot_table_sheet.Name = 'Pivot Table'</pre>			<p>Next, we can create<a id="_idIndexMarker368"/> the pivot table<a id="_idIndexMarker369"/> itself by using the <strong class="source-inline">Create()</strong> method of the <strong class="source-inline">PivotCaches</strong> property of the workbook and then <span class="No-Break">calling </span><span class="No-Break"><strong class="source-inline">CreatePivotTable()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
# Create a Pivot Cache using the data range (UsedRange highlights the whole used range in the sheet):
pivot_cache = workbook.PivotCaches().Create(SourceType=1, \
    SourceData=sheet.UsedRange)
# Create the Pivot Table on the new sheet using the Pivot Cache:
pivot_table = pivot_cache.CreatePivotTable( \
    TableDestination=pivot_table_sheet.Cells(3, 1), \
    TableName='MyPivotTable')</pre>			<p>With the pivot table defined, we can add the fields we want to use as row, column, and <span class="No-Break">data fields:</span></p>
			<pre class="source-code">
# Add fields to the Pivot Table, specifying their orientation (rows, columns, data, etc.):
pivot_table.PivotFields('Product').Orientation = 1 # row field
pivot_table.PivotFields('Category').Orientation = 2 # column field
pivot_table.PivotFields('Sales').Orientation = 4 # data field</pre>			<p>We’re almost there! We now<a id="_idIndexMarker370"/> have a working pivot table, but we may want to switch<a id="_idIndexMarker371"/> grand totals and subtotals on <span class="No-Break">or off:</span></p>
			<pre class="source-code">
# Control row and column grandtotals
pivot_table.ColumnGrand = False
pivot_table.RowGrand = False
# Decide which fields have Subtotals
pivot_table.PivotFields('Sales').Subtotals = [False]*12
pivot_table.PivotFields('Product').Subtotals = [False]*12
pivot_table.PivotFields('Category').Subtotals = [True]*12</pre>			<p>Finally, we can customize the labels <span class="No-Break">and styles:</span></p>
			<pre class="source-code">
# Customize labels and styles
pivot_table.ShowTableStyleRowStripes = True
pivot_table.PivotFields('Product').Caption = 'Product Name'
pivot_table.PivotFields('Sales').NumberFormat = '#,##0'
pivot_table.PivotFields('Sales').Caption = 'Total Sales'
# Note: labels change the Pivot Table wizard available when clicking into the Pivot Table, not the table itself.
# Save the workbook and close Excel:
 # Note: you will want to change the path to a path that exists on your computer.
file_path = os.path.join('C:' + os.sep, 'Users', 'david_1q5aypk', 'Extending-Excel-with-Python-and-R')
workbook.SaveAs(os.path.join(file_path, 'pivot_table.xlsx'))
workbook.Close()
excel.Quit()</pre>			<p>With that, you’ve learned how to create a pivot table in Excel using <strong class="source-inline">win32com.client</strong>, enabling you to analyze<a id="_idIndexMarker372"/> and summarize your data effectively. The library allows you to have full control<a id="_idIndexMarker373"/> over Excel, including creating and customizing pivot tables based on your specific data <span class="No-Break">analysis needs.</span></p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor118"/>Summary</h1>
			<p>In this chapter, we delved into the art of formatting Excel sheets to present data in a visually appealing and organized manner. Divided into three sections, we covered essential techniques to transform raw data into professional-looking tables that enhance <span class="No-Break">data readability.</span></p>
			<p>The first section focused on cell formatting, where we demonstrated how to apply various styles to cells, such as adjusting font properties, cell backgrounds, and text alignment. By mastering cell formatting, you can create well-organized and visually <span class="No-Break">appealing tables.</span></p>
			<p>Next, we explored conditional formatting, a powerful feature that allows you to dynamically format cells based on specific conditions. We provided practical examples of using <strong class="source-inline">styledTables</strong> and <strong class="source-inline">basictabler</strong> for R and then <strong class="source-inline">pandas</strong> and <strong class="source-inline">openpyxl</strong> for Python to implement various conditional formatting rules, such as color scales, data bars, and icon sets, making your data stand out and revealing <span class="No-Break">critical insights.</span></p>
			<p>Lastly, we unlocked the potential of pivot tables, which are indispensable tools for summarizing and analyzing data. Using <strong class="source-inline">pywin32</strong>, we created pivot tables and learned how to adjust subtotals and grand totals, as well as customize labels <span class="No-Break">and styles.</span></p>
			<p>Throughout this chapter, you’ve gained valuable skills in Excel manipulation using <strong class="source-inline">styledTables</strong>, <strong class="source-inline">basictabler</strong>, <strong class="source-inline">pandas</strong>, <strong class="source-inline">openpyxl</strong>, and <strong class="source-inline">pywin32</strong>, thus enabling you to present your data professionally, make it visually compelling, and uncover meaningful insights for more informed decision-making. With these techniques at your disposal, you are well-equipped to excel in data analysis and visualization, taking your Excel proficiency to <span class="No-Break">new heights.</span></p>
			<p>Stay tuned for the next chapter, <em class="italic">Inserting ggplot2/matplotlib Graphs</em>! There, you will learn how to add beautiful data visualizations to your Excel sheets using R <span class="No-Break">and Python.</span></p>
		</div>
	</body></html>