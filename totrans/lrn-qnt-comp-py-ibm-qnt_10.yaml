- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppressing and Mitigating Quantum Noise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous edition of this book, you may recall a chapter which discussed,
    in a reasonable amount of detail, the different types of noise that affect various
    quantum systems. Since then, there has been an incredible amount of research that
    has evolved not only the hardware but the software as well. Due to the changes
    since then, which includes a few major refactorization iterations of Qiskit, for
    example, the deprecation of Ignis and its many test circuit libraries, I thought
    it might be a good time to shift into the latest and not spend too much time on
    how to test a system, but rather understand how to leverage the latest error suppression
    and mitigation techniques. Of course, I don’t want to leave you too far in the
    dark, so I will cover some of the fundamentals of what these noises are and how
    they affect your experiments. However, I do want to ensure we cover the current
    era of quantum utility ([https://www.nature.com/articles/s41586-023-06096-3](https://www.nature.com/articles/s41586-023-06096-3)),
    which entails using error suppression and mitigation techniques to help you find
    some useful quantum applications. We should expect to see some advancements as
    the systems evolve and get wider (more qubits) and deeper (complex quantum circuits
    with thousands of 2-qubit gates), which can be seen as a great step towards useful
    quantum applications without needing to wait for fault-tolerant quantum computers.
  prefs: []
  type: TYPE_NORMAL
- en: Early quantum systems were commonly referred to as near-term devices, which
    generally means they are close to becoming fully fault-tolerant quantum systems.
    One of the reasons for this is that all current quantum systems, no matter what
    technology they use to create qubits, are affected by **noise** in some shape
    or form, which increases the error rates of these systems. To address, and in
    turn minimize the error rates, it helps to understand what causes these errors
    and how can we suppress or mitigate them. Keep in mind that the study of errors
    in any one of the following examples could easily qualify as a research topic,
    which is why we will simply touch on some examples but if you are interested in
    more details, I will provide some reference materials at the end of the chapter.
    For now, this chapter is merely an overview with some examples to help you get
    an idea on how to create some of these noise models using the functionalities
    provided to you in Qiskit and how to suppress and mitigate against them using
    features included in the Qiskit Runtime. The goal here is to help you optimize
    the effectiveness of your quantum circuits, which in turn helps you design your
    applications to be as resistant as possible to the various forms of errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Qiskit Runtime Service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Sessions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Qiskit Runtime Options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Primitives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Sampler primitive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the noise effects of decoherence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Differences between error suppression, mitigation, and correction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover one of the challenges faced by most quantum
    systems: noise. By the end of the chapter, you will understand some of the varying
    noise effects, such as relaxation and dephasing. Then, you’ll get an overview
    of the latest advancements in the Qiskit Runtime Service and learn about the building
    blocks to run your circuits efficiently on any backend system. Finally, you will
    learn about the error suppression and error mitigation techniques and how to apply
    them to your complex quantum circuits.'
  prefs: []
  type: TYPE_NORMAL
- en: In previous versions of Qiskit, there was a module titled, Ignis, which was
    the module that contained libraries to characterize and mitigate against noise.
    Since then, the Ignis library has been deprecated, so it is recommended that you
    read the Qiskit Migration Guide on the Qiskit GitHub page ([https://github.com/Qiskit/qiskit-ignis#migration-guide](https://github.com/Qiskit/qiskit-ignis#migration-guide)),
    particularly if you want to use many of the recent advancements.
  prefs: []
  type: TYPE_NORMAL
- en: 'In quantum systems, noise originates from various sources: thermal heat from
    electronics, decoherence, dephasing, crosstalk, or signal loss. Here, we will
    see how to measure the effects of noise on a **qubit**, and how to mitigate readout
    error noise to optimize our results. In the end, we will compare the differences
    to better understand the effects and ways to mitigate them using other techniques
    such as **dynamical decoupling**, which is used to help reduce noise caused by
    decoherence of a qubit when its state is left idle for too long.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get started with all of that, we need to first get familiar with
    one of the newest features that will help bring all these techniques to our fingertips
    and allow us to adjust them all as needed: the Qiskit Runtime service.'
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will cover some refreshers on simulating noise, so if you
    have some knowledge of signal to noise theory, this will help. If not, review
    *Chapter 9*, *Simulating Quantum Systems and Noise Models*, to get an understanding
    of the various forms of noise that affect quantum systems. This will help you
    understand how to suppress and mitigate errors on a quantum computer using the
    Qiskit Runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the full source code used throughout this book: [https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition](https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Qiskit Runtime service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For those of you who have used earlier versions of Qiskit, you may have been
    using the `execute()` or `backend.run()` functions to run quantum circuits on
    a quantum system. This was good to run some basic quantum circuits for learning
    purposes on small quantum systems with less than 100 qubits. However, if we want
    to start to think about the future and how we can create circuits for hundreds,
    thousands, and even millions of qubits, then we will need to think about how to
    optimally do so without just throwing a large circuit onto a single machine. This
    is where the **Qiskit Runtime Service** comes in very handy. Not only does it
    include many new options, such as selecting the optimization and resilience levels,
    which we will learn about later in this chapter, but it also includes all the
    transpilation features we covered earlier, so we won’t necessarily lose what we
    have learned so far. In this section, we will cover what the Qiskit Runtime is
    and how you can execute your circuits using it. Knowing how to use the Qiskit
    Runtime will also help you later in this chapter, when we learn about the various
    error suppression and mitigation techniques and how they are applied to your quantum
    circuit.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin by learning more about the Qiskit Runtime Service, how is it different
    from the execute function, and what new features we can use to optimize executing
    our quantum circuits on a quantum system.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s create a new notebook and import a few Qiskit Runtime objects,
    functions, and instantiate the `QiskitRuntimeService` class, using our helper
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Note, at the time of writing, there has been a switch from the current Sampler
    version to SamplerV2\. In the following code, it is assumed that the “V2” will
    be removed. If for some reason it is not, then please update `Sampler` to `SamplerV2`
    to ensure you are using the latest version of the Sampler.
  prefs: []
  type: TYPE_NORMAL
- en: Another important step is that you must use the `token` parameter to set either
    your IBM Quantum or IBM Cloud API token, as illustrated in the following code
    snippet. If you do not set this, you will likely get an error, and when trying
    to access the Qiskit Runtime service, it will not work.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have your notebook setup, let’s dig into some of the execution
    mode descriptions..
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Sessions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **Session** is in essence a collection of Jobs that is guaranteed to run
    on the backend without any interruptions from other user Jobs, particularly those
    that require multiple iterations, such as those that are based on variational
    algorithms: **Variational Quantum Eigensolver** (**VQE**), and **Quantum Approximate
    Optimization Algorithm** (**QAOA**). In other words, “without interruptions” means
    that the Qiskit Runtime will ensure that each Job will complete, including the
    period where the variables are being adjusted between classical and quantum resources,
    where in the past this time was used to interleave Jobs from another user in the
    queue.'
  prefs: []
  type: TYPE_NORMAL
- en: To understand the practicality of this format, imagine standing in a long queue
    waiting your turn to submit a form, like renewing your driver’s license. After
    waiting a few hours, you’re finally at the window and handing over your form,
    only to be told that you need to adjust some values in the form. This is where
    the difference comes in. In the previous version, you would have to stand off
    to the side and update the form fields; meanwhile, someone else will move up to
    the window. Now, if you happen to be ready, you now must wait for that other person
    to finish before you can continue. This, of course, might take a long time, causing
    you to wait longer. What Sessions allows you to do is keep that window free and
    available for you until you finish updating the form and then turn it in.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding what the default and max times are for both the interactive and maximum
    time values, I would refer you to the Qiskit Runtime documentation [https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/runtime_service](https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/runtime_service)
    ) as these values might change over time. However, time in the queue does count
    towards the maximum time of the Session. The idle time could be used to perform
    any classical operations based on the results of the Job and/or prepare for the
    subsequent Job in the Session.
  prefs: []
  type: TYPE_NORMAL
- en: Each Job can be set as part of a batch of Jobs to ensure that they run on the
    same device or closely together to avoid the issues that can occur if they are
    run on separate systems or far apart, which would introduce strangeness to our
    results due to device characteristics or device drift. To learn more about device
    drift, see the *Further reading* section at the end of this chapter. At the time
    of writing, there are upcoming features that will further optimize execution of
    circuits, so do keep an eye on the documentation and information feeds for details
    and examples.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start coding, let’s get familiar with the other classes first as this
    will simplify our coding experience moving forward. In the next section, we will
    look at the options that we can set to our `Session` class. The `Options` class
    will also be very important later when suppressing and mitigating errors.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Qiskit Runtime Options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`RuntimeOptions` is a class used to set the various parameters for the Qiskit
    Runtime execution options. Parameters are used to select which quantum system
    to use and which optimization or resilience levels to use that enable various
    error suppression or error mitigation features. Below is a list of `Options` parameters
    that are used for the various Qiskit Runtime primitives. Keep in mind that, as
    always, you should check the latest version of Qiskit API documentation to ensure
    your code is always current:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Environment parameters such as `log_level` (`DEBUG`, `INFO`, etc.), and `callback`
    for any interim or final results, which will receive two positional parameters:
    Job ID and Job result'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execution parameters for execution time options, such as number of `shots(int)`,
    and `init_qubits(bool)`, which will reset the qubits to the ground state for each
    shot the (default is `true`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max_execution_time` is the maximum time, in seconds, after which a job is
    canceled. If this is not set, the default will be the time limit of the Primitive.
    If it is set, then the time must be set between 300 seconds and the maximum execution
    time set for the simulator or device, which can be found in the Qiskit API documentation:
    [https://docs.quantum.ibm.com/guides/max-execution-time](https://docs.quantum.ibm.com/guides/max-execution-time).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`optimization_level` sets the level of optimization to the circuit. The higher
    the level, the more optimal and therefore longer the transpilation time. These
    optimization levels also include error suppression such as dynamical decoupling,
    which we will cover later in this chapter. There are four `optimization_level`
    settings. The default value is set to the highest, `3`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0 – no optimization, uses basic translation, whichever layout is specified,
    and routing (uses stochastic swaps by default)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 – light optimization, routing (uses SabreSWAP, 1Q gate optimization, and dynamical
    decoupling for error suppression)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 – medium optimization, layout and routing are the same as level 1, but includes
    heuristic optimization with a greater search depth and trials of optimization
    and dynamical decoupling for error suppression
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 3 – high optimization, layout and routing are the same as level 2 and include
    further optimization with greater efforts/trials, 2-qubit KAK optimization, and
    dynamical decoupling for error suppression
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resilience_level` sets the level of resilience to mitigate errors. The higher
    the resilience level, the higher the accuracy of your results. Higher results
    are like that of the optimization level where it will cause longer transpilation
    time. These resilience levels range from 0 to 2, where level 1 is the default
    value and is only available for the Estimator primitive. It is important to note
    that as the technology evolves, so does the implementation and mitigation of these
    techniques. Please refer to the latest documentation to ensure your code is running
    the latest version ([https://docs.quantum.ibm.com/guides/configure-error-mitigation](https://docs.quantum.ibm.com/guides/configure-error-mitigation)
    ).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0 – no mitigation.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 – (default) minimal mitigation, which minimizes readout errors. The Estimator
    primitive uses the Twirled Readout Error Extinction.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 – medium mitigation, used to minimize bias in a circuit but indicates that
    it is not guaranteed to be zero, using the same as level 1 and includes Zero Noise
    Extrapolation.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we’re familiar with all the options we can set to optimize and run
    circuits on our backend systems, let’s continue to move forward and learn what
    the Primitive classes are all about.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Primitives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Primitives**, as defined on the Qiskit documentation, are generally the “*foundational
    building blocks for designing and optimizing quantum workloads*.” At the time
    of writing, there are two primitives within the Qiskit Runtime: **Sampler** and
    **Estimator**. Each of these provides a simple way to encapsulate your circuit
    and leverage each of its features to optimize workloads during execution to optimize
    running them on multiple quantum systems at scale. If you recall in the previous
    chapters, when we built and applied optimization levels to our circuit, it involved
    quite a bit of work, and the optimization was based on a single quantum system
    that we selected to run on. You can imagine the number of steps and overhead that
    would require if we needed to do that for each different system that executes
    our circuit. With the interface provided by the primitives, a lot of that is taken
    care of for us by applying a handful of option settings and selections. The runtime
    will then apply these accordingly as it selects multiple systems to execute the
    circuits. The primitives each perform a specific task and serve as the entry point
    to the Qiskit Runtime service. Let’s look at each primitive to get a little understanding
    of their functionality and the differences between them. In this chapter, we will
    focus on the Sampler primitive. The IBM Quantum Learning platform has some very
    good examples, courses, and tutorials that you can learn from in much greater
    detail than I can provide in this one chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Sampler primitive
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Sampler** primitive is similar to what we have used throughout this book
    in that it takes a quantum circuit as its input and generates a quasi-probability
    result. The result of this is also error-mitigated to ensure that the results
    are as precise as possible. Example of Sampler primitive circuits are Grover’s
    search and Deutsch-Jozsa. The Sampler can be modified to allow changes such as
    backends (local simulator or quantum system), which simplifies the management
    of your circuits and how they are run on the backend in accordance with the needs
    of your experiments. This is very helpful as each primitive has its own form of
    operating on the quantum circuit when executed on a quantum system, therefore
    certain properties or mitigating techniques will not work on some primitives based
    on the way they perform their tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Well, so far, we’ve done quite a bit of reading, why don’t we get back to some
    coding. Let’s create a new Qiskit notebook and run a simple circuit using the
    Sampler to try it out. We’ll also include the classes mentioned earlier so we
    can wrap everything together in a simple construct of a circuit.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll create a simple circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will display the following circuit that we wish to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a circuit  Description automatically generated](img/B18420_10_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: Simple circuit to run on the system'
  prefs: []
  type: TYPE_NORMAL
- en: Now, here’s where the fun starts! Let’s begin by following the Qiskit Patterns
    so we are not only ensuring that our circuits are efficient but also our development
    patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Qiskit Patterns are a 4-step process that we can use to help integrate our
    quantum computation circuits into a larger application layer. The 4 steps are
    Map, Optimize, Execute, and Post-process. We’ll go through each of these steps
    so that you can get familiar with running circuits optimally on a quantum system.
    We’ll start with what we just did: map our problem into a quantum circuit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Map'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Mapping a problem to a quantum circuit can be done in many ways. We can probably
    write volumes of books that could be dedicated to this. This is because it not
    only depends on the problem we’re trying to solve, but also how we can best map
    our input data and problem solution into a quantum state or initial state. This
    is similar to planning a trip. If I were to ask you to plan a group trip to New
    York, there could be many options and even more questions regarding how to get
    there? Where will everyone be? Are they all in the same location at the beginning
    of the trip. How long will they be available? These are similar questions we need
    to consider. How do we get the data to the quantum systems? Where is all the data,
    at that moment, and how long will the data be there? Once we have obtained the
    input data the next step is to translate it from classical information into a
    quantum state or input for our circuit. Let’s do this now with a simple example,
    the circuit we built earlier in this chapter. In *Chapter 13*, we will cover a
    more sophisticated problem, Grover’s search. For now, to allow us to focus on
    the overall process, we’ll stick with the simple circuit, and some random circuits.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have mapped a problem into a quantum state, in this case the circuit
    we constructed above. That’s step one, Map, done.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now run this circuit using a `Statevector` class to get the expected results
    before running on a quantum system. Since this is a small and simple quantum circuit,
    we can simulate this easily on a classical system such as the one you have at
    home or in your office. If the circuit or problem involved a large number of qubits
    that you would be unable to run on a classical system, then the preferred way
    to do this would be to reduce the problem size to something you can run on a classical
    system so that you can confirm the expected result at a smaller scale and then
    run on a quantum system to get the full-scale results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This will display the expected results in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph with blue bars  Description automatically generated](img/B18420_10_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: Expected probability results from the circuit using Statevector'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can prepare this to run on an actual backend. To do this, we need
    to include measurement operators in our circuit, which we will do, and then obtain
    the least busy backend system to run this circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will print out the selected backend, which is the least busy at the time
    it is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2: Optimize'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now we can prepare our circuit to run on the backend by transpiling it accordingly.
    To do this, we will use the new `preset_passmanager` function, which is a new
    addition to the Qiskit `transpiler` library that allows you to set, run, and draw
    the result of the circuit after transpilation. Aligning a circuit to a target
    backend is ideal in that it will optimize the circuit to that selected backend
    by applying not only the general passes available but also AI generated optimizers
    that introduce further improvements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This displays the transpiled circuit specific to the selected backend target.
    Here, you will note two differences from the original circuit. First, note the
    qubit mapping has changed; qubit 0 is now assigned to qubit 73\. In your case,
    depending on which system was selected, it might point to other qubits. Next,
    you’ll also note that there are more gates added. This is due to having to use
    basis gates and connectivity between qubits (using ECR gates: [https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.ECRGate](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.ECRGate)
    ) to connect between qubits that might not be adjacent to each other. Results
    might differ here as your selected backend might have different results.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a graph  Description automatically generated with medium confidence](img/B18420_10_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.3: Transpiled circuit'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to transpile a circuit and set the optimization level values,
    let’s now switch to a bit more complex circuit so we can push the optimizer further
    and see the differences between the resulting circuits. We’ll use a simple Grover
    operator to generate a circuit. Since we have not yet covered Grover’s algorithm
    in much detail, let’s ease into it and just say that we will use it to mark a
    state we wish the circuit to find. In this case, we will use the binary representation
    `110`. Grover’s algorithm will be discussed in *Chapter 13*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This will result in the following circuit, where we have a set of Hadamard gates
    followed by the Grover operator composite. Note that this is a composite that
    represents a series of gates into a single block titled Q to simplify the visualization
    of the circuit. You can run the `decompose` method a few times to break it down
    to the basis gates.
  prefs: []
  type: TYPE_NORMAL
- en: In the next steps, we will transpile it with varying optimization level values
    and compare the two so you can see the power that the `transpiler` optimizers
    have on the circuit.
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a number of squares  Description automatically generated with
    medium confidence](img/B18420_10_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.4: Grover operator circuit'
  prefs: []
  type: TYPE_NORMAL
- en: The following will highlight the difference between optimization levels with
    the complexities that accompany many circuits. To be more specific regarding the
    comparisons, we will be observing the number of **ECR** gates, which is an acronym
    for **Echoed Cross-Resonance** gate. They’re similar to CX gates but with an echoing
    procedure, which mitigates a few unwanted terms. Details on this gate can be found
    in the Qiskit Circuit Library. ECR gates, or any multi-source/multi-target gates,
    are quite complex as they require additional gates to generate connectivity. In
    this example, we will use the number of ECR gates to compare the circuits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s first capture the `Statevector` results from the current circuit so we
    can compare them to the results after transpiling and running on the quantum systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we’ll add measurement gates to this circuit and create multiple copies,
    each with varying `optimization_level` values to compare:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The result here is a transpiled version of the original Grover circuit we created.
    I have included a truncated portion of it in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a circuit  Description automatically generated with medium confidence](img/B18420_10_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.5: Transpiled Grover operator circuit (truncated)'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it is much more complex and with quite a few extra gates, including
    ECR gates.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s go through the circuit and assign a different `optimization_level`
    value for each. In this case, we’ll compare the extreme levels, one at 0, which
    is to say no optimization at all, and another at 3, which is fully optimized.
    We’ll then add it to a `circuits` array to run on a quantum system later.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will display the number of ECR gates for each circuit. Note the difference
    between the two circuits (they will vary based on system) is quite large when
    compared with no optimization (level 0) and fully optimized (level 3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have optimized our circuit by transpiling to the device with specific
    optimization levels, let’s now run both circuits and compare the results, along
    with the simulated results, on an actual quantum system.
  prefs: []
  type: TYPE_NORMAL
- en: This completes the optimize step and we move onto the next Qiskit Pattern, executing
    the optimized circuit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 3: Execute'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Here, we will now run our circuit on the targeted backend, but this time with
    a twist. We will use a new feature of the Qiskit Runtime called Batch. This will
    allow us to provide a batch of operations to run on a quantum system.
  prefs: []
  type: TYPE_NORMAL
- en: To execute the circuits we created, we will first need to create a batch, which
    is one of the execution modes of the Qiskit Runtime ([https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/qiskit_ibm_runtime.Batch](https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/qiskit_ibm_runtime.Batch)
    ), and load it up with our circuit and backend information first, then within
    the batch, we’ll run the Sampler primitive on the backend and print the results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This might take a while depending on where you are in the queue. But once it’s
    complete, you should see the following results from your experiment, which includes
    the quasi-probability results and the metadata from the experiment, in this case
    the number of shots used to obtain the results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Let’s look at the results a little deeper. First, you will see a set of `quasi_dists`.
    These are the results of the quasi-distribution from our experiments. Since we
    ran a 3-qubit circuit, we should see 8 possible results, 0-7, and the quasi-probabilities
    for each. This is then followed by some nice information on the readout overhead
    for each circuit, which is simply the time it took to read out the results for
    each circuit.
  prefs: []
  type: TYPE_NORMAL
- en: This now helps us move into the final step in the Qiskit Patterns, post-process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 4: Post-process'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this final step of the Qiskit patterns, we will extract the results from
    the quantum systems and do some post-processing. What exactly is post-processing?
    Well, simply put, it’s whatever you wish it to be. You could extrapolate the results
    and return them to the next task in your classical application to continue a particular
    hybrid classical-quantum workflow, or you can simply provide the results as an
    input to another classical or quantum computational task and continue. In this
    case, we’ll keep it simple and just display the results visually to compare them.
    We’ll compare the state vector results we computed earlier and visualize them
    in comparison to the results from the two circuits we ran on a quantum system.
    The following will display the results onto a histogram:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting plot will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph with different colored bars  Description automatically generated](img/B18420_10_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.6: Post-processed results, visualization comparison'
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see that our result is as expected, where the results from the
    optimization at the higher level, 3, are closer to our simulated results, whereas
    the results from the circuit without any optimization are less accurate.
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings us to the next topic we need to discuss: noise. All quantum systems,
    no matter the technology, have some form of noise or effect that the system has
    that is related to noise. There are some technologies that isolate qubits from
    any environmental noise; however, this also presents a disadvantage in that when
    we want to alter the state of the qubit, the speed and fidelity might take longer
    than other technologies. In this book, since we are using IBM Quantum systems,
    we will focus on superconducting qubits and the effects that noise has on them.
    We will, of course, also cover the latest advancements in both error suppression
    and error mitigation, which over time will potentially provide us with useful
    quantum applications. In the next section, we’ll begin by understanding the differences
    between the types of noise and how they affect quantum systems.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the noise effects of decoherence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned in *Chapter 9*, *Simulating Quantum Systems and Noise Models*, that
    we can generate various noise models that are based on the configuration of a
    specified quantum computer. After the configuration information is extracted,
    we can then apply any one of an array of error functions to a local simulator,
    which will reproduce similar error effects to what we would get from a quantum
    computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will expand on that to learn how these errors affect our
    circuits over time. The two effects we will review here are the two most common
    issues found in near-term quantum systems: **relaxation** and **dephasing**. These
    are critical errors as they can affect the quantum state information, which would
    result in erroneous responses.'
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, we will also look at **readout errors**, another common
    source of noise that originates when the system is applying a measurement pulse,
    while in parallel, listening in on the acquisition channel. The results and conversion
    from an analog pulse to a digital value (either 0 or 1) can introduce many errors
    as well, which we will then try and mitigate.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by learning about one of the most common and important effects
    of noise in quantum systems: **decoherence**. The three main types of decoherence
    are **T1**, **T2**, and **T2***. Each of these represents a type of decoherence
    effect on the qubit. We will begin by looking at each of them individually to
    understand the differences between them and how to suppress and mitigate against
    them when they are run on a real quantum device.'
  prefs: []
  type: TYPE_NORMAL
- en: If you are deeply interested to learn how to analyze the effects of **relaxation**
    (**T1**) and **dephasing** (**T2/T2***), *Chapter 9*, *Simulating Quantum Systems
    and Noise Models*, illustrates ways to create circuits that include noise models
    that replicate each of the three. This will help you run experiments to analyze
    the characterization of the device.
  prefs: []
  type: TYPE_NORMAL
- en: The next section provides a quick overview of both, just to get you to understand
    which of them is affected when discussing the mitigation features.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding decoherence errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'T[1], as we covered in *Chapter 9*, *Simulating Quantum Systems and Noise Models*,
    is often referred to as the **relaxation time**. Relaxation time refers to the
    time it takes the energy of a qubit to decay from the **excited state** (![](img/B18420_05_005.png))
    back down to its **ground state** (![](img/B18420_10_002.png)), as illustrated
    in the following graph, where ![](img/B18420_10_003.png) indicates the probability
    of `1`, and ![](img/B18420_10_004.png) is the probability of `0`. The T[1] time
    is defined as the value when *P(t) = 1/e* (refer to the following diagram):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – T1 defined as the decay time where the probability of the energy
    state reaches 1/e ](img/B18420_10_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.7: T1 defined as the decay time where the probability of the energy
    state reaches 1/e'
  prefs: []
  type: TYPE_NORMAL
- en: When applying this to a quantum system, if you want to determine the amount
    of time to reach T[1] for any qubit, you would need to create a test circuit that
    places the qubit in an excited state, ![](img/B18420_05_005.png). We know how
    to do this by simply applying an X gate to the qubit and then waiting a given
    amount of time before measuring that qubit. If you were to do this over a set
    number of time intervals, you will likely start to see the results switch from
    the excited state transition to the ground state.
  prefs: []
  type: TYPE_NORMAL
- en: So, what does all that mean? Let’s dig in a little bit and see how this applies
    to quantum systems over time and on complex circuits.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with a simple analogy to provide you with some intuitive understanding
    of the concepts here. For those of you who already have knowledge of these concepts,
    feel free to jump to the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine yourself just before or soon after New Year’s Eve making that same resolution
    most of us make, me included, year after year of hitting the gym and getting back
    in shape, particularly after the feasts we’ve enjoyed over the holidays. Then,
    usually on the first or second week of January, we go to the gym and our personal
    trainer takes us straight to the weights and asks us to pick a weight. Now, one
    of the things we naturally do is try to pick up where we were the last time we
    were at the gym and grab a heavy weight. Of course, at first it seems a little
    heavy, but we power on. Our trainer then wants to test our strength and asks us
    to hold the weight high over our heads with our arms extended. We then raise the
    weight confidently over our heads and we’re *excited* that this wasn’t too bad.
    Let’s call our ability to hold the weight over our heads the excited state. OK,
    so let’s now say our trainer asks us to hold it there as long as we can. What
    we will notice is that our strength can only sustain this position for some time.
    We will then begin to feel the fatigue in our muscles, which will then slowly,
    or in my case rather rapidly, start to lower down towards the original position,
    which is with the weight down close to the *ground*, where I am no longer feeling
    the strain of my muscles. Let’s call this the *relaxed* position, the ground state.
  prefs: []
  type: TYPE_NORMAL
- en: A qubit pretty much follows this concept in that it will start at a ground state,
    then sometime later we will amplify the qubit from the ground state to some excited
    state. Now, just like us, over time we will return to that ground state to relax.
    This relaxation from excited to ground state is, logically enough, called amplitude
    relaxation, which may sound familiar because we learned about this in the previous
    chapter when creating an amplitude dampening noise model to represent decoherence.
  prefs: []
  type: TYPE_NORMAL
- en: Looking back at *Figure 10.8*, you can imagine this is what the effect decoherence
    (T[1]) has on a qubit caused by its environment. What do we mean by environment?
    I’m glad you asked! A qubit isn’t just a single aluminum-niobium component with
    a Josephson Junction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Oh no, no, no, it has so much more going on! Of course, depending on the technology
    that the qubit relies on, superconducting, ion traps, photonics, etc. the qubit
    is not sitting all alone. It is usually surrounded by various environment variables
    that can interfere with and even at times speed up the decoherence of the qubit.
    Superconducting qubits, for example, must sit at a certain temperature, approximately
    15 millikelvin, to work properly and make sure that the energy levels between
    the ground and first excited state are precise to determine the state of the qubit.
    Then, the pulse sent to the qubit has to have the right amplitude, duration, frequency,
    etc. in order to place the qubit in the correct state. Keep in mind that this
    could be difficult as the quantum system might be very complex. For example, we
    defined one amplitude value as the excited state as just one position earlier
    in our example: lifting the weight over our heads. But what if we needed multiple
    amplitudes to encode our data? Then the precision of our gates will need to be
    very exact, which means that the fidelity of the gates also might influence our
    system. This is how decoherence, also referred to as the relaxation rate or T[1],
    if not suppressed, causes us to lose the quantum state information of our circuit,
    which leads to errors when we read the results of our circuits.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding dephasing errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: T[1], we learned in the previous section, refers to the decoherence or relaxation
    rate caused when the amplitude of the qubit decays over time. Dephasing errors,
    on the other hand, occur when the phase of the qubit is blurred, often referred
    to either T[2] or T[2]*. Dephasing is quite like decoherence in that we will also
    lose state information over time, only in a slightly different manner.
  prefs: []
  type: TYPE_NORMAL
- en: To define dephasing simply means to lose phase information, of a qubit in this
    case.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many different sources for dephasing noise, each of which has varying
    properties. A few examples are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**White noise**, when there is an equal amount of a signal that is of equal
    intensity at varying frequencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pink noise**, often referred to as flicker noise, occurs usually in electronic
    devices where the power density decreases with increasing frequency, i.e., 1/f,
    where f is the frequency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flux noise**, is found on the surface of **superconducting quantum interference
    devices**, commonly referred to as **SQUIDS**, the source of which are the magnetic
    spins on the surface of the SQUID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Short of converting this from a developer to an engineering book, I will include
    some references to these as well, should you want to learn more about them, at
    the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a basic understanding of noise, let’s learn what the differences
    are between error suppression, error mitigation, and error correction and how
    we can use them to create useful quantum applications.
  prefs: []
  type: TYPE_NORMAL
- en: Differences between error suppression, mitigation, and correction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we discussed some sources of errors that can be introduced
    to your quantum circuit when running them on a quantum system. Here, we will define
    the various ways to eliminate these errors from your quantum circuit to obtain
    optimal results. We’ll begin by first defining what the differences between suppressing,
    mitigating, and correcting errors.
  prefs: []
  type: TYPE_NORMAL
- en: '**Error suppression** is just as the name states, suppressing the noise of
    a given circuit so that the quantum state remains intact. The specific noise here
    could be either the decoherence time of a qubit (amplitude dampening) or dephasing.
    As we learned earlier, if a qubit is placed in a specific state and left there
    over some long period of time, that qubit will eventually return to the ground
    state, or some state that is different from the set state. What we would like
    to do here is suppress this by keeping the circuit in the current state. Of course,
    this is easier said than done. Let’s first think about this intuitively, and then
    get into the details.'
  prefs: []
  type: TYPE_NORMAL
- en: Returning to our gym scenario from earlier, let’s now assume you are lifting
    a very heavy set of weights over your chest from a laying position on the workout
    bench, bench-pressing. There is a risk here that the weight, over time, starts
    to feel heavier due to the strain your muscles are feeling. This is why you see
    most people that do this have, standing very close to the weights, a spotter.
    This is someone who helps you either when you are fatigued and need a little help,
    or helps lift the weight off your chest when your muscles just suddenly give up.
    There are many videos I’m sure you can find online where you can see the terrible
    results when there’s no spotter around, but for now, let’s elaborate on what this
    has to do with error suppression.
  prefs: []
  type: TYPE_NORMAL
- en: If you imagine that you need to sustain the weight over your head for a long
    period of time, you’ll realize that over time your muscles will strain; we aligned
    this to decoherence earlier. To help with this, your spotter can assist by gently
    helping you raise the bar back up so you can maintain your initial position, or
    state in this case. That assistance from your spotter can be seen as error suppression
    in that it helped maintain your state while not changing the state itself, meaning
    you’re not holding it any higher or lower than expected to count as a lift. Now,
    let’s get out of the gym and switch our context back to quantum and see how this
    helps us understand error suppression with respect to a quantum circuit.
  prefs: []
  type: TYPE_NORMAL
- en: When a gate or set of gates is applied to a qubit within a circuit, that circuit
    may, over some period of time, lose its state in many ways, some of which we mentioned
    earlier. What we need to do is apply a technique in which we can help the circuit
    maintain its state. Yes, this sounds like the definition of error correction,
    but let me take a moment to elaborate on that to identify the difference. To do
    that I’ll explain a new Pass (recall that a Pass is an object used to optimize
    a circuit, such as finding an optimal layout mapping, or optimal qubits) that
    was added to Qiskit called **Dynamical Decoupling** (**DD**). Dynamical decoupling
    is a well-known technique that was described back in 1998 by Dr. Seth Lloyd and
    Dr. Lorenza Viola from MIT ([https://arxiv.org/abs/quant-ph/9803057](https://arxiv.org/abs/quant-ph/9803057)
    ). They describe it as a form of using control pulses to minimize the diffusion
    of the state of the qubit. This is generally done by applying the same gate operation
    twice, which mimics an identity gate. We learned about this earlier when we explained
    that most universal quantum gates are reversible, hence by applying two reversible
    gates back-to-back, you end up with the identity gate. So, how does this work,
    you ask? I’m glad you did, here we go!
  prefs: []
  type: TYPE_NORMAL
- en: If you recall from *Chapter 7*, *Programming with Qiskit*; *Understanding pulses,
    and Pulse Library* section when we described that when running your circuit on
    a quantum computer, you must first create a pulse schedule, which is what dictates
    to the control systems the pulses to the qubits by following the pulse schedule
    in order. You may also recall that the pulse schedule includes information regarding
    the pulse, but also the duration of the pulse and the time gaps in between pulses.
    Luckily for us, we learned that all of this is done for us with the Transpiler
    and the `PassManager`. Once the pulse schedule is created to run on the specific
    quantum system, the Dynamical Decoupling Pass takes a run through it before running
    on the system. What the DD Pass looks for is idle time gaps between pulse signals,
    and it inserts a sequence of gates into those gaps. Remember that since the gates
    are reversible and we do not want to alter the state or phase of the circuit,
    it will apply a pair of gates to ensure that it sustains the action of a unitary
    gate. Let’s go to the code and see this in action to get a better idea.
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll import some of the objects and functions we need to get started.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over what we are importing here. First, from the Transpiler, we’re
    pulling in `PassManager` and `InstructionDurations`. `PassManager` is what manages
    the Passes used to optimize our quantum circuits during transpilation. `InstructionDurations`
    is basically just that; it stores the durations of all the gates, timescales (dt),
    to the selected backend system. Let’s pull the durations for a random backend
    system to try this out. Check which backends are availale as the systems may change
    over time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a truncated example of the outputs, in this case the X gates.
    Since `ibm_kyoto` is a 127-qubit device, we see that the durations shown are indexed
    to identify the duration time for the x-gate and its corresponding qubit. Note
    that the actual results will be a list of all gate durations between all qubits;
    the following is just a subset of the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Qiskit also provides you with the ability to set the durations yourself for
    each gate. This allows you to have a bit more control should you want to modify
    them for specific devices. The following illustrates how to do this for all gates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have set the following custom duration times for each gate:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gate** | **Duration** |'
  prefs: []
  type: TYPE_TB
- en: '| x | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| h | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| cx[0,1] | 200 |'
  prefs: []
  type: TYPE_TB
- en: '| cx[1,2] | 200 |'
  prefs: []
  type: TYPE_TB
- en: '| cx[2,3] | 200 |'
  prefs: []
  type: TYPE_TB
- en: '| measure | 500 |'
  prefs: []
  type: TYPE_TB
- en: 'Table 10.1: Custom gate duration times'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will visualize the circuit duration in a nice timeline. To visualize
    the circuit and its timeline, we will need to transpile the circuit using a *scheduling
    method* to a backend. A scheduling method is how the `transpiler` will schedule
    the operations to the qubits, for example, as soon as possible when the qubit
    is ready for the next instruction, or you can have it scheduled for later, which
    basically keeps the qubit in the ground state when possible. For these examples,
    we will use the **alap** scheduling method, which is an acronym for *as late as
    possible*. You can find details about the various scheduling methods in the Qiskit
    API documentation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This will print out a visual representation of the gate duration. It will look
    very much like the pulse schedule we learned about earlier; however, this is the
    circuit and not the pulse schedule. You can tell because we see the qubit labels
    on the left and not the drive
  prefs: []
  type: TYPE_NORMAL
- en: channels. Also note that CX gates have taken on the label of **ecr** in this
    case.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B18420_10_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.8: Circuit timeline visualization'
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 10.8*, this is the specified duration for each gate that
    is based on the selected backend. We will use this duration to visualize some
    of the error suppression features included in Qiskit, particularly Dynamical Decoupling.
  prefs: []
  type: TYPE_NORMAL
- en: The way Dynamical Decoupling works is that it will search for idle time in your
    circuit and insert a sequence of Dynamical Decoupling gates to those idle time
    slots to ensure that the qubit’s state is not altered. The pair of reversible
    gates used will operate equally to that of an Identity gate so that it does not
    alter the state of the circuit. Let’s use our custom duration times and a pair
    of X gates to create the Dynamical Decoupling sequence of reversible gates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: What we have defined is the pair of reversible gates that mimic an Identity
    gate. In this case, we are using a pair of X gates. Then, we instantiated our
    `PassManager`, which is what manages which Passes to use to optimize our circuit
    during the transpilation phase. In this case, we are setting the `alap` scheduling
    method and Dynamical Decoupling times to the custom duration times we created
    earlier. Also included are the reversible gates as an argument to the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we want to run our transpiled circuit through the `PassManager` we just
    created to produce the altered circuit with the Dynamical Decoupling included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s visualize this circuit and compare it to the previous circuit in
    *Figure 10.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This will draw the circuit with the error suppression of the Dynamical Decoupling
    added. You can see the X gates that have been added to the first qubit, q[0].
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B18420_10_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.9: Visualization of the Dynamical Decoupling circuit'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can observe a couple of things. First, that the gate durations are
    smaller due to the custom duration we set when compared to the previous circuit.
    Next, you will also note that the inserted X gates were added to the first qubit
    only, and not to the space after the second qubit, q[1]. This is because the idle
    time gap is shorter than that of the two X gates, therefore the gate pairs were
    not added. Let’s make a quick yet significant adjustment to the custom duration
    time to include a pair of X gates after the second qubit by increasing the duration
    from 50 to 1500\. Since we are only updating the value of one gate, we can just
    update the value of the gate without restating the other gates by using the `update()`
    function, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s retry and see what we get back this time. Here, we will set the
    parameters with the updated values and rerun the `PassManager` and visualize the
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This will now produce two sets of reversible gates, one as before, and now
    a second set, which we can see after the second qubit. Since we have reduced the
    duration time, it can now fit in the idle time gap at the end of the second qubit,
    as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B18420_10_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.10: Visualization of circuit with updated duration times'
  prefs: []
  type: TYPE_NORMAL
- en: As *Figure 10.10* illustrates, we can set the duration time of each gate. In
    this case, we increased the duration so we can see the changes. However, in many
    cases you need to reduce it to try to squeeze in our reversible gates to fill
    in the idle time gaps as needed. But, of course, like anything else, we do not
    necessarily need to do all this fine tuning ourselves. Thankfully for us, the
    Qiskit Runtime includes optimization and **resilience levels** that we can set
    to enable these features for us, as described earlier in this chapter when we
    discussed the various optimization levels we can set in the Options, which include
    enabling Dynamical Decoupling.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered an example of error suppression, let’s continue and
    look at error mitigation.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, before we begin defining what **error mitigation** is, let me cover
    what **error correction** is and how it is different. Error correction in general
    is composed of two steps: first identifying that an error has occurred and second,
    correcting that error using various error correcting techniques. Error mitigation
    on the other hand uses the errors to calculate and determine an outcome that reduces
    yet does not necessarily eliminate the error itself.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are various error mitigating techniques, and much research is still ongoing
    to find more optimal ways to reduce errors. At the time of writing, three techniques
    are used to mitigate errors that are included into the Qiskit Runtime resilience
    level options: **TREX**, **ZNE**, and **PEC**. Details regarding each are linked
    earlier in this chapter, where we defined the resilience levels. Each of these
    techniques uses classical resources to perform their tasks. This of course introduces
    overhead into our application. However, there are advances released regularly
    that reduce a lot of the overhead to optimize speed, quality, and scalability.
    By continuing to do this we can surely over time reach a level of quantum utility
    that will mean the cost to implement a complex quantum circuit may be substantially
    lower than that of classical simulations.'
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, again, Qiskit makes it easy for us to set the levels of error mitigation
    using the resilience levels to activate specific error mitigation techniques.
    In the following code snippet, we will run a circuit first without any error suppression
    or mitigation techniques, and then we will create one that will use Dynamical
    Decoupling for error suppression and TREX for error mitigation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start with no error suppression or mitigation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are as follows when running the Sampler, and you should see a visual
    representation of the results as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will enable both Dynamical Decoupling and TREX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we set the `optimization_level` to `3`, which will enable Dynamical Decoupling,
    and the `resilience_level` to `1`, which uses TREX for error mitigation. Note
    the difference in the results are much more refined and the metadata includes
    the added overhead and mitigation time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This and many other error suppression and mitigation methods are increasing
    in popularity among researchers as they try to understand the effects of noise
    and determine optimal ways to mitigate against them in the hopes of accelerating
    our path from quantum utility towards quantum advantage.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered some of the many effects that noise has on a quantum
    computing system, both specific to the qubit and externally with respect to the
    quantum system itself via readout errors. We discovered how we can use the Qiskit
    Runtime service to run our circuits using the fundamental building blocks known
    as Primitives. Finally, we learned how to apply error suppression and mitigation
    techniques to our quantum circuits so to filter the noisy results from a quantum
    device, which significantly reduces errors and provides more accurate results
    to complex quantum circuits.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to create quantum applications using
    the many features available in Qiskit. We will look at creating quantum algorithms,
    and ultimately provide you with all the tools you need to create your own quantum
    algorithms and quantum applications.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: List the three main error mitigation techniques used by the Qiskit Runtime service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which resilience levels are used for error mitigation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What other reversible gates could you use to fill in the idle time of a qubit
    using Dynamical Decoupling?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which type of noise contributes to amplitude dampening of a qubit?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which type of noises contribute to dephasing of a qubit?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'IBM Quantum Learning platform: [https://learning.quantum.ibm.com](https://learning.quantum.ibm.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Evidence for the utility of quantum computing before fault tolerance: [https://www.nature.com/articles/s41586-023-06096-3](https://www.nature.com/articles/s41586-023-06096-3)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Quasi-probability decompositions with reduced sampling overhead: [https://www.nature.com/articles/s41534-022-00517-3](https://www.nature.com/articles/s41534-022-00517-3)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dynamical suppression of decoherence in two-state quantum systems: [https://arxiv.org/pdf/quant-ph/9803057.pdf](https://arxiv.org/pdf/quant-ph/9803057.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Error mitigation in short depth circuits: [https://arxiv.org/pdf/1612.02058.pdf](https://arxiv.org/pdf/1612.02058.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sutor, B., *Dancing with Qubits*, Packt Publishing: [https://www.packtpub.com/data/dancing-with-qubits](https://www.packtpub.com/data/dancing-with-qubits%0D%0A)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Nielsen, M. & Chuang, I., *Quantum Computation and Quantum Information*, Cambridge
    University Press: [https://www.cambridge.org/us/academic/subjects/physics/quantum-physics-quantum-information-and-quantum-computation/quantum-computation-and-quantum-information-10th-anniversary-edition](https://www.cambridge.org/us/academic/subjects/physics/quantum-physics-quantum-information-and-quantum-computation/quantum-computation-and-quantum-information-10th-anniversary-edition)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Wootton, J., *What is Quantum Error Correction?*, Medium Series: [https://decodoku.medium.com/1-what-is-quantum-error-correction-4ab6d97cb398](https://decodoku.medium.com/1-what-is-quantum-error-correction-4ab6d97cb398%0D%0A%0D%0A)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join us on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/3FyN1](Chapter_10.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code261762599683826593.png)'
  prefs: []
  type: TYPE_IMG
