<html><head></head><body>
		<div id="_idContainer026">
			<h1 id="_idParaDest-37" class="chapter-number"><a id="_idTextAnchor036"/>2</h1>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor037"/>Writing Excel Spreadsheets</h1>
			<p>This may sound contradictory to modern-day data science practices, but Excel has its place in the world of analysis and data storytelling. Exporting data from R and Python to Excel can be beneficial for several reasons, offering users the opportunity to leverage the strengths of both platforms. Excel is a widely used spreadsheet program known for its user-friendly interface, while R and Python is a powerful statistical programming language. By exporting data from R and Python to Excel, users can take advantage of Excel’s familiar and versatile features to further analyze, visualize, and <span class="No-Break">share data.</span></p>
			<p>One significant advantage of exporting data from R and Python to Excel is the ability to harness Excel’s extensive range of data manipulation and visualization capabilities. Excel provides a variety of tools, such as pivot tables, charts, and conditional formatting, which enable users to explore and present data more interactively and intuitively. These features allow for quick data exploration, identification of trends, and the creation of professional-looking reports <span class="No-Break">or presentations.</span></p>
			<p>Moreover, exporting data to Excel can facilitate collaboration with colleagues or stakeholders who may not be familiar with R and Python or statistical programming. Excel is a widely recognized and accessible tool that’s often used for data analysis and reporting across various industries. By exporting data to Excel, users can share the data with others who may prefer working with spreadsheets, allowing for easier collaboration and <span class="No-Break">knowledge exchange.</span></p>
			<p>Another reason to export data from R and Python to Excel is to take advantage of Excel’s extensive ecosystem of add-ins and extensions. Excel offers numerous specialized tools and add-ins that can enhance data analysis, such as Power Query, Power Pivot, and Solver. These tools provide additional functionalities for data cleaning, advanced calculations, and optimization, which may not be readily available or as user-friendly in R and Python. Exporting data to Excel allows users to leverage these tools and benefit from the broader <span class="No-Break">Excel ecosystem.</span></p>
			<p>In summary, exporting data from R and Python to Excel allows you to utilize Excel’s user-friendly interface, powerful data manipulation and visualization capabilities, and compatibility with a wide range of users. By combining the strengths of both R and Excel, individuals can enhance their data analysis workflows, improve collaboration, and effectively communicate insights derived from <span class="No-Break">statistical analyses.</span></p>
			<p>In this chapter, we will cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Packages to write into <span class="No-Break">Excel sheets</span></li>
				<li>Creating and manipulating Excel sheets <span class="No-Break">using Python</span></li>
				<li>Keeping it simple – exporting data to Excel <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">pandas</strong></span></li>
				<li>Advanced mode – <strong class="source-inline">openpyxl</strong> for <span class="No-Break">Excel manipulation</span></li>
				<li>Choosing between <strong class="source-inline">openpyxl</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">pandas</strong></span></li>
				<li><span class="No-Break">Other alternatives</span></li>
			</ul>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor038"/>Technical requirements</h1>
			<p>We are going to use the built-in <strong class="source-inline">Iris</strong> dataset in this chapter. This is a good dataset for <span class="No-Break">demonstration purposes.</span></p>
			<p>This chapter’s code can be found in this book’s GitHub <span class="No-Break">repository: </span><a href="https://github.com/PacktPublishing/Extending-Excel-with-Python-and-R/tree/main/Chapter2"><span class="No-Break">https://github.com/PacktPublishing/Extending-Excel-with-Python-and-R/tree/main/Chapter2</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor039"/>Packages to write into Excel files</h1>
			<p>In this section, we are going<a id="_idIndexMarker068"/> to go over a few different libraries that we can use to write <strong class="source-inline">data.frames</strong>/<strong class="source-inline">tibbles</strong> to Excel files. We are going to use the <strong class="source-inline">writexl</strong>, <strong class="source-inline">openxlsx</strong>, and <span class="No-Break"><strong class="source-inline">xlsx</strong></span><span class="No-Break"> libraries.</span></p>
			<p>In the following section, we are going to list each package, specify where you can find the function documentation that writes the data to Excel, and go over the <span class="No-Break">functions’ parameters.</span></p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/>writexl</h2>
			<p>The <strong class="source-inline">writexl</strong> package is part of the<a id="_idIndexMarker069"/> rOpenSci<a id="_idIndexMarker070"/> consortium and can<a id="_idIndexMarker071"/> be found <span class="No-Break">here: </span><a href="https://docs.ropensci.org/writexl/reference/write_xlsx.html"><span class="No-Break">https://docs.ropensci.org/writexl/reference/write_xlsx.html</span></a><span class="No-Break">.</span></p>
			<p>The library does not require Java or Excel <span class="No-Break">to work.</span></p>
			<p>The function that writes the data to Excel is <strong class="source-inline">write_xlsx()</strong>. Let’s go over the different parameters of the function and look at a full pseudo <span class="No-Break">function call.</span></p>
			<p>First, let’s look at the function call itself – that <span class="No-Break">is, </span><span class="No-Break"><strong class="source-inline">write_xlsx()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
write_xlsx(
  x,
  path = tempfile(fileext = ".xlsx"),
  col_names = TRUE,
  format_headers = TRUE,
  use_zip64 = FALSE
)</pre>			<p>Now, let’s look at each of the parameters in <span class="No-Break">this code:</span></p>
			<ul>
				<li><strong class="source-inline">x</strong>: This is the DataFrame or named list of DataFrames that will be sheets in the <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">xlsx</strong></span><span class="No-Break"> file.</span></li>
				<li><strong class="source-inline">path</strong>: A filename to write to. Here, you could type something such as <strong class="source-inline">tempfile(fileext = .xlsx")col_names</strong> to write column names at the top of <span class="No-Break">the file.</span></li>
				<li><strong class="source-inline">format_headers</strong>: Make <strong class="source-inline">col_names</strong> in the <strong class="source-inline">.xlsx</strong> file centered <span class="No-Break">and bold.</span></li>
				<li><strong class="source-inline">use_zip64</strong>: Use <strong class="bold">ZIP64</strong> (<a href="https://en.wikipedia.org/wiki/Zip_(file_format)#ZIP64">https://en.wikipedia.org/wiki/Zip_(file_format)#ZIP64</a>) to enable support for 4 GB+ <strong class="source-inline">.xlsx</strong> files. Not all platforms<a id="_idIndexMarker072"/> can <span class="No-Break">read this.</span></li>
			</ul>
			<p>Let’s see what a simple example<a id="_idIndexMarker073"/> of this function would look<a id="_idIndexMarker074"/> like in <span class="No-Break">typical practice:</span></p>
			<pre class="source-code">
write_xlsx(list(mysheet = iris), path = "./iris_data_written.xlsx")</pre>			<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/>openxlsx</h2>
			<p>The <strong class="source-inline">openxlsx</strong> package can be found<a id="_idIndexMarker075"/> at <a href="https://ycphs.github.io/openxlsx/;">https://ycphs.github.io/openxlsx/;</a> the function<a id="_idIndexMarker076"/> that we are going to use to write to an Excel file is <strong class="source-inline">write.xlsx()</strong>. Again, we’ll go over the full function call and the parameters that get passed to <span class="No-Break">this function:</span></p>
			<pre class="source-code">
write.xlsx(
  x,
  file,
  asTable = FALSE,
  overwrite = TRUE,
  …
)</pre>			<p>Now, let’s go over all of the parameters of <span class="No-Break">the function:</span></p>
			<ul>
				<li><strong class="source-inline">x</strong>: A DataFrame or a (named) list of objects that can be handled by <strong class="source-inline">writeData()</strong> or <strong class="source-inline">writeDataTable()</strong> to write to <span class="No-Break">the file.</span></li>
				<li><strong class="source-inline">file</strong>: A file path to save the <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">xlsx</strong></span><span class="No-Break"> file.</span></li>
				<li><strong class="source-inline">asTable</strong>: If <strong class="source-inline">TRUE</strong>, then it will use <strong class="source-inline">writeDataTable()</strong> rather than <strong class="source-inline">writeData()</strong> to write <strong class="source-inline">x</strong> to the file (the default value <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">FALSE</strong></span><span class="No-Break">).</span></li>
				<li><strong class="source-inline">overwrite</strong>: Overwrite existing file (this defaults to <strong class="source-inline">TRUE</strong>, as <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">write.table</strong></span><span class="No-Break">).</span></li>
				<li><strong class="source-inline">...</strong>: Additional arguments passed to <strong class="source-inline">buildWorkbook();</strong>. To see additional details, you can type <strong class="source-inline">?openxlsx::buildWorkbook</strong> into the <span class="No-Break">R console.</span></li>
			</ul>
			<p>Let’s take a look at a short example of some code where we will write the Iris dataset to <span class="No-Break">a file:</span></p>
			<pre class="source-code">
openxlsx::write.xlsx(
x = iris,
File = paste0(getwd(), "/iris.xlsx"
)</pre>			<p>Next, we’ll look at the last <span class="No-Break">package, </span><span class="No-Break"><strong class="source-inline">xlsx</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor042"/>xlsx</h2>
			<p>The <strong class="source-inline">xlsx</strong> package can be<a id="_idIndexMarker077"/> found at <a href="https://github.com/colearendt/xlsx;">https://github.com/colearendt/xlsx;</a> the function that we<a id="_idIndexMarker078"/> are using to explore writing to an Excel file is <strong class="source-inline">write.xlsx()</strong>. Given that this function has the same name as the function from the <strong class="source-inline">openxlsx</strong> library, it is important to be aware of namespace collision. This takes place when there is a function from two or more separate packages that have the same name. Avoiding any possible namespace collision for users is easy but can be cumbersome. To do so, you can write <strong class="source-inline">xlsx::write.xlsx()</strong>. Again, let’s go over the full function call and the parameters that get passed to <span class="No-Break">this function:</span></p>
			<pre class="source-code">
write.xlsx(
  x,
  file,
  sheetName = "Sheet1",
  col.names = TRUE,
  row.names = TRUE,
  append = FALSE,
  showNA = TRUE,
  password = NULL
)</pre>			<p>Now, let’s go over the parameters of <span class="No-Break">the function:</span></p>
			<ul>
				<li><strong class="source-inline">x</strong>: A DataFrame to write to <span class="No-Break">the workbook.</span></li>
				<li><strong class="source-inline">file</strong>: The path to the <span class="No-Break">output file.</span></li>
				<li><strong class="source-inline">sheetName</strong>: A character string that contains the <span class="No-Break">sheet’s name.</span></li>
				<li><strong class="source-inline">col.names</strong>: A logical value indicating whether the column names of <strong class="source-inline">x</strong> are to be written along with <strong class="source-inline">x</strong> to <span class="No-Break">the file.</span></li>
				<li><strong class="source-inline">row.names</strong>: A logical value indicating whether the row names of <strong class="source-inline">x</strong> are to be written along with <strong class="source-inline">x</strong> to <span class="No-Break">the file.</span></li>
				<li><strong class="source-inline">append</strong>: A logical value indicating whether <strong class="source-inline">x</strong> should be appended to an existing file. If <strong class="source-inline">TRUE</strong>, the file is read from disk. Otherwise, the file <span class="No-Break">is created.</span></li>
				<li><strong class="source-inline">showNA</strong>: A logical value. If set to <strong class="source-inline">FALSE</strong>, <strong class="source-inline">NA</strong> values will be left as <span class="No-Break">empty cells.</span></li>
				<li><strong class="source-inline">password</strong>: A string containing <span class="No-Break">the password.</span></li>
			</ul>
			<p>A simple function call would take the <span class="No-Break">following form:</span></p>
			<pre class="source-code">
xlsx::write.xlsx(x = iris,
File = paste0(getwd(), "/iris.xlsx"
)</pre>			<p>Now that we have gone over the three different functions, it is important to see how each one writes – that is, how long they take to write to disk and how large the output file is. To do this, we are going to use the <strong class="source-inline">rbenchmark</strong> library for speed testing. We will also bring in the <strong class="source-inline">dplyr</strong> library to arrange the results by their relative order of speed. After this, we will see<a id="_idIndexMarker079"/> which file has the smallest<a id="_idIndexMarker080"/> <span class="No-Break">size output.</span></p>
			<p>Here is the code for <span class="No-Break">doing this:</span></p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/B19142_02_1.jpg" alt="Figure 2.1 – File write benchmark"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – File write benchmark</p>
			<p>This R code is used to compare<a id="_idIndexMarker081"/> the performance of three different packages<a id="_idIndexMarker082"/> for writing DataFrames to Excel files: <strong class="source-inline">writexl</strong>, <strong class="source-inline">openxlsx</strong>, and <strong class="source-inline">xlsx</strong>. Here’s a breakdown of what the <span class="No-Break">code does:</span></p>
			<ol>
				<li>The code starts by loading several libraries (<strong class="source-inline">rbenchmark</strong>, <strong class="source-inline">xlsx</strong>, <strong class="source-inline">writexl</strong>, <strong class="source-inline">openxlsx</strong>, and <strong class="source-inline">dplyr</strong>) using the <strong class="source-inline">library()</strong> function. These libraries provide functions that will be used later in the code. If you do not have them installed, you will need to use something such as <strong class="source-inline">install.packaegs("package")</strong> to <span class="No-Break">do so.</span></li>
				<li>The <strong class="source-inline">n</strong> variable is assigned a value of <strong class="source-inline">5</strong>. This variable represents the number of times the code will be executed for each package to <span class="No-Break">measure performance.</span></li>
				<li>The <strong class="source-inline">benchmark()</strong> function is called to compare the performance of the three Excel-writing packages. It takes <span class="No-Break">several arguments:</span><ul><li>The first argument, <strong class="source-inline">writexl</strong>, is a name that’s assigned to the first test. Inside the curly braces, the <strong class="source-inline">write_xlsx()</strong> function from the <strong class="source-inline">writexl</strong> package is called to write the <strong class="source-inline">iris</strong> dataset to a temporary <span class="No-Break">Excel file.</span></li><li>The second argument, <strong class="source-inline">openxlsx</strong>, is a name that’s assigned to the second test. Inside the curly braces, the <strong class="source-inline">write.xlsx()</strong> function from the <strong class="source-inline">openxlsx</strong> package is called to write the <strong class="source-inline">iris</strong> dataset to a temporary <span class="No-Break">Excel file.</span></li><li>The third argument, <strong class="source-inline">xlsx</strong>, is a name that’s assigned to the third test. Inside the curly braces, the <strong class="source-inline">write.xlsx()</strong> function from the <strong class="source-inline">xlsx</strong> package is called to write the <strong class="source-inline">iris</strong> dataset to a temporary Excel file with an <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">xlsx</strong></span><span class="No-Break"> extension.</span></li><li>The <strong class="source-inline">replications</strong> argument is set to <strong class="source-inline">n</strong>, indicating the number of times each test should <span class="No-Break">be repeated.</span></li><li>The <strong class="source-inline">columns</strong> argument specifies the columns to include in the output. It includes the names of the test, any replications, the elapsed time, relative performance, user time, and <span class="No-Break">system time.</span></li></ul></li>
				<li>The resulting benchmark results are then piped (<strong class="source-inline">|&gt;</strong>) to the <strong class="source-inline">arrange()</strong> function from the <strong class="source-inline">dplyr</strong> package. The <strong class="source-inline">arrange()</strong> function is used to sort the results based on the relative performance column, arranging them in <span class="No-Break">ascending order.</span><p class="list-inset">For the preceding<a id="_idIndexMarker083"/> benchmarking<a id="_idIndexMarker084"/> process, the results are <span class="No-Break">as follows:</span></p><pre class="source-code">
  test      replications elapsed relative  user.self  sys.self
1 writexl      5     0.03   1.000      0.01        0.00
2 openxlsx     5     0.32   10.667     0.01        0.00
3 xlsx         5     0.88   29.333     0.81<strong class="source-inline">      0.01</strong></pre><p class="list-inset">In summary, the preceding code loads the necessary libraries, performs benchmarks on three different Excel-writing packages (<strong class="source-inline">writexl</strong>, <strong class="source-inline">openxlsx</strong>, and <strong class="source-inline">xlsx</strong>), and sorts the results based on relative performance. The purpose is to compare the efficiency of these packages when writing the <strong class="source-inline">iris</strong> dataset to an Excel file. It is important to note that there are many factors at play here, such as the system and operating system, among others. Now, let’s see how the sizes <span class="No-Break">measure up:</span></p></li>			</ol>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="image/B19142_02_2.jpg" alt="Figure 2.2 – File size comparison"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – File size comparison</p>
			<p>This R code performs<a id="_idIndexMarker085"/> the following tasks<a id="_idIndexMarker086"/> using different packages to write the <strong class="source-inline">iris</strong> dataset to Excel files and then retrieves the sizes of those files, listed <span class="No-Break">in bytes:</span></p>
			<ul>
				<li>The <strong class="source-inline">write_xlsx()</strong> function from the <strong class="source-inline">writexl</strong> package is called with two arguments: the <strong class="source-inline">iris</strong> dataset and a temporary file path generated using the <strong class="source-inline">tempfile()</strong> function. The <strong class="source-inline">write_xlsx()</strong> function writes the <strong class="source-inline">iris</strong> dataset to the temporary <span class="No-Break">Excel file.</span></li>
				<li>The <strong class="source-inline">file.info()</strong> function is called with the temporary file path, <strong class="source-inline">(tmp1)</strong>, as an argument. It retrieves information about the file, including its size. The <strong class="source-inline">$size</strong> attribute is used to extract the size of <span class="No-Break">the file.</span></li>
				<li>The <strong class="source-inline">write.xlsx()</strong> function from the <strong class="source-inline">openxlsx</strong> package is called with two arguments: the <strong class="source-inline">iris</strong> dataset and another temporary file path generated using the <strong class="source-inline">tempfile()</strong> function. The <strong class="source-inline">write.xlsx()</strong> function writes the <strong class="source-inline">iris</strong> dataset to the temporary <span class="No-Break">Excel file.</span></li>
				<li>Similar to <em class="italic">the second point</em>, the <strong class="source-inline">file.info()</strong> function is called with the temporary file path, <strong class="source-inline">(tmp2)</strong>, as an argument to retrieve the size of <span class="No-Break">the file.</span></li>
				<li>The <strong class="source-inline">write.xlsx()</strong> function from the <strong class="source-inline">xlsx</strong> package is called with two arguments: the <strong class="source-inline">iris</strong> dataset and a temporary file path generated using the combination of <strong class="source-inline">tempfile()</strong> and <strong class="source-inline">paste0()</strong> functions. The <strong class="source-inline">write.xlsx()</strong> function writes the <strong class="source-inline">iris</strong> dataset to the temporary Excel file with an <strong class="source-inline">.xlsx</strong> extension. For the <strong class="source-inline">xlsx</strong> package, we use <strong class="source-inline">paste0()</strong> and specify the file extension since this isn’t done by default in the function, so the user must be careful and specify <span class="No-Break">this accordingly.</span></li>
				<li>Again, the <strong class="source-inline">file.info()</strong> function is called with the temporary file path, <strong class="source-inline">(tmp3)</strong>, as an argument to retrieve the size of <span class="No-Break">the file.</span></li>
			</ul>
			<p>In summary, this code uses different packages (<strong class="source-inline">writexl</strong>, <strong class="source-inline">openxlsx</strong>, and <strong class="source-inline">xlsx</strong>) to write the <strong class="source-inline">iris</strong> dataset<a id="_idIndexMarker087"/> into three separate Excel files. Then, it retrieves<a id="_idIndexMarker088"/> the sizes of those files using the <strong class="source-inline">file.info()</strong> function. Its purpose is to compare the sizes of the resulting Excel files when using these different packages. Again, many factors that are outside the scope of this book could be affecting file sizes, but you must be aware the different systems and configurations could have an impact <span class="No-Break">on this.</span></p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor043"/>A comprehensive recap and insights</h2>
			<p>In the previous section, we learned how to write <strong class="source-inline">data.frame</strong> to Excel using three different packages. We learned that with these three different packages come differences in the speed of writing in a file and differences in the size of the output file itself. It is important to run these benchmarks as we might be trying to achieve speed, a small file size, or some <span class="No-Break">combination thereof.</span></p>
			<p>When it comes to speed, there are a few reasons why it is good to run benchmarks <span class="No-Break">in R:</span></p>
			<ul>
				<li><strong class="bold">Accuracy</strong>: Benchmarks can be used<a id="_idIndexMarker089"/> to accurately measure the speed of different functions. This is important because it can help you choose the fastest function for <span class="No-Break">your task.</span></li>
				<li><strong class="bold">Consistency</strong>: Benchmarks can be used<a id="_idIndexMarker090"/> to consistently measure the speed of different functions over time. This is important because it can help you identify any changes in performance that may <span class="No-Break">have occurred.</span></li>
				<li><strong class="bold">Reliability</strong>: Benchmarks can be used to reliably<a id="_idIndexMarker091"/> measure the speed of different functions across different platforms. This is important because it can help you ensure that the results of your benchmarks are accurate<a id="_idIndexMarker092"/> <span class="No-Break">and reproducible.</span></li>
			</ul>
			<p>In addition to these advantages, benchmarks can also be used to identify bottlenecks in your code. This can help you improve the performance of your code as you can optimize the areas that are taking the most time <span class="No-Break">to execute.</span></p>
			<p>Here are some of the most popular R packages <span class="No-Break">for benchmarking:</span></p>
			<ul>
				<li><strong class="source-inline">microbenchmark</strong>: This package provides<a id="_idIndexMarker093"/> a simple and convenient way to benchmark <span class="No-Break">R code</span></li>
				<li><strong class="source-inline">rbenchmark</strong>: This package provides a more comprehensive<a id="_idIndexMarker094"/> set of benchmarking features <span class="No-Break">than </span><span class="No-Break"><strong class="source-inline">microbenchmark</strong></span></li>
				<li><strong class="source-inline">rbenchmark2</strong>: This package is a fork of <strong class="source-inline">rbenchmark</strong> that provides<a id="_idIndexMarker095"/> additional features, such as the ability to benchmark <span class="No-Break">multiple cores</span></li>
			</ul>
			<p>When choosing a benchmarking package, it is important to consider<a id="_idIndexMarker096"/> your needs and the available features. For example, if you need to benchmark a large amount of code, you may want to choose a package that supports <span class="No-Break"><em class="italic">parallel benchmarking</em></span><span class="No-Break">.</span></p>
			<p>Once you have chosen a benchmarking package, you can use it to compare the speed of different functions. To do this, you will need to create a benchmark object that contains the functions that you want to compare. You can then use the <strong class="source-inline">benchmark</strong> object to run the functions and measure their <span class="No-Break">execution time.</span></p>
			<p>The results of the benchmark can be used to identify the fastest function for your task. You can then use this information to improve the performance of <span class="No-Break">your code.</span></p>
			<p>In this section, we learned not only how to write data to an Excel file, but also how to do so with different R libraries. This is important as it helps you explore different methods of achieving the same goal. This exercise also illustrated the differences in implementations, which we saw by checking the output file size and by benchmarking the time it took to write our data to Excel with each package. Next, we will conduct similar exercises <span class="No-Break">using Python.</span></p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor044"/>Creating and manipulating Excel sheets using Python</h1>
			<p>In this section, we will explore<a id="_idIndexMarker097"/> how to create and manipulate Excel sheets<a id="_idIndexMarker098"/> <span class="No-Break">using Python.</span></p>
			<p>Exporting data to Excel is a common requirement in various data analysis and reporting scenarios. Excel provides a familiar and widely used interface for data visualization, sharing, and <span class="No-Break">further analysis.</span></p>
			<p>We’ll cover various tasks in the sections ahead, including creating new workbooks, adding sheets to existing workbooks, deleting sheets, and manipulating data within an Excel workbook. Python provides several libraries that make these tasks straightforward and efficient. But first, let’s understand why we need to export data <span class="No-Break">to Excel.</span></p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor045"/>Why export data to Excel?</h2>
			<p>Exporting data to Excel offers<a id="_idIndexMarker099"/> several benefits. Firstly, Excel provides a user-friendly environment for data exploration and visualization, allowing users to easily sort, filter, and analyze data. Additionally, Excel’s rich formatting capabilities make it suitable for generating professional reports or sharing data with stakeholders who may not have programming knowledge. Furthermore, Excel supports various formulas and functions, enabling users to perform calculations on the exported <span class="No-Break">data easily.</span></p>
			<p>Let’s see how we can export data to Excel <span class="No-Break">with Python!</span></p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor046"/>Keeping it simple – exporting data to Excel with pandas</h1>
			<p><strong class="source-inline">pandas</strong> is a popular data manipulation<a id="_idIndexMarker100"/> library in Python that provides powerful<a id="_idIndexMarker101"/> tools for data<a id="_idIndexMarker102"/> analysis. It also<a id="_idIndexMarker103"/> offers excellent functionality for exporting data to Excel. Using <strong class="source-inline">pandas</strong>, you can effortlessly transform your data into Excel sheets <span class="No-Break">or workbooks.</span></p>
			<p><strong class="source-inline">pandas</strong> provides the <strong class="source-inline">DataFrame.to_excel()</strong> method, allowing you to export data to an Excel file with just a few lines of code. Here’s <span class="No-Break">an example:</span></p>
			<pre class="source-code">
import pandas as pd
# Create a DataFrame with sample data
data = {
    'Name': ['John', 'Jane', 'Mike'],
    'Age': [25, 30, 35],
    'City': ['New York', 'London', 'Sydney']
}
df = pd.DataFrame(data)
# Export the DataFrame to an Excel file
df.to_excel('data.xlsx', index=False)</pre>			<p>The code doesn’t return<a id="_idIndexMarker104"/> anything, but it<a id="_idIndexMarker105"/> does have a side<a id="_idIndexMarker106"/> effect – it creates the <strong class="source-inline">data.xlsx</strong> file with the <span class="No-Break">exported data:</span></p>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="image/B19142_02_3.jpg" alt="Figure 2.3 – Excel export with pandas"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Excel export with pandas</p>
			<p>While <strong class="source-inline">pandas</strong> is good at simple data export, we may want to have more control over the Excel workbook. The next few subsections cover more advanced Excel manipulation using <strong class="source-inline">openpyxl</strong>. We will cover the capabilities of <strong class="source-inline">openpyxl</strong>, starting with the basics such as creating a new workbook<a id="_idIndexMarker107"/> by adding and deleting sheets<a id="_idIndexMarker108"/> up to and including<a id="_idIndexMarker109"/> manipulating data in an <span class="No-Break">existing sheet.</span></p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor047"/>Advanced mode – openpyxl for Excel manipulation</h1>
			<p>In this section, we will look<a id="_idIndexMarker110"/> at the <strong class="source-inline">openpyxl</strong> package, which allows for a more nuanced interaction with Excel when <span class="No-Break">writing data.</span></p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor048"/>Creating a new workbook</h2>
			<p>To start working with Excel sheets<a id="_idIndexMarker111"/> in Python, we need to create a new workbook. <strong class="source-inline">openpyxl</strong> provides an intuitive API to create, modify, and save Excel workbooks. Here’s an example code snippet that demonstrates creating a <span class="No-Break">new workbook:</span></p>
			<pre class="source-code">
import openpyxl
# Create a new workbook
workbook = openpyxl.Workbook()</pre>			<p>Once again, the preceding code snippet doesn’t return anything but it does have a side effect – it creates <span class="No-Break">the workbook:</span></p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="image/B19142_02_4.jpg" alt="Figure 2.4 – Creating a workbook with openpyxl"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – Creating a workbook with openpyxl</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor049"/>Adding sheets to the workbook</h2>
			<p>Once we have a workbook, we can add sheets<a id="_idIndexMarker112"/> to it. Adding sheets allows us to organize data into separate sections or categories. <strong class="source-inline">openpyxl</strong> provides a simple method, <strong class="source-inline">create_sheet()</strong>, to add sheets to a workbook. Let’s see <span class="No-Break">an example:</span></p>
			<pre class="source-code">
import openpyxl
# Create a new workbook
workbook = openpyxl.Workbook()
# Add a new sheet
workbook.create_sheet(title="Sheet2")
# Save the changes
workbook.save("example.xlsx")</pre>			<p>The result is an <strong class="source-inline">openpyxl</strong> worksheet object we can use going forward. The resulting workbook can then be saved for <span class="No-Break">future use.</span></p>
			<p>The preceding example attempts to save the workbook you are working with. If the workbook is open in Excel, the attempt will fail, with a hard-to-decipher error message about the COM systems. Make sure you close your Excel instance before attempting to save your work from the Python side! This warning will remain applicable<a id="_idIndexMarker113"/> to most of this book, so keep it in mind for later chapters <span class="No-Break">as well.</span></p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor050"/>Deleting a sheet</h2>
			<p>At times, we may need to remove<a id="_idIndexMarker114"/> a sheet from a workbook. The <strong class="source-inline">remove()</strong> method in <strong class="source-inline">openpyxl</strong> allows us to delete a sheet by its name. The following is an example of how you can delete a sheet from a workbook. Please note that we will not save the result, so the stored version of the file <span class="No-Break">remains unchanged:</span></p>
			<pre class="source-code">
import openpyxl
# Load an existing workbook
workbook = openpyxl.load_workbook("example.xlsx")
# Delete a sheet
sheet_name = "Sheet2"
sheet = workbook[sheet_name]
workbook.remove(sheet)</pre>			<p>As before, the code has a side effect (the deleted sheet) but no <span class="No-Break">return value:</span></p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="image/B19142_02_5.jpg" alt="Figure 2.5 – Deleting a sheet with openpyxl"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – Deleting a sheet with openpyxl</p>
			<p>In this example, we used the sheet we created previously. The <strong class="source-inline">load_workbook()</strong> method from <strong class="source-inline">openpyxl</strong> is used to load the existing workbook, after which the <strong class="source-inline">remove()</strong> method is used to delete<a id="_idIndexMarker115"/> a sheet specified <span class="No-Break">by name.</span></p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor051"/>Manipulating an existing workbook</h2>
			<p>Python libraries such as <strong class="source-inline">openpyxl</strong> provide powerful methods<a id="_idIndexMarker116"/> to manipulate existing Excel workbooks. We can modify cells, apply formatting, insert formulas, and more. Let’s look at an example of how to update<a id="_idIndexMarker117"/> a cell value in an <span class="No-Break">existing workbook:</span></p>
			<pre class="source-code">
import openpyxl
# Load an existing workbook
workbook = openpyxl.load_workbook("example.xlsx")
# Add a new sheet
workbook.create_sheet(title="Sheet1")
# Select a sheet
sheet_name = "Sheet1"
sheet = workbook[sheet_name]
# Update a cell value
sheet["A1"] = "Hello, World!"
# Save the changes
workbook.save("example.xlsx")</pre>			<p>This code snippet will directly change the value of a cell in the <span class="No-Break">Excel sheet:</span></p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/B19142_02_6.jpg" alt="Figure 2.6 – Updating the value of a cell with openpyxl"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6 – Updating the value of a cell with openpyxl</p>
			<p>The result is as we<a id="_idIndexMarker118"/> expect (keep in mind that the process of deleting the sheet was <span class="No-Break">not saved):</span></p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/B19142_02_7.jpg" alt="Figure 2.7 – The fruit of our efforts – Hell﻿o, World! in A1, Sheet1"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7 – The fruit of our efforts – Hello, World! in A1, Sheet1</p>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor052"/>Choosing between openpyxl and pandas</h1>
			<p>When it comes to exporting <a id="_idIndexMarker119"/>data to Excel, both <strong class="source-inline">openpyxl</strong> and <strong class="source-inline">pandas</strong> are excellent choices. <strong class="source-inline">openpyxl</strong> is a dedicated library for working with Excel files as it provides extensive functionality for creating, modifying, and saving Excel workbooks. On the other hand, <strong class="source-inline">pandas</strong> offers a high-level data manipulation interface with convenient methods for exporting data to Excel, which is ideal when a simple data dump is all <span class="No-Break">you need.</span></p>
			<p>If you require fine-grained control over the Excel file’s structure, such as adding formatting, formulas, or charts, <strong class="source-inline">openpyxl</strong> is a suitable option. It allows you to work directly with the underlying Excel objects, providing more flexibility. On the other hand, if you primarily focus on data manipulation and want a simpler way to export DataFrames to Excel without worrying about Excel-specific features, <strong class="source-inline">pandas</strong> is a convenient choice. It abstracts away some of the lower-level details and provides a more straightforward interface for exporting data. While <strong class="source-inline">openpyxl</strong> provides a simple abstracted way of manipulating and controlling sheets, R also has this in packages such as <strong class="source-inline">openxlsx</strong> and <strong class="source-inline">xlsx</strong>, both of which provide<a id="_idIndexMarker120"/> their own form of these types <span class="No-Break">of functionalities.</span></p>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor053"/>Other alternatives</h1>
			<p>Apart from <strong class="source-inline">pandas</strong> and <strong class="source-inline">openpyxl</strong>, there are other libraries available for exporting data to Excel from Python. Some<a id="_idIndexMarker121"/> popular alternatives<a id="_idIndexMarker122"/> include <strong class="source-inline">XlsxWriter</strong>, <strong class="source-inline">xlrd</strong>, and <strong class="source-inline">xlwt</strong>. These libraries offer different<a id="_idIndexMarker123"/> features and capabilities, and the choice depends on your specific requirements. <strong class="source-inline">XlsxWriter</strong>, for example, emphasizes performance and supports advanced Excel features, while <strong class="source-inline">xlrd</strong> and <strong class="source-inline">xlwt</strong> provide functionality for reading and writing older Excel file <span class="No-Break">formats (</span><span class="No-Break"><strong class="source-inline">.xls</strong></span><span class="No-Break">).</span></p>
			<p>In this section, we explored the benefits of exporting data to Excel, demonstrated how to do so using <strong class="source-inline">pandas</strong>, went through the process of creating and manipulating Excel sheets using <strong class="source-inline">openpyxl</strong>, discussed the reasons for choosing <strong class="source-inline">openpyxl</strong> or <strong class="source-inline">pandas</strong> based on your needs, and mentioned other alternatives available. By leveraging the power of these libraries, you can seamlessly export your data from Python to Excel, enabling efficient analysis, reporting, <span class="No-Break">and collaboration.</span></p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor054"/>Summary</h1>
			<p>In <a href="B19142_02.xhtml#_idTextAnchor036"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, we explored the process of writing data to Excel using different R and Python libraries and benchmarking their performance. We also discussed creating and manipulating Excel sheets from Python using <strong class="source-inline">pandas</strong> and <strong class="source-inline">openpyxl</strong>. By comparing their features and exploring alternatives, you have gained insights into the capabilities of both R and Python for <span class="No-Break">Excel tasks.</span></p>
			<p>In the next chapter, we will learn how to execute VBA code with R <span class="No-Break">and Python.</span></p>
		</div>
	</body></html>