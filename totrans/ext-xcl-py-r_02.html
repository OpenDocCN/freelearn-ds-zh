<html><head></head><body>
		<div><h1 id="_idParaDest-37" class="chapter-number"><a id="_idTextAnchor036"/>2</h1>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor037"/>Writing Excel Spreadsheets</h1>
			<p>This may sound contradictory to modern-day data science practices, but Excel has its place in the world of analysis and data storytelling. Exporting data from R and Python to Excel can be beneficial for several reasons, offering users the opportunity to leverage the strengths of both platforms. Excel is a widely used spreadsheet program known for its user-friendly interface, while R and Python is a powerful statistical programming language. By exporting data from R and Python to Excel, users can take advantage of Excel’s familiar and versatile features to further analyze, visualize, and share data.</p>
			<p>One significant advantage of exporting data from R and Python to Excel is the ability to harness Excel’s extensive range of data manipulation and visualization capabilities. Excel provides a variety of tools, such as pivot tables, charts, and conditional formatting, which enable users to explore and present data more interactively and intuitively. These features allow for quick data exploration, identification of trends, and the creation of professional-looking reports or presentations.</p>
			<p>Moreover, exporting data to Excel can facilitate collaboration with colleagues or stakeholders who may not be familiar with R and Python or statistical programming. Excel is a widely recognized and accessible tool that’s often used for data analysis and reporting across various industries. By exporting data to Excel, users can share the data with others who may prefer working with spreadsheets, allowing for easier collaboration and knowledge exchange.</p>
			<p>Another reason to export data from R and Python to Excel is to take advantage of Excel’s extensive ecosystem of add-ins and extensions. Excel offers numerous specialized tools and add-ins that can enhance data analysis, such as Power Query, Power Pivot, and Solver. These tools provide additional functionalities for data cleaning, advanced calculations, and optimization, which may not be readily available or as user-friendly in R and Python. Exporting data to Excel allows users to leverage these tools and benefit from the broader Excel ecosystem.</p>
			<p>In summary, exporting data from R and Python to Excel allows you to utilize Excel’s user-friendly interface, powerful data manipulation and visualization capabilities, and compatibility with a wide range of users. By combining the strengths of both R and Excel, individuals can enhance their data analysis workflows, improve collaboration, and effectively communicate insights derived from statistical analyses.</p>
			<p>In this chapter, we will cover the following main topics:</p>
			<ul>
				<li>Packages to write into Excel sheets</li>
				<li>Creating and manipulating Excel sheets using Python</li>
				<li>Keeping it simple – exporting data to Excel with <code>pandas</code></li>
				<li>Advanced mode – <code>openpyxl</code> for Excel manipulation</li>
				<li>Choosing between <code>openpyxl</code> and <code>pandas</code></li>
				<li>Other alternatives</li>
			</ul>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor038"/>Technical requirements</h1>
			<p>We are going to use the built-in <code>Iris</code> dataset in this chapter. This is a good dataset for demonstration purposes.</p>
			<p>This chapter’s code can be found in this book’s GitHub repository: <a href="https://github.com/PacktPublishing/Extending-Excel-with-Python-and-R/tree/main/Chapter2">https://github.com/PacktPublishing/Extending-Excel-with-Python-and-R/tree/main/Chapter2</a>.</p>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor039"/>Packages to write into Excel files</h1>
			<p>In this section, we are going<a id="_idIndexMarker068"/> to go over a few different libraries that we can use to write <code>data.frames</code>/<code>tibbles</code> to Excel files. We are going to use the <code>writexl</code>, <code>openxlsx</code>, and <code>xlsx</code> libraries.</p>
			<p>In the following section, we are going to list each package, specify where you can find the function documentation that writes the data to Excel, and go over the functions’ parameters.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/>writexl</h2>
			<p>The <code>writexl</code> package is part of the<a id="_idIndexMarker069"/> rOpenSci<a id="_idIndexMarker070"/> consortium and can<a id="_idIndexMarker071"/> be found here: <a href="https://docs.ropensci.org/writexl/reference/write_xlsx.html">https://docs.ropensci.org/writexl/reference/write_xlsx.html</a>.</p>
			<p>The library does not require Java or Excel to work.</p>
			<p>The function that writes the data to Excel is <code>write_xlsx()</code>. Let’s go over the different parameters of the function and look at a full pseudo function call.</p>
			<p>First, let’s look at the function call itself – that is, <code>write_xlsx()</code>:</p>
			<pre class="source-code">
write_xlsx(
  x,
  path = tempfile(fileext = ".xlsx"),
  col_names = TRUE,
  format_headers = TRUE,
  use_zip64 = FALSE
)</pre>			<p>Now, let’s look at each of the parameters in this code:</p>
			<ul>
				<li><code>x</code>: This is the DataFrame or named list of DataFrames that will be sheets in the <code>.</code><code>xlsx</code> file.</li>
				<li><code>path</code>: A filename to write to. Here, you could type something such as <code>tempfile(fileext = .xlsx")col_names</code> to write column names at the top of the file.</li>
				<li><code>format_headers</code>: Make <code>col_names</code> in the <code>.xlsx</code> file centered and bold.</li>
				<li><code>use_zip64</code>: Use <code>.xlsx</code> files. Not all platforms<a id="_idIndexMarker072"/> can read this.</li>
			</ul>
			<p>Let’s see what a simple example<a id="_idIndexMarker073"/> of this function would look<a id="_idIndexMarker074"/> like in typical practice:</p>
			<pre class="source-code">
write_xlsx(list(mysheet = iris), path = "./iris_data_written.xlsx")</pre>			<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/>openxlsx</h2>
			<p>The <code>openxlsx</code> package can be found<a id="_idIndexMarker075"/> at <a href="https://ycphs.github.io/openxlsx/;">https://ycphs.github.io/openxlsx/;</a> the function<a id="_idIndexMarker076"/> that we are going to use to write to an Excel file is <code>write.xlsx()</code>. Again, we’ll go over the full function call and the parameters that get passed to this function:</p>
			<pre class="source-code">
write.xlsx(
  x,
  file,
  asTable = FALSE,
  overwrite = TRUE,
  …
)</pre>			<p>Now, let’s go over all of the parameters of the function:</p>
			<ul>
				<li><code>x</code>: A DataFrame or a (named) list of objects that can be handled by <code>writeData()</code> or <code>writeDataTable()</code> to write to the file.</li>
				<li><code>file</code>: A file path to save the <code>.</code><code>xlsx</code> file.</li>
				<li><code>asTable</code>: If <code>TRUE</code>, then it will use <code>writeDataTable()</code> rather than <code>writeData()</code> to write <code>x</code> to the file (the default value is <code>FALSE</code>).</li>
				<li><code>overwrite</code>: Overwrite existing file (this defaults to <code>TRUE</code>, as with <code>write.table</code>).</li>
				<li><code>...</code>: Additional arguments passed to <code>buildWorkbook();</code>. To see additional details, you can type <code>?openxlsx::buildWorkbook</code> into the R console.</li>
			</ul>
			<p>Let’s take a look at a short example of some code where we will write the Iris dataset to a file:</p>
			<pre class="source-code">
openxlsx::write.xlsx(
x = iris,
File = paste0(getwd(), "/iris.xlsx"
)</pre>			<p>Next, we’ll look at the last package, <code>xlsx</code>.</p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor042"/>xlsx</h2>
			<p>The <code>xlsx</code> package can be<a id="_idIndexMarker077"/> found at <a href="https://github.com/colearendt/xlsx;">https://github.com/colearendt/xlsx;</a> the function that we<a id="_idIndexMarker078"/> are using to explore writing to an Excel file is <code>write.xlsx()</code>. Given that this function has the same name as the function from the <code>openxlsx</code> library, it is important to be aware of namespace collision. This takes place when there is a function from two or more separate packages that have the same name. Avoiding any possible namespace collision for users is easy but can be cumbersome. To do so, you can write <code>xlsx::write.xlsx()</code>. Again, let’s go over the full function call and the parameters that get passed to this function:</p>
			<pre class="source-code">
write.xlsx(
  x,
  file,
  sheetName = "Sheet1",
  col.names = TRUE,
  row.names = TRUE,
  append = FALSE,
  showNA = TRUE,
  password = NULL
)</pre>			<p>Now, let’s go over the parameters of the function:</p>
			<ul>
				<li><code>x</code>: A DataFrame to write to the workbook.</li>
				<li><code>file</code>: The path to the output file.</li>
				<li><code>sheetName</code>: A character string that contains the sheet’s name.</li>
				<li><code>col.names</code>: A logical value indicating whether the column names of <code>x</code> are to be written along with <code>x</code> to the file.</li>
				<li><code>row.names</code>: A logical value indicating whether the row names of <code>x</code> are to be written along with <code>x</code> to the file.</li>
				<li><code>append</code>: A logical value indicating whether <code>x</code> should be appended to an existing file. If <code>TRUE</code>, the file is read from disk. Otherwise, the file is created.</li>
				<li><code>showNA</code>: A logical value. If set to <code>FALSE</code>, <code>NA</code> values will be left as empty cells.</li>
				<li><code>password</code>: A string containing the password.</li>
			</ul>
			<p>A simple function call would take the following form:</p>
			<pre class="source-code">
xlsx::write.xlsx(x = iris,
File = paste0(getwd(), "/iris.xlsx"
)</pre>			<p>Now that we have gone over the three different functions, it is important to see how each one writes – that is, how long they take to write to disk and how large the output file is. To do this, we are going to use the <code>rbenchmark</code> library for speed testing. We will also bring in the <code>dplyr</code> library to arrange the results by their relative order of speed. After this, we will see<a id="_idIndexMarker079"/> which file has the smallest<a id="_idIndexMarker080"/> size output.</p>
			<p>Here is the code for doing this:</p>
			<div><div><img src="img/B19142_02_1.jpg" alt="Figure 2.1 – File write benchmark"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – File write benchmark</p>
			<p>This R code is used to compare<a id="_idIndexMarker081"/> the performance of three different packages<a id="_idIndexMarker082"/> for writing DataFrames to Excel files: <code>writexl</code>, <code>openxlsx</code>, and <code>xlsx</code>. Here’s a breakdown of what the code does:</p>
			<ol>
				<li>The code starts by loading several libraries (<code>rbenchmark</code>, <code>xlsx</code>, <code>writexl</code>, <code>openxlsx</code>, and <code>dplyr</code>) using the <code>library()</code> function. These libraries provide functions that will be used later in the code. If you do not have them installed, you will need to use something such as <code>install.packaegs("package")</code> to do so.</li>
				<li>The <code>n</code> variable is assigned a value of <code>5</code>. This variable represents the number of times the code will be executed for each package to measure performance.</li>
				<li>The <code>benchmark()</code> function is called to compare the performance of the three Excel-writing packages. It takes several arguments:<ul><li>The first argument, <code>writexl</code>, is a name that’s assigned to the first test. Inside the curly braces, the <code>write_xlsx()</code> function from the <code>writexl</code> package is called to write the <code>iris</code> dataset to a temporary Excel file.</li><li>The second argument, <code>openxlsx</code>, is a name that’s assigned to the second test. Inside the curly braces, the <code>write.xlsx()</code> function from the <code>openxlsx</code> package is called to write the <code>iris</code> dataset to a temporary Excel file.</li><li>The third argument, <code>xlsx</code>, is a name that’s assigned to the third test. Inside the curly braces, the <code>write.xlsx()</code> function from the <code>xlsx</code> package is called to write the <code>iris</code> dataset to a temporary Excel file with an <code>.</code><code>xlsx</code> extension.</li><li>The <code>replications</code> argument is set to <code>n</code>, indicating the number of times each test should be repeated.</li><li>The <code>columns</code> argument specifies the columns to include in the output. It includes the names of the test, any replications, the elapsed time, relative performance, user time, and system time.</li></ul></li>
				<li>The resulting benchmark results are then piped (<code>|&gt;</code>) to the <code>arrange()</code> function from the <code>dplyr</code> package. The <code>arrange()</code> function is used to sort the results based on the relative performance column, arranging them in ascending order.<p class="list-inset">For the preceding<a id="_idIndexMarker083"/> benchmarking<a id="_idIndexMarker084"/> process, the results are as follows:</p><pre class="source-code">
  test      replications elapsed relative  user.self  sys.self
1 writexl      5     0.03   1.000      0.01        0.00
2 openxlsx     5     0.32   10.667     0.01        0.00
3 xlsx         5     0.88   29.333     0.81<code>      0.01</code></pre><p class="list-inset">In summary, the preceding code loads the necessary libraries, performs benchmarks on three different Excel-writing packages (<code>writexl</code>, <code>openxlsx</code>, and <code>xlsx</code>), and sorts the results based on relative performance. The purpose is to compare the efficiency of these packages when writing the <code>iris</code> dataset to an Excel file. It is important to note that there are many factors at play here, such as the system and operating system, among others. Now, let’s see how the sizes measure up:</p></li>			</ol>
			<div><div><img src="img/B19142_02_2.jpg" alt="Figure 2.2 – File size comparison"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – File size comparison</p>
			<p>This R code performs<a id="_idIndexMarker085"/> the following tasks<a id="_idIndexMarker086"/> using different packages to write the <code>iris</code> dataset to Excel files and then retrieves the sizes of those files, listed in bytes:</p>
			<ul>
				<li>The <code>write_xlsx()</code> function from the <code>writexl</code> package is called with two arguments: the <code>iris</code> dataset and a temporary file path generated using the <code>tempfile()</code> function. The <code>write_xlsx()</code> function writes the <code>iris</code> dataset to the temporary Excel file.</li>
				<li>The <code>file.info()</code> function is called with the temporary file path, <code>(tmp1)</code>, as an argument. It retrieves information about the file, including its size. The <code>$size</code> attribute is used to extract the size of the file.</li>
				<li>The <code>write.xlsx()</code> function from the <code>openxlsx</code> package is called with two arguments: the <code>iris</code> dataset and another temporary file path generated using the <code>tempfile()</code> function. The <code>write.xlsx()</code> function writes the <code>iris</code> dataset to the temporary Excel file.</li>
				<li>Similar to <em class="italic">the second point</em>, the <code>file.info()</code> function is called with the temporary file path, <code>(tmp2)</code>, as an argument to retrieve the size of the file.</li>
				<li>The <code>write.xlsx()</code> function from the <code>xlsx</code> package is called with two arguments: the <code>iris</code> dataset and a temporary file path generated using the combination of <code>tempfile()</code> and <code>paste0()</code> functions. The <code>write.xlsx()</code> function writes the <code>iris</code> dataset to the temporary Excel file with an <code>.xlsx</code> extension. For the <code>xlsx</code> package, we use <code>paste0()</code> and specify the file extension since this isn’t done by default in the function, so the user must be careful and specify this accordingly.</li>
				<li>Again, the <code>file.info()</code> function is called with the temporary file path, <code>(tmp3)</code>, as an argument to retrieve the size of the file.</li>
			</ul>
			<p>In summary, this code uses different packages (<code>writexl</code>, <code>openxlsx</code>, and <code>xlsx</code>) to write the <code>iris</code> dataset<a id="_idIndexMarker087"/> into three separate Excel files. Then, it retrieves<a id="_idIndexMarker088"/> the sizes of those files using the <code>file.info()</code> function. Its purpose is to compare the sizes of the resulting Excel files when using these different packages. Again, many factors that are outside the scope of this book could be affecting file sizes, but you must be aware the different systems and configurations could have an impact on this.</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor043"/>A comprehensive recap and insights</h2>
			<p>In the previous section, we learned how to write <code>data.frame</code> to Excel using three different packages. We learned that with these three different packages come differences in the speed of writing in a file and differences in the size of the output file itself. It is important to run these benchmarks as we might be trying to achieve speed, a small file size, or some combination thereof.</p>
			<p>When it comes to speed, there are a few reasons why it is good to run benchmarks in R:</p>
			<ul>
				<li><strong class="bold">Accuracy</strong>: Benchmarks can be used<a id="_idIndexMarker089"/> to accurately measure the speed of different functions. This is important because it can help you choose the fastest function for your task.</li>
				<li><strong class="bold">Consistency</strong>: Benchmarks can be used<a id="_idIndexMarker090"/> to consistently measure the speed of different functions over time. This is important because it can help you identify any changes in performance that may have occurred.</li>
				<li><strong class="bold">Reliability</strong>: Benchmarks can be used to reliably<a id="_idIndexMarker091"/> measure the speed of different functions across different platforms. This is important because it can help you ensure that the results of your benchmarks are accurate<a id="_idIndexMarker092"/> and reproducible.</li>
			</ul>
			<p>In addition to these advantages, benchmarks can also be used to identify bottlenecks in your code. This can help you improve the performance of your code as you can optimize the areas that are taking the most time to execute.</p>
			<p>Here are some of the most popular R packages for benchmarking:</p>
			<ul>
				<li><code>microbenchmark</code>: This package provides<a id="_idIndexMarker093"/> a simple and convenient way to benchmark R code</li>
				<li><code>rbenchmark</code>: This package provides a more comprehensive<a id="_idIndexMarker094"/> set of benchmarking features than <code>microbenchmark</code></li>
				<li><code>rbenchmark2</code>: This package is a fork of <code>rbenchmark</code> that provides<a id="_idIndexMarker095"/> additional features, such as the ability to benchmark multiple cores</li>
			</ul>
			<p>When choosing a benchmarking package, it is important to consider<a id="_idIndexMarker096"/> your needs and the available features. For example, if you need to benchmark a large amount of code, you may want to choose a package that supports <em class="italic">parallel benchmarking</em>.</p>
			<p>Once you have chosen a benchmarking package, you can use it to compare the speed of different functions. To do this, you will need to create a benchmark object that contains the functions that you want to compare. You can then use the <code>benchmark</code> object to run the functions and measure their execution time.</p>
			<p>The results of the benchmark can be used to identify the fastest function for your task. You can then use this information to improve the performance of your code.</p>
			<p>In this section, we learned not only how to write data to an Excel file, but also how to do so with different R libraries. This is important as it helps you explore different methods of achieving the same goal. This exercise also illustrated the differences in implementations, which we saw by checking the output file size and by benchmarking the time it took to write our data to Excel with each package. Next, we will conduct similar exercises using Python.</p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor044"/>Creating and manipulating Excel sheets using Python</h1>
			<p>In this section, we will explore<a id="_idIndexMarker097"/> how to create and manipulate Excel sheets<a id="_idIndexMarker098"/> using Python.</p>
			<p>Exporting data to Excel is a common requirement in various data analysis and reporting scenarios. Excel provides a familiar and widely used interface for data visualization, sharing, and further analysis.</p>
			<p>We’ll cover various tasks in the sections ahead, including creating new workbooks, adding sheets to existing workbooks, deleting sheets, and manipulating data within an Excel workbook. Python provides several libraries that make these tasks straightforward and efficient. But first, let’s understand why we need to export data to Excel.</p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor045"/>Why export data to Excel?</h2>
			<p>Exporting data to Excel offers<a id="_idIndexMarker099"/> several benefits. Firstly, Excel provides a user-friendly environment for data exploration and visualization, allowing users to easily sort, filter, and analyze data. Additionally, Excel’s rich formatting capabilities make it suitable for generating professional reports or sharing data with stakeholders who may not have programming knowledge. Furthermore, Excel supports various formulas and functions, enabling users to perform calculations on the exported data easily.</p>
			<p>Let’s see how we can export data to Excel with Python!</p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor046"/>Keeping it simple – exporting data to Excel with pandas</h1>
			<p><code>pandas</code> is a popular data manipulation<a id="_idIndexMarker100"/> library in Python that provides powerful<a id="_idIndexMarker101"/> tools for data<a id="_idIndexMarker102"/> analysis. It also<a id="_idIndexMarker103"/> offers excellent functionality for exporting data to Excel. Using <code>pandas</code>, you can effortlessly transform your data into Excel sheets or workbooks.</p>
			<p><code>pandas</code> provides the <code>DataFrame.to_excel()</code> method, allowing you to export data to an Excel file with just a few lines of code. Here’s an example:</p>
			<pre class="source-code">
import pandas as pd
# Create a DataFrame with sample data
data = {
    'Name': ['John', 'Jane', 'Mike'],
    'Age': [25, 30, 35],
    'City': ['New York', 'London', 'Sydney']
}
df = pd.DataFrame(data)
# Export the DataFrame to an Excel file
df.to_excel('data.xlsx', index=False)</pre>			<p>The code doesn’t return<a id="_idIndexMarker104"/> anything, but it<a id="_idIndexMarker105"/> does have a side<a id="_idIndexMarker106"/> effect – it creates the <code>data.xlsx</code> file with the exported data:</p>
			<div><div><img src="img/B19142_02_3.jpg" alt="Figure 2.3 – Excel export with pandas"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Excel export with pandas</p>
			<p>While <code>pandas</code> is good at simple data export, we may want to have more control over the Excel workbook. The next few subsections cover more advanced Excel manipulation using <code>openpyxl</code>. We will cover the capabilities of <code>openpyxl</code>, starting with the basics such as creating a new workbook<a id="_idIndexMarker107"/> by adding and deleting sheets<a id="_idIndexMarker108"/> up to and including<a id="_idIndexMarker109"/> manipulating data in an existing sheet.</p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor047"/>Advanced mode – openpyxl for Excel manipulation</h1>
			<p>In this section, we will look<a id="_idIndexMarker110"/> at the <code>openpyxl</code> package, which allows for a more nuanced interaction with Excel when writing data.</p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor048"/>Creating a new workbook</h2>
			<p>To start working with Excel sheets<a id="_idIndexMarker111"/> in Python, we need to create a new workbook. <code>openpyxl</code> provides an intuitive API to create, modify, and save Excel workbooks. Here’s an example code snippet that demonstrates creating a new workbook:</p>
			<pre class="source-code">
import openpyxl
# Create a new workbook
workbook = openpyxl.Workbook()</pre>			<p>Once again, the preceding code snippet doesn’t return anything but it does have a side effect – it creates the workbook:</p>
			<div><div><img src="img/B19142_02_4.jpg" alt="Figure 2.4 – Creating a workbook with openpyxl"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – Creating a workbook with openpyxl</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor049"/>Adding sheets to the workbook</h2>
			<p>Once we have a workbook, we can add sheets<a id="_idIndexMarker112"/> to it. Adding sheets allows us to organize data into separate sections or categories. <code>openpyxl</code> provides a simple method, <code>create_sheet()</code>, to add sheets to a workbook. Let’s see an example:</p>
			<pre class="source-code">
import openpyxl
# Create a new workbook
workbook = openpyxl.Workbook()
# Add a new sheet
workbook.create_sheet(title="Sheet2")
# Save the changes
workbook.save("example.xlsx")</pre>			<p>The result is an <code>openpyxl</code> worksheet object we can use going forward. The resulting workbook can then be saved for future use.</p>
			<p>The preceding example attempts to save the workbook you are working with. If the workbook is open in Excel, the attempt will fail, with a hard-to-decipher error message about the COM systems. Make sure you close your Excel instance before attempting to save your work from the Python side! This warning will remain applicable<a id="_idIndexMarker113"/> to most of this book, so keep it in mind for later chapters as well.</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor050"/>Deleting a sheet</h2>
			<p>At times, we may need to remove<a id="_idIndexMarker114"/> a sheet from a workbook. The <code>remove()</code> method in <code>openpyxl</code> allows us to delete a sheet by its name. The following is an example of how you can delete a sheet from a workbook. Please note that we will not save the result, so the stored version of the file remains unchanged:</p>
			<pre class="source-code">
import openpyxl
# Load an existing workbook
workbook = openpyxl.load_workbook("example.xlsx")
# Delete a sheet
sheet_name = "Sheet2"
sheet = workbook[sheet_name]
workbook.remove(sheet)</pre>			<p>As before, the code has a side effect (the deleted sheet) but no return value:</p>
			<div><div><img src="img/B19142_02_5.jpg" alt="Figure 2.5 – Deleting a sheet with openpyxl"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – Deleting a sheet with openpyxl</p>
			<p>In this example, we used the sheet we created previously. The <code>load_workbook()</code> method from <code>openpyxl</code> is used to load the existing workbook, after which the <code>remove()</code> method is used to delete<a id="_idIndexMarker115"/> a sheet specified by name.</p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor051"/>Manipulating an existing workbook</h2>
			<p>Python libraries such as <code>openpyxl</code> provide powerful methods<a id="_idIndexMarker116"/> to manipulate existing Excel workbooks. We can modify cells, apply formatting, insert formulas, and more. Let’s look at an example of how to update<a id="_idIndexMarker117"/> a cell value in an existing workbook:</p>
			<pre class="source-code">
import openpyxl
# Load an existing workbook
workbook = openpyxl.load_workbook("example.xlsx")
# Add a new sheet
workbook.create_sheet(title="Sheet1")
# Select a sheet
sheet_name = "Sheet1"
sheet = workbook[sheet_name]
# Update a cell value
sheet["A1"] = "Hello, World!"
# Save the changes
workbook.save("example.xlsx")</pre>			<p>This code snippet will directly change the value of a cell in the Excel sheet:</p>
			<div><div><img src="img/B19142_02_6.jpg" alt="Figure 2.6 – Updating the value of a cell with openpyxl"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6 – Updating the value of a cell with openpyxl</p>
			<p>The result is as we<a id="_idIndexMarker118"/> expect (keep in mind that the process of deleting the sheet was not saved):</p>
			<div><div><img src="img/B19142_02_7.jpg" alt="Figure 2.7 – The fruit of our efforts – Hell﻿o, World! in A1, Sheet1"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7 – The fruit of our efforts – Hello, World! in A1, Sheet1</p>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor052"/>Choosing between openpyxl and pandas</h1>
			<p>When it comes to exporting <a id="_idIndexMarker119"/>data to Excel, both <code>openpyxl</code> and <code>pandas</code> are excellent choices. <code>openpyxl</code> is a dedicated library for working with Excel files as it provides extensive functionality for creating, modifying, and saving Excel workbooks. On the other hand, <code>pandas</code> offers a high-level data manipulation interface with convenient methods for exporting data to Excel, which is ideal when a simple data dump is all you need.</p>
			<p>If you require fine-grained control over the Excel file’s structure, such as adding formatting, formulas, or charts, <code>openpyxl</code> is a suitable option. It allows you to work directly with the underlying Excel objects, providing more flexibility. On the other hand, if you primarily focus on data manipulation and want a simpler way to export DataFrames to Excel without worrying about Excel-specific features, <code>pandas</code> is a convenient choice. It abstracts away some of the lower-level details and provides a more straightforward interface for exporting data. While <code>openpyxl</code> provides a simple abstracted way of manipulating and controlling sheets, R also has this in packages such as <code>openxlsx</code> and <code>xlsx</code>, both of which provide<a id="_idIndexMarker120"/> their own form of these types of functionalities.</p>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor053"/>Other alternatives</h1>
			<p>Apart from <code>pandas</code> and <code>openpyxl</code>, there are other libraries available for exporting data to Excel from Python. Some<a id="_idIndexMarker121"/> popular alternatives<a id="_idIndexMarker122"/> include <code>XlsxWriter</code>, <code>xlrd</code>, and <code>xlwt</code>. These libraries offer different<a id="_idIndexMarker123"/> features and capabilities, and the choice depends on your specific requirements. <code>XlsxWriter</code>, for example, emphasizes performance and supports advanced Excel features, while <code>xlrd</code> and <code>xlwt</code> provide functionality for reading and writing older Excel file formats (<code>.xls</code>).</p>
			<p>In this section, we explored the benefits of exporting data to Excel, demonstrated how to do so using <code>pandas</code>, went through the process of creating and manipulating Excel sheets using <code>openpyxl</code>, discussed the reasons for choosing <code>openpyxl</code> or <code>pandas</code> based on your needs, and mentioned other alternatives available. By leveraging the power of these libraries, you can seamlessly export your data from Python to Excel, enabling efficient analysis, reporting, and collaboration.</p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor054"/>Summary</h1>
			<p>In <a href="B19142_02.xhtml#_idTextAnchor036"><em class="italic">Chapter 2</em></a>, we explored the process of writing data to Excel using different R and Python libraries and benchmarking their performance. We also discussed creating and manipulating Excel sheets from Python using <code>pandas</code> and <code>openpyxl</code>. By comparing their features and exploring alternatives, you have gained insights into the capabilities of both R and Python for Excel tasks.</p>
			<p>In the next chapter, we will learn how to execute VBA code with R and Python.</p>
		</div>
	</body></html>