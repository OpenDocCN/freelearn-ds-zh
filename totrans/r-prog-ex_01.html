<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Introduction to R</h1>
                
            
            
                
<p class="calibre2">In a world where data is becoming increasingly important, business people and scientists need tools to analyze and process large volumes of data efficiently. R is one of the tools that has become increasingly popular in recent years for data processing, statistical analysis, and data science, and while R has its roots in academia, it is now used by organizations across a wide range of industries and geographical areas.</p>
<p class="calibre2">Some of the important topics covered in this chapter are as follows:</p>
<ul class="calibre11">
<li class="calibre12">History of R and why it was designed the way it was</li>
<li class="calibre12">What the interpreter and the console are and how to use them</li>
<li class="calibre12">How to work with basic data types and data structures of R</li>
<li class="calibre12">How to divide work by using functions in different ways</li>
<li class="calibre12">How to introduce complex logic with control structures</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">What R is and what it isn't</h1>
                
            
            
                
<p class="calibre2">When it comes to choosing software for statistical computing, it's tough to argue against R. Who could dislike a high quality, cross-platform, open source, statistical software product? It has an interactive console for exploratory work. It can run as a scripting language to replicate processes. It has a lot of statistical models built in, so you don't have to reinvent the wheel, but when the base toolset is not enough, you have access to a rich ecosystem of external packages. And, it's free! No wonder R has become a favorite in the age of data.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The inspiration for R – the S language</h1>
                
            
            
                
<p class="calibre2">R was inspired by the S statistical language developed by John Chambers at AT&amp;T. The name S is an allusion to another one-letter-name programming language also developed at AT&amp;T, the famous C language. R was created by Ross Ihaka and Robert Gentleman in the Department of Statistics at the University of Auckland in 1991.</p>
<p class="calibre2">The general S philosophy sets the stage for the design of the R language itself, which many programmers coming from other programming languages find somewhat odd and confusing. In particular, it's important to realize that S was developed to make data analysis as easy as possible. </p>
<p>"We wanted users to be able to begin in an interactive environment, where they did not consciously think of programming. Then as their needs became clearer and their sophistication increased, they should be able to slide gradually into programming, when the language and system aspects would become more important."</p>
<p>– John Chambers</p>
<p class="calibre2">The key part here is the transition from analyst to developer. They wanted to build a language that could easily service both types of users. They wanted to build language that would be suitable for interactive data analysis through a command line but which could also be used to program complex systems, like traditional programming languages.</p>
<p class="calibre2">It's no coincidence that this book is structured that way. We will start doing data analysis first, and we will gradually move toward developing a full and complex system for information retrieval with a web application on top.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">R is a high quality statistical computing system</h1>
                
            
            
                
<p class="calibre2">R is comparable, and often superior, to commercial products when it comes to programming capabilities, complex systems development, graphic production, and community ecosystems. Researchers in statistics and machine learning, as well as many other data-related disciplines, will often publish R packages to accompany their publications. This translates into immediate public access to the very latest statistical techniques and implementations. Whatever model or graphic you're trying to develop, chances are that someone has already tried it, and if not, you can at least learn from their efforts.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">R is a flexible programming language</h1>
                
            
            
                
<p class="calibre2">As we have seen, in addition to providing statistical tools, R is a general-purpose programming language. You can use R to extend its own functionality, automate processes that make use of complex systems, and many other things. It incorporates features from other object-oriented programming languages and has strong foundations for functional programming, which is well suited for solving many of the challenges of data analysis. R allows the user to write powerful, concise, and descriptive code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">R is free, as in freedom and as in free beer</h1>
                
            
            
                
<p class="calibre2">In many ways, a language is successful inasmuch as it creates a platform with which many people can create new things, and R has proven to be very successful in this regard. One key limitation of the S language was that it was only available in a commercial package, but R is free software. Free as in freedom, and free as in free beer.</p>
<p class="calibre2">The copyright for the primary source code for R is held by the R Foundation and is published under <strong class="calibre1">General Public License</strong> (<strong class="calibre1">GPL</strong>). According to the Free Software Foundation (<a href="http://www.fsf.org/" target="_blank" class="calibre4">http://www.fsf.org/</a>), with free software (free as in freedom) you are granted the following four freedoms:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Freedom 0</strong>: Run the program for any purpose</li>
<li class="calibre12"><strong class="calibre1">Freedom 1</strong>: Study how the program works and adapt it to your needs</li>
<li class="calibre12"><strong class="calibre1">Freedom 2</strong>: Redistribute copies so you can help your neighbor</li>
<li class="calibre12"><strong class="calibre1">Freedom 3</strong>: Improve the program and release your improvements to the public</li>
</ul>
<p class="calibre2">These freedoms have allowed R to develop strong prolific communities that include world-class statisticians and programmers as well as many volunteers, who help improve and extend the language. They also allow for R to be developed and maintained for all popular operating systems, and to be easily used by individuals and organizations who wish to do so, possibly sharing their findings in a way that others can replicate their results. Such is the power of free software.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">What R is not good for</h1>
                
            
            
                
<p class="calibre2">No programming language or system is perfect. R certainly has a number of drawbacks, the most common being that it can be painfully slow (when not used correctly). Keep in mind that R is essentially based on 40-year-old technology, going back to the original S system developed at Bell Labs. Therefore, several of its imperfections come from the fact that it was not built in anticipation for the data age we live in now. When R was born, disk and RAM were very expensive and the internet was just getting started. Notions of large-scale data analysis and high-performance computing were rare.</p>
<p class="calibre2">Fast-forward to the present, hardware cost is just a fraction of what it used to be, computing power is available online for pennies, and everyone is interested in collecting and analyzing data at large scale. This surge in data analysis has brought to the forefront two of R's fundamental limitations, the fact that it's single-threaded and memory-bound. These two characteristics drastically slow it down. Furthermore, R is an interpreted dynamically typed language, which can make it even slower. And finally, R has object immutability and various ways to implement object-oriented programming, both of which can make it hard for people, specially those coming from other languages, to write high-quality code if they don't know how to deal with them. You should know that all of the characteristics mentioned in this paragraph are addressed in <a target="_blank" href="part0229.html#6QCGQ0-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 9</a>, <em class="calibre19">Implementing an Efficient Simple Moving Average</em>.</p>
<p class="calibre2">A double-edged sword in R, is that most of its users do not think of themselves as programmers, and are more concerned with results than with process (which is not necessarily a bad thing). This means that much of the R code you can find online is written without regard for elegance, speed, or readability, since most R users do not revise their code to address these shortcomings. This permeates into code that is patchy and not rigorously tested, which in turn produces many edge cases that you must take into account when using low-quality packages. You will do well to keep this in mind.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Comparing R with other software</h1>
                
            
            
                
<p class="calibre2">My intention for this section is not to provide a comprehensive comparison between R and other software, but to simply point out a few of R's most noticeable features. If you can, I encourage you to test other software yourself so that you know first-hand what may be the best tool for the job at hand.</p>
<p class="calibre2">The most noticeable feature of R compared to other statistical software such as SAS, Stata, SPSS, and even Python, is the very large number of packages that it has available. At the time of writing this, there are almost 12,000 packages published in The <strong class="calibre1">Comprehensive R Archive Network</strong> (<strong class="calibre1">CRAN</strong>) (<a href="https://cran.r-project.org/" target="_blank" class="calibre4">https://cran.r-project.org/</a>), and this does not include packages published in other places, such as Git repositories. This enables R to have a very large community and a huge number of tools for data analysis in areas such as finance, mathematics, machine learning, high-performance computing, and many others.</p>
<p class="calibre2">With the exception of Python, R has much more programming capabilities than SAS, Stata, SPSS, and even more so than Python in some respects (for example, in R, you may use different object models). However, efficient and effective R usage requires the use of code which implies a steep learning curve for some people, while Stata and SPSS have graphical user interfaces that guide the user through many of the tasks with point-and-click wizards. In my opinion, this hand-holding, although nice for beginners, quickly becomes an important restriction for people looking to become intermediate to advanced users, and that's where the advantage of programming really shines.</p>
<p class="calibre2">R has one of the best graphics systems among all existing software. The most popular package for producing graphs in R, which we will use extensively in this book, is the <kbd class="calibre9">ggplot2</kbd> package, but there are many other great graphing packages as well. This package allows the modification of virtually every aspect of a graph through its graphics grammar, and is far superior to anything I've seen in SPSS, Stata, SAS, or even Python.</p>
<p class="calibre2">R is a great tool, but it's not the right tool for everything. If you're looking to perform data analysis but don't want to invest the time in learning to program, then software like SAS, Stata, or SPSS may be a better option for you. If you're looking to develop analytical software that is very easily integrated into larger systems and which needs to plug into various interfaces, then Python may be a better tool for the job. However, if you're looking to do a lot of complex data analysis and graphing, and you are going to mostly spend your time focused on these areas, then R is a great choice.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The interpreter and the console</h1>
                
            
            
                
<p class="calibre2">As I mentioned earlier, R is an interpreted language. When you enter an expression into the R console or execute an R script in your operating system's terminal, a program called the interpreter parses and executes the code. Other examples of interpreted languages are Lisp, Python, and JavaScript. Unlike C, C++, and Java, R doesn't require you to explicitly compile your programs before you execute them.</p>
<p class="calibre2">All R programs are composed of a series of expressions. The interpreter begins by parsing each expression, substituting objects for symbols where appropriate, evaluates them, and finally return the resulting objects. We will define each of these concepts in the following sections, but you should understand that this is the basic process through which all R programs go through.</p>
<p class="calibre2">The R console is the most important tool for using R and can be thought of as a wrapper around the interpreter. The console is a tool that allows you to type expressions directly into R and see how it responds. The interpreter will read the expressions and respond with a result or an error message, if there was one. When you execute expressions through the console, the interpreter will pass objects to the <kbd class="calibre9">print()</kbd> function automatically, which is why you can see the result printed below your expressions (we'll cover more on functions later).</p>
<div><img src="img/00005.jpeg" class="calibre20"/></div>
<p class="calibre2"/>
<p class="calibre2">If you've used a command line before (for example, bash in Linux of macOS or cmd.exe in Windows) or a language with an interactive interpreter such as Lisp, Python, or JavaScript, the console should look familiar since it simply is a command-line interface. If not, don't worry. Command-line interfaces are simple to use tools. They are programs that receive code and return objects whose printed representations you see below the code you execute.</p>
<p class="calibre2">When you launch R, you will see a window with the R console. Inside the console you will see a message like the one shown below. This message displays some basic information, including the version of R you're running, license information, reminders about how to get help, and a Command Prompt.</p>
<p>Note that the R version in this case is 3.4.2. The code developed during this book will assume this version. If you have a different version, but in case you end up with some problems, this could be a reason you may want to look into.</p>
<p class="calibre2">You should note that, by default, R will display a greater-than sign (&gt;) at the beginning of the last line of the console, signaling you that it's ready to receive commands. Since R is prompting you to type something, this is called a Command Prompt. When you see the greater-than symbol, R is able to receive more expressions as input. When you don't, it is probably because R is busy processing something you sent, and you should wait for it to finish before sending something else.</p>
<pre>Enter</em> key. When you do, you will see a [1] 3 which is the output you received back from R. Go ahead and execute various arithmetic expressions to get a feel for the console:</pre>
<pre class="mce-root">&gt; 1 + 2
[1] 3</pre>
<p>Note the <kbd class="calibre21">[1]</kbd> that accompanies each returned value. It's there because the result is actually a vector (an ordered collection). The <kbd class="calibre21">[1]</kbd> means that the index of the first item displayed in that row is 1 (in this case, our resulting vector has a single value within).</p>
<p class="calibre2">Finally, you should know that the console provides tools for looking through previous commands. You will probably find that the up and down arrow keys are the most useful. You can scroll through previous commands by pressing them. The up arrow lets you look at earlier commands, and the down arrow lets you look at later commands. If you would like to repeat a previous command with a minor change, or if you need to correct a mistake, you can easily do so using these keys.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Tools to work efficiently with R</h1>
                
            
            
                
<p class="calibre2">In this section we discuss the tools that will help us when working with R.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Pick an IDE or a powerful editor</h1>
                
            
            
                
<p class="calibre2">For efficient code development, you may want to try a more powerful editor or an <strong class="calibre1">Integrated Development Environment</strong> (<strong class="calibre1">IDE</strong>). The most popular IDE for R is RStudio (<a href="https://www.rstudio.com/" target="_blank" class="calibre4">https://www.rstudio.com/</a>). It offers an impressive feature set that makes interacting with R much easier. If you're new to R, and programming in general, this is probably the way to go. As you can see in the image below it wraps the console (right side) within a larger application which offers a lot of functionality, and in this case, it is displaying the help system (left side). Furthermore, RStudio offers tabs to navigate files, browse installed packages, visualize plots, among other features, as well as a large amount of configuration options under the top menu dropdowns.</p>
<p class="calibre2">Throughout this book, we will not use any functionality provided by RStudio. All I will show you is pure R functionality. I decided to proceed this way to make sure that the book is useful for any R programmer, including those who do not use RStudio. For RStudio users, this means that there may be easier ways to accomplish some of the tasks I will show, and instead of programming a few lines, you could simply click some buttons. If that's something you prefer, I encourage you to take a look through the excellent RStudio Essential webinars,which can be found in RStudio's website at <a href="https://www.rstudio.com/resources/webinars/?wvideo=lxel3j2kos" target="_blank" class="calibre4">https://www.rstudio.com/resources/webinars/?wvideo=lxel3j2kos</a>, as well as Stanford's Introduction to R, RStudio (<a href="https://web.stanford.edu/class/stats101/intro/intro-lab01.html" target="_blank" class="calibre4">https://web.stanford.edu/class/stats101/intro/intro-lab01.html</a>).</p>
<p>You should be careful to avoid the common mistake of referring to R as RStudio. Since many people are introduced to R through RStudio, they think that RStudio is actually R, which it is not. RStudio is a wrapper around R to extend it's functionality, and is technically known as an IDE.</p>
<p class="calibre2">Experienced programmers may prefer to work with other tools they already know and love and have used for many years. For example, in my case, I prefer to use Emacs (<a href="https://www.gnu.org/software/emacs/" target="_blank" class="calibre4">https://www.gnu.org/software/emacs/</a>) for any programming I do. Emacs is a very powerful text editor that you can programatically extend to work the way you want it to by using a programming language known as <strong class="calibre1">Elisp</strong>, which is a Lisp extension. In case you use Emacs too, the <kbd class="calibre9">ess</kbd> package is all you really need.</p>
<div><img src="img/00006.jpeg" class="calibre22"/></div>
<p class="calibre2">If you're going to use Emacs, I encourage you to take a look through the <kbd class="calibre9">ess</kbd> package's documentation (<a href="https://ess.r-project.org/Manual/ess.html" target="_blank" class="calibre4">https://ess.r-project.org/Manual/ess.html</a>) and Johnson's presentation titled <em class="calibre19">Emacs Has No Learning Curve, University of Kansas, 2015</em> (<a href="http://pj.freefaculty.org/guides/Rcourse/emacs-ess/emacs-ess.pdf" target="_blank" class="calibre4">http://pj.freefaculty.org/guides/Rcourse/emacs-ess/emacs-ess.pdf</a>). If you use Vim, Sublime Text, Atom, or other similar tools, I'm confident you can find useful packages as well.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The send to console functionality</h1>
                
            
            
                
<p class="calibre2">The base R installation provides the console environment we mentioned in the previous section. This console is really all you need to work with R, but it will quickly become cumbersome to type everything directly into it and it may not be your best option. To efficiently work with R, you need to be able to experiment and iterate as fast as you can. Doing so will accelerate your learning curve and productivity.</p>
<p class="calibre2">Whichever tool you use, the key functionality you need is to be able to easily send code snippets into the console without having to type them yourself, or copying them from your editor and pasting them into the console. In RStudio, you can accomplish this by clicking on the Run or Source button in the top-right corner of the code editor panel. In Emacs, you may use the ess-eval-region command.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The efficient write-execute loop</h1>
                
            
            
                
<p class="calibre2">One of the most productive ways to work with R, especially when learning it, is to use the <em class="calibre19">write-execute</em> loop, which makes use of the send to console functionality mentioned in the previous section. This will allow you to do two very important things: develop your code through small and quick iterations, which allow you to see step-by-step progress until you converge to the behavior you seek, and save the code you converged to as your final result, which can be easily reproduced using the source code file you used for your iterations. R source code files use the <kbd class="calibre9">.R</kbd> extension.</p>
<p class="calibre2">Assuming you have a source code file ready to send expressions to the console, the basic steps through the write-execute loop are as follows:</p>
<ol class="calibre14">
<li class="calibre12" value="1">Define what behavior you're looking to implement with code.</li>
<li class="calibre12" value="2">Write the minimal amount of code necessary to achieve one piece of the behavior you seek in your implementation.</li>
<li class="calibre12" value="3">Use the send to console functionality to verify that the result in the console is what you expected, and if it's not, to identify possible causes.</li>
<li class="calibre12" value="4">If it's not what you expected, go back to the second step with the purpose of fixing the code until it has the intended piece of behavior.</li>
<li class="calibre12" value="5">If it's what you expected, go back to the second step with the purpose of extending the code with another piece of the behavior, until convergence.</li>
</ol>
<p class="calibre2">This write-execute loop will become second nature to you as you start using it, and when it does, you'll be a more productive R programmer. It will allow you to diagnose issues faster, to quickly experiment with a few ways to accomplishing the same behavior to find which one seems best for your context, and once you have working code, it will also allow you to clean your implementation to keep the same behavior but have better or more readable code.</p>
<p>For experienced programmers, this should be a familiar process, and it's very similar to <strong class="calibre23">Test-Driven Development</strong> (<strong class="calibre23">TDD</strong>), but instead of using unit-tests to automatically test the code, you verify the output in the console in each iteration, and you don't have a set of tests to re-test each iteration. Even though TDD will not be used in this book, you can definitely use it in R.</p>
<p class="calibre2">I encourage you to use this write-execute loop to work through the examples presented in this book. At times, we will show step-by-step progress so that you understand the code better, but it's practically impossible to show all of the write-execute loop iterations I went through to develop it, and much of the knowledge you can acquire comes from iterating this way.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Executing R code in non-interactive sessions</h1>
                
            
            
                
<p class="calibre2">Once your code has the functionality you were looking to implement, executing it through an interactive session using the console may not be the best way to do so. In such cases, another option you have is to tell your computer to directly execute the code for you, in a non-interactive session. This means that you won't be able to type commands into the console, but you'll get the benefit of being able to configure your computer to automatically execute code for you, or to integrate it into larger systems where R is only one of many components. This is known as batch mode.</p>
<p class="calibre2">To execute code in the batch mode, you have two options: the old R <kbd class="calibre9">CMD BATCH</kbd> command which we won't look into, and the newer Rscript command, which we will. The <strong class="calibre1">Rscript</strong> is a command that you can execute within your computer's terminal. It receives the name of a source code file and executes its contents.</p>
<p>In the following example, we will make use of various concepts that we will explain in later sections, so if you don't feel ready to understand it, feel free to skip it now and come back to it later.</p>
<p class="calibre2">Suppose you have the following code in a file named greeting.R. It gets the arguments passed through the command line to Rscript through the args object created with the <kbd class="calibre9">commandArgs()</kbd> function, assigns the corresponding values to the greeting and name variables, and finally prints a vector that contains those values.</p>
<pre class="mce-root">args     &lt;- commandArgs(TRUE)
greeting &lt;- args[1]
name     &lt;- args[2]

print(c(greeting, name))</pre>
<p class="calibre2">Once ready, you may use the Rscript command to execute it from your Terminal (not from within your R console) as is shown ahead.  The result shows the vector with the greeting and name variable values you passed it.</p>
<p>When you see a Command Prompt that begins with the <kbd class="calibre21">$</kbd> symbol instead of of the <kbd class="calibre21">&gt;</kbd> symbol, it means that you should execute that line in your computer's Terminal, not in the R console.</p>
<pre class="mce-root"><strong class="calibre1">$ Rscript greeting.R Hi John
[1] "Hi" "John"</strong></pre>
<p class="calibre2">Note that if you simply execute the file without any arguments, they will be passed as NA values, which allows you to customize your code to deal with such situations:</p>
<pre class="mce-root"><strong class="calibre1">$ Rscript greeting.R
[1] NA NA</strong></pre>
<p class="calibre2">This was a very simple example, but the same mechanism can be used to execute much more complex systems, like the one we will build in the final chapters of this book to constantly retrieve real-time price data from remote servers.</p>
<p class="calibre2">Finally, if you want to provide a mechanism that is closer to the one in Python, you may want to look into the optparse package to create command-line help pages as well as to parse arguments.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How to use this book</h1>
                
            
            
                
<p class="calibre2">To make the most out of this book, you should recreate on your own the examples shown throughout, and make sure that you understand what each of them is doing in detail. If at some point you feel confused, it's not too difficult to do a couple of searches online to clarify things for yourself. However, I highly recommend that you look into the following books as well, which go into more detail on some of the concepts and ideas presented in this book, and are considered very good references for R programmers:</p>
<ul class="calibre11">
<li class="calibre12"><em class="calibre19">R in a Nutshell, by Adler, O'Reilly, 2010</em></li>
<li class="calibre12"><em class="calibre19">The Art of R Programming, by Matloff, No Starch Press, 2011</em></li>
<li class="calibre12"><em class="calibre19">Advanced R, by  Wickham, CRC Press, 2015</em></li>
<li class="calibre12"><em class="calibre19">R Programming for Data Science, by Peng, LeanPub, 2016</em></li>
</ul>
<p class="calibre2">Sometimes all you need to do to clarify something is use R's help system. To get help on a function, you may use the question mark notation, like <kbd class="calibre9">?function_name</kbd>, but in case you want to search for help on a topic, you may use the <kbd class="calibre9">help.search()</kbd> function, like <kbd class="calibre9">help.search</kbd> <em class="calibre19">(regression).</em> This can be helpful if you know what topic you're interested in but can't remember the actual name of the function you want to use. Another way of invoking such functionality is using the double question mark notation, like <kbd class="calibre9">??</kbd> regression.</p>
<p class="calibre2">Keep in mind that topics in this book are interconnected and not linearly ordered, which means that at times it will seem that we are jumping around. When that happens, it's because a topic can be seen through different points of view. That's why, to make the most out of this book, you should experiment as much as you can in the console and build code progressively using the write-execute loop mentioned earlier. If you simply replicate the code exactly as is shown, you may miss some of the learning that you could have gotten had you built the systems step by step.</p>
<p class="calibre2">Finally, you should know that this book is meant to show how to use R through somewhat real examples, and as such, does not provide too much technical depth or discussion on some of the topics presented. Furthermore, since my objective is to get you quickly working with the real examples, in this first chapter, I explain R fundamentals very briefly, just to introduce the minimum amount of knowledge you need to follow through the real examples presented in the following chapters. Therefore, you should not think that the explanations presented in this chapter are enough for you to understand R's basic constructs. If you're looking for a more in-depth introduction to R fundamentals, you may want to take a look at the references we mentioned previously.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Tracking state with symbols and variables</h1>
                
            
            
                
<p class="calibre2">Like most programming languages, R lets you assign values to variables and refer to these objects by name. The names you use to refer to variables are called symbols in R. This allows you to keep some information available in case it's needed at a later point in time. These variables may contain any type of object available in R, even combinations of them when using lists, as we will see in a later section in this chapter. Furthermore, these objects are immutable, but that's a topic for <a target="_blank" href="part0229.html#6QCGQ0-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 9</a>, <em class="calibre19">Implementing an Efficient Simple Moving Average</em>.</p>
<p class="calibre2">In R, the assignment operator is <kbd class="calibre9">&lt;-</kbd>, which is a less-than symbol (<kbd class="calibre9">&lt;</kbd>) followed by a dash (<kbd class="calibre9">-</kbd>). If you have worked with algorithm pseudo code before, you may find it familiar. You may also use the single equals symbol (<kbd class="calibre9">=</kbd>) for assignments, similar to many other languages, but I prefer to stick to the <kbd class="calibre9">&lt;-</kbd> operator.</p>
<p class="calibre2">An expression like <kbd class="calibre9">x &lt;- 1</kbd> means that the value <kbd class="calibre9">1</kbd> is assigned to the  <kbd class="calibre9">x</kbd> symbol, which can be thought of as a variable. You can also assign the other way around, meaning that with an expression like <kbd class="calibre9">1 -&gt; x </kbd>we would have the same effect as we did earlier. However, the assignment from left to right is very rarely used, and is more of a convenience feature in case you forget the assignment operator at the beginning of a line in the console.</p>
<p class="calibre2">Note that the value substitution is done at the time when the value is assigned to <kbd class="calibre9">z</kbd>, not at the time when <kbd class="calibre9">z</kbd> is evaluated. If you enter the following code into the console, you can see that the second time <kbd class="calibre9">z</kbd> is printed, it still has the value that y had when it was used to assign to it, not the y value assigned afterward:</p>
<pre class="mce-root">x &lt;- 1
y &lt;- 2
z &lt;- c(x, y)
z<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 1 2</strong>
<br class="title-page-name"/>y &lt;- 3
z<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 1 2</strong></pre>
<p class="calibre2">It's easy to use variable names like <kbd class="calibre9">x</kbd>, <kbd class="calibre9">y</kbd>, and <kbd class="calibre9">z</kbd>, but using them has a high cost for real programs. When you use names like that, you probably have a very good idea of what values they will contain and how they will be used. In other words, their intention is clear for you. However, when you give your code to someone else or come back to it after a long period of time, those intentions may not be clear, and that's when cryptic names can be harmful. In real programs, your names should be self descriptive and instantly communicate intention.</p>
<p class="calibre2">For a deeper discussion about this and many other topics regarding high-quality code, take a look at Martin's excellent book <em class="calibre19">Clean Code: A Handbook of Agile Software Craftsmanship, Prentice Hall, 2008</em>.</p>
<p class="calibre2">Standard object names in R should only contain alphanumeric characters (numbers and ASCII letters), underscores (<kbd class="calibre9">_</kbd>), and, depending on context, even periods (<kbd class="calibre9">.</kbd>). However, R will allow you to use very cryptic strings if you want. For example, in the following code, we show how the variable <kbd class="calibre9">!A @B #C $D %E ^F</kbd> name is used to contain a vector with three integers. As you can see, you are even allowed to use spaces. You can use this non-standard name provided that you wrap the string with backticks (<kbd class="calibre9">`</kbd>):</p>
<pre class="mce-root">`!A @B #C $D %E ^F` &lt;- c(1, 2, 3)
`!A @B #C $D %E ^F`<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 1 2 3</strong></pre>
<p class="calibre2">It goes without saying that you should avoid those names, but you should be aware they exist because they may come in handy when using some of R's more advanced features. These types of variable names are not allowed in most languages, but R is flexible in that way. Furthermore, the example goes to show a common theme around R programming: it is so flexible that if you're not careful, you will end up shooting yourself in the foot. It's not too rare for someone to be very confused about some code because they assumed R would behave a certain way (for example, raise an error under certain conditions) but don't explicitly test for such behavior, and later find that it behaves differently.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Working with data types and data structures</h1>
                
            
            
                
<p class="calibre2">This section summarizes the most important data types and data structures in R. In this brief overview, we won't discuss them in depth. We will only show a couple of examples that will allow you to understand the code shown throughout this book. If you want to dig deeper into them, you may look into their documentation or some of the references pointed out in this chapter's introduction.</p>
<p class="calibre2">The basic data types in R are numbers, text, and Boolean values (<kbd class="calibre9">TRUE</kbd> or <kbd class="calibre9">FALSE</kbd>), which R calls numerics, characters, and logicals, respectively. Strictly speaking, there are also types for integers, complex numbers, and raw data (bytes), but we won't use them explicitly in this book. The six basic data structures in R are vectors, factors, matrices, data frames, and lists, which we will summarize in the following sections.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Numerics</h1>
                
            
            
                
<p class="calibre2">Numbers in R behave pretty much as you would mathematically expect them to. For example, the operation <kbd class="calibre9">2 / 3</kbd> performs real division, which results in <kbd class="calibre9">0.6666667</kbd> in R. This natural numeric behavior is very convenient for data analysis, as you don't need to pay too much attention when using numbers of different types, which may require special handling in other languages. Also the mathematical priorities for operators applies, as well the use of parenthesis.</p>
<p class="calibre2">The following example shows how variables can be used within operations, and how operator priorities are handled. As you can see, you may mix the use of variables with values when performing operations:</p>
<pre class="mce-root">x &lt;- 2
y &lt;- 3
z &lt;- 4
(x * y + z) / 5<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 2</strong></pre>
<p class="calibre2">The modulo operation can be performed with the <kbd class="calibre9">%%</kbd> symbol, while integer division can be performed with the <kbd class="calibre9">%/%</kbd> symbol:</p>
<pre class="mce-root">7 %% 3<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 1</strong>
7 %/% 3<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 2</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Special values</h1>
                
            
            
                
<p class="calibre2">There are a few special values in R. The NA values are used to represent missing values, which stands for not available. If a computation results in a number that is too big, R will return Inf for a positive number and -Inf for a negative number, meaning positive and negative infinity, respectively. These are also returned when a number is divided by 0. Sometimes a computation will produce a result that makes little sense. In these cases, we will get a NaN, which stands for not a number. And, finally, there is a null object, represented by NULL. The symbol NULL always points to the same object (which is a data type on its own) and is often used as a default argument in functions to mean that no value was passed through. You should know that <kbd class="calibre9">NA</kbd>, <kbd class="calibre9">Inf</kbd>, <kbd class="calibre9">-Inf</kbd>, <kbd class="calibre9">NaN</kbd>, and <kbd class="calibre9">NULL </kbd>are not substitutes for each other.</p>
<p>There are specific NA values for numerics, characters, and logicals, but we will stick to the simple NA, which is internally treated as a logical.</p>
<p class="calibre2">In the following example, you can see how these special values behave when used among themselves in R. Note that 1 / 0 results in <kbd class="calibre9">Inf</kbd>, <kbd class="calibre9">0 / 0</kbd>, <kbd class="calibre9">Inf - Inf</kbd>, and <kbd class="calibre9">Inf / Inf</kbd> results in undefined represented by <kbd class="calibre9">NaN</kbd>, but <kbd class="calibre9">Inf + Inf</kbd>, <kbd class="calibre9">0 / Inf</kbd>, and <kbd class="calibre9">Inf / 0</kbd>, result in <kbd class="calibre9">Inf</kbd>, <kbd class="calibre9">0</kbd>, and <kbd class="calibre9">Inf</kbd>, respectively. It's no coincidence that these results resemble mathematical definitions. Also note that any operation including <kbd class="calibre9">NaN</kbd> or <kbd class="calibre9">NA</kbd> will also result in <kbd class="calibre9">NaN</kbd> and <kbd class="calibre9">NA</kbd>, respectively:</p>
<pre class="mce-root">1 / 0<br class="title-page-name"/><strong class="calibre1">#&gt; [1] Inf</strong>
-1 / 0<br class="title-page-name"/><strong class="calibre1">#&gt; [1] -Inf</strong>
0 / 0<br class="title-page-name"/><strong class="calibre1">#&gt; [1] NaN</strong>
Inf + Inf<br class="title-page-name"/><strong class="calibre1">#&gt; [1] Inf</strong>
Inf - Inf<br class="title-page-name"/><strong class="calibre1">#&gt; [1] NaN</strong>
Inf / Inf<br class="title-page-name"/><strong class="calibre1">#&gt; [1] NaN</strong>
Inf / 0<br class="title-page-name"/><strong class="calibre1">#&gt; [1] Inf</strong>
0 / Inf<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 0</strong>
Inf / NaN<br class="title-page-name"/><strong class="calibre1">#&gt; [1] NaN</strong>
Inf + NA<br class="title-page-name"/><strong class="calibre1">#&gt; [1] NA</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Characters</h1>
                
            
            
                
<p class="calibre2">Text can be used just as easily, you just need to remember to use quotation marks (" ") around it. The following example shows how to save the text Hi, there! and "10" in two variables. Note that since "10.5" is surrounded by quotation marks, it is text and not a numeric value. To find what type of object you're actually dealing with you can use the <kbd class="calibre9">class()</kbd>, <kbd class="calibre9">typeof()</kbd>, and <kbd class="calibre9">str()</kbd> (short for structure) functions to get the metadata for the object in question.</p>
<p class="calibre2">In this case, since the y variable contains text, we can't multiply it by 2, as is seen in the error we get. Also, if you want to know the number of characters in a string, you can use the <kbd class="calibre9">nchar()</kbd> function, as follows:</p>
<pre class="mce-root">x &lt;- "Hi, there!"
y &lt;- "10"
class(y)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "character"</strong>
typeof(y)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "character"</strong>
str(y)<br class="title-page-name"/><strong class="calibre1">#&gt; chr "10"</strong>
y * 2<br class="title-page-name"/><strong class="calibre1">#&gt; Error in y * 2: non-numeric argument to binary operator</strong>
nchar(x)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 10</strong>
nchar(y)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 2</strong></pre>
<p class="calibre2">Sometimes, you may have text information, as well as numeric information that you want to combine into a single string. In this case, you should use the <kbd class="calibre9">paste()</kbd> function. This function receives an arbitrary number of unnamed arguments, which is something we will define more precisely in a later section in this chapter. It then transforms each of these arguments into characters, and returns a single string with all of them combined. The following code shows such an example. Note how the numeric value of 10 in y was automatically transformed into a character type so that it could be pasted inside the rest of the string:</p>
<pre class="mce-root">x &lt;- "the x variable"
y &lt;- 10
paste("The result for", x, "is", y)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "The result for the x variable is 10"</strong></pre>
<p class="calibre2">Other times, you will want to replace some characters within a piece of text. In that case, you should use the <kbd class="calibre9">gsub()</kbd> function, which stands for global substitution. This function receives the string to be replaced as its first argument, the string to replace with as its second argument, and it will return the text in the third argument with the corresponding replacements:</p>
<pre class="mce-root">x &lt;- "The ball is blue"
gsub("blue", "red", x)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "The ball is red"</strong></pre>
<p class="calibre2">Yet other times, you will want to know whether a string contains a substring, in which case you should use the <kbd class="calibre9">gprel()</kbd> function. The name for this function comes from terminal command known as grep, which is an acronym for global regular expression print (yes, you can also use regular expressions to look for matches). The l at the end of <kbd class="calibre9">grepl()</kbd> comes from the fact that the result is a logical:</p>
<pre class="mce-root">x &lt;- "The sky is blue"
grepl("blue", x)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] TRUE</strong>
grepl("red", x)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] FALSE</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Logicals</h1>
                
            
            
                
<p class="calibre2">Logical vectors contain Boolean values, which can only be <kbd class="calibre9">TRUE</kbd> or <kbd class="calibre9">FALSE</kbd>. When you want to create logical variables with such values, you must avoid using quotation marks around them and remember that they are all capital letters, as shown here. When programming in R, logical values are commonly used to test a condition, which is in turn used to decide which branch from a complex program we should take. We will look at examples for this type of behavior in a later section in this chapter:</p>
<pre class="mce-root">x &lt;- TRUE</pre>
<p class="calibre2">In R, you can easily convert values among different types with the <kbd class="calibre9">as.*()</kbd> functions, where <kbd class="calibre9">*</kbd> is used as a wildcard which can be replaced with character, numeric, or logical to convert among these types. The functions work by receiving an object of a different type from what the function name specifies and return the object parsed into the specified type if possible, or return an <kbd class="calibre9">NA</kbd> if it's not possible. The following example shows how to convert the <kbd class="calibre9">TRUE</kbd> string into a logical value, which in this case non-surprisingly turns out to be the logical <kbd class="calibre9">TRUE</kbd>:</p>
<pre class="mce-root">as.logical("TRUE")<br class="title-page-name"/><strong class="calibre1">#&gt; [1] TRUE</strong></pre>
<p class="calibre2">Converting from characters and numerics into logicals is one of those things that is not very intuitive in R. The following table shows some of this behavior. Note that even though the <kbd class="calibre9">true</kbd> string (all lowercase letters) is not a valid logical value when removing quotation marks, it is converted into a <kbd class="calibre9">TRUE</kbd> value when applying the <kbd class="calibre9">as.logical()</kbd> to it, for compatibility reasons. Also note that since T is a valid logical value, which is a shortcut for <kbd class="calibre9">TRUE</kbd>, it's corresponding text is also accepted as meaning such a value. The same logic applies to <kbd class="calibre9">false</kbd> and <kbd class="calibre9">F</kbd>. Any other string will return an <kbd class="calibre9">NA</kbd> value, meaning that the string could not be parsed as a logical value. Also note that 0 will be parsed as <kbd class="calibre9">FALSE</kbd>, but any other numeric value, including Inf, will be converted to a <kbd class="calibre9">TRUE</kbd> value. Finally, note that both <kbd class="calibre9">NA </kbd>and <kbd class="calibre9">NaN </kbd>will be parsed, returning NA in both cases.</p>
<p class="calibre2">The <kbd class="calibre9">as.character()</kbd> and <kbd class="calibre9">as.numeric()</kbd> functions have less counter-intuitive behavior, and I will leave you to explore them on your own. When you do, try to test as many edge cases as you can. Doing so will help you foresee possible issues as you develop your own programs.</p>
<div><img src="img/00007.jpeg" class="calibre24"/></div>
<p class="calibre2">Before we move on, you should know that these data structures can be organized by their dimensionality and whether they're homogeneous (all contents must be of the same type) or heterogeneous (the contents can be of different types). Vectors, matrices, and arrays are homogeneous data structures, while lists and data frames are heterogeneous. Vectors and lists have a single dimension, matrices and data frames have two dimensions, and arrays can have as many dimensions as we want.</p>
<div><img src="img/00008.jpeg" class="calibre25"/></div>
<p>When it comes to dimensions, arrays in R are different from arrays in many other languages, where you would have to create an array of arrays to produce a two-dimensional structure, which is not necessary in R.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Vectors</h1>
                
            
            
                
<p class="calibre2">The fundamental data type in R is the vector, which is an ordered collection of values. The first thing you should know is that unlike other languages, single values for numbers, strings, and logicals, are special cases of vectors (vectors of length one), which means that there's no concept of scalars in R. A vector is a one-dimensional data structure and all of its elements are of the same data type.</p>
<p class="calibre2">The simplest way to create a vector is with the <kbd class="calibre9">c()</kbd> function, which stands for combine, and coerces all of its arguments into a single type. The coercion will happen from simpler types into more complex types. That is, if we create a vector which contains logicals, numerics, and characters, as the following example shows, our resulting vector will only contain characters, which are the more complex of the three types. If we create a vector that contains logicals and numerics, our resulting vector will be numeric, again because it's the more complex type.</p>
<p class="calibre2">Vectors can be named or unnamed. Unnamed vector elements can only be accessed through positional references, while named vectors can be accessed through positional references as well as name references. In the example below, the y vector is a named vector, where each element is named with a letter from A to I. This means that in the case of x, we can only access elements using their position (the first position is considered as 1 instead of the 0 used in other languages), but in the case of y, we may also use the names we assigned.</p>
<p class="calibre2">Also note that the special values we mentioned before, that is NA, NULL, NaN, and Inf, will be coerced into characters if that's the more complex type, except NA, which stays the same. In case coercion is happening toward numerics, they all stay the same since they are valid numeric values. Finally, if we want to know the length of a vector, simply call the <kbd class="calibre9">length()</kbd> function upon it:</p>
<pre class="mce-root">x &lt;- c(TRUE, FALSE, -1, 0, 1, "A", "B", NA, NULL, NaN, Inf)
x<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "TRUE" "FALSE" "-1" "0" "1" "A" "B" NA</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [9] "NaN" "Inf"</strong>
x[1]<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "TRUE"</strong>
x[5]<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "1"</strong>
y &lt;- c(A=TRUE, B=FALSE, C=-1, D=0, E=1, F=NA, G=NULL, H=NaN, I=Inf)
y<br class="title-page-name"/><strong class="calibre1">#&gt; A B  C D E F  H   I</strong><br class="title-page-name"/><strong class="calibre1">#&gt; 1 0 -1 0 1 NA NaN Inf</strong>
y[1]<br class="title-page-name"/><strong class="calibre1">#&gt; A</strong><br class="title-page-name"/><strong class="calibre1">#&gt; 1</strong><br class="title-page-name"/>y["A"]<br class="title-page-name"/><strong class="calibre1">#&gt; A</strong><br class="title-page-name"/><strong class="calibre1">#&gt; 1</strong><br class="title-page-name"/>y[5]<br class="title-page-name"/><strong class="calibre1">#&gt; E</strong><br class="title-page-name"/><strong class="calibre1">#&gt; 1</strong><br class="title-page-name"/>y["E"]<br class="title-page-name"/><strong class="calibre1">#&gt; E</strong><br class="title-page-name"/><strong class="calibre1">#&gt; 1</strong><br class="title-page-name"/>length(x)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 10</strong><br class="title-page-name"/>length(y)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 8</strong></pre>
<p class="calibre2">Furthermore, we can select sets or ranges of elements using vectors with index numbers for the values we want to retrieve. For example, using the selector c(1, 2) would retrieve the first two elements of the vector, while using the c(1, 3, 5) would return the first, third, and fifth elements. The : function (yes, it's a function even though we don't normally use the function-like syntax we have seen so far in other examples to call it), is often used as a shortcut to create range selectors. For example, the 1:5 syntax means that we want a vector with elements 1 through 5, which would be equivalent to explicitly using c(1, 2, 3, 4, 5). Furthermore, if we send a vector of logicals, which must have the same length as the vector we want to retrieve values from, each of the logical values will be associated to the corresponding position in the vector we want to retrieve from, and if the corresponding logical is <kbd class="calibre9">TRUE</kbd>, the value will be retrieved, but if it's <kbd class="calibre9">FALSE</kbd>, it won't be. All of these selection methods are shown in the following example:</p>
<pre class="mce-root">x[c(1, 2, 3, 4, 5)]<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "TRUE" "FALSE" "-1" "0" "1"</strong><br class="title-page-name"/>x[1:5]
<strong class="calibre1">#&gt; [1] "TRUE" "FALSE" "-1" "0" "1"</strong><br class="title-page-name"/>x[c(1, 3, 5)]<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "TRUE" "-1" "1"</strong><br class="title-page-name"/>x[c(TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, <br class="title-page-name"/>    FALSE, TRUE, FALSE, TRUE)]<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "TRUE" "-1" "1" "B" "NaN" NA</strong></pre>
<p class="calibre2">Next we will talk about operation among vectors. In the case of numeric vectors, we can apply operations element-to-element by simply using operators as we normally would. In this case, R will match the elements of the two vectors pairwise and return a vector. The following example shows how two vectors are added, subtracted, multiplied, and divided in an element-to-element way. Furthermore, since we are working with vectors of the same length, we may want to get their dot-product (if you don't know what a dot-product is, you may take a look at <a href="https://en.wikipedia.org/wiki/Dot_product" target="_blank" class="calibre4">https://en.wikipedia.org/wiki/Dot_product</a>), which we can do using the <kbd class="calibre9">%*%</kbd> operator, which performs matrix-like multiplications, in this case vector-to-vector:</p>
<pre class="mce-root">x &lt;- c(1, 2, 3, 4)<br class="title-page-name"/>y &lt;- c(5, 6, 7, 8)<br class="title-page-name"/>x + y<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 6 8 10 12</strong><br class="title-page-name"/>x - y<br class="title-page-name"/><strong class="calibre1">#&gt; [1] -4 -4 -4 -4</strong><br class="title-page-name"/>x * y<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 5 12 21 32</strong><br class="title-page-name"/>x / y<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 0.2000 0.3333 0.4286 0.5000</strong><br class="title-page-name"/>x %*% y<br class="title-page-name"/><strong class="calibre1">#&gt; [,1]</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1,] 70</strong></pre>
<p class="calibre2">If you want to combine multiple vectors into a single one, you can simply use the <kbd class="calibre9">c()</kbd> recursively on them, and it will flatten them for you automatically. Let's say we want to combine the x and y into the z such that the y elements appear first. Furthermore, suppose that after we do we want to sort them, so we apply the <kbd class="calibre9">sort()</kbd> function on z:</p>
<pre class="mce-root">z &lt;- c(y, x)<br class="title-page-name"/>z<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 5 6 7 8 1 2 3 4</strong><br class="title-page-name"/>sort(z)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 1 2 3 4 5 6 7 8</strong></pre>
<p class="calibre2">A common source for confusion is how R deals with vectors of different lengths. If we apply an element-to-element operation, as the ones we covered earlier, but using vectors of different lengths, we may expect R to throw an error, as is the case in other languages. However, it does not. Instead, it repeats vector elements in order until they all have the same length. The following example shows three vectors, each of different lengths, and the result of adding them together.</p>
<p class="calibre2">The way R is configured by default, you will actually get a warning message to let you know that the vectors you operated on were not of the same length, but since R can be configured to avoid showing warnings, you should not rely on them:</p>
<pre class="mce-root">c(1, 2) + c(3, 4, 5) + c(6, 7, 8, 9)<br class="title-page-name"/><strong class="calibre1">#&gt; Warning in c(1, 2) + c(3, 4, 5): <br class="title-page-name"/>       longer object length is not a multiple of</strong><br class="title-page-name"/><strong class="calibre1">#&gt; shorter object length</strong><br class="title-page-name"/><strong class="calibre1">#&gt; Warning in c(1, 2) + c(3, 4, 5) + c(6, 7, 8, 9): <br class="title-page-name"/>       longer object length is</strong><br class="title-page-name"/><strong class="calibre1">#&gt; not a multiple of shorter object length</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 10 13 14 13</strong></pre>
<p class="calibre2">The first thing that may come to mind is that the first vector is expanded into <kbd class="calibre9">c(1, 2, 1, 2)</kbd>, the second vector is expanded into <kbd class="calibre9">c(3, 4, 5, 3)</kbd>, and the third one is kept as is, since it's the largest one. Then if we add these vectors together, the result would be <kbd class="calibre9">c(10, 13, 14, 14)</kbd>. However, as you can see in the example, the result actually is <kbd class="calibre9">c(10, 13, 14, 13)</kbd>. So, what are we missing? The source of confusion is that R does this step by step, meaning that it will first perform the addition <kbd class="calibre9">c(1, 2) + c(3, 4, 5)</kbd>, which after being expanded is <kbd class="calibre9">c(1, 2, 1) + c(3, 4, 5)</kbd> and results in <kbd class="calibre9">c(4, 6, 6)</kbd>, then given this result, the next step that R performs is <kbd class="calibre9">c(4, 6, 6) + c(6, 7, 8, 9)</kbd>, which after being expanded is <kbd class="calibre9">c(4, 6, 6, 4) + c(6, 7, 8, 9)</kbd>, and that's where the result we get comes from. It can be confusing at first, but just remember to imagine the operations step by step.</p>
<p class="calibre2">Finally, we will briefly mention a very powerful feature in R, known as vectorization. Vectorization means that you apply an operation to a vector at once, instead of independently doing so to each of its elements. This is a feature you should get to know quite well. Programming without it is considered to be bad R code, and not just for syntactic reasons, but because vectorized code takes advantage of many internal optimizations in R, which results in much faster code. We will show different ways of vectorizing code in <a target="_blank" href="part0229.html#6QCGQ0-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 9</a>, <em class="calibre19">Implementing An Efficient Simple Moving Average</em>, and in this chapter, we will see an example, followed by a couple more in following sections.</p>
<p class="calibre2">Even though the phrase vectorized code may seem scary or magical at first, in reality, R makes it quite simple to implement in some cases. For example, we can square each of the elements in the x vector by using the x symbol as if it were a single number. R is intelligent enough to understand that we want to apply the operation to each of the elements in the vector. Many functions in R can be applied using this technique:</p>
<pre class="mce-root">x^2<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 1 4 9 16</strong></pre>
<p class="calibre2">We will see more examples that really showcase how vectorization can shine in the following section about functions, where we will see how to apply vectorized operations even when the operations depend on other parameters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Factors</h1>
                
            
            
                
<p class="calibre2">When analyzing data, it's quite common to encounter categorical values. R provides a good way to represent categorical values using factors, which are created using the <kbd class="calibre9">factor()</kbd> function and are integer vectors with associated labels for each integer. The different values that the factor can take are called levels. The <kbd class="calibre9">levels()</kbd> function shows all the levels from a factor, and the levels parameter of the <kbd class="calibre9">factor()</kbd> function can be used to explicitly define their order, which is alphabetical in case it's not explicitly defined.</p>
<p>Note that defining an explicit order can be important in linear modeling because the first level is used as the baseline level for functions like <kbd class="calibre21">lm()</kbd> (linear models), which we will use in <a target="_blank" href="part0076.html#28FAO0-f494c932c729429fb734ce52cafce730" class="calibre26">Chapter 3</a>, <em class="calibre27">Predicting Votes with Linear Models</em>.</p>
<p class="calibre2">Furthermore, printing a factor shows slightly different information than printing a character vector. In particular, note that the quotes are not shown and that the levels are explicitly printed in order afterwards:</p>
<pre class="mce-root">x &lt;- c("Blue", "Red", "Black", "Blue")
y &lt;- factor(c("Blue", "Red", "Black", "Blue"))
z &lt;- factor(c("Blue", "Red", "Black", "Blue"), <br class="title-page-name"/>            levels=c("Red", "Black", "Blue"))

x
<strong class="calibre1">#&gt; [1] "Blue" "Red" "Black" "Blue"</strong><br class="title-page-name"/>y<br class="title-page-name"/><strong class="calibre1">#&gt; [1] Blue Red Black Blue</strong><br class="title-page-name"/><strong class="calibre1">#&gt; Levels: Black Blue Red</strong><br class="title-page-name"/>z<br class="title-page-name"/><strong class="calibre1">#&gt; [1] Blue Red Black Blue</strong><br class="title-page-name"/><strong class="calibre1">#&gt; Levels: Red Black Blue</strong><br class="title-page-name"/>levels(y)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "Black" "Blue" "Red"</strong><br class="title-page-name"/>levels(z)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "Red" "Black" "Blue"</strong></pre>
<p class="calibre2">Factors can sometimes be tricky to work with because their types are interpreted differently depending on what function is used to operate on them. Remember the <kbd class="calibre9">class()</kbd> and <kbd class="calibre9">typeof()</kbd> functions we used before? When used on factors, they may produce unexpected results. As you can see below, the <kbd class="calibre9">class()</kbd> function will identify x and y as being character and factor, respectively. However, the <kbd class="calibre9">typeof()</kbd> function will let us know that they are character and integer, respectively. Confusing isn't it? This happens because, as we mentioned, factors are stored internally as integers, and use a mechanism similar to look-up tables to retrieve the actual string associated for each one.</p>
<p>Technically, the way factors store the strings associated with their integer values is through attributes, which is a topic we will touch on in <a target="_blank" href="part0178.html#59O440-f494c932c729429fb734ce52cafce730" class="calibre26">Chapter 8</a>,  <em class="calibre27">Object-Oriented System to Track Cryptocurrencies</em>.</p>
<pre class="mce-root">class(x)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "character"</strong><br class="title-page-name"/>class(y)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "factor"</strong><br class="title-page-name"/>typeof(x)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "character"</strong><br class="title-page-name"/>typeof(y)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "integer"</strong></pre>
<p class="calibre2">While factors look and often behave like character vectors, as we mentioned, they are actually integer vectors, so be careful when treating them like strings. Some string methods, like <kbd class="calibre9">gsub()</kbd> and <kbd class="calibre9">grepl()</kbd>, will coerce factors to characters, while others, like <kbd class="calibre9">nchar()</kbd>, will throw an error, and still others, like <kbd class="calibre9">c()</kbd>, will use the underlying integer values. For this reason, it's usually best to explicitly convert factors to the data type you need:</p>
<pre class="mce-root">gsub("Black", "White", x)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "Blue" "Red" "White" "Blue"</strong><br class="title-page-name"/>gsub("Black", "White", y)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "Blue" "Red" "White" "Blue"</strong><br class="title-page-name"/>nchar(x)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 4 3 5 4</strong><br class="title-page-name"/>nchar(y)<br class="title-page-name"/><strong class="calibre1">#&gt; Error in nchar(y): 'nchar()' requires a character vector</strong><br class="title-page-name"/>c(x)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "Blue" "Red" "Black" "Blue"</strong><br class="title-page-name"/>c(y)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 2 3 1 2</strong></pre>
<p class="calibre2">If you did not notice, the <kbd class="calibre9">nchar()</kbd> applied itself to each of the elements in the x factor. The <kbd class="calibre9">"Blue"</kbd>, <kbd class="calibre9">"Red"</kbd>, and <kbd class="calibre9">"Black"</kbd> strings have 4, 3, and 5 characters, respectively. This is another example of the vectorized operations we mentioned in the vectors section earlier.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Matrices</h1>
                
            
            
                
<p class="calibre2">Matrices are commonly used in mathematics and statistics, and much of R's power comes from the various operations you can perform with them. In R, a matrix is a vector with two additional attributes, the number of rows and the number of columns. And, since matrices are vectors, they are constrained to a single data type.</p>
<p class="calibre2">You can use the <kbd class="calibre9">matrix()</kbd> function to create matrices. You may pass it a vector of values, as well as the number of rows and columns the matrix should have. If you specify the vector of values and one of the dimensions, the other one will be calculated for you automatically to be the lowest number that makes sense for the vector you passed. However, you may specify both of them simultaneously if you prefer, which may produce different behavior depending on the vector you passed, as can be seen in the next example.</p>
<p class="calibre2">By default, matrices are constructed column-wise, meaning that the entries can be thought of as starting in the upper-left corner and running down the columns. However, if you prefer to construct it row-wise, you can send the <kbd class="calibre9">byrow = TRUE</kbd> parameter. Also, note that you may create an empty or non-initialized matrix, by specifying the number of rows and columns without passing any actual data for its construction, and if you don't specify anything at all, an uninitialized 1-by-1 matrix will be returned. Finally, note that the same element-repetition mechanism we saw for vectors is applied when creating matrices, so do be careful when creating them this way:</p>
<pre class="mce-root">matrix()<br class="title-page-name"/><strong class="calibre1">#&gt; [,1]</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1,] NA</strong><br class="title-page-name"/><br class="title-page-name"/>matrix(nrow = 2, ncol = 3)<br class="title-page-name"/><strong class="calibre1">#&gt; [,1] [,2] [,3]</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1,] NA NA NA</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [2,] NA NA NA</strong><br class="title-page-name"/><br class="title-page-name"/>matrix(c(1, 2, 3), nrow = 2)<br class="title-page-name"/><strong class="calibre1">#&gt; Warning in matrix(c(1, 2, 3), nrow = 2): </strong><br class="title-page-name"/><strong class="calibre1">       data length [3] is not a sub-</strong><br class="title-page-name"/><strong class="calibre1">#&gt; multiple or multiple of the number of rows [2]</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [,1] [,2]</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1,] 1 3</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [2,] 2 1</strong><br class="title-page-name"/><br class="title-page-name"/>matrix(c(1, 2, 3), nrow = 2, ncol = 3)<br class="title-page-name"/><strong class="calibre1">#&gt; [,1] [,2] [,3]</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1,] 1 3 2</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [2,] 2 1 3</strong><br class="title-page-name"/><br class="title-page-name"/>matrix(c(1, 2, 3, 4, 5, 6), nrow = 2, byrow = TRUE)<br class="title-page-name"/><strong class="calibre1">#&gt; [,1] [,2] [,3]</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1,] 1 2 3</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [2,] 4 5 6</strong></pre>
<p class="calibre2">Matrix subsets can be specified in various ways. Using matrix-like notation, you can specify the row and column selection using the same mechanisms we showed before for vectors, with which you can use vectors with indexes or vectors with logicals, and in case you decide to use vectors with logicals the vector used to subset must be of the same length as the matrix's dimension you are using it for. Since in this case, we have two dimensions to work with, we must separate the selection for rows and columns by using a comma (,) between them (row selection goes first), and R will return their intersection.</p>
<p class="calibre2">For example, <kbd class="calibre9">x[1, 2]</kbd> tells R to get the element in the first row and the second column, <kbd class="calibre9">x[1:2, 1]</kbd> tells R to get the first through second elements of the third row, which is equivalent to using <kbd class="calibre9">x[c(1, 2), 3]</kbd>. You may also use logical vectors for the selection. For example, <kbd class="calibre9">x[c(TRUE, FALSE), c(TRUE, FALSE, TRUE)]</kbd> tells R to get the first row while avoiding the second one, and from that row, to get the first and third columns. An equivalent selection is <kbd class="calibre9">x[1, c(1, 3)]</kbd>. Note that when you want to specify a single row or column, you can use an integer by itself, but if you want to specify two or more, then you must use vector notation. Finally, if you leave out one of the dimension specifications, R will interpret as getting all possibilities for that dimension:</p>
<pre class="mce-root">x &lt;- matrix(c(1, 2, 3, 4, 5, 6), nrow = 2, ncol = 3, byrow = TRUE)<br class="title-page-name"/>x[1, 2]<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 2</strong><br class="title-page-name"/>x[1:2, 2]<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 2 5</strong><br class="title-page-name"/>x[c(1, 2), 3]<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 3 6</strong><br class="title-page-name"/>x[c(TRUE, FALSE), c(TRUE, FALSE, TRUE)]<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 1 3</strong><br class="title-page-name"/>x[1, c(1, 3)]<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 1 3</strong><br class="title-page-name"/>x[, 1]<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 1 4</strong><br class="title-page-name"/>x[1, ]<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 1 2 3</strong></pre>
<p class="calibre2">As mentioned earlier, matrices are basic mathematical tools, and R gives you a lot of flexibility when working with them. The most common matrix operation is transposition, which is performed using the <kbd class="calibre9">t()</kbd> function, and matrix-vector multiplication, vector-matrix multiplication, and matrix-matrix multiplication, which are performed with the <kbd class="calibre9">%*%</kbd> operator we used previously to calculate the dot-product of two vectors.</p>
<p class="calibre2">Note that the same dimensionality restrictions apply as with mathematical notation, meaning that in case you try to perform one of these operations and the dimensions don't make mathematical sense, R will throw an error, as can be seen in the last part of the example:</p>
<pre class="mce-root">A &lt;- matrix(c(1, 2, 3, 4, 5, 6), nrow = 2, byrow = TRUE)<br class="title-page-name"/>x &lt;- c(7, 8)<br class="title-page-name"/>y &lt;- c(9, 10, 11)<br class="title-page-name"/>A<br class="title-page-name"/><strong class="calibre1">#&gt; [,1] [,2] [,3]</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1,] 1 2 3</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [2,] 4 5 6</strong><br class="title-page-name"/>x<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 7 8</strong><br class="title-page-name"/>y<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 9 10 11</strong><br class="title-page-name"/>t(A)<br class="title-page-name"/><strong class="calibre1">#&gt; [,1] [,2]</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1,] 1 4</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [2,] 2 5</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [3,] 3 6</strong><br class="title-page-name"/>t(x)<br class="title-page-name"/><strong class="calibre1">#&gt; [,1] [,2]</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1,] 7 8</strong><br class="title-page-name"/>t(y)<br class="title-page-name"/><strong class="calibre1">#&gt; [,1] [,2] [,3]</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1,] 9 10 11</strong><br class="title-page-name"/>x %*% A<br class="title-page-name"/><strong class="calibre1">#&gt; [,1] [,2] [,3]</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1,] 39 54 69</strong><br class="title-page-name"/>A %*% t(x)<br class="title-page-name"/><strong class="calibre1">#&gt; Error in A %*% t(x): non-conformable arguments</strong><br class="title-page-name"/>A %*% y<br class="title-page-name"/><strong class="calibre1">#&gt; [,1]</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1,] 62</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [2,] 152</strong><br class="title-page-name"/>t(y) %*% A<br class="title-page-name"/><strong class="calibre1">#&gt; Error in t(y) %*% A: non-conformable arguments</strong><br class="title-page-name"/>A %*% t(A)<br class="title-page-name"/><strong class="calibre1">#&gt; [,1] [,2]</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1,] 14 32</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [2,] 32 77</strong><br class="title-page-name"/>t(A) %*% A<br class="title-page-name"/><strong class="calibre1">#&gt; [,1] [,2] [,3]</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1,] 17 22 27</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [2,] 22 29 36</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [3,] 27 36 45</strong><br class="title-page-name"/>A %*% x<br class="title-page-name"/><strong class="calibre1">#&gt; Error in A %*% x: non-conformable arguments</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Lists</h1>
                
            
            
                
<p class="calibre2">A list is an ordered collection of objects, like vectors, but lists can actually combine objects of different types. List elements can contain any type of object that exists in R, including data frames and functions (explained in the following sections). Lists play a central role in R due to their flexibility and they are the basis for data frames, object-oriented programming, and other constructs. Learning to use them properly is a fundamental skill for R programmers, and here, we will barely touch the surface, but you should definitely research them further.</p>
<p>For those familiar with Python, R lists are similar to Python dictionaries.</p>
<p class="calibre2">Lists can be explicitly created using the <kbd class="calibre9">list()</kbd> function, which takes an arbitrary number of arguments, and we can refer to each of those elements by both position, and, in case they are specified, also by names. If you want to reference list elements by names, you can use the <kbd class="calibre9">$</kbd> notation.</p>
<p class="calibre2">The following example shows how flexible lists can be. It shows that a list that contains numerics, characters, logicals, matrices, and even other lists (these are known as nested lists), and as you can see, we can extract each of those elements to work independently from them.</p>
<p>This is the first time we show a multi-line expression. As you can see, you can do it to preserve readability and avoid having very long lines in your code. Arranging code this way is considered to be a good practice. If you're typing this directly in the console, plus symbols (+) will appear in each new line, as long as you have an unfinished expression, to guide you along.</p>
<pre class="mce-root">x &lt;- list(<br class="title-page-name"/>    A = 1,<br class="title-page-name"/>    B = "A",<br class="title-page-name"/>    C = TRUE,<br class="title-page-name"/>    D = matrix(c(1, 2, 3, 4), nrow = 2),<br class="title-page-name"/>    E = list(F = 2, G = "B", H = FALSE)<br class="title-page-name"/>)<br class="title-page-name"/><br class="title-page-name"/>x <br class="title-page-name"/><strong class="calibre1">#&gt; $A</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 1</strong><br class="title-page-name"/><strong class="calibre1">#&gt;</strong><br class="title-page-name"/><strong class="calibre1">#&gt; $B</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] "A"</strong><br class="title-page-name"/><strong class="calibre1">#&gt;</strong><br class="title-page-name"/><strong class="calibre1">#&gt; $C</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] TRUE</strong><br class="title-page-name"/><strong class="calibre1">#&gt;</strong><br class="title-page-name"/><strong class="calibre1">#&gt; $D</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [,1] [,2]</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1,] 1 3</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [2,] 2 4</strong><br class="title-page-name"/><strong class="calibre1">#&gt;</strong><br class="title-page-name"/><strong class="calibre1">#&gt; $E</strong><br class="title-page-name"/><strong class="calibre1">#&gt; $E$F</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 2</strong><br class="title-page-name"/><strong class="calibre1">#&gt;</strong><br class="title-page-name"/><strong class="calibre1">#&gt; $E$G</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] "B"</strong><br class="title-page-name"/><strong class="calibre1">#&gt;</strong><br class="title-page-name"/><strong class="calibre1">#&gt; $E$H</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] FALSE<br class="title-page-name"/></strong><br class="title-page-name"/>x[1]<br class="title-page-name"/><strong class="calibre1">#&gt; $A</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 1<br class="title-page-name"/></strong><br class="title-page-name"/>x$A<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 1<br class="title-page-name"/></strong><br class="title-page-name"/>x[2]<br class="title-page-name"/><strong class="calibre1">#&gt; $B</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] "A"<br class="title-page-name"/></strong><br class="title-page-name"/>x$B<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "A"</strong></pre>
<p class="calibre2">When working with lists, we can use the <kbd class="calibre9">lapply()</kbd> function to apply a function to each of the elements in a list. In this case, we want to know the class and type of each of the elements in the list we just created:</p>
<pre class="mce-root">lapply(x, class)
<strong class="calibre1">#&gt; $A</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] "numeric"</strong><br class="title-page-name"/><strong class="calibre1">#&gt;</strong><br class="title-page-name"/><strong class="calibre1">#&gt; $B</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] "character"</strong><br class="title-page-name"/><strong class="calibre1">#&gt;</strong><br class="title-page-name"/><strong class="calibre1">#&gt; $C</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] "logical"</strong><br class="title-page-name"/><strong class="calibre1">#&gt;</strong><br class="title-page-name"/><strong class="calibre1">#&gt; $D</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] "matrix"</strong><br class="title-page-name"/><strong class="calibre1">#&gt;</strong><br class="title-page-name"/><strong class="calibre1">#&gt; $E</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] "list"
</strong><br class="title-page-name"/>lapply(x, typeof)<br class="title-page-name"/><strong class="calibre1">#&gt; $A</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] "double"</strong><br class="title-page-name"/><strong class="calibre1">#&gt;</strong><br class="title-page-name"/><strong class="calibre1">#&gt; $B</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] "character"</strong><br class="title-page-name"/><strong class="calibre1">#&gt;</strong><br class="title-page-name"/><strong class="calibre1">#&gt; $C</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] "logical"</strong><br class="title-page-name"/><strong class="calibre1">#&gt;</strong><br class="title-page-name"/><strong class="calibre1">#&gt; $D</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] "double"</strong><br class="title-page-name"/><strong class="calibre1">#&gt;</strong><br class="title-page-name"/><strong class="calibre1">#&gt; $E</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] "list"</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Data frames</h1>
                
            
            
                
<p class="calibre2">Now we turn to data frames, which are a lot like spreadsheets or database tables. In scientific contexts, experiments consist of individual observations (rows), each of which involves several different variables (columns). Often, these variables contain different data types, which would not be possible to store in matrices since they must contain a single data type. A data frame is a natural way to represent such heterogeneous tabular data. Every element within a column must be of the same type, but different elements within a row may be of different types, that's why we say that a data frame is a heterogeneous data structure.</p>
<p>Technically, a data frame is a list whose elements are equal-length vectors, and that's why it permits heterogeneity.</p>
<p class="calibre2">Data frames are usually created by reading in a data using the <kbd class="calibre9">read.table()</kbd>, <kbd class="calibre9">read.csv()</kbd>, or other similar data-loading functions. However, they can also be created explicitly with the <kbd class="calibre9">data.frame()</kbd> function or they can be coerced from other types of objects such as lists. To create a data frame using the <kbd class="calibre9">data.frame()</kbd> function, note that we send a vector (which, as we know, must contain elements of a single type) to each of the column names we want our data frame to have, which are A, B, and C in this case. The data frame we create below has four rows (observations) and three variables, with numeric, character, and logical types, respectively. Finally, extract subsets of data using the matrix techniques we saw earlier, but you can also reference columns using the $ operator and then extract elements from them:</p>
<pre class="mce-root">x &lt;- data.frame(
    A = c(1, 2, 3, 4),
    B = c("D", "E", "F", "G"),
    C = c(TRUE, FALSE, NA, FALSE)
)
x[1, ]<br class="title-page-name"/><strong class="calibre1">#&gt; A B C</strong><br class="title-page-name"/><strong class="calibre1">#&gt; 1 1 D TRUE</strong><br class="title-page-name"/>x[, 1]<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 1 2 3 4</strong><br class="title-page-name"/>x[1:2, 1:2]<br class="title-page-name"/><strong class="calibre1">#&gt; A B</strong><br class="title-page-name"/><strong class="calibre1">#&gt; 1 1 D</strong><br class="title-page-name"/><strong class="calibre1">#&gt; 2 2 E</strong><br class="title-page-name"/>x$B<br class="title-page-name"/><strong class="calibre1">#&gt; [1] D E F G</strong><br class="title-page-name"/><strong class="calibre1">#&gt; Levels: D E F G</strong><br class="title-page-name"/>x$B[2]<br class="title-page-name"/><strong class="calibre1">#&gt; [1] E</strong><br class="title-page-name"/><strong class="calibre1">#&gt; Levels: D E F G</strong></pre>
<p class="calibre2">Depending on how the data is organized, the data frame is said to be in either wide or narrow formats (<a href="https://en.wikipedia.org/wiki/Wide_and_narrow_data" target="_blank" class="calibre4">https://en.wikipedia.org/wiki/Wide_and_narrow_data</a>). Finally, if you want to keep only observations for which you have complete cases, meaning only rows that don't contain any <kbd class="calibre9">NA</kbd> values for any of the variables, then you should use the <kbd class="calibre9">complete.cases()</kbd> function, which returns a logical vector of length equal to the number of rows, and which contains a <kbd class="calibre9">TRUE</kbd> value for those rows that don't have any <kbd class="calibre9">NA</kbd> values and <kbd class="calibre9">FALSE</kbd> for those that have at least one such value.</p>
<p class="calibre2">Note that when we created the x data frame, the C column contains an <kbd class="calibre9">NA</kbd> in its third value. If we use the <kbd class="calibre9">complete.cases()</kbd> function on x, then we will get a <kbd class="calibre9">FALSE</kbd> value for that row and a <kbd class="calibre9">TRUE</kbd> value for all others. We can then use this logical vector to subset the data frame just as we have done before with matrices. This can be very useful when analyzing data that may not be clean, and for which you only want to keep those observations for which you have full information:</p>
<pre class="mce-root">x
<strong class="calibre1">#&gt; A B C</strong><br class="title-page-name"/><strong class="calibre1">#&gt; 1 1 D TRUE</strong><br class="title-page-name"/><strong class="calibre1">#&gt; 2 2 E FALSE</strong><br class="title-page-name"/><strong class="calibre1">#&gt; 3 3 F NA</strong><br class="title-page-name"/><strong class="calibre1">#&gt; 4 4 G FALSE</strong><br class="title-page-name"/><br class="title-page-name"/>complete.cases(x)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] TRUE TRUE FALSE TRUE</strong><br class="title-page-name"/>x[complete.cases(x), ]<br class="title-page-name"/><strong class="calibre1">#&gt; A B C</strong><br class="title-page-name"/><strong class="calibre1">#&gt; 1 1 D TRUE</strong><br class="title-page-name"/><strong class="calibre1">#&gt; 2 2 E FALSE</strong><br class="title-page-name"/><strong class="calibre1">#&gt; 4 4 G FALSE</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Divide and conquer with functions</h1>
                
            
            
                
<p class="calibre2">Functions are a fundamental building block of R. To master many of the more advanced techniques in this book, you need a solid foundation in how they work. We've already used a few functions above since you can't really do anything interesting in R without them. They are just what you remember from your mathematics classes, a way to transform inputs into outputs. Specifically in R, a function is an object that takes other objects as inputs, called arguments, and returns an output object. Most functions are in the following form <kbd class="calibre9">f(argument_1, argument_2, ...)</kbd>. Where f is the name of the function, and <kbd class="calibre9">argument_1</kbd>, <kbd class="calibre9">argument_2</kbd>, and so on are the arguments to the function.</p>
<p class="calibre2">Before we continue, we should briefly mention the role of curly braces ({}) in R. Often they are used to group a set of operations in the body of a function, but they can also be used in other contexts (as we will see in the case of the web application we will build in <a target="_blank" href="part0271.html#82E8E0-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 10</a>, <em class="calibre19">Adding Interactivity with Dashboards</em>). Curly braces are used to evaluate a series of expressions, which are separated by newlines or semicolons, and return only the last expression as a result. For example, the following line only prints the x + y operation to the screen, hiding the output of the x * y operation, which would have been printed had we typed the expressions step by step. In this sense, curly braces are used to encapsulate a set of behavior and only provide the result from the last expression:</p>
<pre class="mce-root">{ x &lt;- 1; y &lt;- 2; x * y; x + y }<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 3</strong></pre>
<p class="calibre2">We can create our own function by using the <kbd class="calibre9">function() </kbd>constructor and assign it to a symbol. The <kbd class="calibre9">function()</kbd> constructor takes an arbitrary number of named arguments, which can be used within the body of the function. Unnamed arguments can also be passed using the "..." argument notation, but that's an advanced technique we won't look at in this book. Feel free to read the documentation for functions to learn more about them.</p>
<p class="calibre2">When calling the function, arguments can be passed by position or by name. The positional order must correspond to the order provided in the function's signature (that is, the <kbd class="calibre9">function()</kbd> specification with the corresponding arguments), but when using named arguments, we can send them in whatever order we prefer. As the following example shows.</p>
<p class="calibre2">In the following example, we create a function that calculates the <strong class="calibre1">Euclidian distance</strong> (<a href="https://en.wikipedia.org/wiki/Euclidean_distance" target="_blank" class="calibre4">https://en.wikipedia.org/wiki/Euclidean_distance</a>) between two numeric vectors, and we show how the order of the arguments can be changed if we use named arguments. To realize this effect, we use the <kbd class="calibre9">print()</kbd> function to make sure we can see in the console what R is receiving as the x and y vectors. When developing your own programs, using the <kbd class="calibre9">print() </kbd>function in similar ways is very useful to understand what's happening.</p>
<p class="calibre2">Instead of using the function name like <kbd class="calibre9">euclidian_distance</kbd>, we will use <kbd class="calibre9">l2_norm</kbd>  because it's the generalized name for such an operation when working with spaces of arbitrary number dimensions and because it will make a follow-up example easier to understand. Note that even though outside the function call our vectors are called a and b, since they are passed into the x and y arguments, those are the names we need to use within our function. It's easy for beginners to confuse these objects as being the same if we had used the x and y names in both places:</p>
<pre class="mce-root">l2_norm &lt;- function(x, y) {
    print("x")
    print(x)
    print("y")
    print(y)
    element_to_element_difference &lt;- x - y
    result &lt;- sum(element_to_element_difference^2)
    return(result)
}

a &lt;- c(1, 2, 3)<br class="title-page-name"/>b &lt;- c(4, 5, 6)<br class="title-page-name"/><br class="title-page-name"/>l2_norm(a, b)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "x"</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 1 2 3</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] "y"</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 4 5 6</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 27</strong><br class="title-page-name"/><br class="title-page-name"/>l2_norm(b, a)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "x"</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 4 5 6</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] "y"</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 1 2 3</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 27</strong><br class="title-page-name"/><br class="title-page-name"/>l2_norm(x = a, y = b)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "x"</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 1 2 3</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] "y"</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 4 5 6</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 27</strong><br class="title-page-name"/><br class="title-page-name"/>l2_norm(y = b, x = a)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "x"</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 1 2 3</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] "y"</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 4 5 6</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 27</strong></pre>
<p class="calibre2">Functions may use the <kbd class="calibre9">return()</kbd> function to specify the value returned by the function. However, R will simply return the last evaluated expression as the result of a function, so you may see code that does not make use of the <kbd class="calibre9">return()</kbd> function explicitly.</p>
<p class="calibre2">Our previous <kbd class="calibre9">l2_norm()</kbd> function implementation seems to be somewhat cluttered. If the function has a single expression, then we can avoid using the curly braces, which we can achieve by removing the <kbd class="calibre9">print()</kbd> function calls and avoid creating intermediate objects, and since we know that it's working fine, we can do so without hesitation. Furthermore, we avoid explicitly calling the <kbd class="calibre9">return()</kbd> function to simplify our code even more. If we do so, our function looks much closer to its mathematical definition and is easier to understand, isn't it?</p>
<pre class="mce-root">l2_norm &lt;- function(x, y) sum((x - y)^2)</pre>
<p class="calibre2">Furthermore, in case you did not notice, since we use vectorized operations, we can send vectors of different lengths (dimensions), provided that both vectors share the same length, and the function will work just as we expect it to, without regard for the dimensionality of the space we're working with. As I had mentioned earlier, vectorization can be quite powerful. In the following example, we show such behavior with vectors of dimension 1 (mathematically known as scalars), as well as vectors of dimension 5, created with the ":" shortcut syntax:</p>
<pre class="mce-root">l2_norm(1, 2)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 1</strong><br class="title-page-name"/>l2_norm(1:5, 6:10)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 125</strong></pre>
<p class="calibre2">Before we move on, I just want to mention that you should always make an effort to follow the Single Responsibility principle, which states that each object (functions in this case) should focus on doing a single thing, and do it very well. Whenever you describe a function you created as doing "<em class="calibre19">something</em>" and "<em class="calibre19">something else,</em>" you're probably doing it wrong since the "and" should let you know that the function is doing more than one thing, and you should split it into two or more functions that possibly call each other. To read more about good software engineering principles, take a look at Martin's great book title <em class="calibre19">Agile Software Development, Principles, Patterns, and Practices, Pearson, 2002</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Optional arguments</h1>
                
            
            
                
<p class="calibre2">When creating functions, you may specify a default value for an argument, and if you do, then the argument is considered optional. If you do not specify a default value for an argument, and you do not specify a value when calling a function, you will get an error if the function attempts to use the argument.</p>
<p class="calibre2">In the following example, we show that if a single numeric vector is passed to our <kbd class="calibre9">l2_norm()</kbd> function as it stands, it will throw an error, but if we redefine it to make the second vector optional, then we will simply return the first vector's norm, not the distance between two different vectors To accomplish this, we will provide a zero-vector of length one, but because R repeats vector elements until all the vectors involved in an operation are of the same length, as we saw before in this chapter, it will automatically expand our zero-vector into the appropriate dimension:</p>
<pre class="mce-root">l2_norm(a)     # Should throw an error because `y` is missing<br class="title-page-name"/><strong class="calibre1">#&gt; Error in l2_norm(a): argument "y" is missing, with no default</strong>

l2_norm &lt;- function(x, y = 0) sum((x - y)^2)

l2_norm(a)     # Should work fine, since `y` is optional now
<strong class="calibre1">#&gt; [1] 14</strong>
l2_norm(a, b)  # Should work just as before<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 27</strong></pre>
<p class="calibre2">As you can see, now our function can optionally receive the <kbd class="calibre9">y</kbd> vector, but will also work as expected without it. Also, note that we introduced some comments into our code. Anything that comes after the <kbd class="calibre9">#</kbd> symbol in a line, R will ignore, which allows us to explain our code where need be. I prefer to avoid using comments because I tend to think that code should be expressive and communicate its intention without the need for comments, but they are actually useful every now and then.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Functions as arguments</h1>
                
            
            
                
<p class="calibre2">Sometimes when you want to generalize functions, you may want to plug in a certain functionality into a function. You can do that in various ways. For example, you may use conditionals, as we will see in the following section in this chapter, to provide them with different functionality based on context. However, conditional should be avoided when possible because they can introduce unnecessary complexity into our code. A better solution would be to pass a function as a parameter which will be called when appropriate, and if we want to change how a function behaves, we can change the function we're passing through for a specific task.</p>
<p class="calibre2">That may sound complicated, but in reality, it's very simple. Let's start by creating a <kbd class="calibre9">l1_norm()</kbd> function that calculates the distance between two vectors but uses the sum of absolute differences among corresponding coordinates instead of the sum of squared differences as our <kbd class="calibre9">l2_norm()</kbd> function does. For more information, take a look at the <em class="calibre19">Taxicab geometry</em> article on Wikipedia (<a href="https://en.wikipedia.org/wiki/Taxicab_geometry" class="calibre4">https://en.wikipedia.org/wiki/Taxicab_geometry</a>).</p>
<p class="calibre2">Note that we use the same <em class="calibre19">signature</em> for our two functions, meaning that both receive the same required as well as optional arguments, which are <kbd class="calibre9">x</kbd> and <kbd class="calibre9">y</kbd> in this case. This is important because if we want to change the behavior by switching functions, we must make sure they are able to work with the same inputs, otherwise, we may get unexpected results or even errors:</p>
<pre class="mce-root">l1_norm &lt;- function(x, y = 0) sum(abs(x - y))

l1_norm(a)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 6</strong><br class="title-page-name"/>l1_norm(a, b)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 9</strong></pre>
<p class="calibre2">Now that our <kbd class="calibre9">l2_norm()</kbd> and <kbd class="calibre9">l1_norm()</kbd> are built so that they can be switched among themselves to provide different behavior, we will create a third <kbd class="calibre9">distance()</kbd> function, which will take the two vectors as arguments, but will also receive a norm argument, which will contain the function we want to use to calculate the distance.</p>
<p class="calibre2">Note that we are specifying that we want to use the <kbd class="calibre9">l2_norm()</kbd> by default in case there's no explicit selection when calling the function, and to do so we simply specify the symbol that contains the function object, without parenthesis. Finally note, that if we want to avoid sending the <kbd class="calibre9">y</kbd> vector, but we want to specify what norm should be used, then we must pass it through as a named argument, otherwise R would interpret the second argument as the <kbd class="calibre9">y</kbd> vector, not the norm function:</p>
<pre class="mce-root">distance &lt;- function(x, y = 0, norm = l2_norm) norm(x, y)

distance(a)
<strong class="calibre1">#&gt; [1] 14</strong><br class="title-page-name"/>distance(a, b)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 27</strong><br class="title-page-name"/>distance(a, b, l2_norm)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 27</strong><br class="title-page-name"/>distance(a, b, l1_norm)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 9</strong><br class="title-page-name"/>distance(a, norm = l1_norm)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 6</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Operators are functions</h1>
                
            
            
                
<p class="calibre2">Now that you have a working understanding of how functions work. You should know that not all function calls look like the ones we have shown so far, where you use the name of the function followed by parentheses that contains the function's arguments. Actually, all statements in R, including setting variables and arithmetic operations, are functions in the background, even if we mostly call them with a different syntax.</p>
<p class="calibre2">Remember that previously in this chapter we mentioned that R objects could be referred to by almost any string, but you should avoid doing so. Well here we show how using cryptic names can be useful under certain contexts. The following example shows how the assignment, selection, and addition operators are usually used with <em class="calibre19">sugar</em> syntax (a term used to describe syntax that exists for ease of use), but that in the background they use the functions named <kbd class="calibre9">[&lt;-</kbd>, <kbd class="calibre9">[</kbd>, and <kbd class="calibre9">+</kbd>, respectively.</p>
<p class="calibre2">The <kbd class="calibre9">[&lt;-()</kbd> function receives three arguments: the vector we want to modify, the position we want to modify in the vector, and the value we want it to have at that position. The <kbd class="calibre9">[()</kbd> function receives two arguments, the vector from which we want to retrieve a value and the position of the value we want to retrieve. Finally, the <kbd class="calibre9">+()</kbd> function receives the two values we want to add. The following example shows the syntax sugar, followed by the background function calls R performs for us:</p>
<pre class="mce-root">x &lt;- c(1, 2, 3, 4, 5)<br class="title-page-name"/>x<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 1 2 3 4 5</strong><br class="title-page-name"/>x[1] &lt;- 10<br class="title-page-name"/>x<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 10 2 3 4 5</strong><br class="title-page-name"/>`[&lt;-`(x, 1, 20)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 20 2 3 4 5</strong><br class="title-page-name"/>x<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 10 2 3 4 5</strong><br class="title-page-name"/>x[1]<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 10</strong><br class="title-page-name"/>`[`(x, 1)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 10</strong><br class="title-page-name"/>x[1] + x[2]<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 12</strong><br class="title-page-name"/>`+`(x[1], x[2])<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 12</strong><br class="title-page-name"/>`+`(`[`(x, 1), `[`(x, 1))<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 20</strong></pre>
<p class="calibre2">In practice, you would probably never write these statements as explicit function calls. The syntax sugar is much more intuitive and much easier to read. However, to use some of the advanced techniques shown in this book, it is helpful to know that every operation in R is a function.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Coercion</h1>
                
            
            
                
<p class="calibre2">Finally, we will briefly mention what coercion is in R since it's a topic of confusion for newcomers. When you call a function with an argument of a different type than what was expected, R will try to coerce values so that the function will work, and this can introduce bugs if not handled correctly. R will follow a mechanism similar to what was used when creating vectors.</p>
<p class="calibre2">Strongly typed languages (like Java) will raise exceptions when the object passed to a function is of the wrong type, and will try not to convert the object to a compatible type. However, as we mentioned earlier, R was designed to work out of the box with a lot of unforeseen contexts, so coercion was introduced.</p>
<p class="calibre2">In the following example, we show that if we call our <kbd class="calibre9">distance()</kbd> function and pass logical vectors instead of numeric ones, R will coerce the logical vectors into numeric vectors, using <kbd class="calibre9">TRUE</kbd> as 1 and <kbd class="calibre9">FALSE</kbd> as 0, and proceed with the calculations. To avoid this issue in your own programs, you should coerce data types explicitly with the <kbd class="calibre9">as.*()</kbd> functions we mentioned before:</p>
<pre class="mce-root">x &lt;- c(1, 2, 3)
y &lt;- c(TRUE, FALSE, TRUE)
distance(x, y)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 8</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Complex logic with control structures</h1>
                
            
            
                
<p class="calibre2">The final topic we should cover is how to introduce complex logic by using control structures. When I write introduce complex logic, I don't mean to imply that it's complex to do so. Complex logic refers to code that has multiple possible paths of execution, but in reality, it's quite simple to implement it.</p>
<p class="calibre2">Nearly every operation in R can be written as a function, and these functions can be passed through to other functions to create very complex behavior. However, it isn't always convenient to implement logic that way and using simple control structures may be a better option sometimes.</p>
<p class="calibre2">The control structures we will look at are <kbd class="calibre9">if... else</kbd> conditionals, <kbd class="calibre9">for</kbd> loops, and <kbd class="calibre9">while</kbd> loops. There are also <kbd class="calibre9">switch</kbd> conditionals, which are very much like <kbd class="calibre9">if... else</kbd> conditionals, but we won't look at them since we won't use them in the examples contained in this book.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">If… else conditionals</h1>
                
            
            
                
<p class="calibre2">As their name states, if…else conditionals will check a condition, and if it is evaluated to be a <kbd class="calibre9">TRUE</kbd> value, one path of execution will be taken, but if the condition is evaluated to be a <kbd class="calibre9">FALSE</kbd> value, a different path of execution will be taken, and they are mutually exclusive.</p>
<p class="calibre2">To show how <kbd class="calibre9">if... else</kbd> conditions work, we will program the same <kbd class="calibre9">distance()</kbd> function we used before, but instead of passing it the third argument in the form of a function, we will pass it a string that will be checked to decide which function should be used. This way you can compare different ways of implementing the same functionality. If we pass the <kbd class="calibre9">l2</kbd> string to the norm argument, then the <kbd class="calibre9">l2_norm()</kbd> function will be used, but if any other string is passed through, the <kbd class="calibre9">l1_norm()</kbd> will be used. Note that we use the double equals operator (==) to check for equality. Don't confuse this with a single equals, which means assignment:</p>
<pre class="mce-root">distance &lt;- function(x, y = 0, norm = "l2") {
    if (norm == "l2") {
        return(l2_norm(x, y))
    } else {
        return(l1_norm(x, y))
    }
}

a &lt;- c(1, 2, 3)
b &lt;- c(4, 5, 6)

distance(a, b)
<strong class="calibre1">#&gt; 27</strong>
distance(a, b, "l2")
<strong class="calibre1">#&gt; 27</strong>
distance(a, b, "l1")
<strong class="calibre1">#&gt; 9</strong>
distance(a, b, "l1 will also be used in this case")
<strong class="calibre1">#&gt; 9</strong></pre>
<p class="calibre2">As can be seen in the last line of the previous example, using conditionals in a non-rigorous manner can introduce potential bugs, as in this case we used the <kbd class="calibre9">l1_norm()</kbd> function, even when the norm argument in the last function call did not make any sense at all. To avoid such situations, we may introduce the more conditionals to exhaust all valid possibilities and throw an error, with the <kbd class="calibre9">stop()</kbd> function, if the <kbd class="calibre9">else</kbd> branch is executed, which would mean that no valid option was provided:</p>
<pre class="mce-root">distance &lt;- function(x, y = 0, norm = "l2") {
    if (norm == "l2") {
        return(l2_norm(x, y))
    } else if (norm == "l1") {
        return(l1_norm(x, y))
    } else {
        stop("Invalid norm option")
    }
}

distance(a, b, "l1")
<strong class="calibre1">#&gt; [1] 9</strong>
distance(a, b, "this will produce an error")
<strong class="calibre1">#&gt; Error in distance(a, b, "this will produce an error") :
#&gt;   Invalid norm option</strong></pre>
<p class="calibre2">Sometimes, there's no need for the <kbd class="calibre9">else</kbd> part of the <kbd class="calibre9">if... else</kbd> condition. In that case, you can simply avoid putting it in, and R will execute the if branch if the condition is met and will ignore it if it's not.</p>
<p class="calibre2">There are many different ways to generate the logical values that can be used within the <kbd class="calibre9">if()</kbd> check. For example, you could specify an optional argument with a <kbd class="calibre9">NULL</kbd> default value and check whether it was not sent in the function call by checking whether the corresponding variable still contains the <kbd class="calibre9">NULL</kbd> object at the time of the check, using the <kbd class="calibre9">is.null()</kbd> function. The actual condition would look something like <kbd class="calibre9">if(is.null(optional_argument))</kbd>. Other times you may get a logical vector, and if a single one of its values is <kbd class="calibre9">TRUE</kbd>, then you want to execute a piece of code, in that case you can use something like <kbd class="calibre9">if(any(logical_vector))</kbd> as the condition, or in case you require that all of the values in the logical vector are <kbd class="calibre9">TRUE</kbd> to execute a piece of code, then you can use something like <kbd class="calibre9">if(all(logical_vector))</kbd>. The same logic can be applied to the self-descriptive functions named <kbd class="calibre9">is.na()</kbd> and <kbd class="calibre9">is.nan()</kbd>.</p>
<p class="calibre2">Another way to generate these logical values is using the comparison operators. These include less than (&lt;), less than or equal to (&lt;=), greater than (&gt;), greater than or equal to (&gt;=), exactly equal (which we have seen ,==), and not equal to (!=). All of these can be used to test numerics as well as characters, in which case alphanumerical order is used. Furthermore, logical values can be combined among themselves to provide more complex conditions. For example, the ! operator will negate a logical, meaning that if <kbd class="calibre9">!TRUE</kbd> is equal to <kbd class="calibre9">FALSE</kbd>, and <kbd class="calibre9">!FALSE</kbd> is equal to <kbd class="calibre9">TRUE</kbd>. Other examples of these types of operators are the OR operator where in case any of the logical values is <kbd class="calibre9">TRUE</kbd>, then the whole expression evaluates to <kbd class="calibre9">TRUE</kbd>, and the AND operator where all logical must be <kbd class="calibre9">TRUE</kbd> to evaluate to <kbd class="calibre9">TRUE</kbd>. Even though we don't show specific examples of the information mentioned in the last two paragraphs, you will see it used in the examples we will develop in the rest of the book.</p>
<p class="calibre2">Finally, note that a vectorized form of the <kbd class="calibre9">if... else</kbd> conditional is available under the <kbd class="calibre9">ifelse()</kbd> function. In the following code we use the modulo operator in the conditional, which is the first argument to the function, to identify which values are even, in which case we use the <kbd class="calibre9">TRUE</kbd> branch which is the second argument to indicate that the integer is <em class="calibre19">even</em>, and which are not, in which case we use the <kbd class="calibre9">FALSE</kbd> branch which is the third argument to indicate that the integer is <em class="calibre19">odd</em>:</p>
<pre class="mce-root">ifelse(c(1, 2, 3, 4, 5, 6) %% 2 == 0, "even", "odd")<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "odd" "even" "odd" "even" "odd" "even"</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">For loops</h1>
                
            
            
                
<p class="calibre2">There are two important properties of <kbd class="calibre9">for</kbd> loops. First, results are not printed inside a loop unless you explicitly call the <kbd class="calibre9">print()</kbd> function. Second, the indexing variable used within a <kbd class="calibre9">for</kbd> loop will be changed, in order, after each iteration. Furthermore, to stop iterating you can use the keyword break, and to skip to the next iteration you can use the next command.</p>
<p class="calibre2">For this first example, we create a vector of characters called <kbd class="calibre9">words</kbd>, and iterate through each of its elements in order using the for (word in words) syntax. Doing so will take the first element in <kbd class="calibre9">words</kbd>, assign it to <kbd class="calibre9">word</kbd>, and pass it through the expression defined in the block defined by the curly braces, which in this case print the word to the console, as well as the number of characters in the word. When the iteration is finished, word will be updated with the next word, and the loop will be repeated this way until all words have been used:</p>
<pre class="mce-root">words &lt;- c("Hello", "there", "dear", "reader")
for (word in words) {
    print(word)
    print(nchar(word))
}<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "Hello"</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 5</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] "there"</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 5</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] "dear"</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 4</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] "reader"</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 6</strong></pre>
<p class="calibre2">Interesting behavior can be achieved by using <em class="calibre19">nested for loops</em> which are <kbd class="calibre9">for</kbd> loops inside other <kbd class="calibre9">for</kbd> loops. In this case, the same logic applies, when we encounter a <kbd class="calibre9">for</kbd> loop we execute it until completion. It's easier to see the result of such behavior than explaining it, so take a look at the behavior of the following code:</p>
<pre class="mce-root">for (i in 1:5) {
    print(i)
    for (j in 1:3) {
        print(paste("   ", j))
    }
}<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 1</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] " 1"</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] " 2"</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] " 3"</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 2</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] " 1"</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] " 2"</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] " 3"</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 3</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] " 1"</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] " 2"</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] " 3"</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 4</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] " 1"</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] " 2"</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] " 3"</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 5</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] " 1"</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] " 2"</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] " 3"</strong></pre>
<p class="calibre2">Using such nested <kbd class="calibre9">for</kbd> loops is how people perform matrix-like operations when using languages that do not offer vectorized operations. Luckily, we can use the syntax shown in previous sections to perform those operations without having to use nested for-loops ourselves which can be tricky at times.</p>
<p class="calibre2">Now, we will see how to use the <kbd class="calibre9">sapply()</kbd> and <kbd class="calibre9">lapply()</kbd> functions to apply a function to each element of a vector. In this case, we will call use the <kbd class="calibre9">nchar()</kbd> function on each of the elements in the words vector we created before. The difference between the <kbd class="calibre9">sapply()</kbd> and the <kbd class="calibre9">lapply()</kbd> functions is that the first one returns a vector, while the second returns a list. Finally, note that explicitly using any of these functions is unnecessary, since, as we have seen before in this chapter, the <kbd class="calibre9">nchar()</kbd> function is already vectorized for us:</p>
<pre class="mce-root">sapply(words, nchar)<br class="title-page-name"/><strong class="calibre1">#&gt; Hello there dear reader</strong><br class="title-page-name"/><strong class="calibre1">#&gt; 5     5     4    6</strong>
lapply(words, nchar)<br class="title-page-name"/><strong class="calibre1">#&gt; [[1]]</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 5</strong><br class="title-page-name"/><strong class="calibre1">#&gt;</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [[2]]</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 5</strong><br class="title-page-name"/><strong class="calibre1">#&gt;</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [[3]]</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 4</strong><br class="title-page-name"/><strong class="calibre1">#&gt;</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [[4]]</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 6</strong>
nchar(words)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 5 5 4 6</strong></pre>
<p class="calibre2">When you have a function that has not been vectorized, like our <kbd class="calibre9">distance()</kbd> function. You can still use it in a vectorized way by making use of the functions we just mentioned. In this case we will apply it to the x list which contains three different numeric vectors. We will use the <kbd class="calibre9">lapply()</kbd> function by passing it the list, followed by the function we want to apply to each of its elements (<kbd class="calibre9">distance()</kbd> in this case). Note that in case the function you are using receives other arguments apart from the one that will be taken from <kbd class="calibre9">x</kbd> and which will be passed as the first argument to such function, you can pass them through after the function name, like we do here with the <kbd class="calibre9">c(1, 1, 1)</kbd> and <kbd class="calibre9">l1_norm</kbd> arguments, which will be received by the <kbd class="calibre9">distance()</kbd> function as the <kbd class="calibre9">y</kbd> and <kbd class="calibre9">norm</kbd> arguments, and will remain fixed for all the elements of the <kbd class="calibre9">x</kbd> list:</p>
<pre class="mce-root">x &lt;- list(c(1, 2, 3), c(4, 5, 6), c(7, 8, 9))
lapply(x, distance, c(1, 1, 1), l1_norm)<br class="title-page-name"/><strong class="calibre1">#&gt; [[1]]</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 3</strong><br class="title-page-name"/><strong class="calibre1">#&gt;</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [[2]]</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 12</strong><br class="title-page-name"/><strong class="calibre1">#&gt;</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [[3]]</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 21</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">While loops</h1>
                
            
            
                
<p class="calibre2">Finally, we will take a look at the <kbd class="calibre9">while</kbd> loops which use a different way of looping than <kbd class="calibre9">for</kbd> loops. In the case of <kbd class="calibre9">for</kbd> loops, we know the number of elements in the object we use to iterate, so we know in advance the number of iterations that will be performed. However, there are times where we don't know this number before we start iterating, and instead, we will iterate based on some condition being true after each iteration. That's when <kbd class="calibre9">while</kbd> loops are useful.</p>
<p class="calibre2">The way <kbd class="calibre9">while</kbd> loops work is that we specify a condition, just as with <kbd class="calibre9">if…else</kbd> conditions, and if the condition is met, then we proceed to iterate. When the iteration is finished, we check the condition again, and if it continues to be true, then we iterate again, and so on. Note that in this case if we want to stop at some point, we must modify the elements used in the condition such that it evaluates to <kbd class="calibre9">FALSE</kbd> at some point. You can also use break and next inside the <kbd class="calibre9">while</kbd> loops.</p>
<p class="calibre2">The following example shows how to print all integers starting at 1 and until 10. Note that if we start at 1 as we do, but instead of adding 1 after each iteration, we subtracted 1 or didn't change <kbd class="calibre9">x</kbd> at all, then we would never stop iterating. That's why you need to be very careful when using <kbd class="calibre9">while</kbd> loops since the number of iterations can be infinite:</p>
<pre class="mce-root">x &lt;- 1
while (x &lt;= 10) {
    print(x)
    x &lt;- x + 1
}<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 1</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 2</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 3</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 4</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 5</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 6</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 7</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 8</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 9</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 10</strong></pre>
<p class="calibre2">In case you do want to execute an infinite loop, you may use the <kbd class="calibre9">while</kbd> loop with a <kbd class="calibre9">TRUE</kbd> value in the place of the conditional. If you do not include a <kbd class="calibre9">break</kbd> command, the code will effectively provide an infinite loop, and it will repeat itself until stopped with the <em class="calibre19">CTRL</em> + <em class="calibre19">C</em> keyboard command or any other stopping mechanism in the IDE you're using. However, in such cases, it's cleaner to use the repeat construct as is shown below. It may seem counter intuitive, but there are times when using infinite loops is useful. We will see one such case in <a href="part0178.html#59O440-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 8</a>, <em class="calibre19">Object-Oriented System to Track Cryptocurrencies</em>, but in such cases, you have an external mechanism used to stop the program based on a condition external to R.</p>
<p class="calibre2">Executing the following example will crash your R session:</p>
<pre class="mce-root"># DO NOTE EXCEUTE THIS, IT's AN INFINITE LOOP

x &lt;- 1
repeat {
    print(x)
    x &lt;- x + 1
}

<strong class="calibre1">#&gt; [1] 1
#&gt; [1] 2
#&gt; [1] 3
#&gt; [1] 4
#&gt; [1] 5
#&gt; [1] 5</strong>
...</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The examples in this book</h1>
                
            
            
                
<p class="calibre2">To end this introductory chapter, I want to introduce you to the three examples we will develop throughout the rest of the book. The first one is the Brexit Votes example, in which we are going to use real Brexit votes data, and, with descriptive statistics and linear models, we will attempt to understand the population dynamics at play behind the results. If you're not familiar with Brexit, it is the popular term for the prospective withdrawal of the United Kingdom from the European Union after a referendum which took place on June 23, 2016 (<a href="https://en.wikipedia.org/wiki/Brexit" class="calibre4">https://en.wikipedia.org/wiki/Brexit</a>). This example will be developed through <a href="part0059.html#1O8H60-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 2</a>, <em class="calibre19">Understanding Votes with Descriptive Statistics</em>, and <a href="part0076.html#28FAO0-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 3</a>, <em class="calibre19">Predicting Votes with Linear Models</em>.</p>
<p class="calibre2">The second one is The Food Factory example, in which you will learn how to simulate various kinds of data for a hypothetical company called The Food Factory, as well as integrate real data from other sources (customer reviews in this case) to complement our simulations. The data will be used to develop various kinds of visualizations, text analysis, and presentations that are updated automatically. This example will be developed through; <a href="part0091.html#2MP360-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 4</a>, <em class="calibre19">Simulating Sales Data and Working with Databases</em>; <a href="part0110.html#38STS0-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 5</a>, <em class="calibre19">Communicating Sales with Visualizations; </em><a href="part0129.html#3R0OI0-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 6</a>, <em class="calibre19">Understanding Reviews with Text Analysis</em>; and <a href="" class="calibre4">Chapter 7</a>, <em class="calibre19">Developing Automatic Presentations</em>.</p>
<p class="calibre2">The third and final one is the <em class="calibre19">Cryptocurrencies Tracking System</em> example, in which we will develop an object-oriented system that will be used to retrieve real-time price data from cryptocurrency markets and the amount of cryptocurrencies assets we hold. We will then show how to compute a simple moving average efficiently using performance optimization techniques, and finally we will show how to build interactive web applications using only R. This example will be developed through <a href="part0178.html#59O440-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 8</a>, <em class="calibre19">Object-Oriented System to Track Cryptocurrencies</em>; <a href="part0229.html#6QCGQ0-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 9</a>, <em class="calibre19">Implementing an Efficient Simple Moving Average;</em> and <a href="part0271.html#82E8E0-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 10</a>, <em class="calibre19">Adding Interactivity with Dashboards</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            
                
<p class="calibre2">In this chapter, we introduced the book by mentioning its intended audience, as well as our intentions for it, which are to provide examples that you can use to understand how real-world R applications are built using a high-quality code, and the useful guidelines of what to do and not to do when building your own applications.</p>
<p class="calibre2">We also introduced R's basic constructs and prepared the baseline we need to work through the examples developed in the rest of the book. Specifically, we looked at how to work with the console, how to create and use variables, how to work with R basic data types like numerics, characters, and logicals, as well as how to handle special values, and how to make basic use of data structures like vectors, factors, matrices, data frames, and lists. Finally, we showed how to create our own functions and how to provide multiple paths of execution with control structures.</p>
<p class="calibre2">I hope this book is useful to you and that you enjoy reading it.</p>


            

            
        
    </body></html>