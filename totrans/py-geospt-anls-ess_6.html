<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Building a Complete Geospatial Analysis System</h1></div></div></div><p>In this chapter, we will take the skills we have learned in the previous chapters and apply them to build a suite of programs that solve a complicated geospatial problem. In doing so, we will learn:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What map matching is, and how it works</li><li class="listitem" style="list-style-type: disc">How to use map matching to generate a heatmap of roads traveled based on GPS recordings</li><li class="listitem" style="list-style-type: disc">How to download road map data and transform it into a network of roads</li><li class="listitem" style="list-style-type: disc">How to store the road network in a database</li><li class="listitem" style="list-style-type: disc">How to generate your own records of journeys using a GPS tracking device</li><li class="listitem" style="list-style-type: disc">How to implement a map matching algorithm to match GPS recordings to an existing road network, and use the results to calculate how often each road segment was used</li><li class="listitem" style="list-style-type: disc">How to generate a great-looking GPS Heatmap using this calculated data</li></ul></div><p>Let's start by examining the concept of map matching, and see how it can be useful in solving various geospatial problems.</p><div><div><div><div><h1 class="title"><a id="ch06lvl1sec40"/>Matching GPS data against a map</h1></div></div></div><p>A GPS recording<a id="id432" class="indexterm"/> device <a id="id433" class="indexterm"/>captures a series of latitude and longitude coordinates over time. As the device is carried by someone moving from place to place, the GPS coordinates record the person's movements. The following map shows a typical GPS recording:</p><div><img src="img/B04102_6_01.jpg" alt="Matching GPS data against a map"/></div><p>GPS devices are relatively <a id="id434" class="indexterm"/>cheap and remarkably accurate, allowing <a id="id435" class="indexterm"/>you to record a journey taken on foot, by bicycle, car, or truck. However, by itself, all the GPS device is doing is recording a series of coordinates—the GPS device doesn't know which roads you followed on your journey.</p><p>
<strong>Map matching</strong><a id="id436" class="indexterm"/> is the process of taking a GPS recording and matching it against a database of roads to identify which set of roads were used on that journey. For map matching to be successful, you need three things:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An accurate GPS recording of the journey, including enough GPS coordinates to identify which roads were taken.</li><li class="listitem" style="list-style-type: disc">An accurate database of roads.</li><li class="listitem" style="list-style-type: disc">A suitable algorithm to match the GPS coordinates against the road database.</li></ul></div><p>Once you know which roads were taken, you can use this information for various purposes. For example, a turn-by-turn navigation system will use its knowledge of the road database and the path taken so far to suggest the next turn to take.</p><p>You can also use map matching for historical purposes: keeping track of which routes a traveler took on their journey, possibly to optimize future journeys, or noting which roads were most commonly traveled.</p><p>In this chapter, we will implement a complete map matching system, using an appropriate database of road data and a sophisticated algorithm for matching a GPS recording against those roads. We will use this information to generate a heatmap of commonly-used roads over a series of historical GPS recordings.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec41"/>An overview of the GPS Heatmap system</h1></div></div></div><p>The system we are<a id="id437" class="indexterm"/> implementing will be called the <a id="id438" class="indexterm"/>
<strong>GPS Heatmap</strong>. We will download a set of road data and convert this data into a network of directed road segments. We will then either generate or download a collection of GPS recordings from various journeys, which we will use to identify commonly-traveled roads. Finally, we will generate a heatmap based on how often the roads are traveled, providing a visual summary of the most commonly-traveled roads captured by the GPS device. The resulting output will look something like the following:</p><div><img src="img/B04102_6_02.jpg" alt="An overview of the GPS Heatmap system"/></div><div><div><h3 class="title"><a id="note33"/>Note</h3><p>A heatmap<a id="id439" class="indexterm"/> typically uses a color gradient ranging from blue to red to draw the roads, with blue used for the less-traveled roads and red for the most commonly traveled roads. In the printed edition of this book, however, the heatmaps will appear in black and white, so we have selected a single shade of blue so that the heatmap still makes sense when printed.</p></div></div><p>To allow our GPS Heatmap program to work as efficiently as possible, we will make use of a PostGIS database to store the underlying road data. We will generate a planar graph of the nonintersecting road segments, use this data to build a network of connected road segments, and store this network in the database for quick access. We will then use a map matching algorithm to calculate a <strong>tally</strong> for each road segment. These tallies then form the basis for generating the GPS heatmap image, with a suitable color chosen for each road segment based on the calculated tally for that segment.</p><p>Because our GPS Heatmap program consists of many parts, we will implement it as a suite of individual Python programs:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">init_db.py</code>: This will <a id="id440" class="indexterm"/>initialize the PostGIS database, providing us with a place to store the data as we load and process it.</li><li class="listitem" style="list-style-type: disc"><code class="literal">import_roads.py</code>: This <a id="id441" class="indexterm"/>will import the road data from a shapefile into the PostGIS database.</li><li class="listitem" style="list-style-type: disc"><code class="literal">split_roads.py</code>: This will convert<a id="id442" class="indexterm"/> the imported roads into a series of nonoverlapping road segments by calculating a planar graph based on the raw road data.</li><li class="listitem" style="list-style-type: disc"><code class="literal">calc_directed_network.py</code>: This will use the road segments to generate a directed network of <a id="id443" class="indexterm"/>connected road segments. This tells us how the various road segments are connected, and which segments lead off from a given point.</li><li class="listitem" style="list-style-type: disc"><code class="literal">map_matcher.py</code>: This performs<a id="id444" class="indexterm"/> the actual map matching process, reading the raw GPS data from a GPX format file, using it to identify which road segments were traveled by the person using that GPS device, and incrementing the tally for each road segment as it is used.</li><li class="listitem" style="list-style-type: disc"><code class="literal">generate_heatmap.py</code>: This will use the <a id="id445" class="indexterm"/>calculated tally data to generate a heatmap image for display.</li></ul></div><p>Before we can start implementing these various programs, we will need to obtain the underlying data. Let's look at how to do this now.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec42"/>Obtaining the necessary data</h1></div></div></div><p>Your first choice is to decide <a id="id446" class="indexterm"/>which GPS dataset to use. You can capture your own GPS recordings using a GPS device if you wish, or you can make use of the GPS recordings provided with the example code for this chapter. Once you have decided which set of GPS data to use, you will need to download road data for the same area.</p><p>Let's start by deciding which set of GPS data you wish to use.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec54"/>Obtaining GPS data</h2></div></div></div><p>If you have your own <a id="id447" class="indexterm"/>GPS recording device, you might like to go out and capture your own GPS recordings as you travel back and forth in your local area. If you do not have your own GPS recording device, or if you do not want to capture your own GPS data, example GPS recordings are provided along with the sample code for this chapter.</p><p>These example recordings were taken in and around the author's home city of Rotorua, New Zealand. The recordings were captured using a Garmin Edge 500 cycle computer, and exported in <code class="literal">GPX</code> format. If you want to capture your own GPS recordings, make sure you record at least 20 separate journeys so that you have a good set of data to work with.</p><div><div><h3 class="title"><a id="note34"/>Note</h3><p>Not every GPS recording will be usable. Sometimes, the GPS data can be too inaccurate or might miss sections of your journey, leading to matching errors. Also, limitations in the map matching algorithm mean that any journey which U-turns along a road, or uses the same road segment twice, cannot be matched. For this reason, you may find that some of your recordings do not work.</p></div></div><p>Whether you use the sample recordings or create your own, place the resulting <code class="literal">GPX</code> format files into a directory named <code class="literal">gps-data</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec55"/>Downloading the road data</h2></div></div></div><p>Once you have your <a id="id448" class="indexterm"/>GPS recordings, you next need a matching set of road data. If your GPS recordings were taken in the USA, you can use the TIGER data from the US Census Bureau's website. We used this site in the previous chapter to download all primary and secondary roads in California. In this case, you will want to download all the roads in your area. To do this:</p><div><ol class="orderedlist arabic"><li class="listitem">Go <a id="id449" class="indexterm"/>to <a class="ulink" href="https://www.census.gov/geo/maps-data/data/tiger-line.html">https://www.census.gov/geo/maps-data/data/tiger-line.html</a>, scroll down to the section labeled <strong>2014 TIGER/Line Shapefiles</strong>, click on the <strong>Download</strong> option, and then click on <strong>Web interface</strong>.</li><li class="listitem">From the download page, choose <strong>Roads</strong> from the <strong>Select a layer type</strong> drop-down menu, and then click on the <strong>Submit</strong> button.</li><li class="listitem">Choose your state from the <strong>All Roads</strong> drop-down menu, and click on <strong>Submit</strong>.</li><li class="listitem">You will then need to choose the county you are in, and finally you can click on the <strong>Download</strong> button to obtain the road data you need.</li></ol></div><p>If you are outside the USA, you will need to find a suitable alternative. OpenStreetMap (<a class="ulink" href="http://openstreetmap.org">http://openstreetmap.org</a>) is one<a id="id450" class="indexterm"/> possible source of data, though you may need to hunt to find road data in a format you can use. Alternatively, the <a class="ulink" href="https://koordinates.com">https://koordinates.com</a> site<a id="id451" class="indexterm"/> might have data you can use.</p><p>If you want to make use<a id="id452" class="indexterm"/> of the example GPS recordings provided in this chapter, take the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Go to <a class="ulink" href="https://koordinates.com">https://koordinates.com</a>.</li><li class="listitem">Click on the <strong>Sign in</strong> link in the upper-right-hand corner of the page.</li><li class="listitem">Register for a free account by clicking on the <strong>Register</strong> link.</li><li class="listitem">After signing in, you will see a map centered on your location. Pan the map over to New Zealand and zoom in on the central North Island until you find the city of Rotorua.</li><li class="listitem">Click on the search box in the upper-left corner of the page, type <code class="literal">road centrelines</code> and press <em>Return</em>.<div><div><h3 class="title"><a id="note35"/>Note</h3><p>Note the New Zealand spelling for the word "centrelines"; if you type <code class="literal">centerlines</code>, you won't find the data you're looking for.</p></div></div></li><li class="listitem">The dataset you are looking for is called <em>Improved NZ Road Centrelines (August 2011)</em>. Click on the <strong>+</strong> icon beside this dataset, and the road data will appear on your map.</li><li class="listitem">
Next, zoom in further to show the city of Rotorua and its environs, click on the crop tool (<img src="img/B04102_6_03.jpg" alt="Downloading the road data"/>) in the upper-right-hand corner of the page, and drag out a rectangle that looks approximately like the following screenshot:
<div><img src="img/B04102_6_04.jpg" alt="Downloading the road data"/></div></li><li class="listitem">Once this has <a id="id453" class="indexterm"/>been selected, click on the <strong>Download or Order</strong> link in the upper-right-hand corner of the window. The default options (WGS 84 map projection and shapefile format) are exactly what you want, so just click on the <strong>Accept terms and create download</strong> button.</li><li class="listitem">After a minute or so, the road data will be available for you to download. The resulting file will be named <code class="literal">kx-improved-nz-road-centrelines-august-2011-SHP.zip</code>. Decompress this ZIP archive, rename the resulting directory to <code class="literal">roads</code>, and place this directory somewhere convenient.</li></ol></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec43"/>Implementing the GPS Heatmap system</h1></div></div></div><p>Now that we have the<a id="id454" class="indexterm"/> necessary data, we're ready to start implementing our GPS Heatmap system. Create a directory named <code class="literal">gps-heatmap</code> to hold the suite of programs and their associated data files, and then place the two data directories you created earlier (<code class="literal">gps-data</code> and <code class="literal">roads</code>) into this directory.</p><p>We're now ready to start coding. Let's start by implementing the <code class="literal">init_db.py</code> program to initialize our PostGIS database.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec56"/>Initializing the database</h2></div></div></div><p>You should already have <a id="id455" class="indexterm"/>installed Postgres when you worked through <a class="link" href="ch03.html" title="Chapter 3. Spatial Databases">Chapter 3</a>, <em>Spatial Databases</em>. We're going to use Postgres to create and initialize a database to hold all our processed road data. The first step is to create the database itself, which you can do by typing the following into a terminal window:</p><div><pre class="programlisting">
<strong>% createdb gps_heatmap</strong>
</pre></div><p>This should create a database named <code class="literal">gps_heatmap</code>. If you get an authentication error, you will need to enter a password or use the <code class="literal">-U postgres</code> command-line option so that the <code class="literal">createdb</code> command can run.</p><p>Now that you have created the database itself, the next step is to turn it into a spatial database so we can use it to store geometry data. To do this, enter the following command into the terminal window:</p><div><pre class="programlisting">
<strong>% psql -d gps_heatmap -c "CREATE EXTENSION postgis;"</strong>
</pre></div><div><div><h3 class="title"><a id="tip14"/>Tip</h3><p>Do not forget to add the <code class="literal">-U postgres</code> command-line option if you need it.</p></div></div><p>You have now created a spatial database for your Python code to use. We are now going to write the <code class="literal">init_db.py</code> script that initializes the various tables and indexes within this database. Go ahead and create the <code class="literal">init_db.py</code> file inside your main <code class="literal">gps-heatmap</code> directory, and enter the following code into this file:</p><div><pre class="programlisting">import psycopg2

connection = psycopg2.connect(database="gps_heatmap",
                              user="postgres")
cursor = connection.cursor()

cursor.execute("DROP TABLE IF EXISTS roads")
cursor.execute("CREATE TABLE roads (" +
                   "id SERIAL PRIMARY KEY," +
                   "name VARCHAR," + 
                   "centerline GEOMETRY)")
cursor.execute("CREATE INDEX ON roads USING GIST(centerline)")

 connection.commit()</pre></div><p>As you can see, we are using the <code class="literal">psycopg2</code> library to access our PostGIS database. We create a database connection and an associated <code class="literal">cursor</code> object. We then create the <code class="literal">roads</code> database table, first deleting it so that we can run this script again if we have to change the database structure.</p><div><div><h3 class="title"><a id="tip15"/>Tip</h3><p>Don't forget to change the parameters to the <code class="literal">psycopg2.connect()</code> statement if you need to use a different username or password to access PostGIS on your computer.</p></div></div><p>The <code class="literal">roads</code> table <a id="id456" class="indexterm"/>will hold the raw road data imported from the shapefile that we have just downloaded. As you can see, this table will have three separate fields:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">id</code>: This is the unique ID for this road in the database</li><li class="listitem" style="list-style-type: disc"><code class="literal">name</code>: This is the name of the road</li><li class="listitem" style="list-style-type: disc"><code class="literal">centerline</code>: This is a LineString geometry that represents the shape of this road</li></ul></div><p>This is not the only database table we need, but it is enough to get us started. We will add more table definitions to the <code class="literal">init_db.py</code> program as we go along. For now, though, you should be able to run this program to create the <code class="literal">roads</code> table, which we will need in the next section when we import the downloaded road data into the database.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec57"/>Importing the road data</h2></div></div></div><p>We are now ready to import the <a id="id457" class="indexterm"/>road data from the downloaded shapefile into the database. The program that will do this is called <code class="literal">import_roads.py</code>. Go ahead and create this file, and enter the following Python code into it:</p><div><pre class="programlisting">import psycopg2
from osgeo import ogr

connection = psycopg2.connect(database="gps_heatmap",
                              user="postgres")
cursor = connection.cursor()

cursor.execute("DELETE FROM roads")</pre></div><p>So far, all we have done is to open a connection to the database and delete the existing contents of the <code class="literal">roads</code> table. Next, we need to import the road data from the shapefile we downloaded. How we do this, of course, will vary depending on where the road data came from. For the <em>Improved NZ Road Centrelines</em> data, we will use the following code:</p><div><pre class="programlisting">shapefile = ogr.Open("roads/improved-nz-road-centrelines-august-2011.shp")
layer = shapefile.GetLayer(0)

for i in range(layer.GetFeatureCount()):
    feature = layer.GetFeature(i)
    geometry = feature.GetGeometryRef()

    if feature.GetField("descr") != None:
        name = feature.GetField("descr")
    elif feature.GetField("label") != None:
        name = feature.GetField("label")
    else:
        name = None

    centerline_wkt = geometry.ExportToWkt()

    cursor.execute("INSERT INTO roads (name, centerline) " +
                   "VALUES (%s, ST_GeomFromText(%s))",
                   (name, centerline_wkt))

connection.commit()</pre></div><p>As you can see, we use <a id="id458" class="indexterm"/>OGR to import the road data from the shapefile, and use either the <code class="literal">descr</code> or the <code class="literal">label</code> field for the road name. This corresponds to the way the <em>NZ Road Centrelines</em> data has been defined, where sometimes the road name is in the <code class="literal">descr</code> field, and at other times the road name is in the <code class="literal">label</code> field. Some roads don't have a name (for example, where the road goes through a roundabout), and so in this case the road name will be set to <code class="literal">None</code>.</p><p>If you are using a different source of road data, you will need to modify this code to suit the way your road data is organized. Just make sure that you store the centerline and (where applicable) the name of the road into the <code class="literal">roads</code> table.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec58"/>Splitting the road data into segments</h2></div></div></div><p>As we have seen in the <a id="id459" class="indexterm"/>previous chapter, the points where roads touch or cross aren't automatically considered to be connection points for the purpose of building a road network. We first need to create a <strong>planar graph</strong><a id="id460" class="indexterm"/> out of the intersecting roads, just like we did in the previous chapter. Our next task, therefore, is to split the roads up into segments, forming a planar graph of road segments out of the raw road data.</p><p>The <code class="literal">split_roads.py</code> program will split the raw road data into segments. Before we can write this program, however, we need to add a table to the database which will hold the road segments. To do this, add the following code to your <code class="literal">init_db.py</code> program, immediately before the call to <code class="literal">connection.commit()</code>:</p><div><pre class="programlisting">cursor.execute("DROP TABLE IF EXISTS road_segments")
cursor.execute("CREATE TABLE road_segments (" +
               "id SERIAL PRIMARY KEY," +
               "name VARCHAR," + 
               "centerline GEOMETRY," +
               "tally INTEGER)")
cursor.execute("CREATE INDEX ON road_segments USING GIST(centerline)")</pre></div><p>As you can see, we create a<a id="id461" class="indexterm"/> new table called <code class="literal">road_segments</code> to hold the various segments in our planar graph. Each road segment will have the following fields:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">id</code>: This is the unique ID for this road segment.</li><li class="listitem" style="list-style-type: disc"><code class="literal">name</code>: This is the name of the road this segment is a part of.</li><li class="listitem" style="list-style-type: disc"><code class="literal">centerline</code>: This is a LineString geometry representing the shape of this road segment.</li><li class="listitem" style="list-style-type: disc"><code class="literal">tally</code>: This is the number of times this road segment was used by the GPS recordings. This is the output of the map matching algorithm we will implement later in this chapter.</li></ul></div><p>Now that we've created the <code class="literal">road_segments</code> table, we can start implementing the <code class="literal">split_roads.py</code> program. Create this file and add the following code to it:</p><div><pre class="programlisting">import psycopg2
import shapely.wkt
import shapely

connection = psycopg2.connect(database="gps_heatmap",
                              user="postgres")
cursor = connection.cursor()

cursor.execute("DELETE FROM road_segments")</pre></div><p>So far, we have simply opened a connection to the database and deleted any existing <code class="literal">road_segments</code> records. As usual, this gives us a blank table where we can store our calculated road segments, removing any segments that we may have stored previously. This allows us to run the program as often as we need.</p><p>Next, we want to convert the contents of the <code class="literal">roads</code> table into a series of connected road segments. In the previous chapter, we used Shapely to perform this task using road data held in memory. This time, we're going to implement the same process using PostGIS. First, we are going to load a master list of all the <code class="literal">road</code> record IDs into memory:</p><div><pre class="programlisting">all_road_ids = []
cursor.execute("SELECT id FROM roads")
for row in cursor:
    all_road_ids.append(row[0])</pre></div><p>We will work through each of these roads in turn. For each road, we start by loading the road's name and geometry into memory:</p><div><pre class="programlisting">for road_id in all_road_ids:
    cursor.execute("SELECT name,ST_AsText(centerline) " +
                   "FROM roads WHERE id=%s", (road_id,))
    name,wkt = cursor.fetchone()
    cur_road = shapely.wkt.loads(wkt)</pre></div><p>Now that we have got the <a id="id462" class="indexterm"/>road's LineString geometry, we want to split it at each point where it touches or crosses another road. To do this, we'll build a list of <strong>crossroads</strong><a id="id463" class="indexterm"/> for this road:</p><div><pre class="programlisting">    crossroads = []
    cursor.execute("SELECT ST_AsText(centerline) FROM ROADS" +
                   "WHERE ST_Touches(roads.centerline, " +
                   "ST_GeomFromText(%s)) OR ST_Crosses(" +
                   "roads.centerline, ST_GeomFromText(%s))",
                   (wkt, wkt))
    for row in cursor:
        crossroad = shapely.wkt.loads(row[0])
        crossroads.append(crossroad)</pre></div><p>We then use the crossroads to split the current road's geometry into one or more segments:</p><div><pre class="programlisting">    for crossroad in crossroads:
        cur_road = cur_road.difference(crossroad)</pre></div><p>Next, we need to process the resulting road, dividing it up into a separate LineString for each road segment:</p><div><pre class="programlisting">    segments = []
    if cur_road.geom_type == "MultiLineString":
        for segment in cur_road.geoms:
            segments.append(segment)
    elif cur_road.geom_type == "LineString":
        segments.append(cur_road)</pre></div><p>Then, we save the calculated segments into the <code class="literal">road_segments</code> table:</p><div><pre class="programlisting">    for segment in segments:
        centerline_wkt = shapely.wkt.dumps(segment)
        cursor.execute("INSERT INTO road_segments (name, " +
                       "centerline, tally) VALUES (%s, " +
                       "ST_GeomFromText(%s), %s)",
                       (name, centerline_wkt, 0))</pre></div><p>Finally (outside the <code class="literal">for road_id in all_road_ids</code> loop), we commit our changes to the database:</p><div><pre class="programlisting">connection.commit()</pre></div><p>This completes our <code class="literal">split_roads.py</code> program. If you run through the programs in sequence, and then use the <code class="literal">psql</code> command-line client to access the database, you can see that the program has indeed generated a number of road segments out of the raw road data:</p><div><pre class="programlisting">
<strong>% python init_db.py</strong>
<strong>% python import_roads.py</strong>
<strong>% python split_roads.py</strong>
<strong>% psql gps_heatmap</strong>
<strong># SELECT count(*) from roads;</strong>
<strong>1556</strong>
<strong># SELECT count(*) from road_segments;</strong>
<strong>3240</strong>
</pre></div><p>As you would expect, there<a id="id464" class="indexterm"/> are many more segments than there are roads.</p><div><div><h3 class="title"><a id="note36"/>Note</h3><p>If you want to view the road segments, you can easily write a program using Mapnik which displays the contents of the <code class="literal">road_segments</code> table. A version of this program, named <code class="literal">preview_segments.py</code>, is included in the sample code for this chapter.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec59"/>Constructing a network of directed road segments</h2></div></div></div><p>When we try to match the <a id="id465" class="indexterm"/>recorded GPS data against a database of road segments, one of the important questions we will need to answer is, "Which other road segments lead off from this one?" To answer this question, we will need to build a <strong>directed network</strong><a id="id466" class="indexterm"/> of road segments.</p><p>We did something similar to this in the previous chapter, where we used NetworkX to calculate the shortest path between two points. In this case, however, we are going to store the network in the database for later use.</p><p>To make the map matching algorithm easier to implement, our network of road segments will be <strong>directed</strong>—that is, each segment in our <code class="literal">road_segments</code> table will actually be represented by two separate road segments:</p><div><img src="img/B04102_6_05.jpg" alt="Constructing a network of directed road segments"/></div><div><div><h3 class="title"><a id="note37"/>Note</h3><p>Of course, not every road is two-way, but we are ignoring this to keep things easier.</p></div></div><p>As you can see, each <a id="id467" class="indexterm"/>road segment is converted into two directed segments: one running from point A to point B, and the other running from point B back to point A.</p><p>We are going to use a new table named <code class="literal">directed_segments</code> to hold the directed road segments. Each directed segment record will have the following fields:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">id</code>: This is the unique ID for this road segment</li><li class="listitem" style="list-style-type: disc"><code class="literal">road_segment_id</code>: This is the record ID of the road segment this directed segment is derived from</li><li class="listitem" style="list-style-type: disc"><code class="literal">centerline</code>: This is the LineString geometry for this directed segment</li></ul></div><p>Note that the directed segment's LineString runs in the same direction as the segment itself—that is, the start of the directed segment is at <code class="literal">centerline.coords[0]</code> and the end of the directed segment is at <code class="literal">centerline.coords[-1]</code>.</p><p>A second table, <code class="literal">endpoints</code>, will hold the coordinates for the ends of the various directed road segments. Each endpoint record will have the following fields:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">id</code>: This is the unique ID for this endpoint</li><li class="listitem" style="list-style-type: disc"><code class="literal">endpoint</code>: This is a Point geometry containing the coordinates for this endpoint<div><div><h3 class="title"><a id="note38"/>Note</h3><p>We use a Point geometry here so that we can make spatial queries against this table.</p></div></div></li></ul></div><p>Finally, we are going to need a table that identifies which directed road segments leave from a given endpoint. This table, <code class="literal">endpoint_segments</code>, will have the following fields:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">id</code>: This is the unique ID for this <code class="literal">endpoint_segments</code> record</li><li class="listitem" style="list-style-type: disc"><code class="literal">directed_segment_id</code>: This is the record ID of a directed road segment</li><li class="listitem" style="list-style-type: disc"><code class="literal">endpoint_id</code>: This is the record ID of the endpoint that this directed road segment leaves from</li></ul></div><p>These three tables will be used to store the network of directed road segments. Let's modify our <code class="literal">init_db.py</code> program to create these three new tables. To do this, add the following code to the end of this file, immediately before the call to <code class="literal">connection.commit()</code>:</p><div><pre class="programlisting">cursor.execute("DROP TABLE IF EXISTS directed_segments")
cursor.execute("CREATE TABLE directed_segments (" +
               "id SERIAL PRIMARY KEY," +
               "road_segment_id INTEGER," +
               "centerline GEOMETRY)")
cursor.execute("CREATE INDEX ON directed_segments USING GIST(centerline)")

cursor.execute("DROP TABLE IF EXISTS endpoints")
cursor.execute("CREATE TABLE endpoints (" +
               "id SERIAL PRIMARY KEY," +
               "endpoint GEOMETRY)")
cursor.execute("CREATE INDEX ON endpoints USING GIST(endpoint)")

cursor.execute("DROP TABLE IF EXISTS endpoint_segments")
cursor.execute("CREATE TABLE endpoint_segments (" +
               "id SERIAL PRIMARY KEY," +
               "directed_segment_id INTEGER," +
               "endpoint_id INTEGER)")
cursor.execute("CREATE INDEX ON endpoint_segments(directed_segment_id)")
cursor.execute("CREATE INDEX ON endpoint_segments(endpoint_id)")</pre></div><p>This is the last change we'll<a id="id468" class="indexterm"/> need to make to our database structure, so go ahead and re-create the database tables, import the roads, and split them again:</p><div><pre class="programlisting">
<strong>% python init_db.py</strong>
<strong>% python import_roads.py</strong>
<strong>% python split_roads.py</strong>
</pre></div><div><div><h3 class="title"><a id="note39"/>Note</h3><p>We wouldn't need to rerun our programs each time if we'd used database migrations, but we are keeping the database logic as simple as possible. Fortunately, this is the last time we will need to do this.</p></div></div><p>We are now ready to calculate the directed road network and store it into the database. The program we will create is called <code class="literal">calc_directed_network.py</code>; create this file, and enter the following code into it:</p><div><pre class="programlisting">import networkx
import psycopg2
import shapely.wkt
import shapely.geometry

connection = psycopg2.connect(database="gps_heatmap", user="postgres")
cursor = connection.cursor()</pre></div><p>We are now ready to create <a id="id469" class="indexterm"/>the NetworkX graph representing the road network. When we did this in the previous chapter, we used the <code class="literal">networkx.read_shp()</code> function to create a NetworkX <code class="literal">DiGraph</code> object from the contents of a shapefile. Unfortunately, there's no equivalent function for creating a graph from the contents of a PostGIS database; however, since NetworkX is implemented in Python, it is easy to adapt the source code for the <code class="literal">read_shp()</code> function to do what we want. Add the following code to the end of your <code class="literal">calc_directed_network.py</code> program:</p><div><pre class="programlisting">network = networkx.Graph()

cursor.execute("SELECT id,ST_AsText(centerline) FROM road_segments")
for row in cursor:
    road_segment_id,wkt = row
    linestring = shapely.wkt.loads(wkt)

    first_pt = linestring.coords[0]
    last_pt  = linestring.coords[-1]

    network.add_edge(first_pt, last_pt,
                     {'road_segment_id' : road_segment_id})</pre></div><p>The nodes in the NetworkX graph are a <code class="literal">(long,lat)</code> tuple identifying each road segment's endpoints, and the edges represent the directed road segments. Note that we store the record ID of the road segment as an attribute in the graph so that we can refer to it later.</p><p>Now that we have the NetworkX graph, let's prepare to use it to generate the directed network of connected road segments. To do this, we have to calculate the <strong>largest connected subgraph</strong><a id="id470" class="indexterm"/> from the graph we have built, just like we did in the previous chapter. Here is the necessary code:</p><div><pre class="programlisting">sub_graphs = list(networkx.connected_component_subgraphs(network))
largest = sub_graphs[0]</pre></div><p>We now have a graph containing all the connected road segments. We can now use this to store the road segment endpoints into the database:</p><div><pre class="programlisting">cursor.execute("DELETE FROM endpoints")

endpoint_ids = {}
for node in largest.nodes():
    point = shapely.geometry.Point(node)
    wkt = shapely.wkt.dumps(point)

    cursor.execute("INSERT INTO endpoints (endpoint) " +
                   "VALUES (ST_GeomFromText(%s)) RETURNING id",
                   (wkt,))
    endpoint_id = cursor.fetchone()[0]

    endpoint_ids[node] = endpoint_id</pre></div><p>Notice that the <code class="literal">endpoint_ids</code> dictionary maps a <code class="literal">(long,lat)</code> coordinate to the record ID of the endpoint in the database. We will use this to link the directed road segments to their endpoints.</p><p>Our final task is to<a id="id471" class="indexterm"/> store the directed road segments, along with the endpoint the segment starts from. We'll start by deleting the existing records in the database, and iterating over the road segments in our graph:</p><div><pre class="programlisting">cursor.execute("DELETE FROM directed_segments")
cursor.execute("DELETE FROM endpoint_segments")

for node1,node2 in largest.edges():
    endpoint_id_1 = endpoint_ids[node1]
    endpoint_id_2 = endpoint_ids[node2]
    road_segment_id = largest.get_edge_data(node1, node2)['road_segment_id']

    cursor.execute("SELECT ST_AsText(centerline) " +
                   "FROM road_segments WHERE id=%s",
                   (road_segment_id,))
    wkt = cursor.fetchone()[0]
    linestring = shapely.wkt.loads(wkt)</pre></div><p>We now have the record ID of the segment's endpoints, and the LineString defining this road segment. We now need to convert this segment into two <em>directed</em> segments, one heading in each direction:</p><div><pre class="programlisting">    reversed_coords = list(reversed(linestring.coords))
    if node1 == linestring.coords[0]:
        forward_linestring = linestring
        reverse_linestring = shapely.geometry.LineString(reversed_coords)
    else:
        reverse_linestring = linestring
        forward_linestring = shapely.geometry.LineString(reversed_coords)</pre></div><p>This gives us two LineString geometries, one running from the first endpoint to the second, and the other running from the second endpoint back to the first. We can now save the information we've calculated into the database:</p><div><pre class="programlisting">    cursor.execute("INSERT INTO directed_segments " +
                   "(road_segment_id,centerline) VALUES " +
                   "(%s, ST_GeomFromText(%s)) RETURNING id",
                   (road_segment_id, forward_linestring.wkt))
    forward_segment_id = cursor.fetchone()[0]

    cursor.execute("INSERT INTO directed_segments " +
                   "(road_segment_id,centerline) VALUES " +
                   "(%s, ST_GeomFromText(%s)) RETURNING id",
                   (road_segment_id, reverse_linestring.wkt))
    reverse_segment_id = cursor.fetchone()[0]

    cursor.execute("INSERT INTO endpoint_segments " + 
                       "(directed_segment_id, endpoint_id) " +

                       "VALUES (%s, %s)", 

                       (forward_segment_id, endpoint_id_1))


        cursor.execute("INSERT INTO endpoint_segments " + 
                       "(directed_segment_id, endpoint_id) " +

                       "VALUES (%s, %s)", 

                       (reverse_segment_id, endpoint_id_2))</pre></div><p>To finish our program, we have to commit the changes we've made:</p><div><pre class="programlisting">connection.commit()</pre></div><p>You can now create the <a id="id472" class="indexterm"/>network of the directed road segments by running this program:</p><div><pre class="programlisting">
<strong>% python calc_directed_network.py</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec60"/>Implementing the map matching algorithm</h2></div></div></div><p>We are now ready, at long last, to <a id="id473" class="indexterm"/>implement our map matching algorithm. The algorithm we will use is derived from the paper: <em>Map-matching of GPS traces on high-resolution navigation networks using the Multiple Hypothesis Technique (MHT)</em>, written by Nadine Schuessler and Kay Axhausen for the Institute of Transport Planning and Systems in Switzerland.</p><p>If you are interested in reading this paper, it can be found at <a class="ulink" href="http://www.ivt.ethz.ch/vpl/publications/reports/ab568.pdf">www.ivt.ethz.ch/vpl/publications/reports/ab568.pdf</a>. This algorithm is based on the notion of a <a id="id474" class="indexterm"/>
<strong>route candidate</strong>, which is a possible path the traveler could have taken as the GPS points were recorded. Each route candidate has a list of directed road segments and a <strong>score</strong><a id="id475" class="indexterm"/> identifying how closely the GPS points match those road segments.</p><p>The journey is recreated by following the GPS points one at a time. At any particular moment, there is a list of route candidates which could possibly match the GPS coordinates which have been processed thus far. As each new GPS point is processed, the route candidates are updated one at a time by comparing the GPS coordinate with the route candidate's final road segment.</p><p>If the GPS point is considered to still be somewhere on that final segment, then the GPS point is simply added to that segment and the route candidate's score is updated. If, on the other hand, the GPS point is beyond the end of the route candidate's final road segment, then we look at the road network to see which other road segments lead off from that point. We then create new route candidates for each road segment leaving <a id="id476" class="indexterm"/>from that endpoint:</p><div><img src="img/B04102_6_06.jpg" alt="Implementing the map matching algorithm"/></div><p>Once all the GPS points have been processed, we select the route candidate with the lowest score as being the one most likely to have been used for this journey.</p><p>To implement this algorithm, we are going to use Python dictionaries to represent a <strong>route segment</strong><a id="id477" class="indexterm"/>—that is, a single segment within a route candidate's journey. Each route segment dictionary will have the following entries:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">directed_segment_id</code>: This is the record ID of the <code class="literal">directed_segment</code> which this segment of the <a id="id478" class="indexterm"/>route is following</li><li class="listitem" style="list-style-type: disc"><code class="literal">linestring</code>: This is the <a id="id479" class="indexterm"/>road segment's centerline, as a Shapely LineString object</li><li class="listitem" style="list-style-type: disc"><code class="literal">gps_points</code>: This is a<a id="id480" class="indexterm"/> list of (long,lat) coordinates defining the GPS points which have been assigned to this route segment</li><li class="listitem" style="list-style-type: disc"><code class="literal">gps_distances</code>: This is a list<a id="id481" class="indexterm"/> holding the calculated minimum distance between each GPS point and the segment's LineString</li></ul></div><p>Each route candidate is going to be represented by a Python dictionary with the following entries:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">segments</code>: This is a list of the <a id="id482" class="indexterm"/>route segments that make up this route candidate.</li><li class="listitem" style="list-style-type: disc"><code class="literal">directed_segment_ids</code>: This is <a id="id483" class="indexterm"/>a list containing the record ID of each directed segment used by this route. We use this to quickly discard a new route candidate if another route is using the same sequence of road segments.</li><li class="listitem" style="list-style-type: disc"><code class="literal">score</code>: This is<a id="id484" class="indexterm"/> the calculated <a id="id485" class="indexterm"/>score for this route candidate. The score is calculated as the sum of the GPS distances in each route segment—in other words, the lower the score, the more closely the GPS points follow this route.</li></ul></div><p>With this information in mind, let's start implementing the map matcher. Create a new Python program called <code class="literal">map_matcher.py</code>, and enter the following into this file:</p><div><pre class="programlisting">import os
import osgeo.ogr
import shapely.geometry
import shapely.wkt
import psycopg2
import pyproj

gps_tracks = []
for fName in os.listdir("gps-data"):
    if fName.endswith(".gpx"):
        srcFile = osgeo.ogr.Open("gps-data/" + fName)
        layer = srcFile.GetLayerByName("tracks")

        for feature_num in range(layer.GetFeatureCount()):
            feature = layer.GetFeature(feature_num)
            geometry = feature.GetGeometryRef()

            if geometry.GetGeometryName() == "MULTILINESTRING":
                for geom_num in range(geometry.GetGeometryCount()):
                    wkt = geometry.GetGeometryRef(geom_num).ExportToWkt()
                    gps_tracks.append((fName, wkt))
            elif geometry.GetGeometryName() == "LINESTRING":
                wkt = geometry.ExportToWkt()
                gps_tracks.append((fName, wkt))

connection = psycopg2.connect(database="gps_heatmap", user="postgres")
cursor = connection.cursor()</pre></div><p>As you can see, we import the various libraries we'll need, load the recorded GPS data into memory, and open a connection to our database. Next, we want to reset the <code class="literal">tally</code> values for our road segments:</p><div><pre class="programlisting">cursor.execute("UPDATE road_segments SET tally=0")
connection.commit()</pre></div><p>We are now ready to start processing the recorded GPS data. While the paper this algorithm is based on uses a sophisticated process of splitting the GPS data into trip segments, processing each trip segment and then joining the resulting routes together, we are going to use a much <a id="id486" class="indexterm"/>simpler approach; we will assume that each GPS recording has no gaps in it, but that it might start or finish away from a road. To handle this, we trim the start and end coordinates until we reach a point within 10 meters of a road.</p><p>Add the following to the end of your program:</p><div><pre class="programlisting">for fName,track_wkt in gps_tracks:
    print "Processing " + fName

    gps_track  = shapely.wkt.loads(track_wkt)
    gps_points = list(gps_track.coords)

    while len(gps_points) &gt; 0:
        circle = calc_circle_with_radius(gps_points[0], 10)
        cursor.execute("SELECT count(*) FROM road_segments " +
                "WHERE ST_Intersects(ST_GeomFromText(%s)," +
                       "centerline)", (circle.wkt,))
        if cursor.fetchone()[0] == 0:
            del gps_points[0]
        else:
            break

    while len(gps_points) &gt; 0:
        circle = calc_circle_with_radius(gps_points[-1], 10)
        cursor.execute("SELECT count(*) FROM road_segments " +
                "WHERE ST_Intersects(ST_GeomFromText(%s)," +
                       "centerline)", (circle.wkt,))
        if cursor.fetchone()[0] == 0:
            del gps_points[-1]
        else:
            break</pre></div><p>We are simply processing each GPS track in turn, trimming points from the start and end until we find a GPS point which is within 10 meters of a road segment. Notice that we're using a function named <code class="literal">calc_circle_with_radius()</code> to create a Shapely polygon that describes a circle 10 meters around a GPS coordinate, and then ask the database to find any road segments within that circle. Let's go ahead and implement that <code class="literal">calc_circle_with_radius()</code> function; place this at the top of your program, immediately after the <code class="literal">import</code> statements:</p><div><pre class="programlisting">def calc_circle_with_radius(center_point, radius):
    geod = pyproj.Geod(ellps="WGS84")
    sLong,sLat = center_point
    eLong,eLat,iHeading = geod.fwd(sLong, sLat, 0, radius)
    lat_delta = abs(sLat - eLat)
    return shapely.geometry.Point(sLong, sLat).buffer(lat_delta)</pre></div><p>Now that we have the set of relevant GPS points within each recording, we are ready to start map matching. The first step is to build an initial set of route candidates based on the starting GPS point. We do this by identifying all road endpoints within 750 meters of the GPS point, and create<a id="id487" class="indexterm"/> a (single-segment) route candidate for each road segment leading off from those endpoints. Following Schuessler and Axhausen's paper, we ensure that there are at least 25 route candidates, and if there are not, we expand the search area by 100 meters and try again.</p><p>Add the following code to the end of your program:</p><div><pre class="programlisting">    search_distance = 750
    while True:
        circle = calc_circle_with_radius(gps_points[0],
                                         search_distance)

        cursor.execute("SELECT id FROM endpoints " +
                       "WHERE ST_Contains(ST_GeomFromText(%s)," +
                       "endpoint)", (circle.wkt,))
        possible_endpoints = []
        for row in cursor:
            possible_endpoints.append(row[0])

        possible_road_segments = []
        for endpoint_id in possible_endpoints:
            cursor.execute("SELECT directed_segment_id " +
                           "FROM endpoint_segments " +
                           "WHERE endpoint_id=%s", (endpoint_id,))
            for row in cursor:
                directed_segment_id = row[0]
                possible_road_segments.append(
                    (directed_segment_id, endpoint_id))

        route_candidates = []
        for directed_segment_id,endpoint_id in possible_road_segments:
            cursor.execute("SELECT ST_AsText(centerline) " +
                           "FROM directed_segments WHERE id=%s",
                           (directed_segment_id,))
            wkt = cursor.fetchone()[0]
            linestring = shapely.wkt.loads(wkt)
            gps_distance = calc_distance(gps_points[0],
                                         linestring)

            segment = {
                'directed_segment_id' : directed_segment_id,
                'linestring' : linestring,
                'gps_points': [gps_points[0]],
                'gps_distances': [gps_distance]}
            route_segments = [segment]

            candidate = {
                'segments': route_segments,
                'directed_segment_ids' : [directed_segment_id],
                'score': calc_score(route_segments)}
            route_candidates.append(candidate)

        if len(route_candidates) &gt;= 25:
            break
        else:
            search_distance = search_distance + 100
            continue</pre></div><p>As you can see, we create<a id="id488" class="indexterm"/> a single route segment dictionary and a route candidate dictionary for each possible route candidate, storing the results in the <code class="literal">route_candidates</code> list. There are two more functions that we need here: one to calculate the distance from a given point to the closest point within a given Shapely geometry, and another to calculate the score for a given route candidate. Go ahead and add these two functions to the top of your program:</p><div><pre class="programlisting">def calc_distance(point, geometry):
    return shapely.geometry.Point(point).distance(geometry)

def calc_score(route_segments):
    total = 0
    for segment in route_segments:
        total = total + sum(segment['gps_distances'])
    return total</pre></div><p>Now that we have an initial set of route candidates, we have to <strong>develop</strong> them by adding each successive GPS point to each route candidate, generating new route candidates as we reach the end of each road segment. At the same time, we <strong>trim</strong> the list of route candidates to stop it from growing too large.</p><p>The bulk of our work will be done in a function named <code class="literal">develop_route()</code>. This function will take a route candidate and a GPS point (as well as a few other parameters), and return a list of new or updated route candidates to include for processing in the next iteration. Let's write the code which uses this function; add the following to the end of your program:</p><div><pre class="programlisting">    for next_point in gps_points[1:]:
        num_routes_to_process = len(route_candidates)
        for i in range(num_routes_to_process):
            route = route_candidates.pop(0)
            new_candidates = develop_route(next_point, route, route_candidates, cursor)
            route_candidates.extend(new_candidates)</pre></div><p>We process each <a id="id489" class="indexterm"/>route candidate exactly once, first removing it from the list of candidates using <code class="literal">route_candidates.pop(0)</code>, and then passing the candidate to the <code class="literal">develop_route()</code> function. We then add the new or updated route candidates to the end of the <code class="literal">route_candidates</code> list. By the time our <code class="literal">for i in range(num_routes_to_process)</code> loop has finished, we would have processed each route candidate exactly once, either incorporating the GPS point into that route candidate or replacing it with a new set of route candidates.</p><p>Before we start processing the next GPS point, we need to trim the list of route candidates. According to Schuessler and Axhausen, a highly effective way of doing this is to repeatedly remove the route candidate with the highest score until there are no more than 40 remaining candidates. Let's do this now:</p><div><pre class="programlisting">        while len(route_candidates) &gt; 40:
            highest = None
            for index,route in enumerate(route_candidates):
                if highest == None:
                    highest = index
                elif route['score'] &gt; route_candidates[highest]['score']:
                    highest = index
            del route_candidates[highest]</pre></div><div><div><h3 class="title"><a id="tip16"/>Tip</h3><p>Make sure you put this code inside the <code class="literal">for next_point in...</code> loop.</p></div></div><p>Before we implement the <code class="literal">develop_route()</code> function, let's finish writing the main part of our program. We have now processed all the GPS points, so we can check the score for each remaining route candidate and choose the candidate with the lowest score (excluding any candidates with fewer than two route segments). This is the route candidate most likely to have been taken by the GPS points. We then increment the tally for each road segment used by that route. Here is the relevant code:</p><div><pre class="programlisting">    best_route = None
    for route in route_candidates:
        if len(route['segments']) &gt;= 2:
            if best_route == None:
                best_route = route
            elif route['score'] &lt; best_route['score']:
                best_route = route

    if best_route == None: continue

    for segment in best_route['segments']:
        cursor.execute("SELECT road_segment_id " +
                       "FROM directed_segments WHERE id=%s",
                       (segment['directed_segment_id'],))
        road_segment_id = cursor.fetchone()[0]
        cursor.execute("UPDATE road_segments SET tally=tally+1" +
                       "WHERE id=%s", (road_segment_id,))

connection.commit()</pre></div><p>We now need to <a id="id490" class="indexterm"/>implement the <code class="literal">develop_route()</code> function. This function uses the following logic, taken from the paper by Schuessler and Axhausen:</p><div><ol class="orderedlist arabic"><li class="listitem">If the route candidate has only one segment, see whether the GPS point has reached the start of that segment's LineString. If this happens, the GPS recording must be following the directed road segment in the wrong direction, so we discard the route candidate.</li><li class="listitem">See whether the GPS point is still within the route candidate's final segment. If so, add the GPS point to that final segment, recalculate the candidate's score, and return it for further processing.</li><li class="listitem">If the GPS point is beyond the end of the route candidate's final segment, identify the endpoint we have reached and create a new route candidate for each directed road segment leaving from that endpoint. We check the validity of each of the new route candidates, and return the valid candidates for further processing.</li></ol></div><p>Let's start implementing this function:</p><div><pre class="programlisting">def develop_route(next_point, route, route_candidates, cursor):
    if len(route['segments']) == 1:
        if point_at_start_of_segment(next_point,
                                     route['segments'][0]):
            return []

    last_segment = route['segments'][-1]

    if point_in_route_segment(next_point, last_segment):
        next_distance = calc_distance(next_point,
                                      last_segment['linestring'])
        last_segment['gps_points'].append(next_point)
        last_segment['gps_distances'].append(next_distance)
        route['score'] = calc_score(route['segments'])
        return [route]</pre></div><p>This implements the <a id="id491" class="indexterm"/>first two of the steps described earlier. Notice that we use a couple of new functions, <code class="literal">point_at_start_of_segment()</code> and <code class="literal">point_in_route_segment</code>(), to do all the hard work. We'll implement these functions shortly, but first let's work through the process of creating a new set of route candidates once the GPS point has gone past the end of the last route segment.</p><p>The first step in this process is to identify the current endpoint that we have reached. Add the following to the end of your <code class="literal">develop_route()</code> function:</p><div><pre class="programlisting">    last_point = last_segment['linestring'].coords[-1]
    endpoint = shapely.geometry.Point(last_point)

    cursor.execute("SELECT id FROM endpoints " +
                   "WHERE endpoint=ST_GeomFromText(%s)",
                   (endpoint.wkt,))
    endpoint_id = cursor.fetchone()[0]</pre></div><p>Next, we will build a list of all the directed road segments that leave from this endpoint:</p><div><pre class="programlisting">    possible_segment_ids = []
    cursor.execute("SELECT directed_segment_id " +
                   "FROM endpoint_segments " +
                   "WHERE endpoint_id=%s", (endpoint_id,))
    for row in cursor:
        possible_segment_ids.append(row[0])</pre></div><p>We now need to create a new route candidate for each of the possible road segments. For each route candidate, we create a single route segment using that directed road segment:</p><div><pre class="programlisting">    new_candidates = []
    for directed_segment_id in possible_segment_ids:
        cursor.execute("SELECT road_segment_id," +
                       "ST_AsText(centerline) " +
                       "FROM directed_segments " +
                       "WHERE id=%s", (directed_segment_id,))
        road_segment_id,wkt = cursor.fetchone()
        linestring = shapely.wkt.loads(wkt)

        next_distance = calc_distance(next_point, linestring)

        new_segment = {}
        new_segment['directed_segment_id'] = directed_segment_id
        new_segment['linestring'] = linestring
        new_segment['gps_points'] = [next_point]
        new_segment['gps_distances'] = [next_distance]

        new_candidate = {}
        new_candidate['segments'] = []
        new_candidate['segments'].extend(route['segments'])
        new_candidate['segments'].append(new_segment)
        new_candidate['directed_segment_ids'] = []
        new_candidate['directed_segment_ids'].extend(
                            route['directed_segment_ids'])
        new_candidate['directed_segment_ids'].append(directed_segment_id)

        if not route_is_valid(new_candidate, route_candidates,
                              new_candidates):
            continue

        new_candidate['score'] = calc_score(new_candidate['segments'])
        new_candidates.append(new_candidate)
    return new_candidates</pre></div><p>Notice that we check the<a id="id492" class="indexterm"/> new route's validity using another function, <code class="literal">route_is_valid()</code>. We will also have to implement this function.</p><p>This completes the <code class="literal">develop_route()</code> function itself. Let's now write the <code class="literal">point_at_start_of_segment()</code> function, which determines whether the GPS track is running the wrong way along a directed road segment:</p><div><pre class="programlisting">def point_at_start_of_segment(next_point, segment):
    num_points = len(segment['gps_points'])
    if num_points &gt; 0:
        average_distance = sum(segment['gps_distances']) / num_points

        startpoint_coord = segment['linestring'].coords[0]
        startpoint = shapely.geometry.Point(startpoint_coord)
        endpoint_coord = segment['linestring'].coords[-1]
        endpoint = shapely.geometry.Point(endpoint_coord)

        distance_to_start = calc_distance(next_point, startpoint)
        distance_to_end   = calc_distance(next_point, endpoint)

        if distance_to_start &lt; 2 * average_distance:
            if distance_to_end &gt; 2 * average_distance:
                return True
    return False</pre></div><p>This code is a bit of a <a id="id493" class="indexterm"/>kludge, comparing the distance from the current point to the road segment's start and endpoints, but it works well enough for our purposes.</p><p>Next, we need to implement the <code class="literal">point_in_route_segment()</code> function. We will use two separate tests to see whether the point has reached the segment's endpoint. First off, we know we have reached the endpoint if the distance from the GPS point to the closest point on the segment's LineString is equal to the distance from the point to the end of that LineString:</p><div><img src="img/B04102_6_07.jpg" alt="Implementing the map matching algorithm"/></div><p>Here is the first part of the <code class="literal">point_in_route_segment()</code> function, which implements this test:</p><div><pre class="programlisting">def point_in_route_segment(point, segment):
    endpoint = shapely.geometry.Point(segment['linestring'].coords[-1])

    distance_to_linestring = calc_distance(point,
                                           segment['linestring'])
    distance_to_endpoint = calc_distance(point, endpoint)

    if distance_to_linestring == distance_to_endpoint:
        return False</pre></div><p>The second test involves<a id="id494" class="indexterm"/> comparing the length of the final route segment with the length of a LineString built out of the GPS points assigned to that route segment. If the GPS LineString is longer than the road segment, then we must have reached the end of that segment:</p><div><pre class="programlisting">    gps_coords = []
    gps_coords.extend(segment['gps_points'])
    gps_coords.append(point)

    gps_length = shapely.geometry.LineString(gps_coords).length
    segment_length = segment['linestring'].length

    if gps_length &gt; segment_length:
        return False</pre></div><p>Finally, if the GPS point failed both of these tests, then it must still be within the current route segment:</p><div><pre class="programlisting">    return True</pre></div><div><div><h3 class="title"><a id="note40"/>Note</h3><p>The paper by Schuessler and Axhausen suggests a third test, comparing the direction of the GPS track against the direction of the road segment. However, it was not clear how this could be implemented where road segments are complex LineStrings rather than straight line segments, so we won't use this test in our implementation of the map matching algorithm.</p></div></div><p>This completes the <code class="literal">point_in_route_segment()</code> function. The last function we need to implement is <code class="literal">route_is_valid()</code>. A route candidate is considered to be valid if:</p><div><ol class="orderedlist arabic"><li class="listitem">It is unique; that is, there is no other route candidate with the exact same sequence of road segments</li><li class="listitem">Its final road segment does not go back to the start of the previous segment; that is, the route doesn't double back on itself.</li><li class="listitem">The route doesn't include the same directed road segment twice</li></ol></div><p>In order to calculate uniqueness, the <code class="literal">route_is_valid()</code> function will need not only a list of all the current route candidates, but also a list of the new candidates being created by the <code class="literal">develop_route()</code> function. For this reason, the <code class="literal">route_is_valid()</code> function accepts both the current list of route candidates and the list of new candidates being created.</p><p>Here is the first part of the implementation of this function, including the uniqueness check:</p><div><pre class="programlisting">def route_is_valid(route, route_candidates, new_candidates):
    route_roads = route['directed_segment_ids']

    for other_route in route_candidates:
        if route_roads == other_route['directed_segment_ids']:
            return False

    for other_route in new_candidates:
        if route_roads == other_route['directed_segment_ids']:
            return False</pre></div><p>The following code checks that a route does not double back on itself:</p><div><pre class="programlisting">    if len(route['segments']) &gt;= 2:
        last_segment = route['segments'][-1]
        prev_segment = route['segments'][-2]

        last_segment_end   = last_segment['linestring'].coords[-1]
        prev_segment_start = prev_segment['linestring'].coords[0]

        if last_segment_end == prev_segment_start:
            return False</pre></div><p>Finally, we ensure that the same directed road segment isn't being used twice:</p><div><pre class="programlisting">    directed_segment_ids = set()
    for segment in route['segments']:
        directed_segment_id = segment['directed_segment_id']
        if directed_segment_id in directed_segment_ids:
            return False
        else:
            directed_segment_ids.add(directed_segment_id)</pre></div><p>If the route passes all three checks, then it is considered to be valid:</p><div><pre class="programlisting">    return True</pre></div><p>This completes the <a id="id495" class="indexterm"/>implementation of the <code class="literal">route_is_valid()</code> function, and indeed the implementation of the entire <code class="literal">map_matcher.py</code> program. You should be able to run it from the command line and see each GPS recording being processed in turn:</p><div><pre class="programlisting">
<strong>% python map_matcher.py</strong>
<strong>Processing ride_2015_01_08.gpx</strong>
<strong>Processing ride_2015_01_11.gpx</strong>
<strong>Processing ride_2015_01_23.gpx</strong>
<strong>...</strong>
</pre></div><p>Because there are thousands of points in each GPS recording, the program will take a few minutes to process each file. Once it has finished, the <code class="literal">tally</code> field in the <code class="literal">road_segments</code> table would have been updated to show the number of times each road segment was used. You can check this using the Postgres command-line client:</p><div><pre class="programlisting">
<strong>% psql gps_heatmap</strong>
<strong># SELECT name,tally FROM road_segments WHERE tally &gt; 0 ORDER BY tally DESC;</strong>
<strong> 3560 | otonga rd                        |    42</strong>
<strong> 6344 | wychwood cres                    |    42</strong>
<strong> 3561 | otonga rd                        |    42</strong>
<strong> 3557 | otonga rd                        |    42</strong>
<strong> 3558 | otonga rd                        |    42</strong>
<strong> 3559 | otonga rd                        |    42</strong>
<strong> 6343 | wychwood cres                    |    41</strong>
<strong> 6246 | springfield rd                   |    19</strong>
<strong> 6300 | old taupo rd                     |    19</strong>
</pre></div><p>As you can see, map <a id="id496" class="indexterm"/>matching is quite a complex process, but this program actually works pretty well. Now that we've calculated the tallies, we can write the final part of our GPS Heatmap system: the program that displays the heatmap based on the calculated tally values.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec61"/>Generating the GPS heatmap</h2></div></div></div><p>We are going to use <a id="id497" class="indexterm"/>Mapnik to generate the heatmap, creating a separate <code class="literal">mapnik.Rule</code> for each unique tally value so that the color used for each road segment varies depending on its tally. This program will be called <code class="literal">generate_heatmap.py</code>; create this program and enter the following code into it:</p><div><pre class="programlisting">import mapnik
import psycopg2

MAX_WIDTH = 1200
MAX_HEIGHT = 800
MIN_TALLY = 3

connection = psycopg2.connect(database="gps_heatmap",
                              user="postgres")
cursor = connection.cursor()</pre></div><p>After importing the libraries we need and defining some constants, we open up a connection to the database so that we can calculate the highest tally value and the bounds of the calculated heatmap. Let's do that now:</p><div><pre class="programlisting">cursor.execute("SELECT max(tally) FROM road_segments")
max_tally = cursor.fetchone()[0]

cursor.execute("SELECT ST_XMIN(ST_EXTENT(centerline)), " +
               "ST_YMIN(ST_EXTENT(centerline)), " +
               "ST_XMAX(ST_EXTENT(centerline)), " +
               "ST_YMAX(ST_EXTENT(centerline)) " +
               "FROM road_segments WHERE tally &gt;= %s" % MIN_TALLY)
min_long,min_lat,max_long,max_lat = cursor.fetchone()</pre></div><p>As you can see, we use the <code class="literal">MIN_TALLY</code> constant to zoom in on the more popular parts of the heatmap. You can change this value if you want; setting it to <code class="literal">1</code> will display every road segment covered by a GPS track, and setting it to a higher value will focus in on the most commonly used portions of the map.</p><p>Now that we know the area <a id="id498" class="indexterm"/>of the Earth covered by the heatmap, we can calculate the dimensions of the map image. We want to use the specified maximum size, while maintaining the aspect ratio of the map:</p><div><pre class="programlisting">extent = mapnik.Envelope(min_long, min_lat,  max_long, max_lat)
aspectRatio = extent.width() / extent.height()

mapWidth = MAX_WIDTH
mapHeight = int(mapWidth / aspectRatio)
if mapHeight &gt; MAX_HEIGHT:
    scaleFactor = float(MAX_HEIGHT) / float(mapHeight)
    mapWidth = int(mapWidth * scaleFactor)
    mapHeight = int(mapHeight * scaleFactor)</pre></div><p>Next, we initialize the map itself:</p><div><pre class="programlisting">map = mapnik.Map(mapWidth, mapHeight)
map.background = mapnik.Color("white")</pre></div><p>Even though only some of the road segments would have been used by the GPS recordings, we still want to show all the unused road segments as a backdrop for the heatmap. To do this, we will create an <code class="literal">unused_roads</code> layer and corresponding Mapnik style:</p><div><pre class="programlisting">layer = mapnik.Layer("unused_roads")
layer.datasource = mapnik.PostGIS(host='localhost',
                                  user='postgres',
                                  password='',
                                  dbname='gps_heatmap',
                                  table='road_segments')
layer.styles.append("unused_road_style")
map.layers.append(layer)

line_symbol = mapnik.LineSymbolizer(mapnik.Color("#c0c0c0"), 1.0)

rule = mapnik.Rule()
rule.filter = mapnik.Filter("[tally] = 0")
rule.symbols.append(line_symbol)

style = mapnik.Style()
style.rules.append(rule)
map.append_style("unused_road_style", style)</pre></div><p>Notice that we use a <code class="literal">mapnik.PostGIS()</code> datasource so that the map layer takes its data directly from our PostGIS database.</p><p>Next, we need to define a map <a id="id499" class="indexterm"/>layer for the roads which were used (that is, the roads which have a <code class="literal">tally</code> value of <code class="literal">1</code> or more). This map layer, which we will call <code class="literal">used_roads</code>, will have a separate <code class="literal">mapnik.Rule()</code> for each unique tally value. This allows us to assign a different color to each unique tally value so that the color used for each road segment varies according to that segment's tally. To implement this, we will need a function that calculates the <code class="literal">mapnik.Stroke()</code> to use for a given tally value. Here is that function, which you should place near the top of your program:</p><div><pre class="programlisting">def calc_stroke(value, max_value):
    fraction = float(value) / float(max_value)

    def interpolate(start_value, end_value, fraction):
        return start_value + (end_value - start_value) * fraction

    r = interpolate(0.7, 0.0, fraction)
    g = interpolate(0.7, 0.0, fraction)
    b = interpolate(1.0, 0.4, fraction)

    color = mapnik.Color(int(r*255), int(g*255), int(b*255))
    width = max(4.0 * fraction, 1.5)

    return mapnik.Stroke(color, width)</pre></div><p>The <code class="literal">interpolate()</code> helper function is used to calculate a color range from pale blue to dark blue. We also adjust the width of the displayed road segment according to the tally so that more frequently used roads are drawn with a wider stroke on the map.</p><div><div><h3 class="title"><a id="tip17"/>Tip</h3><p>If you want, you can change the starting and ending colors to make the heatmap more colorful. As mentioned earlier, we are just using shades of blue so that the heatmap makes sense when printed in black and white.</p></div></div><p>With this function implemented, we can add the <code class="literal">used_roads</code> layer to our map. To do this, add the following code to the end of your program:</p><div><pre class="programlisting">layer = mapnik.Layer("used_roads")
layer.datasource = mapnik.PostGIS(host='localhost',
                                  user='postgres',
                                  password='',
                                  dbname='gps_heatmap',
                                  table='road_segments')
layer.styles.append("used_road_style")
map.layers.append(layer)

style = mapnik.Style()
for tally in range(1, max_tally+1):
    line_symbol = mapnik.LineSymbolizer()
    line_symbol.stroke = calc_stroke(tally, max_tally)

    rule = mapnik.Rule()
    rule.filter = mapnik.Filter("[tally] = %d" % tally)
    rule.symbols.append(line_symbol)

    style.rules.append(rule)
map.append_style("used_road_style", style)</pre></div><p>Finally, we can render the map, saving the <a id="id500" class="indexterm"/>results to an image file on the disk:</p><div><pre class="programlisting">map.zoom_to_box(extent)
mapnik.render_to_file(map, "heatmap.png", "png")</pre></div><p>After running this program, you should get a <code class="literal">heatmap.png</code> file containing the generated heatmap:</p><div><img src="img/B04102_6_08.jpg" alt="Generating the GPS heatmap"/></div><p>Congratulations! This <a id="id501" class="indexterm"/>program is anything but trivial, and solves a number of geospatial problems along the way in producing this image. Of course, you can use this program to match your own GPS recordings against a road network, but what we have really done is shown how complex geospatial problems can be solved one step at a time, using the various techniques described throughout this book.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec44"/>Further improvements</h1></div></div></div><p>While the GPS Heatmap system<a id="id502" class="indexterm"/> works surprisingly well, it is not perfect. No program is ever complete. If you're inclined, you might want to consider the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Make the road-segmentation algorithm more sophisticated to support one-way roads, and points where two roads intersect but do not join (for example, on a highway overpass).</li><li class="listitem" style="list-style-type: disc">Improve the route-development process to allow it to capture routes that include U-turns and repeated road segments.</li><li class="listitem" style="list-style-type: disc">Take the raw GPS data and split it into contiguous segments, process each segment in turn, and then join the processed segments back together again. This will allow the algorithm to work with GPS recordings that include gaps in the recorded data.</li><li class="listitem" style="list-style-type: disc">Combine the map matching algorithm with a shortest-path calculation to write your own turn-by-turn navigation system.</li><li class="listitem" style="list-style-type: disc">Look at ways to improve the speed of the map matching algorithm. For example, if two different route candidates use the same road segment, those two candidates should be able to share the calculated distance between a point and that road segment. This will avoid having to calculate the same distance twice. There are bound to be other ways you could optimize the map matcher so that it runs even faster.</li><li class="listitem" style="list-style-type: disc">Add a nice-looking<a id="id503" class="indexterm"/> raster basemap image to the generated heatmap.</li></ul></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec45"/>Summary</h1></div></div></div><p>Congratulations! You have finished implementing a suite of programs that use a range of geospatial analysis techniques to match recorded GPS data to an existing network of roads. In the process of creating the GPS Heatmap system, you have learned how to convert existing road data into a network, how to represent a network of roads within a database, and how to use this data to implement a sophisticated map matching algorithm. This algorithm was then used to calculate a tally of how often each road segment was used by the recorded GPS data, and the tallies were then used to generate a nice-looking heatmap showing the most commonly used roads.</p><p>Even if you are not interested in capturing your own GPS data and matching it against a map, the techniques we have used in this chapter will give you many ideas for your own development efforts. Using a combination of Python, GDAL and OGR, Shapely, PyProj, PostGIS and Mapnik, you now have a fantastic arsenal of tools for processing, analyzing and displaying geospatial data. To learn more, check out the following references:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://gdal.org">http://gdal.org</a> is the main website for the GDAL and OGR libraries.</li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://trac.osgeo.org/gdal/wiki/GdalOgrInPython">http://trac.osgeo.org/gdal/wiki/GdalOgrInPython</a> describes the overall design of the Python interface to GDAL and OGR.</li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://trac.osgeo.org/gdal/wiki/PythonGotchas">http://trac.osgeo.org/gdal/wiki/PythonGotchas</a> lists a number of issues to be aware of when using GDAL/OGR from Python.</li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://pypi.python.org/pypi/Shapely">http://pypi.python.org/pypi/Shapely</a> is the main website for the Shapely library.</li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://toblerity.org/shapely/manual.html">http://toblerity.org/shapely/manual.html</a> is where you can find the Shapely user manual.</li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://trac.osgeo.org/proj">https://trac.osgeo.org/proj</a> describes the Proj.4 cartographic projection library.</li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://jswhit.github.io/pyproj">http://jswhit.github.io/pyproj</a> is the main site for the Python interface to the Proj library.</li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.postgresql.org">http://www.postgresql.org</a> is the main site for the PostgreSQL database.</li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://postgis.net">http://postgis.net</a> is the site for the PostGIS extension to Postgres.</li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://mapnik.org">http://mapnik.org</a> is the main site for the Mapnik library.</li><li class="listitem" style="list-style-type: disc">Finally, <a class="ulink" href="http://github.com/mapnik/mapnik/wiki">http://github.com/mapnik/mapnik/wiki</a> provides a lot of useful information to help you work with Mapnik.</li></ul></div><p>This particular book is now finished, but I hope I have left you with a greater understanding of the tools and techniques you can use for geospatial analysis, and how Python can be used as the foundation for your own geospatial development efforts. The rest is up to you.</p></div></div>
</body></html>