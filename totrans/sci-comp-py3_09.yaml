- en: Chapter 9. Iterating
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will present iteration using loops and iterators. We will
    show examples of how this can be used with lists and generators. Iteration is
    one of the fundamental operations a computer is useful for. Traditionally, iteration
    is achieved by a `for` loop. A `for` loop is a repetition of a block of instructions
    a certain number of times. Inside the loop, one has access to a loop variable,
    in which the iteration number is stored.
  prefs: []
  type: TYPE_NORMAL
- en: The Python idiom is slightly different. A `for` loop in Python is primarily
    designed to exhaust a list, that is, to enumerate the elements of a list. The
    effect is similar to the repetition effect just described if one uses a list containing
    the first *n* integers.
  prefs: []
  type: TYPE_NORMAL
- en: A `for` loop only needs one element of the list at a time. It is therefore desirable
    to use a `for` loop with objects that are able to create those elements on demand,
    one at a time. This is what iterators achieve in Python.
  prefs: []
  type: TYPE_NORMAL
- en: The for statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The primary aim of the `for` statement is to traverse a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the loop variable *s* is successively assigned to one element
    of the list. Notice that the loop variable is available after the loop has terminated.
    This may sometimes be useful; refer, for instance, the example in section *Controlling
    the flow inside the loop*.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most frequent uses of a `for` loop is to repeat a given task a defined
    number of times, using the function `range`  (refer to section *Lists* of [Chapter
    1](ch01.html "Chapter 1. Getting Started"), *Getting Started*).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If the purpose of a loop is to go through a list, many languages (including
    Python) offer the following pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If the purpose of that code were to go through the list `my_list`, the preceding
    code would not make it very clear. For this reason, a better way to express this
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It is now clear at first glance that the preceding piece of code goes through
    the `my_list` list. Note that if you really need the index variable *k*, you may
    replace the preceding code by this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The intent of this piece of code is to go through `my_list` while keeping the
    index variable *k* available. A similar construction for arrays is the command
    `ndenumerate`.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the flow inside the loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes it is necessary to jump out of the loop, or to go directly to the
    next loop iteration. These two operations are performed by the `break` and `continue` commands.
     The `break` keyword, as the name indicates, breaks the loop. Two situations can
    occur where the loop breaks:'
  prefs: []
  type: TYPE_NORMAL
- en: The loop is completely executed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The loop is left before it was completely executed (`break`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the first case, special actions can be defined in an `else` block, which
    is executed if the whole list is traversed. This is useful in general if the purpose
    of the `for` loop is to find something and stop. Examples might be searching for
    one element satisfying a certain property inside a list. If such an element is not
    found, the `else` block is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a common usage in scientific computing. Quite often, we use an iterating
    algorithm that is not guaranteed to succeed. In that case, it is preferable to
    use a (big) finite loop so that the program does not get caught in an infinite
    loop. The `for`/`else` construct allows such an implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `for` loop is primarily used to traverse a list, but it picks the elements
    of the list one at a time. In particular, there is no need to store the whole
    list in memory for the loop to work properly. The mechanism that allows `for`
    loops to work without lists is that of iterators.
  prefs: []
  type: TYPE_NORMAL
- en: 'An iterable object produces objects (to be passed to a `for` loop). Such an
    object, `obj`, may be used inside a `for` loop, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The notion of iterator thus generalizes the idea of lists. The simplest example
    of an iterable object is given by lists. The produced objects are simply the objects
    stored in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: An iterable object need not produce existing objects. The objects may, instead,
    be produced on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical iterable is the object returned by the function `range`. This function
    works as if it would generate a list of integers, but instead, the successive
    integers are produced on the fly when they are needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If one really needs a list with all integers between 0 and 100,000,000, then
    it has to be formed explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Generators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can create your own iterators using the `yield` keyword. For example, a
    generator for odd numbers smaller than  *n* can be defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you can use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Or even like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Iterators are disposable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One salient feature of iterators is that they may be used only once. In order
    to use the iterator again, you will have to create a new iterator object. Note
    that an iterable object is able to create new iterators as many times as necessary.
    Let us examine the case of a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Each time a generator object is called, it creates a new iterator. Hence, when
    that iterator is exhausted, one has to call the generator again to obtain a new
    iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Iterator tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are a couple of iterator tools that often come in very handy:'
  prefs: []
  type: TYPE_NORMAL
- en: '`enumerate` is used to enumerate another iterator. It produces a new iterator
    that yields pairs (iteration, element), where `iteration` stores the index of
    the iteration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`reversed` creates an iterator from a list by going through that list backwards.
    Notice that this is different from creating a reversed list:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`itertools.count` is a possibly infinite iterator of integers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`intertools.islice` truncates an iterator using the familiar `slicing` syntax;
    refer to [Chapter 3](ch03.html "Chapter 3. Container Types"), *Container Types*.
    One application is creating a finite iterator from an infinite one:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, let''s find some odd numbers by combining `islice` with an infinite
    generator. First, we modify the generator for odd numbers so that it becomes an
    infinite generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we use it with `islice` to get a list of some odd numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Generators of recursive sequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Assume that a sequence is given by an induction formula. For instance, consider
    the Fibonacci sequence, defined by the recurrence formula: *u[n] = u[n]*[-1] +
    *u*[*n*-2].'
  prefs: []
  type: TYPE_NORMAL
- en: 'This sequence depends on two initial values, namely *u*[0] and *u*[1], although
    for the standard Fibonacci sequence those numbers are taken as 0 and 1 respectively.
    A nifty way of programming the generation of such a sequence is by using generators,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This may then be used, for instance, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Arithmetic geometric mean
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The iteration based on iteratively computing arithmetic and geometric means
    is called **AGM iteration** (refer to [[1, p. 598]](apa.html "Appendix . References")
    for more information):'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Arithmetic geometric mean](img/B05511_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It has the fascinating property that for  ![ Arithmetic geometric mean](img/B05511_09_02.jpg)
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Arithmetic geometric mean](img/B05511_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The integral on the right-hand side is called a complete elliptic integral
    of the first kind. We now proceed to compute this elliptic integral. We use a
    generator to describe the iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As the sequence {*a[i]*} is convergent, the sequence {*c*[*i*]}  defined by
    {*c[i]*} = (*a[i]–b[i]*)/2, converges to zero – a fact that will be used to terminate
    the iteration in the program to compute the elliptic integral:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to make sure that the algorithm stops. Note that this code fully relies
    on the mathematical statement that the arithmetic geometric mean iteration converges
    (fast). In practical computing, we have to be careful while applying theoretical
    results, as they might no longer be valid in limited-precision arithmetic. The
    right way to make the preceding code safe is to use `itertools.islice`. The safe
    code is as follows (see the example under the section *Controlling the flow inside
    the loop* for another typical usage of the `for`/`else` statement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As an application, elliptic integrals may be used to compute the period of
    a **pendulum** of length *L* starting at an angle θ (refer to [[18, p.114]](apa.html
    "Appendix . References") for more information) using:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Arithmetic geometric mean](img/B05511_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Using this formula, the period of the pendulum is easily obtained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Convergence acceleration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We give an example of application of generators for convergence acceleration.
    This presentation follows closely the example given by *Pramode C.E* in *Python
    Generator Tricks* (refer [[9]](apa.html "Appendix . References") for more information).
  prefs: []
  type: TYPE_NORMAL
- en: Note that a generator may take an other generator as an input parameter. For
    instance, suppose that we have defined a generator that generates the elements
    of a converging sequence. It is then possible to improve the convergence by an
    acceleration technique due to *Euler* and *Aitken*, often called Aitken’s Δ²-method
    (Refer [[33]](apa.html "Appendix . References")*).* It transforms a sequence *s[i]*
    into another by defining
  prefs: []
  type: TYPE_NORMAL
- en: '![Convergence acceleration](img/B05511_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Both sequences have the same limit, but the sequence ![Convergence acceleration](img/B05511_09_19.jpg) 
    converges significantly faster. One possible implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As an example, we use the classical series:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Convergence acceleration](img/B05511_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It converges towards π/4*.* We implement this series as a generator in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We may now use the accelerated version of that sequence using this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Accordingly, the first *N* elements of that accelerated sequence are obtained
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance, the following figure (*Figure 9.1*) shows the convergence rate
    of the log of the error for the standard version of the sequence defined by the
    above formula and its accelerated version:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Convergence acceleration](img/seqacceleration-e1481709869771.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: Comparison between the sequence defined and its accelerated version'
  prefs: []
  type: TYPE_NORMAL
- en: List filling patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section we will compare different ways to fill lists. They are different
    in computational  efficiency and also in code readability.
  prefs: []
  type: TYPE_NORMAL
- en: List filling with the append method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A ubiquitous programming pattern is to compute elements and store them in a
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach has a number of disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: The number of iterations is decided in advance. If there is a `break` instruction,
    then the preceding code takes care of both generating values and deciding when
    to stop. This is not desirable and lacks flexibility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes the assumption that the user wants the whole history of the computation,
    for all the iterations. Suppose we are only interested in the sum of all the computed
    values. If there are many computed values, it does not make sense to store them,
    as it is much more efficient to add them one at a time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List from iterators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Iterators provide us with an elegant solution to problems discussed previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'With iterators, we separate the task of generating the computed values without
    bothering about the stopping condition or about the storage. If the user of that
    code wants to store the *n* first values, it is easily done using the `list` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If the user wants the sum of the first *n* generated values, this construction
    is recommended:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: What we did here was separating the generation of elements on one hand, and
    storing those elements on the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the purpose is really to build a list, and when the result at each step
    does not depend on previously computed elements, one may use the list comprehension
    syntax (refer to section *List* of [Chapter 3](ch03.html "Chapter 3. Container
    Types"), *Container Types*, for more information):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: When iteratively computing values that depend on the previously computed values,
    list comprehensions cannot help.
  prefs: []
  type: TYPE_NORMAL
- en: Storing generated values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using iterators to fill out lists will work nicely most of the time, but there
    are complications to this pattern when the algorithm computing the new values
    is liable to throw an exception; if the iterator raises an exception along the
    way, the list will not be available! The following example illustrates this problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we generate the sequence defined recursively by ![Storing generated
    values](img/B05511_09_07.jpg) . This sequence quickly diverges to infinity if
    the initial data *u*[0] is greater than one. Let us generate it with a generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: If you try to obtain the first *20* elements of the sequence (initialized by
    *u[0] = 2*) by executing,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'an exception will be raised and no list will be available, not even the list
    of elements before the exception was raised. There is currently no way to obtain
    a partially filled list from a possibly faulty generator. The only way around
    is to use the append method wrapped in an exception-catching block (refer to section
    *Exceptions* in [Chapter 10](ch10.html "Chapter 10. Error Handling"), *Error Handling*, for
    more details):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: When iterators behave as lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some list operations also work on iterators. We will now examine the equivalents
    of *list comprehensions* and *list zipping* (refer to section *List* of [Chapter
    3](ch03.html "Chapter 3. Container Types"), *Container Types*, for more details).
  prefs: []
  type: TYPE_NORMAL
- en: Generator expression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is an equivalent of list comprehension for generators. Such a construction
    is called a generator expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This is useful in particular for computing sums or products because those operations
    are incremental; they only need one element at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In that code, you notice that the `sum` function is given one argument, which
    is a generator expression. Note that Python syntax allows us to omit the enclosing
    parentheses of generators when a generator is used as the *only* argument of a
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Let us compute the Riemann zeta function *ζ*, whose expression is
  prefs: []
  type: TYPE_NORMAL
- en: '![Generator expression](img/B05511_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With a generator expression, we may compute a partial sum of this series in
    one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we could also have defined a generator of the sequence 1 ⁄ *n^s*as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we simply obtain the sum of the first *N* terms using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We point out that we used this way of computing the zeta (ζ) function as a demonstration
    of the use of generators in an elegant way. It is certainly not the most accurate
    and computationally efficient way to evaluate this function.
  prefs: []
  type: TYPE_NORMAL
- en: Zipping iterators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We saw in section *List*, [Chapter 3](ch03.html "Chapter 3. Container Types"),
    *Container Types*, that it is possible to create a list out of two by zipping
    them together. The same operation exists for iterators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The zipped iterator stops as soon as one of the iterators is exhausted. This
    is the same behavior as for a zip operation on lists.
  prefs: []
  type: TYPE_NORMAL
- en: Iterator objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, a `for` loop only needs an iterable object. Lists,
    in particular, are iterable. This means that a list is able to create an iterator
    from its contents. In fact, this is true for any object (not only lists): any
    object may be made iterable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is achieved via the `__iter__` method, which should return an iterator.
    Here we give an example where the `__iter__` method is a generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to use the features of an iterator with an object that is not iterable,
    an exception will be raised:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the list function tries to iterate through the object *3*
    by calling the `__iter__` method. But this method is not implemented for integers
    and thus the exception is raised. The same would happen if we tried to cycle through
    a non-iterable object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Infinite iterations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Infinite iterations are obtained either with an infinite iterator, with a `while`
    loop, or by recursion. Obviously, in practical cases, some condition stops the
    iteration. The difference with finite iterations is that it is impossible to say
    by a cursory examination of the code, whether the iteration will stop or not.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `while` loop may be used to repeat a code block until a condition is fulfilled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'A `while` loop is equivalent to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'So a `while` loop is equivalent to an infinite iterator, which might be stopped
    if a condition is fulfilled. The danger of such a construction is obvious: the
    code may be trapped in an infinite loop if the condition is never fulfilled.'
  prefs: []
  type: TYPE_NORMAL
- en: The problem in scientific computing is that one is not always sure that an algorithm
    will converge. Newton iteration, for instance, might not converge at all. If that
    algorithm were implemented inside a `while` loop, the corresponding code would
    be trapped in an infinite loop for some choices of initial conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We therefore give an advice that finite iterators are often better suited for
    such a task. The following construction replaces, often advantageously, the use
    of a `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The first advantage is that the code is guaranteed to execute in a finite time
    no matter what happens. The second advantage is that the variable `nb_iterations`
    contains the number of iterations that was necessary for the algorithm to converge.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A recursion occurs when a function calls itself (refer to section *Recursive
    Function* in [Chapter 7](ch07.html "Chapter 7. Functions"), *Functions*).
  prefs: []
  type: TYPE_NORMAL
- en: 'When doing recursions, it is the recursion depth, that is the number of iterations,
    which brings your computer to its limits. We demonstrate this here by considering
    a simple recursion, which actually contains no computations at all. It assigns
    to the iterates only the value zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Depending on your system, this program may choke for *N ≥ 10000* (too much
    memory is used). The result is that the Python interpreter crashes without further
    exception. Python provides a mechanism to raise an exception when a too high recursion
    depth is detected. This maximum recursion depth may be changed by executing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The actual value of the recursion limit can be obtained by `sys.getrecursionlimit()`.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware though, that choosing too high a number may imperil the stability of
    your code, since Python might crash before that maximum depth is reached. It is
    therefore often wise to leave the recursion limit as it is.
  prefs: []
  type: TYPE_NORMAL
- en: 'By comparison, the following, non recursive, program runs ten of millions of
    iterations without any problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We advocate that, if possible, recursion should be avoided in Python. This applies
    obviously only if there is an appropriate alternative iterative algorithm available.
    The first reason is that a recursion of depth *N* involves *N* function calls
    at the same time, which might result in a significant overhead. The second reason
    is that it is an infinite iteration, that is, it is difficult to give an upper
    bound to the number of steps necessary before the recursion is over.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in some very special cases (tree traversal) recursion is unavoidable.
    Besides, in some cases (with small recursion depths) recursive programs might
    be preferred due to readability.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we studied iterators,  a programming construct very near to
    a mathematical description of iterative methods. You saw the `yield` keyword and
    met finite and infinite iterators.
  prefs: []
  type: TYPE_NORMAL
- en: We showed that an iterator can be exhausted. More special aspects such as iterator
    comprehension and recursive iterators were introduced and demonstrated with the
    help of examples.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Ex. 1** → Compute the value of the sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercises](img/B05511_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Ex. 2** → Create a generator that computes the sequence defined by the relation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercises](img/un2nm1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Ex. 3** → Generate all the even numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 4** → Let ![Exercises](img/B05511_09_10.jpg). In calculus, it is shown
    that ![Exercises](img/limsn.jpg). Determine experimentally the smallest number
    *n* such that ![Exercises](img/tempowminus5.jpg). Use a generator for this task.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 5** → Generate all prime numbers less than a given integer. Use the algorithm
    called Sieve of Eratosthenes.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 6** → Solving the differential equation ![Exercises](img/odesin.jpg)
    by applying the explicit Euler method results in the recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercises](img/euler1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Write a generator that computes the solution values *u[n]* for a given initial
    value *u*[0] and for a given value of the time step *h*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 7** → Compute π using the formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercises](img/B05511_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The integral can be approximated using the composite trapezoidal rule, that
    is, by this formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercises](img/B05511_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where ![Exercises](img/grid_value.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: Program a *generator* for the values *y[i] = f(x[i])* and evaluate the formula
    by summing one term after the other. Compare your results with the `quad` function
    of SciPy.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 8** → Let *x* = [1, 2, 3] and *y* = [-1, -2, -3]. What is the effect
    of the code `zip(*zip(x, y))`? Explain how it works.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 9** → Complete elliptic integrals can be computed by the function `scipy.special.ellipk`.
    Write a function, which counts the number of iterations needed with the  AGM iteration
    until the result coincides up to a given tolerance (note that the input parameter
    *m* in `ellipk` corresponds to *k²* in the definition in the section *Arithmetic
    geometric mean)* .'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 10** → Consider the sequence defined by:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercises](img/En.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It converges monotonically to zero: *E[1] >E[2] > . . . > 0*. By integration
    by parts, one can show that the sequence *E[n]* fulfills the following recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercises](img/E_recurse.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Compute the first 20 terms of the recursion by using an appropriate generator
    and compare the results with those obtained by numerical integration with `scipy.integrate.quad`.
    Do the same by reversing the recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercises](img/B05511_09_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Use the `exp` function to evaluate the exponential function. What do you observe?
    Do you have an explanation? (refer to [[29]](apa.html "Appendix . References")*)*
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercises](img/Euler-e1481710075110.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: A convergence study of functions approximating to sin(x)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 11** → The  sine-function can be expressed due to Euler as'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercises](img/B05511_09_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Write a generator that generates the function values *P[k](x)*. Set `x=linspace(-1,3.5*pi,200)`
    and demonstrate graphically how good *P[k](x)* approximates sin for increasing
    *k*. In previous figure (*Figure 9.2*), the possible result is shown (refer to
    [[11, Th. 5.2, p. 65]](apa.html "Appendix . References")).
  prefs: []
  type: TYPE_NORMAL
