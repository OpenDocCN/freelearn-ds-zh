- en: Chapter 9. Iterating
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章。迭代
- en: In this chapter, we will present iteration using loops and iterators. We will
    show examples of how this can be used with lists and generators. Iteration is
    one of the fundamental operations a computer is useful for. Traditionally, iteration
    is achieved by a `for` loop. A `for` loop is a repetition of a block of instructions
    a certain number of times. Inside the loop, one has access to a loop variable,
    in which the iteration number is stored.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过循环和迭代器展示迭代。我们将展示如何使用列表和生成器来实现这一点。迭代是计算机有用的基本操作之一。传统上，迭代是通过 `for` 循环实现的。`for`
    循环是一系列指令的重复执行，执行次数是确定的。在循环内部，可以访问一个循环变量，其中存储了迭代次数。
- en: The Python idiom is slightly different. A `for` loop in Python is primarily
    designed to exhaust a list, that is, to enumerate the elements of a list. The
    effect is similar to the repetition effect just described if one uses a list containing
    the first *n* integers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的习惯用法略有不同。Python 中的 `for` 循环主要是设计用来耗尽列表，即枚举列表的元素。如果使用包含前 *n* 个整数的列表，效果与前面描述的重复效果相似。
- en: A `for` loop only needs one element of the list at a time. It is therefore desirable
    to use a `for` loop with objects that are able to create those elements on demand,
    one at a time. This is what iterators achieve in Python.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环一次只需要列表中的一个元素。因此，最好使用能够按需逐个创建这些元素的 `for` 循环，这正是 Python 中的迭代器所实现的。'
- en: The for statement
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: for 语句
- en: 'The primary aim of the `for` statement is to traverse a list:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 语句的主要目的是遍历列表：'
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, the loop variable *s* is successively assigned to one element
    of the list. Notice that the loop variable is available after the loop has terminated.
    This may sometimes be useful; refer, for instance, the example in section *Controlling
    the flow inside the loop*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，循环变量 *s* 依次赋值给列表中的一个元素。请注意，循环变量在循环结束后仍然可用。这有时可能很有用；例如，可以参考 *控制循环内部的流程*
    这一部分的例子。
- en: One of the most frequent uses of a `for` loop is to repeat a given task a defined
    number of times, using the function `range`  (refer to section *Lists* of [Chapter
    1](ch01.html "Chapter 1. Getting Started"), *Getting Started*).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环最频繁的用途之一是重复执行定义次数的任务，使用 `range` 函数（请参阅 [第 1 章](ch01.html "第 1 章。入门")
    的 *列表* 部分，*入门*）。'
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If the purpose of a loop is to go through a list, many languages (including
    Python) offer the following pattern:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果循环的目的是遍历列表，许多语言（包括 Python）都提供了以下模式：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If the purpose of that code were to go through the list `my_list`, the preceding
    code would not make it very clear. For this reason, a better way to express this
    is as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该代码的目的是遍历 `my_list` 列表，前面的代码可能不太清楚。因此，更好的表达方式如下：
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It is now clear at first glance that the preceding piece of code goes through
    the `my_list` list. Note that if you really need the index variable *k*, you may
    replace the preceding code by this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在很明显，前面的代码遍历了 `my_list` 列表。请注意，如果您确实需要索引变量 *k*，您可以将前面的代码替换为以下代码：
- en: '[PRE4]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The intent of this piece of code is to go through `my_list` while keeping the
    index variable *k* available. A similar construction for arrays is the command
    `ndenumerate`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的意图是在遍历 `my_list` 的同时保持索引变量 *k* 可用。对于数组，类似的构造是命令 `ndenumerate`。
- en: Controlling the flow inside the loop
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制循环内部的流程
- en: 'Sometimes it is necessary to jump out of the loop, or to go directly to the
    next loop iteration. These two operations are performed by the `break` and `continue` commands.
     The `break` keyword, as the name indicates, breaks the loop. Two situations can
    occur where the loop breaks:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有时需要跳出循环或直接跳到下一次循环迭代。这两个操作由 `break` 和 `continue` 命令执行。正如其名所示，`break` 关键字会中断循环。循环中断可能发生两种情况：
- en: The loop is completely executed.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环已完全执行。
- en: The loop is left before it was completely executed (`break`).
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环在完全执行之前被跳出（`break`）。
- en: For the first case, special actions can be defined in an `else` block, which
    is executed if the whole list is traversed. This is useful in general if the purpose
    of the `for` loop is to find something and stop. Examples might be searching for
    one element satisfying a certain property inside a list. If such an element is not
    found, the `else` block is executed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一种情况，可以在 `else` 块中定义特殊操作，该块在遍历整个列表时执行。如果 `for` 循环的目的是查找某个东西并停止，这通常很有用。例如，可以在列表中搜索满足特定属性的元素。如果找不到这样的元素，则执行
    `else` 块。
- en: 'Here is a common usage in scientific computing. Quite often, we use an iterating
    algorithm that is not guaranteed to succeed. In that case, it is preferable to
    use a (big) finite loop so that the program does not get caught in an infinite
    loop. The `for`/`else` construct allows such an implementation:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在科学计算中的一种常见用法。通常，我们使用一个不一定成功的迭代算法。在这种情况下，最好使用（大）有限循环，这样程序就不会陷入无限循环。`for`/`else`
    构造允许这种实现：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Iterators
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器
- en: A `for` loop is primarily used to traverse a list, but it picks the elements
    of the list one at a time. In particular, there is no need to store the whole
    list in memory for the loop to work properly. The mechanism that allows `for`
    loops to work without lists is that of iterators.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环主要用于遍历列表，但它一次只选择列表中的一个元素。特别是，不需要将整个列表存储在内存中，循环才能正常工作。允许 `for` 循环在没有列表的情况下工作的机制是迭代器。'
- en: 'An iterable object produces objects (to be passed to a `for` loop). Such an
    object, `obj`, may be used inside a `for` loop, as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 可迭代对象产生对象（传递给 `for` 循环）。这样的对象 `obj` 可以在 `for` 循环中使用，如下所示：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The notion of iterator thus generalizes the idea of lists. The simplest example
    of an iterable object is given by lists. The produced objects are simply the objects
    stored in the list:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，迭代器的概念扩展了列表的想法。最简单的可迭代对象示例是列表。产生的对象只是列表中存储的对象：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: An iterable object need not produce existing objects. The objects may, instead,
    be produced on the fly.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 可迭代对象不需要产生现有的对象。对象可以即时产生。
- en: 'A typical iterable is the object returned by the function `range`. This function
    works as if it would generate a list of integers, but instead, the successive
    integers are produced on the fly when they are needed:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的可迭代对象是由函数 `range` 返回的对象。这个函数的工作方式就像它会生成一个整数列表一样，但事实上，当需要时，连续的整数会即时生成：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If one really needs a list with all integers between 0 and 100,000,000, then
    it has to be formed explicitly:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果真的需要一个包含0到100,000,000之间所有整数的列表，那么必须显式地形成它：
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Generators
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器
- en: 'You can create your own iterators using the `yield` keyword. For example, a
    generator for odd numbers smaller than  *n* can be defined:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `yield` 关键字创建自己的迭代器。例如，可以定义一个小于 *n* 的奇数生成器：
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then you can use it as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以这样使用它：
- en: '[PRE11]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Or even like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 或者甚至可以这样：
- en: '[PRE12]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Iterators are disposable
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器是可丢弃的
- en: 'One salient feature of iterators is that they may be used only once. In order
    to use the iterator again, you will have to create a new iterator object. Note
    that an iterable object is able to create new iterators as many times as necessary.
    Let us examine the case of a list:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器的一个显著特点是它们只能使用一次。为了再次使用迭代器，你必须创建一个新的迭代器对象。请注意，可迭代对象能够根据需要创建任意数量的新迭代器。让我们来考察一下列表的情况：
- en: '[PRE13]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Each time a generator object is called, it creates a new iterator. Hence, when
    that iterator is exhausted, one has to call the generator again to obtain a new
    iterator:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用生成器对象时，它都会创建一个新的迭代器。因此，当该迭代器耗尽时，必须再次调用生成器以获取新的迭代器：
- en: '[PRE14]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Iterator tools
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器工具
- en: 'Here are a couple of iterator tools that often come in very handy:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些经常非常有用的迭代器工具：
- en: '`enumerate` is used to enumerate another iterator. It produces a new iterator
    that yields pairs (iteration, element), where `iteration` stores the index of
    the iteration:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enumerate` 用于对另一个迭代器进行编号。它产生一个新的迭代器，产生一对（迭代，元素），其中 `iteration` 存储迭代的索引：'
- en: '[PRE15]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`reversed` creates an iterator from a list by going through that list backwards.
    Notice that this is different from creating a reversed list:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reversed` 通过遍历列表的逆序来从一个列表创建一个迭代器。请注意，这与创建逆序列表是不同的：'
- en: '[PRE16]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`itertools.count` is a possibly infinite iterator of integers:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`itertools.count` 是一个可能无限的整数迭代器：'
- en: '[PRE17]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`intertools.islice` truncates an iterator using the familiar `slicing` syntax;
    refer to [Chapter 3](ch03.html "Chapter 3. Container Types"), *Container Types*.
    One application is creating a finite iterator from an infinite one:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`intertools.islice` 使用熟悉的 `切片` 语法截断迭代器；请参阅[第3章](ch03.html "第3章。容器类型")，*容器类型*。一个应用是从无限迭代器创建有限迭代器：'
- en: '[PRE18]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For example, let''s find some odd numbers by combining `islice` with an infinite
    generator. First, we modify the generator for odd numbers so that it becomes an
    infinite generator:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们通过结合 `islice` 和无限生成器来找到一些奇数。首先，我们修改奇数生成器，使其成为一个无限生成器：
- en: '[PRE19]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we use it with `islice` to get a list of some odd numbers:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `islice` 来获取一些奇数的列表：
- en: '[PRE20]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Generators of recursive sequences
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归序列生成器
- en: 'Assume that a sequence is given by an induction formula. For instance, consider
    the Fibonacci sequence, defined by the recurrence formula: *u[n] = u[n]*[-1] +
    *u*[*n*-2].'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个序列由归纳公式给出。例如，考虑斐波那契序列，由递归公式定义：*u[n] = u[n]*[-1] + *u*[*n*-2]。
- en: 'This sequence depends on two initial values, namely *u*[0] and *u*[1], although
    for the standard Fibonacci sequence those numbers are taken as 0 and 1 respectively.
    A nifty way of programming the generation of such a sequence is by using generators,
    as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个序列依赖于两个初始值，即 *u*[0] 和 *u*[1]，尽管对于标准的斐波那契序列，这些数字分别取为 0 和 1。通过使用生成器编程生成此类序列是一种巧妙的方法，如下所示：
- en: '[PRE21]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This may then be used, for instance, like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能被用于，例如，如下所示：
- en: '[PRE22]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Arithmetic geometric mean
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 算术几何平均
- en: 'The iteration based on iteratively computing arithmetic and geometric means
    is called **AGM iteration** (refer to [[1, p. 598]](apa.html "Appendix . References")
    for more information):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 基于迭代计算算术和几何平均的迭代称为 **AGM 迭代**（更多信息请参考 [[1, p. 598]](apa.html "附录 . 参考文献")）：
- en: '![ Arithmetic geometric mean](img/B05511_09_01.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![算术几何平均](img/B05511_09_01.jpg)'
- en: 'It has the fascinating property that for  ![ Arithmetic geometric mean](img/B05511_09_02.jpg)
    :'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '它有一个迷人的性质，即对于 ![算术几何平均](img/B05511_09_02.jpg) :'
- en: '![ Arithmetic geometric mean](img/B05511_09_03.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![算术几何平均](img/B05511_09_03.jpg)'
- en: 'The integral on the right-hand side is called a complete elliptic integral
    of the first kind. We now proceed to compute this elliptic integral. We use a
    generator to describe the iteration:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧的积分称为第一类完全椭圆积分。我们现在继续计算这个椭圆积分。我们使用生成器来描述迭代：
- en: '[PRE23]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As the sequence {*a[i]*} is convergent, the sequence {*c*[*i*]}  defined by
    {*c[i]*} = (*a[i]–b[i]*)/2, converges to zero – a fact that will be used to terminate
    the iteration in the program to compute the elliptic integral:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于序列 `{*a[i]*}` 是收敛的，由 `{*c[i]*}` = (*a[i]–b[i]*)/2 定义的序列 `{*c*[*i*]}` 收敛到零——这是一个将在计算椭圆积分的程序中终止迭代的性质：
- en: '[PRE24]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We have to make sure that the algorithm stops. Note that this code fully relies
    on the mathematical statement that the arithmetic geometric mean iteration converges
    (fast). In practical computing, we have to be careful while applying theoretical
    results, as they might no longer be valid in limited-precision arithmetic. The
    right way to make the preceding code safe is to use `itertools.islice`. The safe
    code is as follows (see the example under the section *Controlling the flow inside
    the loop* for another typical usage of the `for`/`else` statement):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保算法停止。请注意，此代码完全依赖于数学陈述，即算术几何平均迭代收敛（快速）。在实际计算中，我们必须在应用理论结果时小心，因为它们在有限精度算术中可能不再有效。使前面的代码安全的方法是使用
    `itertools.islice`。安全的代码如下（有关 `for`/`else` 语句的另一种典型用法，请参阅 *控制循环内部的流程* 部分的示例）：
- en: '[PRE25]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As an application, elliptic integrals may be used to compute the period of
    a **pendulum** of length *L* starting at an angle θ (refer to [[18, p.114]](apa.html
    "Appendix . References") for more information) using:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 作为应用，椭圆积分可以用来计算长度为 *L* 的摆的周期，起始角度为 θ（更多信息请参考 [[18, p.114]](apa.html "附录 . 参考文献")）使用：
- en: '![ Arithmetic geometric mean](img/B05511_09_04.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![算术几何平均](img/B05511_09_04.jpg)'
- en: 'Using this formula, the period of the pendulum is easily obtained:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个公式，很容易得到摆的周期：
- en: '[PRE26]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Convergence acceleration
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收敛加速
- en: We give an example of application of generators for convergence acceleration.
    This presentation follows closely the example given by *Pramode C.E* in *Python
    Generator Tricks* (refer [[9]](apa.html "Appendix . References") for more information).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给出一个使用生成器进行收敛加速的应用示例。这个演示紧密遵循 *Pramode C.E* 在 *Python Generator Tricks* 中给出的示例（更多信息请参考
    [[9]](apa.html "附录 . 参考文献")）。
- en: Note that a generator may take an other generator as an input parameter. For
    instance, suppose that we have defined a generator that generates the elements
    of a converging sequence. It is then possible to improve the convergence by an
    acceleration technique due to *Euler* and *Aitken*, often called Aitken’s Δ²-method
    (Refer [[33]](apa.html "Appendix . References")*).* It transforms a sequence *s[i]*
    into another by defining
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，生成器可以接受另一个生成器作为输入参数。例如，假设我们定义了一个生成器，用于生成收敛序列的元素。然后，可以通过 *Euler* 和 *Aitken*
    的加速技术（通常称为 Aitken 的 Δ² 方法）来提高收敛速度（更多信息请参考 [[33]](apa.html "附录 . 参考文献")）。它通过定义将序列
    *s[i]* 转换为另一个序列：
- en: '![Convergence acceleration](img/B05511_09_05.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![收敛加速](img/B05511_09_05.jpg)'
- en: 'Both sequences have the same limit, but the sequence ![Convergence acceleration](img/B05511_09_19.jpg) 
    converges significantly faster. One possible implementation is as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个序列都有相同的极限，但![收敛加速](img/B05511_09_19.jpg)序列收敛得显著更快。一个可能的实现如下：
- en: '[PRE27]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As an example, we use the classical series:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们使用经典的级数：
- en: '![Convergence acceleration](img/B05511_09_06.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![收敛加速](img/B05511_09_06.jpg)'
- en: 'It converges towards π/4*.* We implement this series as a generator in the
    following code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 它收敛于π/4*.* 我们在以下代码中将这个级数实现为一个生成器：
- en: '[PRE28]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We may now use the accelerated version of that sequence using this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用这个序列的加速版本：
- en: '[PRE29]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Accordingly, the first *N* elements of that accelerated sequence are obtained
    with:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用以下方法可以获得该加速序列的前*N*个元素：
- en: '[PRE30]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For instance, the following figure (*Figure 9.1*) shows the convergence rate
    of the log of the error for the standard version of the sequence defined by the
    above formula and its accelerated version:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下图（*图9.1*）显示了由上述公式定义的序列的标准版本及其加速版本的误差对数的收敛率：
- en: '![Convergence acceleration](img/seqacceleration-e1481709869771.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![收敛加速](img/seqacceleration-e1481709869771.jpg)'
- en: 'Figure 9.1: Comparison between the sequence defined and its accelerated version'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：定义的序列及其加速版本的比较
- en: List filling patterns
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表填充模式
- en: In this section we will compare different ways to fill lists. They are different
    in computational  efficiency and also in code readability.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将比较不同的填充列表的方法。它们在计算效率上不同，在代码可读性上也有所不同。
- en: List filling with the append method
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用append方法填充列表
- en: 'A ubiquitous programming pattern is to compute elements and store them in a
    list:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一种普遍的编程模式是计算元素并将它们存储在一个列表中：
- en: '[PRE31]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This approach has a number of disadvantages:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有几个缺点：
- en: The number of iterations is decided in advance. If there is a `break` instruction,
    then the preceding code takes care of both generating values and deciding when
    to stop. This is not desirable and lacks flexibility.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代次数是预先决定的。如果有`break`指令，则前面的代码负责生成值和决定何时停止。这并不理想，缺乏灵活性。
- en: It makes the assumption that the user wants the whole history of the computation,
    for all the iterations. Suppose we are only interested in the sum of all the computed
    values. If there are many computed values, it does not make sense to store them,
    as it is much more efficient to add them one at a time.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它假设用户想要整个计算的历史记录，对于所有迭代。假设我们只对所有计算值的总和感兴趣。如果有许多计算值，存储它们是没有意义的，因为逐个相加要高效得多。
- en: List from iterators
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从迭代器生成列表
- en: 'Iterators provide us with an elegant solution to problems discussed previously:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器为我们提供了一个优雅的解决方案来解决之前讨论过的问题：
- en: '[PRE32]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'With iterators, we separate the task of generating the computed values without
    bothering about the stopping condition or about the storage. If the user of that
    code wants to store the *n* first values, it is easily done using the `list` constructor:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用迭代器，我们分离了生成计算值的任务，而不必担心停止条件或存储。如果该代码的用户想要存储前*n*个值，这很容易通过使用`list`构造函数来完成：
- en: '[PRE33]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If the user wants the sum of the first *n* generated values, this construction
    is recommended:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户想要前*n*个生成值的总和，建议使用以下构造：
- en: '[PRE34]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: What we did here was separating the generation of elements on one hand, and
    storing those elements on the other.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是一方面分离元素的生成，另一方面存储这些元素。
- en: 'If the purpose is really to build a list, and when the result at each step
    does not depend on previously computed elements, one may use the list comprehension
    syntax (refer to section *List* of [Chapter 3](ch03.html "Chapter 3. Container
    Types"), *Container Types*, for more information):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目的是真正构建一个列表，并且每个步骤的结果不依赖于先前计算过的元素，则可以使用列表推导语法（有关更多信息，请参阅[第3章](ch03.html "第3章。容器类型")的*列表*部分，*容器类型*）：
- en: '[PRE35]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When iteratively computing values that depend on the previously computed values,
    list comprehensions cannot help.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当迭代计算依赖于先前计算值的值时，列表推导无法提供帮助。
- en: Storing generated values
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储生成的值
- en: Using iterators to fill out lists will work nicely most of the time, but there
    are complications to this pattern when the algorithm computing the new values
    is liable to throw an exception; if the iterator raises an exception along the
    way, the list will not be available! The following example illustrates this problem.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用迭代器填充列表在大多数情况下都会很顺利，但当计算新值的算法可能抛出异常时，这种模式会有一些复杂性；如果迭代器在过程中抛出异常，列表将不可用！以下示例说明了这个问题。
- en: 'Suppose we generate the sequence defined recursively by ![Storing generated
    values](img/B05511_09_07.jpg) . This sequence quickly diverges to infinity if
    the initial data *u*[0] is greater than one. Let us generate it with a generator:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们生成一个递归定义的序列，其定义为![存储生成的值](img/B05511_09_07.jpg)。如果初始数据*u*[0]大于一，这个序列会迅速发散到无穷大。让我们用生成器生成它：
- en: '[PRE36]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If you try to obtain the first *20* elements of the sequence (initialized by
    *u[0] = 2*) by executing,
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试通过执行来获取序列（由*u[0] = 2*初始化）的前*20*个元素，
- en: '[PRE37]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'an exception will be raised and no list will be available, not even the list
    of elements before the exception was raised. There is currently no way to obtain
    a partially filled list from a possibly faulty generator. The only way around
    is to use the append method wrapped in an exception-catching block (refer to section
    *Exceptions* in [Chapter 10](ch10.html "Chapter 10. Error Handling"), *Error Handling*, for
    more details):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在执行过程中抛出异常，将会引发异常，并且将无法访问任何列表，甚至包括异常抛出之前的元素列表。目前尚无从可能存在问题的生成器中获取部分填充列表的方法。唯一的解决方案是使用包含异常捕获块的`append`方法（有关详细信息，请参阅第10章的*异常*部分，[第10章](ch10.html
    "第10章。错误处理")，*错误处理*）：
- en: '[PRE38]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When iterators behave as lists
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当迭代器表现得像列表一样
- en: Some list operations also work on iterators. We will now examine the equivalents
    of *list comprehensions* and *list zipping* (refer to section *List* of [Chapter
    3](ch03.html "Chapter 3. Container Types"), *Container Types*, for more details).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一些列表操作也适用于迭代器。我们现在将检查*列表推导式*和*列表zip*的等价物（有关详细信息，请参阅第3章的*列表*部分，[第3章](ch03.html
    "第3章。容器类型")，*容器类型*）。
- en: Generator expression
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器表达式
- en: 'There is an equivalent of list comprehension for generators. Such a construction
    is called a generator expression:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生成器，也存在列表推导式的等价物。这种构造称为生成器表达式：
- en: '[PRE39]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This is useful in particular for computing sums or products because those operations
    are incremental; they only need one element at a time:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这特别有用，尤其是在计算和或积时，因为这些操作是增量式的；它们只需要一次一个元素：
- en: '[PRE40]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In that code, you notice that the `sum` function is given one argument, which
    is a generator expression. Note that Python syntax allows us to omit the enclosing
    parentheses of generators when a generator is used as the *only* argument of a
    function.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在那段代码中，你会注意到`sum`函数只接受一个参数，即一个生成器表达式。请注意，Python语法允许我们在将生成器用作函数的唯一参数时省略生成器的括号。
- en: Let us compute the Riemann zeta function *ζ*, whose expression is
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们计算黎曼ζeta函数，其表达式为
- en: '![Generator expression](img/B05511_09_08.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![生成器表达式](img/B05511_09_08.jpg)'
- en: 'With a generator expression, we may compute a partial sum of this series in
    one line:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用生成器表达式，我们可以一行计算这个级数的部分和：
- en: '[PRE41]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Note that we could also have defined a generator of the sequence 1 ⁄ *n^s*as
    follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们也可以按照以下方式定义一个序列1/n^s的生成器：
- en: '[PRE42]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then we simply obtain the sum of the first *N* terms using:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们只需使用以下方法来简单地获取前*N*项的和：
- en: '[PRE43]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We point out that we used this way of computing the zeta (ζ) function as a demonstration
    of the use of generators in an elegant way. It is certainly not the most accurate
    and computationally efficient way to evaluate this function.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指出，我们使用这种方式计算ζeta（ζ）函数是为了展示以优雅的方式使用生成器。这当然不是评估此函数最准确和计算效率最高的方法。
- en: Zipping iterators
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器zip
- en: 'We saw in section *List*, [Chapter 3](ch03.html "Chapter 3. Container Types"),
    *Container Types*, that it is possible to create a list out of two by zipping
    them together. The same operation exists for iterators:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第3章的*列表*部分中看到，[第3章](ch03.html "第3章。容器类型")，*容器类型*，可以创建一个列表，通过将两个列表进行zip操作。对于迭代器，也存在相同的操作：
- en: '[PRE44]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The zipped iterator stops as soon as one of the iterators is exhausted. This
    is the same behavior as for a zip operation on lists.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个迭代器耗尽时，zipped迭代器就会停止。这与列表上的zip操作行为相同。
- en: Iterator objects
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器对象
- en: 'As we mentioned earlier, a `for` loop only needs an iterable object. Lists,
    in particular, are iterable. This means that a list is able to create an iterator
    from its contents. In fact, this is true for any object (not only lists): any
    object may be made iterable.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，`for`循环只需要一个可迭代的对象。特别是列表是可迭代的。这意味着列表能够从其内容中创建一个迭代器。实际上，这是任何对象（不仅仅是列表）的普遍情况：任何对象都可以变得可迭代。
- en: 'This is achieved via the `__iter__` method, which should return an iterator.
    Here we give an example where the `__iter__` method is a generator:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过`__iter__`方法实现的，该方法应该返回一个迭代器。这里我们给出一个`__iter__`方法是一个生成器的例子：
- en: '[PRE45]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If you try to use the features of an iterator with an object that is not iterable,
    an exception will be raised:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试在一个不可迭代的对象上使用迭代器的功能，将会引发异常：
- en: '[PRE46]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In this example, the list function tries to iterate through the object *3*
    by calling the `__iter__` method. But this method is not implemented for integers
    and thus the exception is raised. The same would happen if we tried to cycle through
    a non-iterable object:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，列表函数试图通过调用`__iter__`方法来迭代对象*3*。但是，这个方法没有为整数实现，因此会引发异常。如果我们尝试遍历一个不可迭代的对象，也会发生同样的事情：
- en: '[PRE47]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Infinite iterations
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无限迭代
- en: Infinite iterations are obtained either with an infinite iterator, with a `while`
    loop, or by recursion. Obviously, in practical cases, some condition stops the
    iteration. The difference with finite iterations is that it is impossible to say
    by a cursory examination of the code, whether the iteration will stop or not.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 无限迭代可以通过无限迭代器、`while`循环或递归来获得。显然，在实际情况下，某些条件会停止迭代。与有限迭代不同的是，仅通过代码的快速检查，我们无法确定迭代是否会停止。
- en: The while loop
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`while`循环'
- en: 'The `while` loop may be used to repeat a code block until a condition is fulfilled:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环可以用来重复执行一个代码块，直到满足某个条件：'
- en: '[PRE48]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'A `while` loop is equivalent to the following code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环等价于以下代码：'
- en: '[PRE49]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'So a `while` loop is equivalent to an infinite iterator, which might be stopped
    if a condition is fulfilled. The danger of such a construction is obvious: the
    code may be trapped in an infinite loop if the condition is never fulfilled.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`while`循环等价于一个无限迭代器，如果满足某个条件，它可能会停止。这种构造的危险性是显而易见的：如果条件永远不会满足，代码可能会陷入无限循环。
- en: The problem in scientific computing is that one is not always sure that an algorithm
    will converge. Newton iteration, for instance, might not converge at all. If that
    algorithm were implemented inside a `while` loop, the corresponding code would
    be trapped in an infinite loop for some choices of initial conditions.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 科学计算中的问题在于，人们并不总是能确定一个算法是否会收敛。例如，牛顿迭代法可能根本不会收敛。如果这个算法被实现在一个`while`循环中，相应的代码可能会因为某些初始条件的选择而陷入无限循环。
- en: 'We therefore give an advice that finite iterators are often better suited for
    such a task. The following construction replaces, often advantageously, the use
    of a `while` loop:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们建议有限迭代器通常更适合这样的任务。以下构造通常可以有效地替代`while`循环的使用：
- en: '[PRE50]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The first advantage is that the code is guaranteed to execute in a finite time
    no matter what happens. The second advantage is that the variable `nb_iterations`
    contains the number of iterations that was necessary for the algorithm to converge.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个优点是，无论发生什么情况，代码都保证在有限的时间内执行。第二个优点是，变量`nb_iterations`包含了算法收敛所需的迭代次数。
- en: Recursion
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归
- en: A recursion occurs when a function calls itself (refer to section *Recursive
    Function* in [Chapter 7](ch07.html "Chapter 7. Functions"), *Functions*).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数调用自身时，就会发生递归（参见第7章中的*递归函数*部分[Chapter 7](ch07.html "Chapter 7. Functions")，*函数*）。
- en: 'When doing recursions, it is the recursion depth, that is the number of iterations,
    which brings your computer to its limits. We demonstrate this here by considering
    a simple recursion, which actually contains no computations at all. It assigns
    to the iterates only the value zero:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行递归时，是递归深度，即迭代次数，将计算机推向极限。我们在这里通过考虑一个简单的递归来说明这一点，实际上这个递归根本不包含任何计算。它只将值零赋给迭代项：
- en: '[PRE51]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Depending on your system, this program may choke for *N ≥ 10000* (too much
    memory is used). The result is that the Python interpreter crashes without further
    exception. Python provides a mechanism to raise an exception when a too high recursion
    depth is detected. This maximum recursion depth may be changed by executing:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的系统，此程序可能在 *N ≥ 10000* 时崩溃（使用了太多内存）。结果是 Python 解释器在没有进一步异常的情况下崩溃。Python 提供了一种机制，当检测到过深的递归深度时，会引发异常。此最大递归深度可以通过执行以下操作来更改：
- en: '[PRE52]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The actual value of the recursion limit can be obtained by `sys.getrecursionlimit()`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的递归限制值可以通过 `sys.getrecursionlimit()` 获取。
- en: Be aware though, that choosing too high a number may imperil the stability of
    your code, since Python might crash before that maximum depth is reached. It is
    therefore often wise to leave the recursion limit as it is.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 但是请注意，选择过高的数字可能会危及你代码的稳定性，因为 Python 可能会在达到最大深度之前崩溃。因此，通常明智的做法是保留递归限制不变。
- en: 'By comparison, the following, non recursive, program runs ten of millions of
    iterations without any problem:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，以下非递归程序在没有任何问题的前提下运行了数千万次迭代：
- en: '[PRE53]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We advocate that, if possible, recursion should be avoided in Python. This applies
    obviously only if there is an appropriate alternative iterative algorithm available.
    The first reason is that a recursion of depth *N* involves *N* function calls
    at the same time, which might result in a significant overhead. The second reason
    is that it is an infinite iteration, that is, it is difficult to give an upper
    bound to the number of steps necessary before the recursion is over.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主张，如果可能的话，在 Python 中应避免递归。这显然仅适用于有适当的替代迭代算法可用的情况。第一个原因是深度为 *N* 的递归涉及 *N* 个函数调用同时进行，这可能会导致显著的开销。第二个原因是它是无限迭代，也就是说，很难给出递归结束前所需步骤数量的上界。
- en: Note that in some very special cases (tree traversal) recursion is unavoidable.
    Besides, in some cases (with small recursion depths) recursive programs might
    be preferred due to readability.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在某些非常特殊的情况下（树遍历），递归是不可避免的。此外，在某些情况下（递归深度较小），由于可读性，递归程序可能更受欢迎。
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we studied iterators,  a programming construct very near to
    a mathematical description of iterative methods. You saw the `yield` keyword and
    met finite and infinite iterators.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了迭代器，这是一个接近迭代方法数学描述的编程结构。你看到了 `yield` 关键字，并遇到了有限和无限迭代器。
- en: We showed that an iterator can be exhausted. More special aspects such as iterator
    comprehension and recursive iterators were introduced and demonstrated with the
    help of examples.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了迭代器可以被耗尽。通过示例的帮助，介绍了更多特殊方面，如迭代器推导和递归迭代器。
- en: Exercises
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: '**Ex. 1** → Compute the value of the sum:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 1** → 计算求和的值：'
- en: '![Exercises](img/B05511_09_09.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![练习](img/B05511_09_09.jpg)'
- en: '**Ex. 2** → Create a generator that computes the sequence defined by the relation:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 2** → 创建一个生成器，该生成器通过关系式计算序列：'
- en: '![Exercises](img/un2nm1.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![练习](img/un2nm1.jpg)'
- en: '**Ex. 3** → Generate all the even numbers.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 3** → 生成所有偶数。'
- en: '**Ex. 4** → Let ![Exercises](img/B05511_09_10.jpg). In calculus, it is shown
    that ![Exercises](img/limsn.jpg). Determine experimentally the smallest number
    *n* such that ![Exercises](img/tempowminus5.jpg). Use a generator for this task.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 4** → 令 ![练习](img/B05511_09_10.jpg)。在微积分中，已经证明 ![练习](img/limsn.jpg)。通过实验确定最小的数字
    *n*，使得 ![练习](img/tempowminus5.jpg)。为此任务使用生成器。'
- en: '**Ex. 5** → Generate all prime numbers less than a given integer. Use the algorithm
    called Sieve of Eratosthenes.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 5** → 生成小于给定整数的所有质数。使用称为埃拉托斯特尼筛法的算法。'
- en: '**Ex. 6** → Solving the differential equation ![Exercises](img/odesin.jpg)
    by applying the explicit Euler method results in the recursion:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 6** → 通过应用显式欧拉方法求解微分方程 ![练习](img/odesin.jpg) 导致递归：'
- en: '![Exercises](img/euler1.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![练习](img/euler1.jpg)'
- en: Write a generator that computes the solution values *u[n]* for a given initial
    value *u*[0] and for a given value of the time step *h*.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个生成器，用于计算给定初始值 *u*[0] 和给定的时间步长 *h* 的解值 *u[n]*。
- en: '**Ex. 7** → Compute π using the formula:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 7** → 使用公式计算 π：'
- en: '![Exercises](img/B05511_09_11.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![练习](img/B05511_09_11.jpg)'
- en: 'The integral can be approximated using the composite trapezoidal rule, that
    is, by this formula:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用复合梯形规则近似积分，即通过此公式：
- en: '![Exercises](img/B05511_09_12.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![练习](img/B05511_09_12.jpg)'
- en: where ![Exercises](img/grid_value.jpg).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 ![练习](img/grid_value.jpg)。
- en: Program a *generator* for the values *y[i] = f(x[i])* and evaluate the formula
    by summing one term after the other. Compare your results with the `quad` function
    of SciPy.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 *生成器* 用于计算值 *y[i] = f(x[i])*，并通过逐项求和来评估公式。将你的结果与 SciPy 的 `quad` 函数进行比较。
- en: '**Ex. 8** → Let *x* = [1, 2, 3] and *y* = [-1, -2, -3]. What is the effect
    of the code `zip(*zip(x, y))`? Explain how it works.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 8** → 令 *x* = [1, 2, 3] 和 *y* = [-1, -2, -3]。代码 `zip(*zip(x, y))` 的效果是什么？解释它是如何工作的。'
- en: '**Ex. 9** → Complete elliptic integrals can be computed by the function `scipy.special.ellipk`.
    Write a function, which counts the number of iterations needed with the  AGM iteration
    until the result coincides up to a given tolerance (note that the input parameter
    *m* in `ellipk` corresponds to *k²* in the definition in the section *Arithmetic
    geometric mean)* .'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 9** → 可以通过函数 `scipy.special.ellipk` 计算完全椭圆积分。编写一个函数，该函数计算使用 AGM 迭代直到结果达到给定容差所需的迭代次数（注意，`ellipk`
    中的输入参数 *m* 对应于 *Arithmetic geometric mean* 部分定义中的 *k²*）。'
- en: '**Ex. 10** → Consider the sequence defined by:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 10** → 考虑由以下序列定义：'
- en: '![Exercises](img/En.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![练习](img/En.jpg)'
- en: 'It converges monotonically to zero: *E[1] >E[2] > . . . > 0*. By integration
    by parts, one can show that the sequence *E[n]* fulfills the following recursion:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 它单调收敛到零：*E[1] >E[2] > . . . > 0*。通过分部积分，可以证明序列 *E[n]* 满足以下递归：
- en: '![Exercises](img/E_recurse.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![练习](img/E_recurse.jpg)'
- en: 'Compute the first 20 terms of the recursion by using an appropriate generator
    and compare the results with those obtained by numerical integration with `scipy.integrate.quad`.
    Do the same by reversing the recursion:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用适当的生成器计算递归的前 20 项，并将结果与使用 `scipy.integrate.quad` 进行数值积分得到的结果进行比较。通过反转递归进行同样的操作：
- en: '![Exercises](img/B05511_09_17.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![练习](img/B05511_09_17.jpg)'
- en: Use the `exp` function to evaluate the exponential function. What do you observe?
    Do you have an explanation? (refer to [[29]](apa.html "Appendix . References")*)*
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `exp` 函数来评估指数函数。你观察到了什么？你有解释吗？（参考 [[29]](apa.html "附录 . 参考文献")*）
- en: '![Exercises](img/Euler-e1481710075110.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![练习](img/Euler-e1481710075110.jpg)'
- en: 'Figure 9.2: A convergence study of functions approximating to sin(x)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2：逼近 sin(x) 的函数的收敛性研究
- en: '**Ex. 11** → The  sine-function can be expressed due to Euler as'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 11** → 正弦函数可以像欧拉那样表示'
- en: '![Exercises](img/B05511_09_18.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![练习](img/B05511_09_18.jpg)'
- en: Write a generator that generates the function values *P[k](x)*. Set `x=linspace(-1,3.5*pi,200)`
    and demonstrate graphically how good *P[k](x)* approximates sin for increasing
    *k*. In previous figure (*Figure 9.2*), the possible result is shown (refer to
    [[11, Th. 5.2, p. 65]](apa.html "Appendix . References")).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个生成器，用于生成函数值 *P[k](x)*。设置 `x=linspace(-1,3.5*pi,200)` 并通过图形演示 *P[k](x)* 随
    *k* 增加对 sin 的逼近效果。在之前的图（图 9.2）中显示了可能的结果（参考 [[11, Th. 5.2, p. 65]](apa.html "附录 . 参考文献")）。
