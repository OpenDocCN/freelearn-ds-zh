- en: 'Appendix A: Readying Mathematical Concepts'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By convention, a # indicates that there is a complimentary entry in [*Chapter
    9*](B18268_09_ePub.xhtml#_idTextAnchor253)*, Glossary*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this appendix, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Notations used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mathematical definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A companion Jupyter notebook for this chapter can be downloaded from GitHub
    at [https://github.com/PacktPublishing/Quantum-Chemistry-and-Computing-for-the-Curious](https://github.com/PacktPublishing/Quantum-Chemistry-and-Computing-for-the-Curious),
    which has been tested in the Google Colab environment, which is free and runs
    entirely in the cloud, and in the IBM Quantum Lab environment. Please refer to
    [*Appendix B*](B18268_Appendix_B_ePub.xhtml#_idTextAnchor313) *– Leveraging Jupyter
    Notebooks in the Cloud*, for more information. The companion Jupyter notebook
    automatically installs the following list of libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Numerical Python** (**NumPy**) [NumPy], an open-source Python library that
    is used in almost every field of science and engineering'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SymPy** [SymPy], a Python library for symbolic mathematics'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qiskit** [Qiskit], an open-source SDK for working with quantum computers
    at the level of pulses, circuits, and application modules'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qiskit visualization support to enable the use of its visualization functionality
    and Jupyter notebooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing NumPy, SimPy, and Qiskit and importing various modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install NumPy with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Install SymPy using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Install Qiskit using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Importing NumPy and a function that returns a LaTeX representation of a complex
    array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Import NumPy with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Import the required functions and class methods. The `array_to_latex function()`
    returns a LaTeX representation of a complex array with dimension 1 or 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notations used
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be using the following notations wherever it is appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_A_001.png), and so on – Lowercase Greek letters for scalars.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/Formula_A_002.png), and so on – Lowercase Latin letters for column
    vectors in particle space. These vectors have n components denoted ![](img/Formula_A_003.png),
    and so on where k is an integer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/Formula_A_004.png), and so on – Uppercase Latin letters for matrices
    in particle space. These are n X n matrices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/Formula_A_005.png), and so on – The prime symbol ('') and the letter
    ![](img/Formula_A_006.png) stand for vector and matrix transpose.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/Formula_A_007.png), and so on – The asterisk symbol (*) is used for
    vector and matrix complex conjugate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/Formula_A_008.png), ![](img/Formula_A_009.png), and so on – The dagger
    symbol, ![](img/Formula_A_010.png), is used for vector and matrix complex conjugate
    transpose.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/Formula_A_011.png), and so on – A power to the negative one ![](img/Formula_A_012.png)
    represents the inverse of a matrix.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/Formula_A_013.png), and so on – The o-times symbol ![](img/Formula_A_014.png)
    represents the Kronecker product or tensor product of matrices and/or vectors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/Formula_A_015.png), and so on. – The symbol ![](img/Formula_A_016.png)
    represents the Kronecker sum of square matrices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/Formula_A_017.png) – There exists at least one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/Formula_A_018.png) – For all.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/Formula_A_019.png) – Is member of, for example ![](img/Formula_A_020.png)
    means that ![](img/Formula_A_021.png) is in the set ![](img/Formula_A_022.png)
    of real numbers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mathematical definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pauli exclusion principle (PEP) #'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In 1925, Pauli described the PEP for electrons, which states that it is impossible
    for two electrons of the same atom to simultaneously have the same values of the
    following four quantum numbers: ![](img/Formula_A_023.png), the principal quantum
    number; ![](img/Formula_A_024.png), the angular momentum quantum number; ![](img/Formula_A_025.png),
    the magnetic quantum number; and ![](img/Formula_A_026.png), the spin quantum
    number.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the discovery of various types of elementary particles, the PEP for
    electrons has been generalized for all elementary particles and composite systems.
    Remember that fermions are particles that have half-integer spin (![](img/Formula_A_027.png))
    and bosons are particles that have integer spin (![](img/Formula_A_028.png)).
    The general formulation of the PEP states the total wave function ![](img/Formula_A_029.png)
    for a quantum system must have certain symmetries for all sets of identical particles,
    that is, electrons and identical nuclei, both bosons and fermions, under the operation
    of pair particle permutation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For fermions, the total wave function must be antisymmetric (![](img/Formula_A_030.png))
    with respect to the exchange of identical pair particles ![](img/Formula_A_031.png):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/Formula_A_032.png)'
  prefs: []
  type: TYPE_IMG
- en: meaning that the spatial part of the wave function is antisymmetric while the
    spin part is symmetric, or vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'For bosons, the total wave function must be symmetric (![](img/Formula_A_033.png))
    with respect to the exchange of pair particles (![](img/Formula_A_034.png)):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/Formula_A_035.png)'
  prefs: []
  type: TYPE_IMG
- en: meaning that both the spatial wave function and spin function are symmetric,
    or both are antisymmetric.
  prefs: []
  type: TYPE_NORMAL
- en: For composite systems with both identical fermions and identical bosons, the
    preceding operations must hold true simultaneously.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Angular momentum quantum number #'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Also known as the orbital quantum number or the azimuthal quantum number, and
    denoted by ![](img/Formula_A_036.png), this describes the electron subshell and
    gives the magnitude of the orbital angular momentum through the relation: ![](img/Formula_A_037.png).
    In chemistry and spectroscopy, ![](img/Formula_A_038.png) is called the ![](img/Formula_A_039.png)
    orbital, ![](img/Formula_A_040.png) the ![](img/Formula_06_013.png) orbital, ![](img/Formula_A_042.png)
    the ![](img/Formula_A_043.png) orbital, and ![](img/Formula_A_044.png) the ![](img/Formula_A_045.png)
    orbital. Technically, there are more orbitals beyond the ![](img/Formula_A_046.png)
    orbital, that is, ![](img/Formula_A_047.png), ![](img/Formula_A_048.png), and
    so on, and these are of higher energy levels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Occupation number operator #'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An operator ![](img/Formula_A_049.png) where ![](img/Formula_A_050.png), and
    ![](img/Formula_A_051.png) are the annihilation operators and ![](img/Formula_A_052.png)
    are the creation operators that act on local electron modes, and satisfy the following
    anti-commutation relations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_A_053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_A_054.png)'
  prefs: []
  type: TYPE_IMG
- en: where ![](img/Formula_A_055.png) is the Dirac delta function and ![](img/Formula_A_056.png)
    is the anti-commutator of two operators ![](img/Formula_A_057.png) and ![](img/Formula_A_058.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Quantum Phase Estimation (QPE) #'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given a unitary operator ![](img/Formula_05_052.png), its eigenstate and eigenvalues,
    ![](img/Formula_A_060.png), the ability to prepare a state ![](img/Formula_A_061.png),
    and the ability to apply ![](img/Formula_A_062.png) itself, the QPE algorithm
    calculates ![](img/Formula_A_063.png), where ![](img/Formula_06_123.png) is the
    number of qubits used to estimate ![](img/Formula_A_065.png) thereby allowing
    measurement of ![](img/Formula_A_066.png) as precisely as we want.
  prefs: []
  type: TYPE_NORMAL
- en: Complex numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Complex numbers are of the form ![](img/Formula_A_067.png) where ![](img/Formula_A_068.png)
    and ![](img/Formula_A_069.png) are real numbers and ![](img/Formula_A_070.png)
    (![](img/Formula_A_071.png) in Python) is called the imaginary unit that by definition
    satisfies the equation ![](img/Formula_A_072.png). The magnitude of a complex
    number is: ![](img/Formula_A_073.png). The complex conjugate of ![](img/Formula_A_074.png)
    is ![](img/Formula_A_075.png). Euler''s formula ![](img/Formula_A_076.png) is
    convenient for multiplying complex numbers, and exponentiation. The set of complex
    numbers together with the addition and multiplication operations is a field denoted
    ![](img/Formula_A_077.png). Algebraic expressions composed of complex numbers
    follow the standard rules of algebra; the difference with real numbers is that
    ![](img/Formula_A_078.png) is replaced by ![](img/Formula_A_079.png).'
  prefs: []
  type: TYPE_NORMAL
- en: Vector space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A vector space ![](img/Formula_A_080.png) over the field ![](img/Formula_A_081.png)
    of complex numbers or the field ℝ of real numbers is a set of objects called vectors
    that can be added together and multiplied ("scaled") by numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Python code illustrates a vector with two complex components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/Formula_A_082.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We use the @ operator introduced in Python 3.5 to multiply a vector by a number,
    as illustrated below, multiplying vector ![](img/Formula_A_083.png) by the imaginary
    unit ![](img/Formula_A_084.png) (![](img/Formula_A_071.png) in Python) where ![](img/Formula_A_086.png)
    is replaced by ![](img/Formula_A_0791.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/Formula_A_088.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_A_089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Linear operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A function ![](img/Formula_A_090.png) defined on a vector space ![](img/Formula_A_091.png)
    over ![](img/Formula_A_092.png) is a linear operator if it has the two following
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: For any ![](img/Formula_A_093.png) in ![](img/Formula_A_094.png), ![](img/Formula_A_095.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For any ![](img/Formula_A_096.png) in ![](img/Formula_A_097.png), ![](img/Formula_A_098.png)
    in ![](img/Formula_A_099.png) , ![](img/Formula_A_100.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A matrix is a set of elements arranged in a square or rectangular array. Elements
    can be numbers, matrices, functions, or algebraic expressions. The order or shape
    of a matrix is written (number of rows) x (number of columns). Indices are written
    in *row, column* format so for example, ![](img/Formula_A_101.png) is an element
    in row ![](img/Formula_A_102.png) and column ![](img/Formula_A_103.png). Matrices
    represent linear operators in a vector space. It is convenient to use the same
    symbol for an operator and its matrix in some orthonormal basis.
  prefs: []
  type: TYPE_NORMAL
- en: Eigenvalues and eigenvectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By definition, an eigenvector of a linear operator ![](img/Formula_A_104.png)
    defined on a vector space ![](img/Formula_A_105.png) over ![](img/Formula_A_099.png)
    is a non-zero vector ![](img/Formula_05_045.png) that has the following property:
    ![](img/Formula_A_108.png) where ![](img/Formula_A_109.png) is a scalar in ![](img/Formula_A_110.png)
    known as the eigenvalue associated with the eigenvector ![](img/Formula_A_111.png).'
  prefs: []
  type: TYPE_NORMAL
- en: For a finite-dimensional space ![](img/Formula_A_112.png), the above definition
    is equivalent to ![](img/Formula_A_113.png) where ![](img/Formula_A_114.png) is
    the matrix representation of ![](img/Formula_A_115.png).
  prefs: []
  type: TYPE_NORMAL
- en: Vector and matrix transpose, conjugate, and conjugate transpose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The transpose of some vector ![](img/Formula_A_116.png) or some matrix ![](img/Formula_A_114.png)
    often denoted as ![](img/Formula_A_118.png) is obtained by switching the row and
    column indices of the vector ![](img/Formula_A_119.png) or matrix ![](img/Formula_A_120.png).
    The following Python code illustrates the transpose of vector ![](img/Formula_A_121.png)
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/Formula_A_122.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The complex conjugate of some vector ![](img/Formula_A_123.png) or some matrix
    ![](img/Formula_A_124.png) often denoted as ![](img/Formula_A_125.png), ![](img/Formula_A_126.png)
    is obtained by performing the complex conjugate of all the elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/Formula_A_127.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The complex conjugate transpose of some vector ![](img/Formula_A_128.png) or
    matrix ![](img/Formula_02_430.png) often is denoted as ![](img/Formula_A_130.png)
    , ![](img/Formula_A_131.png) in quantum mechanics. The symbol, ![](img/Formula_A_132.png),
    is called the dagger. ![](img/Formula_02_429.png) is called the adjoint or Hermitian
    conjugate of ![](img/Formula_02_304.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/Formula_A_135.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Dirac''s notation #'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Dirac''s notation, also known as bra-ket notation:'
  prefs: []
  type: TYPE_NORMAL
- en: A ket ![](img/Formula_A_136.png) denotes a vector, which represents a state
    of a quantum system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A bra ![](img/Formula_A_137.png) denotes a linear function that maps each vector
    to a complex number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The action of the linear function ![](img/Formula_A_138.png) on a vector ![](img/Formula_A_139.png)
    is written as ![](img/Formula_A_140.png).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'They are related as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_A_141.png) ![](img/Formula_A_142.png)'
  prefs: []
  type: TYPE_IMG
- en: Inner product of two vectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An inner product over a vector space ![](img/Formula_A_105.png) over ![](img/Formula_A_144.png)
    is a complex function (·, ·) of two vectors that returns a scalar, and which satisfies
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: For any ![](img/Formula_A_145.png) in ![](img/Formula_A_080.png), ![](img/Formula_A_147.png).
    Moreover ![](img/Formula_A_148.png) if and only if ![](img/Formula_A_149.png).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/Formula_A_150.png).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/Formula_A_151.png).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On ![](img/Formula_A_152.png) the standard Hermitian inner product is: ![](img/Formula_A_153.png)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Dirac''s notation, the inner product of vectors ![](img/Formula_A_154.png)
    and ![](img/Formula_A_155.png) is denoted ![](img/Formula_A_156.png) and is the
    same as the result of applying the bra ![](img/Formula_A_157.png) to the ket ![](img/Formula_A_155.png)
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_A_159.png) ![](img/Formula_A_160.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_A_161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The Python `numpy.vdot` function returns the Hermitian inner product of two
    vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/Formula_A_162.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/Formula_A_163.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/Formula_A_164.png)'
  prefs: []
  type: TYPE_IMG
- en: Norm of a vector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The inner product yields a norm defined by ![](img/Formula_A_165.png) . In addition
    to the triangle inequality ![](img/Formula_A_166.png), the norm also satisfies
    the Schwarz inequality ![](img/Formula_A_167.png) . The vector norm or the vector's
    magnitude is commonly known as the length of the vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python `numpy.linalg.norm` function returns the norm of a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/Formula_A_168.png)'
  prefs: []
  type: TYPE_IMG
- en: Hilbert space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An inner-product space ![](img/Formula_A_169.png) is a Hilbert space if it
    is complete under the induced norm, that is, if every Cauchy sequence converges:
    for every sequence ![](img/Formula_A_170.png) with ![](img/Formula_A_171.png)
    such that ![](img/Formula_A_172.png) there is an ![](img/Formula_02_529.png) in
    ![](img/Formula_A_105.png) with ![](img/Formula_A_175.png). This property allows
    the technique of calculus to be used.'
  prefs: []
  type: TYPE_NORMAL
- en: Matrix multiplication with a vector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `@` operator introduced in Python 3.5 implements matrix multiplication
    with a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/Formula_A_176.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/Formula_A_177.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/Formula_A_180.png)'
  prefs: []
  type: TYPE_IMG
- en: Matrix addition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The addition of two matrices of the same shape is achieved by adding the corresponding
    entries together:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_A_181.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/Formula_A_182.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/Formula_A_183.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/Formula_A_184.png)'
  prefs: []
  type: TYPE_IMG
- en: Matrix multiplication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let ![](img/Formula_02_304.png) be an m-by-n matrix and ![](img/Formula_A_186.png)
    an n-by-p matrix, then the product ![](img/Formula_A_187.png) is the m-by-p matrix
    defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_A_188.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `@` operator introduced in Python 3.5 implements matrix multiplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/Formula_A_189.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/Formula_A_190.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/Formula_A_191.png)'
  prefs: []
  type: TYPE_IMG
- en: Matrix inverse
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The inverse of some matrix ![](img/Formula_A_192.png) when it exists is denoted
    as ![](img/Formula_A_193.png) is a matrix such that ![](img/Formula_A_194.png)
    where ![](img/Formula_A_195.png) is the identity matrix, for any matrix ![](img/Formula_02_304.png)
    : ![](img/Formula_A_197.png) . The `numpy.linalg.inv` function computes the multiplicative
    matrix inverse of a matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/Formula_A_198.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/Formula_A_199.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tensor product
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given vector spaces ![](img/Formula_02_458.png) of dimension ![](img/Formula_02_350.png)
    and ![](img/Formula_A_202.png) of dimension ![](img/Formula_A_203.png) over ![](img/Formula_A_204.png)
    the tensor product ![](img/Formula_A_205.png) is another vector space ![](img/Formula_A_206.png)
    of dimension ![](img/Formula_A_207.png) over ![](img/Formula_A_099.png).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_A_209.png) and ![](img/Formula_A_210.png) linear maps on ![](img/Formula_A_211.png)
    and ![](img/Formula_A_212.png) linear maps on ![](img/Formula_A_213.png):'
  prefs: []
  type: TYPE_NORMAL
- en: Bilinearity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](img/Formula_A_214.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_A_215.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_A_216.png)'
  prefs: []
  type: TYPE_IMG
- en: Associativity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](img/Formula_A_217.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_A_218.png)'
  prefs: []
  type: TYPE_IMG
- en: Linear maps properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](img/Formula_A_219.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_A_220.png)'
  prefs: []
  type: TYPE_IMG
- en: If the inner-product space ![](img/Formula_A_221.png) is the tensor product
    of two inner-product spaces ![](img/Formula_A_222.png), ![](img/Formula_A_169.png),
    then for each pair of vectors ![](img/Formula_A_224.png) , ![](img/Formula_A_225.png)
    there is an associated tensor product ![](img/Formula_A_226.png) in ![](img/Formula_A_227.png).
  prefs: []
  type: TYPE_NORMAL
- en: In Dirac's notation, we denote the tensor product ![](img/Formula_A_228.png)
    as ![](img/Formula_A_229.png) or ![](img/Formula_A_230.png).
  prefs: []
  type: TYPE_NORMAL
- en: The inner product of ![](img/Formula_A_231.png) and ![](img/Formula_A_232.png)
    is ![](img/Formula_A_233.png) .
  prefs: []
  type: TYPE_NORMAL
- en: Kronecker product or tensor product of matrices or vectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Kronecker product or tensor product denoted as ![](img/Formula_A_234.png)
    of two matrices is a composite matrix made of blocks of the second matrix scaled
    by the first. Let ![](img/Formula_A_124.png) be an m-by-n matrix and ![](img/Formula_A_236.png)
    an p-by-q matrix, then the Kronecker product ![](img/Formula_A_237.png) is the
    pm-by-qn block matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_A_238.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Python `numpy.kron` function implements the Kronecker product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/Formula_A_239.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/Formula_A_240.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/Formula_A_241.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Kronecker sum
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Kronecker sum of any two square matrices, ![](img/Formula_A_192.png) n-by-n
    and ![](img/Formula_A_243.png) m-by-m, noted ![](img/Formula_A_244.png) is defined
    by:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_A_245.png)'
  prefs: []
  type: TYPE_IMG
- en: where ![](img/Formula_A_246.png) is the identity matrix or order ![](img/Formula_A_247.png)
    and ![](img/Formula_A_248.png) is the identity matrix of order ![](img/Formula_A_249.png).
  prefs: []
  type: TYPE_NORMAL
- en: Outer product
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The outer product of a ket ![](img/Formula_A_139.png) and a bra ![](img/Formula_A_251.png)
    is the rank-one operator ![](img/Formula_A_252.png) with the rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_A_253.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For a finite-dimensional vector space, the outer product is a simple matrix
    multiplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_A_254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The Python `numpy.outer` function implements the outer product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/Formula_A_255.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/Formula_A_256.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/Formula_A_257.png)'
  prefs: []
  type: TYPE_IMG
- en: Writing matrices as a sum of outer products
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Any matrix can be written in terms of outer products. For instance, for a 2
    x 2 matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_A_258.png) ![](img/Formula_A_259.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_A_260.png) ![](img/Formula_A_261.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_A_262.png)'
  prefs: []
  type: TYPE_IMG
- en: Hermitian operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The complex conjugate transpose of some vector ![](img/Formula_A_263.png) or
    matrix ![](img/Formula_A_057.png) is often denoted as ![](img/Formula_02_426.png),
    ![](img/Formula_A_266.png) in quantum mechanics. The symbol, ![](img/Formula_A_267.png),
    is called the dagger. ![](img/Formula_A_268.png) is called the adjoint or Hermitian
    conjugate of ![](img/Formula_06_015.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'A linear operator ![](img/Formula_A_270.png) is called Hermitian or self-adjoint
    if it is its own adjoint: ![](img/Formula_A_271.png).'
  prefs: []
  type: TYPE_NORMAL
- en: The spectral theorem says that if ![](img/Formula_A_270.png) is Hermitian then
    it must have a set of orthonormal eigenvectors
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_A_273.png)'
  prefs: []
  type: TYPE_IMG
- en: 'where ![](img/Formula_A_274.png) with real eigenvalues ![](img/Formula_A_275.png),
    and ![](img/Formula_02_480.png) is the number of eigenvectors, or also is the
    dimension of the Hilbert space. Hermitian operators have a unique spectral representation
    in terms of the set of eigenvalues ![](img/Formula_A_277.png) and the corresponding
    eigenvectors ![](img/Formula_A_278.png) :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_A_279.png)'
  prefs: []
  type: TYPE_IMG
- en: Unitary operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A linear operator ![](img/Formula_02_433.png) is called unitary if its adjoint
    exists and satisfies ![](img/Formula_A_281.png) where ![](img/Formula_A_282.png)
    is the identity matrix, which by definition leaves any vector it is multiplied
    with unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unitary operators preserve inner products:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_A_283.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Hence unitary operators also preserve the norm commonly known as the length
    of quantum states:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_A_284.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For any unitary matrix ![](img/Formula_02_458.png), any eigenvectors ![](img/Formula_A_286.png)
    and ![](img/Formula_A_287.png) and their eigenvalues ![](img/Formula_A_288.png)
    and ![](img/Formula_A_289.png), ![](img/Formula_A_290.png) and ![](img/Formula_A_291.png)
    , the eigenvalues ![](img/Formula_A_292.png) and ![](img/Formula_02_466.png) have
    the form ![](img/Formula_A_294.png) and if ![](img/Formula_A_295.png) then the
    eigenvectors ![](img/Formula_A_296.png)and ![](img/Formula_A_297.png) are orthogonal:
    ![](img/Formula_A_298.png).'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is useful to note that since for any ![](img/Formula_02_472.png) , ![](img/Formula_A_300.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_A_301.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Density matrix #'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Any quantum state, either **mixed** or **pure**, can be described by a **density
    matrix** (![](img/Formula_A_302.png)), which is a normalized positive Hermitian
    operator where ![](img/Formula_A_303.png). According to the spectral theorem,
    there exists an orthonormal basis, defined in *Section 2.3.1, Hermitian operator*,
    such that the density is the sum of all eigenvalues (![](img/Formula_02_480.png)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_A_305.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'where ![](img/Formula_A_306.png) ranges from 1 to ![](img/Formula_A_307.png),
    ![](img/Formula_A_308.png) are positive or null eigenvalues (![](img/Formula_A_309.png)),
    and the sum of eigenvalues is the trace operation (![](img/Formula_A_310.png))
    of the density matrix and is equal to 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_A_311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For example, when the density is ![](img/Formula_A_312.png), with ![](img/Formula_A_313.png),
    the trace of the density is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_A_314.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here are some examples of the density matrices of pure quantum states:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_A_315.jpg)![](img/Formula_A_316.jpg)![](img/Formula_A_317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The density matrix of a mixed quantum state consisting of a statistical ensemble
    of ![](img/Formula_02_247.png) pure quantum states ![](img/Formula_A_319.png),
    each with a classical probability of occurrence ![](img/Formula_A_320.png), is
    defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_A_321.png)'
  prefs: []
  type: TYPE_IMG
- en: 'where every ![](img/Formula_A_322.png) is positive or null and their sum is
    equal to one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_A_323.png)'
  prefs: []
  type: TYPE_IMG
- en: We summarize the difference between pure states and mixed states in Figure AA.1
    which is the same as *Figure 2.20*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Appendix_table1.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure AA.1 – Density matrix of pure and mixed quantum states
  prefs: []
  type: TYPE_NORMAL
- en: Pauli matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three Pauli matrices (![](img/Formula_A_330.png) , ![](img/Formula_A_331.png)
    and ![](img/Formula_A_332.png)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_A_333.png) , ![](img/Formula_A_334.png) , ![](img/Formula_A_335.png)'
  prefs: []
  type: TYPE_IMG
- en: 'which are Hermitian and unitary making the square of each equal to the ![](img/Formula_A_336.png)
    identity matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_A_337.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Each of the Pauli matrices is equal to its inverse:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_A_338.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_A_339.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_A_340.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We summarize the Pauli matrices and the operations on a qubit that yields the
    associated eigenvectors in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Appendix_table1.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Decomposing a matrix into the weighted sum of the tensor product of Pauli matrices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It can be shown that any matrix can be decomposed into the weighted sum of
    the tensor product of the identity matrix and the Pauli matrices ![](img/Formula_A_353.png)
    where ![](img/Formula_A_354.png) with weights ![](img/Formula_A_355.png) and ![](img/Formula_02_331.png)
    qubits:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_A_357.png)'
  prefs: []
  type: TYPE_IMG
- en: For Hermitian matrices, all weights ![](img/Formula_A_355.png) are real.
  prefs: []
  type: TYPE_NORMAL
- en: We provide a proof for any 2x2 matrix, ![](img/Formula_A_359.png).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_A_360.jpg)![](img/Formula_A_361.jpg)![](img/Formula_A_362.jpg)![](img/Formula_A_363.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Since ![](img/Formula_A_364.png) hence ![](img/Formula_A_365.png) we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_A_366.jpg)![](img/Formula_A_367.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Starting from the decomposition of a 2x2 matrix as a sum of outer products:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_A_368.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can then write:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_A_369.jpg)![](img/Formula_A_370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Anti-commutator #'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An operation of two operators ![](img/Formula_A_371.png) defined as: ![](img/Formula_A_372.png).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Anti-commutation #'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A set of fermionic annihilation operators ![](img/Formula_A_373.png) and creation
    operators ![](img/Formula_A_374.png) that act on local electron modes can be defined
    that satisfy the following anti-commutation relations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_A_375.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_A_376.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Commutator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An operation of two operators ![](img/Formula_A_377.png) defined as: ![](img/Formula_A_378.png).
    For any operators ![](img/Formula_02_304.png) and ![](img/Formula_06_150.png),
    ![](img/Formula_A_381.png) if and only if ![](img/Formula_02_425.png) and ![](img/Formula_A_383.png)
    commute. It can be shown that if a quantum system has two simultaneously physically
    observable quantities, then the Hermitian operators that represent them must commute.
    For any operators ![](img/Formula_02_425.png) , ![](img/Formula_A_385.png) and
    ![](img/Formula_A_386.png) we have the following relations, which are useful for
    calculating commutators:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_A_387.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_A_388.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_A_389.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_A_390.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_A_391.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_A_392.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_A_393.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fermion, fermionic, electron annihilation operator #'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A mathematical operation that allows us to represent excitations or transitions
    of quasi-particles. An excitation requires the initial state to be at a lower
    energy level than the final state.
  prefs: []
  type: TYPE_NORMAL
- en: 'An operator ![](img/Formula_A_394.png) that lowers by one unit the number of
    particles sitting in the ![](img/Formula_A_395.png) fermionic orbital:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_A_396.png)'
  prefs: []
  type: TYPE_IMG
- en: 'where:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_A_397.png) and ![](img/Formula_A_398.png) are the number of
    particles sitting in the ![](img/Formula_A_395.png) fermionic orbital.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_A_400.png) is a pre-factor that annihilates the state in the
    Slater determinant if there is no electron in the ![](img/Formula_A_401.png) fermionic
    orbital, that is, if ![](img/Formula_A_402.png).'
  prefs: []
  type: TYPE_NORMAL
- en: The phase factor ![](img/Formula_A_403.png) keeps the anti-symmetric properties
    of the whole superposition of states.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fermion, fermionic, electron creation operator #'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A mathematical operation that allows us to represent disexcitement (de-exitation)
    or transitions of quasi-particles. A de-excitation requires the initial state
    to be at a higher energy level than the final state.
  prefs: []
  type: TYPE_NORMAL
- en: 'An operator ![](img/Formula_A_404.png) that raises by one unit the number of
    particles sitting in the ![](img/Formula_A_405.png) fermionic orbital:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_A_406.png)'
  prefs: []
  type: TYPE_IMG
- en: 'where:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_A_407.png) and ![](img/Formula_A_408.png) are the number of
    particles sitting in the ![](img/Formula_A_409.png) fermionic orbital.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_A_410.png) is a pre-factor that annihilates the state if we
    had an electron in the ![](img/Formula_A_411.png) fermionic orbital, that is,
    if ![](img/Formula_A_412.png).'
  prefs: []
  type: TYPE_NORMAL
- en: The phase factor ![](img/Formula_A_413.png) keeps the anti-symmetric properties
    of the whole superposition of states.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fermion, fermionic, electron excitation operator #'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An operator ![](img/Formula_A_414.png) that excites an electron from the occupied
    spin orbital ![](img/Formula_A_415.png) into the unoccupied orbital ![](img/Formula_A_416.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Total wave function #'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Describes the physical behavior of a system and is represented by the capital
    Greek letter Psi: ![](img/Formula_A_417.png). It contains all the information
    of a quantum system including complex numbers (![](img/Formula_A_418.png)) as
    parameters. In general, ![](img/Formula_A_419.png) is a function of all the particles
    in the system ![](img/Formula_A_420.png), where the total number of particles
    is ![](img/Formula_06_024.png). Furthermore, ![](img/Formula_A_422.png) includes
    the spatial position of each particle (![](img/Formula_A_423.png)), the spin directional
    coordinates of each particle (![](img/Formula_A_424.png)), and time ![](img/Formula_A_425.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_A_426.png)'
  prefs: []
  type: TYPE_IMG
- en: 'where ![](img/Formula_A_427.png) and ![](img/Formula_A_428.png) are vectors
    of single particle coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_A_429.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_A_430.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The total wave function for a one particle system is a product of a spatial
    ![](img/Formula_A_431.png), spin ![](img/Formula_A_432.png), and time ![](img/Formula_02_017.png)
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_A_434.png)'
  prefs: []
  type: TYPE_IMG
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Micr_Algebra] Linear algebra, QuantumKatas/tutorials/LinearAlgebra/: [https://github.com/microsoft/QuantumKatas/tree/main/tutorials/LinearAlgebra](https://github.com/microsoft/QuantumKatas/tree/main/tutorials/LinearAlgebra)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Micr_Complex] Complex arithmetic, QuantumKatas/tutorials/ComplexArithmetic/:
    https://github.com/microsoft/QuantumKatas/tree/main/tutorials/ComplexArithmetic'
  prefs: []
  type: TYPE_NORMAL
- en: '[NumPy] NumPy: the absolute basics for beginners: [https://numpy.org/doc/stable/user/absolute_beginners.html](https://numpy.org/doc/stable/user/absolute_beginners.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Qiskit] Qiskit: [https://qiskit.org/](https://qiskit.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Qiskit_Alg] Linear Algebra, Qiskit: [https://qiskit.org/textbook/ch-appendix/linear_algebra.html](https://qiskit.org/textbook/ch-appendix/linear_algebra.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[SymPy] SymPy, A Python library for symbolic mathematics: [https://www.sympy.org/en/index.html](https://www.sympy.org/en/index.html)'
  prefs: []
  type: TYPE_NORMAL
