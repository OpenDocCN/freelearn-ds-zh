<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Working with the NumPy Array As a First Step to SciPy"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Working with the NumPy Array As a First Step to SciPy</h1></div></div></div><p>At the top level, SciPy is basically NumPy, since both the object creation and basic manipulation of these objects are performed by functions of the latter library. This assures much faster computations, since the memory handling is done internally in an optimal way. For instance, if an operation must be made on the elements of a big multidimensional array, a novice user might be tempted to go over columns and rows with as many for loops as necessary. Loops run much faster when they access each consecutive element in the same order in which they are stored in memory. We should not be bothered with considerations of this kind when coding. The NumPy/SciPy operations assure that this is the case. As an added advantage, the names of operations in NumPy/SciPy are intuitive and self explanatory. Code written in this fashion is extremely easy to understand and maintain, faster to correct or change in case of need.</p><p>Let's illustrate this point with an introductory example.</p><p>The <code class="literal">scipy.misc</code> module in the SciPy package contains a classical image called <code class="literal">lena</code>, used in the image processing community for testing and comparison purposes. This is a 512 x 512 pixel standard test image, which has been in use since 1973, and was originally cropped from the centerfold of the November 1972 issue of the Playboy magazine. It is a picture of Lena Söderberg, a Swedish model, shot by photographer Dwight Hooker. The image is <a id="id52" class="indexterm"/>probably the most widely used test image for all sorts of image processing algorithms (such as compression and noise reduction) and related scientific publications.</p><p>This image is stored as a two-dimensional array. Note that the number in the <span class="emphasis"><em>n<sup>th</sup></em></span> column and <span class="emphasis"><em>m<sup>th</sup></em></span> row of this array measures the grayscale value at the pixel position (<span class="emphasis"><em>n+1</em></span>, <span class="emphasis"><em>m+1</em></span>) of the image. In the following, we access this picture and store it in the <code class="literal">img</code> variable, by issuing the following commands:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; import scipy.misc</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; img=scipy.misc.lena()</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; import matplotlib.pyplot as plt </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.gray() </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.imshow(img) </strong></span>
</pre></div><p>The image<a id="id53" class="indexterm"/> can be displayed by issuing the following command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; plt.show() </strong></span>
</pre></div><div class="mediaobject"><img src="graphics/7702OS_02_01.jpg" alt="Working with the NumPy Array As a First Step to SciPy"/></div><p>We may take a peek at some of these values; say the 7 x 3 upper corner of the image (7 columns, 3 rows). Instead of issuing for loops, we could <span class="emphasis"><em>slice</em></span> the corresponding portion of the image. The <code class="literal">img[0:3,0:7]</code> command gives us the following:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>array([[162, 162, 162, 161, 162, 157, 163],</strong></span>
<span class="strong"><strong>       [162, 162, 162, 161, 162, 157, 163],</strong></span>
<span class="strong"><strong>       [162, 162, 162, 161, 162, 157, 163]])</strong></span>
</pre></div><p>We can use the same strategy to populate arrays or change their values. For instance, let's change all entries of the previous array to hold zeros on the second row between columns 2 to 6: </p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; img[1,1:6]=0</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print (img[0:3,0:7])</strong></span>
</pre></div><p>The <a id="id54" class="indexterm"/>output is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>[[162 162 162 161 162 157 163]</strong></span>
<span class="strong"><strong> [162   0   0   0   0   0 163]</strong></span>
<span class="strong"><strong> [162 162 162 161 162 157 163]]</strong></span>
</pre></div><div class="section" title="Object essentials"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Object essentials</h1></div></div></div><p>We<a id="id55" class="indexterm"/> have been introduced to NumPy's main object—the homogeneous multidimensional array, also referred to as <code class="literal">ndarray</code>. All elements of the array are casted to the same datatype (homogeneous). We obtain the datatype by the <code class="literal">dtype</code> attribute, its dimension by the <code class="literal">shape</code> attribute, the total number of elements in the array by the <code class="literal">size</code> attribute, and elements by referring to their positions: </p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; img.dtype, img.shape, img.size</strong></span>
</pre></div><p>The output is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>(dtype('int64'), (512, 512), 262144)</strong></span>
</pre></div><p>Let's compute the grayscale values now:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; img[32,67]</strong></span>
</pre></div><p>The output is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>87</strong></span>
</pre></div><p>Let's interpret the outputs. The elements of <code class="literal">img</code> are 64-bit integer values ('int64'). This may vary depending on the system, the Python installation, and the computer specifications. The shape of the array (note it comes as a Python tuple) is 512 x 512, and the number of elements 262144. The grayscale value of the image in the 33<sup>rd</sup> column and 68<sup>th</sup> row is <code class="literal">87</code> (note that in NumPy, as in Python or C, all indices are zero-based).</p><p>We will now introduce the basic property and methods of NumPy/SciPy objects—datatype and indexing.</p></div></div>
<div class="section" title="Using datatypes"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Using datatypes</h1></div></div></div><p>There <a id="id56" class="indexterm"/>are several approaches to impose the datatype. For instance, if we want all entries of an already created array to be 32-bit floating point values, we may cast it as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; import scipy.misc</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; img=scipy.misc.lena().astype('float32')</strong></span>
</pre></div><p>We can also use an optional argument, <code class="literal">dtype</code> through the command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; import numpy</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; scores = numpy.array([101,103,84], dtype='float32')</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; scores</strong></span>
</pre></div><p>The output is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>array([ 101.,  103.,   84.], dtype=float32)</strong></span>
</pre></div><p>This can be simplified even further with a third clever method (although this practice offers code that are not so easy to interpret):</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; scores = numpy.float32([101,103,84])</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; scores</strong></span>
</pre></div><p>The <a id="id57" class="indexterm"/>output is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>array([ 101.,  103.,   84.], dtype=float32)</strong></span>
</pre></div><p>The choice of datatypes for NumPy arrays is very flexible; we may choose the basic Python types (including <code class="literal">bool</code>, <code class="literal">dict</code>, <code class="literal">list</code>, <code class="literal">set</code>, <code class="literal">tuple</code>, <code class="literal">str</code>, and <code class="literal">unicode</code>), although for numerical computations we focus on <code class="literal">int</code>, <code class="literal">float</code>, <code class="literal">long</code>, and <code class="literal">complex</code>.</p><p>NumPy has its own set of datatypes optimized to use with instances of <code class="literal">ndarray</code>, and with the same precision as the previously given native types. We distinguish them with a trailing underscore (<code class="literal">_</code>). For instance, <code class="literal">ndarray</code> of strings could be initialized, as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; a=numpy.array(['Cleese', 'Idle', 'Gilliam'], dtype='str_')</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a.dtype</strong></span>
</pre></div><p> The output is shown as follows (it depends on your Python version):</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>dtype('&lt;U7')</strong></span>
</pre></div><p>Note two things; unlike it's purely Python counterpart, the usage of the <code class="literal">'str_'</code> datatype requires the name to be quoted; we could use the longer unquoted version, <code class="literal">numpy.str_</code>. </p><p>When prompted for datatype, the system returns its C-derived equivalent: <code class="literal">'&lt;U7'</code> ('<code class="literal">&lt;U</code> for strings, and <code class="literal">7</code>' to indicate the largest size of any of its elements).</p><p>The most common way to address numerical types is with the bit width nomenclature: <code class="literal">boolXX</code>, <code class="literal">intXX</code>, <code class="literal">uintXX</code>, <code class="literal">floatXX</code>, or <code class="literal">complexXX</code>, where <code class="literal">XX</code> indicates the bit size (for example, <code class="literal">uint32</code> for 32-bit unsigned integers).</p><p>It is also possible to design our own datatypes, and this is where the full potential of the flexibility of NumPy datatypes arise. For instance, a datatype to indicate the name and grades of a student could be created, as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; dt = numpy.dtype([ ('name', numpy.str_, 16), ('grades',numpy.float64, (2,)) ])</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; dt </strong></span>
</pre></div><p>The output is shown as follows (it depends on your Python version):</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>dtype([('name', '&lt;U16'), ('grades', '&lt;f8', (2,))])</strong></span>
</pre></div><p>This means that the <code class="literal">dt</code> datatype has two parts: the first part, the <code class="literal">name</code>, that must be a <code class="literal">numpy.str_</code> string with 16 characters. The second part, the <code class="literal">grades</code>, is a subarray of dimension 2 with scores as 64-bit floating point values. A valid array with elements in this datatype would then look like the following:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; MA141=numpy.array([ ('Cleese', (7.0,8.0)), ('Gilliam',(9.0,10.0)) ], dtype=dt)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; MA141</strong></span>
</pre></div><p>The <a id="id58" class="indexterm"/>output is shown as follows (it depends on your Python version):</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>array([('Cleese', [7.0, 8.0]), ('Gilliam', [9.0, 10.0])],dtype=[('name', '&lt;U16'), ('grades', '&lt;f8', (2,))])</strong></span>
</pre></div></div>
<div class="section" title="Indexing and slicing arrays"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Indexing and slicing arrays</h1></div></div></div><p>There <a id="id59" class="indexterm"/>are two basic methods to access the data in a NumPy array; let's <a id="id60" class="indexterm"/>call that array for <code class="literal">A</code>. Both methods use the same syntax, <code class="literal">A[obj]</code>, where <code class="literal">obj</code> is a Python object that performs the selection. We are already familiar with the first method of accessing a single element. The second method is the subject of<a id="id61" class="indexterm"/> this section, namely <span class="strong"><strong>slicing</strong></span>. This concept is exactly what makes NumPy and SciPy so incredibly easy to manage.</p><p>The basic slice method is a Python object of the form <code class="literal">slice(start,stop,step)</code>, or in a more compact notation, <code class="literal">start:stop:step</code>. Initially, the three variables, <code class="literal">start</code>, <code class="literal">stop</code>, and <code class="literal">step</code> are non-negative integer values, with <code class="literal">start</code> less than or equal to <code class="literal">stop</code>. </p><p>This represents the sequence of indices <span class="emphasis"><em>k = start + (i * step)</em></span>, where <span class="emphasis"><em>k</em></span> runs from <code class="literal">start</code> to the largest integer <span class="emphasis"><em>k_max = start + step*int((stop-start)/step)</em></span>, or <span class="emphasis"><em>i </em></span>from <code class="literal">0</code> to the largest integer equal to <span class="emphasis"><em>int((stop - start) / step)</em></span>. When a slice method is invoked on any of the dimensions of <code class="literal">ndarray</code>, it selects all elements in that dimension indexed by the corresponding sequence of indices. The simple example next illustrates this point:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; A=numpy.array([[1,2,3,4,5,6,7,8],[2,4,6,8,10,12,14,16]])</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print (A[0:2, 0:8:2])</strong></span>
</pre></div><p>The output is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>[[ 1  3  5  7]</strong></span>
<span class="strong"><strong> [ 2  6 10 14]]</strong></span>
</pre></div><p>If <code class="literal">start</code> is greater than <code class="literal">stop</code>, a negative value of <code class="literal">step</code> is used to traverse the sequence backwards:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; print (A[0:2, 8:0:-2])</strong></span>
</pre></div><p>The output is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>[[ 8,  6,  4,  2]</strong></span>
<span class="strong"><strong> [16, 12,  8,  4]]</strong></span>
</pre></div><p>Negative values of <code class="literal">start</code> and <code class="literal">stop</code> are interpreted as <code class="literal">n-start</code> and <code class="literal">n-stop</code> (respectively), where <code class="literal">n</code> is the size of the corresponding dimension. The <code class="literal">A[0:2,-1:0:-2]</code> command gives exactly the same output as the previous example.</p><p>The slice <a id="id62" class="indexterm"/>objects can be shortened by the absence of <code class="literal">start</code> (which implies<a id="id63" class="indexterm"/> a zero if <code class="literal">step</code> is positive, or the size of the dimension if <code class="literal">step</code> is negative), absence of <code class="literal">stop</code> (which implies the size of the corresponding dimension in case of positive <code class="literal">step</code>, or zero in case of negative <code class="literal">step</code>). Absence of <code class="literal">step</code> implies <code class="literal">step</code> is equal to 1. The <code class="literal">::</code> object can be shortened simply as <code class="literal">:</code> for an easier syntax. The <code class="literal">A[:,::-2]</code> command then offers, yet again, the same output as the previous two.</p><p>The first nonbasic method of accessing data from an array is based on the idea of collecting several indices and requesting the elements in the array with those indices. For example, from our previous array <code class="literal">A</code>, we would like to construct a new array with the elements on locations (0, 0), (0, 3), (1, 2), and (1, 5). We do so by gathering the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> values of the indices in respective lists, <code class="literal">[0,0,1,1]</code> and <code class="literal">[0,3,2,5]</code>, and feeding these lists to <code class="literal">A</code> as an indexing object, as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; print (A[ [0,0,1,1], [0,3,2,5] ])</strong></span>
</pre></div><p>The output is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>[ 1  4  6 12]</strong></span>
</pre></div><p>Note how the result loses the dimension of the primitive array, and offers a one-dimensional array. If we desire to capture a subarray of <code class="literal">A</code> with indices in the <span class="strong"><strong>Cartesian</strong></span> product of two sets of indices, respecting the row and column choice and creating a new array with the dimensions of the Cartesian product, we use the <code class="literal">ix_</code> command. For instance, if in our previous array we would like to obtain the subarray of dimension 2 x 2 with indices in the Cartesian product of indices (0, 1) by (0,3) (these are the locations (0, 0), (0, 3), (1, 0), and (1, 3), we do so as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; print (A[ numpy.ix_( [0,1], [0,3] )])</strong></span>
</pre></div><p>The output is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>[[1 4]</strong></span>
<span class="strong"><strong> [2 8]]</strong></span>
</pre></div></div>
<div class="section" title="The array object"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>The array object</h1></div></div></div><p>At this<a id="id64" class="indexterm"/> point, we are ready for a thorough study of all interesting attributes of <code class="literal">ndarray</code> for scientific computing purposes. We have already covered a few, such as <code class="literal">dtype</code>, <code class="literal">shape</code>, and <code class="literal">size</code>. Other useful attributes are <code class="literal">ndim</code> (to compute the number of dimensions in the array), <code class="literal">real</code>, and <code class="literal">imag</code> (to obtain the real and imaginary parts of the data, should this be formed by complex numbers) or <code class="literal">flat</code> (which creates a one-dimensional indexable iterator from the data).</p><p>For instance, if we desired to add all the values of an array together, we could use the <code class="literal">flat</code> attribute to run over all the elements sequentially, and accumulate all the values in a variable. A possible code to perform this task should look like the following code snippet (compare this code with the <code class="literal">ndarray.sum()</code> method, which will be explained in object calculation ahead):</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; value=0; import scipy.misc; img=scipy.misc.lena()</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; for item in img.flat: value+=item</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; value</strong></span>
</pre></div><p>The output is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>32518120</strong></span>
</pre></div><p>We will <a id="id65" class="indexterm"/>also explore some of the methods applied to arrays. These are tools used to modify objects; let it be their datatypes, their shape, or their structure through conversion. These methods can be classified in three big categories—<span class="strong"><strong>array</strong></span> <span class="strong"><strong>conversion</strong></span>, <span class="strong"><strong>shape</strong></span> <span class="strong"><strong>selection</strong></span>/<span class="strong"><strong>manipulation</strong></span>, and <span class="strong"><strong>object calculation</strong></span>.</p><div class="section" title="Array conversions"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec12"/>Array conversions</h2></div></div></div><p>The <code class="literal">astype()</code> method returns a copy of the array converted to a specific type; the <code class="literal">copy</code> method<a id="id66" class="indexterm"/> returns a copy of the array. Finally, the <code class="literal">tofile()</code>, <code class="literal">tolist()</code>, or <code class="literal">tostring()</code> method writes the binary data of the array into a file, returns <a id="id67" class="indexterm"/>a hierarchical python list version of the same array, or returns a string representation of the array data.</p><p>For instance, to write the contents of the <code class="literal">img</code> array to a text file making sure that each entry of the array is printed as an integer and that every two integers are separated by a white space, we can issue the following command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; img.tofile("lena.txt",sep=" ",format="%i")</strong></span>
</pre></div><p>Note how the formatting string follows the C language conventions.</p></div><div class="section" title="Shape selection/manipulations"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec13"/>Shape selection/manipulations</h2></div></div></div><p>These <a id="id68" class="indexterm"/>are used not only when we need to rearrange (<code class="literal">swapaxes</code> and <code class="literal">transpose</code>) or sort (<code class="literal">argsort</code> and <code class="literal">sort</code>) an array, but also when we need to reshape (<code class="literal">reshape</code>), resize (<code class="literal">flatten</code>, <code class="literal">ravel</code>, <code class="literal">resize</code>, and <code class="literal">squeeze</code>), or select (<code class="literal">choose</code>, <code class="literal">compress</code>, <code class="literal">diagonal</code>, <code class="literal">nonzero</code>, <code class="literal">searchsorted</code>, and <code class="literal">take</code>) arrays. Note that these methods are very powerful when combined with slicing operations; as a matter of fact, many of them can replace slicing to offer more readability.</p><p>We need to say a word about the attributes <code class="literal">flat</code>, <code class="literal">ravel</code>, and <code class="literal">flatten</code>, which offer very similar outputs, but very different memory management. The first attribute, <code class="literal">flat</code>, creates an iterator over an array. Once used, it disappears from memory. The attribute <code class="literal">ravel</code> returns a one-dimensional flattened array of the input; a copy is made only if needed. Finally, <code class="literal">flatten</code> creates a one-dimensional array of the input, and always allocates memory for it. We use it only when we need to change the values of flattened arrays. We will highlight the power of the sorting methods in the following code snippets. When sorting an array of integers, what would be the order of their indices? We may obtain this information with the <code class="literal">argsort()</code> method. We may even impose which sorting algorithm is to be<a id="id69" class="indexterm"/> used (rather than coding it ourselves)—<code class="literal">quicksort</code>, <code class="literal">mergesort</code>, or <code class="literal">heapsort</code>. We <a id="id70" class="indexterm"/>can even sort the array in place, using the <code class="literal">sort()</code> method. Let's take a look at the following set of commands:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; import numpy</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; A = numpy.array([11,13,15,17,19,18,16,14,12,10])</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; A.argsort(kind='mergesort')</strong></span>
</pre></div><p>The output is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>array([9, 0, 8, 1, 7, 2, 6, 3, 5, 4])</strong></span>
</pre></div><p>Now, we apply the <code class="literal">sort()</code> method:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; A.sort()</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print(A)</strong></span>
</pre></div><p>The output is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>[10 11 12 13 14 15 16 17 18 19]</strong></span>
</pre></div></div><div class="section" title="Object calculations"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec14"/>Object calculations</h2></div></div></div><p>Array <a id="id71" class="indexterm"/>calculation methods are used to perform computations <a id="id72" class="indexterm"/>or extract information from our data. Python supplies a range of statistical methods to compute, for instance, maximum and minimum values of the data (<code class="literal">max</code> and <code class="literal">min</code>) with their corresponding indices (<code class="literal">argmax</code> and <code class="literal">argmin</code>) methods to compute the sum, cumulative sums, product, or cumulative products (<code class="literal">sum</code>, <code class="literal">cumsum</code>, <code class="literal">prod</code>, and <code class="literal">cumprod</code>), and to calculate the average (<code class="literal">mean</code>), point spread (<code class="literal">ptp</code>), variance (<code class="literal">var</code>), and standard deviation (<code class="literal">std</code>) of our data. Other methods allow us to compute complex conjugate of complex-valued arrays (<code class="literal">conj</code>), the trace of the array (<code class="literal">trace</code>, which is the sum of the elements in the diagonal), and even clipping the matrix (<code class="literal">clip</code>) by forcing a minimum and maximum value below and above certain thresholds.</p><p>Note, that most of these methods can act on the entire array and each of their dimension:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; A=numpy.array([[1,1,1],[2,2,2],[3,3,3]])</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; A.mean()</strong></span>
</pre></div><p>The output is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>2</strong></span>
</pre></div><p>Now, let's apply the <code class="literal">mean()</code> method with <code class="literal">axis=0</code>:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; A.mean(axis=0)</strong></span>
</pre></div><p>The output is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>array([ 2.,  2.,  2.])</strong></span>
</pre></div><p>Similarly, we perform the same command with <code class="literal">axis=1</code>:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; A.mean(axis=1)</strong></span>
</pre></div><p>The output is shown as:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>array([ 1.,  2.,  3.])</strong></span>
</pre></div><p>Let's also<a id="id73" class="indexterm"/> illustrate the <code class="literal">clip</code> command with an easy exercise <a id="id74" class="indexterm"/>based on the Lena image. Compute the maximum and minimum values of Lena (<code class="literal">img</code>), and contrast them with the point spread (it should be equal to the difference between those two values). Now, create a new array <code class="literal">A</code> by clipping Lena so that the minimum is maintained, but the point spread is reduced to only 100 values. Let's illustrate the effect of <code class="literal">min()</code>, <code class="literal">max()</code>, and <code class="literal">ptp()</code> commands on Lena (<code class="literal">img</code>):</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; img.min(), img.max(), img.ptp()</strong></span>
</pre></div><p>The output is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>(25, 245, 220)</strong></span>
</pre></div><p>Further, we illustrate the effect of <code class="literal">clip()</code> command on <code class="literal">img</code> in the following lines of code:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; A=img.clip(img.min(),img.min()+100)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; A.min(), A.max(), A.ptp()</strong></span>
</pre></div><p>The output is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>(25, 125, 100)</strong></span>
</pre></div></div></div>
<div class="section" title="Array routines"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Array routines</h1></div></div></div><p>In this <a id="id75" class="indexterm"/>section, we will deal with most operations on arrays. We will classify them into four main categories:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Routines to create new arrays</li><li class="listitem" style="list-style-type: disc">Routines to manipulate a single array</li><li class="listitem" style="list-style-type: disc">Routines to combine two or more arrays</li><li class="listitem" style="list-style-type: disc">Routines to extract information from arrays</li></ul></div><p>The reader will surely realize that some operations of this kind can be carried out by methods, which once again shows the flexibility of Python and NumPy.</p><div class="section" title="Routines to create arrays"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec15"/>Routines to create arrays</h2></div></div></div><p>We <a id="id76" class="indexterm"/>have previously seen the command to create <a id="id77" class="indexterm"/>an array and store it to a variable <code class="literal">A</code>. Let's take a look at it again:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; A=numpy.array([[1,2],[2,1]])</strong></span>
</pre></div><p>The complete syntax, however, writes as follows:</p><div class="informalexample"><pre class="programlisting">array(object,dtype=None,copy=True,order=None, subok=False,ndim=0)</pre></div><p>Let's go over the options: <code class="literal">object</code> is simply the data we use to initialize the array. In the previous example, the object is a 2 x 2 square matrix; we may impose a datatype with the <code class="literal">dtype</code> option. The result is stored in the variable <code class="literal">A</code>. If <code class="literal">copy</code> is <code class="literal">True</code>, the returned object will be a copy of the array, if <code class="literal">False</code>, the returned object will only be a copy, if <code class="literal">dtype</code> is different from the datatype of <code class="literal">object</code>. The arrays are stored following a C-style ordering of rows and columns. If the user prefers to store the array following the memory style of FORTRAN, the <code class="literal">order='Fortran'</code> option should be used. The <code class="literal">subok</code> option is very subtle; if <code class="literal">True</code>, the array may be passed as a subclass of the object, if <code class="literal">False</code>, then only <code class="literal">ndarray</code> arrays are passed. And finally, the <code class="literal">ndmin</code> option indicates the smallest dimension returned by the array. If not offered, this is computed from <code class="literal">object</code>.</p><p>A set of special arrays can be obtained with commands such as <code class="literal">zeros</code>, <code class="literal">ones</code>, <code class="literal">empty</code>, <code class="literal">identity</code>, and <code class="literal">eye</code>. The names of these commands are quite informative:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">zeros</code> creates<a id="id78" class="indexterm"/> an array filled with zeros.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ones</code> creates<a id="id79" class="indexterm"/> an array filled with ones.</li><li class="listitem" style="list-style-type: disc"><code class="literal">empty</code> returns<a id="id80" class="indexterm"/> an array of required shape without initializing its entries.</li><li class="listitem" style="list-style-type: disc"><code class="literal">identity</code> creates <a id="id81" class="indexterm"/>a square matrix with dimensions indicated by a single positive integer <span class="emphasis"><em>n</em></span>. The entries are filled with zeros, except the diagonal, which is filled with ones.</li></ul></div><p>The <code class="literal">eye</code> command is very similar to <code class="literal">identity</code>. It also constructs diagonal arrays, but unlike <code class="literal">identity</code>, <code class="literal">eye</code> allows specifying diagonals offset the traditional centered, as it can operate on rectangular arrays as well. In the following lines of code, we use zeros, ones, and identity commands:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; Z=numpy.zeros((5,5), dtype=int)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; U=numpy.ones((2,2), dtype=int)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; I=numpy.identity(3, dtype=int)</strong></span>
</pre></div><p>In the first two cases, we indicated the shape of the array (as a Python tuple of positive integers) and the optional datatype imposition.</p><p>The syntax for <code class="literal">eye</code> is as follows:</p><div class="informalexample"><pre class="programlisting">numpy.eye(N,M=None,k=0,dtype=float)</pre></div><p>The integers, <code class="literal">N</code> and <code class="literal">M</code> indicate the shape of the array, and the integer <code class="literal">k</code> indicates the index of the diagonal to populate. </p><p>An index <code class="literal">k=0</code> (the default) points to the traditional diagonal; a positive index refers to upper diagonals and negative to lower diagonals. To illustrate this<a id="id82" class="indexterm"/> point, the following example shows how to <a id="id83" class="indexterm"/>create a 4 x 4 sparse matrix with nonzero elements on the first upper and subdiagonals:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; D=numpy.eye(4,k=1) + numpy.eye(4,k=-1)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print (D)</strong></span>
</pre></div><p>The output is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>[[ 0.  1.  0.  0.]</strong></span>
<span class="strong"><strong> [ 1.  0.  1.  0.]</strong></span>
<span class="strong"><strong> [ 0.  1.  0.  1.]</strong></span>
<span class="strong"><strong> [ 0.  0.  1.  0.]]</strong></span>
</pre></div><p>Using the previous four commands together with basic slicing, it is possible to create even more complex arrays very simply. We propose the following challenge.</p><p>Use exclusively, the previous definitions of <code class="literal">U</code> and <code class="literal">I</code> together with an <code class="literal">eye</code> array. How would the reader create a 5 x 5 array <code class="literal">A</code> of values, type float with <span class="emphasis"><em>fives</em></span> at the four entries (0, 0), (0, 1), (1, 0), and (1, 1); <span class="emphasis"><em>sixes</em></span> along the remaining entries of the diagonal; and <span class="emphasis"><em>threes</em></span> in the two other corners ? The solution to this question can be addressed by issuing the following set of commands:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; A=3.0*(numpy.eye(5,k=4) + numpy.eye(5,k=-4))</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; A[0:2,0:2]=5*U; A[2:5,2:5]=6*I</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print (A)</strong></span>
</pre></div><p>The output is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>[[ 5.  5.  0.  0.  3.]</strong></span>
<span class="strong"><strong> [ 5.  5.  0.  0.  0.]</strong></span>
<span class="strong"><strong> [ 0.  0.  6.  0.  0.]</strong></span>
<span class="strong"><strong> [ 0.  0.  0.  6.  0.]</strong></span>
<span class="strong"><strong> [ 3.  0.  0.  0.  6.]]</strong></span>
</pre></div><p>The flexibility of creating an array in NumPy is even more clear using the <code class="literal">fromfunction</code> command. For instance, if we require a 4 x 4 array where each entry reflects the product of its indices, we may use the <code class="literal">lambda</code> function <code class="literal">(lambda i,j: i*j)</code> in the <code class="literal">fromfunction</code> command, as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; B=numpy.fromfunction( (lambda i,j: i*j), (4,4), dtype=int)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print (B)</strong></span>
</pre></div><p>The output is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>[[0 0 0 0]</strong></span>
<span class="strong"><strong> [0 1 2 3]</strong></span>
<span class="strong"><strong> [0 2 4 6]</strong></span>
<span class="strong"><strong> [0 3 6 9]]</strong></span>
</pre></div><p>A very important tool dealing with arrays is the concept of masking. <span class="strong"><strong>Masking</strong></span> is based on the idea of selecting or masking those indices for which their corresponding entries satisfy<a id="id84" class="indexterm"/> a given condition. For example, in the<a id="id85" class="indexterm"/> array <code class="literal">B</code> shown in the previous example, we can<a id="id86" class="indexterm"/> mask all zero-valued entries with the <code class="literal">B==0</code> command, as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; print (B==0)</strong></span>
</pre></div><p>The output is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>[[ True  True  True  True]</strong></span>
<span class="strong"><strong> [ True False False False]</strong></span>
<span class="strong"><strong> [ True False False False]</strong></span>
<span class="strong"><strong> [ True False False False]]</strong></span>
</pre></div><p>Now, how would the reader update <code class="literal">B</code> so that all zero's would be replaced by the sum of the squares of their corresponding indices?</p><p>Multiplying a mask by a second array of the same shape offers a new array in which each entry is either zero (if the corresponding entry in the mask is <code class="literal">False</code>), or the entry of the second array (if the corresponding entry in the mask is <code class="literal">True</code>):</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; B += numpy.fromfunction((lambda i,j:i*i+j*j), (4,4))*(B==0)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print (B)</strong></span>
</pre></div><p>The output is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>[[0 1 4 9]</strong></span>
<span class="strong"><strong> [1 1 2 3]</strong></span>
<span class="strong"><strong> [4 2 4 6]</strong></span>
<span class="strong"><strong> [9 3 6 9]]</strong></span>
</pre></div><p>Note that we have created a new array filled with Boolean values as the size of the original array and in each step. This isn't a big deal in these toy examples, but when handling large datasets, allocating too much memory could seriously slow down our computations and exhaust the memory of our system. Among the commands to create arrays, there are two in particular <code class="literal">putmask</code> and <code class="literal">where</code>, which facilitate the management of resources internally, thus speeding up the process.</p><p>Note, for example, when we look for all odd-valued entries in <code class="literal">B</code>, the resulting mask has size of 16, although the interesting entries are only eight:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; print (B%2!=0)</strong></span>
</pre></div><p>The output is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>[[False  True False  True]</strong></span>
<span class="strong"><strong> [ True  True False  True]</strong></span>
<span class="strong"><strong> [False False False False]</strong></span>
<span class="strong"><strong> [ True  True False  True]]</strong></span>
</pre></div><p>The <code class="literal">numpy.where()</code> command helps us gather those entries more efficiently. Let's take a look at the following command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; numpy.where(B%2!=0)</strong></span>
</pre></div><p>The <a id="id87" class="indexterm"/>output is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>(array([0, 0, 1, 1, 1, 3, 3, 3], dtype=int32),array([1, 3, 0, 1, 3, 0, 1, 3], dtype=int32))</strong></span>
</pre></div><p>If we <a id="id88" class="indexterm"/>desire to change those entries (all odd), to, say they are <span class="emphasis"><em>squares plus one</em></span>, we can use the <code class="literal">numpy.putmask()</code> command instead, and better manage the memory at the same time. The following is a sample code for the <code class="literal">numpy.putmask()</code> command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; numpy.putmask( B, B%2!=0, B**2+1)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print (B)</strong></span>
</pre></div><p>The output is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>[[ 0  2  4 82]</strong></span>
<span class="strong"><strong> [ 2  2  2 10]</strong></span>
<span class="strong"><strong> [ 4  2  4  6]</strong></span>
<span class="strong"><strong> [82 10  6 82]]</strong></span>
</pre></div><p>Note how the <code class="literal">putmask</code> procedure updates the values of <code class="literal">B</code>, without the explicit need to make a new assignment.</p><p>There are three additional commands that create arrays in the form of meshes. The <code class="literal">arange</code> and <code class="literal">linspace</code> commands create uniformly spaced values between two numbers. In <code class="literal">arange</code>, we specify the spacing between elements; in <code class="literal">linspace</code>, we specify the desired number of elements in the mesh. The <code class="literal">logspace</code> command creates uniformly spaced values in a logarithmic scale between the logarithms of two numbers to the base 10. The user could think of these outputs as the support of univariate functions.</p><p>The following is a sample code for the <code class="literal">numpy.arrange()</code> command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; L1=numpy.arange(-1,1,0.3)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print (L1)</strong></span>
</pre></div><p>The output for the preceding lines of code is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>[-1.  -0.7 -0.4 -0.1  0.2  0.5  0.8]</strong></span>
</pre></div><p>The following is a sample code for the <code class="literal">numpy.linspace()</code> command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; L2=numpy.linspace(-1,1,4)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print (L2)</strong></span>
</pre></div><p>The output is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>[-1.         -0.33333333  0.33333333  1.        ]</strong></span>
</pre></div><p>The following is an example for the <code class="literal">numpy.logspace()</code> command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; L3= numpy.logspace(-1,1,4)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print (L3)</strong></span>
</pre></div><p>The output for the preceding lines of code is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>[  0.1          0.46415888   2.15443469  10.        ]</strong></span>
</pre></div><p>Finally, <code class="literal">meshgrid</code>, <code class="literal">mgrid</code>, and <code class="literal">ogrid</code> create two two-dimensional arrays of dimensions <span class="emphasis"><em>n x m</em></span>, containing the elements of two given one-dimensional arrays of dimensions <span class="emphasis"><em>n</em></span> and <span class="emphasis"><em>m</em></span>. It accomplished this by repeating the values of each array as necessary. The user could think of these outputs as the support of functions of two variables.</p><p>The<a id="id89" class="indexterm"/> first of these routines, <code class="literal">meshgrid</code>, accepts<a id="id90" class="indexterm"/> only arrays as input. The other two routines, <code class="literal">mgrid</code> and <code class="literal">ogrid</code>, accept only indexing objects (for example, slices). The difference between these last two is a matter of memory allocation; while <code class="literal">mgrid</code> allocates full arrays with all the data, <code class="literal">ogrid</code> only creates enough sets so that the corresponding <code class="literal">mgrid</code> command could be obtained by a proper Cartesian product.</p><p>Let's take a look at the following <code class="literal">meshgrid</code> command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; print (numpy.meshgrid(L2,L3))</strong></span>
</pre></div><p>The output is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>(array([[-1.        , -0.33333333,  0.33333333,  1.        ],</strong></span>
<span class="strong"><strong>       [-1.        , -0.33333333,  0.33333333,  1.        ],</strong></span>
<span class="strong"><strong>       [-1.        , -0.33333333,  0.33333333,  1.        ],</strong></span>
<span class="strong"><strong>       [-1.        , -0.33333333,  0.33333333,  1.        ]]), array([[  </strong></span>
<span class="strong"><strong>0.1       ,   0.1       ,   0.1       ,   0.1       ],</strong></span>
<span class="strong"><strong>       [  0.46415888,   0.46415888,   0.46415888,   0.46415888],</strong></span>
<span class="strong"><strong>       [  2.15443469,   2.15443469,   2.15443469,   2.15443469],</strong></span>
<span class="strong"><strong>       [ 10.        ,  10.        ,  10.        ,  10.        ]]))</strong></span>
</pre></div><p>Let's take a look at the following <code class="literal">mgrid</code> command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; print (numpy.mgrid[0:5,0:5])</strong></span>
</pre></div><p>The output is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>[[[0 0 0 0 0]</strong></span>
<span class="strong"><strong>  [1 1 1 1 1]</strong></span>
<span class="strong"><strong>  [2 2 2 2 2]</strong></span>
<span class="strong"><strong>  [3 3 3 3 3]</strong></span>
<span class="strong"><strong>  [4 4 4 4 4]]</strong></span>

<span class="strong"><strong> [[0 1 2 3 4]</strong></span>
<span class="strong"><strong>  [0 1 2 3 4]</strong></span>
<span class="strong"><strong>  [0 1 2 3 4]</strong></span>
<span class="strong"><strong>  [0 1 2 3 4]</strong></span>
<span class="strong"><strong>  [0 1 2 3 4]]]</strong></span>
</pre></div><p>Let's take a look at the following <code class="literal">ogrid</code> command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; print (numpy.ogrid[0:5,0:5])</strong></span>
</pre></div><p>The output is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>[array([[0],</strong></span>
<span class="strong"><strong>       [1],</strong></span>
<span class="strong"><strong>       [2],</strong></span>
<span class="strong"><strong>       [3],</strong></span>
<span class="strong"><strong>       [4]]), array([[0, 1, 2, 3, 4]])]</strong></span>
</pre></div><p>We <a id="id91" class="indexterm"/>would like to finish the subsection on creations<a id="id92" class="indexterm"/> of arrays by showing one of the most useful routines for image processing and differential equations—the <code class="literal">tile</code> command. Its syntax is very simple, and is shown as follows:</p><div class="informalexample"><pre class="programlisting">tile(A, reps)</pre></div><p>This routine presents a very effective method of tiling an array <code class="literal">A</code> following some repetition pattern <code class="literal">reps</code> (a <code class="literal">tuple</code>, a <code class="literal">list</code>, or another <code class="literal">array</code>) to create larger arrays. The following checkerboards exercise shows its potential.</p><p>Start with two small binary arrays—<code class="literal">B=numpy.ones((3,3))</code> and <code class="literal">checker2by2=numpy.zeros((6,6))</code> and create a checkerboard using <code class="literal">tile</code> and as few operations as possible.</p><p>Let's perform some operations using these commands:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; checker2by2[0:3,0:3]=checker2by2[3:6,3:6]=B</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; numpy.tile(checker2by2,(4,4))</strong></span>
</pre></div><p>The output is too long to be shown here. Please refer to the <span class="emphasis"><em>How to open IPython Notebooks</em></span> section in <a class="link" href="ch01.html" title="Chapter 1. Introduction to SciPy">Chapter 1</a>, <span class="emphasis"><em>Introduction to SciPy</em></span>, to run the IPython Notebook corresponding to this chapter.</p></div><div class="section" title="Routines for the combination of two or more arrays"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Routines for the combination of two or more arrays</h2></div></div></div><p>On <a id="id93" class="indexterm"/>occasion, we need to combine<a id="id94" class="indexterm"/> the data of two or more arrays together to solve a specific problem. The core NumPy libraries contain extremely efficient routines to carry out these computations, and we urge the reader to get familiar with them. They are constructed with state-of-the-art algorithms, and they make sure that usage of memory is minimum and the complexity optimal. Most relevant are the routines that operate on arrays as if they were matrices. These include matrix products (<code class="literal">outer</code>, <code class="literal">inner</code>, <code class="literal">dot</code>, <code class="literal">vdot</code>, <code class="literal">tensordot</code>, <code class="literal">cross</code>, and <code class="literal">kron</code>), array correlations (<code class="literal">correlate</code> and <code class="literal">convolve</code>), array stacking (<code class="literal">concatenate</code>, <code class="literal">vstack</code>, <code class="literal">hstack</code>, <code class="literal">column_stack</code>, <code class="literal">row_stack</code>, and <code class="literal">dstack</code>), and array comparison (<code class="literal">allclose</code>).</p><p>If you are well-versed in linear algebra, you will surely enjoy the matrix products included in NumPy. We will postpone their usage and analysis until we cover the SciPy module on linear algebra in <a class="link" href="ch03.html" title="Chapter 3. SciPy for Linear Algebra">Chapter 3</a>, <span class="emphasis"><em>SciPy for Linear Algebra</em></span>.</p><p>An <a id="id95" class="indexterm"/>excellent use for correlation<a id="id96" class="indexterm"/> of arrays is basic pattern-matching. For instance, the image in the following example (the <code class="literal">text</code> array) contains an image of a paragraph extracted from the Wikipedia page about Don Quixote, while the second array, <code class="literal">letterE</code>, contains an image of the letter <span class="emphasis"><em>e</em></span>, which is actually a subarray obtained from the <code class="literal">text</code> array and represents the pattern to be matched.</p><p>First, we load the text image and performs some preprocessing on it in order to bring the image to the right format (as close as possible to the grayscale approximation) to have better performance on this naive approach of pattern matching. We do this by executing the following lines of code in a Python console:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; import scipy.ndimage</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; import numpy as np</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; import matplotlib.pyplot as plt</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; text = scipy.ndimage.imread('Chap_02_text_image.png')</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; text = np.mean(text.astype(float)/255,-1)*2-1</strong></span>
</pre></div><p>Second, the pattern for the letter <span class="emphasis"><em>e</em></span> is identified:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; letterE = text[37:53,275:291]</strong></span>
</pre></div><p>Next, a fraction of the maximum value of the correlation of both arrays offers the location of all the <span class="emphasis"><em>e</em></span> letters contained in the array <code class="literal">text</code>:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; corr = scipy.ndimage.correlate(text,letterE)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; eLocations = (corr &gt;= 0.95 * corr.max())</strong></span>
</pre></div><p>The positions in the image of the pattern found for <code class="literal">x</code> are as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; CorrLocIndex = np.where(eLocations==True)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; x=CorrLocIndex[1]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; x </strong></span>
</pre></div><p>The output is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>array([ 283,  514,  583,  681,  722,  881,  929, 1023,   64,  188,  452, </strong></span>
<span class="strong"><strong>        504,  892,  921, 1059, 1087, 1102, 1133,  118,  547,  690, 1066, </strong></span>
<span class="strong"><strong>       1110,  330,  363,  519,  671,  913,  951, 1119,  120,  292,  441, </strong></span>
<span class="strong"><strong>        516,  557,  602,  649,  688,  717,  747,  783,  813,  988, 1016, </strong></span>
<span class="strong"><strong>        250,  309,  505,  691,  769,  876,  904, 1057,  224,  289,  470, </strong></span>
<span class="strong"><strong>        596,  626,  780, 1027,  112,  151,  203,  468,  596,  751,  817, </strong></span>
<span class="strong"><strong>        867,  203,  273,  369,  560,  599,  888, 1111,  159,  221,  260, </strong></span>
<span class="strong"><strong>        352,  427,  861,  901, 1034, 1146,  325,  506,  558]) </strong></span>
</pre></div><p>The positions in the image of the found pattern for <code class="literal">y</code> are as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; y=CorrLocIndex[0] </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; y </strong></span>
</pre></div><p>The <a id="id97" class="indexterm"/>output is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>array([ 45,  45,  45,  45,  45,  45,  45,  45,  74,  74,  74,  74,  74, </strong></span>
<span class="strong"><strong>        74,  74,  74,  74,  74, 103, 103, 103, 103, 103, 132, 132, 132, </strong></span>
<span class="strong"><strong>       132, 132, 132, 132, 161, 161, 161, 161, 161, 161, 161, 161, 161, </strong></span>
<span class="strong"><strong>       161, 161, 161, 161, 161, 190, 190, 190, 190, 190, 190, 190, 190, </strong></span>
<span class="strong"><strong>       219, 219, 219, 219, 219, 219, 219, 248, 248, 248, 248, 248, 248, </strong></span>
<span class="strong"><strong>       248, 248, 277, 277, 277, 277, 277, 277, 277, 306, 306, 306, 306, </strong></span>
<span class="strong"><strong>       306, 306, 306, 306, 306, 335, 335, 335]) </strong></span>
</pre></div><p>There<a id="id98" class="indexterm"/> are 86 elements, which are in fact the total number of the occurrence of the letter <span class="emphasis"><em>e</em></span> in the text image, as can be verified by counting them. Whether the matching has been done correctly can be verified graphically, superposing each pair <code class="literal">(x,y)</code> of the pattern on the text image, as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; thefig=plt.figure()</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.subplot(211)</strong></span>
<span class="strong"><strong>&lt;matplotlib.axes._subplots.AxesSubplot object at 0x7fb9b2390110&gt;</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.imshow(text, cmap=plt.cm.gray, interpolation='nearest')</strong></span>
<span class="strong"><strong>&lt;matplotlib.image.AxesImage object at 0x7fb9b1f29410&gt;</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.axis('off')</strong></span>
</pre></div><p>The output for <code class="literal">plt.axis()</code> is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>(-0.5, 1199.5, 359.5, -0.5) </strong></span>
</pre></div><p>Now, let's move further in the code:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; plt.subplot(212) </strong></span>
<span class="strong"><strong>&lt;matplotlib.axes._subplots.AxesSubplot object at 0x7fb9b1f29890&gt;  </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.imshow(text, cmap=plt.cm.gray, interpolation='nearest') </strong></span>
<span class="strong"><strong>&lt;matplotlib.image.AxesImage object at 0x7fb9b1637e10&gt; </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.autoscale(False) </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.plot(x,y,'wo',markersize=10) </strong></span>
<span class="strong"><strong>[&lt;matplotlib.lines.Line2D object at 0x7fb9b1647290&gt;] </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.axis('off') </strong></span>
</pre></div><p>The output for <code class="literal">plt.axis()</code> is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>(-0.5, 1199.5, 359.5, -0.5) </strong></span>
</pre></div><p>Finally, in<a id="id99" class="indexterm"/> the following <code class="literal">show()</code> command, we display a figure that superposes each pair <code class="literal">(x,y)</code> of the pattern on the<a id="id100" class="indexterm"/> text image:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; plt.show() </strong></span>
</pre></div><p>This results in the following screenshot (the first image is the text and the next is the text where all occurrences of letter <span class="emphasis"><em>e</em></span> have been crossed out):</p><div class="mediaobject"><img src="graphics/7702OS_02_02.jpg" alt="Routines for the combination of two or more arrays"/></div><p>A few words about stacking operations; we have a basic concatenation routine, <code class="literal">concatenate</code>, which joins a sequence of arrays together along a pre-determined axis. Of course, all<a id="id101" class="indexterm"/> arrays in the sequence <a id="id102" class="indexterm"/>must have the same dimensions, otherwise it obviously doesn't work. The rest of the stack operations are syntactic sugar for special cases of <code class="literal">concatenate</code>—<code class="literal">vstack</code> to glue arrays vertically, <code class="literal">hstack</code> to glue arrays horizontally, <code class="literal">dstack</code> to glue arrays in the third dimension, and so on.</p><p>Another impressive set of routines are set operations. They allow the user to handle one-dimensional arrays as if they were sets and perform the Boolean operations of intersection (<code class="literal">intersect1d</code>), union (<code class="literal">union1d</code>), set difference (<code class="literal">setdiff1d</code>), and set exclusive or (<code class="literal">setxor1d</code>). The results of these set operations return sorted arrays. Note that it is also possible to test whether all the elements in one array belong to a second array (<code class="literal">in1d</code>).</p></div><div class="section" title="Routines for array manipulation"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec17"/>Routines for array manipulation</h2></div></div></div><p>There<a id="id103" class="indexterm"/> is a sequence of splitting routines, designed<a id="id104" class="indexterm"/> to break up arrays into smaller arrays, in any given dimension—<code class="literal">array_split</code>, <code class="literal">split</code> (both are basic splitting along the indicated axis), <code class="literal">hsplit</code> (horizontal split), <code class="literal">vsplit</code> (vertical split), and <code class="literal">dsplit</code> (in the third axis). Let's illustrate these with a simple example:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; import numpy </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; B = numpy.ones((3,3)) </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; checker2by2 = numpy.zeros((6,6)) </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; checker2by2[0:3,0:3] = checker2by2[3:6,3:6] = B </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print(checker2by2)</strong></span>
</pre></div><p>The output is shown as follows: </p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>[[ 1.  1.  1.  0.  0.  0.]</strong></span>
<span class="strong"><strong> [ 1.  1.  1.  0.  0.  0.]</strong></span>
<span class="strong"><strong> [ 1.  1.  1.  0.  0.  0.]</strong></span>
<span class="strong"><strong> [ 0.  0.  0.  1.  1.  1.]</strong></span>
<span class="strong"><strong> [ 0.  0.  0.  1.  1.  1.]</strong></span>
<span class="strong"><strong> [ 0.  0.  0.  1.  1.  1.]]</strong></span>
</pre></div><p>Now, let's perform the vertical split:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; numpy.vsplit(checker2by2,3)</strong></span>
</pre></div><p>The output is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>[array([[ 1.,  1.,  1.,  0.,  0.,  0.],</strong></span>
<span class="strong"><strong>       [ 1.,  1.,  1.,  0.,  0.,  0.]]),</strong></span>
<span class="strong"><strong> array([[ 1.,  1.,  1.,  0.,  0.,  0.],</strong></span>
<span class="strong"><strong>       [ 0.,  0.,  0.,  1.,  1.,  1.]]),</strong></span>
<span class="strong"><strong> array([[ 0.,  0.,  0.,  1.,  1.,  1.],</strong></span>
<span class="strong"><strong>       [ 0.,  0.,  0.,  1.,  1.,  1.]])]</strong></span>
</pre></div><p>Applying a Python function on an array <span class="emphasis"><em>usually</em></span> means applying the function to each element of the array. Note how the NumPy function <code class="literal">sin</code> works on an array, for example:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; a=numpy.array([-numpy.pi, numpy.pi])</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print (numpy.vstack((a, numpy.sin(a))))</strong></span>
</pre></div><p>The output is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>[[ -3.14159265e+00   3.14159265e+00]</strong></span>
<span class="strong"><strong> [ -1.22464680e-16   1.22464680e-16]]</strong></span>
</pre></div><p>Note that the <code class="literal">sin</code> function was computed on each element of the array.</p><p>This works provided the function has been properly vectorized (which is the case with <code class="literal">numpy.sin</code>). Notice the behavior with non-vectorized Python functions. Let's define such a function for computing, for each value of <code class="literal">x</code>, the maximum between <code class="literal">x</code> and 100 without using any routine from the NumPy libraries:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong># function max100</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; def max100(x):</strong></span>
<span class="strong"><strong>            return(x)</strong></span>
</pre></div><p>If we try to apply this function to the preceding array, the system raises an error, as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; max100(a)</strong></span>
</pre></div><p>The output is an error which is shown as:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()</strong></span>
</pre></div><p>We need to explicitly indicate to the system when we desire to apply one of our functions to arrays, as well as scalars. We do that with the <code class="literal">vectorize</code> routine, as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; numpy.vectorize(max100)(a)</strong></span>
</pre></div><p>The output is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>array([100, 100])</strong></span>
</pre></div><p>For our benefit, the NumPy libraries provide a great deal of already-vectorized mathematical functions. Some examples are <code class="literal">round_</code>, <code class="literal">fix</code> (to round the elements of an array to a desired number of decimal places), and <code class="literal">angle</code> (to provide the angle of the elements of an array, provided they are complex numbers) and any basic trigonometric (<code class="literal">sin</code>, <code class="literal">cos</code>, <code class="literal">tan</code>, <code class="literal">sic</code>), exponential (<code class="literal">exp</code>, <code class="literal">exp2</code>, <code class="literal">sinh</code>, <code class="literal">cosh</code>), and logarithmic functions (<code class="literal">log</code>, <code class="literal">log10</code>, <code class="literal">log2</code>).</p><p>We also have mathematical functions that treat the array as an output of multidimensional functions, and<a id="id105" class="indexterm"/> offer relevant computations. Some useful examples are <code class="literal">diff</code> (to emulate differentiation along any specified<a id="id106" class="indexterm"/> dimension, by performing discrete differences), <code class="literal">gradient</code> (to compute the gradient of the corresponding function), or <code class="literal">cov</code> (for the covariance of the array). </p><p>Sorting the whole array according to the values of the first axis is also possible with the <code class="literal">msort</code> and <code class="literal">sort_complex</code> routines.</p></div><div class="section" title="Routines to extract information from arrays"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Routines to extract information from arrays</h2></div></div></div><p>Most<a id="id107" class="indexterm"/> of the routines to extract information are statistical in nature, which include <code class="literal">average</code> (which acts exactly as the <code class="literal">mean</code> method), <code class="literal">median</code> (to compute the statistical median of the array on any of its dimensions, or the array as a whole), and computation of histograms (<code class="literal">histogram</code>, <code class="literal">histogram2d</code>, and <code class="literal">histogramdd</code>, depending on the dimensions of the array). The other important set of routines in this category deal with the concept of bins for arrays of dimension one. This is more easily explained by means of examples. Take the array <code class="literal">A=numpy.array([5,1,1,2,1,1,2,2,10,3,3,4,5])</code>, the <code class="literal">unique</code> command finds the unique values in the array and presents them as sorted:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; numpy.unique(A)</strong></span>
</pre></div><p>The output is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>array([ 1, 2, 3, 4, 5, 10])</strong></span>
</pre></div><p>For arrays such as <code class="literal">A</code>, in which all the entries are nonnegative integers, we can visualize the array <code class="literal">A</code> as a sequence of eleven bins labeled with numbers from 0 to 10 (the maximum value in the array). Each bin with label <span class="emphasis"><em>n</em></span> contains the number of <span class="emphasis"><em>n</em></span>'s in the array:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; numpy.bincount(A)</strong></span>
</pre></div><p>The output is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>array([0, 4, 3, 2, 1, 2, 0, 0, 0, 0, 1])</strong></span>
</pre></div><p>For arrays where some of the elements are not numbers (<code class="literal">nan</code>), NumPy has a set of routines that mimic methods to extract information, but disregard the conflicting elements—<code class="literal">nanmax</code>, <code class="literal">nanmin</code>, <code class="literal">nanargmax</code>, <code class="literal">nanargmin</code>, <code class="literal">nansum</code>, and so on:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; A=numpy.fromfunction((lambda i,j: (i+1)*(-1)**(i*j)), (4,4))</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print (A)</strong></span>
</pre></div><p>The output is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>[[ 1.  1.  1.  1.]</strong></span>
<span class="strong"><strong> [ 2. -2.  2. -2.]</strong></span>
<span class="strong"><strong> [ 3.  3.  3.  3.]</strong></span>
<span class="strong"><strong> [ 4. -4.  4. -4.]]</strong></span>
</pre></div><p>Let's see the effect of <code class="literal">log2</code> on array <code class="literal">A</code>:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; B=numpy.log2(A)</strong></span>
<span class="strong"><strong>__main__:1: RuntimeWarning: invalid value encountered in log2</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print (B)</strong></span>
</pre></div><p>The output is<a id="id108" class="indexterm"/> shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>[[ 0.         0.         0.         0.       ]</strong></span>
<span class="strong"><strong> [ 1.               nan  1.               nan]</strong></span>
<span class="strong"><strong> [ 1.5849625  1.5849625  1.5849625  1.5849625]</strong></span>
<span class="strong"><strong> [ 2.               nan  2.               nan]]</strong></span>
</pre></div><p>Let's take a look at the <code class="literal">sum</code> and <code class="literal">nansum</code> commands in the following line of code:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; numpy.sum(B), numpy.nansum(B)</strong></span>
</pre></div><p>The output is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>(nan, 12.339850002884624)</strong></span>
</pre></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Summary</h1></div></div></div><p>In this chapter, we have explored in depth the creation and basic manipulation of the object array used by SciPy, as an overview of the NumPy libraries. In particular, we have seen the principles of slicing and masking, which simplify the coding of algorithms to the point of transforming an otherwise unreadable sequence of loops and primitive commands into an intuitive and self-explanatory set of object calls and methods. You also learned that the nonbasic modules in NumPy are replicated as modules in SciPy itself. The chapter roughly followed the same structure as the official NumPy reference (which the reader can access at the SciPy pages <a class="ulink" href="http://docs.scipy.org/doc/numpy/reference/">http://docs.scipy.org/doc/numpy/reference/</a>). There are other good sources that cover NumPy with rigor, and we refer you to any of that material for a more detailed coverage of this topic.</p><p>In the next five chapters, we will be accessing the commands that make SciPy a powerful tool in numerical computing. The structure of those chapters is basically a reflection of the different SciPy modules structured in an order that allows building applications on top of each other.</p></div></body></html>