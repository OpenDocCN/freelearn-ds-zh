<html><head></head><body>
        

                            
                    <h1 class="header-title">Working with pgRouting</h1>
                
            
            
                
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Startup – Dijkstra routing</li>
<li>Loading data from OpenStreetMap and finding the shortest path using A*</li>
<li>Calculating the driving distance/service area</li>
<li>Calculating the driving distance with demographics</li>
<li>Extracting the centerlines of polygons</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>So far, we have used PostGIS as a vector and raster tool, using relatively simple relationships between objects and simple structures. In this chapter, we review an additional PostGIS-related extension: <strong>pgRouting</strong>. pgRouting allows us to interrogate graph structures in order to answer questions such as "What is the shortest route from where I am to where I am going?" This is an area that is heavily occupied by the existing web APIs (such as Google, Bing, MapQuest, and others) and services, but it can be better served by <em>rolling our own</em> services for many use cases. Which cases? It might be a good idea to create our own services in situations where we are trying to answer questions that aren't answered by the existing services; where the data available to us is better or more applicable; or where we need or want to avoid the terms of service conditions for these APIs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Startup – Dijkstra routing</h1>
                
            
            
                
<p>pgRouting is a separate extension used in addition to PostGIS, which is now available in the PostGIS bundle on the Application Stack Builder (recommended for Windows). It can also be downloaded and installed by DEB, RPM, and macOS X packages and Windows binaries available at <a href="http://pgrouting.org/download.html">http://pgrouting.org/download.html</a>.</p>
<p>For macOS users, it is recommended that you use the source packages available on Git (<a href="https://github.com/pgRouting/pgrouting/releases">https://github.com/pgRouting/pgrouting/releases</a>), and use CMake, available at <a href="https://cmake.org/download/">https://cmake.org/download/</a>, to make the installation build.</p>
<p>Packages for Linux Ubuntu users can be found at <a href="http://trac.osgeo.org/postgis/wiki/UsersWikiPostGIS22UbuntuPGSQL95Apt">http://trac.osgeo.org/postgis/wiki/UsersWikiPostGIS22UbuntuPGSQL95Apt</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>pgRouting doesn't deal well with nondefault schemas, so before we begin, we will set the schema in our user preferences using the following command:</p>
<pre><strong>ALTER ROLE me SET search_path TO chp06,public;</strong></pre>
<p>Next, we need to add the <kbd>pgrouting</kbd> extension to our database. If PostGIS is not already installed on the database, we'll need to add it as an extension as well:</p>
<pre><strong>CREATE EXTENSION postgis;</strong>
<strong>CREATE EXTENSION pgrouting;</strong></pre>
<p>We will start by loading a test dataset. You can get some really basic sample data from <a href="http://docs.pgrouting.org/latest/en/sampledata.html">http://docs.pgrouting.org/latest/en/sampledata.html</a>.</p>
<p>This sample data consists of a small grid of streets in which any functions can be run.</p>
<p>Then, run the create table and data insert scripts available at the dataset website. You should make adjustments to preserve the schema structure for <kbd>chp06</kbd>—for example:</p>
<pre><strong>CREATE TABLE chp06.edge_table (</strong><br/><strong>  id BIGSERIAL,</strong><br/><strong>  dir character varying,</strong><br/><strong>  source BIGINT,</strong><br/><strong>  target BIGINT,</strong><br/><strong>  cost FLOAT,</strong><br/><strong>  reverse_cost FLOAT,</strong><br/><strong>  capacity BIGINT,</strong><br/><strong>  reverse_capacity BIGINT,</strong><br/><strong>  category_id INTEGER,</strong><br/><strong>  reverse_category_id INTEGER,</strong><br/><strong>  x1 FLOAT,</strong><br/><strong>  y1 FLOAT,</strong><br/><strong>  x2 FLOAT,</strong><br/><strong>  y2 FLOAT,</strong><br/><strong>  the_geom geometry</strong><br/><strong>);</strong></pre>
<p>Now that the data is loaded, let's build topology on the table (if you haven't already done this during the data-load process):</p>
<pre><strong>SELECT pgr_createTopology('chp06.edge_table',0.001);</strong></pre>
<p>Building a topology creates a new node table—<kbd>chp06.edge_table_vertices_pgr</kbd>—for us to view. This table will aid us in developing queries.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Now that the data is loaded, we can run a quick test. We'll use a simple algorithm called Dijkstra to calculate the shortest path from node 5 to node 12.</p>
<p>Dijkstra's algorithm is an effective and simple routing algorithm that runs a search on all available paths from point A to point B in a network, also known as the <strong>graph structure</strong>. It is not the most efficient routing algorithm, but will always find the best route. For more information on Dijkstra's algorithm, refer to Wikipedia, which has a good explanation, with illustrations, at <a href="http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm</a>. The animation at <a href="http://en.wikipedia.org/wiki/File:Dijkstras_progress_animation.gif">http://en.wikipedia.org/wiki/File:Dijkstras_progress_animation.gif</a> is particularly helpful.</p>
<p>An important point to note is that the nodes created in pgRouting during the topology creation process are created unintentionally for some versions. This has been patched in future versions, but for some versions of pgRouting, this means that your node numbers will not be the same as those we use here in the book. View your data in an application to determine which nodes to use or whether you should use a k-nearest neighbors search for the node nearest to a static geographic point. See <a href="e708d3c0-02ba-49ec-aaa1-b65693dee5ed.xhtml">Chapter 11</a>, <em>Using Desktop Clients</em>, for more information on viewing PostGIS data and <a href="68182eea-7041-4488-9f05-188b0a493ba5.xhtml">Chapter 4</a>,  <em>Working with Vector Data – Advanced Recipes</em>, for approaches to finding the nearest node automatically:</p>
<pre><strong>SELECT * FROM pgr_dijkstra(</strong>
 <strong> 'SELECT id, source, target, cost</strong>
  <strong>FROM chp06.edge_table_vertices_pgr',</strong><strong> 2,</strong><strong> 9,</strong>
<strong>);</strong> </pre>
<p>The preceding query will result in the following:</p>
<div><strong><img src="img/fb6e007f-aa22-4b3f-9fe6-e7588dc042d7.png" style="width:42.17em;height:10.67em;"/></strong></div>
<p>When we ask for a route using Dijkstra and other routing algorithms, the result often comes in the following form:</p>
<ul>
<li><kbd>seq</kbd>: This returns the sequence number so we can maintain the order of the output</li>
<li><kbd>node</kbd>: This is the node ID</li>
<li><kbd>edge</kbd>: This is the edge ID</li>
<li><kbd>cost</kbd>: This is the cost for the route traversal (often, the distance)</li>
<li><kbd>agg_cost</kbd>: This is the aggregated cost for the route from the starting node</li>
</ul>
<p>For example, to get the geometry back, we need to rejoin the edge IDs with the original table. To make this approach work transparently, we will use the <kbd>WITH</kbd> common table expression to create a temporary table to which we will join our geometry:</p>
<pre><strong>WITH dijkstra AS (</strong><br/><strong>  SELECT pgr_dijkstra(</strong><br/><strong>    'SELECT id, source, target, cost, x1, x2, y1, y2</strong><br/><strong>    FROM chp06.edge_table', 2, 9</strong><br/><strong>  )</strong><br/><strong>)</strong><br/><strong>SELECT id, ST_AsText(the_geom)</strong><br/><strong>FROM chp06.edge_table et, dijkstra d</strong><br/><strong>WHERE et.id = (d.pgr_dijkstra).edge;</strong></pre>
<p>The preceding code will give the following output:</p>
<div><strong><img src="img/1d23b34b-b5eb-4c36-a988-79cb0fb39b1f.png" style="width:14.67em;height:7.83em;"/></strong></div>
<p>Congratulations! You have just completed a route in pgRouting. The following diagram illustrates this scenario:</p>
<div><img src="img/60b29bbe-fcaa-46e6-9992-76e19fb05d40.png" style="width:27.33em;height:27.08em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Loading data from OpenStreetMap and finding the shortest path using A*</h1>
                
            
            
                
<p>Test data is great for understanding how algorithms work, but the real data is often more interesting. A good source for real data worldwide is <strong>OpenStreetMap</strong> (<strong>OSM</strong>), a worldwide, accessible, wiki-style, geospatial dataset. What is wonderful about using OSM in conjunction with pgRouting is that it is inherently a topological model, meaning that it follows the same kinds of rules in its construction as we do in graph traversal within pgRouting. Because of the way editing and community participation works in OSM, it is often an equally good or better data source than commercial ones and is, of course, quite compatible with our open source model.</p>
<p>Another great feature is that there is free and open source software to ingest OSM data and import it into a routing database—<kbd>osm2pgrouting</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>It is recommended that you get the downloadable files from the example dataset that we have provided, available at <a href="http://www.packtpub.com/support">http://www.packtpub.com/support</a>. You will be using the XML OSM data. You can also get custom extracts directly from the web interface at <a href="http://www.openstreetmap.org/">http://www.openstreetmap.org/</a>or by using the overpass turbo interface to access OSM data (<a href="https://overpass-turbo.eu/">https://overpass-turbo.eu/</a>), but this could limit the area we would be able to extract.</p>
<p>Once we have the data, we need to unzip it using our favorite compression utility. Double-clicking on the file to unzip it will typically work on Windows and macOS machines. Two good utilities for unzipping on Linux are <kbd>bunzip2</kbd> and <kbd>zip</kbd>. What will remain is an XML extract of the data we want for routing. In our use case, we are downloading the data for the greater Cleveland area.</p>
<p>Now we need a utility for placing this data into a routable database. An example of one such tool is <kbd>osm2pgrouting</kbd>, which can be downloaded and compiled using the instructions at <a href="http://github.com/pgRouting/osm2pgrouting">http://github.com/pgRouting/osm2pgrouting</a>. Use CMake from <a href="https://cmake.org/download/">https://cmake.org/download/</a> to make the installation build in macOS. For Linux Ubuntu users there is an available package at <a href="https://packages.ubuntu.com/artful/osm2pgrouting">https://packages.ubuntu.com/artful/osm2pgrouting</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>When <kbd>osm2pgrouting</kbd> is run without anything set, the output shows us the options that are required and available to use with <kbd>osm2pgrouting</kbd>:</p>
<div><img src="img/e6584ad6-f42a-4618-869f-52d5d075c430.png" style="width:39.33em;height:35.08em;"/></div>
<p>To run the <kbd>osm2pgrouting</kbd> command, we have a small number of required parameters. Double-check the paths pointing to <kbd>mapconfig.xml</kbd> and <kbd>cleveland.osm</kbd> before running the following command:</p>
<pre><strong>osm2pgrouting --file cleveland.osm --conf /usr/share/osm2pgrouting/mapconfig.xml --dbname postgis_cookbook --user me --schema chp06 --host localhost --prefix cleveland_ --clean</strong></pre>
<p>Our dataset may be quite large, and could take some time to process and import—be patient. The end of the output should say something like the following:</p>
<div><img src="img/6c33f9d8-6827-4a6e-ae5d-88269e323bad.png" style="width:44.33em;height:36.00em;"/></div>
<p>Our new vector table, by default, is named <kbd>cleveland_ways</kbd>. If no <kbd>-prefix</kbd> flag was used, the table name would just be <kbd>ways</kbd>.</p>
<p>You should have the created following tables:</p>
<div><img src="img/e3055d46-dc72-432f-b043-06e109fa52ee.png" style="width:16.83em;height:16.17em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p><kbd>osm2pgrouting</kbd> is a powerful tool that handles a lot of the translation of OSM data into a format that can be used in pgRouting. In this case, it creates eight tables from our input file. Of those eight, we'll address the two primary tables: the <kbd>ways</kbd> table and the <kbd>nodes</kbd> table.</p>
<p>Our <kbd>ways</kbd> table is a table of the lines that represent all our streets, roads, and trails that are in OSM. The nodes table contains all the intersections. This helps us identify the beginning and end points for routing.</p>
<p>Let's apply an <em>A* ("A star")</em> routing approach to this problem.</p>
<div><em>A*</em> is an extension of Dijkstra's algorithm which uses a heuristic to speed up the search for the shortest path, at the cost of occasionally not finding the optimum route. See <a href="http://en.wikipedia.org/wiki/A*">http://en.wikipedia.org/wiki/A*</a> and <a href="http://en.wikipedia.org/wiki/File:Astar_progress_animation.gif">http://en.wikipedia.org/wiki/File:Astar_progress_animation.gif</a> for more information.</div>
<p>You will recognize the following syntax from Dijkstra:</p>
<pre><strong>WITH astar AS (</strong>
  <strong>SELECT * FROM pgr_astar(</strong>
    <strong>'SELECT gid AS id, source, target,</strong>
    <strong> length AS cost, x1, y1, x2, y2 <br/>     FROM chp06.cleveland_ways', </strong><strong>89475, </strong><strong>14584, </strong><strong>false</strong>
  <strong>)<br/></strong>
<strong>)<br/></strong>
<strong>SELECT </strong><strong>gid, </strong><strong>the_geom</strong>
<strong>FROM chp06.cleveland_ways w, astar a</strong>
<strong>WHERE w.gid = a.edge;</strong></pre>
<p>The following screenshot shows the results displayed on a map (map tiles by <em>Stamen Design, under CC BY 3.0</em>; data by <em>OpenStreetMap, under CC BY SA</em>):</p>
<div><img src="img/dc488ec7-e796-40fa-9241-0bb1c210d78d.png"/></div>
<p>Sample calculated route with pgRouting visualized in QGIS</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Calculating the driving distance/service area</h1>
                
            
            
                
<p>Driving distance (<kbd>pgr_drivingDistance</kbd>) is a query that calculates all nodes within the specified driving distance of a starting node. This is an optional function compiled with pgRouting; so if you compile pgRouting yourself, make sure that you enable it and include the CGAL library, an optional dependency for <kbd>pgr_drivingDistance</kbd>.</p>
<p>Driving distance is useful when <em>user sheds</em> are needed that give realistic driving distance estimates, for example, for all customers with five miles driving, biking, or walking distance. These estimates can be contrasted with buffering techniques, which assume no barrier to travelling and are useful for revealing the underlying structures of our transportation networks relative to individual locations.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We will load the same dataset that we used in the <em>Startup – Dijkstra routing</em> recipe. Refer to this recipe to import data.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>In the following example, we will look at all users within a distance of three units from our starting point—that is, a proposed bike shop at node 2:</p>
<pre><strong>SELECT * FROM pgr_drivingDistance(</strong><br/><strong>  'SELECT id, source, target, cost FROM chp06.edge_table',</strong><br/><strong>  2, 3</strong><br/><strong>);</strong></pre>
<p>The preceding command gives the following output:</p>
<div><img src="img/20daab54-0c5d-4db5-b929-b7eb6bcc2979.png"/></div>
<p>As usual, we just get a list from the <kbd>pgr_drivingDistance</kbd> table that, in this case, comprises sequence, node, edge cost, and aggregate cost. PgRouting, like PostGIS, gives us low-level functionality; we need to reconstruct what geometries we need from that low-level functionality. We can use that node ID to extract the geometries of all of our nodes by executing the following script:</p>
<pre><strong>WITH DD AS (</strong>
  <strong>SELECT * </strong><strong>FROM pgr_drivingDistance(</strong>
    <strong>'SELECT id, source, target, cost </strong>
    <strong>FROM chp06.edge_table', </strong><strong>2, </strong><strong>3</strong>
  <strong>)</strong>
<strong>)</strong>
    
<strong>SELECT ST_AsText(the_geom)</strong>
<strong>FROM chp06.edge_table_vertices_pgr w, DD d</strong>
<strong>WHERE w.id = d.node;</strong> </pre>
<p>The preceding command gives the following output:</p>
<div><img src="img/cc260d04-52fb-4d83-8b8f-45e3958351e4.png" style="width:7.67em;height:12.67em;"/></div>
<p>But the output seen is just a cluster of points. Normally, when we think of driving distance, we visualize a polygon. Fortunately, we have the <kbd>pgr_alphaShape</kbd> function that provides us that functionality. This function expects <kbd>id</kbd>, <kbd>x</kbd>, and <kbd>y</kbd> values for input, so we will first change our previous query to convert to <kbd>x</kbd> and <kbd>y</kbd> from the geometries in <kbd>edge_table_vertices_pgr</kbd>:</p>
<pre><strong>WITH DD AS (</strong>
  <strong>SELECT * </strong><strong>FROM pgr_drivingDistance(</strong>
    <strong>'SELECT id, source, target, cost FROM chp06.edge_table',</strong>
    <strong> 2, 3</strong>
  <strong>)</strong>
<strong>)</strong>
<strong>SELECT </strong><strong>id::integer, </strong><strong> ST_X(the_geom)::float AS x, </strong><strong>ST_Y(the_geom)::float AS y </strong>
<strong>FROM chp06.edge_table_vertices_pgr w, DD d</strong>
<strong>WHERE w.id = d.node;</strong></pre>
<p>The output is as follows:</p>
<div><img src="img/e6c051cc-4aeb-4127-8f5d-2406e1888ee4.png" style="width:22.17em;height:13.58em;"/></div>
<p>Now we can wrap the preceding script up in the <kbd>alphashape</kbd> function:</p>
<pre><strong>WITH alphashape AS (</strong>
  <strong>SELECT pgr_alphaShape('</strong>
    <strong>WITH DD AS (</strong>
    <strong>  SELECT * </strong><strong>FROM pgr_drivingDistance(</strong>
       <strong> ''SELECT id, source, target, cost </strong>
    <strong>    FROM chp06.edge_table'', </strong><strong>2, </strong><strong>3</strong>
    <strong>  )</strong>
    <strong>),</strong>
    <strong>dd_points AS(</strong>
    <strong>  SELECT id::integer, ST_X(the_geom)::float AS x, </strong>
    <strong>  ST_Y(the_geom)::float AS y</strong>
    <strong>  FROM chp06.edge_table_vertices_pgr w, DD d</strong>
    <strong>  WHERE w.id = d.node</strong>
    <strong>)</strong>
    <strong>SELECT * FROM dd_points</strong>
  <strong>')</strong>
<strong>),</strong>  </pre>
<p>So first, we will get our cluster of points. As we did earlier, we will explicitly convert the text to geometric points:</p>
<pre><strong>alphapoints AS (</strong>
  <strong>SELECT ST_MakePoint((pgr_alphashape).x, (pgr_alphashape).y) FROM alphashape</strong>
<strong>),</strong></pre>
<p>Now that we have points, we can create a line by connecting them:</p>
<pre><strong>alphaline AS (</strong>
  <strong>SELECT ST_Makeline(ST_MakePoint) FROM alphapoints</strong>
<strong>)</strong>
<strong>SELECT ST_MakePolygon(ST_AddPoint(ST_Makeline, ST_StartPoint(ST_Makeline))) FROM alphaline;</strong></pre>
<p>Finally, we construct the line as a polygon using <kbd>ST_MakePolygon</kbd>. This requires adding the start point by executing <kbd>ST_StartPoint</kbd> in order to properly close the polygon. The complete code is as follows:</p>
<pre><strong>WITH alphashape AS (</strong><br/><strong>  SELECT pgr_alphaShape('</strong><br/><strong>    WITH DD AS (</strong><br/><strong>      SELECT * FROM pgr_drivingDistance(</strong><br/><strong>        ''SELECT id, source, target, cost</strong><br/><strong>        FROM chp06.edge_table'', 2, 3</strong><br/><strong>      )</strong><br/><strong>    ),</strong><br/><strong>    dd_points AS(</strong><br/><strong>      SELECT id::integer, ST_X(the_geom)::float AS x,</strong><br/><strong>      ST_Y(the_geom)::float AS y</strong><br/><strong>      FROM chp06.edge_table_vertices_pgr w, DD d</strong><br/><strong>      WHERE w.id = d.node</strong><br/><strong>    )</strong><br/><strong>    SELECT * FROM dd_points</strong><br/><strong>  ')</strong><br/><strong>),</strong><br/><strong>alphapoints AS (</strong><br/><strong>  SELECT ST_MakePoint((pgr_alphashape).x,</strong><br/><strong>  (pgr_alphashape).y)</strong><br/><strong>  FROM alphashape</strong><br/><strong>),</strong><br/><strong>alphaline AS (</strong><br/><strong>  SELECT ST_Makeline(ST_MakePoint) FROM alphapoints</strong><br/><strong>)</strong><br/><strong>SELECT ST_MakePolygon(</strong><br/><strong>  ST_AddPoint(ST_Makeline, ST_StartPoint(ST_Makeline))</strong><br/><strong>)</strong><br/><strong>FROM alphaline;</strong></pre>
<p>Our first driving distance calculation can be better understood in the context of the following diagram, where we can reach nodes 9, 11, 13 from node 2 with a driving distance of 3:</p>
<div><img src="img/77d41e55-eeb2-45b5-b776-41efc1129e64.jpg" style="width:35.42em;height:34.75em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>The <em>Calculating the driving distance with demographics</em> recipe</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Calculating the driving distance with demographics</h1>
                
            
            
                
<p>In the <em>Using polygon overlays for proportional census estimates</em> recipe in <a href="dec6904b-477f-4c16-a90f-7563a36c4652.xhtml">Chapter 2</a>, <em>Structures That Work</em>, we employed a simple buffer around a trail alignment in conjunction with the census data to get estimates of what the demographics were of the people within walking distance of the trail, estimated as a mile long. The problem with this approach, of course, is that it assumes that it is an "as the crow flies" estimate. In reality, rivers, large roads, and roadless stretches serve as real barriers to people's movement through space. Using pgRouting's <kbd>pgr_drivingDistance</kbd> function, we can realistically simulate people's movement on the routable networks and get better estimates. For our use case, we'll keep the simulation a bit simpler than a trail alignment—we'll consider the demographics of a park facility, say, the Cleveland Metroparks Zoo, and potential bike users within 4 miles of it, which adds up approximately to a 15-minute bike ride.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>For our analysis, we will use the <kbd>proportional_sum</kbd> function from <a href="dec6904b-477f-4c16-a90f-7563a36c4652.xhtml">Chapter 2</a>, <em>Structures That Work</em>, so if you have not added this to your PostGIS tool belt, run the following commands:</p>
<pre><strong>CREATE OR REPLACE FUNCTION chp02.proportional_sum(geometry, geometry, numeric)</strong>
<strong>RETURNS numeric AS</strong>
<strong>$BODY$</strong>
<strong>SELECT $3 * areacalc FROM</strong>
<strong>(</strong>
  <strong>SELECT (ST_Area(ST_Intersection($1, $2))/ST_Area($2))::numeric AS areacalc</strong>
<strong>) AS areac</strong>
<strong>;</strong>
<strong>$BODY$</strong>
<strong>LANGUAGE sql VOLATILE;</strong></pre>
<p>The <kbd>proportional_sum</kbd> function will take our input geometry into account and the <kbd>count</kbd> value of the population and return an estimate of the proportional population.</p>
<p>Now we need to load our census data. Use the following command:</p>
<pre><strong>shp2pgsql -s 3734 -d -i -I -W LATIN1 -g the_geom census chp06.census | psql -U me -d postgis_cookbook -h localhost</strong></pre>
<p>Also, if you have not yet loaded the data mentioned in the <em>Loading data from OpenStreetMap and finding the shortest path A*</em> recipe, take the time to do so now.</p>
<p>Once all the data is entered, we can proceed with the analysis.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>The <kbd>pgr_drivingdistance</kbd> polygon we created is the first step in the demographic analysis. Refer to the <em>Driving distance/service area calculation</em> recipe if you need to familiarize yourself with its use. In this case, we'll consider the cycling distance. The nearest node to the Cleveland Metroparks Zoo is 24746, according to our loaded dataset; so we'll use that as the center point for our <kbd>pgr_drivingdistance</kbd> calculation and we'll use approximately 6 kilometers as our distance, as we want to know the number of zoo visitors within this distance of the Cleveland Metroparks Zoo. However, since our data is using 4326 EPSG, the distance we will give the function will be in degrees, so 0.05 will give us an approximate distance of 6 km that will work with the <kbd>pgr_drivingDistance</kbd> function:</p>
<pre><strong>CREATE TABLE chp06.zoo_bikezone AS (</strong>
  <strong>WITH alphashape AS (</strong>
    <strong>SELECT pgr_alphaShape('</strong>
    <strong>  WITH DD AS (</strong>
    <strong>    SELECT * </strong><strong>FROM pgr_drivingDistance(</strong>
    <strong>      ''SELECT gid AS id, source, target, reverse_cost <br/>          AS cost FROM chp06.cleveland_ways'',</strong>
         <strong> 24746, 0.05, false</strong>
    <strong>    )</strong>
    <strong>  ),</strong>
     <strong> dd_points AS(</strong>
       <strong> SELECT id::int4, ST_X(the_geom)::float8 as x, <br/>          ST_Y(the_geom)::float8 AS y</strong>
    <strong>    FROM chp06.cleveland_ways_vertices_pgr w, DD d</strong>
       <strong> WHERE w.id = d.node</strong>
    <strong>  )</strong>
    <strong>  SELECT * FROM dd_points</strong>
    <strong>')</strong>
  <strong>),</strong>
  <strong>alphapoints AS (</strong>
    <strong>SELECT ST_MakePoint((pgr_alphashape).x, (pgr_alphashape).y) <br/>    FROM alphashape</strong>
  <strong>),</strong>
  <strong>alphaline AS (</strong>
    <strong>SELECT ST_Makeline(ST_MakePoint) FROM alphapoints</strong>
  <strong>)</strong>
  <strong>SELECT 1 as id, ST_SetSRID(ST_MakePolygon(ST_AddPoint(ST_Makeline, ST_StartPoint(ST_Makeline))), 4326) AS the_geom FROM alphaline</strong>
<strong>);</strong>  </pre>
<p>The preceding script gives us a very interesting shape (map tiles by <em>Stamen Design, under CC BY 3.0</em>; data by <em>OpenStreetMap, under CC BY SA</em>). See the following screenshot:</p>
<div><img src="img/1663b115-c4ac-4372-b671-21349efd1837.jpg" style="width:46.67em;height:35.00em;"/></div>
<div><img src="img/eeb3d160-d7f7-4f11-bdb9-55653d832832.jpg" style="width:45.92em;height:34.42em;"/></div>
<p>In the previous screenshot, we can see the difference between the cycling distance across the real road network, shaded in blue, and the equivalent 4-mile buffer or as-the-crow-flies distance. Let's apply this to our demographic analysis using the following script:</p>
<pre><strong>SELECT ROUND(SUM(chp02.proportional_sum(<br/>  ST_Transform(a.the_geom,3734), b.the_geom, b.pop))) AS population <br/>FROM </strong><strong>Chp06.zoo_bikezone AS a, chp06.census as b</strong>
<strong>WHERE ST_Intersects(ST_Transform(a.the_geom, 3734), b.the_geom)</strong>
<strong>GROUP BY a.id;</strong></pre>
<p>The output is as follows:</p>
<div><img src="img/e4d7d9dd-e926-4266-86ca-0e3bc32f69ce.png" style="width:8.67em;height:4.83em;"/></div>
<pre><strong>(1 row)</strong></pre>
<p>So, how does the preceding output compare to what we would get if we look at the buffered distance?</p>
<pre><strong>SELECT ROUND(SUM(chp02.proportional_sum(<br/>  ST_Transform(a.the_geom,3734), b.the_geom, b.pop))) AS population </strong>
<strong>  FROM</strong><strong> (</strong><strong>SELECT </strong><strong>1 AS id, </strong><strong>ST_Buffer(ST_Transform(the_geom, 3734), 17000) <br/>    AS the_geom </strong>
<strong>  FROM chp06.cleveland_ways_vertices_pgr WHERE id = 24746</strong>
<strong>) AS a, </strong><strong> chp06.census as b</strong>
<strong>WHERE ST_Intersects(ST_Transform(a.the_geom, 3734), b.the_geom)</strong>
<strong>GROUP BY a.id;</strong></pre>
<div><strong><img src="img/be372de8-b81c-4f5c-9c50-3457da9f22b2.png" style="width:9.08em;height:5.00em;"/></strong></div>
<pre><strong>(1 row)</strong></pre>
<p>The preceding output shows a difference of more than 60,000 people. In other words, using a buffer overestimates the population compared to using <kbd>pgr_drivingdistance</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Extracting the centerlines of polygons</h1>
                
            
            
                
<p>In several recipes in <a href="68182eea-7041-4488-9f05-188b0a493ba5.xhtml">Chapter 4</a>, <em>Working with Vector Data – Advanced Recipes</em>, we explored extracting Voronoi polygons from sets of points. In this recipe, we'll use the Voronoi function employed in the <em>Using external scripts to embed new functionality to calculate Voronoi polygons</em> section to serve as the first step in extracting the centerline of a polygon. One could also use the <em>Using external scripts to embed new functionality to calculate Voronoi polygons—advanced</em> recipe, which would run faster on large datasets. For this recipe, we will use the simpler but slower approach.</p>
<p>One additional dependency is that we will be using the <kbd>chp02.polygon_to_line(geometry)</kbd> function from the <em>Normalizing internal overlays</em> recipe in <a href="dec6904b-477f-4c16-a90f-7563a36c4652.xhtml">Chapter 2</a>, <em>Structures That Work</em>.</p>
<p>What do we mean by the centerline of a polygon? Imagine a digitized stream flowing between its pair of banks, as shown in the following screenshot:</p>
<div><img src="img/f00a4afe-12be-4343-82aa-27ea584ad382.png" style="width:28.58em;height:35.17em;"/></div>
<p>If we wanted to find the center of this in order to model the water flow, we could extract it using a skeletonization approach, as shown in the following screenshot:</p>
<div><img src="img/d7e6ef05-b751-40dc-a57e-116bdbe080da.png" style="width:28.92em;height:35.58em;"/></div>
<p>The difficulty with skeletonization approaches, as we'll soon see, is that they are often subject to noise, which is something that natural features such as our stream make plenty of. This means that typical skeletonization, which could be done simply with a Voronoi approach, is therefore inherently inadequate for our purposes.</p>
<p>This brings us to the reason why skeletonization is included in this chapter. Routing is a way for us to simplify skeletons derived from the Voronoi method. It allows us to trace from one end of a major feature to the other and skip all the noise in between.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>As we will be using the Voronoi calculations from the <em>Calculating Voronoi Diagram</em> recipe in <a href="68182eea-7041-4488-9f05-188b0a493ba5.xhtml">Chapter 4</a>, <em>Working with Vector Data – Advanced Recipes</em>, you should refer to that recipe to prepare yourself for the functions used in this recipe.</p>
<p>We will use a stream dataset found in this book's source package under the hydrology folder. To load it, use the following command:</p>
<pre><strong>shp2pgsql -s 3734 -d -i -I -W LATIN1 -g the_geom ebrr_polygon chp06.voronoi_hydro | psql -U me -d postgis_cookbook</strong></pre>
<p>The streams we create will look as shown in the following screenshot:</p>
<div><img src="img/226e58e6-292d-4c14-80fe-86414225a226.png" style="width:15.75em;height:32.58em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>In order to perform the basic skeletonization, we'll calculate the Voronoi polygons on the nodes that make up the original stream polygon. By default, the edges of the Voronoi polygons find the line that demarcates the midpoint between points. We will leverage this tendency by treating our lines like points—adding extra points to the lines and then converting the lines to a point set. This approach, in combination with the Voronoi approach, will provide an initial estimate of the polygon's centerline.</p>
<p>We will add extra points to our input geometries using the <kbd>ST_Segmentize</kbd> function and then convert the geometries to points using <kbd>ST_DumpPoints</kbd>:</p>
<pre><strong>CREATE TABLE chp06.voronoi_points AS(</strong>
  <strong>SELECT (ST_DumpPoints(ST_Segmentize(the_geom, 5))).geom AS the_geom <br/>    FROM chp06.voronoi_hydro</strong>
  <strong>UNION ALL</strong>
  <strong>SELECT (ST_DumpPoints(ST_Extent(the_geom))).geom AS the_geom <br/>    FROM chp06.voronoi_hydro</strong>
<strong>)</strong></pre>
<p>The following screenshot shows our polygons as a set of points if we view it on a desktop GIS:</p>
<div><img src="img/cb567a7d-7c5e-4730-a771-716f88083209.png" style="width:41.33em;height:20.83em;"/></div>
<p>The set of points in the preceding screenshot is what we feed into our Voronoi calculation:</p>
<pre><strong>CREATE TABLE chp06.voronoi AS(</strong>
  <strong>SELECT (ST_Dump(</strong>
    <strong>ST_SetSRID(</strong>
     <strong> ST_VoronoiPolygons(points.the_geom),</strong>
    <strong>  3734))).geom as the_geom</strong>
<strong>FROM (</strong><strong>SELECT </strong><strong>ST_Collect(ST_SetSRID(the_geom, 3734)) as the_geom </strong><strong>FROM chp06.voronoi_points</strong><strong>) as points);</strong></pre>
<p>The following screenshot shows a Voronoi diagram derived from our points:</p>
<div><img src="img/98524ae2-9061-4745-bc65-6addf7a8db89.png" style="width:44.17em;height:22.25em;"/></div>
<p>If you look closely at the preceding screenshot, you will see the basic centerline displayed in our new data. Now we will take the first step toward extracting it. We should index our inputs and then intersect the Voronoi output with the original stream polygon in order to clean the data back to something reasonable. In the extraction process, we'll also extract the edges from the polygons and remove the edges along the original polygon in order to remove any excess lines before our routing step. This is implemented in the following script:</p>
<pre><strong>CREATE INDEX chp06_voronoi_geom_gist</strong>
<strong>ON chp06.voronoi</strong>
<strong>USING gist(the_geom);</strong>
    
<strong>DROP TABLE IF EXISTS voronoi_intersect;</strong>
    
<strong>CREATE TABLE chp06.voronoi_intersect AS </strong><strong>WITH vintersect AS (</strong>
  <strong>SELECT ST_Intersection(ST_SetSRID(ST_MakeValid(a.the_geom), 3734), <br/>  ST_MakeValid(b.the_geom)) AS the_geom <br/>  FROM </strong><strong>Chp06.voronoi a, chp06.voronoi_hydro b</strong>
  <strong>WHERE ST_Intersects(ST_SetSRID(a.the_geom, 3734), b.the_geom)</strong>
<strong>),</strong>
<strong>linework AS (</strong>
  <strong>SELECT chp02.polygon_to_line(the_geom) AS the_geom <br/>  FROM </strong><strong>vintersect</strong>
<strong>),</strong>
<strong>polylines AS (</strong>
  <strong>SELECT ((ST_Dump(ST_Union(lw.the_geom))).geom)<br/>    ::geometry(linestring, 3734) AS the_geom <br/>  FROM </strong><strong>linework AS lw</strong>
<strong>),</strong>
<strong>externalbounds AS (</strong>
  <strong>SELECT chp02.polygon_to_line(the_geom) AS the_geom <br/>  FROM </strong><strong>voronoi_hydro</strong>
<strong>)</strong>
    
<strong>SELECT (ST_Dump(ST_Union(p.the_geom))).geom <br/>  FROM </strong><strong>polylines p, externalbounds b <br/></strong><strong>  WHERE NOT ST_DWithin(p.the_geom, b.the_geom, 5)</strong><strong>;</strong></pre>
<p>Now we have a second-level approximatio of the skeleton (shown in the following screenshot). It is messy, but it starts to highlight the centerline that we seek:</p>
<div><img src="img/68de608f-7d5d-4709-a43f-48fa042db042.png" style="width:49.67em;height:25.00em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Now we are nearly ready for routing. The centerline calculation we have is a good approximation of a straight skeleton, but is still subject to the noisiness of the natural world. We'd like to eliminate that noisiness by choosing our features and emphasizing them through routing. First, we need to prepare the table to allow for routing calculations, as shown in the following commands:</p>
<pre><strong>ALTER TABLE chp06.voronoi_intersect ADD COLUMN gid serial;</strong>
<strong>ALTER TABLE chp06.voronoi_intersect ADD PRIMARY KEY (gid);</strong>
    
<strong>ALTER TABLE chp06.voronoi_intersect ADD COLUMN source integer;</strong>
<strong>ALTER TABLE chp06.voronoi_intersect ADD COLUMN target integer;</strong></pre>
<p>Then, to create a routable network from our skeleton, enter the following commands:</p>
<pre><strong>SELECT pgr_createTopology('voronoi_intersect', 0.001, 'the_geom', 'gid', 'source', 'target', 'true');</strong>
    
<strong>CREATE INDEX source_idx ON chp06.voronoi_intersect("source");</strong>
<strong>CREATE INDEX target_idx ON chp06.voronoi_intersect("target");</strong>
    
<strong>ALTER TABLE chp06.voronoi_intersect ADD COLUMN length double precision;</strong>
<strong>UPDATE chp06.voronoi_intersect SET length = ST_Length(the_geom);</strong>
    
<strong>ALTER TABLE chp06.voronoi_intersect ADD COLUMN reverse_cost double precision;</strong>
<strong>UPDATE chp06.voronoi_intersect SET reverse_cost = length;</strong></pre>
<p>Now we can route along the primary centerline of our polygon using the following commands:</p>
<pre><strong>CREATE TABLE chp06.voronoi_route AS</strong>
<strong>WITH dijkstra AS (</strong>
  <strong>SELECT * FROM pgr_dijkstra('SELECT gid AS id, source, target, </strong><strong>length <br/>    AS cost FROM chp06.voronoi_intersect', </strong><strong>10851, 3, </strong><strong>false)</strong>
<strong>)</strong>
    
<strong>SELECT gid, geom</strong>
<strong>FROM voronoi_intersect et, dijkstra d</strong>
<strong>WHERE et.gid = d.edge;</strong></pre>
<p>If we look at the detail of this routing, we see the following:</p>
<div><img src="img/6d461f56-bdcc-45a3-97f8-2bfc9ab985a6.png" style="width:21.50em;height:15.17em;"/></div>
<p>Now we can compare the original polygon with the trace of its centerline:</p>
<div><img src="img/99455e9d-a4f8-4256-b5ae-c8db0248139e.png" style="width:21.42em;height:21.67em;"/></div>
<p>The preceding screenshot shows the original geometry of the stream in contrast to our centerline or skeleton. It is an excellent output that vastly simplifies our input geometry while retaining its relevant features.</p>


            

            
        
    </body></html>