<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Introduction to ArcPy.Mapping"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Introduction to ArcPy.Mapping</h1></div></div></div><p>Creating maps<a id="id286" class="indexterm"/> is an art, one that can be learned through years of dedicated study of cartography. The visual display of information is both exciting and difficult, and can be a rewarding part of the daily workflow of geospatial professionals. Once the basics have been learned and mastered, cartographic output becomes a constant battle to produce more maps at a faster pace. ArcPy, once again, has a powerful solution: the <code class="literal">arcpy.mapping</code> module.</p><p>By allowing for the automatic manipulation of all map components, including the map window, the layers, the legend, and all text elements, <code class="literal">arcpy.mapping</code> makes creating, modifying, and outputting multiple maps fast and simple. Map book creation – another important skill for geospatial professionals, is also made easy using the module. In this chapter we will discuss some basic functionalities available through <code class="literal">arcpy.mapping</code> and use it to output a map book of bus stops and their surrounding census blocks.</p><p>This chapter will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Inspecting and updating Map Document (MXD) layer data sources</li><li class="listitem" style="list-style-type: disc">Exporting MXDs to PDF or other image formats</li><li class="listitem" style="list-style-type: disc">Adjusting map document elements</li></ul></div><div class="section" title="Using ArcPy with map documents"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec40"/>Using ArcPy with map documents</h1></div></div></div><p>Recognizing <a id="id287" class="indexterm"/>the limitations of the previous <code class="literal">arcgisscripting</code> module, ESRI designed the ArcPy module to not only work with data but also <a id="id288" class="indexterm"/>included the <code class="literal">arcpy.mapping</code> module to allow direct interaction with map documents (MXDs) and the layers they contain. This new module opened up a multitude of map automation possibilities. A script might aid in identifying broken layer links, update the data source of these layers, and apply new color schemes to layers. Another script might use a map template and create a set of maps, one from each feature class in a feature dataset. A third script could create a map book from an MXD, moving from cell to cell in a grid layer to output the pages of the book, or even calculating the coordinates on the fly. Dynamically created maps, based on data from a fresh analysis, can be outputted at the same time the data is produced. <code class="literal">Arcpy.mapping</code> moves the ArcPy module from helpful to instrumental, in any geospatial workflow.</p><p>To<a id="id289" class="indexterm"/> investigate the utility of the <code class="literal">arcpy.mapping</code> module, we'll need the help of an MXD template. I've prepared a map package<a id="id290" class="indexterm"/> containing the data and MXD that we will use for the exercises in this chapter. It includes the data from our San Francisco bus stop's analysis, which we will continue and extend to include maps.</p></div></div>
<div class="section" title="Inspecting and replacing layer sources"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec41"/>Inspecting and replacing layer sources</h1></div></div></div><p>The first<a id="id291" class="indexterm"/> and most important <code class="literal">arcpy.mapping</code> module use is<a id="id292" class="indexterm"/> to identify and fix the broken links between layers in a map document and their data sources. Layer symbology and GIS data storage are separated, meaning that layer data sources are often moved. <code class="literal">Arcpy.mapping</code> offers a quick solution, though imperfect.</p><p>This solution depends on a number of methods included in the <code class="literal">arcpy.mapping</code> module. First, we will need to identify the broken links, and then we will fix them. To identify the broken links we will use the <code class="literal">ListBrokenDataSources()</code> method included in <code class="literal">arcpy.mapping</code>.</p><p>The <code class="literal">ListBrokenDataSources()</code> method requires an MXD path to be passed to the <code class="literal">MapDocument()</code> method of <code class="literal">arcpy.mapping</code>. Once the map document object has been created, it is passed to the <code class="literal">ListBrokenDataSources()</code> method, and a list will be generated containing layer objects, one for each layer with a broken link. The layer objects have a number of properties available to them. Using these properties, let's print out the name and data source of each layer using the name and data source properties of each object:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>import arcpy</strong></span>
<span class="strong"><strong>mxdPath = 'C:\Projects\MXDs\Chapter8\BrokenLinks.mxd'</strong></span>
<span class="strong"><strong>mxdObject = arcpy.mapping.MapDocument(mxdPath)</strong></span>
<span class="strong"><strong>brokenLinks = arcpy.mapping.ListBrokenDataSources(mxdObject)</strong></span>
<span class="strong"><strong>for link in brokenLinks:</strong></span>
<span class="strong"><strong>    print link.name, link.dataSource</strong></span>
</pre></div><div class="section" title="Fixing the broken links"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec59"/>Fixing the broken links</h2></div></div></div><p>Now that <a id="id293" class="indexterm"/>we have identified the broken links, the next step <a id="id294" class="indexterm"/>is to fix them. In this case, it was revealed that the data sources should be in a folder called Data, but they are not contained within that folder. The script must then be stepped up to replace the data sources of each layer, so that they point at the actual location of the data source.</p><p>There are<a id="id295" class="indexterm"/> methods included in both layer objects and map<a id="id296" class="indexterm"/> document objects that can accomplish this next step. If all of the data sources for an MXD have been moved, it is better to use the MXD object and its methods to fix the sources. In the example MXD, the data sources have all been moved into a new folder called <code class="literal">NewData</code>, so we will employ the <code class="literal">findAndReplaceWorkspacePaths()</code> method to repair the links:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>oldPath = r'C:\Projects\MXDs\Data'</strong></span>
<span class="strong"><strong>newPath = r'C:\Projects'</strong></span>
<span class="strong"><strong>mxdObject.findAndReplaceWorkspacePaths(oldPath,newPath)</strong></span>
<span class="strong"><strong>mxdObject.save() </strong></span>
</pre></div><p>As long as the data sources are still in the same format (such that shapefiles are still shapefiles or feature classes are still feature classes), the <code class="literal">findAndReplaceWorkspacePaths()</code> method will work. If the data source types have been changed (such that, shapefiles are imported into a file geodatabase), the <code class="literal">replaceWorkspaces()</code> method will have to be used instead as it requires workspace type as a parameter:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>oldPath = r'C:\Projects\MXDs\Data'</strong></span>
<span class="strong"><strong>oldType = 'SHAPEFILE_WORKSPACE'</strong></span>
<span class="strong"><strong>newPath = r'C:\Projects'</strong></span>
<span class="strong"><strong>newType = 'FILEGDB_WORKSPACE'</strong></span>
<span class="strong"><strong>mxdObject.replaceWorkspaces(oldPath,oldType,newPath,newType)</strong></span>
<span class="strong"><strong>mxdObject.save()</strong></span>
</pre></div></div><div class="section" title="Fixing the links of individual layers"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec60"/>Fixing the links of individual layers</h2></div></div></div><p>If the <a id="id297" class="indexterm"/>individual layers do not share a data source, the <a id="id298" class="indexterm"/>layer objects will need to be adjusted using the <code class="literal">findAndReplaceWorkspacePath()</code> method available to layers. This method is similar to the method used previously, but it will only replace the data source of the layer object it is applied to instead of all of the layers. When combined with a dictionary, the layer data sources can be updated using the layer name property:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>import arcpy</strong></span>
<span class="strong"><strong>layerDic = {'Bus_Stops':[r'C:\Projects\OldDataPath', r'C:\Projects'],</strong></span>
<span class="strong"><strong>            'stclines_streets': [r'C:\Projects\OtherPath', r'C:\Projects']}</strong></span>
<span class="strong"><strong>mxdPath = r'C:\Projects\MXDs\Chapter8\BrokenLinks.mxd'</strong></span>
<span class="strong"><strong>mxdObject = arcpy.mapping.MapDocument(mxdPath)</strong></span>
<span class="strong"><strong>brokenLinks = arcpy.mapping.ListBrokenDataSources(mxdObject)</strong></span>
<span class="strong"><strong>for layer in brokenLinks:</strong></span>
<span class="strong"><strong>    oldPath, newPath = layerDic[layer.name]</strong></span>
<span class="strong"><strong>    layer.findAndReplaceWorkspacePath(oldPath, newPath )</strong></span>
<span class="strong"><strong>   mxdObject.save()</strong></span>
</pre></div><p>These<a id="id299" class="indexterm"/> solutions work well for individual map documents <a id="id300" class="indexterm"/>and layers. They can also be extended to folders full of MXDs by using the <code class="literal">glob.glob()</code> method of the built-in <code class="literal">glob</code> module (which helps to generate a list of files that match a certain file extension) and the <code class="literal">os.path.join()</code> method of the <code class="literal">os</code> module:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>import arcpy, glob, os</strong></span>
<span class="strong"><strong>oldPath = r'C:\Projects\MXDs\Data'</strong></span>
<span class="strong"><strong>newPath = r'C:\Projects'</strong></span>
<span class="strong"><strong>folderPath = r'C:\Projects\MXDs\Chapter8'</strong></span>
<span class="strong"><strong>mxdPathList = glob.glob(os.path.join(folderPath, '*.mxd'))</strong></span>
<span class="strong"><strong>for path in mxdPathList:   </strong></span>
<span class="strong"><strong>    mxdObject = arcpy.mapping.MapDocument(mxdPath)</strong></span>
<span class="strong"><strong>    mxdObject.findAndReplaceWorkspacePaths(oldPath,newPath)</strong></span>
<span class="strong"><strong>    mxdObject.save()</strong></span>
</pre></div></div><div class="section" title="Exporting to PDF from an MXD"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec61"/>Exporting to PDF from an MXD</h2></div></div></div><p>The next most important use of <code class="literal">arcpy.mapping</code> is to automatically export MXDs. The following code will highlight the export of PDFs, but note that the module also supports the export of JPEGs and other image formats. Using <code class="literal">arcpy.mapping</code> for this process is a joy, as the usual process of opening and exporting the MXDs involves a lot of waiting for ArcMap to start and the map to load, which can be a time sink:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>import arcpy, glob, os</strong></span>
<span class="strong"><strong>mxdFolder = r'C:\Projects\MXDs\Chapter8'</strong></span>
<span class="strong"><strong>pdfFolder = r'C:\Projects\PDFs\Chapter8'</strong></span>
<span class="strong"><strong>mxdPathList = glob.glob(os.path.join(mxdFolder, '*.mxd'))</strong></span>
<span class="strong"><strong>for mxdPath in mxdPathList:</strong></span>
<span class="strong"><strong>    mxdObject = arcpy.mapping.MapDocument(mxdPath)</strong></span>
<span class="strong"><strong>    arcpy.mapping.ExportToPDF(mxdObject,</strong></span>
<span class="strong"><strong>                              os.path.join(pdfFolder,</strong></span>
<span class="strong"><strong>                              basepath( </strong></span>
<span class="strong"><strong>             mxdPath.replace('mxd','pdf')</strong></span>
<span class="strong"><strong>             )))</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>Note that the output folder must exist for this code to run correctly. While there are <code class="literal">os</code> module methods to check whether a path exists (<code class="literal">os.path.exists</code>) and to create a folder (<code class="literal">os.mkdir</code>), that is not included in this code snippet and the <code class="literal">arcpy.mapping.ExportToPDF()</code> method will throw an exception if the input or output paths do not exist.</p></div></div><p>This<a id="id301" class="indexterm"/> example code is very useful and can be converted into<a id="id302" class="indexterm"/> a function that would accept the folder path as a parameter. The function could then be added to a script tool, as discussed in the last chapter.</p></div><div class="section" title="Adjusting map document elements"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec62"/>Adjusting map document elements</h2></div></div></div><p>
<code class="literal">Arcpy.mapping</code> includes important methods that will facilitate the automation of map document <a id="id303" class="indexterm"/>manipulation. These include the <a id="id304" class="indexterm"/>ability to add new layers or turn layers on and off within MXDs, the ability to adjust the scale of the data frame or move a data frame to focus on a specific region, and the ability to adjust text components of the map (such as titles or subtitles). These methods will be addressed as we continue our bus stop analysis.</p><p>Open up the MXD called <code class="literal">MapAdjust.mxd</code>. This represents our base map document, with layers and elements that we will adjust to our needs. It contains layers that we have generated from our analysis, and the base layers that fill out the map. There are also a number of text elements that will be automatically replaced by the script to fit the specific needs of each map. However, it does not do a good job of representing the results of the analysis as the census blocks that intersect the bus stop buffers overlap, making it hard to interpret the cartography.</p><p>The script will replace the data source of the census block layer and the bus stop layer to make it possible to only produce one map for each bus stop, and the census blocks that are intersected with each buffer surrounding the stops.</p><div class="mediaobject"><img src="graphics/8662OS_08_01.jpg" alt="Adjusting map document elements"/></div><p>To <a id="id305" class="indexterm"/>make this possible, we will have to create<a id="id306" class="indexterm"/> two empty feature classes: one, with all of the attributes of the census blocks, and the other, with the attributes of the bus stops. This will allow the data source to be replaced with the data produced by the analysis.</p><p>Open up the <code class="literal">SanFrancisco.gdb</code> File Geodatabase and right click on the <code class="literal">Chapter8Results</code> feature dataset. Select <span class="strong"><strong>New</strong></span> from the drop-down menu and then select <span class="strong"><strong>Feature Class. Name</strong></span> the first feature class <code class="literal">SelectedCensusBlocks</code> and make it a polygon. Select the <span class="strong"><strong>defaults keyword</strong></span> on the next menu, and then on the following menu, push the <span class="strong"><strong>import</strong></span> button. Select the <span class="strong"><strong>CensusBlocks</strong></span> feature class from the SanFrancisco feature dataset; this will load the fields into the new feature class. Do the same thing for a second feature class called <code class="literal">SelectedBusStops</code>, but make sure that it is a point geometry type and import the schema from the <code class="literal">BusStops</code> feature class. Repeat the same process for a third feature class called <code class="literal">SelectedStopBuffers</code>, but make sure that it is a point geometry type and import the schema from the <code class="literal">Buffers</code> feature class.</p><p>Once the feature classes have been created, it is now possible to use them to load the results<a id="id307" class="indexterm"/> of the analysis. We will be redoing the<a id="id308" class="indexterm"/> analysis in memory and writing out the results to the newly created feature classes, so that the entire census block will be captured, instead of only the portion that intersects with the buffer, as it will better illustrate the results of the analysis.</p><p>The initial state of the <code class="literal">MapAdjust.mxd</code> map document features a number of feature classes with which we are now familiar: the downloaded feature class <code class="literal">Bus_Stops</code>, the generated feature class Buffers, the intersected and clipped Census Blocks, and four feature classes used for cartographic purposes, namely the <span class="strong"><strong>Streets feature</strong></span> class, the <span class="strong"><strong>Parks feature</strong></span> class, a <span class="strong"><strong>Neighborhoods feature</strong></span> class, and an outline of <span class="strong"><strong>San Francisco</strong></span>. There are two data frames, one with the default name <span class="strong"><strong>Layers</strong></span> and another called <span class="strong"><strong>Inset</strong></span>, that are used to create the small inset that will show the position of the Layers data frame as it moves around San Francisco. The small rectangle that depicts the extent of the Layers data frame is an Extent frame created in the properties of the Inset data frame.</p><p>Here is an exported view of the initial state of the map document:</p><div class="mediaobject"><img src="graphics/8662OS_08_02.jpg" alt="Adjusting map document elements"/></div><p>The idea here, is to use the initial results of our analysis to generate the symbology of the population layer as well as the bus stop layer and the buffer layer. Once they have been set and <a id="id309" class="indexterm"/>saved, they can be used as a basis <a id="id310" class="indexterm"/>for the individual map pages that we will be producing from this basic map document.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>Note the text elements that make up the title and subtitle, as well as the legend and attribution text at the bottom of the right pane. These elements are available for adjustment along with the layers and data sources that make up the map document by using the <code class="literal">arcpy.mapping.ListElements()</code> method.</p></div></div></div></div>
<div class="section" title="Automated map document adjustment"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec42"/>Automated map document adjustment</h1></div></div></div><p>Now<a id="id311" class="indexterm"/> that we understand the initial configuration of the map document, we will introduce a script that will automate the adjustment. This script will include a number of  concepts that we have covered in this chapter and earlier chapters, and will also introduce some new methods for map document<a id="id312" class="indexterm"/> adjustments that we will detail in the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>import arcpy, os</strong></span>
<span class="strong"><strong>dirpath = os.path.dirname</strong></span>
<span class="strong"><strong>basepath = os.path.basename</strong></span>
<span class="strong"><strong>Bus_Stops = r"C:\Projects\SanFrancisco.gdb\Bus_Stops"</strong></span>
<span class="strong"><strong>selectedBusStop = r'C:\Projects\SanFrancisco.gdb\Chapter8Results\SelectedBusStop'</strong></span>
<span class="strong"><strong>selectedStopBuffer = r'C:\Projects\SanFrancisco.gdb\Chapter8Results\SelectedStopBuffer'</strong></span>
<span class="strong"><strong>CensusBlocks2010 = r"C:\Projects\SanFrancisco.gdb\CensusBlocks2010"</strong></span>
<span class="strong"><strong>selectedBlock = r'C:\Projects\SanFrancisco.gdb\Chapter8Results\SelectedCensusData'</strong></span>
<span class="strong"><strong>pdfFolder = r'C:\Projects\PDFs\Chapter8\Map_{0}'</strong></span>
<span class="strong"><strong>bufferDist = 400</strong></span>
<span class="strong"><strong>sql = "(NAME = '71 IB' AND BUS_SIGNAG = 'Ferry Plaza')"</strong></span>
<span class="strong"><strong>mxdObject = arcpy.mapping.MapDocument("CURRENT")</strong></span>
<span class="strong"><strong>dataFrame = arcpy.mapping.ListDataFrames(mxdObject, "Layers")[0]</strong></span>
<span class="strong"><strong>elements = arcpy.mapping.ListLayoutElements(mxdObject)</strong></span>
<span class="strong"><strong>for el in elements:</strong></span>
<span class="strong"><strong>    if el.type =="TEXT_ELEMENT":</strong></span>
<span class="strong"><strong>        if el.text == 'Title Element':</strong></span>
<span class="strong"><strong>            titleText = el</strong></span>
<span class="strong"><strong>        elif el.text == 'Subtitle Element':</strong></span>
<span class="strong"><strong>            subTitleText = el</strong></span>
<span class="strong"><strong>arcpy.MakeFeatureLayer_management(CensusBlocks2010, 'blocks_lyr')       </strong></span>
<span class="strong"><strong>layersList = arcpy.mapping.ListLayers(mxdObject,"",dataFrame)</strong></span>
<span class="strong"><strong>layerStops = layersList[0]</strong></span>
<span class="strong"><strong>layerCensus = layersList[1]</strong></span>
<span class="strong"><strong>layerBuffer = layersList[2]</strong></span>
<span class="strong"><strong>layerBlocks = layersList[3] </strong></span>
<span class="strong"><strong>if layerBlocks.dataSource != selectedBlock:</strong></span>
<span class="strong"><strong>    layerBlocks.replaceDataSource(dirpath(dirpath(layerBlocks.dataSource)),</strong></span>
<span class="strong"><strong>                                  'FILEGDB_WORKSPACE',basepath(selectedBlock))</strong></span>
<span class="strong"><strong>if layerStops.dataSource != selectedBusStop:</strong></span>
<span class="strong"><strong>    layerStops.replaceDataSource(dirpath(dirpath(layerStops.dataSource)),</strong></span>
<span class="strong"><strong>                                 'FILEGDB_WORKSPACE',basepath(selectedBusStop))</strong></span>
<span class="strong"><strong>if layerBuffer.dataSource != selectedStopBuffer:</strong></span>
<span class="strong"><strong>    layerBuffer.replaceDataSource(dirpath(dirpath(layerBuffer.dataSource)),</strong></span>
<span class="strong"><strong>                                  'FILEGDB_WORKSPACE',basepath(selectedStopBuffer))</strong></span>
<span class="strong"><strong>layerStops.visible = True</strong></span>
<span class="strong"><strong>layerBuffer.visible = True</strong></span>
<span class="strong"><strong>layerCensus.visible = False</strong></span>
<span class="strong"><strong>with arcpy.da.SearchCursor(Bus_Stops,['SHAPE@','STOPID','NAME',</strong></span>
<span class="strong"><strong>                                      'BUS_SIGNAG' ,'OID@','SHAPE@XY'],sql) as cursor:</strong></span>
<span class="strong"><strong>    for row in cursor:</strong></span>
<span class="strong"><strong>        stopPointGeometry = row[0]</strong></span>
<span class="strong"><strong>        stopBuffer = stopPointGeometry.buffer(bufferDist)</strong></span>
<span class="strong"><strong>        with arcpy.da.UpdateCursor(layerBlocks,['OID@']) as dcursor:</strong></span>
<span class="strong"><strong>            for drow in dcursor:</strong></span>
<span class="strong"><strong>                dcursor.deleteRow()</strong></span>
<span class="strong"><strong>        arcpy.SelectLayerByLocation_management('blocks_lyr', 'intersect', stopBuffer, "", "NEW_SELECTION")</strong></span>
<span class="strong"><strong>        with arcpy.da.SearchCursor('blocks_lyr',['SHAPE@','POP10','OID@']) as bcursor:</strong></span>
<span class="strong"><strong>            inCursor = arcpy.da.InsertCursor(selectedBlock,['SHAPE@','POP10'])</strong></span>
<span class="strong"><strong>            for drow in bcursor:                </strong></span>
<span class="strong"><strong>                data = drow[0],drow[1]</strong></span>
<span class="strong"><strong>                inCursor.insertRow(data)</strong></span>
<span class="strong"><strong>        del inCursor</strong></span>
<span class="strong"><strong>        with arcpy.da.UpdateCursor(selectedBusStop,['OID@']) as dcursor:</strong></span>
<span class="strong"><strong>            for drow in dcursor:</strong></span>
<span class="strong"><strong>                dcursor.deleteRow()</strong></span>
<span class="strong"><strong>        inBusStopCursor = arcpy.da.InsertCursor(selectedBusStop,['SHAPE@'])</strong></span>
<span class="strong"><strong>        data = [row[0]]</strong></span>
<span class="strong"><strong>        inBusStopCursor.insertRow(data)</strong></span>
<span class="strong"><strong>        del inBusStopCursor</strong></span>
<span class="strong"><strong>        with arcpy.da.UpdateCursor(selectedStopBuffer,['OID@']) as dcursor:</strong></span>
<span class="strong"><strong>            for drow in dcursor:</strong></span>
<span class="strong"><strong>                dcursor.deleteRow()</strong></span>
<span class="strong"><strong>        inBufferCursor = arcpy.da.InsertCursor(selectedStopBuffer,['SHAPE@'])</strong></span>
<span class="strong"><strong>        data = [stopBuffer]</strong></span>
<span class="strong"><strong>        inBufferCursor.insertRow(data)</strong></span>
<span class="strong"><strong>        del inBufferCursor</strong></span>
<span class="strong"><strong>        layerStops.name = "Stop #{0}".format(row[1])</strong></span>
<span class="strong"><strong>        arcpy.RefreshActiveView()</strong></span>
<span class="strong"><strong>        dataFrame.extent = arcpy.Extent(row[-1][0]-1200,row[-1][1]-1200,</strong></span>
<span class="strong"><strong>                                        row[-1][0]+1200,row[-1][1]-1200)</strong></span>
<span class="strong"><strong>        subTitleText.text = "Route {0}".format(row[2])</strong></span>
<span class="strong"><strong>        titleText.text = "Bus Stop {0}".format(row[1])</strong></span>
<span class="strong"><strong>        outPath  = pdfFolder.format( str(row[1])+ "_" + str(row[-2])) + '.pdf'</strong></span>
<span class="strong"><strong>        print outPath</strong></span>
<span class="strong"><strong>        arcpy.mapping.ExportToPDF(mxdObject,outPath)</strong></span>
<span class="strong"><strong>        titleText.text = 'Title Element'</strong></span>
<span class="strong"><strong>        subTitleText.text = 'Subtitle Element'</strong></span>
<span class="strong"><strong>        arcpy.RefreshActiveView()</strong></span>
</pre></div><p>Wow! That's a lot of code. Let's review it section by section to address what each part of the script is doing.</p><p>This<a id="id313" class="indexterm"/> code will be run in the Python Window of the MXD, so make sure to open the MXD. Once it is, open the <span class="strong"><strong>Python</strong></span> Window and right click in it, and then select <span class="strong"><strong>Load</strong></span> from the right-click menu. Using the file navigation browser, find the script called <code class="literal">Chapter8_6_AdjustmapCURRENT.py</code> and select it by clicking on it. Push <span class="strong"><strong>OK</strong></span> and it will load in the Python Window. Pushing <span class="strong"><strong>Enter</strong></span> will execute the script, or use the scroll bar to peruse the loaded lines.</p><div class="section" title="The variables"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec63"/>The variables</h2></div></div></div><p>Within <a id="id314" class="indexterm"/>the script, a number of variables are first created to hold the <code class="literal">string</code> file paths, the <code class="literal">integer</code> buffer distance, and the <code class="literal">sql</code> statement used to identify the bus line of interest:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>import arcpy, os</strong></span>
<span class="strong"><strong>Bus_Stops = r"C:\Projects\SanFrancisco.gdb\Bus_Stops"</strong></span>
<span class="strong"><strong>selectedBusStop = r'C:\Projects\SanFrancisco.gdb\Chapter8Results\SelectedBusStop'</strong></span>
<span class="strong"><strong>selectedStopBuffer = r'C:\Projects\SanFrancisco.gdb\Chapter8Results\SelectedStopBuffer'</strong></span>
<span class="strong"><strong>CensusBlocks2010 = r"C:\Projects\SanFrancisco.gdb\CensusBlocks2010"</strong></span>
<span class="strong"><strong>selectedBlock = r'C:\Projects\SanFrancisco.gdb\Chapter8Results\SelectedCensusData'</strong></span>
<span class="strong"><strong>pdfFolder = r'C:\Projects\PDFs\Chapter8\Map_{0}'</strong></span>
<span class="strong"><strong>bufferDist = 400</strong></span>
<span class="strong"><strong>sql = "(NAME = '71 IB' AND BUS_SIGNAG = 'Ferry Plaza')"</strong></span>
</pre></div><p>These <a id="id315" class="indexterm"/>will be used later to allow us to search the layers and perform analysis on them.</p></div><div class="section" title="The map document object and the text elements"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec64"/>The map document object and the text elements</h2></div></div></div><p>Because<a id="id316" class="indexterm"/> this code will be executed<a id="id317" class="indexterm"/> in an open map document, we don't have to pass an MXD file path to the <code class="literal">arcpy.mapping.MapDocument()</code> method. Instead, we will use the keyword <code class="literal">CURRENT</code> to indicate that we are referencing the open map document:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>mxdObject = arcpy.mapping.MapDocument("CURRENT")</strong></span>
<span class="strong"><strong>dataFrame = arcpy.mapping.ListDataFrames(mxdObject, "Layers")[0]</strong></span>
<span class="strong"><strong>elements = arcpy.mapping.ListLayoutElements(mxdObject)</strong></span>
<span class="strong"><strong>for el in elements:</strong></span>
<span class="strong"><strong>    if el.type =="TEXT_ELEMENT":</strong></span>
<span class="strong"><strong>        if el.text == 'Title Element':</strong></span>
<span class="strong"><strong>            titleText = el</strong></span>
<span class="strong"><strong>        elif el.text == 'Subtitle Element':</strong></span>
<span class="strong"><strong>            subTitleText = el</strong></span>
</pre></div><p>Once the map document object has been created, the Layers data frame is selected from a list of data frames using the <code class="literal">ListDataFrames()</code> method and passed to the variable called dataFrame.</p><p>Next, the layout elements are passed as a list to the elements variable using the <code class="literal">ListLayoutElements()</code> method. The layout elements include the various elements of the map document layout view: the legend, the neat lines, the north arrow, the scale bar, and the text elements used as titles and descriptions. Unfortunately, there is no nice order to the list returned, as their position throughout the layout is undetermined. Access to the text elements, which we would like to assign to a variable for later use, must be identified using two properties of the element objects: the type and the text. We want to adjust the title and subtitle elements, so a <code class="literal">for</code> loop is used to search through the list of elements and the properties are used to find the elements of interest.</p><div class="section" title="The layer objects"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec32"/>The layer objects</h3></div></div></div><p>The Make <a id="id318" class="indexterm"/>Feature Layer tool, part of the Data Management toolset, is used to copy data from disk into memory as a layer. ArcGIS requires the generation of layers to perform selections and operations on data, instead of operating on the feature classes directly. By using layers to perform these operations, the source feature classes are protected.</p><p>The Make Feature Layer tool is accessed using ArcPy's <code class="literal">MakeFeatureLayer_management()</code> method. When using this tool in the Python Window, the result is added to the map document as a layer that will be visible in the Table of Contents. When the tool is not used in the Python Window in ArcMap, the resulting layer is only generated in memory and is not added to the map document.</p><p>In the portion<a id="id319" class="indexterm"/> of the following code, a layer called <code class="literal">blocks_lyr</code> is generated in memory by passing the file path of the census blocks feature class. The layer objects contained within the initial MXD are then accessed using the <code class="literal">ListLayers()</code> method of the <code class="literal">arcpy.mapping()</code> module. They are returned in the order that they are listed in the Table of Contents of the map document and are assigned to variables using list indexing, including the newly created <code class="literal">blocks_lyr</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>arcpy.MakeFeatureLayer_management(CensusBlocks2010, 'blocks_lyr')       </strong></span>
<span class="strong"><strong>layersList = arcpy.mapping.ListLayers(mxdObject,"",dataFrame)</strong></span>
<span class="strong"><strong>layerStops = layersList[0]</strong></span>
<span class="strong"><strong>layerCensus = layersList[1]</strong></span>
<span class="strong"><strong>layerBuffer = layersList[2]</strong></span>
<span class="strong"><strong>layerBlocks = layersList[3] </strong></span>
</pre></div></div><div class="section" title="Replacing the data sources"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec33"/>Replacing the data sources</h3></div></div></div><p>Now that <a id="id320" class="indexterm"/>we have assigned the layer objects to variables, we will check whether their data sources are the correct feature classes that we use for map production. Using the <code class="literal">dataSource</code> property of each layer object, they are compared to the file path variables that we want to use as data sources:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>if layerBlocks.dataSource != selectedBlock:</strong></span>
<span class="strong"><strong>    layerBlocks.replaceDataSource(dirpath(dirpath(layerBlocks.dataSource)),</strong></span>
<span class="strong"><strong>                                  'FILEGDB_WORKSPACE',basepath(selectedBlock))</strong></span>
<span class="strong"><strong>if layerStops.dataSource != selectedBusStop:</strong></span>
<span class="strong"><strong>    layerStops.replaceDataSource(dirpath(dirpath (layerStops.dataSource)),</strong></span>
<span class="strong"><strong>                                             'FILEGDB_WORKSPACE',basepath(selectedBusStop))</strong></span>
<span class="strong"><strong>if layerBuffer.dataSource != selectedStopBuffer:</strong></span>
<span class="strong"><strong>  layerBuffer.replaceDataSource(dirpath( dirpath(layerBuffer.dataSource)),</strong></span>
<span class="strong"><strong>                                    'FILEGDB_WORKSPACE',basepath(selectedStopBuffer))</strong></span>
</pre></div><p>
<code class="literal">If </code>statements are used to check whether the data sources are correct. If not, they are replaced with the correct data sources using the <code class="literal">replaceDataSource()</code> layer method. This method requires three parameters: the workspace (in this case, the File Geodatabase), the workspace<a id="id321" class="indexterm"/> type, and the name of the new feature class data source, which must be in the same workspace for the <code class="literal">replaceDataSource()</code> method to work (though it does not need to be in the same feature dataset).</p></div></div><div class="section" title="Adjusting layer visibility"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec65"/>Adjusting layer visibility</h2></div></div></div><p>The<a id="id322" class="indexterm"/> layer objects have a <a id="id323" class="indexterm"/>property that allows us to adjust their visibility. Setting this Boolean property to <code class="literal">True</code> or <code class="literal">False</code> will adjust the layer's visibility on (True) or off (False):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>layerStops.visible = True</strong></span>
<span class="strong"><strong>layerBuffer.visible = True</strong></span>
<span class="strong"><strong>layerCensus.visible = False</strong></span>
</pre></div><p>We want the layer variable <code class="literal">layerCensus</code>, which is the new <code class="literal">blocks_lyr</code> object, to be turned off, so it is set to <code class="literal">False</code>, but the bus stops and buffer layer objects need to be visible, so they are set to <code class="literal">True</code>.</p></div><div class="section" title="Generating a buffer from the bus stops feature class"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec66"/>Generating a buffer from the bus stops feature class</h2></div></div></div><p>All <a id="id324" class="indexterm"/>of the variables have been generated or assigned, so the next step is to use a <code class="literal">SearchCursor</code> to search through the selected bus stops. For each bus stop, buffer objects will <a id="id325" class="indexterm"/>be generated to find census blocks that intersect with these individual bus stops:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>with arcpy.da.SearchCursor(Bus_Stops,['SHAPE@','STOPID','NAME',</strong></span>
<span class="strong"><strong>                                      'BUS_SIGNAG' ,'OID@','SHAPE@XY'],sql) as cursor:</strong></span>
<span class="strong"><strong>    for row in cursor:</strong></span>
<span class="strong"><strong>        stopPointGeometry = row[0]</strong></span>
<span class="strong"><strong>        stopBuffer = stopPointGeometry.buffer(bufferDist)</strong></span>
<span class="strong"><strong>        with arcpy.da.UpdateCursor(layerBlocks,['OID@']) as                   dcursor:</strong></span>
<span class="strong"><strong>            for drow in dcursor:</strong></span>
<span class="strong"><strong>                dcursor.deleteRow()</strong></span>
</pre></div><p>For each row of data retrieved from the Bus Stops feature class, a number of attributes are returned, contained in a tuple. The first of these, row[0], is a <code class="literal">PointGeometry</code> object. This object has a buffer method that is used to generate a buffer <code class="literal">Polygon</code> object in memory, which is then assigned to the <code class="literal">stopBuffer</code> variable. Once the buffer object is created, the data access UpdateCursor's <code class="literal">deleteRow()</code> method is used to erase the rows in the census blocks layer. Once the rows have been deleted, the layer can then be repopulated with newly <a id="id326" class="indexterm"/>selected<a id="id327" class="indexterm"/> census blocks that will be identified in the next section.</p></div><div class="section" title="Intersecting the bus stop buffer and census blocks"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec67"/>Intersecting the bus stop buffer and census blocks</h2></div></div></div><p>To <a id="id328" class="indexterm"/>identify the census<a id="id329" class="indexterm"/> blocks intersecting with the buffer around each bus stop, the ArcToolbox tool <a id="id330" class="indexterm"/>SelectLayerByLocation is invoked using the ArcPy method <code class="literal">SelectLayerByLocation_management()</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>arcpy.SelectLayerByLocation_management('blocks_lyr', 'intersect', stopBuffer, "", "NEW_SELECTION")</strong></span>
<span class="strong"><strong>        with arcpy.da.SearchCursor('blocks_lyr', ['SHAPE@', 'POP10','OID@']) as bcursor:</strong></span>
<span class="strong"><strong>                inCursor = arcpy.da.InsertCursor(selectedBlock,['SHAPE@', 'POP10'])</strong></span>
<span class="strong"><strong>              for drow in bcursor:                </strong></span>
<span class="strong"><strong>                  data = drow[0],drow[1]</strong></span>
<span class="strong"><strong>                  inCursor.insertRow(data)</strong></span>
<span class="strong"><strong>   del inCursor</strong></span>
</pre></div><p>This method requires the in-memory <code class="literal">blocks_lyr</code> layer object and the newly created buffer object assigned to the variable <code class="literal">stopBuffer</code>. It also requires the type of selection <code class="literal">intersect</code> and another parameter that controls whether the selection will be added to an existing selection or will be a new selection. In this case, we want a new selection, as only the census blocks that intersect the current bus stop are needed.</p><p>Once the census blocks have been selected and identified, the shape data and population data is passed to the feature class represented by the variable <code class="literal">selectedBlock</code> using an <code class="literal">InsertCursor</code>. The InsertCursor must be deleted using the del keyword, as only one <code class="literal">InsertCursor </code>or <code class="literal">UpdateCursor</code> can be in memory at a time.</p><div class="section" title="Populating the selected bus stop and buffer feature classes"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec34"/>Populating the selected bus stop and buffer feature classes</h3></div></div></div><p>In a similar manner, the next step is to populate the bus stop and buffer feature classes that <a id="id331" class="indexterm"/>will be used in the map production. The bus stops feature class is first made blank using the <code class="literal">deleteRow()</code> method, and then the selected bus stop shape field data is inserted into the feature class. The same steps are then taken with the bus stop buffers feature class and the buffer geometry object:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>  with arcpy.da.UpdateCursor(selectedBusStop,['OID@']) as dcursor:</strong></span>
<span class="strong"><strong>    for drow in dcursor:</strong></span>
<span class="strong"><strong>        dcursor.deleteRow()</strong></span>
<span class="strong"><strong>  inBusStopCursor = arcpy.da.InsertCursor(selectedBusStop,['SHAPE@'])</strong></span>
<span class="strong"><strong>  data = [row[0]]</strong></span>
<span class="strong"><strong>  inBusStopCursor.insertRow(data)</strong></span>
<span class="strong"><strong>  del inBusStopCursor</strong></span>
<span class="strong"><strong>  with arcpy.da.UpdateCursor(selectedStopBuffer,['OID@']) as dcursor:</strong></span>
<span class="strong"><strong>    for drow in dcursor:</strong></span>
<span class="strong"><strong>        dcursor.deleteRow()</strong></span>
<span class="strong"><strong>  inBufferCursor = arcpy.da.InsertCursor(selectedStopBuffer,['SHAPE@'])</strong></span>
<span class="strong"><strong>  data = [stopBuffer]</strong></span>
<span class="strong"><strong>  inBufferCursor.insertRow(data)</strong></span>
<span class="strong"><strong>  del inBufferCursor</strong></span>
</pre></div></div></div><div class="section" title="Updating the text elements"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec68"/>Updating the text elements</h2></div></div></div><p>Now <a id="id332" class="indexterm"/>that the data has been <a id="id333" class="indexterm"/>generated and written to the feature classes created to hold them, the next step is to update the layout elements. This includes layer properties that will affect the legend, the extent of the data frame, and the text elements:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>layerStops.name = "Stop #{0}".format(row[1])</strong></span>
<span class="strong"><strong>dataFrame.extent = arcpy.Extent(row[-1][0]-1200,row[-1][1]-1200,</strong></span>
<span class="strong"><strong>                                row[-1][0]+1200,row[-1][1]-1200)</strong></span>
<span class="strong"><strong>subTitleText.text = "Route {0}".format(row[2])</strong></span>
<span class="strong"><strong>titleText.text = "Bus Stop {0}".format(row[1])</strong></span>
<span class="strong"><strong>arcpy.RefreshActiveView()</strong></span>
</pre></div><p>The name of the bus stops layer is adjusted using its name property to reflect the current bus stop. The data frame extent is adjusted by creating an <code class="literal">arcpy.Extent</code> object and passing it four parameters: <span class="emphasis"><em>Xmin</em></span>, <span class="emphasis"><em>Ymin</em></span>, <span class="emphasis"><em>Xmax</em></span>, <span class="emphasis"><em>Ymax</em></span>. To generate these values I have used the somewhat arbitrary value of 1200 feet to create a square around the bus stop. The text elements are updated using their text property. Finally, the <code class="literal">RefreshActiveView()</code> method is used to ensure that the map document window is correctly <a id="id334" class="indexterm"/>updated to the<a id="id335" class="indexterm"/> new extent.</p><div class="section" title="Exporting the adjusted map to PDF"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec35"/>Exporting the adjusted map to PDF</h3></div></div></div><p>The final<a id="id336" class="indexterm"/> step is to pass the newly adjusted <a id="id337" class="indexterm"/>map document object to ArcPy's <code class="literal">ExportToPDF</code> method. This<a id="id338" class="indexterm"/> method requires two parameters, the map document object and a string that represents the file path of the PDF:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>outPath = pdfFolder.format(str(row[1])+"_"+ str(row[-2]))+'.pdf'</strong></span>
<span class="strong"><strong>arcpy.mapping.ExportToPDF(mxdObject,outPath)</strong></span>
<span class="strong"><strong>titleText.text = 'Title Element'</strong></span>
<span class="strong"><strong>subTitleText.text = 'Subtitle Element'</strong></span>
<span class="strong"><strong>arcpy.RefreshActiveView()</strong></span>
</pre></div><p>The PDF file path string is generated from the pdfFolder string template and the ID of the bus stop, along with the object ID and the file extension <code class="literal">.pdf</code>. Once that and the map document object represented by the variable <code class="literal">mxdObject</code> are passed to the <code class="literal">ExportToPDF</code> method, the PDF will be generated. The text elements are then reset and the view is refreshed to ensure that the map document will be ready for the next time the script is used.</p></div></div></div>
<div class="section" title="Running the script in the Python Window"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec43"/>Running the script in the Python Window</h1></div></div></div><p>Open up<a id="id339" class="indexterm"/> the map document called <code class="literal">MapAdjust.mxd</code> if it is not open already. Open the <span class="strong"><strong>Python</strong></span> Window and right click in the window. Select<a id="id340" class="indexterm"/> <span class="strong"><strong>Load</strong></span> from the menu. When the file dialog opens, find the script called <code class="literal">Chapter8_6_AdjustmapCURRENT.py</code> and select it, making sure that the file paths within it are correct. Push <span class="strong"><strong>OK</strong></span> and it will load in the Python Window. Push <span class="strong"><strong>Enter</strong></span> once the script is loaded to run the script. It can take a few seconds or more for it to be obvious that the script is running.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>Note that the Python Window is not a great place to execute ArcPy scripts in most cases, as it is somewhat limited when compared to IDEs. Using it to load and execute a script that performs these map document adjustments is one of the best uses of the Python Window.</p></div></div><p>Once the <a id="id341" class="indexterm"/>script is running, the adjustments to the map<a id="id342" class="indexterm"/> document will begin to appear and repeat. This is a fascinating process, as the effects of running the script are visible in a manner that is not readily available when running Python scripts. Once the PDFs begin to be generated, open one up to view the output. The script will generate a map for each bus stop on the selected bus line, so feel free to shut down the map document after generating a set number of the PDFs.</p><p>Here is an example of the output:</p><div class="mediaobject"><img src="graphics/8662OS_08_03.jpg" alt="Running the script in the Python Window"/></div><p>The maps generated by the script show each bus stop at the center, surrounded by the buffer and the symbolized census blocks with which the buffer intersects. The title, subtitle and the legend have been adjusted to indicate the bus stop depicted in the map. With ArcPy, we are now in control of both the parts of geospatial analysis: the analysis itself, and the cartographic production depicting the result of the output.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec44"/>Summary</h1></div></div></div><p>In this chapter arcpy.mapping was introduced and used to control the elements of map documents that need to be adjusted to create custom maps. By joining geospatial analysis and map production together, we are closer to utilizing the full power of ArcPy.</p><p>In the next chapter, we will go further with arcpy.mapping and create a script tool that can be added to ArcToolbox, which will run the analysis as well as generate maps from the resulting data. We will also refine the script and introduce Data Driven Pages to discuss how that powerful tool can be used in an ArcPy script.</p></div></body></html>