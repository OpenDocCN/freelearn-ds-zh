["```py\nimport itertools, operator\nfrom .data import *\n```", "```py\nimport PIL, PIL.Image\n```", "```py\nimport . import manager\n```", "```py\nimport Tkinter as tk\nimport ScrolledText as tkst # a convenience module that ships with Tkinter\n\nfrom .toolkit.popups import *\nfrom .toolkit.ribbon import *\nfrom .toolkit import theme\nfrom . import icons\nfrom .. import vector, raster\n\nstyle_layeroptions_info = {\"fg\": theme.font1[\"color\"],\n                            \"font\": theme.font1[\"type\"],\n                            \"relief\": \"flat\"}\n\nclass LayerOptionsWindow(Window):\n    def __init__(self, master, **kwargs):\n        # Make this class a subclass of tk.Menu and add to it\n        Window.__init__(self, master, **kwargs)\n\n        # Make the top ribbon selector\n        self.ribbon = Ribbon(self)\n        self.ribbon.pack(side=\"top\", fill=\"both\", expand=True)\n\n    def add_info(self, tab, label, value):\n        row = tk.Frame(tab, bg=tab.cget(\"bg\"))\n        row.pack(fill=\"x\", anchor=\"n\", pady=5, padx=5)\n\n        # place label\n        header = tk.Label(row, text=label, bg=tab.cget(\"bg\"), **style_layeroptions_info)\n        header.pack(side=\"left\", anchor=\"nw\", padx=3)\n\n        # place actual info text\n        value = str(value)\n        info = tk.Entry(row, width=400, disabledbackground=\"white\", justify=\"right\", **style_layeroptions_info)\n        info.pack(side=\"right\", anchor=\"ne\", padx=3)\n        info.insert(0, value)\n        info.config(state=\"readonly\")\n        return info\n```", "```py\nclass VectorLayerOptionsWindow(LayerOptionsWindow):\n    def __init__(self, master, layeritem, statusbar, **kwargs):\n        # Make this class a subclass of tk.Menu and add to it\n        LayerOptionsWindow.__init__(self, master, **kwargs)\n        self.layeritem = layeritem\n        ###########\n        ### GENERAL OPTIONS TAB\n        general = self.ribbon.add_tab(\"General\")\n\n        # add pieces of info\n        self.source = self.add_info(general, \"Source file: \", layeritem.renderlayer.data.filepath)\n        self.proj = self.add_info(general, \"Projection: \", self.layeritem.renderlayer.data.crs)\n        self.bbox = self.add_info(general, \"Bounding box: \", layeritem.renderlayer.data.bbox)\n        self.fields = self.add_info(general, \"Attribute fields: \", layeritem.renderlayer.data.fields)\n        self.rows = self.add_info(general, \"Total rows: \", len(layeritem.renderlayer.data))\n\n        ###########\n        # Set starting tab\n        self.ribbon.switch(tabname=\"General\")\n```", "```py\nclass RasterLayerOptionsWindow(LayerOptionsWindow):\n    def __init__(self, master, layeritem, statusbar, **kwargs):\n        # Make this class a subclass of tk.Menu and add to it\n        LayerOptionsWindow.__init__(self, master, **kwargs)\n        self.layeritem = layeritem\n\n        ###########\n        ### GENERAL OPTIONS TAB\n        general = self.ribbon.add_tab(\"General\")\n\n        # add pieces of info\n        self.source = self.add_info(general, \"Source file: \", layeritem.renderlayer.data.filepath)\n        self.proj = self.add_info(general, \"Projection: \", self.layeritem.renderlayer.data.crs)\n        self.dims = self.add_info(general, \"Dimensions: \", \"%i, %i\"%(self.layeritem.renderlayer.data.width,\n                                                                     self.layeritem.renderlayer.data.height))\n        self.bands = self.add_info(general, \" Raster bands: \", \"%i\"%len(self.layeritem.renderlayer.data.bands))\n        self.transform = self.add_info(general, \"Transform: \", self.layeritem.renderlayer.data.info)\n        self.bbox = self.add_info(general, \"Bounding box: \", layeritem.renderlayer.data.bbox)\n\n        ###########\n        # Set starting tab\n        self.ribbon.switch(tabname=\"General\")\n```", "```py\ndef split(data, splitfields):\n    fieldindexes = [index for index,field in enumerate(data.fields)\n                    if field in splitfields]\n    sortedfeatures = sorted(data, key=operator.itemgetter(*fieldindexes))\n    grouped = itertools.groupby(sortedfeatures, key=operator.itemgetter(*fieldindexes))\n    for splitid,features in grouped:\n        outfile = VectorData()\n        outfile.fields = list(data.fields)\n        for oldfeat in features:\n            outfile.add_feature(oldfeat.row, oldfeat.geometry)\n        yield outfile\n```", "```py\ndef merge(*datalist):\n    #make empty table\n    firstfile = datalist[0]\n    outfile = VectorData()\n    #combine fields from all files\n    outfields = list(firstfile.fields)\n    for data in datalist[1:]:\n        for field in data.fields:\n            if field not in outfields:\n                outfields.append(field)\n    outfile.fields = outfields\n    #add the rest of the files\n    for data in datalist:\n        for feature in data:\n            geometry = feature.geometry.copy()\n            row = []\n            for field in outfile.fields:\n                if field in data.fields:\n                    row.append( feature[field] )\n                else:\n                    row.append( \"\" )\n            outfile.add_feature(row, geometry)\n    #return merged file\n    return outfile\n```", "```py\ndef clean(data, tolerance=0):\n    # create new file\n    outfile = VectorData()\n    outfile.fields = list(data.fields)\n\n    # clean\n    for feat in data:\n        shapelyobj = feat.get_shapely()\n\n        # try fixing invalid geoms\n        if not shapelyobj.is_valid:\n            if \"Polygon\" in shapelyobj.type:\n                # fix bowtie polygons\n                shapelyobj = shapelyobj.buffer(0.0)\n\n        # remove repeat points (tolerance=0)\n        # (and optionally smooth out complex shapes, tolerance > 0)\n        shapelyobj = shapelyobj.simplify(tolerance)\n\n        # if still invalid, do not add to output\n        if not shapelyobj.is_valid:\n            continue\n\n        # write to file\n        geojson = shapelyobj.__geo_interface__\n        outfile.add_feature(feat.row, geojson)\n\n    return outfile\n```", "```py\ndef align_rasters(*rasters): \n    \"Used internally by other functions only, not by user\"\n    # get coord bbox containing all rasters\n    for rast in rasters: print rast.bbox\n    xlefts,ytops,xrights,ybottoms = zip(*[rast.bbox for rast in rasters])\n    if xlefts[0] < xrights[0]:\n        xleft,xright = min(xlefts),max(xrights)\n    else: xleft,xright = max(xlefts),min(xrights)\n    if ytops[0] > ybottoms[0]:\n        ytop,ybottom = max(ytops),min(ybottoms)\n    else: ytop,ybottom = min(ytops),max(ybottoms)\n\n    # get the required pixel dimensions (based on first raster, but should probably allow user to specify)\n    xs,ys = (xleft,xright),(ytop,ybottom)\n    coordwidth,coordheight = max(xs)-min(xs), max(ys)-min(ys)\n    rast = rasters[0]\n    orig_xs,orig_ys = (rast.bbox[0],rast.bbox[2]),(rast.bbox[1],rast.bbox[3])\n    orig_coordwidth,orig_coordheight = max(orig_xs)-min(orig_xs), max(orig_ys)-min(orig_ys)\n    widthratio,heightratio = coordwidth/orig_coordwidth, coordheight/orig_coordheight\n    reqwidth = int(round(rast.width*widthratio))\n    reqheight = int(round(rast.height*heightratio))\n\n    # position into same coordbbox\n    aligned = []\n    for rast in rasters:\n        coordbbox = [xleft,ytop,xright,ybottom]\n        positioned = rast.positioned(reqwidth, reqheight, coordbbox)\n        aligned.append(positioned)\n    return aligned\n```", "```py\ndef mosaic(*rasters):\n    \"\"\"\n    Mosaic rasters covering different areas together into one file.\n    Parts of the rasters may overlap each other, in which case we use the value\n    from the last listed raster (the \"last\" overlap rule). \n    \"\"\"\n    # align all rasters, ie resampling to the same dimensions as the first raster\n    aligned = align_rasters(*rasters)\n    # copy the first raster and reset the cached mask for the new raster\n    firstalign,firstmask = aligned[0]\n    merged = firstalign.copy()\n    del merged._cached_mask\n    # paste onto each other, ie \"last\" overlap rule\n    for rast,mask in aligned[1:]:\n        merged.bands[0].img.paste(rast.bands[0].img, (0,0), mask)\n\n    return merged\n```", "```py\ndef resample(raster, width=None, height=None, cellwidth=None, cellheight=None):\n    raster = raster.copy()\n\n    if width and height:\n        # calculate new cell dimensions based on the new raster size\n        widthfactor = raster.width / float(width)\n        heightfactor = raster.height / float(height)\n        oldcellwidth, oldcellheight = raster.info[\"cellwidth\"], raster.info[\"cellheight\"]\n        newcellwidth, newcellheight = oldcellwidth * widthfactor, oldcellheight * heightfactor\n\n        # resample each grid\n        for band in raster:\n            band.img = band.img.resize((width, height), PIL.Image.NEAREST)\n            # update cells access\n            band.cells = band.img.load()\n\n        # remember new celldimensions\n        raster.info[\"cellwidth\"] = newcellwidth\n        raster.info[\"cellheight\"] = newcellheight\n        return raster\n\n    elif cellwidth and cellheight:\n        # calculate new raster size based on the new cell dimensions\n        widthfactor = raster.info[\"cellwidth\"] / float(cellwidth)\n        heightfactor = raster.info[\"cellheight\"] / float(cellheight)\n        oldwidth, oldheight = raster.width, raster.height\n        newwidth, newheight = int(round(oldwidth * widthfactor)), int(round(oldheight * heightfactor))\n\n        # resample each grid\n        for band in raster:\n            band.img = band.img.resize((newwidth, newheight), PIL.Image.NEAREST)\n            # update cells access\n            band.cells = band.img.load()\n\n        # remember new celldimensions\n        raster.info[\"cellwidth\"] = cellwidth\n        raster.info[\"cellheight\"] = cellheight\n        return raster\n\n    else:\n        raise Exception(\"To rescale raster, either width and height or cellwidth and cellheight must be specified.\")\n```", "```py\nclass RightClickMenu_VectorLayer(tk.Menu):\n    def __init__(self, master, layerspane, layeritem, statusbar, **kwargs):\n        # Make this class a subclass of tk.Menu and add to it\n        tk.Menu.__init__(self, master, tearoff=0, **kwargs)\n        self.layerspane = layerspane\n        self.layeritem = layeritem\n        self.statusbar = statusbar\n        self.imgs = dict()\n\n        # Renaming\n        self.imgs[\"rename\"] = icons.get(\"rename.png\", width=32, height=32)\n        self.add_command(label=\"Rename\", command=self.layeritem.ask_rename, image=self.imgs[\"rename\"], compound=\"left\")\n\n        # Saving\n        def ask_save():\n            savepath = asksaveasfilename()\n            self.statusbar.task.start(\"Saving layer to file...\")\n            pending = dispatch.request_results(self.layeritem.renderlayer.data.save, args=[savepath])\n            def finish(result):\n                if isinstance(result, Exception):\n                    popup_message(self, str(result) + \"\\n\\n\" + savepath)\n                self.statusbar.task.stop()\n            dispatch.after_completion(self, pending, finish)\n        self.imgs[\"save\"] = icons.get(\"save.png\", width=32, height=32)\n        self.add_command(label=\"Save as\", command=ask_save, image=self.imgs[\"save\"], compound=\"left\")\n\n        # ---(Breakline)---\n        self.add_separator()\n\n        # Splitting\n        def open_options_window():\n            window = VectorSplitOptionWindow(self.layeritem, self.layerspane, self.layeritem, statusbar)\n        self.imgs[\"split\"] = icons.get(\"split.png\", width=32, height=32)\n        self.add_command(label=\"Split to layers\", command=open_options_window, image=self.imgs[\"split\"], compound=\"left\")\n\n        # ---(Breakline)---\n        self.add_separator()\n\n        # Cleaning\n        def open_options_window():\n            window = VectorCleanOptionWindow(self.layeritem, self.layerspane, self.layeritem, statusbar)\n        self.imgs[\"clean\"] = icons.get(\"clean.png\", width=32, height=32)\n        self.add_command(label=\"Clean Geometries\", command=open_options_window, image=self.imgs[\"clean\"], compound=\"left\")\n\n        # ---(Breakline)---\n        self.add_separator()\n\n        # View properties\n        def view_properties():\n            window = VectorLayerOptionsWindow(self.layeritem, self.layeritem, statusbar)\n        self.imgs[\"properties\"] = icons.get(\"properties.png\", width=32, height=32)\n        self.add_command(label=\"Properties\", command=view_properties, image=self.imgs[\"properties\"], compound=\"left\")\n```", "```py\nclass RightClickMenu_RasterLayer(tk.Menu):\n    def __init__(self, master, layerspane, layeritem, statusbar, **kwargs):\n        # Make this class a subclass of tk.Menu and add to it\n        tk.Menu.__init__(self, master, tearoff=0, **kwargs)\n        self.layerspane = layerspane\n        self.layeritem = layeritem\n        self.statusbar = statusbar\n        self.imgs = dict()\n\n        # Renaming\n        self.imgs[\"rename\"] = icons.get(\"rename.png\", width=32, height=32)\n        self.add_command(label=\"Rename\", command=self.layeritem.ask_rename, image=self.imgs[\"rename\"], compound=\"left\")\n\n        # Saving\n        def ask_save():\n            savepath = asksaveasfilename()\n            self.statusbar.task.start(\"Saving layer to file...\")\n            pending = dispatch.request_results(self.layeritem.renderlayer.data.save, args=[savepath])\n            def finish(result):\n                if isinstance(result, Exception):\n                    popup_message(self, str(result) + \"\\n\\n\" + savepath)\n                self.statusbar.task.stop()\n            dispatch.after_completion(self, pending, finish)\n        self.imgs[\"save\"] = icons.get(\"save.png\", width=32, height=32)\n        self.add_command(label=\"Save as\", command=ask_save, image=self.imgs[\"save\"], compound=\"left\")\n\n        # ---(Breakline)---\n        self.add_separator()\n\n        # Resampling\n        def open_options_window():\n            window = RasterResampleOptionWindow(self.layeritem, self.layerspane, self.layeritem, statusbar)\n        self.imgs[\"resample\"] = icons.get(\"resample.png\", width=32, height=32)\n        self.add_command(label=\"Resample\", command=open_options_window, image=self.imgs[\"resample\"], compound=\"left\")\n\n        # ---(Breakline)---\n        self.add_separator()\n\n        # View properties\n        def view_properties():\n            window = RasterLayerOptionsWindow(self.layeritem, self.layeritem, statusbar)\n        self.imgs[\"properties\"] = icons.get(\"properties.png\", width=32, height=32)\n        self.add_command(label=\"Properties\", command=view_properties, image=self.imgs[\"properties\"], compound=\"left\")\n```", "```py\nclass VectorCleanOptionWindow(Window):\n    def __init__(self, master, layerspane, layeritem, statusbar, **kwargs):\n        # Make this class a subclass and add to it\n        Window.__init__(self, master, **kwargs)\n\n        # Create runtoolframe\n        self.runtool = RunToolFrame(self)\n        self.runtool.pack(fill=\"both\", expand=True)\n        self.runtool.assign_statusbar(statusbar)\n\n        # Add a hidden option from its associated layeritem data\n        self.runtool.add_hidden_option(argname=\"data\", value=layeritem.renderlayer.data)\n\n        # Set the remaining options\n        self.runtool.set_target_method(\"Cleaning data...\", vector.manager.clean)\n        self.runtool.add_option_input(argname=\"tolerance\", label=\"Tolerance (in distance units)\",\n                             valuetype=float, default=0.0, minval=0.0, maxval=1.0)\n\n        # Define how to process\n        newname = layeritem.namelabel[\"text\"] + \"_cleaned\"\n        def process(result):\n            if isinstance(result, Exception):\n                popup_message(self, \"Failed to clean the data:\" + \"\\n\\n\" + str(result) )\n            else:\n                layerspane.add_layer(result, name=newname)\n                self.destroy()\n\n        self.runtool.set_finished_method(process)\n```", "```py\nclass VectorSplitOptionWindow(Window):\n    def __init__(self, master, layerspane, layeritem, statusbar, **kwargs):\n        # Make this class a subclass and add to it\n        Window.__init__(self, master, **kwargs)\n\n        # Create runtoolframe\n        self.runtool = RunToolFrame(self)\n        self.runtool.pack(fill=\"both\", expand=True)\n        self.runtool.assign_statusbar(statusbar)\n\n        # Add a hidden option from its associated layeritem data\n        self.runtool.add_hidden_option(argname=\"data\", value=layeritem.renderlayer.data)\n\n        # Set the remaining options\n        self.runtool.set_target_method(\"Splitting data...\", vector.manager.split)\n        self.runtool.add_option_input(argname=\"splitfields\",\n                              label=\"Split by fields\",\n                              multi=True, choices=layeritem.renderlayer.data.fields,\n                              valuetype=str)\n\n        # Define how to process\n        def process(result):\n            if isinstance(result, Exception):\n                popup_message(self, \"Failed to split the data:\" + \"\\n\\n\" + str(result) )\n            else:\n                for splitdata in result:\n                    layerspane.add_layer(splitdata)\n                    self.update()\n                self.destroy()\n        self.runtool.set_finished_method(process)\n```", "```py\nclass RasterResampleOptionWindow(Window):\n    def __init__(self, master, layerspane, layeritem, statusbar, **kwargs):\n        # Make this class a subclass and add to it\n        Window.__init__(self, master, **kwargs)\n\n        # Create runtoolframe\n        self.runtool = RunToolFrame(self)\n        self.runtool.pack(fill=\"both\", expand=True)\n        self.runtool.assign_statusbar(statusbar)\n\n        # Add a hidden option from its associated layeritem data\n        self.runtool.add_hidden_option(argname=\"raster\", value=layeritem.renderlayer.data)\n\n        # Set the remaining options\n        self.runtool.set_target_method(\"Resampling data...\", raster.manager.resample)\n        def get_data_from_layername(name):\n            data = None\n            for layeritem in layerspane:\n                if layeritem.name_label[\"text\"] == name:\n                    data = layeritem.renderlayer.data\n                    break\n            return data\n        self.runtool.add_option_input(argname=\"width\", label=\"Raster width (in cells)\",\n                                valuetype=int)\n        self.runtool.add_option_input(argname=\"height\", label=\"Raster height (in cells)\",\n                                valuetype=int)\n        self.runtool.add_option_input(argname=\"cellwidth\", label=\"Cell width (in distance units)\",\n                                valuetype=float)\n        self.runtool.add_option_input(argname=\"cellheight\", label=\"Cell height (in distance units)\",\n                                valuetype=float)\n        # Define how to process after finished\n        def process(result):\n            if isinstance(result, Exception):\n                popup_message(self, \"Failed to resample the data:\" + \"\\n\\n\" + str(result) )\n            else:\n                layerspane.add_layer(result)\n                self.destroy()\n        self.runtool.set_finished_method(process)\n```", "```py\n        # Bind layeritem right click behavior\n        def layer_rightclick(event):\n            layeritem = event.widget.master.master\n            if isinstance(layeritem.renderlayer, pg.renderer.VectorLayer):\n                menu = RightClickMenu_VectorLayer(self, self.layerspane, layeritem, self.statusbar)\n            elif isinstance(layeritem.renderlayer, pg.renderer.RasterLayer):\n                menu = RightClickMenu_RasterLayer(self, self.layerspane, layeritem, self.statusbar)\n            # Place and show menu\n            menu.post(event.x_root, event.y_root)      \n        self.layerspane.bind_layer_rightclick(layer_rightclick)\n```", "```py\n        ## Management tab\n        managetab = self.ribbon.add_tab(\"Manage\")\n        ### (Vector toolbar)\n        vectorfiles = managetab.add_toolbar(\"Vector Files\")\n        def open_merge_window():\n            window = VectorMergeOptionWindow(self, self.layerspane, self.statusbar)\n        vectorfiles.add_button(text=\"Merge\", icon=\"vector_merge.png\",\n                               command=open_merge_window)\n        ### (Raster toolbar)\n        rasterfiles = managetab.add_toolbar(\"Raster Files\")\n        def open_mosaic_window():\n            window = RasterMosaicOptionWindow(self, self.layerspane, self.statusbar)\n        rasterfiles.add_button(text=\"Mosaic\", icon=\"mosaic.png\",\n                               command=open_mosaic_window)\n```", "```py\nclass VectorMergeOptionWindow(Window):\n    def __init__(self, master, layerspane, statusbar, **kwargs):\n        # Make this class a subclass and add to it\n        Window.__init__(self, master, **kwargs)\n\n        # Create runtoolframe\n        self.runtool = RunToolFrame(self)\n        self.runtool.pack(fill=\"both\", expand=True)\n        self.runtool.assign_statusbar(statusbar)\n\n        # Set the remaining options\n        self.runtool.set_target_method(\"Merging data...\", vector.manager.merge)\n        def get_data_from_layername(name):\n            data = None\n            for layeritem in layerspane:\n                if layeritem.namelabel[\"text\"] == name:\n                    data = layeritem.renderlayer.data\n                    break\n            return data\n        self.runtool.add_option_input(argname=None,\n                              label=\"Layers to be merged\",\n                              multi=True,\n                              choices=[layeritem.namelabel[\"text\"] for layeritem in layerspane],\n                              valuetype=get_data_from_layername)\n\n        # Define how to process\n        def process(result):\n            if isinstance(result, Exception):\n                popup_message(self, \"Failed to merge the data:\" + \"\\n\\n\" + str(result) )\n            else:\n                layerspane.add_layer(result, name=\"merged\")\n        self.runtool.set_finished_method(process)\n```", "```py\nclass RasterMosaicOptionWindow(Window):\n    def __init__(self, master, layerspane, statusbar, **kwargs):\n        # Make this class a subclass and add to it\n        Window.__init__(self, master, **kwargs)\n\n        # Create runtoolframe\n        self.runtool = RunToolFrame(self)\n        self.runtool.pack(fill=\"both\", expand=True)\n        self.runtool.assign_statusbar(statusbar)\n\n        # Set the remaining options\n        self.runtool.set_target_method(\"Mosaicking data...\", raster.manager.mosaic)\n        def get_data_from_layername(name):\n            data = None\n            for layeritem in layerspane:\n                if layeritem.namelabel[\"text\"] == name:\n                    data = layeritem.renderlayer.data\n                    break\n            return data\n        self.runtool.add_option_input(argname=None,\n                              label=\"Layers to be mosaicked\",\n                              multi=True,\n                              choices=[layeritem.namelabel[\"text\"] for layeritem in layerspane],\n                              valuetype=get_data_from_layername)\n\n        # Define how to process\n        def process(result):\n            if isinstance(result, Exception):\n                popup_message(self, \"Failed to mosaick the data:\" + \"\\n\\n\" + str(result) )\n            else:\n                layerspane.add_layer(result, name=\"mosaicked\")\n        self.runtool.set_finished_method(process)\n```"]