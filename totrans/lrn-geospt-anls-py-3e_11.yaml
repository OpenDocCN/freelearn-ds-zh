- en: Advanced Geospatial Python Modeling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll build on the data processing concepts that we've learned
    in order to create some full-scale information products. The previously introduced
    data processing methods rarely provide answers to questions by themselves. You
    combine these data processing methods to build a geospatial model from multiple
    processed datasets. A geospatial model is a simplified representation of some
    aspect of the real world, which helps us answer one or more questions about a
    project or problem. In this chapter, we will introduce some important geospatial
    algorithms that are commonly used in agriculture, emergency management, logistics,
    and other industries.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'The products that we will create are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: A crop health map
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A flood inundation model
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A colorized hillshade
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A terrain routing map
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A street routing map
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A shapefile with links to geolocated photos
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While these products are task-specific, the algorithms that are used to create
    them are widely applied in geospatial analysis. We will be covering the following
    topics in this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Creating a normalized difference vegetative index (NVDI)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a flood inundation model
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a color hillshade
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing least cost path analysis
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting the route to a shapefile
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing along streets
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Geolocating photos
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating satellite image cloud cover
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The examples in this chapter are longer and more involved than in the previous
    chapters. For that reason, there are far more code comments to make the programs
    easier to follow. We will also use more functions in these examples. In previous
    chapters, functions were mostly avoided for clarity, but these examples are sufficiently
    complex that certain functions make the code easier to read. These examples are
    actual processes that you would use on the job as a geospatial analyst.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, the following requirements need to be satisfied:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '**Version**: Python 3.6 or higher'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RAM**: Minimum 6 GB (Windows), 8 GB (macOS); recommended 8 GB'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Storage**: Minimum 7,200 RPM SATA with 20 GB of available space, recommended
    SSD with 40 GB of available space.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Processor**: Minimum Intel Core i3 2.5 GHz, recommended Intel Core i5.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a normalized difference vegetative index
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our first example will be an **normalized difference vegetative index** (**NVDI**). NDVIs
    are used to show the relative health of plants in an area of interest. An NDVI
    algorithm uses satellite or aerial imagery to show relative health by highlighting
    the chlorophyll density in plants. NDVIs use only the red and near-infrared bands.
    The formula of NDVI is as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The goal of this analysis is to produce, to begin with, a multispectral image
    containing infrared and red bands, and end up with a pseudo color image using
    seven classes, which color the healthier plants darker green, less-healthy plants
    lighter green, and bare soil brown.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Because the health index is relative, it is important to localize the area of
    interest. You could perform a relative index for the entire globe but vast areas,
    such as the Sahara desert on the low-vegetation extreme and densely forested areas,
    such as the Amazon jungle, skew the results for vegetation in the middle range.
    However, that being said, climate scientists routinely create global NDVIs to
    study worldwide trends. The more common application, though, is for managed areas,
    such as a forest or a farm field, as in this example.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'We will begin with an analysis of a single farm field in the Mississippi Delta.
    To do so, we''ll start with a multispectral image of a fairly large area and use
    a shapefile in order to isolate a single field. The image in the following screenshot
    is our broad area, with the field of interest highlighted in yellow:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7918c9ce-706d-4b4f-a71e-ba3e85c2e0cd.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: You can download this image and the shapefile for the farm field as a ZIP file
    from [http://git.io/v3fS9](http://git.io/v3fS9).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, we''ll use GDAL, OGR, `gdal_array`/`numpy`, and the **Python
    Imaging Library** (**PIL**) to clip and process the data. In the other examples
    in this chapter, we''ll just use simple ASCII Grids and NumPy. As we''ll be using
    ASCII elevation grids, GDAL isn''t required. In all examples, the scripts use
    the following convention:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Import libraries.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define functions.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define global variables, such as filenames.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute the analysis.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save the output.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our approach to the crop health example is split into two scripts. The first
    script creates the index image, which is a grayscale image. The second script
    classifies the index and outputs a colored image. In this first script, we''ll
    execute the following steps to create the index image:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Read the infrared band.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read the field boundary shapefile.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rasterize the shapefile to an image.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the shapefile image to a NumPy array.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the NumPy array to clip the red band to the field.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do the same for the infrared band.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the band arrays to execute the NDVI algorithm in NumPy.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the resulting indexing algorithm to a GeoTIFF file using `gdal_array`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will discuss this script in sections to make it easier to follow. The code
    comments will also tell you what is going on at each step of the way.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the framework
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Setting up the framework will help us to import the modules that we need and
    set up the functions that we''ll use for steps 1 to 5 of the preceding instructions.
    The `imageToArray()` function converts a PIL image to a NumPy array and is dependent
    on the `gdal_array` and PIL modules. The `world2Pixel()` function converts geospatial
    coordinates to the pixel coordinates of our target image. This function uses the
    georeferencing information that is presented by the `gdal` module. The `copy_geo()`
    function copies the georeferencing information from our source image to our target
    array but accounts for the offset that is created when we clip the image. These
    functions are fairly generic and can serve a role in a variety of different remote
    sensing processes beyond this example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import our libraries:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we need a function to convert an image to a `numpy` array:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we''ll set up a function to convert the coordinates to image pixels:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, we''ll create a function to copy geographic metadata from an image:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The next step is to load the data, which we'll be checking in the next section.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Loading the data
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we load the source image of a farm field using `gdal_array`,
    which takes it straight into a NumPy array. We also define the name of our output
    image, which will be `ndvi.tif`. One interesting piece of this section is that
    we load the source image a second time using the `gdal` module, as opposed to
    `gdal_array`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'This second call is to capture the georeferencing data for the image that is
    available through `gdal`, and not `gdal_array`. Fortunately, `gdal` only loads
    raster data on demand, so this approach avoids loading the complete dataset into
    the memory twice. Once we have the data as a multidimensional NumPy array, we
    split out the red and infrared bands, as they will both be used in the NDVI equation:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that we have our data loaded, we can turn our shapefile into a raster.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Rasterizing the shapefile
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section begins the process of clipping. However, the first step is to rasterize
    the shapefile that outlines the boundary of the specific area that we are going
    to analyze. That area is within the larger `field.tif` satellite image. In other
    words, we convert it from vector data to raster data. But we also want to fill
    in the polygon when we convert it so that it can be used as an image mask. The
    pixels in the mask will be correlated to the pixels in the red and infrared arrays.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Any pixels outside the mask will be turned to `NODATA` pixels so they are not
    processed as part of the NDVI. To make this correlation, we'll need the solid
    polygon to be a NumPy array, just like the raster bands. This approach will make
    sure our NDVI calculation will be limited to the farm field.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to convert the shapefile polygon into a filled polygon as a
    NumPy array is to plot it as a polygon in a PIL image, fill that polygon in, and
    then convert it to a NumPy array using existing methods, in both PIL and NumPy,
    which allow that conversion.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we use the `ogr` module to read the shapefile, because we
    already have GDAL available. But, we could have also used PyShp to read the shapefile
    just as easily. If our farm field image was available as an ASCII Grid, we could
    have avoided using the `gdal`, `gdal_array`, and `ogr` modules altogether:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we open our shapefile and select the one and only layer:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There''s only one polygon, so we''ll grab that feature:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we''ll convert the layer extent to image pixel coordinates:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we calculate the pixel size of the new image:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we create a new blank image at the correct size:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we''re ready to clip the red and infrared bands using the bounding box:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we create the georeferencing information for the image:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then we can prepare to map points to pixels in order to create our mask image:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We loop through all of the point features and store their *x* and *y* values:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we convert the points to pixel locations:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we create a new image that will serve as our mask image:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we can rasterize our polygon:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, we can convert our mask to a `numpy` array:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now that we have converted the shapefile to a mask image, we can clip the bands.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Clipping the bands
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our image mask, we can clip the red and infrared bands to
    the boundary of the mask. For this process, we use NumPy''s `choose()` method
    that correlates the mask cell to the raster band cell and returns that value,
    or returns `0`. The result is a new array that is clipped to the mask, but with
    the correlated values from the raster band:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We now have just the data that we want, so we can apply our NDVI relative vegetation
    health formula.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Using the NDVI formula
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our final process for creating the NDVI is to execute the equation that is
    *infrared - red/infrared + red*. The first step that we perform silences any **not-a-number**,
    also known as **NaN**, values in NumPy that might occur during division. And before
    we save the output, we''ll convert any NaN values to `0`. We''ll save the output
    as `ndvi.tif`, and that will be the input for the next script in order to classify
    and colorize the NDVI as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll ignore any warnings from `numpy`, as we''ll get some errors near
    the edges:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we can perform our NDVI formula:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If there are any NaN values, we convert them to zero:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, we save our finished NDVI image:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following figure is the output of this example. You need to view it in
    a geospatial viewer such as QGIS or OpenEV. The image won''t open in most image
    editors. The lighter the shade of gray, the healthier the plant is within that
    field:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8bc38834-7ad5-40e8-81e9-32c2f8db7151.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: Now that we know how to use the NDVI formula, let's see how to classify it.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Classifying the NDVI
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a valid index, but it is not easy to understand, because it is a
    grayscale image. If we color the image in an intuitive way, then even a child
    can identify the healthier plants. In the following section, *Additional functions*,
    we read in this grayscale index and classify it from brown to dark green using
    seven classes. The classification and image processing routines, such as the histogram
    and stretching functions, are almost identical to what we used in the *Creating
    histograms* section in [Chapter 6](13990656-5786-445c-878b-8b262ad6f3c0.xhtml),
    *Python and Remote Sensing*, but this time we are applying them in a much more
    specific way.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: The output of this example will be another GeoTIFF file, but this time it will
    be a colorful RGB image.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Additional functions
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We won't need any of the functions from our previous NDVI script, but we do
    need to add a function for creating and stretching a histogram. Both of these
    functions work with NumPy arrays. We'll also shorten the reference to `gdal_array` to
    `gd` in this script because it is a long name, and we need it throughout the script.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the steps as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import the libraries that we need:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we need to create a `histogram` function, which we''ll need in order
    to do a histogram stretch:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, we create our histogram `stretch` function:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now that we have our utility functions, we can process the NDVI.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Loading the NDVI
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we''ll load the output of our NDVI script back into a NumPy array. We''ll
    also define the name of our output image as `ndvi_color.tif`, and create a zero-filled
    multidimensional array as a placeholder for the red, green, and blue bands of
    the colorized NDVI image. The following code will load the NDVI TIFF image into
    a `numpy` array:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now that our image is loaded as an array, we can stretch it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the NDVI
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to perform a histogram stretch on the NDVI in order to ensure that
    the image covers the range of classes that will give the final product meaning:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now that we've stretched the image, we can begin the classification process.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Creating classes
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, we set up the ranges for our NDVI classes, which are broken up
    across a range from 0 to 255\. We'll use seven classes. You can change the number
    of classes by adding or removing values from the classes list. Next, we create
    a **look-up table**, or **LUT**, in order to assign colors for each class. The
    number of colors must match the number of classes.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'The colors are defined as RGB values. The `start` variable defines the beginning
    of the first class. In this case, `0` is a nodata value, which we designated in
    the previous script, so we begin the class at `1`. We then loop through the classes,
    extract the ranges, and use the color assignments to add the RGB value to our
    placeholder array. Finally, we save the colorized image as a GeoTIFF file:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now we can classify the image:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, we can save our classified GeoTIFF file:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here is the image that we output:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/26dba7c4-7a58-48e6-9d4c-0a2d61becd64.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
- en: This is our final product for this example. Farmers can use this data to determine
    how to effectively irrigate and spray chemicals, such as fertilizers and pesticides,
    in a targeted, more effective, and more environmentally friendly way. In fact,
    these classes can even be turned into a vector shapefile, which is then loaded
    into a GPS-driven computer on a field sprayer. This then automatically applies
    the correct amount of chemicals in the correct place as a sprayer is driven around
    the field, or in some cases, even flown over the field in an airplane with a sprayer
    attachment.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Notice as well that even though we clipped the data to the field, the image
    is still a square. The black areas are the nodata values that have been converted
    to black. In display software, you can make the nodata color transparent without
    affecting the rest of the image.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Although we created a very specific type of product, a classified NDVI, the
    framework of this script can be altered in order to implement many remote sensing
    analysis algorithms. There are different types of NDVIs, but with relatively minor
    changes, you can turn this script into a tool that can be used to look for harmful
    algae blooms in the ocean, or smoke in the middle of a forest indicating a forest
    fire.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: This book attempts to limit the use of GDAL as much as possible in order to
    focus on what can be accomplished with pure Python and tools that can easily be
    installed from PyPI. However, it is helpful to remember that there is a wealth
    of information on using GDAL and its associated utilities to carry out similar
    tasks. For another tutorial on clipping a raster with GDAL via its command-line
    utilities, see [https://joeyklee.github.io/broc-cli-geo/guide/XX_raster_cropping_and_clipping.html](https://joeyklee.github.io/broc-cli-geo/guide/XX_raster_cropping_and_clipping.html).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've worked with the land, let's work with water in order to create
    a flood inundation model.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Creating a flood inundation model
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this next example, we'll begin to enter the world of hydrology. Flooding
    is one of the most common and devastating natural disasters, which affects nearly
    every population on the globe. Geospatial models are a powerful tool in estimating
    the impact of a flood and mitigating that impact before it happens. We often hear
    on the news that a river is reaching the flood stage, but that information is
    meaningless if we can't understand the impact.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Hydrological flood models are expensive to develop and can be very complex.
    These models are essential for engineers in building flood control systems. However,
    first responders and potential flood victims are only interested in the impact
    of an impending flood.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: We can begin to understand the flooding impact in an area using a very simple
    and easy-to-comprehend tool called a **flood inundation model**. This model starts
    with a single point and floods an area with the maximum volume of water that a
    flood basin can hold at a particular flood stage. Usually, this analysis is a
    worst-case scenario. Hundreds of other factors go into calculating how much water
    will enter into a basin from a river-topping flood stage. But we can still learn
    a lot from this simple first-order model.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in the *Elevation data* section in [Chapter 1](6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml),
    *Learning about Geospatial Analysis with Python*, the **Shuttle Radar Topography
    Mission** (**SRTM**) dataset provides a nearly-global DEM that you can use for
    these types of models. More on SRTM data can be found here: [http://www2.jpl.nasa.gov/srtm/](http://www2.jpl.nasa.gov/srtm/).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the ASCII Grid data in EPSG:4326, and a shapefile containing
    the point as a `.zip` file from [http://git.io/v3fSg](http://git.io/v3fSg). The
    shapefile is just for reference and has no role in this model. The following image is
    a **digital elevation model** (**DEM**) with a source point displayed as a yellow
    star near Houston, Texas. In real-world analysis, this point would likely be a
    stream gauge where you would have data about the river''s water level:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e7f70cc-0410-4925-9d89-c2355eb0d961.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
- en: The algorithm that we are introducing in this example is called a **flood fill
    algorithm**. This algorithm is well known in the field of computer science and
    is used in the classic computer game **Minesweeper** to clear empty squares on
    the board when a user clicks a square. It is also the method that is used for
    the well-known **paint bucket tool** in graphics programs such as **Adobe Photoshop**,
    and it is used to fill an area of adjacent pixels of the same color with a different
    color.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to implement this algorithm. One of the oldest and most
    common ways is to recursively crawl through each pixel of the image. The problem
    with recursion is that you end up processing pixels more than once and creating
    an unnecessary amount of work. The resource usage for a recursive flood fill can
    easily crash a program on even a moderately sized image.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: This script uses a four-way queue-based flood fill that may visit a cell more
    than once but ensures that we only process a cell once. The queue only contains
    unique, unprocessed cells by using Python's built-in set type, which only holds
    unique values. We use two sets: **fill**, which contains the cells we need to
    fill, and **filled**, which contains processed cells.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'This example executes the following steps:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Extract the header information from the ASCII DEM.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the DEM as a `numpy` array.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define our starting point as row and column in the array.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare a flood elevation value.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Filter the terrain to only the desired elevation value and below.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Process the filtered array.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a 1, 0, 0 array (that is, a binary array) with flooded pixels as 1.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the flood inundation array as an ASCII Grid.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This example can take a minute or two to run on a slower machine; we'll use
    the `print` statements throughout the script as a simple way to track progress.
    Once again we'll break this script up with explanations, for clarity.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our data, we can begin our flood fill function.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: The flood fill function
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We use ASCII Grids in this example, which means that the engine for this model
    is completely in NumPy. We start off by defining the `floodFill()` function, which
    is the heart and soul of this model. This Wikipedia article on flood fill algorithms
    provides an excellent overview of the different approaches: [http://en.wikipedia.org/wiki/Flood_fill](http://en.wikipedia.org/wiki/Flood_fill).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Flood fill algorithms start at a given cell and begin checking the neighboring
    cells for similarity. The similarity factor might be color or, in our case, elevation.
    If the neighboring cell is of the same or lower elevation as the current cell,
    then that cell is marked for checks of its neighbor until the entire grid is checked.
    NumPy isn't designed to crawl over an array in this way, but it is still efficient
    in handling multidimensional arrays overall. We step through each cell and check
    its neighbors to the north, south, east, and west. Any of those cells which can
    be flooded are added to the filled set, and their neighbors are added to the fill
    set to be checked by the algorithm.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, if you try to add the same value to a set twice, it just
    ignores the duplicate entry and maintains a unique list. By using sets in an array,
    we efficiently check a cell only once because the fill set contains unique cells.
    The following code implements our `floodFill` function:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'First we import our libraries:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, we create our `floodFill` function:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we create sets to track the cells that we''ve already covered:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then we create our inundation array:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now we can loop through the cells and flood them, or not:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If the land is higher than the floodwater, skip it:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If the land elevation is equal to or less than the floodwater, fill it in:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, we check the surrounding neighbor cells to see if they need to be filled,
    and when we run out of cells, we return the flooded matrix:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now that we've set up our `floodFill` function, we can create a flood.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Predicting flood inundation
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the remainder of the script, we load our terrain data from an ASCII Grid,
    define our output grid filename, and execute the algorithm on the terrain data.
    The seed of the flood fill algorithm is an arbitrary point, as `sx` and `sy` within
    the lower elevation areas. In a real-world application, these points would likely
    be a known location, such as a stream gauge or a breach in a dam. In the final
    step, we save the output grid.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps need to be performed:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we set up our `source` and `target` data names:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, we open the source:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We''ll create a mask array of everything below `70` meters:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, we''ll parse the geospatial information from the header:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, we''ll establish a starting point that is located in a riverbed:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, we trigger our `floodFill` function:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, we can save our flood inundation model output:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The image in the following screenshot shows the flood inundation output over
    a classified version of the DEM, with lower elevation values in brown, mid-range
    values in green, and higher values in gray and white:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4696dc35-3027-456b-9b02-a54473c43317.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
- en: The flood raster, which includes all areas less than 70 meters, is colored blue.
    This image was created with QGIS, but it could be displayed in ArcGIS as EPSG:4326\.
    You could also use GDAL to save the flood raster grid as an 8-bit TIFF file or
    JPEG file, just like the NDVI example, in order to view it in a standard graphics
    program.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'This image in the following screenshot is nearly identical, except for the
    filtered mask from which the inundation was derived, which is displayed in yellow.
    This is done by generating a file for the array called `wet`, instead of `fld`,
    to show the non-contiguous regions, which were not included as part of a flood.
    These areas are not connected to the source point, so they would unlikely be reached
    during a flood event:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/714014f4-74aa-4ba5-96ee-a99f77b6caca.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
- en: 'By changing the elevation value, you can create additional flood inundation
    rasters. We started with an elevation of 70 meters. If we increase that value
    to 90, we can expand the flood. The following screenshot shows a flood event at
    both 70 and 90 meters:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/499dbc17-5925-49a3-abc6-a7cf2a17be77.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
- en: The 90 meter inundation is the lighter-blue polygon. You can take bigger or
    smaller steps and show different impacts as different layers.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: This model is an excellent and useful visualization. However, you could take
    this analysis even further by using GDAL's `polygonize()` method on the flood
    mask, as we did with the island in the *Extracting features from images* section
    in [Chapter 6](13990656-5786-445c-878b-8b262ad6f3c0.xhtml), *Python and Remote
    Sensing*. This operation would give you a vector flood polygon. Then, you could
    use the principles that we discussed in the *Performing selections* section in
    [Chapter 5](306ed8f8-99dd-4751-b273-9d76cfac4ec2.xhtml), *Python and Geographic
    Information Systems*, to select buildings using the polygon to determine population
    impact. You could also combine that flood polygon with the dot density example
    in [Chapter 5](306ed8f8-99dd-4751-b273-9d76cfac4ec2.xhtml), *Python and Geographic
    Information Systems*, in the *Dot density calculations* section, to assess the
    potential population impact of a flood. The possibilities are endless.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Creating a color hillshade
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we'll combine previous techniques to combine our terrain hillshade
    from [Chapter 7](964b7276-1604-4df5-b549-6d8f61d5e9cb.xhtml), *Python and Elevation
    Data,* with the color classification that we used on the LIDAR. For this example,
    we'll need the ASCII Grid DEMs named `dem.asc` and `relief.asc` that we used in
    the previous chapter.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll create a colorized DEM and a hillshade, and then use PIL to blend them
    together for an enhanced elevation visualization. The code comments will guide
    you through the example, as many of these steps are already familiar to you:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import the libraries that we need:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: For this next part, you'll need the following two files: [https://github.com/GeospatialPython/Learn/raw/master/relief.zip](https://github.com/GeospatialPython/Learn/raw/master/relief.zip)
    and [https://github.com/GeospatialPython/Learn/raw/master/dem.zip](https://github.com/GeospatialPython/Learn/raw/master/dem.zip).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we''ll set up variables for the inputs and outputs:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, we''ll load our `relief` image:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, we''ll load the DEM image, so that we''ll have the elevation data:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, we''ll create a new image for our colorization with elevation breakpoints
    forming classes and corresponding colors in a LUT:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can now perform our color classification:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then, we can convert our shaded relief array to an image, as well as our colorized
    DEM:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, we''ll blend the two images for the final effect and save it to an image
    file:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The following image shows the output, which makes a great backdrop for GIS
    maps:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/20daa808-1730-438a-9f52-098550887189.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
- en: Now that we can model terrain, let's learn how to navigate over it.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Performing least cost path analysis
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Calculating driving directions is the most commonly used geospatial function
    in the world. Typically, these algorithms calculate the shortest path between
    points *A* and *B*, or they may take into account the speed limit of the road,
    or even current traffic conditions, in order to choose a route by drive time.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: But what if your job is to build a new road? Or what if you are in charge of
    deciding where to run power transmission lines or water lines across a remote
    area? In a terrain-based setting, the shortest path might cross a difficult mountain,
    or run through a lake. In this case, we need to account for obstacles and avoid
    them if possible. However, if avoiding a minor obstacle takes us too far out of
    our way, the cost of implementing that route may be more expensive than just going
    over a mountain.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: This type of advanced analysis is called **least cost path analysis**. We search
    an area for the route that is the best compromise of distance versus the cost
    of following that route. The algorithm that we use for this process is called
    the **A-star or A*** algorithm. The oldest routing method is called the **Dijkstra
    algorithm**, which calculates the shortest path in a network, such as a road network.
    The A* method can do that as well, but it is also better suited for traversing
    a grid-like DEM.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find out more about these algorithms on the following web pages:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Dijkstra's algorithm: [http://en.wikipedia.org/wiki/Dijkstra's_algorithm](http://en.wikipedia.org/wiki/Dijkstra's_algorithm).
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A* algorithm: [http://en.wikipedia.org/wiki/A-star_algorithm](http://en.wikipedia.org/wiki/A-star_algorithm).'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This example is the most complex in this chapter. To better understand it, we
    have a simple version of the program, which is text based, and operates on a 5
    x 5 grid with randomly generated values. You can actually see how this program
    follows the algorithm before trying it on an elevation grid with thousands of
    values.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'This program executes the following steps:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Create a simple grid with randomly generated pseudo-elevation values between
    1 and 16.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a start location in the lower-left corner of the grid.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the end point as the upper-right corner of the grid.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a cost grid that has the elevation of each cell, plus the cell's distance
    to the finish.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Examine each neighboring cell from the start, and choose the one with the lowest
    cost.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the evaluation using the chosen cell until we get to the end.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the set of chosen cells as the least cost path.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the test grid.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You simply run this program from the command line and view its output. The first
    section of this script sets up our artificial terrain grid as a randomly generated
    NumPy array, with notional elevation values between 1 and 16\. We also create
    a distance grid that calculates the distance for each cell to the destination
    cell. This value is the cost of each cell.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the following steps:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll import `numpy` and set the size of our grid:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Next, we set a starting location cell and an ending location:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, we can create a grid of zeros based on our width and height:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Next, we''ll set up our distance grid in order to create impedance values:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, we''ll print out the cost value of each cell in our cost grid:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Now that we have a simulated terrain grid to work with, we can test a routing
    algorithm.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: The simple A* algorithm
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The A* search algorithm that is implemented here crawls the grid in a similar
    fashion to our flood fill algorithm in the previous example. Once again, we use
    sets to avoid using recursion, and to avoid the duplication of cell checks. But
    this time, instead of checking elevation, we check the distance cost of routing
    through a cell in question. If the move raises the cost of getting to the end,
    then we go with a lower-cost option.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps need to be performed, as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll start our A* function by creating sets that will keep track of
    the path progress:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Next, we add the starting cell to the open list of cells in order to process
    and begin looping through that set:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We check the surrounding cells as options for forward progress:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We then check each option for the best option and append it to the path until
    we reach the end:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Now that we have the algorithm set up, we can test it out by creating a path.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Generating the test path
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll generate a path on our test grid. We''ll call our A*
    function, using the starting point, end point, cost grid, and distance grid:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now, we''ll put our path on its own grid and print it:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Next, we'll view the output of this test.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Viewing the test output
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you run this program, you''ll generate a randomly-numbered grid similar
    to the following:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The grid is small enough such that you can easily trace the algorithm's steps
    manually. This implementation uses **Manhattan distance**, which means the distance
    does not use diagonal lines—only left, right, up, and down measurements. The search
    also does not move diagonally in order to keep things simple.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: The real-world example
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a basic understanding of the A* algorithm, let's move to a
    more complex example. For the relief example, we'll use the same DEM that is located
    near Vancouver, British Columbia, Canada, which we used in [Chapter 7](964b7276-1604-4df5-b549-6d8f61d5e9cb.xhtml),
    *Python and Elevation Data*, in the *Creating a shaded relief* section. The spatial
    reference for this grid is EPSG:26910 NAD 83/UTM zone 10N. You can download the
    DEM, relief, and start and end points of the shapefile as a zipped package from [http://git.io/v3fpL](http://git.io/v3fpL).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll actually use the shaded relief for visualization. Our goal in this exercise
    will be to move from the start to the finish point in the lowest-cost way possible:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/100d0634-af6e-4cd1-b470-87d25217cda3.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
- en: 'Just looking at the terrain, there are two paths that follow low-elevation
    routes without much change in direction. These two routes are illustrated in the
    following screenshot:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c28f9cf-7567-4fd4-94c2-d2ad351c2988.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
- en: So, we would expect that when we used the A* algorithm, it would be close. Remember
    that the algorithm is only looking in the immediate vicinity, so it can't look
    at the whole image like we can, and it can't make adjustments early in the route
    based on a known obstacle ahead.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: We will expand this implementation from our simple example and use Euclidean
    distance, or *as the crow flies* measurements, and we will also allow the search
    to look in eight directions instead of four. We will prioritize terrain as the
    primary decision point. We will also use distance, both to the finish and from
    the start, as lower priorities in order to make sure that we are moving forward
    toward the goal and not getting too far off track. Other than those differences,
    the steps are identical to the simple example. The output will be a raster with
    the path values set to one and the other values set to zero.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the problem, let's solve it!
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Loading the grid
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section and the following sections, we''ll create the script that can
    create a route over terrain. The script starts out simple enough. We load the
    grid into a NumPy array from an ASCII Grid. We name our output path grid, and
    then we define the starting cell and end cell:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import our libraries:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Next, we''ll define our input and output data sources:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Then, we can load the grid skipping over the header:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Next, we''ll parse the header for the geospatial and grid size information:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Finally, we''ll define our starting and end locations:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Now that our grid is loaded, we can set up the functions that we'll need.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Defining the helper functions
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need three functions in order to route over terrain. One is the A* algorithm,
    and the other two assist the algorithm in choosing the next step. We'll briefly
    discuss these helper functions. First, we have a simple Euclidean distance function
    named `e_dist`, which returns the straight-line distance between two points as
    map units. Next, we have an important function called `weighted_score`, which
    returns a score for a neighboring cell, based on the elevation change between
    the neighbor and the current cell, as well as the distance to the destination.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: This function is better than distance or elevation alone because it reduces
    the chance of there being a tie between two cells, making it easier to avoid back-tracking.
    This scoring formula is loosely based on a concept called the **Nisson Score**,
    which is commonly used in these types of algorithms and is referenced in the Wikipedia
    articles mentioned earlier in this chapter. What's great about this function is
    that it can score the neighboring cell with any values that you wish. You might
    also use a real-time feed to look at the current weather in the neighboring cell,
    and avoid cells with rain or snow.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code will create our distance function and our weighting function
    that we''ll need to traverse the terrain:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll create a Euclidean distance function that will give us the distance
    between points:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now, we''ll create our weight function in order to score each node for its
    suitability to move:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We start with a `score` of `0` and check the node''s distance from the end
    and the start:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Next, we examine the neighboring nodes and make a decision on where to move:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Now that our helper functions are complete, we can build the A* function.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: The real-world A* algorithm
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This algorithm is more involved than the simple version in our previous example.
    We use sets to avoid redundancy. It also implements our more advanced scoring
    algorithm and checks to make sure we aren''t at the end of the path before doing
    additional calculations. Unlike our last example, this more advanced version also
    checks cells in eight directions, so the path can move diagonally. There is a
    `print` statement at the end of this function that is commented out. You can uncomment
    it in order to watch the search crawl through the grid. The following code will
    implement the A* algorithm that we will use for the rest of the section:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we open the function by accepting a starting point, an end point, and
    a score:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now, we set up the sets that will track progress:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Next, we begin processing using our starting point:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'If we hit the end, we return the completed path:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Otherwise, we keep working through the grid and eliminating possibilities:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'To keep things moving, we grab all of the neighbors that need to be processed
    as we go:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We check each neighbor for being the destination:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We take the first option as the `best` option and process the other options,
    upgrading as we go:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Now that we have our routing algorithm, we can generate a real-world path.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Generating a real-world path
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we create our real-world path as a chain of ones in a grid of zeros.
    This raster can then be brought into an application such as QGIS and visualized
    over the terrain grid. In the following code, we''ll use our algorithm and helper
    functions to generate a path, as follows:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we send our start and end points, as well as our terrain grid, to the
    routing function:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Once we have a path, we can save it out as an ASCII Grid:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Now, we want to save our path data because the points are in the correct order,
    from the starting point to the end point. When we put them into the grid, we lose
    that order because it is all one raster. We''ll use the built-in Python `pickle`
    module to save the list object to disk. We''re going to use this data in the next
    section to create a vector shapefile of the route. So, we''ll save our path data
    as a pickled Python object that we can reuse later, without running the whole
    program:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Here is the output route of our search:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/931aa6a2-3312-40cf-86c0-fb529190bf04.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the A* search came very close to one of our manually selected
    routes. In a couple of cases, the algorithm chose to tackle some terrain, instead
    of trying to go around it. Sometimes the slight terrain is deemed less of a cost
    than the distance to go around it. You can see examples of that choice in this
    zoomed-in portion of the upper-right section of the route. The red line is the
    route that our program generated through the terrain:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b4471f0d-911d-4874-9da1-fef9899f8455.png)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
- en: 'We only used two values: terrain and distance. But you could also add hundreds
    of factors, such as soil type, water bodies, and existing roads. All of these
    items could serve as an impedance or an outright wall. You would just modify the
    scoring function in the example to account for any additional factors. Keep in
    mind, the more factors you add, the more difficult it is to trace what the A*
    implementation was *thinking* when it chose the route.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: An obvious future direction for this analysis would be to create a vector version
    of this route as a line. The process would include mapping each cell to a point
    and then using nearest-neighbor analysis to order the points properly, before
    saving it as a shapefile or GeoJSON file.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: Converting the route to a shapefile
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The raster version of the least cost path route is useful for visualization,
    but it isn''t much good for analysis because it is embedded in the raster, and
    it is, therefore, difficult to relate to other datasets as we have done so many
    other times in this book. Our next goal will be to use the path data that we saved
    when creating the route to create a shapefile since the saved data is in the proper
    order. The following code will convert our raster path to a shapefile that is
    easier to use in a GIS for analysis:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll import the modules that we need, which aren''t many. We''ll use
    the `pickle` module to restore the path `data` object. Then, we''ll use the `linecache`
    module to read the geospatial header information from the path raster in order
    to map the path rows and columns to the earth coordinates. Finally, we''ll use
    the `shapefile` module to export the shapefile:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Next, we''ll create a function to convert rows and columns to *x* and *y* coordinates.
    The function accepts the metadata header information from the path raster file,
    as well as the column and row number:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Now, we''ll restore the `path` object from the pickled object:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Then, we''ll parse the metadata information from the path raster file:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Next, we need a list object to hold the converted coordinates:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Now, we convert each raster location from the least cost path object into a
    geospatial coordinate and store it in the list that we created:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Finally, with just a few lines, we write out a line shapefile:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Good work! You have created a program that can automatically navigate through
    obstacles, based on a set of rules, and exported it to a file that you can display
    and analyze in a GIS! We only used three rules, but you can add additional restrictions
    on how the program picks a path by adding other datasets, such as weather or water
    bodies, or anything else you can imagine.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand blazing a path across an arbitrary surface, we'll look
    at routing through a network.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: Calculating satellite image cloud cover
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Satellite images give us a powerful bird's-eye view of the Earth. They are useful
    for a variety of purposes, which we saw in [Chapter 6](13990656-5786-445c-878b-8b262ad6f3c0.xhtml),
    *Python and Remote Sensing*. However, they have one flaw—clouds. As a satellite
    passes around the Earth and collects imagery, it inevitably images clouds. And
    in addition to obstructing our view of the Earth, the cloud data can adversely
    affect remote sensing algorithms by wasting CPU cycles on useless cloud data,
    or skew the results by introducing unwanted data values.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: The solution is to create a cloud mask. A cloud mask is a raster that isolates
    the cloud data in a separate raster. You can then use that raster as a reference
    when processing the image in order to avoid cloud data, or you can even use it
    to remove the clouds from the original image.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we''ll create a cloud mask for a Landsat image using the `rasterio`
    module and the `rio-l8qa` plugin. The cloud mask will be created as a separate
    image that just contains clouds:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to download some sample Landsat 8 satellite image data as a ZIP
    file from [http://bit.ly/landsat8data](http://bit.ly/landsat8data).
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the download icon in the top right to download the data as a ZIP file,
    and unzip it to a directory named `l8`.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, make sure you have the raster libraries that we need by running `pip`:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Now, we''ll create the cloud mask by first importing the libraries that we
    need:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Next, we need to provide a reference to our satellite image directory:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Now, we need to locate the quality-assurance metadata for the satellite data,
    which gives us the information that we need to generate the cloud mask:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Finally, we use the quality-assurance file to create a cloud mask TIFF file:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The following image is just the band 7 (short-wave infrared) image from the
    Landsat 8 dataset:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ba31b2b-92f2-4011-8886-cb094f201bef.png)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
- en: 'The next image is the cloud mask image containing only the location of clouds
    and shadows:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1379f25-777b-405a-b3e8-f67fb7d071f3.png)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
- en: 'And finally, here''s the mask over the image, showing the clouds as black:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e4c9c790-616c-47ed-a00c-14016e0d066d.png)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
- en: This example brushes the surface of what you can do with image masking. Another
    `rasterio` module, `rio-cloudmask`, allows you to calculate the cloud mask from
    scratch without using the quality-assurance data. But it requires some additional
    pre-processing steps. You can learn more about that here: [https://github.com/mapbox/rio-cloudmask.](https://github.com/mapbox/rio-cloudmask)
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: Routing along streets
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Routing along streets uses a connected network of lines, which is called a graph.
    The lines in the graph can have impedance values, which discourage a routing algorithm
    from including them in a route. Examples of impedance values often include traffic
    volume, speed limit, or even distance. A key requirement for a routing graph is
    that all of the lines, known as edges, must be connected. Road datasets that are
    created for mapping will often have lines whose nodes do not intersect.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we'll calculate the shortest route through a graph by distance.
    We'll use a start and end point, which are not nodes in the graph, meaning we'll
    have to first find the graph nodes that are the closest to our start and destination
    points.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: To calculate the shortest route, we'll use a powerful pure Python graph library
    called NetworkX. NetworkX is a general network graphing library that can create,
    manipulate, and analyze complex networks, including geospatial networks. If `pip`
    does not install NetworkX on your system, then you can find instructions for downloading
    and installing NetworkX for different operating systems at [http://networkx.readthedocs.org/en/stable/](http://networkx.readthedocs.org/en/stable/).
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the road network and the start and end points, which are located
    along the U.S. Gulf Coast, as a ZIP file from [http://git.io/vcXFQ](http://git.io/vcXFQ).
    Then, you can follow these steps:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll need to import the libraries we''re going to use. In addition
    to NetworkX, we’ll use the PyShp library in order to read and write shapefiles:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Next, we''ll define the current directory as our output directory for the route
    shapefile that we''ll create:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Now, we’ll need a function that can calculate the distance between points in
    order to populate the impedance values of our graph and to find the nodes closest
    to our start and destination points for the route:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Then, we''ll create another function, which returns pairs of points from a
    list, to give us the line segments that we''ll use to build our graph edges:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Now, we''ll define our road network shapefile. This road network is a subset
    of a U.S. interstate highway files shapefile from the **United States Geological
    Survey** (**USGS**), which has been edited to ensure all the roads are connected:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Next, we''ll create a graph with NetworkX and add the shapefile segments as
    graph edges:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Then, we can extract the connected components as a subgraph. However, in this
    case, we''ve ensured that the entire graph is connected:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Next, we can read in the `start` and `end` points that we want to navigate:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Now, we loop through the graph, and assign distance values to each edge, using
    our `haversine` formula:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Next, we must find the nodes in the graph that are the closest to our start
    and end points, in order to begin and end our route by looping through all of
    the nodes, and measuring the distance to our end points until we find the shortest
    distance:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Now, we are ready to calculate the shortest distance through our road network:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Finally, we''ll add the results to the shapefile and save our route:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The following screenshot shows the road network in light gray, the start and
    end points, and the route in black. You can see that the route cuts across the
    road network in order to reach the road that is the nearest to the end point in
    the shortest possible distance:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/76184867-4eac-4033-a072-0e4d76b85f28.png)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
- en: Now that we know how to create various types of routes, we can look at locating
    photos that you might take while traveling along a route.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: Geolocating photos
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Photos that are taken with GPS-enabled cameras, including smartphones, store
    location information in the header of the file in a format called **EXIF** tags.
    These tags are based largely on the same header tags that are used by the TIFF
    image standard. In this example, we'll use those tags to create a shapefile with
    point locations for the photos, and file paths to the photos, as attributes.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use the PIL in this example because it has the ability to extract EXIF
    data. Most photos that are taken with smartphones are geotagged images; however,
    you can download the set used in this example from [https://git.io/vczR0](http://git.io/vczR0):'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll import the libraries that we need, including PIL for the image
    metadata and PyShp for the shapefiles:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Now, we''ll need three functions. The first function extracts the EXIF data.
    The second function converts **degree, minutes, seconds** (**DMS**) coordinates
    to decimal degrees (EXIF data stores GPS data as DMS coordinates). The third function
    extracts the GPS data and performs the coordinate conversion:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Next, we will loop through the photos, extract the coordinates, and store the
    coordinates and filename in a dictionary:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Now, we will save the photo information as a shapefile:'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The filenames of the photos in the shapefile are now attributes of the point
    locations where the photos were taken. GIS programs including QGIS and ArcGIS
    have the tools to turn those attributes into links when you click on the photo
    path or the point. The following screenshot from QGIS shows that one of the photos
    opens after clicking on the associated point using the Run Feature Action tool:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f2c3918e-5f85-4a8f-aa32-2da3fcf5192e.png)'
  id: totrans-446
  prefs: []
  type: TYPE_IMG
- en: 'To view the result, please use the following instructions:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: Download QGIS from [https://qgis.org](http://qgis.org) and follow the installation
    instructions.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open QGIS and drag the `photos.shp` file onto the blank map.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Layer panel on the left, right-click the layer named Photos and select
    Properties.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the Actions tab, click the green plus sign to open the new actions dialog.
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Type drop-down menu, select Open.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Description field, enter Open Image.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the Insert button in the lower-right corner.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the OK button, and then close the properties dialog.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the small black arrow to the right of the Run Feature Action tool,
    which is a gear icon with a green center and a white arrow in it.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击运行功能工具右侧的小黑箭头，该工具是一个带有绿色中心和白色箭头的齿轮图标。
- en: In the menu that pops up, choose Open Image.
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在弹出的菜单中，选择打开图片。
- en: Now, click on one of the points on the map to see the geotagged image popup.
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击地图上的一个点，查看带有地理标签的图片弹出窗口。
- en: Now, let's move from an image taken on the Earth, to images taken of the Earth
    itself, by working with satellite images.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从在地球上拍摄的图片，转到拍摄地球本身的图片，通过处理卫星图像来实现。
- en: Summary
  id: totrans-460
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to create three real-world products, which are
    used every day in government, science, and industry. Apart from where this analysis
    is typically done with **black box** packages—costing thousands of dollars—we
    were able to use very minimal and free cross-platform Python tools. And in addition
    to the examples in this chapter, you now have some more reusable functions, algorithms,
    and processing frameworks for other advanced analyses, which will allow you to
    solve new problems that you come across in fields such as transportation, agriculture,
    and weather.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何创建三个现实世界的产品，这些产品在政府、科学和工业中每天都会使用。除了这种分析通常使用成本数千美元的**黑盒**软件包之外，我们能够使用非常少和免费的跨平台Python工具。而且除了本章中的示例之外，你现在还有一些可重用的函数、算法和用于其他高级分析的处理框架，这将使你能够解决你在交通、农业和天气等领域遇到的新问题。
- en: 'In the next chapter, we''ll move into a relatively new area of geospatial analysis:
    real-time and near real-time data.'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进入地理空间分析的一个相对较新的领域：实时和近实时数据。
