- en: Advanced Geospatial Python Modeling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级地理空间Python建模
- en: In this chapter, we'll build on the data processing concepts that we've learned
    in order to create some full-scale information products. The previously introduced
    data processing methods rarely provide answers to questions by themselves. You
    combine these data processing methods to build a geospatial model from multiple
    processed datasets. A geospatial model is a simplified representation of some
    aspect of the real world, which helps us answer one or more questions about a
    project or problem. In this chapter, we will introduce some important geospatial
    algorithms that are commonly used in agriculture, emergency management, logistics,
    and other industries.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将基于我们已经学习的数据处理概念来创建一些全规模的信息产品。之前介绍的数据处理方法很少能单独提供答案。您将这些数据处理方法结合起来，从多个处理后的数据集中构建一个地理空间模型。地理空间模型是现实世界某个方面的简化表示，有助于我们回答一个或多个关于项目或问题的疑问。在本章中，我们将介绍一些在农业、应急管理、物流和其他行业中常用的重要地理空间算法。
- en: 'The products that we will create are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建以下产品：
- en: A crop health map
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作物健康图
- en: A flood inundation model
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 洪水淹没模型
- en: A colorized hillshade
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 彩色等高线
- en: A terrain routing map
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地形路由图
- en: A street routing map
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 街道路由图
- en: A shapefile with links to geolocated photos
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含地理定位照片的shapefile
- en: 'While these products are task-specific, the algorithms that are used to create
    them are widely applied in geospatial analysis. We will be covering the following
    topics in this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些产品是针对特定任务的，但用于创建它们的算法在地理空间分析中得到了广泛应用。在本章中，我们将涵盖以下主题：
- en: Creating a normalized difference vegetative index (NVDI)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建归一化植被指数（NVDI）
- en: Creating a flood inundation model
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建洪水淹没模型
- en: Creating a color hillshade
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建彩色等高线
- en: Performing least cost path analysis
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行最低成本路径分析
- en: Converting the route to a shapefile
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将路线转换为shapefile
- en: Routing along streets
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 沿街道路由
- en: Geolocating photos
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地理定位照片
- en: Calculating satellite image cloud cover
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算卫星图像云覆盖率
- en: The examples in this chapter are longer and more involved than in the previous
    chapters. For that reason, there are far more code comments to make the programs
    easier to follow. We will also use more functions in these examples. In previous
    chapters, functions were mostly avoided for clarity, but these examples are sufficiently
    complex that certain functions make the code easier to read. These examples are
    actual processes that you would use on the job as a geospatial analyst.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例比前几章更长、更复杂。因此，有更多的代码注释来使程序更容易理解。我们还将在这些建议中使用更多函数。在前几章中，为了清晰起见，通常避免使用函数，但这些示例足够复杂，某些函数可以使代码更容易阅读。这些示例是您作为地理空间分析师在工作中会使用的实际过程。
- en: Technical requirements
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, the following requirements need to be satisfied:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，需要满足以下要求：
- en: '**Version**: Python 3.6 or higher'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本**：Python 3.6或更高版本'
- en: '**RAM**: Minimum 6 GB (Windows), 8 GB (macOS); recommended 8 GB'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RAM**：最小6 GB（Windows），8 GB（macOS）；推荐8 GB'
- en: '**Storage**: Minimum 7,200 RPM SATA with 20 GB of available space, recommended
    SSD with 40 GB of available space.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储**：最小7200 RPM SATA，可用空间20 GB，推荐使用具有40 GB可用空间的SSD。'
- en: '**Processor**: Minimum Intel Core i3 2.5 GHz, recommended Intel Core i5.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理器**：最小Intel Core i3 2.5 GHz，推荐Intel Core i5。'
- en: Creating a normalized difference vegetative index
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建归一化植被指数
- en: 'Our first example will be an **normalized difference vegetative index** (**NVDI**). NDVIs
    are used to show the relative health of plants in an area of interest. An NDVI
    algorithm uses satellite or aerial imagery to show relative health by highlighting
    the chlorophyll density in plants. NDVIs use only the red and near-infrared bands.
    The formula of NDVI is as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个示例将是一个**归一化植被指数**（**NVDI**）。NDVIs用于显示感兴趣区域内植物的相对健康状况。NDVI算法使用卫星或航空影像通过突出植物中的叶绿素密度来显示相对健康状况。NDVIs仅使用红色和近红外波段。NDVI的公式如下：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The goal of this analysis is to produce, to begin with, a multispectral image
    containing infrared and red bands, and end up with a pseudo color image using
    seven classes, which color the healthier plants darker green, less-healthy plants
    lighter green, and bare soil brown.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本分析的目标是首先生成一个包含红外和红波段的彩色图像，最终使用七个类别生成伪彩色图像，这些类别将健康的植物着色为深绿色，不太健康的植物着色为浅绿色，裸土为棕色。
- en: Because the health index is relative, it is important to localize the area of
    interest. You could perform a relative index for the entire globe but vast areas,
    such as the Sahara desert on the low-vegetation extreme and densely forested areas,
    such as the Amazon jungle, skew the results for vegetation in the middle range.
    However, that being said, climate scientists routinely create global NDVIs to
    study worldwide trends. The more common application, though, is for managed areas,
    such as a forest or a farm field, as in this example.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于健康指数是相对的，因此定位感兴趣区域非常重要。您可以对整个地球进行相对指数计算，但像撒哈拉沙漠这样的低植被极端地区和像亚马逊雨林这样的密集森林地区会扭曲中等植被范围的结果。然而，尽管如此，气候科学家通常会创建全球NDVI来研究全球趋势。尽管如此，最常见的应用是针对管理区域，例如森林或农田，就像这个例子一样。
- en: 'We will begin with an analysis of a single farm field in the Mississippi Delta.
    To do so, we''ll start with a multispectral image of a fairly large area and use
    a shapefile in order to isolate a single field. The image in the following screenshot
    is our broad area, with the field of interest highlighted in yellow:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从密西西比三角洲的一个单一农田的分析开始。为此，我们将从一个相当大的区域的多光谱图像开始，并使用shapefile来隔离单个农田。以下截图中的图像是我们的大区域，感兴趣的区域用黄色突出显示：
- en: '![](img/7918c9ce-706d-4b4f-a71e-ba3e85c2e0cd.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7918c9ce-706d-4b4f-a71e-ba3e85c2e0cd.png)'
- en: You can download this image and the shapefile for the farm field as a ZIP file
    from [http://git.io/v3fS9](http://git.io/v3fS9).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://git.io/v3fS9](http://git.io/v3fS9)下载此图像和农田的shapefile作为ZIP文件。
- en: 'For this example, we''ll use GDAL, OGR, `gdal_array`/`numpy`, and the **Python
    Imaging Library** (**PIL**) to clip and process the data. In the other examples
    in this chapter, we''ll just use simple ASCII Grids and NumPy. As we''ll be using
    ASCII elevation grids, GDAL isn''t required. In all examples, the scripts use
    the following convention:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用GDAL、OGR、`gdal_array`/`numpy`和**Python图像库**（**PIL**）来裁剪和处理数据。在本章的其他示例中，我们只需使用简单的ASCII网格和NumPy。由于我们将使用ASCII高程网格，因此不需要GDAL。在所有示例中，脚本都遵循以下约定：
- en: Import libraries.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入库。
- en: Define functions.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义函数。
- en: Define global variables, such as filenames.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义全局变量，例如文件名。
- en: Execute the analysis.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行分析。
- en: Save the output.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存输出。
- en: 'Our approach to the crop health example is split into two scripts. The first
    script creates the index image, which is a grayscale image. The second script
    classifies the index and outputs a colored image. In this first script, we''ll
    execute the following steps to create the index image:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对作物健康示例的方法分为两个脚本。第一个脚本创建索引图像，这是一个灰度图像。第二个脚本对索引进行分类并输出彩色图像。在这个第一个脚本中，我们将执行以下步骤来创建索引图像：
- en: Read the infrared band.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取红外波段。
- en: Read the field boundary shapefile.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取农田边界shapefile。
- en: Rasterize the shapefile to an image.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将shapefile栅格化成图像。
- en: Convert the shapefile image to a NumPy array.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将形状文件图像转换为NumPy数组。
- en: Use the NumPy array to clip the red band to the field.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用NumPy数组将红波段裁剪到农田。
- en: Do the same for the infrared band.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对红外波段也执行相同的操作。
- en: Use the band arrays to execute the NDVI algorithm in NumPy.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用波段数组在NumPy中执行NDVI算法。
- en: Save the resulting indexing algorithm to a GeoTIFF file using `gdal_array`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`gdal_array`将结果索引算法保存到GeoTIFF文件中。
- en: We will discuss this script in sections to make it easier to follow. The code
    comments will also tell you what is going on at each step of the way.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分节讨论此脚本，以便更容易理解。代码注释也会告诉你每一步正在发生什么。
- en: Setting up the framework
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置框架
- en: 'Setting up the framework will help us to import the modules that we need and
    set up the functions that we''ll use for steps 1 to 5 of the preceding instructions.
    The `imageToArray()` function converts a PIL image to a NumPy array and is dependent
    on the `gdal_array` and PIL modules. The `world2Pixel()` function converts geospatial
    coordinates to the pixel coordinates of our target image. This function uses the
    georeferencing information that is presented by the `gdal` module. The `copy_geo()`
    function copies the georeferencing information from our source image to our target
    array but accounts for the offset that is created when we clip the image. These
    functions are fairly generic and can serve a role in a variety of different remote
    sensing processes beyond this example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 设置框架将帮助我们导入所需的模块，并设置我们将用于先前指令步骤1到5的函数。`imageToArray()`函数将PIL图像转换为NumPy数组，并依赖于`gdal_array`和PIL模块。`world2Pixel()`函数将地理坐标转换为目标图像的像素坐标。此函数使用`gdal`模块提供的地理参考信息。`copy_geo()`函数将源图像的地理参考信息复制到目标数组，但考虑到我们在裁剪图像时创建的偏移。这些函数相当通用，可以在各种不同的遥感过程中发挥作用，而不仅仅是本例：
- en: 'First, we import our libraries:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入我们的库：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we need a function to convert an image to a `numpy` array:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要一个函数将图像转换为`numpy`数组：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we''ll set up a function to convert the coordinates to image pixels:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将设置一个函数来将坐标转换为图像像素：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, we''ll create a function to copy geographic metadata from an image:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个函数来复制图像的地理元数据：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The next step is to load the data, which we'll be checking in the next section.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是加载数据，我们将在下一节中检查。
- en: Loading the data
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载数据
- en: In this section, we load the source image of a farm field using `gdal_array`,
    which takes it straight into a NumPy array. We also define the name of our output
    image, which will be `ndvi.tif`. One interesting piece of this section is that
    we load the source image a second time using the `gdal` module, as opposed to
    `gdal_array`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用`gdal_array`加载农田的源图像，将其直接转换为NumPy数组。我们还定义了输出图像的名称，它将是`ndvi.tif`。本节中一个有趣的部分是，我们使用`gdal`模块而不是`gdal_array`再次加载源图像。
- en: 'This second call is to capture the georeferencing data for the image that is
    available through `gdal`, and not `gdal_array`. Fortunately, `gdal` only loads
    raster data on demand, so this approach avoids loading the complete dataset into
    the memory twice. Once we have the data as a multidimensional NumPy array, we
    split out the red and infrared bands, as they will both be used in the NDVI equation:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次调用是为了捕获通过`gdal`而不是`gdal_array`提供的图像的地理参考数据。幸运的是，`gdal`仅在需要时加载栅格数据，因此这种方法避免了将整个数据集两次加载到内存中。一旦我们有了多维NumPy数组的数据，我们就将红色和红外波段分离出来，因为它们都将用于NDVI方程：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that we have our data loaded, we can turn our shapefile into a raster.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经加载了数据，我们可以将我们的shapefile转换为栅格数据。
- en: Rasterizing the shapefile
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将shapefile栅格化
- en: This section begins the process of clipping. However, the first step is to rasterize
    the shapefile that outlines the boundary of the specific area that we are going
    to analyze. That area is within the larger `field.tif` satellite image. In other
    words, we convert it from vector data to raster data. But we also want to fill
    in the polygon when we convert it so that it can be used as an image mask. The
    pixels in the mask will be correlated to the pixels in the red and infrared arrays.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 本节开始裁剪的过程。然而，第一步是将我们打算分析的特定区域的边界shapefile栅格化。该区域位于更大的`field.tif`卫星图像内。换句话说，我们将它从矢量数据转换为栅格数据。但我们还希望在转换时填充多边形，以便它可以作为图像掩码使用。掩码中的像素将与红色和红外数组中的像素相关联。
- en: Any pixels outside the mask will be turned to `NODATA` pixels so they are not
    processed as part of the NDVI. To make this correlation, we'll need the solid
    polygon to be a NumPy array, just like the raster bands. This approach will make
    sure our NDVI calculation will be limited to the farm field.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 任何在掩码之外的像素将被转换为`NODATA`像素，这样它们就不会作为NDVI的一部分进行处理。为了进行这种相关性，我们需要将实心多边形转换为NumPy数组，就像栅格波段一样。这种方法将确保我们的NDVI计算仅限于农田。
- en: The easiest way to convert the shapefile polygon into a filled polygon as a
    NumPy array is to plot it as a polygon in a PIL image, fill that polygon in, and
    then convert it to a NumPy array using existing methods, in both PIL and NumPy,
    which allow that conversion.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 将shapefile多边形转换为填充多边形作为NumPy数组的简单方法是将它作为PIL图像中的多边形绘制出来，填充该多边形，然后使用PIL和NumPy中现有的方法将其转换为NumPy数组，这些方法允许进行该转换。
- en: 'In this example, we use the `ogr` module to read the shapefile, because we
    already have GDAL available. But, we could have also used PyShp to read the shapefile
    just as easily. If our farm field image was available as an ASCII Grid, we could
    have avoided using the `gdal`, `gdal_array`, and `ogr` modules altogether:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`ogr`模块来读取shapefile，因为我们已经有了GDAL。但，我们也可以同样容易地使用PyShp来读取shapefile。如果我们的农田图像可用作ASCII网格，我们可以完全避免使用`gdal`、`gdal_array`和`ogr`模块：
- en: 'First, we open our shapefile and select the one and only layer:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们打开我们的shapefile并选择唯一的图层：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There''s only one polygon, so we''ll grab that feature:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有一个多边形，所以我们将获取该特征：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we''ll convert the layer extent to image pixel coordinates:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将图层范围转换为图像像素坐标：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we calculate the pixel size of the new image:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们计算新图像的像素大小：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we create a new blank image at the correct size:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个正确大小的空白图像：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we''re ready to clip the red and infrared bands using the bounding box:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们准备好使用边界框裁剪红光和红外波段：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we create the georeferencing information for the image:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们为图像创建地理参考信息：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then we can prepare to map points to pixels in order to create our mask image:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以准备将点映射到像素以创建我们的掩码图像：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We loop through all of the point features and store their *x* and *y* values:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们遍历所有点特征并存储它们的*x*和*y*值：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we convert the points to pixel locations:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将点转换为像素位置：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we create a new image that will serve as our mask image:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个新的图像，该图像将作为我们的掩码图像：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we can rasterize our polygon:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以将我们的多边形栅格化：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, we can convert our mask to a `numpy` array:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以将我们的掩码转换为`numpy`数组：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now that we have converted the shapefile to a mask image, we can clip the bands.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将shapefile转换为掩码图像，我们可以裁剪波段。
- en: Clipping the bands
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 裁剪波段
- en: 'Now that we have our image mask, we can clip the red and infrared bands to
    the boundary of the mask. For this process, we use NumPy''s `choose()` method
    that correlates the mask cell to the raster band cell and returns that value,
    or returns `0`. The result is a new array that is clipped to the mask, but with
    the correlated values from the raster band:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的图像掩码，我们可以将红光和红外波段裁剪到掩码的边界。为此过程，我们使用NumPy的`choose()`方法，该方法将掩码单元格与栅格波段单元格相关联并返回该值，或返回`0`。结果是一个新的数组，裁剪到掩码，但带有来自栅格波段的关联值：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We now have just the data that we want, so we can apply our NDVI relative vegetation
    health formula.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只得到了我们想要的数据，因此我们可以应用我们的NDVI相对植被健康公式。
- en: Using the NDVI formula
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NDVI公式
- en: 'Our final process for creating the NDVI is to execute the equation that is
    *infrared - red/infrared + red*. The first step that we perform silences any **not-a-number**,
    also known as **NaN**, values in NumPy that might occur during division. And before
    we save the output, we''ll convert any NaN values to `0`. We''ll save the output
    as `ndvi.tif`, and that will be the input for the next script in order to classify
    and colorize the NDVI as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建NDVI的最终过程是执行方程式*红外 - 红光/红外 + 红光*。我们执行的第一步是消除NumPy中可能发生的任何**非数字**（NaN）值，也称为**NaN**。在我们保存输出之前，我们将任何NaN值转换为`0`。我们将输出保存为`ndvi.tif`，这将是下一个脚本的输入，以便对NDVI进行分类和着色如下：
- en: 'First, we''ll ignore any warnings from `numpy`, as we''ll get some errors near
    the edges:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将忽略来自`numpy`的任何警告，因为我们将在边缘附近遇到一些错误：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we can perform our NDVI formula:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以执行我们的NDVI公式：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If there are any NaN values, we convert them to zero:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有任何NaN值，我们将它们转换为零：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, we save our finished NDVI image:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们保存我们的完成NDVI图像：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following figure is the output of this example. You need to view it in
    a geospatial viewer such as QGIS or OpenEV. The image won''t open in most image
    editors. The lighter the shade of gray, the healthier the plant is within that
    field:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图是本例的输出。您需要使用地理空间查看器（如QGIS或OpenEV）查看它。在大多数图像编辑器中无法打开该图像。灰色越浅，该字段内的植物越健康：
- en: '![](img/8bc38834-7ad5-40e8-81e9-32c2f8db7151.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8bc38834-7ad5-40e8-81e9-32c2f8db7151.png)'
- en: Now that we know how to use the NDVI formula, let's see how to classify it.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何使用NDVI公式，让我们看看如何对其进行分类。
- en: Classifying the NDVI
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分类NDVI
- en: We now have a valid index, but it is not easy to understand, because it is a
    grayscale image. If we color the image in an intuitive way, then even a child
    can identify the healthier plants. In the following section, *Additional functions*,
    we read in this grayscale index and classify it from brown to dark green using
    seven classes. The classification and image processing routines, such as the histogram
    and stretching functions, are almost identical to what we used in the *Creating
    histograms* section in [Chapter 6](13990656-5786-445c-878b-8b262ad6f3c0.xhtml),
    *Python and Remote Sensing*, but this time we are applying them in a much more
    specific way.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个有效的索引，但它不容易理解，因为它是一个灰度图像。如果我们以直观的方式给图像上色，那么即使是孩子也能识别出更健康的植物。在下一节 *额外函数*
    中，我们读取这个灰度索引，并使用七个类别将其从棕色分类到深绿色。分类和图像处理例程，如直方图和拉伸函数，几乎与我们在第 6 章 *Python 和遥感* 中
    *创建直方图* 部分使用的相同，但这次我们以更具体的方式应用它们。
- en: The output of this example will be another GeoTIFF file, but this time it will
    be a colorful RGB image.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的输出将是一个 GeoTIFF 文件，但这次它将是一个彩色 RGB 图像。
- en: Additional functions
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外函数
- en: We won't need any of the functions from our previous NDVI script, but we do
    need to add a function for creating and stretching a histogram. Both of these
    functions work with NumPy arrays. We'll also shorten the reference to `gdal_array` to
    `gd` in this script because it is a long name, and we need it throughout the script.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要之前 NDVI 脚本中的任何函数，但我们需要添加一个用于创建和拉伸直方图的函数。这两个函数都使用 NumPy 数组。在这个脚本中，我们将 `gdal_array`
    的引用缩短为 `gd`，因为它是一个长名称，并且我们需要在整个脚本中使用它。
- en: 'Let''s have a look at the steps as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下步骤：
- en: 'First, we import the libraries that we need:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入我们需要的库：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we need to create a `histogram` function, which we''ll need in order
    to do a histogram stretch:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个 `histogram` 函数，我们将需要它来进行直方图拉伸：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, we create our histogram `stretch` function:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建我们的直方图 `stretch` 函数：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now that we have our utility functions, we can process the NDVI.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的实用函数，我们可以处理 NDVI。
- en: Loading the NDVI
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载 NDVI
- en: 'Next, we''ll load the output of our NDVI script back into a NumPy array. We''ll
    also define the name of our output image as `ndvi_color.tif`, and create a zero-filled
    multidimensional array as a placeholder for the red, green, and blue bands of
    the colorized NDVI image. The following code will load the NDVI TIFF image into
    a `numpy` array:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将 NDVI 脚本的输出重新加载到 NumPy 数组中。我们还将定义我们的输出图像名称为 `ndvi_color.tif`，并创建一个零填充的多维数组作为彩色
    NDVI 图像的红、绿、蓝波段的占位符。以下代码将加载 NDVI TIFF 图像到 `numpy` 数组中：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now that our image is loaded as an array, we can stretch it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将图像作为数组加载，我们可以拉伸它。
- en: Preparing the NDVI
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备 NDVI
- en: 'We need to perform a histogram stretch on the NDVI in order to ensure that
    the image covers the range of classes that will give the final product meaning:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对 NDVI 执行直方图拉伸，以确保图像覆盖了将赋予最终产品意义的类范围：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now that we've stretched the image, we can begin the classification process.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拉伸了图像，我们可以开始分类过程。
- en: Creating classes
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建类别
- en: In this part, we set up the ranges for our NDVI classes, which are broken up
    across a range from 0 to 255\. We'll use seven classes. You can change the number
    of classes by adding or removing values from the classes list. Next, we create
    a **look-up table**, or **LUT**, in order to assign colors for each class. The
    number of colors must match the number of classes.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们为 NDVI 类设置范围，这些范围从 0 到 255。我们将使用七个类别。你可以通过向类别列表中添加或删除值来更改类别的数量。接下来，我们创建一个
    **查找表**，或 **LUT**，以为每个类别分配颜色。颜色的数量必须与类别的数量相匹配。
- en: 'The colors are defined as RGB values. The `start` variable defines the beginning
    of the first class. In this case, `0` is a nodata value, which we designated in
    the previous script, so we begin the class at `1`. We then loop through the classes,
    extract the ranges, and use the color assignments to add the RGB value to our
    placeholder array. Finally, we save the colorized image as a GeoTIFF file:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色定义为 RGB 值。`start` 变量定义了第一个类的开始。在这种情况下，`0` 是一个 nodata 值，我们在之前的脚本中指定了它，因此我们从
    `1` 开始分类。然后我们遍历类，提取范围，并使用颜色分配将 RGB 值添加到我们的占位符数组中。最后，我们将着色图像保存为 GeoTIFF 文件：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now we can classify the image:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以对图像进行分类：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, we can save our classified GeoTIFF file:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以保存我们的分类 GeoTIFF 文件：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here is the image that we output:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们输出的图像：
- en: '![](img/26dba7c4-7a58-48e6-9d4c-0a2d61becd64.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/26dba7c4-7a58-48e6-9d4c-0a2d61becd64.png)'
- en: This is our final product for this example. Farmers can use this data to determine
    how to effectively irrigate and spray chemicals, such as fertilizers and pesticides,
    in a targeted, more effective, and more environmentally friendly way. In fact,
    these classes can even be turned into a vector shapefile, which is then loaded
    into a GPS-driven computer on a field sprayer. This then automatically applies
    the correct amount of chemicals in the correct place as a sprayer is driven around
    the field, or in some cases, even flown over the field in an airplane with a sprayer
    attachment.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本例的最终产品。农民可以使用这些数据来确定如何有效地灌溉和喷洒化学物质，如肥料和杀虫剂，以更精准、更有效、更环保的方式进行。实际上，这些类别甚至可以被转换成矢量shapefile，然后加载到田间喷雾器的GPS驱动计算机上。这样，当喷雾器在田间移动时，或者在某些情况下，甚至可以携带喷雾附件的飞机在田间上空飞行，都会自动在正确的位置喷洒正确的化学物质数量。
- en: Notice as well that even though we clipped the data to the field, the image
    is still a square. The black areas are the nodata values that have been converted
    to black. In display software, you can make the nodata color transparent without
    affecting the rest of the image.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管我们已经将数据裁剪到田地中，但图像仍然是正方形。黑色区域是已转换为黑色的nodata值。在显示软件中，您可以设置nodata颜色为透明，而不会影响图像的其余部分。
- en: Although we created a very specific type of product, a classified NDVI, the
    framework of this script can be altered in order to implement many remote sensing
    analysis algorithms. There are different types of NDVIs, but with relatively minor
    changes, you can turn this script into a tool that can be used to look for harmful
    algae blooms in the ocean, or smoke in the middle of a forest indicating a forest
    fire.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们创建了一个非常具体的产品，即分类NDVI，但这个脚本的框架可以被修改以实现许多遥感分析算法。有不同类型的NDVI，但通过相对较小的修改，您可以将这个脚本变成一个工具，用于寻找海洋中的有害藻华，或者在森林中间的烟雾，这表明森林火灾。
- en: This book attempts to limit the use of GDAL as much as possible in order to
    focus on what can be accomplished with pure Python and tools that can easily be
    installed from PyPI. However, it is helpful to remember that there is a wealth
    of information on using GDAL and its associated utilities to carry out similar
    tasks. For another tutorial on clipping a raster with GDAL via its command-line
    utilities, see [https://joeyklee.github.io/broc-cli-geo/guide/XX_raster_cropping_and_clipping.html](https://joeyklee.github.io/broc-cli-geo/guide/XX_raster_cropping_and_clipping.html).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 本书试图尽可能减少GDAL的使用，以便专注于仅使用纯Python和可以从PyPI轻松安装的工具所能完成的工作。然而，记住关于使用GDAL及其相关实用程序执行类似任务的信息量很大。有关通过GDAL的命令行实用程序裁剪栅格的另一个教程，请参阅[https://joeyklee.github.io/broc-cli-geo/guide/XX_raster_cropping_and_clipping.html](https://joeyklee.github.io/broc-cli-geo/guide/XX_raster_cropping_and_clipping.html)。
- en: Now that we've worked with the land, let's work with water in order to create
    a flood inundation model.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经处理了陆地，让我们处理水，以创建洪水淹没模型。
- en: Creating a flood inundation model
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建洪水淹没模型
- en: In this next example, we'll begin to enter the world of hydrology. Flooding
    is one of the most common and devastating natural disasters, which affects nearly
    every population on the globe. Geospatial models are a powerful tool in estimating
    the impact of a flood and mitigating that impact before it happens. We often hear
    on the news that a river is reaching the flood stage, but that information is
    meaningless if we can't understand the impact.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个例子中，我们将开始进入水文的世界。洪水是常见且破坏性极强的自然灾害之一，几乎影响着全球的每一个人口。地理空间模型是估计洪水影响并在发生前减轻这种影响的有力工具。我们经常在新闻中听到河流正在达到洪水位，但如果我们不能理解其影响，那么这些信息就是无意义的。
- en: Hydrological flood models are expensive to develop and can be very complex.
    These models are essential for engineers in building flood control systems. However,
    first responders and potential flood victims are only interested in the impact
    of an impending flood.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 水文洪水模型开发成本高昂，可能非常复杂。这些模型对于工程师在建设防洪系统时至关重要。然而，第一响应者和潜在的洪水受害者只对即将发生的洪水的影响感兴趣。
- en: We can begin to understand the flooding impact in an area using a very simple
    and easy-to-comprehend tool called a **flood inundation model**. This model starts
    with a single point and floods an area with the maximum volume of water that a
    flood basin can hold at a particular flood stage. Usually, this analysis is a
    worst-case scenario. Hundreds of other factors go into calculating how much water
    will enter into a basin from a river-topping flood stage. But we can still learn
    a lot from this simple first-order model.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个非常简单且易于理解的工具来了解一个区域的洪水影响，这个工具被称为**洪水淹没模型**。该模型从一个单点开始，以洪水盆地在该特定洪水阶段可以容纳的最大水量来淹没一个区域。通常，这种分析是一个最坏情况。数百个其他因素都会影响到计算从河流顶部的洪水阶段进入盆地的水量。但我们仍然可以从这个简单的第一阶模型中学到很多东西。
- en: As mentioned in the *Elevation data* section in [Chapter 1](6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml),
    *Learning about Geospatial Analysis with Python*, the **Shuttle Radar Topography
    Mission** (**SRTM**) dataset provides a nearly-global DEM that you can use for
    these types of models. More on SRTM data can be found here: [http://www2.jpl.nasa.gov/srtm/](http://www2.jpl.nasa.gov/srtm/).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在[第1章](6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml)的*高程数据*部分所述，*使用Python学习地理空间分析*，**航天飞机雷达地形任务**（**SRTM**）数据集提供了一个几乎全球性的DEM，你可以用于这些类型的模型。有关SRTM数据的更多信息，请参阅[http://www2.jpl.nasa.gov/srtm/](http://www2.jpl.nasa.gov/srtm/)。
- en: 'You can download the ASCII Grid data in EPSG:4326, and a shapefile containing
    the point as a `.zip` file from [http://git.io/v3fSg](http://git.io/v3fSg). The
    shapefile is just for reference and has no role in this model. The following image is
    a **digital elevation model** (**DEM**) with a source point displayed as a yellow
    star near Houston, Texas. In real-world analysis, this point would likely be a
    stream gauge where you would have data about the river''s water level:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://git.io/v3fSg](http://git.io/v3fSg)下载EPSG:4326的ASCII网格数据，以及包含点作为`.zip`文件的shapefile。这个shapefile仅作参考，在此模型中没有任何作用。以下图像是一个**数字高程模型**（**DEM**），其中源点以黄色星号显示在德克萨斯州休斯顿附近。在现实世界的分析中，这个点可能是一个流量计，你将会有关于河流水位的资料：
- en: '![](img/7e7f70cc-0410-4925-9d89-c2355eb0d961.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7e7f70cc-0410-4925-9d89-c2355eb0d961.png)'
- en: The algorithm that we are introducing in this example is called a **flood fill
    algorithm**. This algorithm is well known in the field of computer science and
    is used in the classic computer game **Minesweeper** to clear empty squares on
    the board when a user clicks a square. It is also the method that is used for
    the well-known **paint bucket tool** in graphics programs such as **Adobe Photoshop**,
    and it is used to fill an area of adjacent pixels of the same color with a different
    color.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本例中介绍的这个算法被称为**洪水填充算法**。这个算法在计算机科学领域是众所周知的，并被用于经典的电脑游戏**扫雷**中，当用户点击一个方块时，用于清除板上的空方块。它也是图形程序（如**Adobe
    Photoshop**）中众所周知的**油漆桶工具**所使用的方法，用于用不同颜色填充相邻像素的同一区域。
- en: There are many ways to implement this algorithm. One of the oldest and most
    common ways is to recursively crawl through each pixel of the image. The problem
    with recursion is that you end up processing pixels more than once and creating
    an unnecessary amount of work. The resource usage for a recursive flood fill can
    easily crash a program on even a moderately sized image.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此算法的方法有很多。其中最古老且最常见的方法是递归地遍历图像中的每个像素。递归的问题在于你最终会多次处理像素，并创建不必要的额外工作。递归洪水填充的资源使用量很容易在即使是中等大小的图像上使程序崩溃。
- en: This script uses a four-way queue-based flood fill that may visit a cell more
    than once but ensures that we only process a cell once. The queue only contains
    unique, unprocessed cells by using Python's built-in set type, which only holds
    unique values. We use two sets: **fill**, which contains the cells we need to
    fill, and **filled**, which contains processed cells.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本使用基于四向队列的洪水填充，可能会多次访问一个单元格，但确保我们只处理一个单元格一次。队列仅通过使用Python内置的集合类型来包含唯一的未处理单元格，该类型只持有唯一值。我们使用两个集合：**fill**，包含我们需要填充的单元格，和**filled**，包含已处理的单元格。
- en: 'This example executes the following steps:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例执行以下步骤：
- en: Extract the header information from the ASCII DEM.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从ASCII DEM中提取标题信息。
- en: Open the DEM as a `numpy` array.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将DEM作为`numpy`数组打开。
- en: Define our starting point as row and column in the array.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的起点定义为数组中的行和列。
- en: Declare a flood elevation value.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明洪水高程值。
- en: Filter the terrain to only the desired elevation value and below.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅过滤地形到所需的 elevations 值及其以下。
- en: Process the filtered array.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理过滤后的数组。
- en: Create a 1, 0, 0 array (that is, a binary array) with flooded pixels as 1.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个1, 0, 0数组（即二进制数组），其中淹没的像素为1。
- en: Save the flood inundation array as an ASCII Grid.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将洪水淹没数组保存为ASCII网格。
- en: This example can take a minute or two to run on a slower machine; we'll use
    the `print` statements throughout the script as a simple way to track progress.
    Once again we'll break this script up with explanations, for clarity.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子在较慢的机器上可能需要一两分钟才能运行；我们将在整个脚本中使用`print`语句作为跟踪进度的简单方法。我们再次将此脚本分解为解释，以便清晰。
- en: Now that we have our data, we can begin our flood fill function.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了数据，我们可以开始我们的洪水填充函数。
- en: The flood fill function
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 洪水填充函数
- en: We use ASCII Grids in this example, which means that the engine for this model
    is completely in NumPy. We start off by defining the `floodFill()` function, which
    is the heart and soul of this model. This Wikipedia article on flood fill algorithms
    provides an excellent overview of the different approaches: [http://en.wikipedia.org/wiki/Flood_fill](http://en.wikipedia.org/wiki/Flood_fill).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用ASCII网格，这意味着这个模型的引擎完全在NumPy中。我们首先定义`floodFill()`函数，这是这个模型的核心和灵魂。这篇维基百科关于洪水填充算法的文章提供了不同方法的优秀概述：[http://en.wikipedia.org/wiki/Flood_fill](http://en.wikipedia.org/wiki/Flood_fill)。
- en: Flood fill algorithms start at a given cell and begin checking the neighboring
    cells for similarity. The similarity factor might be color or, in our case, elevation.
    If the neighboring cell is of the same or lower elevation as the current cell,
    then that cell is marked for checks of its neighbor until the entire grid is checked.
    NumPy isn't designed to crawl over an array in this way, but it is still efficient
    in handling multidimensional arrays overall. We step through each cell and check
    its neighbors to the north, south, east, and west. Any of those cells which can
    be flooded are added to the filled set, and their neighbors are added to the fill
    set to be checked by the algorithm.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 洪水填充算法从一个给定的单元格开始，开始检查相邻单元格的相似性。相似性因素可能是颜色，或者在我们的情况下是海拔。如果相邻单元格的海拔与当前单元格相同或更低，则该单元格被标记为检查其邻居，直到整个网格被检查。NumPy不是设计用来以这种方式遍历数组的，但它总体上在处理多维数组方面仍然很高效。我们逐个单元格地通过并检查其北、南、东和西的邻居。任何可以淹没的单元格都被添加到填充集合中，它们的邻居也被添加到填充集合中以供算法检查。
- en: 'As mentioned earlier, if you try to add the same value to a set twice, it just
    ignores the duplicate entry and maintains a unique list. By using sets in an array,
    we efficiently check a cell only once because the fill set contains unique cells.
    The following code implements our `floodFill` function:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，如果您尝试将相同的值添加到集合中两次，它将忽略重复条目并保持唯一的列表。通过在数组中使用集合，我们有效地检查单元格一次，因为填充集合包含唯一的单元格。以下代码实现了我们的`floodFill`函数：
- en: 'First we import our libraries:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入我们的库：
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, we create our `floodFill` function:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建我们的`floodFill`函数：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we create sets to track the cells that we''ve already covered:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建集合来跟踪我们已经覆盖的单元格：
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then we create our inundation array:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们创建我们的淹没数组：
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now we can loop through the cells and flood them, or not:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以遍历单元格并填充它们，或者不填充：
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If the land is higher than the floodwater, skip it:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果土地高于洪水水位，则跳过它：
- en: '[PRE37]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If the land elevation is equal to or less than the floodwater, fill it in:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果土地海拔等于或低于洪水水位，则填充它：
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, we check the surrounding neighbor cells to see if they need to be filled,
    and when we run out of cells, we return the flooded matrix:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们检查周围的相邻单元格以查看它们是否需要填充，当我们用完单元格时，我们返回填充的矩阵：
- en: '[PRE39]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now that we've set up our `floodFill` function, we can create a flood.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了`floodFill`函数，我们可以创建一个洪水。
- en: Predicting flood inundation
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预测洪水淹没
- en: In the remainder of the script, we load our terrain data from an ASCII Grid,
    define our output grid filename, and execute the algorithm on the terrain data.
    The seed of the flood fill algorithm is an arbitrary point, as `sx` and `sy` within
    the lower elevation areas. In a real-world application, these points would likely
    be a known location, such as a stream gauge or a breach in a dam. In the final
    step, we save the output grid.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本剩余部分，我们从ASCII网格加载我们的地形数据，定义我们的输出网格文件名，并在地形数据上执行算法。洪水填充算法的种子是一个任意点，即`sx`和`sy`位于低海拔区域。在实际应用中，这些点可能是一个已知位置，例如河流流量计或大坝的裂缝。在最后一步，我们保存输出网格。
- en: 'The following steps need to be performed:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 需要执行以下步骤：
- en: 'First, we set up our `source` and `target` data names:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们设置我们的`source`和`target`数据名称：
- en: '[PRE40]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, we open the source:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们打开源：
- en: '[PRE41]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We''ll create a mask array of everything below `70` meters:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个低于`70`米的掩码数组：
- en: '[PRE42]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, we''ll parse the geospatial information from the header:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将解析标题中的地理空间信息：
- en: '[PRE43]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, we''ll establish a starting point that is located in a riverbed:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将建立一个位于河床中的起点：
- en: '[PRE44]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, we trigger our `floodFill` function:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们触发我们的`floodFill`函数：
- en: '[PRE45]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, we can save our flood inundation model output:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以保存我们的洪水淹没模型输出：
- en: '[PRE46]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The image in the following screenshot shows the flood inundation output over
    a classified version of the DEM, with lower elevation values in brown, mid-range
    values in green, and higher values in gray and white:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了在分类版本的DEM上洪水淹没的输出，低海拔值用棕色表示，中值用绿色表示，高值用灰色和白色表示：
- en: '![](img/4696dc35-3027-456b-9b02-a54473c43317.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4696dc35-3027-456b-9b02-a54473c43317.png)'
- en: The flood raster, which includes all areas less than 70 meters, is colored blue.
    This image was created with QGIS, but it could be displayed in ArcGIS as EPSG:4326\.
    You could also use GDAL to save the flood raster grid as an 8-bit TIFF file or
    JPEG file, just like the NDVI example, in order to view it in a standard graphics
    program.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 包含所有低于70米区域的洪水栅格用蓝色表示。这张图片是用QGIS创建的，但它也可以在ArcGIS中以EPSG:4326格式显示。您也可以使用GDAL将洪水栅格网格保存为8位TIFF文件或JPEG文件，就像NDVI示例一样，以便在标准图形程序中查看。
- en: 'This image in the following screenshot is nearly identical, except for the
    filtered mask from which the inundation was derived, which is displayed in yellow.
    This is done by generating a file for the array called `wet`, instead of `fld`,
    to show the non-contiguous regions, which were not included as part of a flood.
    These areas are not connected to the source point, so they would unlikely be reached
    during a flood event:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图中的图像几乎相同，只是显示黄色的是从过滤掩码中导出的淹没，这是通过为数组生成一个名为`wet`的文件来完成的，而不是`fld`，以显示非连续区域，这些区域不是洪水的一部分。这些区域与源点不相连，因此在洪水事件中不太可能被触及：
- en: '![](img/714014f4-74aa-4ba5-96ee-a99f77b6caca.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/714014f4-74aa-4ba5-96ee-a99f77b6caca.png)'
- en: 'By changing the elevation value, you can create additional flood inundation
    rasters. We started with an elevation of 70 meters. If we increase that value
    to 90, we can expand the flood. The following screenshot shows a flood event at
    both 70 and 90 meters:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 通过改变海拔值，您可以创建额外的洪水淹没栅格。我们从一个70米的海拔值开始。如果我们将其值增加到90，我们可以扩大洪水范围。下面的截图显示了70米和90米处的洪水事件：
- en: '![](img/499dbc17-5925-49a3-abc6-a7cf2a17be77.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/499dbc17-5925-49a3-abc6-a7cf2a17be77.png)'
- en: The 90 meter inundation is the lighter-blue polygon. You can take bigger or
    smaller steps and show different impacts as different layers.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 90米淹没区域是较浅的蓝色多边形。您可以采取更大或更小的步骤，以不同的图层显示不同的影响。
- en: This model is an excellent and useful visualization. However, you could take
    this analysis even further by using GDAL's `polygonize()` method on the flood
    mask, as we did with the island in the *Extracting features from images* section
    in [Chapter 6](13990656-5786-445c-878b-8b262ad6f3c0.xhtml), *Python and Remote
    Sensing*. This operation would give you a vector flood polygon. Then, you could
    use the principles that we discussed in the *Performing selections* section in
    [Chapter 5](306ed8f8-99dd-4751-b273-9d76cfac4ec2.xhtml), *Python and Geographic
    Information Systems*, to select buildings using the polygon to determine population
    impact. You could also combine that flood polygon with the dot density example
    in [Chapter 5](306ed8f8-99dd-4751-b273-9d76cfac4ec2.xhtml), *Python and Geographic
    Information Systems*, in the *Dot density calculations* section, to assess the
    potential population impact of a flood. The possibilities are endless.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型是一个优秀且有用的可视化工具。然而，您可以通过使用GDAL的`polygonize()`方法对洪水掩膜进行分析，进一步扩展这个分析，正如我们在[第6章](13990656-5786-445c-878b-8b262ad6f3c0.xhtml)的“从图像中提取特征”部分所做的那样，*Python和遥感*。这个操作将为您提供矢量洪水多边形。然后，您可以使用我们在[第5章](306ed8f8-99dd-4751-b273-9d76cfac4ec2.xhtml)的“执行选择”部分讨论的原则，*Python和地理信息系统*，使用多边形选择建筑物以确定人口影响。您还可以将洪水多边形与[第5章](306ed8f8-99dd-4751-b273-9d76cfac4ec2.xhtml)的“点密度计算”部分中的点密度示例结合起来，以评估洪水潜在的人口影响。可能性是无限的。
- en: Creating a color hillshade
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个彩色阴影图
- en: In this example, we'll combine previous techniques to combine our terrain hillshade
    from [Chapter 7](964b7276-1604-4df5-b549-6d8f61d5e9cb.xhtml), *Python and Elevation
    Data,* with the color classification that we used on the LIDAR. For this example,
    we'll need the ASCII Grid DEMs named `dem.asc` and `relief.asc` that we used in
    the previous chapter.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将结合之前的技术，将我们从[第7章](964b7276-1604-4df5-b549-6d8f61d5e9cb.xhtml)，“Python和高程数据”中提取的地形阴影与我们在LIDAR上使用的颜色分类结合起来。对于这个例子，我们需要之前章节中使用的名为`dem.asc`和`relief.asc`的ASCII网格DEM。
- en: 'We''ll create a colorized DEM and a hillshade, and then use PIL to blend them
    together for an enhanced elevation visualization. The code comments will guide
    you through the example, as many of these steps are already familiar to you:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个彩色DEM和一个阴影，然后使用PIL将它们混合在一起以增强高程可视化。代码注释将引导你通过这个例子，因为许多这些步骤你已经很熟悉了：
- en: 'First, we import the libraries that we need:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入所需的库：
- en: '[PRE47]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: For this next part, you'll need the following two files: [https://github.com/GeospatialPython/Learn/raw/master/relief.zip](https://github.com/GeospatialPython/Learn/raw/master/relief.zip)
    and [https://github.com/GeospatialPython/Learn/raw/master/dem.zip](https://github.com/GeospatialPython/Learn/raw/master/dem.zip).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一部分，你需要以下两个文件：[https://github.com/GeospatialPython/Learn/raw/master/relief.zip](https://github.com/GeospatialPython/Learn/raw/master/relief.zip)
    和 [https://github.com/GeospatialPython/Learn/raw/master/dem.zip](https://github.com/GeospatialPython/Learn/raw/master/dem.zip)。
- en: 'Then, we''ll set up variables for the inputs and outputs:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将设置输入和输出的变量：
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, we''ll load our `relief` image:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将加载我们的`relief`图像：
- en: '[PRE49]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, we''ll load the DEM image, so that we''ll have the elevation data:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将加载DEM图像，这样我们就会有高程数据：
- en: '[PRE50]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, we''ll create a new image for our colorization with elevation breakpoints
    forming classes and corresponding colors in a LUT:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个新的图像用于我们的彩色化，其中高程断点形成类别，并在LUT中对应相应的颜色：
- en: '[PRE51]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can now perform our color classification:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以进行我们的颜色分类：
- en: '[PRE52]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then, we can convert our shaded relief array to an image, as well as our colorized
    DEM:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以将我们的阴影高程数组转换为图像，以及我们的彩色DEM：
- en: '[PRE53]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, we''ll blend the two images for the final effect and save it to an image
    file:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将混合两个图像以产生最终效果，并将其保存为图像文件：
- en: '[PRE54]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The following image shows the output, which makes a great backdrop for GIS
    maps:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图像显示了输出，它非常适合作为GIS地图的背景：
- en: '![](img/20daa808-1730-438a-9f52-098550887189.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/20daa808-1730-438a-9f52-098550887189.png)'
- en: Now that we can model terrain, let's learn how to navigate over it.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够模拟地形，让我们学习如何在上面导航。
- en: Performing least cost path analysis
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行最小成本路径分析
- en: Calculating driving directions is the most commonly used geospatial function
    in the world. Typically, these algorithms calculate the shortest path between
    points *A* and *B*, or they may take into account the speed limit of the road,
    or even current traffic conditions, in order to choose a route by drive time.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 计算驾驶方向是全球最常用的地理空间功能。通常，这些算法计算点 *A* 和 *B* 之间的最短路径，或者它们可能会考虑道路的速度限制，甚至当前的交通状况，以便通过驾驶时间选择路线。
- en: But what if your job is to build a new road? Or what if you are in charge of
    deciding where to run power transmission lines or water lines across a remote
    area? In a terrain-based setting, the shortest path might cross a difficult mountain,
    or run through a lake. In this case, we need to account for obstacles and avoid
    them if possible. However, if avoiding a minor obstacle takes us too far out of
    our way, the cost of implementing that route may be more expensive than just going
    over a mountain.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你的工作是建造一条新的道路？或者如果你负责决定在偏远地区铺设电力传输线或水管的位置？在地形环境中，最短路径可能会穿过一个困难的山脉，或者穿过一个湖泊。在这种情况下，我们需要考虑障碍物，并在可能的情况下避开它们。然而，如果避开一个小障碍物让我们偏离得太远，实施该路线的成本可能比翻越山脉还要高。
- en: This type of advanced analysis is called **least cost path analysis**. We search
    an area for the route that is the best compromise of distance versus the cost
    of following that route. The algorithm that we use for this process is called
    the **A-star or A*** algorithm. The oldest routing method is called the **Dijkstra
    algorithm**, which calculates the shortest path in a network, such as a road network.
    The A* method can do that as well, but it is also better suited for traversing
    a grid-like DEM.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的高级分析称为**最低成本路径分析**。我们在区域内搜索最佳折衷路线，该路线是距离与跟随该路线的成本的最佳平衡。我们用于此过程的算法称为**A星或A***算法。最古老的路线方法是**Dijkstra算法**，它计算网络中的最短路径，例如道路网络。A*方法也可以做到这一点，但它更适合穿越类似网格的DEM。
- en: 'You can find out more about these algorithms on the following web pages:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下网页上了解更多关于这些算法的信息：
- en: Dijkstra's algorithm: [http://en.wikipedia.org/wiki/Dijkstra's_algorithm](http://en.wikipedia.org/wiki/Dijkstra's_algorithm).
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dijkstra算法：[http://en.wikipedia.org/wiki/Dijkstra's_algorithm](http://en.wikipedia.org/wiki/Dijkstra's_algorithm)。
- en: 'A* algorithm: [http://en.wikipedia.org/wiki/A-star_algorithm](http://en.wikipedia.org/wiki/A-star_algorithm).'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A*算法：[http://en.wikipedia.org/wiki/A-star_algorithm](http://en.wikipedia.org/wiki/A-star_algorithm)。
- en: This example is the most complex in this chapter. To better understand it, we
    have a simple version of the program, which is text based, and operates on a 5
    x 5 grid with randomly generated values. You can actually see how this program
    follows the algorithm before trying it on an elevation grid with thousands of
    values.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是本章中最复杂的。为了更好地理解它，我们有一个简单的程序版本，它是基于文本的，并在一个5 x 5的网格上操作，使用随机生成的值。您实际上可以在尝试在具有数千个值的等高线网格上之前看到这个程序如何遵循算法。
- en: 'This program executes the following steps:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序执行以下步骤：
- en: Create a simple grid with randomly generated pseudo-elevation values between
    1 and 16.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个简单的网格，具有介于1和16之间的随机生成的伪高程值。
- en: Define a start location in the lower-left corner of the grid.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网格的左下角定义一个起始位置。
- en: Define the end point as the upper-right corner of the grid.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义终点为网格的右上角。
- en: Create a cost grid that has the elevation of each cell, plus the cell's distance
    to the finish.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个成本网格，包含每个单元格的高程以及单元格到终点的距离。
- en: Examine each neighboring cell from the start, and choose the one with the lowest
    cost.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查从起始位置开始的每个相邻单元格，并选择成本最低的一个。
- en: Repeat the evaluation using the chosen cell until we get to the end.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用所选单元格重复评估，直到到达终点。
- en: Return the set of chosen cells as the least cost path.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回所选单元格的集合作为最低成本路径。
- en: Set up the test grid.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置测试网格。
- en: You simply run this program from the command line and view its output. The first
    section of this script sets up our artificial terrain grid as a randomly generated
    NumPy array, with notional elevation values between 1 and 16\. We also create
    a distance grid that calculates the distance for each cell to the destination
    cell. This value is the cost of each cell.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 您只需从命令行运行此程序并查看其输出。此脚本的第一个部分设置我们的模拟地形网格，作为一个随机生成的NumPy数组，具有介于1和16之间的理论高程值。我们还创建了一个距离网格，该网格计算每个单元格到目标单元格的距离。这个值是每个单元格的成本。
- en: 'Let''s have a look at the following steps:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下步骤：
- en: 'First, we''ll import `numpy` and set the size of our grid:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将导入`numpy`并设置我们网格的大小：
- en: '[PRE55]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Next, we set a starting location cell and an ending location:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们设置起始位置单元格和结束位置：
- en: '[PRE56]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, we can create a grid of zeros based on our width and height:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以根据我们的宽度和高度创建一个零网格：
- en: '[PRE57]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Next, we''ll set up our distance grid in order to create impedance values:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将设置我们的距离网格，以便创建阻抗值：
- en: '[PRE58]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, we''ll print out the cost value of each cell in our cost grid:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将打印出我们成本网格中每个单元格的成本值：
- en: '[PRE59]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Now that we have a simulated terrain grid to work with, we can test a routing
    algorithm.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个模拟的地形网格可以工作，我们可以测试一个路由算法。
- en: The simple A* algorithm
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单的A*算法
- en: The A* search algorithm that is implemented here crawls the grid in a similar
    fashion to our flood fill algorithm in the previous example. Once again, we use
    sets to avoid using recursion, and to avoid the duplication of cell checks. But
    this time, instead of checking elevation, we check the distance cost of routing
    through a cell in question. If the move raises the cost of getting to the end,
    then we go with a lower-cost option.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这里实现的A*搜索算法以类似于前一个示例中我们的洪水填充算法的方式遍历网格。再次，我们使用集合来避免使用递归，并避免单元格检查的重复。但这次，我们不是检查高程，而是检查通过问题单元格的路线成本。如果移动增加了到达终点的成本，那么我们就选择成本更低的选项。
- en: 'The following steps need to be performed, as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 需要执行以下步骤：
- en: 'First, we''ll start our A* function by creating sets that will keep track of
    the path progress:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将通过创建跟踪路径进度的集合来开始我们的A*函数：
- en: '[PRE60]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Next, we add the starting cell to the open list of cells in order to process
    and begin looping through that set:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将起始单元格添加到待处理的开放单元格列表中，以便开始循环处理该集合：
- en: '[PRE61]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We check the surrounding cells as options for forward progress:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们检查周围单元格作为前进的选项：
- en: '[PRE62]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We then check each option for the best option and append it to the path until
    we reach the end:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将检查每个选项以找到最佳选项，并将其附加到路径上，直到我们到达终点：
- en: '[PRE63]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Now that we have the algorithm set up, we can test it out by creating a path.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了算法，我们可以通过创建路径来测试它：
- en: Generating the test path
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成测试路径
- en: 'In this section, we''ll generate a path on our test grid. We''ll call our A*
    function, using the starting point, end point, cost grid, and distance grid:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将在测试网格上生成路径。我们将调用A*函数，使用起点、终点、成本网格和距离网格：
- en: '[PRE64]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now, we''ll put our path on its own grid and print it:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将我们的路径放在自己的网格上并打印出来：
- en: '[PRE65]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Next, we'll view the output of this test.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看这个测试的输出。
- en: Viewing the test output
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看测试输出
- en: 'When you run this program, you''ll generate a randomly-numbered grid similar
    to the following:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个程序时，你会生成一个类似以下随机编号的网格：
- en: '[PRE66]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The grid is small enough such that you can easily trace the algorithm's steps
    manually. This implementation uses **Manhattan distance**, which means the distance
    does not use diagonal lines—only left, right, up, and down measurements. The search
    also does not move diagonally in order to keep things simple.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 网格足够小，你可以轻松地手动追踪算法的步骤。这个实现使用的是**曼哈顿距离**，这意味着距离不使用对角线——只有左、右、上、下的测量。搜索也不会对角移动，以保持简单。
- en: The real-world example
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 真实世界的例子
- en: Now that we have a basic understanding of the A* algorithm, let's move to a
    more complex example. For the relief example, we'll use the same DEM that is located
    near Vancouver, British Columbia, Canada, which we used in [Chapter 7](964b7276-1604-4df5-b549-6d8f61d5e9cb.xhtml),
    *Python and Elevation Data*, in the *Creating a shaded relief* section. The spatial
    reference for this grid is EPSG:26910 NAD 83/UTM zone 10N. You can download the
    DEM, relief, and start and end points of the shapefile as a zipped package from [http://git.io/v3fpL](http://git.io/v3fpL).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对A*算法有了基本的了解，让我们转到更复杂的例子。对于缓解示例，我们将使用与加拿大不列颠哥伦比亚省温哥华附近相同的DEM，我们在*创建阴影高程*部分[第7章](964b7276-1604-4df5-b549-6d8f61d5e9cb.xhtml)中使用了它。这个网格的空间参考是EPSG:26910
    NAD 83/UTM区域10N。您可以从[http://git.io/v3fpL](http://git.io/v3fpL)下载DEM、高程和形状文件的起点和终点作为压缩包。
- en: 'We''ll actually use the shaded relief for visualization. Our goal in this exercise
    will be to move from the start to the finish point in the lowest-cost way possible:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上将使用阴影高程进行可视化。在这个练习中，我们的目标是以最低的成本从起点移动到终点：
- en: '![](img/100d0634-af6e-4cd1-b470-87d25217cda3.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![](img/100d0634-af6e-4cd1-b470-87d25217cda3.png)'
- en: 'Just looking at the terrain, there are two paths that follow low-elevation
    routes without much change in direction. These two routes are illustrated in the
    following screenshot:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 仅从地形来看，有两条路径遵循低海拔路线，方向变化不大。这两条路径在下面的屏幕截图中有展示：
- en: '![](img/2c28f9cf-7567-4fd4-94c2-d2ad351c2988.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2c28f9cf-7567-4fd4-94c2-d2ad351c2988.png)'
- en: So, we would expect that when we used the A* algorithm, it would be close. Remember
    that the algorithm is only looking in the immediate vicinity, so it can't look
    at the whole image like we can, and it can't make adjustments early in the route
    based on a known obstacle ahead.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们预计当我们使用A*算法时，它将非常接近。记住，算法只查看直接附近，所以它不能像我们一样查看整个图像，并且它不能根据已知的障碍物在路线早期进行调整。
- en: We will expand this implementation from our simple example and use Euclidean
    distance, or *as the crow flies* measurements, and we will also allow the search
    to look in eight directions instead of four. We will prioritize terrain as the
    primary decision point. We will also use distance, both to the finish and from
    the start, as lower priorities in order to make sure that we are moving forward
    toward the goal and not getting too far off track. Other than those differences,
    the steps are identical to the simple example. The output will be a raster with
    the path values set to one and the other values set to zero.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从简单的示例扩展这个实现，使用欧几里得距离，或者说是“如鸟飞”的测量，我们还将允许搜索在八个方向上而不是四个方向上进行。我们将优先考虑地形作为主要决策点。我们还将使用距离，即到终点和从起点的距离，作为次要优先级，以确保我们朝着目标前进，而不是偏离轨道太远。除了这些差异之外，步骤与简单示例相同。输出将是一个栅格，路径值设为`1`，其他值设为`0`。
- en: Now that we understand the problem, let's solve it!
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了问题，让我们来解决这个问题！
- en: Loading the grid
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载网格
- en: 'In this section and the following sections, we''ll create the script that can
    create a route over terrain. The script starts out simple enough. We load the
    grid into a NumPy array from an ASCII Grid. We name our output path grid, and
    then we define the starting cell and end cell:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节和接下来的几节中，我们将创建一个脚本，该脚本可以创建地面的路线。脚本开始得很简单。我们从ASCII网格将网格加载到NumPy数组中。我们命名我们的输出路径网格，然后定义起始单元格和结束单元格：
- en: 'First, we import our libraries:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入我们的库：
- en: '[PRE67]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Next, we''ll define our input and output data sources:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将定义我们的输入和输出数据源：
- en: '[PRE68]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Then, we can load the grid skipping over the header:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以加载网格，跳过标题行：
- en: '[PRE69]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Next, we''ll parse the header for the geospatial and grid size information:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将解析标题以获取地理空间和网格大小信息：
- en: '[PRE70]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Finally, we''ll define our starting and end locations:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将定义我们的起始和结束位置：
- en: '[PRE71]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Now that our grid is loaded, we can set up the functions that we'll need.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经加载了网格，我们可以设置所需的函数。
- en: Defining the helper functions
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义辅助函数
- en: We need three functions in order to route over terrain. One is the A* algorithm,
    and the other two assist the algorithm in choosing the next step. We'll briefly
    discuss these helper functions. First, we have a simple Euclidean distance function
    named `e_dist`, which returns the straight-line distance between two points as
    map units. Next, we have an important function called `weighted_score`, which
    returns a score for a neighboring cell, based on the elevation change between
    the neighbor and the current cell, as well as the distance to the destination.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要三个函数来在地面进行路由。一个是A*算法，另外两个辅助算法帮助算法选择下一步。我们将简要讨论这些辅助函数。首先，我们有一个简单的欧几里得距离函数，名为`e_dist`，它返回两点之间的直线距离，以地图单位计。接下来，我们有一个重要的函数，称为`weighted_score`，它根据相邻单元格和当前单元格之间的高度变化以及到目的地的距离为相邻单元格评分。
- en: This function is better than distance or elevation alone because it reduces
    the chance of there being a tie between two cells, making it easier to avoid back-tracking.
    This scoring formula is loosely based on a concept called the **Nisson Score**,
    which is commonly used in these types of algorithms and is referenced in the Wikipedia
    articles mentioned earlier in this chapter. What's great about this function is
    that it can score the neighboring cell with any values that you wish. You might
    also use a real-time feed to look at the current weather in the neighboring cell,
    and avoid cells with rain or snow.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数比单独的距离或海拔更好，因为它减少了两个单元格之间出现平局的可能性，使得避免回溯更容易。这个评分公式松散地基于一个称为**Nisson评分**的概念，这个概念在类似算法中常用，并在本章前面提到的维基百科文章中有所提及。这个函数的伟大之处在于它可以对相邻单元格进行任何你想要的评分。你也可能使用实时数据来查看相邻单元格的当前天气，并避免有雨或雪的单元格。
- en: 'The following code will create our distance function and our weighting function
    that we''ll need to traverse the terrain:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将创建我们的距离函数和权重函数，这些函数是我们穿越地形所需的：
- en: 'First, we''ll create a Euclidean distance function that will give us the distance
    between points:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个欧几里得距离函数，它将给出两点之间的距离：
- en: '[PRE72]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now, we''ll create our weight function in order to score each node for its
    suitability to move:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建我们的权重函数，以便为每个节点的移动适宜性评分：
- en: '[PRE73]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We start with a `score` of `0` and check the node''s distance from the end
    and the start:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从`score`为`0`开始，检查节点与起点和终点的距离：
- en: '[PRE74]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Next, we examine the neighboring nodes and make a decision on where to move:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们检查相邻的节点并决定移动的方向：
- en: '[PRE75]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Now that our helper functions are complete, we can build the A* function.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了辅助函数，我们可以构建A*函数。
- en: The real-world A* algorithm
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实际的A*算法
- en: 'This algorithm is more involved than the simple version in our previous example.
    We use sets to avoid redundancy. It also implements our more advanced scoring
    algorithm and checks to make sure we aren''t at the end of the path before doing
    additional calculations. Unlike our last example, this more advanced version also
    checks cells in eight directions, so the path can move diagonally. There is a
    `print` statement at the end of this function that is commented out. You can uncomment
    it in order to watch the search crawl through the grid. The following code will
    implement the A* algorithm that we will use for the rest of the section:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法比我们之前示例中的简单版本更复杂。我们使用集合来避免冗余。它还实现了我们更高级的评分算法，并在进行额外计算之前检查我们是否在路径的末端。与我们的上一个示例不同，这个更高级的版本还检查八个方向上的单元格，因此路径可以斜向移动。在这个函数的末尾有一个被注释掉的`print`语句。你可以取消注释它来观察搜索如何在网格中爬行。下面的代码将实现我们将在本节中使用的A*算法：
- en: 'First, we open the function by accepting a starting point, an end point, and
    a score:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们通过接受起点、终点和分数来打开函数：
- en: '[PRE76]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now, we set up the sets that will track progress:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们设置跟踪进度的集合：
- en: '[PRE77]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Next, we begin processing using our starting point:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们开始使用起点进行处理：
- en: '[PRE78]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'If we hit the end, we return the completed path:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们到达终点，我们返回完成的路径：
- en: '[PRE79]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Otherwise, we keep working through the grid and eliminating possibilities:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，我们继续在网格中工作，消除可能性：
- en: '[PRE80]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'To keep things moving, we grab all of the neighbors that need to be processed
    as we go:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了保持进度，我们在进行过程中抓取所有需要处理的邻居：
- en: '[PRE81]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We check each neighbor for being the destination:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们检查每个邻居是否是目的地：
- en: '[PRE82]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We take the first option as the `best` option and process the other options,
    upgrading as we go:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将第一个选项作为“最佳”选项，并处理其他选项，在过程中进行升级：
- en: '[PRE83]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Now that we have our routing algorithm, we can generate a real-world path.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的路由算法，我们可以生成实际路径。
- en: Generating a real-world path
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成实际路径
- en: 'Finally, we create our real-world path as a chain of ones in a grid of zeros.
    This raster can then be brought into an application such as QGIS and visualized
    over the terrain grid. In the following code, we''ll use our algorithm and helper
    functions to generate a path, as follows:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将实际路径作为一个零网格中的一系列一，这个栅格可以随后被导入到QGIS等应用程序中，并在地形网格上可视化。在下面的代码中，我们将使用我们的算法和辅助函数来生成路径，如下所示：
- en: 'First, we send our start and end points, as well as our terrain grid, to the
    routing function:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将起点、终点以及地形网格发送到路由函数：
- en: '[PRE84]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Once we have a path, we can save it out as an ASCII Grid:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了路径，我们就可以将其保存为ASCII网格：
- en: '[PRE85]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Now, we want to save our path data because the points are in the correct order,
    from the starting point to the end point. When we put them into the grid, we lose
    that order because it is all one raster. We''ll use the built-in Python `pickle`
    module to save the list object to disk. We''re going to use this data in the next
    section to create a vector shapefile of the route. So, we''ll save our path data
    as a pickled Python object that we can reuse later, without running the whole
    program:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们想要保存我们的路径数据，因为点按正确的顺序排列，从起点到终点。当我们把它们放入网格中时，我们失去了这个顺序，因为它们都是一个栅格。我们将使用内置的Python
    `pickle`模块将列表对象保存到磁盘。我们将在下一节中使用这些数据来创建路线的矢量形状文件。因此，我们将我们的路径数据保存为可重用的pickle Python对象，以后无需运行整个程序：
- en: '[PRE86]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Here is the output route of our search:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的搜索输出路径：
- en: '![](img/931aa6a2-3312-40cf-86c0-fb529190bf04.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![](img/931aa6a2-3312-40cf-86c0-fb529190bf04.png)'
- en: 'As you can see, the A* search came very close to one of our manually selected
    routes. In a couple of cases, the algorithm chose to tackle some terrain, instead
    of trying to go around it. Sometimes the slight terrain is deemed less of a cost
    than the distance to go around it. You can see examples of that choice in this
    zoomed-in portion of the upper-right section of the route. The red line is the
    route that our program generated through the terrain:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，A*搜索非常接近我们手动选择的路线之一。在几个案例中，算法选择解决一些地形，而不是尝试绕过它。有时，轻微的地形被认为比绕行的距离成本低。您可以在路线右上角的放大部分中看到这种选择的例子。红线是我们程序通过地形生成的路线：
- en: '![](img/b4471f0d-911d-4874-9da1-fef9899f8455.png)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b4471f0d-911d-4874-9da1-fef9899f8455.png)'
- en: 'We only used two values: terrain and distance. But you could also add hundreds
    of factors, such as soil type, water bodies, and existing roads. All of these
    items could serve as an impedance or an outright wall. You would just modify the
    scoring function in the example to account for any additional factors. Keep in
    mind, the more factors you add, the more difficult it is to trace what the A*
    implementation was *thinking* when it chose the route.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只使用了两个值：地形和距离。但您也可以添加数百个因素，例如土壤类型、水体和现有道路。所有这些项目都可以作为阻抗或直接的障碍。您只需修改示例中的评分函数，以考虑任何额外的因素。请记住，您添加的因素越多，追踪A*实现选择路线时的“思考”就越困难。
- en: An obvious future direction for this analysis would be to create a vector version
    of this route as a line. The process would include mapping each cell to a point
    and then using nearest-neighbor analysis to order the points properly, before
    saving it as a shapefile or GeoJSON file.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这项分析来说，一个明显的未来方向是创建一个作为线的矢量版本的路线。这个过程包括将每个单元格映射到一个点，然后使用最近邻分析正确排序点，最后将其保存为shapefile或GeoJSON文件。
- en: Converting the route to a shapefile
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将路线转换为shapefile
- en: 'The raster version of the least cost path route is useful for visualization,
    but it isn''t much good for analysis because it is embedded in the raster, and
    it is, therefore, difficult to relate to other datasets as we have done so many
    other times in this book. Our next goal will be to use the path data that we saved
    when creating the route to create a shapefile since the saved data is in the proper
    order. The following code will convert our raster path to a shapefile that is
    easier to use in a GIS for analysis:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 最短路径路由的光栅版本对于可视化很有用，但它在分析方面并不太好，因为它嵌入在光栅中，因此很难与其他数据集相关联，就像我们在本书中多次做的那样。我们的下一个目标将是使用创建路线时保存的路径数据来创建shapefile，因为保存的数据是正确排序的。以下代码将我们的光栅路径转换为shapefile，这使得在GIS中进行分析更容易：
- en: 'First, we''ll import the modules that we need, which aren''t many. We''ll use
    the `pickle` module to restore the path `data` object. Then, we''ll use the `linecache`
    module to read the geospatial header information from the path raster in order
    to map the path rows and columns to the earth coordinates. Finally, we''ll use
    the `shapefile` module to export the shapefile:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将导入所需的模块，数量并不多。我们将使用`pickle`模块来恢复路径`data`对象。然后，我们将使用`linecache`模块从路径光栅中读取地理空间标题信息，以便将路径的行和列映射到地球坐标。最后，我们将使用`shapefile`模块来导出shapefile：
- en: '[PRE87]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Next, we''ll create a function to convert rows and columns to *x* and *y* coordinates.
    The function accepts the metadata header information from the path raster file,
    as well as the column and row number:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个函数来将行和列转换为*x*和*y*坐标。该函数接受路径光栅文件中的元数据标题信息，以及列和行号：
- en: '[PRE88]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Now, we''ll restore the `path` object from the pickled object:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将从pickle对象中恢复`path`对象：
- en: '[PRE89]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Then, we''ll parse the metadata information from the path raster file:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将解析路径光栅文件中的元数据信息：
- en: '[PRE90]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Next, we need a list object to hold the converted coordinates:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个列表对象来存储转换后的坐标：
- en: '[PRE91]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Now, we convert each raster location from the least cost path object into a
    geospatial coordinate and store it in the list that we created:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将每个光栅位置从最短路径对象转换为地理空间坐标，并将其存储在我们创建的列表中：
- en: '[PRE92]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Finally, with just a few lines, we write out a line shapefile:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，只需几行代码，我们就可以写出一条线shapefile：
- en: '[PRE93]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Good work! You have created a program that can automatically navigate through
    obstacles, based on a set of rules, and exported it to a file that you can display
    and analyze in a GIS! We only used three rules, but you can add additional restrictions
    on how the program picks a path by adding other datasets, such as weather or water
    bodies, or anything else you can imagine.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！您已经创建了一个程序，可以根据一组规则自动导航通过障碍物，并将其导出为可以在GIS中显示和分析的文件！我们只使用了三个规则，但您可以通过添加其他数据集来添加额外的限制，例如天气或水体，或您能想到的任何其他东西。
- en: Now that we understand blazing a path across an arbitrary surface, we'll look
    at routing through a network.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了在任意表面上开辟路径，我们将看看在网络中路由。
- en: Calculating satellite image cloud cover
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算卫星图像云覆盖
- en: Satellite images give us a powerful bird's-eye view of the Earth. They are useful
    for a variety of purposes, which we saw in [Chapter 6](13990656-5786-445c-878b-8b262ad6f3c0.xhtml),
    *Python and Remote Sensing*. However, they have one flaw—clouds. As a satellite
    passes around the Earth and collects imagery, it inevitably images clouds. And
    in addition to obstructing our view of the Earth, the cloud data can adversely
    affect remote sensing algorithms by wasting CPU cycles on useless cloud data,
    or skew the results by introducing unwanted data values.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 卫星图像为我们提供了强大的鸟瞰地球的视角。它们在多种用途中都很有用，我们在第6章[Python和遥感](13990656-5786-445c-878b-8b262ad6f3c0.xhtml)中看到了这一点。然而，它们有一个缺点——云层。当卫星绕地球飞行并收集图像时，不可避免地会拍摄到云层。除了遮挡我们对地球的视线外，云层数据还可能通过在无用的云层数据上浪费CPU周期或引入不希望的数据值来不利地影响遥感算法。
- en: The solution is to create a cloud mask. A cloud mask is a raster that isolates
    the cloud data in a separate raster. You can then use that raster as a reference
    when processing the image in order to avoid cloud data, or you can even use it
    to remove the clouds from the original image.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是创建一个云层掩码。云层掩码是一个将云层数据隔离在单独的栅格中的栅格。然后你可以使用这个栅格作为参考来处理图像，以避免云层数据，或者甚至可以使用它从原始图像中移除云层。
- en: 'In this section, we''ll create a cloud mask for a Landsat image using the `rasterio`
    module and the `rio-l8qa` plugin. The cloud mask will be created as a separate
    image that just contains clouds:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用`rasterio`模块和`rio-l8qa`插件为Landsat图像创建一个云层掩码。云层掩码将作为一个单独的图像创建，仅包含云层：
- en: First, we need to download some sample Landsat 8 satellite image data as a ZIP
    file from [http://bit.ly/landsat8data](http://bit.ly/landsat8data).
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要从[http://bit.ly/landsat8data](http://bit.ly/landsat8data)下载一些样本Landsat
    8卫星图像数据作为ZIP文件。
- en: Click the download icon in the top right to download the data as a ZIP file,
    and unzip it to a directory named `l8`.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击右上角的下载图标以将数据作为ZIP文件下载，并将其解压缩到名为`l8`的目录中：
- en: 'Next, make sure you have the raster libraries that we need by running `pip`:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，确保你已经安装了我们需要的栅格库，通过运行`pip`：
- en: '[PRE94]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Now, we''ll create the cloud mask by first importing the libraries that we
    need:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将首先导入我们需要的库来创建云层掩码：
- en: '[PRE95]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Next, we need to provide a reference to our satellite image directory:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要提供一个指向我们的卫星图像目录的引用：
- en: '[PRE96]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Now, we need to locate the quality-assurance metadata for the satellite data,
    which gives us the information that we need to generate the cloud mask:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要定位卫星数据的质量保证元数据，它提供了我们生成云层掩码所需的信息：
- en: '[PRE97]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Finally, we use the quality-assurance file to create a cloud mask TIFF file:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用质量保证文件创建一个云层掩码TIFF文件：
- en: '[PRE98]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The following image is just the band 7 (short-wave infrared) image from the
    Landsat 8 dataset:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像只是来自Landsat 8数据集的7波段（短波红外）图像：
- en: '![](img/8ba31b2b-92f2-4011-8886-cb094f201bef.png)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8ba31b2b-92f2-4011-8886-cb094f201bef.png)'
- en: 'The next image is the cloud mask image containing only the location of clouds
    and shadows:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 下一张图像是仅包含云层和阴影位置的云层掩码图像：
- en: '![](img/b1379f25-777b-405a-b3e8-f67fb7d071f3.png)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b1379f25-777b-405a-b3e8-f67fb7d071f3.png)'
- en: 'And finally, here''s the mask over the image, showing the clouds as black:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里是对图像上的云层的掩码，显示云层为黑色：
- en: '![](img/e4c9c790-616c-47ed-a00c-14016e0d066d.png)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e4c9c790-616c-47ed-a00c-14016e0d066d.png)'
- en: This example brushes the surface of what you can do with image masking. Another
    `rasterio` module, `rio-cloudmask`, allows you to calculate the cloud mask from
    scratch without using the quality-assurance data. But it requires some additional
    pre-processing steps. You can learn more about that here: [https://github.com/mapbox/rio-cloudmask.](https://github.com/mapbox/rio-cloudmask)
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子只是简单介绍了你可以使用图像掩码做什么。另一个`rasterio`模块，`rio-cloudmask`，允许你从头开始计算云层掩码，而不使用质量保证数据。但这需要一些额外的预处理步骤。你可以在这里了解更多信息：[https://github.com/mapbox/rio-cloudmask.](https://github.com/mapbox/rio-cloudmask)
- en: Routing along streets
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 沿街道进行路由
- en: Routing along streets uses a connected network of lines, which is called a graph.
    The lines in the graph can have impedance values, which discourage a routing algorithm
    from including them in a route. Examples of impedance values often include traffic
    volume, speed limit, or even distance. A key requirement for a routing graph is
    that all of the lines, known as edges, must be connected. Road datasets that are
    created for mapping will often have lines whose nodes do not intersect.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 沿街道进行路由使用称为图的连接线网络。图中的线条可以具有阻抗值，这会阻止路由算法将它们包括在路径中。阻抗值的例子通常包括交通量、速度限制，甚至是距离。路由图的一个关键要求是，所有称为边的线条都必须是连通的。为制图创建的道路数据集通常会包含节点不交叉的线条。
- en: In this example, we'll calculate the shortest route through a graph by distance.
    We'll use a start and end point, which are not nodes in the graph, meaning we'll
    have to first find the graph nodes that are the closest to our start and destination
    points.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将通过距离计算图中的最短路径。我们将使用起点和终点，它们不是图中的节点，这意味着我们首先必须找到距离我们的起点和目的地最近的图节点。
- en: To calculate the shortest route, we'll use a powerful pure Python graph library
    called NetworkX. NetworkX is a general network graphing library that can create,
    manipulate, and analyze complex networks, including geospatial networks. If `pip`
    does not install NetworkX on your system, then you can find instructions for downloading
    and installing NetworkX for different operating systems at [http://networkx.readthedocs.org/en/stable/](http://networkx.readthedocs.org/en/stable/).
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算最短路径，我们将使用一个名为 NetworkX 的强大纯 Python 图形库。NetworkX 是一个通用的网络图形库，可以创建、操作和分析复杂网络，包括地理空间网络。如果
    `pip` 在您的系统上没有安装 NetworkX，您可以在 [http://networkx.readthedocs.org/en/stable/](http://networkx.readthedocs.org/en/stable/)
    找到针对不同操作系统的下载和安装 NetworkX 的说明。
- en: 'You can download the road network and the start and end points, which are located
    along the U.S. Gulf Coast, as a ZIP file from [http://git.io/vcXFQ](http://git.io/vcXFQ).
    Then, you can follow these steps:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 [http://git.io/vcXFQ](http://git.io/vcXFQ) 下载道路网络以及位于美国墨西哥湾沿岸的起点和终点，作为一个
    ZIP 文件。然后，您可以按照以下步骤操作：
- en: 'First, we''ll need to import the libraries we''re going to use. In addition
    to NetworkX, we’ll use the PyShp library in order to read and write shapefiles:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要导入我们将要使用的库。除了 NetworkX 之外，我们还将使用 PyShp 库来读取和写入形状文件：
- en: '[PRE99]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Next, we''ll define the current directory as our output directory for the route
    shapefile that we''ll create:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将定义当前目录为我们创建的路线形状文件输出目录：
- en: '[PRE100]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Now, we’ll need a function that can calculate the distance between points in
    order to populate the impedance values of our graph and to find the nodes closest
    to our start and destination points for the route:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要一个函数来计算点之间的距离，以便填充我们图中的阻抗值，并找到路线的起点和终点附近的节点：
- en: '[PRE101]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Then, we''ll create another function, which returns pairs of points from a
    list, to give us the line segments that we''ll use to build our graph edges:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将创建另一个函数，该函数从列表中返回点对，为我们提供构建图边所用的线段：
- en: '[PRE102]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Now, we''ll define our road network shapefile. This road network is a subset
    of a U.S. interstate highway files shapefile from the **United States Geological
    Survey** (**USGS**), which has been edited to ensure all the roads are connected:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将定义我们的道路网络形状文件。这个道路网络是美国地质调查局（**美国地质调查局**）（**USGS**）的 U.S. 州际公路文件形状文件的一个子集，已经编辑过以确保所有道路都是连通的：
- en: '[PRE103]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Next, we''ll create a graph with NetworkX and add the shapefile segments as
    graph edges:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 NetworkX 创建一个图，并将形状文件段添加为图边：
- en: '[PRE104]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Then, we can extract the connected components as a subgraph. However, in this
    case, we''ve ensured that the entire graph is connected:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以提取连接组件作为子图。然而，在这种情况下，我们已经确保整个图是连通的：
- en: '[PRE105]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Next, we can read in the `start` and `end` points that we want to navigate:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以读取我们想要导航的 `start` 和 `end` 点：
- en: '[PRE106]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Now, we loop through the graph, and assign distance values to each edge, using
    our `haversine` formula:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们遍历图，并为每个边分配距离值，使用我们的 `haversine` 公式：
- en: '[PRE107]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Next, we must find the nodes in the graph that are the closest to our start
    and end points, in order to begin and end our route by looping through all of
    the nodes, and measuring the distance to our end points until we find the shortest
    distance:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须找到图中距离我们的起点和终点最近的节点，以便通过遍历所有节点并测量到终点的距离来开始和结束我们的路线，直到找到最短距离：
- en: '[PRE108]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Now, we are ready to calculate the shortest distance through our road network:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好通过我们的道路网络计算最短距离：
- en: '[PRE109]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Finally, we''ll add the results to the shapefile and save our route:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将结果添加到shapefile中，并保存我们的路线：
- en: '[PRE110]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The following screenshot shows the road network in light gray, the start and
    end points, and the route in black. You can see that the route cuts across the
    road network in order to reach the road that is the nearest to the end point in
    the shortest possible distance:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了浅灰色中的道路网络、起点和终点以及黑色中的路线。你可以看到路线穿过道路网络，以便以最短的距离到达最近的终点道路：
- en: '![](img/76184867-4eac-4033-a072-0e4d76b85f28.png)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
  zh: '![](img/76184867-4eac-4033-a072-0e4d76b85f28.png)'
- en: Now that we know how to create various types of routes, we can look at locating
    photos that you might take while traveling along a route.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何创建各种类型的路线，我们可以看看在沿着路线旅行时可能会拍摄到的照片的位置。
- en: Geolocating photos
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地理定位照片
- en: Photos that are taken with GPS-enabled cameras, including smartphones, store
    location information in the header of the file in a format called **EXIF** tags.
    These tags are based largely on the same header tags that are used by the TIFF
    image standard. In this example, we'll use those tags to create a shapefile with
    point locations for the photos, and file paths to the photos, as attributes.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 带有GPS功能的相机拍摄的照片，包括智能手机，在文件的头部存储位置信息，格式称为**EXIF**标签。这些标签主要基于TIFF图像标准中使用的相同头部标签。在这个例子中，我们将使用这些标签创建一个包含照片点位置和照片文件路径的shapefile，并将这些路径作为属性。
- en: 'We’ll use the PIL in this example because it has the ability to extract EXIF
    data. Most photos that are taken with smartphones are geotagged images; however,
    you can download the set used in this example from [https://git.io/vczR0](http://git.io/vczR0):'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用PIL，因为它具有提取EXIF数据的能力。大多数用智能手机拍摄的照片都是带有地理标记的图像；然而，你可以从[https://git.io/vczR0](http://git.io/vczR0)下载本例中使用的集合：
- en: 'First, we''ll import the libraries that we need, including PIL for the image
    metadata and PyShp for the shapefiles:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将导入所需的库，包括用于图像元数据的PIL和用于shapefiles的PyShp：
- en: '[PRE111]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Now, we''ll need three functions. The first function extracts the EXIF data.
    The second function converts **degree, minutes, seconds** (**DMS**) coordinates
    to decimal degrees (EXIF data stores GPS data as DMS coordinates). The third function
    extracts the GPS data and performs the coordinate conversion:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要三个函数。第一个函数提取EXIF数据。第二个函数将**度、分、秒**（**DMS**）坐标转换为十进制度（EXIF数据以DMS坐标存储GPS数据）。第三个函数提取GPS数据并执行坐标转换：
- en: '[PRE112]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Next, we will loop through the photos, extract the coordinates, and store the
    coordinates and filename in a dictionary:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将遍历照片，提取坐标，并将坐标和文件名存储在字典中：
- en: '[PRE113]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Now, we will save the photo information as a shapefile:'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将保存照片信息为shapefile格式：
- en: '[PRE114]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The filenames of the photos in the shapefile are now attributes of the point
    locations where the photos were taken. GIS programs including QGIS and ArcGIS
    have the tools to turn those attributes into links when you click on the photo
    path or the point. The following screenshot from QGIS shows that one of the photos
    opens after clicking on the associated point using the Run Feature Action tool:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: shapefile中照片的文件名现在是照片拍摄地点的属性。包括QGIS和ArcGIS在内的GIS程序具有将那些属性转换为链接的工具，当你点击照片路径或点时。以下是从QGIS中截取的屏幕截图，显示了使用“运行要素动作工具”点击相关点后打开的一张照片：
- en: '![](img/f2c3918e-5f85-4a8f-aa32-2da3fcf5192e.png)'
  id: totrans-446
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f2c3918e-5f85-4a8f-aa32-2da3fcf5192e.png)'
- en: 'To view the result, please use the following instructions:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看结果，请按照以下说明操作：
- en: Download QGIS from [https://qgis.org](http://qgis.org) and follow the installation
    instructions.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://qgis.org](http://qgis.org)下载QGIS并遵循安装说明。
- en: Open QGIS and drag the `photos.shp` file onto the blank map.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开QGIS并将`photos.shp`文件拖放到空白地图上。
- en: In the Layer panel on the left, right-click the layer named Photos and select
    Properties.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧的图层面板上，右键单击名为“照片”的图层并选择“属性”。
- en: On the Actions tab, click the green plus sign to open the new actions dialog.
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“操作”选项卡上，点击绿色加号以打开新的操作对话框。
- en: In the Type drop-down menu, select Open.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类型下拉菜单中，选择“打开”。
- en: In the Description field, enter Open Image.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在描述字段中，输入“打开图像”。
- en: Click the Insert button in the lower-right corner.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击右下角的“插入”按钮。
- en: Click the OK button, and then close the properties dialog.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“确定”按钮，然后关闭属性对话框。
- en: Click on the small black arrow to the right of the Run Feature Action tool,
    which is a gear icon with a green center and a white arrow in it.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击运行功能工具右侧的小黑箭头，该工具是一个带有绿色中心和白色箭头的齿轮图标。
- en: In the menu that pops up, choose Open Image.
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在弹出的菜单中，选择打开图片。
- en: Now, click on one of the points on the map to see the geotagged image popup.
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击地图上的一个点，查看带有地理标签的图片弹出窗口。
- en: Now, let's move from an image taken on the Earth, to images taken of the Earth
    itself, by working with satellite images.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从在地球上拍摄的图片，转到拍摄地球本身的图片，通过处理卫星图像来实现。
- en: Summary
  id: totrans-460
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to create three real-world products, which are
    used every day in government, science, and industry. Apart from where this analysis
    is typically done with **black box** packages—costing thousands of dollars—we
    were able to use very minimal and free cross-platform Python tools. And in addition
    to the examples in this chapter, you now have some more reusable functions, algorithms,
    and processing frameworks for other advanced analyses, which will allow you to
    solve new problems that you come across in fields such as transportation, agriculture,
    and weather.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何创建三个现实世界的产品，这些产品在政府、科学和工业中每天都会使用。除了这种分析通常使用成本数千美元的**黑盒**软件包之外，我们能够使用非常少和免费的跨平台Python工具。而且除了本章中的示例之外，你现在还有一些可重用的函数、算法和用于其他高级分析的处理框架，这将使你能够解决你在交通、农业和天气等领域遇到的新问题。
- en: 'In the next chapter, we''ll move into a relatively new area of geospatial analysis:
    real-time and near real-time data.'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进入地理空间分析的一个相对较新的领域：实时和近实时数据。
