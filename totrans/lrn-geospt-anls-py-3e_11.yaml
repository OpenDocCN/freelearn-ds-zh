- en: Advanced Geospatial Python Modeling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll build on the data processing concepts that we've learned
    in order to create some full-scale information products. The previously introduced
    data processing methods rarely provide answers to questions by themselves. You
    combine these data processing methods to build a geospatial model from multiple
    processed datasets. A geospatial model is a simplified representation of some
    aspect of the real world, which helps us answer one or more questions about a
    project or problem. In this chapter, we will introduce some important geospatial
    algorithms that are commonly used in agriculture, emergency management, logistics,
    and other industries.
  prefs: []
  type: TYPE_NORMAL
- en: 'The products that we will create are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A crop health map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A flood inundation model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A colorized hillshade
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A terrain routing map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A street routing map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A shapefile with links to geolocated photos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While these products are task-specific, the algorithms that are used to create
    them are widely applied in geospatial analysis. We will be covering the following
    topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a normalized difference vegetative index (NVDI)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a flood inundation model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a color hillshade
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing least cost path analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting the route to a shapefile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing along streets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Geolocating photos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating satellite image cloud cover
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The examples in this chapter are longer and more involved than in the previous
    chapters. For that reason, there are far more code comments to make the programs
    easier to follow. We will also use more functions in these examples. In previous
    chapters, functions were mostly avoided for clarity, but these examples are sufficiently
    complex that certain functions make the code easier to read. These examples are
    actual processes that you would use on the job as a geospatial analyst.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, the following requirements need to be satisfied:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Version**: Python 3.6 or higher'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RAM**: Minimum 6 GB (Windows), 8 GB (macOS); recommended 8 GB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Storage**: Minimum 7,200 RPM SATA with 20 GB of available space, recommended
    SSD with 40 GB of available space.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Processor**: Minimum Intel Core i3 2.5 GHz, recommended Intel Core i5.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a normalized difference vegetative index
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our first example will be an **normalized difference vegetative index** (**NVDI**). NDVIs
    are used to show the relative health of plants in an area of interest. An NDVI
    algorithm uses satellite or aerial imagery to show relative health by highlighting
    the chlorophyll density in plants. NDVIs use only the red and near-infrared bands.
    The formula of NDVI is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The goal of this analysis is to produce, to begin with, a multispectral image
    containing infrared and red bands, and end up with a pseudo color image using
    seven classes, which color the healthier plants darker green, less-healthy plants
    lighter green, and bare soil brown.
  prefs: []
  type: TYPE_NORMAL
- en: Because the health index is relative, it is important to localize the area of
    interest. You could perform a relative index for the entire globe but vast areas,
    such as the Sahara desert on the low-vegetation extreme and densely forested areas,
    such as the Amazon jungle, skew the results for vegetation in the middle range.
    However, that being said, climate scientists routinely create global NDVIs to
    study worldwide trends. The more common application, though, is for managed areas,
    such as a forest or a farm field, as in this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will begin with an analysis of a single farm field in the Mississippi Delta.
    To do so, we''ll start with a multispectral image of a fairly large area and use
    a shapefile in order to isolate a single field. The image in the following screenshot
    is our broad area, with the field of interest highlighted in yellow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7918c9ce-706d-4b4f-a71e-ba3e85c2e0cd.png)'
  prefs: []
  type: TYPE_IMG
- en: You can download this image and the shapefile for the farm field as a ZIP file
    from [http://git.io/v3fS9](http://git.io/v3fS9).
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, we''ll use GDAL, OGR, `gdal_array`/`numpy`, and the **Python
    Imaging Library** (**PIL**) to clip and process the data. In the other examples
    in this chapter, we''ll just use simple ASCII Grids and NumPy. As we''ll be using
    ASCII elevation grids, GDAL isn''t required. In all examples, the scripts use
    the following convention:'
  prefs: []
  type: TYPE_NORMAL
- en: Import libraries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define global variables, such as filenames.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute the analysis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save the output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our approach to the crop health example is split into two scripts. The first
    script creates the index image, which is a grayscale image. The second script
    classifies the index and outputs a colored image. In this first script, we''ll
    execute the following steps to create the index image:'
  prefs: []
  type: TYPE_NORMAL
- en: Read the infrared band.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read the field boundary shapefile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rasterize the shapefile to an image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the shapefile image to a NumPy array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the NumPy array to clip the red band to the field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do the same for the infrared band.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the band arrays to execute the NDVI algorithm in NumPy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the resulting indexing algorithm to a GeoTIFF file using `gdal_array`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will discuss this script in sections to make it easier to follow. The code
    comments will also tell you what is going on at each step of the way.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Setting up the framework will help us to import the modules that we need and
    set up the functions that we''ll use for steps 1 to 5 of the preceding instructions.
    The `imageToArray()` function converts a PIL image to a NumPy array and is dependent
    on the `gdal_array` and PIL modules. The `world2Pixel()` function converts geospatial
    coordinates to the pixel coordinates of our target image. This function uses the
    georeferencing information that is presented by the `gdal` module. The `copy_geo()`
    function copies the georeferencing information from our source image to our target
    array but accounts for the offset that is created when we clip the image. These
    functions are fairly generic and can serve a role in a variety of different remote
    sensing processes beyond this example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import our libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need a function to convert an image to a `numpy` array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll set up a function to convert the coordinates to image pixels:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ll create a function to copy geographic metadata from an image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to load the data, which we'll be checking in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Loading the data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we load the source image of a farm field using `gdal_array`,
    which takes it straight into a NumPy array. We also define the name of our output
    image, which will be `ndvi.tif`. One interesting piece of this section is that
    we load the source image a second time using the `gdal` module, as opposed to
    `gdal_array`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This second call is to capture the georeferencing data for the image that is
    available through `gdal`, and not `gdal_array`. Fortunately, `gdal` only loads
    raster data on demand, so this approach avoids loading the complete dataset into
    the memory twice. Once we have the data as a multidimensional NumPy array, we
    split out the red and infrared bands, as they will both be used in the NDVI equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our data loaded, we can turn our shapefile into a raster.
  prefs: []
  type: TYPE_NORMAL
- en: Rasterizing the shapefile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section begins the process of clipping. However, the first step is to rasterize
    the shapefile that outlines the boundary of the specific area that we are going
    to analyze. That area is within the larger `field.tif` satellite image. In other
    words, we convert it from vector data to raster data. But we also want to fill
    in the polygon when we convert it so that it can be used as an image mask. The
    pixels in the mask will be correlated to the pixels in the red and infrared arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Any pixels outside the mask will be turned to `NODATA` pixels so they are not
    processed as part of the NDVI. To make this correlation, we'll need the solid
    polygon to be a NumPy array, just like the raster bands. This approach will make
    sure our NDVI calculation will be limited to the farm field.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to convert the shapefile polygon into a filled polygon as a
    NumPy array is to plot it as a polygon in a PIL image, fill that polygon in, and
    then convert it to a NumPy array using existing methods, in both PIL and NumPy,
    which allow that conversion.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we use the `ogr` module to read the shapefile, because we
    already have GDAL available. But, we could have also used PyShp to read the shapefile
    just as easily. If our farm field image was available as an ASCII Grid, we could
    have avoided using the `gdal`, `gdal_array`, and `ogr` modules altogether:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we open our shapefile and select the one and only layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s only one polygon, so we''ll grab that feature:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''ll convert the layer extent to image pixel coordinates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we calculate the pixel size of the new image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create a new blank image at the correct size:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''re ready to clip the red and infrared bands using the bounding box:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create the georeferencing information for the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can prepare to map points to pixels in order to create our mask image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We loop through all of the point features and store their *x* and *y* values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we convert the points to pixel locations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create a new image that will serve as our mask image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can rasterize our polygon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can convert our mask to a `numpy` array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have converted the shapefile to a mask image, we can clip the bands.
  prefs: []
  type: TYPE_NORMAL
- en: Clipping the bands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our image mask, we can clip the red and infrared bands to
    the boundary of the mask. For this process, we use NumPy''s `choose()` method
    that correlates the mask cell to the raster band cell and returns that value,
    or returns `0`. The result is a new array that is clipped to the mask, but with
    the correlated values from the raster band:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We now have just the data that we want, so we can apply our NDVI relative vegetation
    health formula.
  prefs: []
  type: TYPE_NORMAL
- en: Using the NDVI formula
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our final process for creating the NDVI is to execute the equation that is
    *infrared - red/infrared + red*. The first step that we perform silences any **not-a-number**,
    also known as **NaN**, values in NumPy that might occur during division. And before
    we save the output, we''ll convert any NaN values to `0`. We''ll save the output
    as `ndvi.tif`, and that will be the input for the next script in order to classify
    and colorize the NDVI as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll ignore any warnings from `numpy`, as we''ll get some errors near
    the edges:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can perform our NDVI formula:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If there are any NaN values, we convert them to zero:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we save our finished NDVI image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure is the output of this example. You need to view it in
    a geospatial viewer such as QGIS or OpenEV. The image won''t open in most image
    editors. The lighter the shade of gray, the healthier the plant is within that
    field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8bc38834-7ad5-40e8-81e9-32c2f8db7151.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we know how to use the NDVI formula, let's see how to classify it.
  prefs: []
  type: TYPE_NORMAL
- en: Classifying the NDVI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a valid index, but it is not easy to understand, because it is a
    grayscale image. If we color the image in an intuitive way, then even a child
    can identify the healthier plants. In the following section, *Additional functions*,
    we read in this grayscale index and classify it from brown to dark green using
    seven classes. The classification and image processing routines, such as the histogram
    and stretching functions, are almost identical to what we used in the *Creating
    histograms* section in [Chapter 6](13990656-5786-445c-878b-8b262ad6f3c0.xhtml),
    *Python and Remote Sensing*, but this time we are applying them in a much more
    specific way.
  prefs: []
  type: TYPE_NORMAL
- en: The output of this example will be another GeoTIFF file, but this time it will
    be a colorful RGB image.
  prefs: []
  type: TYPE_NORMAL
- en: Additional functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We won't need any of the functions from our previous NDVI script, but we do
    need to add a function for creating and stretching a histogram. Both of these
    functions work with NumPy arrays. We'll also shorten the reference to `gdal_array` to
    `gd` in this script because it is a long name, and we need it throughout the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the steps as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import the libraries that we need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to create a `histogram` function, which we''ll need in order
    to do a histogram stretch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we create our histogram `stretch` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our utility functions, we can process the NDVI.
  prefs: []
  type: TYPE_NORMAL
- en: Loading the NDVI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we''ll load the output of our NDVI script back into a NumPy array. We''ll
    also define the name of our output image as `ndvi_color.tif`, and create a zero-filled
    multidimensional array as a placeholder for the red, green, and blue bands of
    the colorized NDVI image. The following code will load the NDVI TIFF image into
    a `numpy` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now that our image is loaded as an array, we can stretch it.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the NDVI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to perform a histogram stretch on the NDVI in order to ensure that
    the image covers the range of classes that will give the final product meaning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've stretched the image, we can begin the classification process.
  prefs: []
  type: TYPE_NORMAL
- en: Creating classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, we set up the ranges for our NDVI classes, which are broken up
    across a range from 0 to 255\. We'll use seven classes. You can change the number
    of classes by adding or removing values from the classes list. Next, we create
    a **look-up table**, or **LUT**, in order to assign colors for each class. The
    number of colors must match the number of classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The colors are defined as RGB values. The `start` variable defines the beginning
    of the first class. In this case, `0` is a nodata value, which we designated in
    the previous script, so we begin the class at `1`. We then loop through the classes,
    extract the ranges, and use the color assignments to add the RGB value to our
    placeholder array. Finally, we save the colorized image as a GeoTIFF file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can classify the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can save our classified GeoTIFF file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the image that we output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/26dba7c4-7a58-48e6-9d4c-0a2d61becd64.png)'
  prefs: []
  type: TYPE_IMG
- en: This is our final product for this example. Farmers can use this data to determine
    how to effectively irrigate and spray chemicals, such as fertilizers and pesticides,
    in a targeted, more effective, and more environmentally friendly way. In fact,
    these classes can even be turned into a vector shapefile, which is then loaded
    into a GPS-driven computer on a field sprayer. This then automatically applies
    the correct amount of chemicals in the correct place as a sprayer is driven around
    the field, or in some cases, even flown over the field in an airplane with a sprayer
    attachment.
  prefs: []
  type: TYPE_NORMAL
- en: Notice as well that even though we clipped the data to the field, the image
    is still a square. The black areas are the nodata values that have been converted
    to black. In display software, you can make the nodata color transparent without
    affecting the rest of the image.
  prefs: []
  type: TYPE_NORMAL
- en: Although we created a very specific type of product, a classified NDVI, the
    framework of this script can be altered in order to implement many remote sensing
    analysis algorithms. There are different types of NDVIs, but with relatively minor
    changes, you can turn this script into a tool that can be used to look for harmful
    algae blooms in the ocean, or smoke in the middle of a forest indicating a forest
    fire.
  prefs: []
  type: TYPE_NORMAL
- en: This book attempts to limit the use of GDAL as much as possible in order to
    focus on what can be accomplished with pure Python and tools that can easily be
    installed from PyPI. However, it is helpful to remember that there is a wealth
    of information on using GDAL and its associated utilities to carry out similar
    tasks. For another tutorial on clipping a raster with GDAL via its command-line
    utilities, see [https://joeyklee.github.io/broc-cli-geo/guide/XX_raster_cropping_and_clipping.html](https://joeyklee.github.io/broc-cli-geo/guide/XX_raster_cropping_and_clipping.html).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've worked with the land, let's work with water in order to create
    a flood inundation model.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a flood inundation model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this next example, we'll begin to enter the world of hydrology. Flooding
    is one of the most common and devastating natural disasters, which affects nearly
    every population on the globe. Geospatial models are a powerful tool in estimating
    the impact of a flood and mitigating that impact before it happens. We often hear
    on the news that a river is reaching the flood stage, but that information is
    meaningless if we can't understand the impact.
  prefs: []
  type: TYPE_NORMAL
- en: Hydrological flood models are expensive to develop and can be very complex.
    These models are essential for engineers in building flood control systems. However,
    first responders and potential flood victims are only interested in the impact
    of an impending flood.
  prefs: []
  type: TYPE_NORMAL
- en: We can begin to understand the flooding impact in an area using a very simple
    and easy-to-comprehend tool called a **flood inundation model**. This model starts
    with a single point and floods an area with the maximum volume of water that a
    flood basin can hold at a particular flood stage. Usually, this analysis is a
    worst-case scenario. Hundreds of other factors go into calculating how much water
    will enter into a basin from a river-topping flood stage. But we can still learn
    a lot from this simple first-order model.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in the *Elevation data* section in [Chapter 1](6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml),
    *Learning about Geospatial Analysis with Python*, the **Shuttle Radar Topography
    Mission** (**SRTM**) dataset provides a nearly-global DEM that you can use for
    these types of models. More on SRTM data can be found here: [http://www2.jpl.nasa.gov/srtm/](http://www2.jpl.nasa.gov/srtm/).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the ASCII Grid data in EPSG:4326, and a shapefile containing
    the point as a `.zip` file from [http://git.io/v3fSg](http://git.io/v3fSg). The
    shapefile is just for reference and has no role in this model. The following image is
    a **digital elevation model** (**DEM**) with a source point displayed as a yellow
    star near Houston, Texas. In real-world analysis, this point would likely be a
    stream gauge where you would have data about the river''s water level:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e7f70cc-0410-4925-9d89-c2355eb0d961.png)'
  prefs: []
  type: TYPE_IMG
- en: The algorithm that we are introducing in this example is called a **flood fill
    algorithm**. This algorithm is well known in the field of computer science and
    is used in the classic computer game **Minesweeper** to clear empty squares on
    the board when a user clicks a square. It is also the method that is used for
    the well-known **paint bucket tool** in graphics programs such as **Adobe Photoshop**,
    and it is used to fill an area of adjacent pixels of the same color with a different
    color.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to implement this algorithm. One of the oldest and most
    common ways is to recursively crawl through each pixel of the image. The problem
    with recursion is that you end up processing pixels more than once and creating
    an unnecessary amount of work. The resource usage for a recursive flood fill can
    easily crash a program on even a moderately sized image.
  prefs: []
  type: TYPE_NORMAL
- en: This script uses a four-way queue-based flood fill that may visit a cell more
    than once but ensures that we only process a cell once. The queue only contains
    unique, unprocessed cells by using Python's built-in set type, which only holds
    unique values. We use two sets: **fill**, which contains the cells we need to
    fill, and **filled**, which contains processed cells.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example executes the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Extract the header information from the ASCII DEM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the DEM as a `numpy` array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define our starting point as row and column in the array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare a flood elevation value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Filter the terrain to only the desired elevation value and below.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Process the filtered array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a 1, 0, 0 array (that is, a binary array) with flooded pixels as 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the flood inundation array as an ASCII Grid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This example can take a minute or two to run on a slower machine; we'll use
    the `print` statements throughout the script as a simple way to track progress.
    Once again we'll break this script up with explanations, for clarity.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our data, we can begin our flood fill function.
  prefs: []
  type: TYPE_NORMAL
- en: The flood fill function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We use ASCII Grids in this example, which means that the engine for this model
    is completely in NumPy. We start off by defining the `floodFill()` function, which
    is the heart and soul of this model. This Wikipedia article on flood fill algorithms
    provides an excellent overview of the different approaches: [http://en.wikipedia.org/wiki/Flood_fill](http://en.wikipedia.org/wiki/Flood_fill).
  prefs: []
  type: TYPE_NORMAL
- en: Flood fill algorithms start at a given cell and begin checking the neighboring
    cells for similarity. The similarity factor might be color or, in our case, elevation.
    If the neighboring cell is of the same or lower elevation as the current cell,
    then that cell is marked for checks of its neighbor until the entire grid is checked.
    NumPy isn't designed to crawl over an array in this way, but it is still efficient
    in handling multidimensional arrays overall. We step through each cell and check
    its neighbors to the north, south, east, and west. Any of those cells which can
    be flooded are added to the filled set, and their neighbors are added to the fill
    set to be checked by the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, if you try to add the same value to a set twice, it just
    ignores the duplicate entry and maintains a unique list. By using sets in an array,
    we efficiently check a cell only once because the fill set contains unique cells.
    The following code implements our `floodFill` function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First we import our libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create our `floodFill` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create sets to track the cells that we''ve already covered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we create our inundation array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can loop through the cells and flood them, or not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If the land is higher than the floodwater, skip it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If the land elevation is equal to or less than the floodwater, fill it in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we check the surrounding neighbor cells to see if they need to be filled,
    and when we run out of cells, we return the flooded matrix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've set up our `floodFill` function, we can create a flood.
  prefs: []
  type: TYPE_NORMAL
- en: Predicting flood inundation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the remainder of the script, we load our terrain data from an ASCII Grid,
    define our output grid filename, and execute the algorithm on the terrain data.
    The seed of the flood fill algorithm is an arbitrary point, as `sx` and `sy` within
    the lower elevation areas. In a real-world application, these points would likely
    be a known location, such as a stream gauge or a breach in a dam. In the final
    step, we save the output grid.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps need to be performed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we set up our `source` and `target` data names:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we open the source:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll create a mask array of everything below `70` meters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll parse the geospatial information from the header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll establish a starting point that is located in a riverbed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we trigger our `floodFill` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can save our flood inundation model output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The image in the following screenshot shows the flood inundation output over
    a classified version of the DEM, with lower elevation values in brown, mid-range
    values in green, and higher values in gray and white:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4696dc35-3027-456b-9b02-a54473c43317.png)'
  prefs: []
  type: TYPE_IMG
- en: The flood raster, which includes all areas less than 70 meters, is colored blue.
    This image was created with QGIS, but it could be displayed in ArcGIS as EPSG:4326\.
    You could also use GDAL to save the flood raster grid as an 8-bit TIFF file or
    JPEG file, just like the NDVI example, in order to view it in a standard graphics
    program.
  prefs: []
  type: TYPE_NORMAL
- en: 'This image in the following screenshot is nearly identical, except for the
    filtered mask from which the inundation was derived, which is displayed in yellow.
    This is done by generating a file for the array called `wet`, instead of `fld`,
    to show the non-contiguous regions, which were not included as part of a flood.
    These areas are not connected to the source point, so they would unlikely be reached
    during a flood event:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/714014f4-74aa-4ba5-96ee-a99f77b6caca.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By changing the elevation value, you can create additional flood inundation
    rasters. We started with an elevation of 70 meters. If we increase that value
    to 90, we can expand the flood. The following screenshot shows a flood event at
    both 70 and 90 meters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/499dbc17-5925-49a3-abc6-a7cf2a17be77.png)'
  prefs: []
  type: TYPE_IMG
- en: The 90 meter inundation is the lighter-blue polygon. You can take bigger or
    smaller steps and show different impacts as different layers.
  prefs: []
  type: TYPE_NORMAL
- en: This model is an excellent and useful visualization. However, you could take
    this analysis even further by using GDAL's `polygonize()` method on the flood
    mask, as we did with the island in the *Extracting features from images* section
    in [Chapter 6](13990656-5786-445c-878b-8b262ad6f3c0.xhtml), *Python and Remote
    Sensing*. This operation would give you a vector flood polygon. Then, you could
    use the principles that we discussed in the *Performing selections* section in
    [Chapter 5](306ed8f8-99dd-4751-b273-9d76cfac4ec2.xhtml), *Python and Geographic
    Information Systems*, to select buildings using the polygon to determine population
    impact. You could also combine that flood polygon with the dot density example
    in [Chapter 5](306ed8f8-99dd-4751-b273-9d76cfac4ec2.xhtml), *Python and Geographic
    Information Systems*, in the *Dot density calculations* section, to assess the
    potential population impact of a flood. The possibilities are endless.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a color hillshade
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we'll combine previous techniques to combine our terrain hillshade
    from [Chapter 7](964b7276-1604-4df5-b549-6d8f61d5e9cb.xhtml), *Python and Elevation
    Data,* with the color classification that we used on the LIDAR. For this example,
    we'll need the ASCII Grid DEMs named `dem.asc` and `relief.asc` that we used in
    the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll create a colorized DEM and a hillshade, and then use PIL to blend them
    together for an enhanced elevation visualization. The code comments will guide
    you through the example, as many of these steps are already familiar to you:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import the libraries that we need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: For this next part, you'll need the following two files: [https://github.com/GeospatialPython/Learn/raw/master/relief.zip](https://github.com/GeospatialPython/Learn/raw/master/relief.zip)
    and [https://github.com/GeospatialPython/Learn/raw/master/dem.zip](https://github.com/GeospatialPython/Learn/raw/master/dem.zip).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we''ll set up variables for the inputs and outputs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll load our `relief` image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll load the DEM image, so that we''ll have the elevation data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll create a new image for our colorization with elevation breakpoints
    forming classes and corresponding colors in a LUT:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now perform our color classification:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can convert our shaded relief array to an image, as well as our colorized
    DEM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll blend the two images for the final effect and save it to an image
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image shows the output, which makes a great backdrop for GIS
    maps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/20daa808-1730-438a-9f52-098550887189.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we can model terrain, let's learn how to navigate over it.
  prefs: []
  type: TYPE_NORMAL
- en: Performing least cost path analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Calculating driving directions is the most commonly used geospatial function
    in the world. Typically, these algorithms calculate the shortest path between
    points *A* and *B*, or they may take into account the speed limit of the road,
    or even current traffic conditions, in order to choose a route by drive time.
  prefs: []
  type: TYPE_NORMAL
- en: But what if your job is to build a new road? Or what if you are in charge of
    deciding where to run power transmission lines or water lines across a remote
    area? In a terrain-based setting, the shortest path might cross a difficult mountain,
    or run through a lake. In this case, we need to account for obstacles and avoid
    them if possible. However, if avoiding a minor obstacle takes us too far out of
    our way, the cost of implementing that route may be more expensive than just going
    over a mountain.
  prefs: []
  type: TYPE_NORMAL
- en: This type of advanced analysis is called **least cost path analysis**. We search
    an area for the route that is the best compromise of distance versus the cost
    of following that route. The algorithm that we use for this process is called
    the **A-star or A*** algorithm. The oldest routing method is called the **Dijkstra
    algorithm**, which calculates the shortest path in a network, such as a road network.
    The A* method can do that as well, but it is also better suited for traversing
    a grid-like DEM.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find out more about these algorithms on the following web pages:'
  prefs: []
  type: TYPE_NORMAL
- en: Dijkstra's algorithm: [http://en.wikipedia.org/wiki/Dijkstra's_algorithm](http://en.wikipedia.org/wiki/Dijkstra's_algorithm).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A* algorithm: [http://en.wikipedia.org/wiki/A-star_algorithm](http://en.wikipedia.org/wiki/A-star_algorithm).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This example is the most complex in this chapter. To better understand it, we
    have a simple version of the program, which is text based, and operates on a 5
    x 5 grid with randomly generated values. You can actually see how this program
    follows the algorithm before trying it on an elevation grid with thousands of
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'This program executes the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a simple grid with randomly generated pseudo-elevation values between
    1 and 16.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a start location in the lower-left corner of the grid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the end point as the upper-right corner of the grid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a cost grid that has the elevation of each cell, plus the cell's distance
    to the finish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Examine each neighboring cell from the start, and choose the one with the lowest
    cost.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the evaluation using the chosen cell until we get to the end.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the set of chosen cells as the least cost path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the test grid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You simply run this program from the command line and view its output. The first
    section of this script sets up our artificial terrain grid as a randomly generated
    NumPy array, with notional elevation values between 1 and 16\. We also create
    a distance grid that calculates the distance for each cell to the destination
    cell. This value is the cost of each cell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll import `numpy` and set the size of our grid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we set a starting location cell and an ending location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create a grid of zeros based on our width and height:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll set up our distance grid in order to create impedance values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll print out the cost value of each cell in our cost grid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a simulated terrain grid to work with, we can test a routing
    algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: The simple A* algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The A* search algorithm that is implemented here crawls the grid in a similar
    fashion to our flood fill algorithm in the previous example. Once again, we use
    sets to avoid using recursion, and to avoid the duplication of cell checks. But
    this time, instead of checking elevation, we check the distance cost of routing
    through a cell in question. If the move raises the cost of getting to the end,
    then we go with a lower-cost option.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps need to be performed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll start our A* function by creating sets that will keep track of
    the path progress:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add the starting cell to the open list of cells in order to process
    and begin looping through that set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We check the surrounding cells as options for forward progress:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We then check each option for the best option and append it to the path until
    we reach the end:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the algorithm set up, we can test it out by creating a path.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the test path
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll generate a path on our test grid. We''ll call our A*
    function, using the starting point, end point, cost grid, and distance grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll put our path on its own grid and print it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Next, we'll view the output of this test.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing the test output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you run this program, you''ll generate a randomly-numbered grid similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The grid is small enough such that you can easily trace the algorithm's steps
    manually. This implementation uses **Manhattan distance**, which means the distance
    does not use diagonal lines—only left, right, up, and down measurements. The search
    also does not move diagonally in order to keep things simple.
  prefs: []
  type: TYPE_NORMAL
- en: The real-world example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a basic understanding of the A* algorithm, let's move to a
    more complex example. For the relief example, we'll use the same DEM that is located
    near Vancouver, British Columbia, Canada, which we used in [Chapter 7](964b7276-1604-4df5-b549-6d8f61d5e9cb.xhtml),
    *Python and Elevation Data*, in the *Creating a shaded relief* section. The spatial
    reference for this grid is EPSG:26910 NAD 83/UTM zone 10N. You can download the
    DEM, relief, and start and end points of the shapefile as a zipped package from [http://git.io/v3fpL](http://git.io/v3fpL).
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll actually use the shaded relief for visualization. Our goal in this exercise
    will be to move from the start to the finish point in the lowest-cost way possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/100d0634-af6e-4cd1-b470-87d25217cda3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Just looking at the terrain, there are two paths that follow low-elevation
    routes without much change in direction. These two routes are illustrated in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c28f9cf-7567-4fd4-94c2-d2ad351c2988.png)'
  prefs: []
  type: TYPE_IMG
- en: So, we would expect that when we used the A* algorithm, it would be close. Remember
    that the algorithm is only looking in the immediate vicinity, so it can't look
    at the whole image like we can, and it can't make adjustments early in the route
    based on a known obstacle ahead.
  prefs: []
  type: TYPE_NORMAL
- en: We will expand this implementation from our simple example and use Euclidean
    distance, or *as the crow flies* measurements, and we will also allow the search
    to look in eight directions instead of four. We will prioritize terrain as the
    primary decision point. We will also use distance, both to the finish and from
    the start, as lower priorities in order to make sure that we are moving forward
    toward the goal and not getting too far off track. Other than those differences,
    the steps are identical to the simple example. The output will be a raster with
    the path values set to one and the other values set to zero.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the problem, let's solve it!
  prefs: []
  type: TYPE_NORMAL
- en: Loading the grid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section and the following sections, we''ll create the script that can
    create a route over terrain. The script starts out simple enough. We load the
    grid into a NumPy array from an ASCII Grid. We name our output path grid, and
    then we define the starting cell and end cell:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import our libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll define our input and output data sources:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can load the grid skipping over the header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll parse the header for the geospatial and grid size information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ll define our starting and end locations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Now that our grid is loaded, we can set up the functions that we'll need.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the helper functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need three functions in order to route over terrain. One is the A* algorithm,
    and the other two assist the algorithm in choosing the next step. We'll briefly
    discuss these helper functions. First, we have a simple Euclidean distance function
    named `e_dist`, which returns the straight-line distance between two points as
    map units. Next, we have an important function called `weighted_score`, which
    returns a score for a neighboring cell, based on the elevation change between
    the neighbor and the current cell, as well as the distance to the destination.
  prefs: []
  type: TYPE_NORMAL
- en: This function is better than distance or elevation alone because it reduces
    the chance of there being a tie between two cells, making it easier to avoid back-tracking.
    This scoring formula is loosely based on a concept called the **Nisson Score**,
    which is commonly used in these types of algorithms and is referenced in the Wikipedia
    articles mentioned earlier in this chapter. What's great about this function is
    that it can score the neighboring cell with any values that you wish. You might
    also use a real-time feed to look at the current weather in the neighboring cell,
    and avoid cells with rain or snow.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code will create our distance function and our weighting function
    that we''ll need to traverse the terrain:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll create a Euclidean distance function that will give us the distance
    between points:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll create our weight function in order to score each node for its
    suitability to move:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We start with a `score` of `0` and check the node''s distance from the end
    and the start:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we examine the neighboring nodes and make a decision on where to move:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Now that our helper functions are complete, we can build the A* function.
  prefs: []
  type: TYPE_NORMAL
- en: The real-world A* algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This algorithm is more involved than the simple version in our previous example.
    We use sets to avoid redundancy. It also implements our more advanced scoring
    algorithm and checks to make sure we aren''t at the end of the path before doing
    additional calculations. Unlike our last example, this more advanced version also
    checks cells in eight directions, so the path can move diagonally. There is a
    `print` statement at the end of this function that is commented out. You can uncomment
    it in order to watch the search crawl through the grid. The following code will
    implement the A* algorithm that we will use for the rest of the section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we open the function by accepting a starting point, an end point, and
    a score:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we set up the sets that will track progress:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we begin processing using our starting point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'If we hit the end, we return the completed path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, we keep working through the grid and eliminating possibilities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'To keep things moving, we grab all of the neighbors that need to be processed
    as we go:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'We check each neighbor for being the destination:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'We take the first option as the `best` option and process the other options,
    upgrading as we go:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our routing algorithm, we can generate a real-world path.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a real-world path
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we create our real-world path as a chain of ones in a grid of zeros.
    This raster can then be brought into an application such as QGIS and visualized
    over the terrain grid. In the following code, we''ll use our algorithm and helper
    functions to generate a path, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we send our start and end points, as well as our terrain grid, to the
    routing function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have a path, we can save it out as an ASCII Grid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we want to save our path data because the points are in the correct order,
    from the starting point to the end point. When we put them into the grid, we lose
    that order because it is all one raster. We''ll use the built-in Python `pickle`
    module to save the list object to disk. We''re going to use this data in the next
    section to create a vector shapefile of the route. So, we''ll save our path data
    as a pickled Python object that we can reuse later, without running the whole
    program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output route of our search:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/931aa6a2-3312-40cf-86c0-fb529190bf04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the A* search came very close to one of our manually selected
    routes. In a couple of cases, the algorithm chose to tackle some terrain, instead
    of trying to go around it. Sometimes the slight terrain is deemed less of a cost
    than the distance to go around it. You can see examples of that choice in this
    zoomed-in portion of the upper-right section of the route. The red line is the
    route that our program generated through the terrain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b4471f0d-911d-4874-9da1-fef9899f8455.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We only used two values: terrain and distance. But you could also add hundreds
    of factors, such as soil type, water bodies, and existing roads. All of these
    items could serve as an impedance or an outright wall. You would just modify the
    scoring function in the example to account for any additional factors. Keep in
    mind, the more factors you add, the more difficult it is to trace what the A*
    implementation was *thinking* when it chose the route.'
  prefs: []
  type: TYPE_NORMAL
- en: An obvious future direction for this analysis would be to create a vector version
    of this route as a line. The process would include mapping each cell to a point
    and then using nearest-neighbor analysis to order the points properly, before
    saving it as a shapefile or GeoJSON file.
  prefs: []
  type: TYPE_NORMAL
- en: Converting the route to a shapefile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The raster version of the least cost path route is useful for visualization,
    but it isn''t much good for analysis because it is embedded in the raster, and
    it is, therefore, difficult to relate to other datasets as we have done so many
    other times in this book. Our next goal will be to use the path data that we saved
    when creating the route to create a shapefile since the saved data is in the proper
    order. The following code will convert our raster path to a shapefile that is
    easier to use in a GIS for analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll import the modules that we need, which aren''t many. We''ll use
    the `pickle` module to restore the path `data` object. Then, we''ll use the `linecache`
    module to read the geospatial header information from the path raster in order
    to map the path rows and columns to the earth coordinates. Finally, we''ll use
    the `shapefile` module to export the shapefile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll create a function to convert rows and columns to *x* and *y* coordinates.
    The function accepts the metadata header information from the path raster file,
    as well as the column and row number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll restore the `path` object from the pickled object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll parse the metadata information from the path raster file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need a list object to hold the converted coordinates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we convert each raster location from the least cost path object into a
    geospatial coordinate and store it in the list that we created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, with just a few lines, we write out a line shapefile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Good work! You have created a program that can automatically navigate through
    obstacles, based on a set of rules, and exported it to a file that you can display
    and analyze in a GIS! We only used three rules, but you can add additional restrictions
    on how the program picks a path by adding other datasets, such as weather or water
    bodies, or anything else you can imagine.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand blazing a path across an arbitrary surface, we'll look
    at routing through a network.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating satellite image cloud cover
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Satellite images give us a powerful bird's-eye view of the Earth. They are useful
    for a variety of purposes, which we saw in [Chapter 6](13990656-5786-445c-878b-8b262ad6f3c0.xhtml),
    *Python and Remote Sensing*. However, they have one flaw—clouds. As a satellite
    passes around the Earth and collects imagery, it inevitably images clouds. And
    in addition to obstructing our view of the Earth, the cloud data can adversely
    affect remote sensing algorithms by wasting CPU cycles on useless cloud data,
    or skew the results by introducing unwanted data values.
  prefs: []
  type: TYPE_NORMAL
- en: The solution is to create a cloud mask. A cloud mask is a raster that isolates
    the cloud data in a separate raster. You can then use that raster as a reference
    when processing the image in order to avoid cloud data, or you can even use it
    to remove the clouds from the original image.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we''ll create a cloud mask for a Landsat image using the `rasterio`
    module and the `rio-l8qa` plugin. The cloud mask will be created as a separate
    image that just contains clouds:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to download some sample Landsat 8 satellite image data as a ZIP
    file from [http://bit.ly/landsat8data](http://bit.ly/landsat8data).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the download icon in the top right to download the data as a ZIP file,
    and unzip it to a directory named `l8`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, make sure you have the raster libraries that we need by running `pip`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll create the cloud mask by first importing the libraries that we
    need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to provide a reference to our satellite image directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to locate the quality-assurance metadata for the satellite data,
    which gives us the information that we need to generate the cloud mask:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we use the quality-assurance file to create a cloud mask TIFF file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image is just the band 7 (short-wave infrared) image from the
    Landsat 8 dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ba31b2b-92f2-4011-8886-cb094f201bef.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next image is the cloud mask image containing only the location of clouds
    and shadows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1379f25-777b-405a-b3e8-f67fb7d071f3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And finally, here''s the mask over the image, showing the clouds as black:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e4c9c790-616c-47ed-a00c-14016e0d066d.png)'
  prefs: []
  type: TYPE_IMG
- en: This example brushes the surface of what you can do with image masking. Another
    `rasterio` module, `rio-cloudmask`, allows you to calculate the cloud mask from
    scratch without using the quality-assurance data. But it requires some additional
    pre-processing steps. You can learn more about that here: [https://github.com/mapbox/rio-cloudmask.](https://github.com/mapbox/rio-cloudmask)
  prefs: []
  type: TYPE_NORMAL
- en: Routing along streets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Routing along streets uses a connected network of lines, which is called a graph.
    The lines in the graph can have impedance values, which discourage a routing algorithm
    from including them in a route. Examples of impedance values often include traffic
    volume, speed limit, or even distance. A key requirement for a routing graph is
    that all of the lines, known as edges, must be connected. Road datasets that are
    created for mapping will often have lines whose nodes do not intersect.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we'll calculate the shortest route through a graph by distance.
    We'll use a start and end point, which are not nodes in the graph, meaning we'll
    have to first find the graph nodes that are the closest to our start and destination
    points.
  prefs: []
  type: TYPE_NORMAL
- en: To calculate the shortest route, we'll use a powerful pure Python graph library
    called NetworkX. NetworkX is a general network graphing library that can create,
    manipulate, and analyze complex networks, including geospatial networks. If `pip`
    does not install NetworkX on your system, then you can find instructions for downloading
    and installing NetworkX for different operating systems at [http://networkx.readthedocs.org/en/stable/](http://networkx.readthedocs.org/en/stable/).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the road network and the start and end points, which are located
    along the U.S. Gulf Coast, as a ZIP file from [http://git.io/vcXFQ](http://git.io/vcXFQ).
    Then, you can follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll need to import the libraries we''re going to use. In addition
    to NetworkX, we’ll use the PyShp library in order to read and write shapefiles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll define the current directory as our output directory for the route
    shapefile that we''ll create:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we’ll need a function that can calculate the distance between points in
    order to populate the impedance values of our graph and to find the nodes closest
    to our start and destination points for the route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll create another function, which returns pairs of points from a
    list, to give us the line segments that we''ll use to build our graph edges:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll define our road network shapefile. This road network is a subset
    of a U.S. interstate highway files shapefile from the **United States Geological
    Survey** (**USGS**), which has been edited to ensure all the roads are connected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll create a graph with NetworkX and add the shapefile segments as
    graph edges:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can extract the connected components as a subgraph. However, in this
    case, we''ve ensured that the entire graph is connected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can read in the `start` and `end` points that we want to navigate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we loop through the graph, and assign distance values to each edge, using
    our `haversine` formula:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we must find the nodes in the graph that are the closest to our start
    and end points, in order to begin and end our route by looping through all of
    the nodes, and measuring the distance to our end points until we find the shortest
    distance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are ready to calculate the shortest distance through our road network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ll add the results to the shapefile and save our route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the road network in light gray, the start and
    end points, and the route in black. You can see that the route cuts across the
    road network in order to reach the road that is the nearest to the end point in
    the shortest possible distance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/76184867-4eac-4033-a072-0e4d76b85f28.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we know how to create various types of routes, we can look at locating
    photos that you might take while traveling along a route.
  prefs: []
  type: TYPE_NORMAL
- en: Geolocating photos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Photos that are taken with GPS-enabled cameras, including smartphones, store
    location information in the header of the file in a format called **EXIF** tags.
    These tags are based largely on the same header tags that are used by the TIFF
    image standard. In this example, we'll use those tags to create a shapefile with
    point locations for the photos, and file paths to the photos, as attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use the PIL in this example because it has the ability to extract EXIF
    data. Most photos that are taken with smartphones are geotagged images; however,
    you can download the set used in this example from [https://git.io/vczR0](http://git.io/vczR0):'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll import the libraries that we need, including PIL for the image
    metadata and PyShp for the shapefiles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll need three functions. The first function extracts the EXIF data.
    The second function converts **degree, minutes, seconds** (**DMS**) coordinates
    to decimal degrees (EXIF data stores GPS data as DMS coordinates). The third function
    extracts the GPS data and performs the coordinate conversion:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will loop through the photos, extract the coordinates, and store the
    coordinates and filename in a dictionary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will save the photo information as a shapefile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'The filenames of the photos in the shapefile are now attributes of the point
    locations where the photos were taken. GIS programs including QGIS and ArcGIS
    have the tools to turn those attributes into links when you click on the photo
    path or the point. The following screenshot from QGIS shows that one of the photos
    opens after clicking on the associated point using the Run Feature Action tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f2c3918e-5f85-4a8f-aa32-2da3fcf5192e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To view the result, please use the following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Download QGIS from [https://qgis.org](http://qgis.org) and follow the installation
    instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open QGIS and drag the `photos.shp` file onto the blank map.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Layer panel on the left, right-click the layer named Photos and select
    Properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the Actions tab, click the green plus sign to open the new actions dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Type drop-down menu, select Open.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Description field, enter Open Image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the Insert button in the lower-right corner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the OK button, and then close the properties dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the small black arrow to the right of the Run Feature Action tool,
    which is a gear icon with a green center and a white arrow in it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the menu that pops up, choose Open Image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, click on one of the points on the map to see the geotagged image popup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's move from an image taken on the Earth, to images taken of the Earth
    itself, by working with satellite images.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to create three real-world products, which are
    used every day in government, science, and industry. Apart from where this analysis
    is typically done with **black box** packages—costing thousands of dollars—we
    were able to use very minimal and free cross-platform Python tools. And in addition
    to the examples in this chapter, you now have some more reusable functions, algorithms,
    and processing frameworks for other advanced analyses, which will allow you to
    solve new problems that you come across in fields such as transportation, agriculture,
    and weather.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we''ll move into a relatively new area of geospatial analysis:
    real-time and near real-time data.'
  prefs: []
  type: TYPE_NORMAL
