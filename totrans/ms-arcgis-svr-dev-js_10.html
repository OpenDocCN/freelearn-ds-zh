<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div class="chapter" title="Chapter 10. Testing"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Testing</h1></div></div></div><p>When you publish a website or a web application to the public, users expect it to work. Links are supposed to take their places, and buttons are supposed to do things. They may not have the technical knowhow to look in good their browser console or observe network traffic. They may even have good reason to disable JavaScript on their browser.</p><p>The truth is, sometimes websites don't work because of hardware, software, or user error, but at other times the cause comes from the developer's buggy code. Maybe the code was pieced together from a cut-and-paste collage of code samples and stack overflow answers. Then the developer rushes to test the application once or twice, using the same workflow they use every time they write a component.</p><p>Maybe, though, something changed outside of the developer's control. Maybe a feature attribute that once held numeric values now contains strings. Maybe the API was updated and there was a fundamental change in the application. Maybe a REST data service is down, or maybe some bored kid is trying to input random data or malicious SQL injection code to bring down the website.</p><div class="section" title="Testing through code"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec95"/>Testing through code</h1></div></div></div><p>These are all good reasons to create tests for your applications. Testing <a id="id795" class="indexterm"/>is one method of ensuring that your code does as expected. It defines clear use cases, with clearly defined, expected results. Testing also acts as a sort of project documentation. It tells other developers who work with the project how the code is supposed to behave.</p><p>Now that you understand why testing is important, let's look at the <a id="id796" class="indexterm"/>testing methodologies used by other developers over the years.</p><div class="section" title="Unit testing"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec151"/>Unit testing</h2></div></div></div><p>Unit testing is <a id="id797" class="indexterm"/>when individual components or modules of code are loaded into a testing framework and tested individually. Tests are developed and results are compared to expected values. For object-oriented programming, individual objects can be loaded and tested without having to wait for other components to load.</p><p>JavaScript objects and modules lend themselves well to unit testing. Developers can write scripts to load modules individually, pass values into functions and objects, and see what comes out. Passing the tests ensures the JavaScript modules and objects will perform as far as expected test cases go.</p><p>However, unit testing <a id="id798" class="indexterm"/>doesn't prevent all errors. While they tests the input and output of objects and functions, they don't test how these objects interact. What happens when two or more memory-intense modules are running in the same browser? What happens to module A when input expected from module B times out? Also, unit testing doesn't address user experience concerns. It's hard to write a unit test for a map that pans slower than I think it should. Clearly, unit testing can't be the only tool in your testing tool belt.</p></div><div class="section" title="Functional testing"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec152"/>Functional testing</h2></div></div></div><p>Functional testing <a id="id799" class="indexterm"/>handles the <a id="id800" class="indexterm"/>testing of a single process, instead of a single unit. It makes many of the changes expected in a workflow, and checks that the results line up with what is expected. While one or more unit tests may cover the components tested in the functional test, the functional test connects them together to simulate a real-world example.</p><p>An example might be the calculation of <a id="id801" class="indexterm"/><span class="strong"><strong>Value Added Tax</strong></span> (<span class="strong"><strong>VAT</strong></span>) on an online purchase in European countries. You might have unit tests that cover the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Whether Italy has the correct VAT percentage</li><li class="listitem" style="list-style-type: disc">What the subtotal of a list of purchased items costs</li><li class="listitem" style="list-style-type: disc">What the total cost of a purchase would be after VAT is applied</li></ul></div><p>With a functional test, you can string them all together. You could ask, given that a person in Italy purchases these items, does the total cost after VAT matches what is expected.</p></div><div class="section" title="End-to-end testing"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec153"/>End-to-end testing</h2></div></div></div><p>If unit testing <a id="id802" class="indexterm"/>examines the individual components of an application and functional testing tests a single workflow, then end-to-end testing <a id="id803" class="indexterm"/>examines the whole thing from beginning to end. The entire application is loaded into a platform specially designed for handling tests. A user script is loaded with predefined actions, such as text to enter or buttons to click. Any errors are logged by the system for review. Some testing frameworks even record screenshots or video of the testing process for review.</p><p>End-to-end testing is meant to catch the errors generated by components interacting with one another. They also tend to catch improper implementation of the components (that is human error). However, end-to-end testing can be expensive in terms of computer resources and time. The more use cases you test using end-to-end testing, the longer it will take to get results. End-to-end testing is typically saved for code releases or nightly build processes, while unit testing is expected to cover the minor code changes between releases.</p><p>There are a number of paid services available on the web for end-to-end testing. For some frameworks, such as Angular, there are testing frameworks such as <span class="strong"><strong>Protractor</strong></span>.js that can be used for end-to-end testing, but if you want end-to-end testing that is both free and framework agnostic, you have options. Open source libraries such as Phantom.js, Casper.js, and web browser automation tools such as Selenium, can help you test your application from start to finish, with a bit of setup.</p></div></div></div></div></div>
<div id="book-content"><div id="sbo-rt-content"><div class="section" title="Testing as you code"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec96"/>Testing as you code</h1></div></div></div><p>Many developers <a id="id804" class="indexterm"/>have found that the best time to test their code is when they are writing it. It's a horrible feeling when you spend all day writing a module, only to have it fail and not know why. By creating unit tests in the middle of development, the developer receives quick feedback regarding whether part of their code succeeds or fails. Now, let's look at some ways developers write tests as they code.</p><div class="section" title="Test-Driven Development"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec154"/>Test-Driven Development</h2></div></div></div><p>
<span class="strong"><strong>Test-Driven Development</strong></span> (<span class="strong"><strong>TDD</strong></span>) is <a id="id805" class="indexterm"/>the <a id="id806" class="indexterm"/>process of writing unit tests and end-to-end tests, then writing code to pass those tests. Whenever code is refactored, it runs through the same tests to ensure results come out as expected.</p><p>Developers using TDD tend to code using the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Write a test based on requirements.</li><li class="listitem">Run all tests and see that the new test fails. This eliminates unnecessary tests and tests the overall testing framework.</li><li class="listitem">Write some code to pass the test.</li><li class="listitem">Run the tests again.</li><li class="listitem">Refactor as necessary to clean up ugly code, names, and functionality.</li><li class="listitem">Repeat steps 1 to 5 until done.</li></ol></div><p>By writing <a id="id807" class="indexterm"/>the test before <a id="id808" class="indexterm"/>writing code, the developer keeps their focus on the module's objectives and does not write unnecessary code. The tests also give the developer confidence in the code, and lead to faster code development.</p></div><div class="section" title="Behavior-Driven Development"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec155"/>Behavior-Driven Development</h2></div></div></div><p>
<span class="strong"><strong>Behavior-Driven Development</strong></span> (<span class="strong"><strong>BDD</strong></span>) is <a id="id809" class="indexterm"/>a form of TDD that answers the question "how much should I test?". In BDD, tests <a id="id810" class="indexterm"/>for code modules and objects are written with descriptions that start with "It should do _____". Code tests are then written to test for those features and those only.</p><p>BDD tests help to both define acceptance criteria and document code. By looking through the test descriptions, other developers will have a better idea of what the code is supposed to do. By describing acceptance criteria up front, the developer doesn't have to write extra code for use cases the code will never experience.</p></div><div class="section" title="Test statements"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec156"/>Test statements</h2></div></div></div><p>At the <a id="id811" class="indexterm"/>heart of every TDD and BDD setup is the test statement. The<a id="id812" class="indexterm"/> test statements are lines of code written in a readable format to test properties and values of results. Test statements define a simple test within unit tests or functional tests.</p><p>Depending on the library you choose for generating test statements, they may follow a BDD <code class="literal">should</code> pattern, a TDD <code class="literal">expect</code> pattern, or a TDD <code class="literal">assert</code> pattern. Some libraries may let you use one or more of these patterns for your tests. For example, using the <code class="literal">Chai.js</code> library (which we'll discuss a little later in the chapter), we can look at examples using any of the three patterns. Tests using the <a id="id813" class="indexterm"/><code class="literal">should</code> pattern might look like the following:</p><div class="informalexample"><pre class="programlisting">chai.should();

country.should.be.a('string');
country.should.equal('Greece');
country.should.have.length(6);
texas.should.have.property('counties')
  .with.length(253);</pre></div><p>The <code class="literal">expect</code> pattern <a id="id814" class="indexterm"/>may look something like the following:</p><div class="informalexample"><pre class="programlisting">var expect = chai.expect;

expect(country).to.be.a('string');
expect(country).to.equal('Greece');
expect(country).to.have.length(6);
expect(texas).to.have.property('counties')
  .with.length(253);</pre></div><p>Finally, the <a id="id815" class="indexterm"/><code class="literal">assert</code> pattern <a id="id816" class="indexterm"/>should look something like the following:</p><div class="informalexample"><pre class="programlisting">var assert = chai.assert;

assert.typeOf(country, 'string');
assert.equal(country, 'Greece');
assert.lengthOf(country, 6)
assert.property(texas, 'counties');
assert.lengthOf(texas.counties, 253);</pre></div><p>All three <a id="id817" class="indexterm"/>formats test the same things. Their only difference is the syntax they use to get the same results. Depending on which testing formats your team likes to write, many of the testing libraries will have something in that flavor.</p><p>Now that we've reviewed the general concepts behind software testing, let's look at the tools we have to work with. In the last few years, the JavaScript community has produced a number of testing frameworks. Some are specific to a framework, such as Protractor for Angular, while others work with almost any library or framework, such as Mocha, Jasmine, or Intern. In this chapter, we're going to examine two of them: Intern and Jasmine.</p></div></div></div></div>
<div id="book-content"><div id="sbo-rt-content"><div class="section" title="Intern testing framework"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec97"/>Intern testing framework</h1></div></div></div><p>Intern (<a class="ulink" href="https://theintern.github.io/">https://theintern.github.io/</a>) is <a id="id818" class="indexterm"/>a testing <a id="id819" class="indexterm"/>framework for testing websites and applications. Its website boasts that not only can it test plain JavaScript applications, but also test server-side websites built with Ruby and PHP, as well as mobile iOS, Android, and Firefox apps. Intern supports AMD and promises asynchronous testing.</p><p>If you're using Node.js in your development environment, Intern may integrate well. If you use Grunt, Intern comes with its own Grunt tasks for easy integration into your existing workflow. Intern also works with continuous integration services such as Jenkins and Travis CI.</p><p>Intern works <a id="id820" class="indexterm"/>in most modern browsers, including Android Browser, Chrome, Firefox, Safari, Opera, and Internet Explorer. For Internet Explorer, Intern works with versions 9 and later. If you need to test older versions of Internet Explorer, there is an <code class="literal">intern-geezer</code> module available through <code class="literal">npm</code>. The tests will work with Internet Explorer versions 6-8, which do not support EcmaScript 5, which is required by regular Intern.</p><div class="section" title="Setting up your testing environment"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec157"/>Setting up your testing environment</h2></div></div></div><p>If you're using Node.js, installation <a id="id821" class="indexterm"/>can be as simple as <code class="literal">npm install intern</code>. According to the website, Intern has a recommended folder structure for your projects, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6459OT_10_01.jpg" alt="Setting up your testing environment" width="877" height="354"/></div><p>The makers of Intern recommend that you keep your source code and distributable code in folders separate from the tests. In that way, the tests aren't accidently published along with the code. You may not want people finding your tests, which could expose your secured services, private API keys, and sensitive passwords.</p><div class="section" title="Special requirements for the ArcGIS JavaScript API"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec127"/>Special requirements for the ArcGIS JavaScript API</h3></div></div></div><p>According to <a id="id822" class="indexterm"/>reports from several users, using Intern with ESRI's hosted link to the ArcGIS API for JavaScript is not recommended. It can cause tests to fail where they shouldn't because a module and its dependencies load too slowly. The recommended solution is to download the API and the Dojo framework into folders alongside your project files. You can use Grunt, a Node.js task runner.</p></div></div><div class="section" title="Writing tests for Intern"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec158"/>Writing tests for Intern</h2></div></div></div><p>Writing tests for Intern <a id="id823" class="indexterm"/>was achieved with modules like Dojo's AMD style in mind. Once module paths have been assigned, these modules can be loaded into tests and run. Let's look at how to do that.</p><div class="section" title="Unit testing with Intern"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec128"/>Unit testing with Intern</h3></div></div></div><p>Writing <a id="id824" class="indexterm"/>unit tests for Intern is very similar to writing <code class="literal">Dojo</code> modules, with a few exceptions. Each unit test is made up of a <code class="literal">define()</code> function. The <code class="literal">define()</code> function may take either a function with a single <code class="literal">require</code> argument, or a list of string references to modules, and a function to run when all those modules have loaded. It is a common practice in Node.js modules to load them individually through a single <code class="literal">require()</code> function.</p><p>You will need to load a testing interface and an assertion library in the unit testing function. The testing interface provides a way to register testing suites. When calling the interface as a function, you provide a JavaScript object with descriptive key strings and values containing functions to run tests or objects to classify subtests. An example unit test is shown in the following snippet:</p><div class="informalexample"><pre class="programlisting">define(function (require) {
  var registerSuite = require('intern!object');
  var assert = require('intern/chai!assert');

  registerSuite({
    'One plus one equals two': function () {
      Var result = 1 + 1;
      assert.equal(result, 2, "1 + 1 should add up to 2");

    },
    'Two plus two equals four': function () {
      Var result = 2 + 2;
      assert.equal(result, 4, "2 + 2 should add up to 4");
    }
  });
});</pre></div><p>In the preceding code, the <code class="literal">registerSuite</code> variable accepts Intern's object interface for creating tests, while <code class="literal">assert</code> accepts the <code class="literal">chai.assert</code> library loaded with Intern. The <code class="literal">registerSuite()</code>function is called, passing in two tests in an object. The first test looks at <a id="id825" class="indexterm"/>whether adding one and one will equal two, while the second test looks at adding two two's to see if that equals four. The <code class="literal">assert.equal()</code> function tests whether the result variable matches the expected result, and will throw an error with a text message should the test fail.</p></div><div class="section" title="Test lifecycle with Intern"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec129"/>Test lifecycle with Intern</h3></div></div></div><p>There may be <a id="id826" class="indexterm"/>something you need to do before you run your test in a testing suite, or before and after each test. This is the test lifecycle. Intern provides keywords in your test definitions to define what should happen during the test lifecycle. All these lifecycle functions are optional, but they will help you to create useable tests. Here is an outline of the general lifecycle of a test:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">setup</code>: This <a id="id827" class="indexterm"/>function runs before any of the tests run, presumably to set up something to test against. For example, you may create a map here before you test your widget against it.</li><li class="listitem" style="list-style-type: disc">During each test, the following events occur:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">beforeEach</code>: This function will run before each test. As an example, you might load a fresh copy of your widget.</li><li class="listitem" style="list-style-type: disc">The test runs.</li><li class="listitem" style="list-style-type: disc"><code class="literal">afterEach</code>: This function will run after each test. Here, you might destroy the widget you created in the <code class="literal">beforeEach</code> function, or you might reset variable values that may have changed during tests.</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">teardown</code>: This <a id="id828" class="indexterm"/>function runs after all the tests within the suite run. Here, you might destroy any maps or objects you created in the <code class="literal">setup</code> phase.</li></ul></div><p>You can see an example of a unit test using the lifecycle in the following code. This one simulates loading a map and adding a widget to the map:</p><div class="informalexample"><pre class="programlisting">define(["intern!object", "intern/chai!expect", "esri/map", "app/widget"], 
function (registerSuite, expect, Map, Widget) {
  var map, widget;
  registerSuite({
    setup: function () {
      map = new Map("mapdiv", {});
    },
    beforeEach: function () {
      widget = new Widget({map: map}, "widget");
    },
    afterEach: function () {
      widget.destroy();
    },
    teardown: function () {
      map.destroy();
    },
    'My first test': function () {
      // test content goes here.
    }
  });
});</pre></div><p>In the <a id="id829" class="indexterm"/>preceding code, the <code class="literal">define</code> statement looks a lot like the one we're familiar with, loading multiple objects at once. Note that the <code class="literal">map</code> is created on <code class="literal">setup</code> and destroyed on <code class="literal">teardown</code>, while the <code class="literal">widget</code> is newly created before each test and destroyed after each test.</p></div></div></div></div></div>
<div id="book-content"><div id="sbo-rt-content"><div class="section" title="Jasmine testing framework"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec98"/>Jasmine testing framework</h1></div></div></div><p>If you're looking <a id="id830" class="indexterm"/>for a simple BDD framework to test your application, Jasmine might have what you need. Jasmine is a framework-independent BDD library that can be used to run tests on JavaScript applications. It can either be installed through Node.js, or the library can be downloaded and copied to the test project folder.</p><p>Jasmine loads its test in an HTML file called a <code class="literal">SpecRunner</code> (short for specifications runner). This page loads the main Jasmine library, as well as all the user libraries and unit tests. Once loaded, the Jasmine library runs tests in the browser and displays the results.</p><div class="section" title="Writing tests for Jasmine"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec159"/>Writing tests for Jasmine</h2></div></div></div><p>Once we have the <a id="id831" class="indexterm"/><code class="literal">SpecRunner</code> in place, it's time to write tests. Tests are written using normal JavaScript logic and a few testing objects and methods provided by Jasmine. Let's look at some of the different parts.</p><div class="section" title="Writing suites, specs, and tests"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec130"/>Writing suites, specs, and tests</h3></div></div></div><p>Jasmine tests are organized by suites, specs, and tests. Suites make up the top level, and describe the unit tested. In fact, Jasmine tests write the suites using the <code class="literal">describe()</code> function, which describes the feature to be tested. The arguments for the <code class="literal">describe()</code> function include a string describing the feature, and a function to run the tests.</p><p>Specs for the features can be written using the <code class="literal">it()</code> function in the <code class="literal">describe</code> suite. The <code class="literal">it()</code> function, like the <code class="literal">describe()</code> function, contains a string to describe the test and a function where a test is performed on the behavior. Any errors that occur in the <code class="literal">it()</code> function lead to a failing test, while an <code class="literal">it()</code> function that runs successfully shows a passing test for the behavior. In the following you can see an example of a <code class="literal">describe()</code> and <code class="literal">it()</code> statement:</p><div class="informalexample"><pre class="programlisting">describe("A widget listing the attributes of the U.N.", 
  function () {
    it("has its headquarters located in New York City.", 
      function () {
        //tests go here
      }
    );
  }
);</pre></div><p>Inside each spec is one or more tests. In Jasmine, tests are written in the expect format. Based on the object passed to the <code class="literal">expect</code> object, you have numerous tests that can be performed on it, such as whether or not it equals a specific value, or whether it comes back as a "truthy" JavaScript statement:</p><div class="informalexample"><pre class="programlisting">describe("A widget listing the attributes of the U.N.", 
  function () {
  // unitedNations.countries is a string array of country names.
  it("contains more than 10 countries.", function () {
    expect(unitedNations.countries.length).toBeGreaterThan(10);
  });
  it("should contain France as a member country.", function () {
    expect(unitedNations.countries).toContain("France");
  });
});</pre></div></div><div class="section" title="Setup and teardown"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec131"/>Setup and teardown</h3></div></div></div><p>There are times when you will need to load modules or create JavaScript objects to test. You may also want to reset them between tests and tear them down to save memory. To set up and tear down items to be tested, you would use the <code class="literal">beforeEach</code> and <code class="literal">afterEach</code> functions. Each one lets you set up and tear down values between tests, so that each test has fresh values that are repeatable. These are loaded in the suites, and are supposed to be called before any specs that require them are called:</p><div class="informalexample"><pre class="programlisting">describe("A widget listing the attributes of the U.N.", 
  function () {
    var unitedNations;

    beforeEach(function () {
      unitedNations = new UnitedNations();
    });

    afterEach(function () { 
      unitedNations.destroy();
    });

    it("should do something important", function () {
      //…
    });
  }
);</pre></div></div><div class="section" title="Ignoring tests"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec132"/>Ignoring tests</h3></div></div></div><p>What if your module has a depreciated feature? What if you expect your module to have a feature one day, but you don't want to write a test that fails now. You could delete or comment out the code, but in doing so you lose some of the history of your module in some respect. Jasmine has a way of disabling suites and marking specs as pending without losing code. By replacing your <code class="literal">describe</code> statements with <code class="literal">xdescribe</code>, and your <code class="literal">it</code> statements with <code class="literal">xit</code>, you can write tests that won't fail now, but will be marked as "pending". You can find an example in the following code that uses <code class="literal">xit</code>:</p><div class="informalexample"><pre class="programlisting">xit("Elbownia will join the United Nations next year.", 
  function () {
    expect(unitedNations.countries).toContain("Elbownia");
  }
);</pre></div></div></div><div class="section" title="Red-light green-light"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec160"/>Red-light green-light</h2></div></div></div><p>Many <a id="id832" class="indexterm"/>developers who write TDD and BDD tests practice red-green testing, which is supported in Jasmine. Red stands for a failed test, while green stands for a passed test. In red-green testing, a developer does the following:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Writes a necessary unit test that they know will fail (red).</li><li class="listitem">Writes code for the object or module so that the test passes (green).</li><li class="listitem">Refactors the code as needed, making sure it still passes the test.</li><li class="listitem">Repeats steps 1 to 3 until both the code and tests are satisfactory.</li></ol></div><p>Using the red-green testing method, the developer keeps the tests in mind as they develop module functionality. Passing tests gives the developer confidence in their code, and allows for faster development.</p><p>In Jasmine, test results <a id="id833" class="indexterm"/>on the <code class="literal">SpecRunner</code> HTML page are displayed using red and green colors. Red colors are shown when a test fails, while green colors show when all tests pass. The <code class="literal">SpecRunner</code> page will display which specification failed (if any), and the error thrown when the failure occurred. Armed with that information, the developer can fix the problem and move on to the next step in development.</p></div><div class="section" title="Jasmine and the ArcGIS JavaScript API"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec161"/>Jasmine and the ArcGIS JavaScript API</h2></div></div></div><p>Setting up <a id="id834" class="indexterm"/>your <code class="literal">SpecRunner</code> for applications using the ArcGIS JavaScript API is a little more challenging. The AMD nature of the Dojo framework makes loading the modules and tests a little more challenging, but it can be done.</p><p>The first step is to load the Jasmine and ArcGIS JavaScript APIs into the application. Due to all the parts that Jasmine has to handle outside our application, and because AMD modules tend to not show up when errors occur, we need to load Jasmine before the ArcGIS JavaScript API:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
  &lt;title&gt;Jasmine Spec Runner&lt;/title&gt;

  &lt;link rel="stylesheet" href="https://js.arcgis.com/3.13/esri/css/esri.css" /&gt;
  &lt;link rel="stylesheet" type="text/css" href="tests/jasmine/jasmine.css" /&gt;

  &lt;script type="text/javascript" src="tests/jasmine/jasmine.js"&gt;
  &lt;/script&gt;
  &lt;script type="text/javascript" src="tests/jasmine/jasmine-html.js" &gt;&lt;/script&gt;

  &lt;script type="text/javascript"&gt;var dojoConfig={};&lt;/script&gt;
  &lt;script type="text/javascript" src=" https://js.arcgis.com/3.13/" &gt;&lt;/script&gt;
&lt;/head&gt;</pre></div><p>You will be able to load the locations of both your modules, and the tests on those modules, in the <code class="literal">dojoConfig</code> packages. We will be using the AMD loader to load the test suites as modules. In the following example, the AMD modules are in the <code class="literal">js</code> subfolder, while the spec tests are in the <code class="literal">tests</code> subfolder. The <code class="literal">dojoConfig</code> package should look something like the following:</p><div class="informalexample"><pre class="programlisting">Var basePath = location.pathname.replace(/\/[^\/]*$/, '');
var dojoConfig = {
  async: true,
  packages: [
    {
      name: 'app',
      location: basePath + '/js/'
    }, {
      name: 'spec',
      location: basePath + "/tests/"
    }
  ]
};</pre></div><p>Since many <a id="id835" class="indexterm"/>of your custom widgets will require other modules, including other custom modules, to load, you need to keep the path for your custom modules the same as in your application.</p><p>In the body of the HTML document, add a script to call the specs through Dojo's <code class="literal">require()</code> function. The code will load the specs out of the tests subfolder through AMD. When the modules have loaded and the <code class="literal">dojo/ready</code> function is called, we will load Jasmine's <code class="literal">HtmlReporter</code> and execute the Jasmine testing:</p><div class="informalexample"><pre class="programlisting">&lt;body&gt;
&lt;script type="text/javascript"&gt;
  require([
    "dojo/ready",
    "spec/Widget1",
    "spec/Widget2",
    "spec/Widget3"
  ], function (ready) {

    ready(function () {
      // Set up the HTML reporter - this is responsible for
      // aggregating the results reported by Jasmine as the
      // tests and suites are executed.
      jasmine.getEnv().addReporter(
        new jasmine.HtmlReporter()
      );
      // Run all the loaded test specs.
      jasmine.getEnv().execute();
    });
  });
&lt;/script&gt;
&lt;/body&gt;</pre></div><p>When the tests <a id="id836" class="indexterm"/>are loaded and run, they will be rendered on this HTML page in the browser.</p><div class="section" title="In the specs"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec133"/>In the specs</h3></div></div></div><p>Normally, Jasmine specs <a id="id837" class="indexterm"/>can either be run as a script or enclosed in a self-running JavaScript function. However, to work with Dojo, they need to be enclosed in module definitions. Unlike the custom modules we've made in the past, we won't use the <code class="literal">dojo/_base/declare</code> module to make a custom module. We'll simply use the <code class="literal">define()</code> statement to load the necessary modules, and run the test inside it.</p><p>For each suite, use the <code class="literal">define()</code> statement to help load the tests. You could also load any other ArcGIS JavaScript API modules or widgets you might need to help test the module. The code for the <code class="literal">Widget1</code> spec, as requested by the main app, might look like the following:</p><div class="informalexample"><pre class="programlisting">define(["app/Widget1", "esri/geometry/Point"], 
  function (Widget1, Point) {

});</pre></div><p>Start writing Jasmine specs in the <code class="literal">define</code> statement. When the suite modules are loaded, they will automatically run any tests inside them and display the results on the <code class="literal">SpecRunner</code> page in the browser. You can use <code class="literal">beforeEach</code> to load a fresh module for testing, and <code class="literal">afterEach</code> to destroy it, if necessary. You can perform any custom ArcGIS JavaScript API-related tasks within the suites and specs:</p><div class="informalexample"><pre class="programlisting">define(["app/Widget1", "esri/geometry/Point"], 
  function (Widget1, Point) {

  describe("My widget does some incredible tasks.", function () {
    var widget, startingPoint;

    // before each test, make a new widget from a staring point.
    beforeEach(function () {
      startingPoint = new Point([-43.5, 87.3]);
      widget = new Widget({start: startingPoint}); 
    });

    // after each test, destroy the widget.
    afterEach(function () {
      widget.destroy();
    });

    it("starts at the starting point", function () {
      expect(widget.start.X).toEqual(startingPoint.X);
      expect(widget.start.Y).toEqual(startingPoint.Y);
    });
    //…
  });

});</pre></div><p>Once you <a id="id838" class="indexterm"/>have your tests defined, you can view the <code class="literal">SpecRunner</code> page in the browser and check out the results. If you have set everything up, you should have tests running and displaying results. Have a look at the following screenshot for an example:</p><div class="mediaobject"><img src="graphics/6459OT_10_02.jpg" alt="In the specs" width="590" height="508"/></div></div></div><div class="section" title="Use case for Jasmine and the ArcGIS JavaScript API"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec162"/>Use case for Jasmine and the ArcGIS JavaScript API</h2></div></div></div><p>Jasmine <a id="id839" class="indexterm"/>provides an easy-to-write testing environment for your JavaScript widgets. If you are new to unit testing and BDD, and you aren't comfortable with setting up the Node.js environment on top of your tests, then Jasmine is a good place to start. All the libraries you need can be downloaded from GitHub, and you can begin writing tests almost right away.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>Jasmine can be downloaded from its GitHub repository at <a class="ulink" href="https://github.com/jasmine/jasmine">https://github.com/jasmine/jasmine</a>. Documentation for Jasmine can be found at <a class="ulink" href="http://jasmine.github.io/.">http://jasmine.github.io/.</a> If you are interested in more reading material on this framework, you can read <span class="emphasis"><em>Jasmine JavaScript Testing, Second Edition</em></span> by Paulo Ragonha, or <span class="emphasis"><em>Jasmine Cookbook</em></span> by Munish Sethi.</p></div></div></div></div></div></div>
<div id="book-content"><div id="sbo-rt-content"><div class="section" title="Our application"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec99"/>Our application</h1></div></div></div><p>For our <a id="id840" class="indexterm"/>application, we're going to set up unit testing for our Y2K map app using Intern. Unlike our other applications, which only required a browser, we're going to use Node.js for this setup. If we were following real TDD/BDD practices, we would have written these tests while we were developing the application. However, this will give you practice writing tests for any legacy applications you've previously written.</p><p>For this sample, we'll follow the example provided by David Spriggs and Tom Wayson through GitHub (<a class="ulink" href="https://github.com/DavidSpriggs/intern-tutorial-esri-jsapi">https://github.com/DavidSpriggs/intern-tutorial-esri-jsapi</a>). We'll make some modifications to work with more recent updates in both the ArcGIS JavaScript API and in the modules associated with the tests.</p><div class="section" title="Adding testing files"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec163"/>Adding testing files</h2></div></div></div><p>In our Y2K application, we're <a id="id841" class="indexterm"/>going to <a id="id842" class="indexterm"/>add several files to work with the required Node.js modules. We'll add a <code class="literal">package.json</code> file, which tells the <a id="id843" class="indexterm"/><span class="strong"><strong>Node Package Manager</strong></span> (<span class="strong"><strong>NPM</strong></span>) what modules we need and what version numbers we require. Next, we'll add a <code class="literal">Grunt.js</code> file, since we'll use Grunt to load the ArcGIS JavaScript API locally. We'll also add a <code class="literal">bower.json</code> file for Bower to load the correct <code class="literal">Dojo</code> libraries locally, and a <code class="literal">.bowerc</code> file to configure Bower when we run it. Finally, we're going to add an <code class="literal">intern.js</code> file in a <code class="literal">tests</code> folder to configure the Intern tests.</p><p>Our new folder structure should look like the following:</p><div class="mediaobject"><img src="graphics/6459OT_10_03.jpg" alt="Adding testing files" width="203" height="347"/></div><div class="section" title="The package.json file"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec134"/>The package.json file</h3></div></div></div><p>In our <a id="id844" class="indexterm"/><code class="literal">package.json</code> file, we'll add the file <a id="id845" class="indexterm"/>dependencies required for our Node.js modules. When specifying version numbers for some of the modules, you'll note that some have a tilde (~) in front while others have a caret symbol(<code class="literal">^</code>). A tilde matches both major and minor version numbers (the first and second numbers in the three-number version code), while the caret will pull the most recent matching major version number. Copy the following into your <code class="literal">package.json</code> file:</p><div class="informalexample"><pre class="programlisting">{
  "name": "intern-tutorial-esri-jsapi",
  "repository": {
    "type": "git",
    "url": "https://github.com/DavidSpriggs/intern-tutorial-esri-jsapi.git"
  },
  "version": "0.2.0",
  "devDependencies": {
    "dojo": "^1.10",
    "esrislurp": "^1.1.0",
    "grunt": "^0.4",
    "grunt-contrib-watch": "~0",
    "grunt-esri-slurp": "^1.4.7",
    "intern": "^2.0.3",
    "selenium-server": "2.38.0"
  }
}</pre></div></div><div class="section" title="The Grunt setup"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec135"/>The Grunt setup</h3></div></div></div><p>Grunt is <a id="id846" class="indexterm"/>a <a id="id847" class="indexterm"/>popular task runner used in Node.js applications. It's used to automate code building steps, such <a id="id848" class="indexterm"/>as minifying JavaScript, creating CSS files from CSS preprocessors like LESS or SASS, or, in this case, testing code. Grunt reads a <code class="literal">Grunt.js</code> file, which tells it where to look for files and what to do with them. In our <code class="literal">Grunt.js</code> file, we're going to add the following code:</p><div class="informalexample"><pre class="programlisting">module.exports = function(grunt) {
    grunt.initConfig({
        intern: {
            dev: {
                options: {
                    runType: 'runner',
                    config: 'tests/intern'
                }
            }
        },
        esri_slurp: {
      options: {
        version: '3.13'
      },
            dev: {
                options: {
                    beautify: false
                },
      dest: 'esri'
            }
        },
       esri_slurp_modules:{
      options: {
      version: '3.13',
      src: './',
      dest: './modules'
        }
    },
        watch: {
            all: {
                options: { livereload: true },
                files: ['src/js/*.js']
            }
        }
    });

    // Loading using a local copy
    grunt.loadNpmTasks('intern');
    grunt.loadNpmTasks('grunt-contrib-watch');
    grunt.loadNpmTasks('grunt-esri-slurp');

    // download Esri JSAPI
    grunt.registerTask('slurp', ['esri_slurp']);
    grunt.registerTask('create_modules', ['esri_slurp_modules']);

    // Register a test task
    grunt.registerTask('test', ['intern']);

    // By default we just test
    grunt.registerTask('default', ['test']);
};</pre></div><p>In the <a id="id849" class="indexterm"/>preceding code, Node.js <a id="id850" class="indexterm"/>expects that we will pass our module definition to the <code class="literal">module.exports</code> variable. We tell Grunt where to find our <code class="literal">intern</code> module for testing in <code class="literal">grunt.initConfig</code>, and <code class="literal">esri_slurp</code> for downloading the ArcGIS JavaScript API. We also tell it to watch the <code class="literal">src/js/</code> folder for any changes to JavaScript files, which will trigger the tests to run again.</p><p>Once the configuration has loaded, we tell Grunt to load the modules for <code class="literal">intern</code>, <code class="literal">grunt-contrib-watch</code>, and <code class="literal">grunt-esri-slurp</code> to modules from <code class="literal">npm</code>. The tasks are then registered, and everything is set up to run the tests.</p></div><div class="section" title="Setting up Bower"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec136"/>Setting up Bower</h3></div></div></div><p>Bower is <a id="id851" class="indexterm"/>a Node.js module <a id="id852" class="indexterm"/>used to <a id="id853" class="indexterm"/>download all the required JavaScript libraries for a project automatically. We will use Bower to download the libraries and Dojo modules necessary to run our tests. Most common libraries and frameworks can be downloaded locally through Bower. Our exception in this case is the ArcGIS JavaScript API, which will currently be handled through <code class="literal">esri-slurp</code>. We need to fill out a <code class="literal">bower.json</code> file to tell Bower what libraries we need, and what library versions they should be as well.</p><p>Within our <code class="literal">bower.json</code> file, we need to create a JSON object to list our project name, version number, dependencies, and any development dependencies. We can name it whatever we want, so we'll name it <code class="literal">y2k-map-app</code>. We'll give it a version of <code class="literal">0.0.1</code> for testing, and we'll be sure to increment it whenever dependencies or library version numbers need to be updated. We have no development dependencies in this case, but we do need to list the parts of the Dojo framework, as well as <code class="literal">D3.js</code> , in this application.</p><p>We not only need to <a id="id854" class="indexterm"/>list the <a id="id855" class="indexterm"/>libraries and modules required for the tests, but the version numbers as well. We can refer to the ArcGIS JavaScript API <span class="emphasis"><em>What's New</em></span> page at <a class="ulink" href="https://developers.arcgis.com/javascript/jshelp/whats_new.html">https://developers.arcgis.com/javascript/jshelp/whats_new.html</a> to find out. According to the page, we need version <code class="literal">1.10.4 </code>of the Dojo framework, including <code class="literal">dojo</code>, <code class="literal">dijit</code>, <code class="literal">dojox</code>, and <code class="literal">util</code> modules from <code class="literal">dojo/util</code>. We also need to add the <code class="literal">dgrid</code> modules with version <code class="literal">0.3.16</code>, <code class="literal">put-selector</code> version <code class="literal">0.3.6</code>, and <code class="literal">xstyle</code> version <code class="literal">0.1.3</code>. Referring back to the <code class="literal">dojoConfig</code> packages from our <code class="literal">index.html</code> page, we see that <code class="literal">d3.js</code> is using version <code class="literal">3.5.6</code>. We'll list the dependencies within a JSON object, with the version numbers preceded by a <code class="literal">#</code> sign. The contents of our <code class="literal">bower.json</code> file should be the following:</p><div class="informalexample"><pre class="programlisting">{
  "name": "y2k-map-app",
  "version": "0.0.1",
  "dependencies": {
    "dijit": "#1.10.4",
    "dojo": "#1.10.4",
    "dojox": "#1.10.4",
    "util": "dojo-util#1.10.4",
    "dgrid": "#0.3.16",
    "put-selector": "#0.3.6",
    "xstyle": "#0.1.3",
    "d3": "#3.5.6"
  },
  "devDependencies": {}
}</pre></div><p>For the <code class="literal">.bowerc</code> file, we're going to add a simple configuration object. In the configuration object JSON, we're going to add a directories field and assign a value of <code class="literal">.</code>. This will tell Bower to load the files requested in this folder. The contents of the <code class="literal">.bowerc</code> file should look like the following:</p><div class="informalexample"><pre class="programlisting">{"directories": "."}</pre></div></div><div class="section" title="Intern.js configuration"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec137"/>Intern.js configuration</h3></div></div></div><p>Now we need to set up our <a id="id856" class="indexterm"/><code class="literal">Intern.js</code> configuration file <a id="id857" class="indexterm"/>in the <code class="literal">tests</code> folder to run our tests. We'll start by adding some default code in the page. More information on this configuration file can be found at <a class="ulink" href="https://github.com/theintern/intern/wiki/Configuring-Intern">https://github.com/theintern/intern/wiki/Configuring-Intern</a>. Start by copying the following content:</p><div class="informalexample"><pre class="programlisting">// Learn more about configuring this file at &lt;https://github.com/theintern/intern/wiki/Configuring-Intern&gt;.
// These default settings work OK for most people. The options that *must* be changed below are the
// packages, suites, excludeInstrumentation, and (if you want functional tests) functionalSuites.
define({
  // The port on which the instrumenting proxy will listen
  proxyPort: 9000,

  // A fully qualified URL to the Intern proxy
  proxyUrl: 'http://localhost:9000/',

  // Default desired capabilities for all environments. Individual capabilities can be overridden by any of the
  // specified browser environments in the `environments` array below as well. See
  // https://code.google.com/p/selenium/wiki/DesiredCapabilities for standard Selenium capabilities and
  // https://saucelabs.com/docs/additional-config#desired-capabilities for Sauce Labs capabilities.
  // Note that the `build` capability will be filled in with the current commit ID from the Travis CI environment
  // automatically
  capabilities: {
    'selenium-version': '2.38.0'
  },

  // Browsers to run integration testing against. Note that version numbers must be strings if used with Sauce
  // OnDemand. Options that will be permutated are browserName, version, platform, and platformVersion; any other
  // capabilities options specified for an environment will be copied as-is
  environments: [{
    browserName: 'internet explorer',
    version: '10',
    platform: 'Windows 8'
  }, {
    browserName: 'internet explorer',
    version: '9',
    platform: 'Windows 7'
  }, {
    browserName: 'firefox',
    version: '23',
    platform: ['Linux', 'Windows 7']
  }, {
    browserName: 'firefox',
    version: '21',
    platform: 'Mac 10.6'
  }, {
    browserName: 'chrome',
    platform: ['Linux', 'Mac 10.8', 'Windows 7']
  }, {
    browserName: 'safari',
    version: '6',
    platform: 'Mac 10.8'
  }],

  // Maximum number of simultaneous integration tests that should be executed on the remote WebDriver service
  maxConcurrency: 3,

  // Name of the tunnel class to use for WebDriver tests
  tunnel: 'SauceLabsTunnel',

  // Connection information for the remote WebDriver service. If using Sauce Labs, keep your username and password
  // in the SAUCE_USERNAME and SAUCE_ACCESS_KEY environment variables unless you are sure you will NEVER be
  // publishing this configuration file somewhere
  webdriver: {
    host: 'localhost',
    port: 4444
  },

  // The desired AMD loader to use when running unit tests (client.html/client.js). Omit to use the default Dojo
  // loader
  useLoader: {
    'host-node': 'dojo/dojo',
    'host-browser': 'node_modules/dojo/dojo.js'
  },

  // Configuration options for the module loader; any AMD configuration options supported by the Dojo loader can be
  // used here
  loader: {
    // Packages that should be registered with the loader in each testing environment
    packages:[]
  },

  // Non-functional test suite(s) to run in each browser
  suites: [],

  // A regular expression matching URLs to files that should not be included in code coverage analysis
  excludeInstrumentation: /^tests\//
});</pre></div><p>Inside <a id="id858" class="indexterm"/>the <code class="literal">loader.packages</code> list, we'll add the folder locations of all the files we expect to have. These will <a id="id859" class="indexterm"/>include both the files we have now, plus the files we expect to download through Bower. Note that our <code class="literal">app</code> folder is referenced through the folder where our <code class="literal">Census</code> widget is stored. Also, we're loading all the ESRI and Dojo files, as well as <code class="literal">D3.js</code> for the graphics. Your packages portion should look like the following:</p><div class="informalexample"><pre class="programlisting">packages: [{
  name: 'tests',
  location: 'tests'
}, {
  name: 'app',
  location: 'src/js'
}, {
  name: 'gis',
  location: 'gis'
}, {
  name: 'esri',
  location: 'esri'
}, {
  name: 'dgrid',
  location: 'dgrid'
}, {
  name: 'put-selector',
  location: 'put-selector'
}, {
  name: 'xstyle',
  location: 'xstyle'
}, {
  name: 'dojo',
  location: 'dojo'
}, {
  name: 'dojox',
  location: 'dojox'
}, {
  name: 'dijit',
  location: 'dijit'
}, {
  name: 'd3',
  location: 'd3'
}
], 
…</pre></div><p>We need to add the names of our test suites to the suites list. For now, we'll add the following:</p><div class="informalexample"><pre class="programlisting">…
// Non-functional test suite(s) to run in each browser
  suites: [
  'tests/Census'
],
…</pre></div><p>We should <a id="id860" class="indexterm"/>have <a id="id861" class="indexterm"/>everything we need in this file to run some successful tests on the <code class="literal">Census</code> widget. As we add more modules, we can expand this point with more tests.</p><p>We should be ready at this point to load the files we need through Node.js. If you haven't installed Node.js or any of the other node dependencies for this application, please follow the next section. If you already have, you can still review the next section, or skip it if you're already familiar with Grunt and Bower.</p></div></div><div class="section" title="If you haven't installed Node.js"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec164"/>If you haven't installed Node.js</h2></div></div></div><p>In this section, we'll go through <a id="id862" class="indexterm"/>the necessary steps to set up Node.js and the necessary dependencies. In these examples, we'll be working with NPM, Grunt, Grunt-CLI, and Bower. If you already have these set up in your development environment, you can skip to the next section.</p><p>If you haven't installed Node.js, you can download a copy from <a class="ulink" href="http://nodejs.org">http://nodejs.org</a>. On the home page, you'll find a link to the appropriate installer for your computer. Follow the directions in the installation wizard to install the software.</p><p>Node.js works through a command-line interface. All commands will be typed in either through a Linux or OSX terminal, or through the Windows command prompt (<code class="literal">cmd.exe</code>). Some portions may need you to have root or administrative access. Also, if you're using a Windows machine, the <code class="literal">PATH</code> variable may need to be updated to include both the <code class="literal">node.js</code> folder and its <code class="literal">node_modules</code> subfolder, where other commands and utilities will be loaded.</p><p>Next, if you <a id="id863" class="indexterm"/>have not installed the <code class="literal">grunt</code>, <code class="literal">grunt-cli</code>, and <code class="literal">bower</code> modules, we'll install them using <code class="literal">npm</code>. NPM comes built into Node.js and provides access to a multitude of plugins, libraries, and applications to help you generate applications faster. From your command prompt (or terminal), type the following to download the modules we need:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm install –g grunt</strong></span>
<span class="strong"><strong>npm install –g grunt-cli</strong></span>
<span class="strong"><strong>npm install –g bower</strong></span>
</pre></div><p>The <code class="literal">–g</code> flag tells <code class="literal">npm</code> to install the modules globally, so that they can be accessed anywhere that Node.js and <code class="literal">npm</code> can be called. Without the <code class="literal">–g</code> flag, the module will be loaded in a <code class="literal">node_modules</code> subfolder of your current directory.</p></div><div class="section" title="Loading all the libraries locally"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec165"/>Loading all the libraries locally</h2></div></div></div><p>Now it is time to load <a id="id864" class="indexterm"/>all of the Node.js applications necessary for testing. We're going to do the following:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Install all of our modules from <code class="literal">npm</code>.</li><li class="listitem">Load most of the external JavaScript libraries locally using Bower.</li><li class="listitem">Download the ArcGIS JavaScript API using Grunt Slurp.</li></ol></div><p>We'll start by loading all the modules from <code class="literal">npm</code>. You will need to use a command line tool like Windows command prompt (<code class="literal">cmd.exe</code>) or <code class="literal">terminal</code> for Mac or Linux to run the code. Our <code class="literal">package.json</code> file defines the modules we need to run. We can install the modules by typing the following in the command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm install</strong></span>
</pre></div><p>If we need to test for features in older browsers, such as Internet Explorer 8 or earlier, we will need to install an Intern extension called <code class="literal">intern-geezer</code>. It allows tests to work on older browsers that may not have the features used in standard Intern. If you need the older support, enter the following into the command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm install intern-geezer</strong></span>
</pre></div><p>To load our JavaScript libraries locally, we can call on Bower to install the files. Our <code class="literal">bower.json</code> file tells it what to load, and our <code class="literal">.bowerc</code> file tells it where to load it. Enter the following into the command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>bower install</strong></span>
</pre></div><p>Now, we <a id="id865" class="indexterm"/>need to load the ArcGIS JavaScript library for local testing. Since we defined everything for this task in our <code class="literal">Grunt.js</code> file, we can simply enter the following into the command line to download the files and start up our testing:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>grunt slurp</strong></span>
</pre></div><p>Now our project should be up and running. We can now focus on writing tests for our application.</p></div><div class="section" title="Writing our tests"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec166"/>Writing our tests</h2></div></div></div><p>We will be writing tests <a id="id866" class="indexterm"/>using the same <code class="literal">dojo</code> module definition style we used with creating objects, and similar to the Jasmine tests we talked about earlier. However, since Intern is designed for AMD, we can load the intern items within the module <code class="literal">define()</code> statements. In our tests folder, we'll create a file called <code class="literal">Census.js</code>, and let that contain our test module definition.</p><p>We will start by stubbing out our <code class="literal">define()</code> statement. We will load both Intern and Chai to run our tests. With Chai, we'll try using the <code class="literal">assert</code> module, where all test statements start with <code class="literal">assert</code>. We'll also load our <code class="literal">Census</code> widget and all the modules necessary to get it working, like a map. Since Intern typically runs without requiring HTML DOM, but our maps and <code class="literal">Census</code> widget require it, we'll add some modules to add elements to the DOM:</p><div class="informalexample"><pre class="programlisting">define([
   'intern!object',
   'intern/chai!assert',
   'app/Census',
   'esri/map',
   'dojo/dom-construct',
   'dojo/_base/window'
], function(registerSuite, assert, Census, Map, domConstruct, win) {
   //…
});</pre></div><p>Within the module definition, we'll add the variables for our map and <code class="literal">Census</code> widget, and then register our suite with Intern using <code class="literal">registerSuite()</code>. In the <code class="literal">registerSuite()</code> function, we'll pass an object containing the test name <code class="literal">Census Widget</code>. We'll also add two methods, <code class="literal">setup()</code> and <code class="literal">teardown()</code>, to call before and after all the tests have run:</p><div class="informalexample"><pre class="programlisting">…
var map, census;

registerSuite({
  name: 'Census Widget',
  // before the suite starts
  setup:function () {},
  // after all the tests have run
  teardown: function () {},
});
…</pre></div><p>In the <a id="id867" class="indexterm"/>setup function, we'll need to create the DOM, the map to attach to the DOM, and the <code class="literal">Census</code> widget to attach to the map. We'll use the <code class="literal">dojo/dom-construct</code> and the <code class="literal">dojo/_base/window</code> modules to create the DOM for both. Once the DOM elements have been created, we can initialize our map and census dijit. In our <code class="literal">teardown</code> function, we'll destroy the map so that it doesn't take up valuable memory space. The code should look like the following:</p><div class="informalexample"><pre class="programlisting">…
setup: function () {
  // create a map div in the body, load esri css, and create the map for our tests
  domConstruct.place('&lt;link rel="stylesheet" type="text/css" href="//js.arcgis.com/3.13/dijit/themes/claro/claro.css"&gt;', win.doc.getElementsByTagName("head")[0], 'last');

  domConstruct.place('&lt;link rel="stylesheet" type="text/css" href="//js.arcgis.com/3.13/esri/css/esri.css"&gt;', win.doc.getElementsByTagName("head")[0], 'last');

  domConstruct.place('&lt;div id="map" style="width:300px;height:200px;" class="claro"&gt;&lt;div id="census- widget"&gt;&lt;/div&gt;&lt;/div&gt;', win.body(), 'only');

  map = new Map("map", {
    basemap: "topo",
    center: [-122.45, 37.75],
    zoom: 13,
    sliderStyle: "small"
  });

  census = new Census({
    map: map,
    mapService: "http://sampleserver6.arcgisonline.com/arcgis/rest/services/Census/MapServer/"
  }, "census-widget");
},
… 
teardown: function () {
  map.destroy();
},
…</pre></div><p>Now that the <a id="id868" class="indexterm"/>map and the <code class="literal">Census</code> widget have been initialized, we can start adding tests. I'll walk you through three relatively straightforward tests. It is up to you to extend them further. In this exercise, we'll test the <code class="literal">Census</code> dijit for the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It should have all its working parts</li><li class="listitem" style="list-style-type: disc">It should return the correct query results when we make a known request</li><li class="listitem" style="list-style-type: disc">Parts of the charting widget should work as expected</li></ul></div><p>When writing the first test, we'll give it a label of <code class="literal">Test Census widget creation</code>. For the corresponding function, we'll start by testing if the <code class="literal">baseClass</code> for the dijit is as expected. We'll use <code class="literal">assert.strictEqual()</code> to test whether the value is correct. Note that <code class="literal">assert.strictEqual()</code> takes three arguments, two values to compare, and a string description of the test. That test should look like the following:</p><div class="informalexample"><pre class="programlisting">…
'Test Census widget creation': function() {
  assert.strictEqual(
    census.baseClass, 
    "y2k-census", 
    "census.baseClass should return a string 'y2k-census'"
  );
},
…</pre></div><p>Our second test may seem a little tricky, since it's an asynchronous test. However, Intern is designed to handle asynchronous testing as well. If necessary, we can tweak Intern's timeout before it considers the task failed, but for now we will just load the test.</p><p>In the query test, we'll <a id="id869" class="indexterm"/>send a query to the map service with all the states, and ask for a list of the states. Using a <code class="literal">then()</code> statement after the query, we can grab the results and test those using <code class="literal">assert.strictEqual()</code>. The test should look like the following:</p><div class="informalexample"><pre class="programlisting">…
'Test Census query for dropdown data': function () {

  census.queryShapeAndData({
  url: "http://sampleserver6.arcgisonline.com/arcgis/rest/services/Census/MapServer/3",
  fields: ["STATE_NAME", "STATE_FIPS"],
  where: "1=1",
  }).then(function (featureSet) { 
  assert.strictEqual(
      featureSet.features.length, 
      51, 
      "There should be 51 states returned, including the District of Columbia"
    );
  });
},
…</pre></div><p>Finally, for the graphing functions, we'll write tests to look at the functions we use to translate feature attribute data into a format that D3 can use. In this example, we'll pass attribute data through the <code class="literal">census.ethnicData()</code> method and test the output for expected values. Like other testing libraries, we can add more than one test within this specification. The test should look like the following:</p><div class="informalexample"><pre class="programlisting">'Test Census Graphing Attributes': function () {

  var ethnicAttributes = {
    WHITE: 10,
    BLACK: 20, 
    AMERI_ES: 12,
    ASIAN: 11,
    HAWN_PI: 4,
    HISPANIC: 23,
    OTHER: 7,
    MULT_RACE: 17
  };

  var data = census.ethnicData(ethnicAttributes);

  assert.strictEqual(
    data.length, 
    8, 
    "The translation from graphic attributes to d3-based data should have 8 attributes in the ethnicData function"
  );
  assert.strictEqual(
    data[4].name, 
    "Hawaiian / Pacific Islander", 
    "The item in index 4 should have a name of Hawaiian / Pacific Islander data"
  );
  assert.strictEqual(
    data[5].population, 
    23, 
    "Out of the Hispanic column, the data index of 5 should have a population of 23."
  );
}</pre></div></div><div class="section" title="Checking the results"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec167"/>Checking the results</h2></div></div></div><p>In order <a id="id870" class="indexterm"/>to check our tests, we need to load our file in the browser. Since we installed Intern as a node module, we'll need to view its test-running page. The file is located under <code class="literal">node_modules/intern/client.html</code>. You will need to specify where the tests are loaded in the browser by giving a query parameter of <code class="literal">config=tests/intern</code>. The following URL is an example you might view in a browser (it may be different depending on your setup): <code class="literal">http://localhost/MasteringArcGIS/Chapter10/node_modules/intern/client.html?config=tests/intern</code>.</p><p>When you correctly view the page, you'll be greeted with the Intern icon and a pass/fail report. Failing tests will be highlighted in red, while passing tests will be highlighted in green. You should see something like the following image:</p><div class="mediaobject"><img src="graphics/6459OT_10_04.jpg" alt="Checking the results" width="695" height="509"/></div></div></div></div></div>
<div id="book-content"><div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec100"/>Summary</h1></div></div></div><p>In this chapter, we have reviewed the reasons why we want to set up tests for our web applications. We have looked over different testing methodologies, development practices, and JavaScript libraries useful for testing our applications. Using Intern, we have set up tests for our own application.</p><p>In the next chapter, we'll look into the future of web applications for ArcGIS Server, checking into ArcGIS Online.</p></div></div></div></body></html>