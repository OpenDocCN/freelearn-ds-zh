["```py\nimport pycuda.autoinit\nfrom pycuda import gpuarray\nimport numpy as np\n```", "```py\nfrom skcuda import cublas\n```", "```py\na = np.float32(10)\nx = np.float32([1,2,3])\ny = np.float32([-.345,8.15,-15.867])\nx_gpu = gpuarray.to_gpu(x)\ny_gpu = gpuarray.to_gpu(y)\n```", "```py\ncublas_context_h = cublas.cublasCreate()\n```", "```py\ncublas.cublasSaxpy(cublas_context_h, x_gpu.size, a, x_gpu.gpudata, 1, y_gpu.gpudata, 1)\n```", "```py\ncublas.cublasDestroy(cublas_context)\n```", "```py\nprint 'This is close to the NumPy approximation: %s' % np.allclose(a*x + y , y_gpu.get())\n```", "```py\ndot_output = cublas.cublasSdot(cublas_context_h, v_gpu.size, v_gpu.gpudata, 1, w_gpu.gpudata, 1)\n```", "```py\nl2_output = cublas.cublasSnrm2(cublas_context_h, v_gpu.size, v_gpu.gpudata, 1)\n```", "```py\ncublasSgemv(handle, trans, m, n, alpha, A, lda, x, incx, beta, y, incy)  \n```", "```py\nm = 10\nn = 100\nalpha = 1\nbeta = 0\nA = np.random.rand(m,n).astype('float32')\nx = np.random.rand(n).astype('float32')\ny = np.zeros(m).astype('float32')\n```", "```py\nA_columnwise = A.T.copy()\nA_gpu = gpuarray.to_gpu(A_columnwise) \nx_gpu = gpuarray.to_gpu(x)\ny_gpu = gpuarray.to_gpu(y)\n```", "```py\ntrans = cublas._CUBLAS_OP['N']\n```", "```py\nlda = m \nincx = 1\nincy = 1\nhandle = cublas.cublasCreate()\n```", "```py\ncublas.cublasSgemv(handle, trans, m, n, alpha, A_gpu.gpudata, lda, x_gpu.gpudata, incx, beta, y_gpu.gpudata, incy)\n```", "```py\ncublas.cublasDestroy(handle)\nprint 'cuBLAS returned the correct value: %s' % np.allclose(np.dot(A,x), y_gpu.get())\n```", "```py\nimport pycuda.autoinit\nfrom pycuda import gpuarray\nimport numpy as np\nfrom skcuda import cublas\nfrom time import time\n```", "```py\nm = 5000\nn = 10000\nk = 10000\n```", "```py\ndef compute_gflops(precision='S'):\n\nif precision=='S':\n    float_type = 'float32'\nelif precision=='D':\n    float_type = 'float64'\nelse:\n    return -1\n```", "```py\nA = np.random.randn(m, k).astype(float_type)\nB = np.random.randn(k, n).astype(float_type)\nC = np.random.randn(m, n).astype(float_type)\nA_cm = A.T.copy()\nB_cm = B.T.copy()\nC_cm = C.T.copy()\nA_gpu = gpuarray.to_gpu(A_cm)\nB_gpu = gpuarray.to_gpu(B_cm)\nC_gpu = gpuarray.to_gpu(C_cm)\nalpha = np.random.randn()\nbeta = np.random.randn()\ntransa = cublas._CUBLAS_OP['N']\ntransb = cublas._CUBLAS_OP['N']\nlda = m\nldb = k\nldc = m\n```", "```py\nt = time()\nhandle = cublas.cublasCreate()\n```", "```py\nexec('cublas.cublas%sgemm(handle, transa, transb, m, n, k, alpha, A_gpu.gpudata, lda, B_gpu.gpudata, ldb, beta, C_gpu.gpudata, ldc)' % precision)\n```", "```py\ncublas.cublasDestroy(handle)\nt = time() - t\n```", "```py\ngflops = 2*m*n*(k+1)*(10**-9) / t \nreturn gflops\n```", "```py\nif __name__ == '__main__':\n    print 'Single-precision performance: %s GFLOPS' % compute_gflops('S')\n    print 'Double-precision performance: %s GFLOPS' % compute_gflops('D')\n```", "```py\nimport pycuda.autoinit\nfrom pycuda import gpuarray\nimport numpy as np\nfrom skcuda import fft\n```", "```py\nx = np.asarray(np.random.rand(1000), dtype=np.float32 )\nx_gpu = gpuarray.to_gpu(x)\nx_hat = gpuarray.empty_like(x_gpu, dtype=np.complex64)\n```", "```py\nplan = fft.Plan(x_gpu.shape,np.float32,np.complex64)\n```", "```py\ninverse_plan = fft.Plan(x.shape, in_dtype=np.complex64, out_dtype=np.float32)\n```", "```py\nfft.fft(x_gpu, x_hat, plan)\nfft.ifft(x_hat, x_gpu, inverse_plan, scale=True)\n```", "```py\ny = np.fft.fft(x)\nprint 'cuFFT matches NumPy FFT: %s' % np.allclose(x_hat.get(), y, atol=1e-6)\nprint 'cuFFT inverse matches original: %s' % np.allclose(x_gpu.get(), x, atol=1e-6)\n```", "```py\nprint 'cuFFT matches NumPy FFT: %s' % np.allclose(x_hat.get()[0:N//2], y[0:N//2], atol=1e-6)\n```", "```py\nfrom __future__ import division\nimport pycuda.autoinit\nfrom pycuda import gpuarray\nimport numpy as np\nfrom skcuda import fft\nfrom skcuda import linalg\nfrom matplotlib import pyplot as plt\n```", "```py\ndef cufft_conv(x , y):\n    x = x.astype(np.complex64)\n    y = y.astype(np.complex64)\n\n    if (x.shape != y.shape):\n        return -1\n```", "```py\nplan = fft.Plan(x.shape, np.complex64, np.complex64)\ninverse_plan = fft.Plan(x.shape, np.complex64, np.complex64)\n```", "```py\n x_gpu = gpuarray.to_gpu(x)\n y_gpu = gpuarray.to_gpu(y)\n\n x_fft = gpuarray.empty_like(x_gpu, dtype=np.complex64)\n y_fft = gpuarray.empty_like(y_gpu, dtype=np.complex64)\n out_gpu = gpuarray.empty_like(x_gpu, dtype=np.complex64)\n```", "```py\nfft.fft(x_gpu, x_fft, plan)\nfft.fft(y_gpu, y_fft, plan)\n```", "```py\nlinalg.multiply(x_fft, y_fft, overwrite=True)\n```", "```py\nfft.ifft(y_fft, out_gpu, inverse_plan, scale=True)\nconv_out = out_gpu.get()\nreturn conv_out\n```", "```py\ndef conv_2d(ker, img):\n\n    padded_ker = np.zeros( (img.shape[0] + 2*ker.shape[0], img.shape[1] + 2*ker.shape[1] )).astype(np.float32)\n    padded_ker[:ker.shape[0], :ker.shape[1]] = ker\n```", "```py\npadded_ker = np.roll(padded_ker, shift=-ker.shape[0]//2, axis=0)\npadded_ker = np.roll(padded_ker, shift=-ker.shape[1]//2, axis=1)\n```", "```py\npadded_img = np.zeros_like(padded_ker).astype(np.float32)\npadded_img[ker.shape[0]:-ker.shape[0], ker.shape[1]:-ker.shape[1]] = img\n```", "```py\nout_ = cufft_conv(padded_ker, padded_img)\n```", "```py\noutput = out_[ker.shape[0]:-ker.shape[0], ker.shape[1]:-ker.shape[1]]\n\nreturn output\n```", "```py\ngaussian_filter = lambda x, y, sigma : (1 / np.sqrt(2*np.pi*(sigma**2)) )*np.exp( -(x**2 + y**2) / (2 * (sigma**2) ))\n```", "```py\ndef gaussian_ker(sigma):\n    ker_ = np.zeros((2*sigma+1, 2*sigma+1))\n    for i in range(2*sigma + 1):\n        for j in range(2*sigma + 1):\n            ker_[i,j] = gaussian_filter(i - sigma, j - sigma, sigma)\n    total_ = np.sum(ker_.ravel())\n    ker_ = ker_ */* total*_* return ker_\n```", "```py\nif __name__ == '__main__':\n    akshada = np.float32(plt.imread('akshada.jpg')) / 255\n    akshada_blurred = np.zeros_like(akshada)\n```", "```py\nker = gaussian_ker(15)\n```", "```py\nfor k in range(3):\n    akshada_blurred[:,:,k] = conv_2d(ker, akshada[:,:,k])\n```", "```py\nfig, (ax0, ax1) = plt.subplots(1,2)\nfig.suptitle('Gaussian Filtering', fontsize=20)\nax0.set_title('Before')\nax0.axis('off')\nax0.imshow(akshada)\nax1.set_title('After')\nax1.axis('off')\nax1.imshow(akshada_blurred)\nplt.tight_layout()\nplt.subplots_adjust(top=.85)\nplt.show()\n```", "```py\nimport pycuda.autoinit\nfrom pycuda import gpuarray\nimport numpy as np\nfrom skcuda import linalg\n```", "```py\na = np.random.rand(1000,5000).astype(np.float32)\na_gpu = gpuarray.to_gpu(a)\n```", "```py\nU_d, s_d, V_d = linalg.svd(a_gpu,  lib='cusolver')\n```", "```py\nU = U_d.get()\ns = s_d.get()\nV = V_d.get()\n```", "```py\nS = np.zeros((1000,5000))\nS[:1000,:1000] = np.diag(s)\n```", "```py\nprint 'Can we reconstruct a from its SVD decomposition? : %s' % np.allclose(a, np.dot(U, np.dot(S, V)), atol=1e-5)\n```", "```py\nvals = [ np.float32([10,0,0,0,0,0,0,0,0,0]) , np.float32([0,10,0,0,0,0,0,0,0,0]) ]\n```", "```py\nfor i in range(3000):\n    vals.append(vals[0] + 0.001*np.random.randn(10))\n    vals.append(vals[1] + 0.001*np.random.randn(10))\n    vals.append(0.001*np.random.randn(10))\n```", "```py\nvals = np.float32(vals)\nvals = vals - np.mean(vals, axis=0)\nv_gpu = gpuarray.to_gpu(vals.T.copy())\n```", "```py\nU_d, s_d, V_d = linalg.svd(v_gpu, lib='cusolver')\n\nu = U_d.get()\ns = s_d.get()\nv = V_d.get()\n```"]