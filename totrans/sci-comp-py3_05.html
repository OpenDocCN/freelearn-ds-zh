<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Advanced Array Concepts"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Advanced Array Concepts</h1></div></div></div><p>In this chapter, we will explain some more advanced aspects of arrays. First, we will cover the notion of an array view, followed by Boolean arrays and how to compare arrays. We briefly describe indexing and vectorization, explain sparse arrays, and some special topics such as broadcasting.</p><div class="section" title="Array views and copies"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec42"/>Array views and copies</h1></div></div></div><p>In order to control precisely how memory is used, NumPy offers the concept of view of an array. Views are smaller arrays that share the same data as a larger array. This works just like a reference to one single object (refer to section <span class="emphasis"><em>Basic Types </em></span>in <a class="link" href="ch01.html" title="Chapter 1. Getting Started">Chapter 1</a>, <span class="emphasis"><em>Getting Started</em></span>).</p><div class="section" title="Array views"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec61"/>Array views</h2></div></div></div><p>The simplest example of a view is given by a slice of an array:</p><pre class="programlisting">M = array([[1.,2.],[3.,4.]])&#13;
v = M[0,:] # first row of M</pre><p>The preceding slice is a view of <code class="literal">M</code>. It shares the same data as <code class="literal">M</code>. Modifying <code class="literal">v</code> will modify <code class="literal">M</code> as well:</p><pre class="programlisting">v[-1] = 0.&#13;
v # array([[1.,0.]])&#13;
M # array([[1.,0.],[3.,4.]]) # M is modified as well</pre><p>It is possible to access the object that owns the data using the array attribute <code class="literal">base</code>:</p><pre class="programlisting">v.base # array([[1.,0.],[3.,4.]])&#13;
v.base is M # True</pre><p>If an array owns its data, the attribute base is none :</p><pre class="programlisting">M.base # None</pre></div><div class="section" title="Slices as views"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec62"/>Slices as views</h2></div></div></div><p>There are precise rules on which slices will return views and which ones will return copies. Only basic slices (mainly index expressions with <code class="literal">:</code>) return views, whereas any advanced selections (such as slicing with a Boolean) will return a copy of the data. For instance, it is possible to create new matrices by indexing with lists (or arrays):</p><pre class="programlisting">a = arange(4) # array([0.,1.,2.,3.])&#13;
b = a[[2,3]] # the index is a list [2,3]&#13;
b # array([2.,3.])&#13;
b.base is None # True, the data was copied&#13;
c = a[1:3]&#13;
c.base is None # False, this is just a view</pre><p>In the preceding example, the array <code class="literal">b</code> is not a view, whereas the array <code class="literal">c</code>, obtained with a simpler slice, is a view.</p><p>There is an especially simple slice of an array that returns a view of the whole array:</p><pre class="programlisting">N = M[:] # this is a view of the whole array M</pre></div><div class="section" title="Transpose and reshape as views"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec63"/>Transpose and reshape as views</h2></div></div></div><p>Some other important operations return views. For instance, transpose returns a view:</p><pre class="programlisting">M = random.random_sample((3,3))&#13;
N = M.T&#13;
N.base is M # True</pre><p>The same applies for all reshaping operations:</p><pre class="programlisting">v = arange(10)&#13;
C = v.reshape(-1,1) # column matrix&#13;
C.base is v # True</pre></div><div class="section" title="Array copy"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec64"/>Array copy</h2></div></div></div><p>Sometimes it is necessary to explicitly request that the data be copied. This is simply achieved with the NumPy function called <code class="literal">array</code>:</p><pre class="programlisting">M = array([[1.,2.],[3.,4.]])&#13;
N = array(M.T) # copy of M.T</pre><p>We may verify that the data has indeed been copied:</p><pre class="programlisting">N.base is None # True</pre></div></div></div>
<div class="section" title="Comparing arrays"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec43"/>Comparing arrays</h1></div></div></div><p>Comparing two arrays is not as simple as it may seem. Consider the following code, which is intended to check whether two matrices are close to each other:</p><pre class="programlisting">A = array([0.,0.])&#13;
B = array([0.,0.])&#13;
if abs(B-A) &lt; 1e-10: # an exception is raised here&#13;
    print("The two arrays are close enough")</pre><p>This code raises the exception when the <code class="literal">if</code> statement is executed:</p><pre class="programlisting">ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()</pre><p>In this section, we explain why this is so and how to remedy this state of affairs.</p><div class="section" title="Boolean arrays"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec65"/>Boolean arrays</h2></div></div></div><p>Boolean arrays are useful for advanced array indexing (refer to section <span class="emphasis"><em>Indexing with Boolean arrays</em></span>). A Boolean array is simply an array for which the entries have the type <code class="literal">bool</code>:</p><pre class="programlisting">A = array([True,False]) # Boolean array&#13;
A.dtype # dtype('bool')</pre><p>Any comparison operator acting on arrays will create a Boolean array instead of a simple Boolean:</p><pre class="programlisting">M = array([[2, 3],&#13;
           [1, 4]])&#13;
M &gt; 2 # array([[False, True],&#13;
             # [False, True]])&#13;
M == 0 # array([[False, False],&#13;
             # [False, False]])&#13;
N = array([[2, 3],&#13;
           [0, 0]])&#13;
M == N # array([[True, True],&#13;
              # [False, False]])&#13;
...</pre><p>Note that because array comparison creates Boolean arrays, one cannot use array comparison directly in conditional statements, for example, <code class="literal">if</code> statements. the solution is to use the methods <code class="literal">all</code> and <code class="literal">any</code>:</p><pre class="programlisting">A = array([[1,2],[3,4]])&#13;
B = array([[1,2],[3,3]])&#13;
A == B # creates array([[True, True], [True, False]]) &#13;
(A == B).all() # False&#13;
(A != B).any() # True&#13;
if (abs(B-A) &lt; 1e-10).all():&#13;
    print("The two arrays are close enough")</pre><div class="section" title="Checking for equality"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl4sec4"/>Checking for equality</h3></div></div></div><p>Checking for equality of two float arrays is not straight forward, because two floats may be very close without being equal. In NumPy, it is possible to check for equality with <code class="literal">allclose</code>. This function checks for equality of two arrays up to a given precision:</p><pre class="programlisting">data = random.rand(2)*1e-3&#13;
small_error = random.rand(2)*1e-16&#13;
data == data + small_error # False&#13;
allclose(data, data + small_error, rtol=1.e-5, atol=1.e-8)   # True</pre><p>The tolerance is given in terms of a relative tolerance bound, <code class="literal">rtol</code>, and an absolute error bound, <code class="literal">atol</code>. The command <code class="literal">allclose</code> is a short form of: <code class="literal">(abs(A-B) &lt; atol+rtol*abs(B)).all()</code>.</p><p>Note that <code class="literal">allclose</code> can be also applied to scalars:</p><pre class="programlisting">data = 1e-3&#13;
error = 1e-16&#13;
data == data + error # False&#13;
allclose(data, data + error, rtol=1.e-5, atol=1.e-8)  #True</pre></div></div></div>
<div class="section" title="Boolean operations on arrays"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl2sec66"/>Boolean operations on arrays</h1></div></div></div><p>You cannot use <code class="literal">and</code>, <code class="literal">or</code>, and <code class="literal">not</code> on Boolean arrays. Indeed, those operators force the casting from array to Boolean, which is not permitted. Instead, we can use the operators given in the following table (<span class="emphasis"><em>Table 5.1</em></span>) for componentwise logical operations on Boolean arrays:</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><tbody><tr><td>
<p>
</p><p>
<span class="strong"><strong>Logic operator</strong></span>
</p><p>
</p>
</td><td>
<p>
</p><p>
<span class="strong"><strong>Replacement for Boolean arrays</strong></span>
</p><p>
</p>
</td></tr><tr><td>
<p>
</p><p>
<code class="literal">A and B</code>
</p><p>
</p>
</td><td>
<p>
</p><p>
<code class="literal">A &amp; B</code>
</p><p>
</p>
</td></tr><tr><td>
<p>
</p><p>
<code class="literal">A or B</code>
</p><p>
</p>
</td><td>
<p>
</p><p>
<code class="literal">A | B</code>
</p><p>
</p>
</td></tr><tr><td>
<p>
</p><p>
<code class="literal">not A</code>
</p><p>
</p>
</td><td>
<p>
</p><p>
<code class="literal">~ A</code>
</p><p>
</p>
</td></tr></tbody></table></div><p>Table 5.1 Logical operators and, or and not do not work with arrays.</p><pre class="programlisting">A = array([True, True, False, False])&#13;
B = array([True, False, True, False])&#13;
A and B # error!&#13;
A &amp; B # array([True, False, False, False])&#13;
A | B # array([True, True, True, False])&#13;
~A # array([False, False, True, True])</pre><p>Here is an example usage of logical operators with Boolean arrays:</p><p>Suppose that we have a sequence of data that is marred with some measurement error. Suppose further that we run a regression and it gives us a deviation for each value. We wish to obtain all the exceptional values and all the values with little deviation that are lower than a given threshold:</p><pre class="programlisting">data = linspace(1,100,100) # data&#13;
deviation = random.normal(size=100) # the deviations &#13;
           #don't forget the parentheses in next statement!&#13;
exceptional = data[(deviation&lt;-0.5)|(deviation&gt;0.5)] &#13;
exceptional = data[abs(deviation)&gt;0.5] # same result &#13;
small = data[(abs(deviation)&lt;0.1)&amp;(data&lt;5.)] # small deviation and data</pre></div>
<div class="section" title="Array indexing"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec44"/>Array indexing</h1></div></div></div><p>We have already seen that one may index arrays by combinations of slices and integers, this is the basic slicing technique. There are, however, many more possibilities, which allow for a variety of ways to access and modify array elements.</p><div class="section" title="Indexing with Boolean arrays"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec67"/>Indexing with Boolean arrays</h2></div></div></div><p>It is often useful to access and modify only parts of an array, depending on its value. For instance, one might want to access all the positive elements of an array. This turns out to be possible using Boolean arrays, which act like masks to select only some elements of an array. The result of such an indexing is <span class="emphasis"><em>always</em></span> a vector. For instance, consider the following example:</p><pre class="programlisting">B = array([[True, False],&#13;
           [False, True]])&#13;
M = array([[2, 3],&#13;
           [1, 4]])&#13;
M[B] # array([2,4]), a vector</pre><p>In fact, the <code class="literal">M[B]</code> call is equivalent to <code class="literal">M.flatten()[B]</code>. One may then replace the resulting vector by another vector. For instance, one may replace all the elements by zero (refer to section <span class="emphasis"><em>Broadcasting </em></span>for more information):</p><pre class="programlisting">M[B] = 0&#13;
M # [[0, 3], [1, 0]]</pre><p>Or one may replace all the selected values by others:</p><pre class="programlisting">M[B] = 10, 20&#13;
M # [[10, 3], [1, 20]]</pre><p>By combining the creation of Boolean arrays (<code class="literal">M &gt; 2</code>), smart indexing (indexing with Boolean array), and broadcasting, one may use the following elegant syntax:</p><pre class="programlisting">M[M&gt;2] = 0    # all the elements &gt; 2 are replaced by 0</pre><p>The expression broadcasting here refers to the tacit conversion of the scalar 0 to a vector of an appropriate shape.</p></div><div class="section" title="Using where"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec68"/>Using where</h2></div></div></div><p>The command <code class="literal">where</code> gives a useful construct that can take a Boolean array as a condition and either return the indexes of the array elements satisfying the condition or return different values depending on the values in the Boolean array.</p><p>The basic structure is:</p><pre class="programlisting">where(condition, a, b)</pre><p>This will return values from <code class="literal">a</code> when the condition is <code class="literal">True</code> and values from <code class="literal">b</code> when it is <code class="literal">False</code>.</p><p>For instances consider, a <span class="emphasis"><em>Heaviside</em></span> function:</p><p>
</p><div class="mediaobject"><img src="graphics/B05511_05_01.jpg" alt="Using where"/></div><p>
</p><p>The following code implements a Heaviside function:</p><pre class="programlisting">def H(x):&#13;
    return where(x &lt; 0, 0, 1)&#13;
x = linspace(-1,1,11)  # [-1. -0.8 -0.6 -0.4 -0.2 0. 0.2 0.4 0.6 0.8 1. ]&#13;
print(H(x))            # [0 0 0 0 0 1 1 1 1 1 1]</pre><p>The second and third arguments can be either arrays of the same size as the condition (the Boolean array) or scalars. We give two more example to demonstrated how to manipulate elements from an array or a scalar depending on a condition:</p><pre class="programlisting">x = linspace(-4,4,5)&#13;
# [-4. -2.  0.  2.  4.]&#13;
&#13;
print(where(x &gt; 0, sqrt(x), 0))&#13;
# [ 0.+0.j 0.+0.j 0.+0.j 1.41421356+0.j  2.+0.j ]&#13;
print(where(x &gt; 0, 1, -1)) # [-1 -1 -1  1  1]</pre><p>If the second and third arguments are omitted, then a tuple containing the indexes of the elements satisfying the condition is returned.</p><p>For example consider the use of <code class="literal">where</code> with only one argument in the following code:</p><pre class="programlisting">a = arange(9)&#13;
b = a.reshape((3,3))&#13;
&#13;
print(where(a &gt; 5))   # (array([6, 7, 8]),)&#13;
&#13;
print(where(b &gt; 5))   # (array([2, 2, 2]), array([0, 1, 2]))</pre></div></div>
<div class="section" title="Performance and Vectorization"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec45"/>Performance and Vectorization</h1></div></div></div><p>When it comes to performance of your Python code, it often boils down to the difference between interpreted code and compiled code. Python is an interpreted programming language and basic Python code is executed directly without any intermediate compilation to machine code. With a compiled language, the code needs to be translated to machine instructions before execution.</p><p>The benefits of an interpreted language are many but interpreted code cannot compete with compiled code for speed. To make your code faster, you can write some parts in a compiled language like FORTRAN, C, or C++. This is what NumPy and SciPy do.</p><p>For this reason, it is best to use functions in NumPy and SciPy over interpreted versions whenever possible. NumPy array operations such as matrix multiplication, matrix-vector multiplication, matrix factorization, scalar products, and so on are much faster than any pure Python equivalent. Consider the simple case of scalar products. The scalar product is much slower than the compiled NumPy function, <code class="literal">dot(a,b)</code> (more than 100 times slower for arrays with about 100 elements):</p><pre class="programlisting">def my_prod(a,b):&#13;
    val = 0&#13;
    for aa,bb in zip(a,b):&#13;
        val += aa*bb&#13;
    return val</pre><p>Measuring the speed of your functions is an important aspect of scientific computing. Refer to section <span class="emphasis"><em>Measuring execution time</em></span> in <a class="link" href="ch13.html" title="Chapter 13. Testing">Chapter 13</a>, <span class="emphasis"><em>Testing, </em></span> for details on measuring execution times.</p><div class="section" title="Vectorization"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec69"/>Vectorization</h2></div></div></div><p>To improve performance, one has to vectorize the code often. Replacing <code class="literal">for</code> loops and other slower parts of the code with NumPy slicing, operations, and functions can give significant improvements. For example, the simple addition of a scalar to a vector by iterating over the elements is very slow:</p><pre class="programlisting">for i in range(len(v)):&#13;
    w[i] = v[i] + 5</pre><p>where using NumPy's addition is much faster:</p><pre class="programlisting">w = v + 5</pre><p>Using NumPy slicing can also give significant speed improvements over iterating with <code class="literal">for</code> loops. To demonstrate this let us consider forming the average of neighbors in a two-dimensional array:</p><pre class="programlisting">def my_avg(A):&#13;
    m,n = A.shape&#13;
    B = A.copy()&#13;
    for i in range(1,m-1):&#13;
        for j in range(1,n-1):&#13;
            B[i,j] = (A[i-1,j] + A[i+1,j] + A[i,j-1] + A[i,j+1])/4&#13;
    return B&#13;
&#13;
def slicing_avg(A):&#13;
    A[1:-1,1:-1] = (A[:-2,1:-1] + A[2:,1:-1] +&#13;
    A[1:-1,:-2] + A[1:-1,2:])/4&#13;
    return A</pre><p>These functions both assign each element the average of its four neighbors. The second version, using slicing, is much faster.</p><p>Besides replacing <code class="literal">for</code> loops and other slower constructions with NumPy functions, there is a useful function called <code class="literal">vectorize</code>, refer to section <span class="emphasis"><em>Functions acting on arrays </em></span>in <a class="link" href="ch04.html" title="Chapter 4. Linear Algebra – Arrays">Chapter 4</a>, <span class="emphasis"><em>Linear Algebra - Arrays</em></span>. This will take a function and create a vectorized version that applies the function on all elements of an array using functions wherever possible.</p><p>Consider the following example for vectorizing a function:</p><pre class="programlisting">def my_func(x):&#13;
    y = x**3 - 2*x + 5&#13;
    if y&gt;0.5:&#13;
        return y-0.5&#13;
    else:&#13;
        return 0</pre><p>Applying this by iterating over an array is very slow:</p><pre class="programlisting">for i in range(len(v)):&#13;
    v[i] = my_func(v[i])</pre><p>Instead, use <code class="literal">vectorize</code> to create a new function, like this:</p><pre class="programlisting">my_vecfunc = vectorize(my_func)</pre><p>This function can then be applied to the array directly:</p><pre class="programlisting">v = my_vecfunc(v)</pre><p>The vectorized option is much faster (around 10 times faster with arrays of length 100).</p></div></div>
<div class="section" title="Broadcasting"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec46"/>Broadcasting</h1></div></div></div><p>Broadcasting in NumPy denotes the ability to guess a common, compatible shape between two arrays. For instance, when adding a vector (one-dimensional array) and a scalar (zero-dimensional array), the scalar is extended to a vector, in order to allow for the addition. The general mechanism is called broadcasting. We will first review that mechanism from a mathematical point of view, and then proceed to give the precise rules for broadcasting in NumPy.</p><div class="section" title="Mathematical view"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec70"/>Mathematical view</h2></div></div></div><p>Broadcasting is often performed in mathematics, mainly implicitly. Examples are expressions such as <span class="emphasis"><em>f(x) + C </em></span>or<span class="emphasis"><em> f(x) + g(y)</em></span>. We'll give an explicit description of that technique in this section.</p><p>We have in mind the very close relationship between functions and NumPy arrays, as described in section <span class="emphasis"><em>Mathematical preliminaries</em></span> of <a class="link" href="ch04.html" title="Chapter 4. Linear Algebra – Arrays">Chapter 4</a>, <span class="emphasis"><em>Linear Algebra - Arrays.</em></span>
</p><div class="section" title="Constant functions"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec14"/>Constant functions</h3></div></div></div><p>One of the most common examples of broadcasting is the addition of a function and a constant; if <span class="emphasis"><em>C</em></span> is a scalar, one often writes:</p><p>
</p><div class="mediaobject"><img src="graphics/sinplusC.jpg" alt="Constant functions"/></div><p>
</p><p>This is an abuse of notation since one should not be able to add functions and constants. Constants are however implicitly broadcast to functions. The broadcast version of the constant <span class="emphasis"><em>C</em></span> is the function <span class="inlinemediaobject"><img src="graphics/B05511_05_06_Cbar.jpg" alt="Constant functions"/></span> defined by:</p><p>
</p><div class="mediaobject"><img src="graphics/cbar.jpg" alt="Constant functions"/></div><p>
</p><p>Now it makes sense to add two functions together:</p><p>
</p><div class="mediaobject"><img src="graphics/sinplusCbar.jpg" alt="Constant functions"/></div><p>
</p><p>We are not being pedantic for the sake of it, but because a similar situation may arise for arrays, as in the following code:</p><pre class="programlisting">vector = arange(4) # array([0.,1.,2.,3.])&#13;
vector + 1.        # array([1.,2.,3.,4.])</pre><p>In this example, everything happens as if the scalar <code class="literal">1.</code> had been converted to an array of the same length as <code class="literal">vector</code>, that is, <code class="literal">array([1.,1.,1.,1.])</code>, and then added to <code class="literal">vector</code>.</p><p>This example is exceedingly simple, so we proceed to show less obvious situations.</p></div><div class="section" title="Functions of several variables"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec15"/>Functions of several variables</h3></div></div></div><p>A more intricate example of broadcasting arises when building functions of several variables. Suppose, for instance, that we were given two functions of one variable, <span class="emphasis"><em>f</em></span> and <span class="emphasis"><em>g</em></span>, and that we want to construct a new function <span class="emphasis"><em>F</em></span> according to the formula:</p><p>
</p><div class="mediaobject"><img src="graphics/fplusg.jpg" alt="Functions of several variables"/></div><p>
</p><p>This is clearly a valid mathematical definition. We would like to express this definition as the sum of two functions in two variables defined as</p><p>
</p><div class="mediaobject"><img src="graphics/fgoverline.jpg" alt="Functions of several variables"/></div><p>
</p><p>and now we may simply write:</p><p>
</p><div class="mediaobject"><img src="graphics/fplugoverline.jpg" alt="Functions of several variables"/></div><p>
</p><p>The situation is similar to that arising when adding a column matrix and a row matrix:</p><pre class="programlisting">C = arange(2).reshape(-1,1) # column&#13;
R = arange(2).reshape(1,-1) # row&#13;
C + R                       # valid addition: array([[0.,1.],[1.,2.]])</pre><p>This is especially useful when sampling functions of two variables, as shown in section <span class="emphasis"><em>Typical examples</em></span>.</p></div><div class="section" title="General mechanism"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec16"/>General mechanism</h3></div></div></div><p>We have seen how to add a function and a scalar and how to build a function of two variables from two functions of one variable. Let us now focus on the general mechanism that makes this possible. The general mechanism consists of two steps: reshaping and extending.</p><p>First, the function <span class="emphasis"><em>g</em></span> is reshaped to a function <span class="inlinemediaobject"><img src="graphics/gwidetilde.jpg" alt="General mechanism"/></span> that takes two arguments. One of these arguments is a dummy argument, which we take to be zero, as a convention:</p><p>
</p><div class="mediaobject"><img src="graphics/gtilde-1.jpg" alt="General mechanism"/></div><p>
</p><p>Mathematically, the domain of definition of <span class="inlinemediaobject"><img src="graphics/gwidetilde.jpg" alt="General mechanism"/></span> is now <span class="inlinemediaobject"><img src="graphics/domain.jpg" alt="General mechanism"/></span>Then the function <span class="emphasis"><em>f</em></span> is reshaped in a way similar to:</p><p>
</p><div class="mediaobject"><img src="graphics/ftilde.jpg" alt="General mechanism"/></div><p>
</p><p>Now both <span class="inlinemediaobject"><img src="graphics/fwidetilde.jpg" alt="General mechanism"/></span> and <span class="inlinemediaobject"><img src="graphics/gwidetilde.jpg" alt="General mechanism"/></span> take two arguments, although one of them is always zero. We proceed to the next step, extending. It is the same step that converted a constant into a constant function (refer to the constant function example).</p><p>The function <span class="inlinemediaobject"><img src="graphics/fwidetilde.jpg" alt="General mechanism"/></span> is extended to:</p><p>
</p><div class="mediaobject"><img src="graphics/foverlinewide.jpg" alt="General mechanism"/></div><p>
</p><p>The function <span class="inlinemediaobject"><img src="graphics/gwidetilde.jpg" alt="General mechanism"/></span> is extended to:</p><p>
</p><div class="mediaobject"><img src="graphics/goverlinewide.jpg" alt="General mechanism"/></div><p>
</p><p>Now the function of two variables<span class="emphasis"><em> F</em></span>, which was sloppily defined by <span class="emphasis"><em>F(x,y) = f(x) + g(y)</em></span>, may be defined without reference to its arguments:</p><p>
</p><div class="mediaobject"><img src="graphics/Fasfoverlinepluggoverline.jpg" alt="General mechanism"/></div><p>
</p><p>For example, let us describe the preceding mechanism for constants. A constant is a scalar, that is, a function of zero arguments. The reshaping step is thus to define the function of one (empty) variable:</p><p>
</p><div class="mediaobject"><img src="graphics/Cwidetilde.jpg" alt="General mechanism"/></div><p>
</p><p>Now the extension step proceeds simply by:</p><p>
</p><div class="mediaobject"><img src="graphics/Cwideoverline.jpg" alt="General mechanism"/></div><p>
</p></div><div class="section" title="Conventions"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec17"/>Conventions</h3></div></div></div><p>The last ingredient is the convention on how to add the extra arguments to a function, that is, how the reshaping is automatically performed. By convention, a function is automatically reshaped by adding zeros on the left.</p><p>For example, if a function <span class="emphasis"><em>g</em></span> of two arguments has to be reshaped to three arguments, the new function would be defined by:</p><p>
</p><div class="mediaobject"><img src="graphics/gthreearguments.jpg" alt="Conventions"/></div><p>
</p></div></div><div class="section" title="Broadcasting arrays"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec71"/>Broadcasting arrays</h2></div></div></div><p>We now repeat the observation that arrays are merely functions of several variables (refer to section <span class="emphasis"><em>Mathematical preliminaries </em></span>in <a class="link" href="ch04.html" title="Chapter 4. Linear Algebra – Arrays">Chapter 4</a>, <span class="emphasis"><em>Linear Algebra - Arrays</em></span>). Array broadcasting thus follows exactly the same procedure as explained above for mathematical functions. Broadcasting is done automatically in NumPy.</p><p>In the following figure (<span class="emphasis"><em>Figure 5.1</em></span>), we show what happens when adding a matrix of shape (4, 3) to a matrix of size (1, 3). The second matrix is of the shape (4, 3):</p><p>
</p><div class="mediaobject"><img src="graphics/broadcastingMV.jpg" alt="Broadcasting arrays"/></div><p>
</p><p>Figure 5.1: Broadcasting between a matrix and a vector.</p><div class="section" title="The broadcasting problem"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec18"/>The broadcasting problem</h3></div></div></div><p>When NumPy is given two arrays with different shapes, and is asked to perform an operation that would require the two shapes to be the same, both arrays are broadcast to a common shape.</p><p>Suppose the two arrays have shapes <span class="emphasis"><em>s<sub>1</sub></em></span> and <span class="emphasis"><em>s<sub>2</sub></em></span>. This broadcasting is performed in two steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">If the shape <span class="emphasis"><em>s<sub>1</sub></em></span> is shorter than the shape <span class="emphasis"><em>s<sub>2</sub></em></span> then ones are added on the left of the shape <span class="emphasis"><em>s<sub>1</sub></em></span>. This is a reshaping.</li><li class="listitem">When the shapes have the same length, the array is extended to match the shape <span class="emphasis"><em>s<sub>2</sub></em></span> (if possible).</li></ol></div><p>Suppose we want to add a vector of shape (3, ) to a matrix of shape (4, 3). The vector needs be broadcast. The first operation is a reshaping; the shape of the vector is converted from (3, ) to (1, 3). The second operation is an extension; the shape is converted from (1, 3) to (4, 3).</p><p>For instance, suppose a vector of size <span class="emphasis"><em>n</em></span> is to be broadcast to the shape (<span class="emphasis"><em>m, n</em></span>):</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><span class="emphasis"><em>v</em></span> is automatically reshaped to (1, <span class="emphasis"><em>n</em></span>).</li><li class="listitem"><span class="emphasis"><em>v</em></span> is extended to (<span class="emphasis"><em>m</em></span>, <span class="emphasis"><em>n</em></span>).</li></ol></div><p>To demonstrate this we consider a matrix defined by:</p><pre class="programlisting">M = array([[11, 12, 13, 14],&#13;
           [21, 22, 23, 24],&#13;
           [31, 32, 33, 34]])</pre><p>and vector given by:</p><pre class="programlisting">v = array([100, 200, 300, 400])</pre><p>Now we may add <code class="literal">M</code> and <code class="literal">v</code> directly:</p><pre class="programlisting">M + v # works directly</pre><p>The result is this matrix:</p><p>
</p><div class="mediaobject"><img src="graphics/B05511_05_02.jpg" alt="The broadcasting problem"/></div><p>
</p></div><div class="section" title="Shape mismatch"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec19"/>Shape mismatch</h3></div></div></div><p>It is not possible to automatically broadcast a vector <code class="literal">v</code> of length <code class="literal">n</code> to the shape <code class="literal">(n,m)</code>. This is illustrated in the following figure:</p><p>
</p><div class="mediaobject"><img src="graphics/broadcastingwrong.jpg" alt="Shape mismatch"/></div><p>
</p><p>The broadcasting will fail, because the shape <code class="literal">(n,)</code> may not be automatically broadcast to the shape <code class="literal">(m, n)</code>. The solution is to manually reshape <code class="literal">v</code> to the shape <code class="literal">(n,1)</code>. The broadcasting will now work as usual (by extension only):</p><pre class="programlisting">M + v.reshape(-1,1)</pre><p>Here is another example, define a matrix  by:</p><pre class="programlisting">M = array([[11, 12, 13, 14],&#13;
           [21, 22, 23, 24],&#13;
           [31, 32, 33, 34]])</pre><p>and a vector by:</p><pre class="programlisting">v = array([100, 200, 300])</pre><p>Now automatic broadcasting will fail, because automatic reshaping does not work:</p><pre class="programlisting">M + v # shape mismatch error</pre><p>The solution is thus to take care of the reshaping manually. What we want in that case is to add 1 on the right, that is, transform the vector into a column matrix. The broadcasting then works directly:</p><pre class="programlisting">M + v.reshape(-1,1)</pre><p>For the shape parameter -1, refer to section <span class="emphasis"><em>Accessing and changing the shape </em></span>of <a class="link" href="ch04.html" title="Chapter 4. Linear Algebra – Arrays">Chapter 4</a>, <span class="emphasis"><em>Linear Algebra  - Arrays. </em></span>The result is this matrix:</p><p>
</p><div class="mediaobject"><img src="graphics/B05511_05_03.jpg" alt="Shape mismatch"/></div><p>
</p></div></div><div class="section" title="Typical examples"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec72"/>Typical examples</h2></div></div></div><p>Let us examine some typical examples where broadcasting may come in handy.</p><div class="section" title="Rescale rows"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec20"/>Rescale rows</h3></div></div></div><p>Suppose <code class="literal">M</code> is an <span class="emphasis"><em>n</em></span> × <span class="emphasis"><em>m</em></span> matrix, and we want to multiply each row by a coefficient. The coefficients are stored in a vector <code class="literal">coeff</code> with <span class="emphasis"><em>n</em></span> components. In that case, automatic reshaping will not work, and we have to execute:</p><pre class="programlisting">rescaled = M*coeff.reshape(-1,1)</pre></div><div class="section" title="Rescale columns"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec21"/>Rescale columns</h3></div></div></div><p>The setup is the same here, but we would like to rescale each column with a coefficient stored in a vector <code class="literal">coeff</code> of length <span class="emphasis"><em>m</em></span>. In this case, automatic reshaping will work:</p><pre class="programlisting">rescaled = M*coeff</pre><p>Obviously, we may also do the reshaping manually and achieve the same result with:</p><pre class="programlisting">rescaled = M*coeff.reshape(1,-1)</pre></div><div class="section" title="Functions of two variables"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec22"/>Functions of two variables</h3></div></div></div><p>Suppose <span class="emphasis"><em>u</em></span> and <span class="emphasis"><em>v</em></span> are vectors and we want to form the matrix <span class="emphasis"><em>W</em></span> with elements <span class="emphasis"><em>w<sub>ij</sub> = u<sub>i</sub> + v<sub>j</sub></em></span>. This would correspond to the function <span class="emphasis"><em>F(x, y) = x + y</em></span>. The matrix <span class="emphasis"><em>W</em></span> is merely defined by:</p><pre class="programlisting">W=u.reshape(-1,1) + v</pre><p>If the vectors <span class="emphasis"><em>u</em></span> and <span class="emphasis"><em>v</em></span> are [0, 1] and [0, 1, 2] respectively, the result is:</p><p>
</p><div class="mediaobject"><img src="graphics/B05511_05_04.jpg" alt="Functions of two variables"/></div><p>
</p><p>More generally, suppose that we want to sample the function <span class="emphasis"><em>w</em></span>(<span class="emphasis"><em>x, y</em></span>)<span class="emphasis"><em> := </em></span>cos(<span class="emphasis"><em>x</em></span>)<span class="emphasis"><em> +</em></span> sin(2<span class="emphasis"><em>y</em></span>). Supposing that the vectors <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> are defined, the matrix <span class="emphasis"><em>w</em></span> of sampled values is obtained by:</p><pre class="programlisting">w = cos(x).reshape(-1,1) + sin(2*y)</pre><p>Note that this is very frequently used in combination with <code class="literal">ogrid</code>. The vectors obtained from <code class="literal">ogrid</code> are already conveniently shaped for broadcasting. This allows for the following elegant sampling of the function cos(<span class="emphasis"><em>x</em></span>)<span class="emphasis"><em> +</em></span> sin(2<span class="emphasis"><em>y</em></span>):</p><pre class="programlisting">x,y = ogrid[0:1:3j,0:1:3j] &#13;
# x,y are vectors with the contents of linspace(0,1,3)&#13;
w = cos(x) + sin(2*y)</pre><p>The syntax of <code class="literal">ogrid</code> needs some explanation. First, <code class="literal">ogrid</code> is no function. It is an instance of a class with a <code class="literal">__getitem__</code> method (refer to section <span class="emphasis"><em>Attributes </em></span>in <a class="link" href="ch08.html" title="Chapter 8. Classes">Chapter 8</a>, <span class="emphasis"><em>Classes</em></span>). That is why it is used with brackets instead of parentheses.</p><p>The two commands are equivalent:</p><pre class="programlisting">x,y = ogrid[0:1:3j, 0:1:3j]&#13;
x,y = ogrid.__getitem__((slice(0, 1, 3j),slice(0, 1, 3j)))</pre><p>The stride parameter in the preceding example is a complex number. This is to indicate that it is the number of steps instead of the step size. The rules for the stride parameter might be confusing at first glance:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If the stride is a real number, then it defines the size of the steps between start and stop and stop is not included in the list.</li><li class="listitem" style="list-style-type: disc">If the stride is a complex number <code class="literal">s</code>, then the integer part of <code class="literal">s.imag</code> defines the number of steps between start and stop and stop is included in the list.</li></ul></div><p>Another example for the output of <code class="literal">ogrid</code> is a tuple with two arrays, which can be used for broadcasting:</p><pre class="programlisting">x,y = ogrid[0:1:3j, 0:1:3j]</pre><p>gives:</p><pre class="programlisting">array([[ 0. ],&#13;
       [ 0.5],&#13;
       [ 1. ]])&#13;
array([[ 0. ,  0.5,  1. ]])</pre><p>which is equivalent to:</p><pre class="programlisting">x,y = ogrid[0:1.5:.5, 0:1.5:.5]</pre></div></div></div>
<div class="section" title="Sparse matrices"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec47"/>Sparse matrices</h1></div></div></div><p>Matrices with a small number of nonzero entries are called <span class="strong"><strong>sparse matrices</strong></span>. Sparse matrices occur, for example, in scientific computing when describing discrete differential operators in the context of numerically solving partial differential equations.</p><p>Sparse matrices often have large dimensions, sometimes so large that the entire matrix (with zero entries) would not even fit in the available memory. This is one motivation for a special type for sparse matrices. Another motivation is better performance of operations where zero matrix entries can be avoided.</p><p>There are only a very limited number of algorithms for general, unstructured sparse matrices in linear algebra. Most of them are iterative in nature and based on efficient implementations of matrix-vector multiplication for sparse matrices.</p><p>Examples for sparse matrices are diagonal or banded matrices. The simple pattern of these matrices allows straightforward storing strategies; the principal diagonal and the sub- and super-diagonals are stored in 1D arrays. Conversion from a sparse representation to the classical array type and vice-versa can be done by the command <code class="literal">diag</code>.</p><p>In general, there is not such a simple structure and the description of sparse matrices requires special techniques and standards. Here we present a row and a column oriented type for sparse matrices, both available through the module <code class="literal">scipy.sparse</code> .</p><p>
</p><div class="mediaobject"><img src="graphics/sparse.jpg" alt="Sparse matrices"/></div><p>
</p><p>Figure 5.2: A stiffness matrix from a finite element model of an elastic plate. The pixels denote nonzero entries in the 1250 × 1250 matrix</p><div class="section" title="Sparse matrix formats"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec73"/>Sparse matrix formats</h2></div></div></div><p>The <code class="literal">scipy.sparse</code> module provides many different storing formats from sparse matrices. We describe here only the most important ones: CSR, CSC, and LIL. The LIL format should be used for generating and altering sparse matrices; CSR and CSC are efficient formats for matrix-matrix and matrix-vector operations.</p><div class="section" title="Compressed sparse row"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec23"/>Compressed sparse row</h3></div></div></div><p>The compressed sparse row format (CSR) uses three arrays: <code class="literal">data</code>, <code class="literal">indptr</code>, and <code class="literal">indices</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The 1D array <code class="literal">data</code> stores all the nonzero values in order. It has as many elements as there are nonzero elements, often denoted by the variable <code class="literal">nnz</code>.</li><li class="listitem" style="list-style-type: disc">The 1D array <code class="literal">indptr</code> contains integers such that <code class="literal">indptr[i]</code> is the index of the element in <code class="literal">data</code>, which is the first nonzero element of row <span class="emphasis"><em>i</em></span>. If the entire row <span class="emphasis"><em>i</em></span> is zero, then <code class="literal">indptr[i]==indptr[i+1]</code>. If the original matrix has <span class="emphasis"><em>m</em></span> rows, then <code class="literal">len(indptr)==m+1</code>.</li><li class="listitem" style="list-style-type: disc">The 1D array <code class="literal">indices</code> contains the column index information in such a way that <code class="literal">indices[indptr[i]:indptr[i+1]]</code> is an integer array with the column indexes of the nonzero elements in row <span class="emphasis"><em>i</em></span>. Obviously, <code class="literal">len(indices)==len(data)==nnz</code>.</li></ul></div><p>Let's see an example:
The CSR format of the matrix:</p><p>
</p><div class="mediaobject"><img src="graphics/B05511_05_05.jpg" alt="Compressed sparse row"/></div><p>
</p><p>is given by the three arrays:</p><pre class="programlisting">data = (1. 2. 3. 4.)&#13;
indptr = (0 2 2 3 5)&#13;
indices = (0 2 0 0 3)</pre><p>The module <code class="literal">scipy.sparse</code> provides a type, <code class="literal">csr_matrix</code>, with a constructor, which can be used in the following ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">With a 2D array as argument</li><li class="listitem" style="list-style-type: disc">With a matrix in one of the other sparse formats in <code class="literal">scipy.sparse</code></li><li class="listitem" style="list-style-type: disc">With a shape argument, <code class="literal">(m,n)</code>, to generate a zero matrix in CSR format</li><li class="listitem" style="list-style-type: disc">By a 1D array for the <code class="literal">data</code> and an integer array <code class="literal">ij</code> with the shape <code class="literal">(2,len(data))</code> such that <code class="literal">ij[0,k]</code> is the row index and <code class="literal">ij[1,k]</code> is the column index of <code class="literal">data[k]</code> of the matrix</li><li class="listitem" style="list-style-type: disc">The three arguments, <code class="literal">data</code>, <code class="literal">indptr</code>, and <code class="literal">indices</code>, can be given to the constructor directly</li></ul></div><p>The first two options are there for conversion purposes while the last two directly define the sparse matrix.</p><p>Consider the above example in python look like:</p><pre class="programlisting">import scipy.sparse as sp&#13;
A = array([[1,0,2,0],[0,0,0,0],[3.,0.,0.,0.],[1.,0.,0.,4.]])&#13;
AS = sp.csr_matrix(A)</pre><p>Among others, the following attributes are provided:</p><pre class="programlisting">AS.data      # returns array([ 1., 2., 3., 1., 4.]) &#13;
AS.indptr    # returns array([0, 2, 2, 3, 5])&#13;
AS.indices   # returns array([0, 2, 0, 0, 3])&#13;
AS.nnz       # returns 5</pre></div><div class="section" title="Compressed Sparse Column"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec24"/>Compressed Sparse Column</h3></div></div></div><p>The CSR format has a column oriented twin - the compressed sparse column (CSC) format. The only difference in it compared to the CSR format is the definition of the <code class="literal">indptr</code> and <code class="literal">indices</code> arrays, which are now column-related. The type for the CSC format is <code class="literal">csc_matrix</code> and its use corresponds to <code class="literal">csr_matrix</code>, explained previously in this section.</p><p>Continuing the same example in CSC format:</p><pre class="programlisting">import scipy.sparse as sp&#13;
A = array([[1,0,2,0],[0,0,0,0],[3.,0.,0.,0.],[1.,0.,0.,4.]])&#13;
AS = sp.csc_matrix(A)&#13;
AS.data         # returns array([ 1., 3., 1., 2., 4.]) &#13;
AS.indptr       # returns array([0, 3, 3, 4, 5])&#13;
AS.indices      # returns array([0, 2, 3, 0, 3])&#13;
AS.nnz          # returns 5</pre></div><div class="section" title="Row-based linked list format"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec25"/>Row-based linked list format</h3></div></div></div><p>The linked list sparse format stores the nonzero matrix entries rowwise in a list <code class="literal">data</code> such that <code class="literal">data[k]</code> is a list of the nonzero entries in row <span class="emphasis"><em>k</em></span>. If all entries in that row are 0, it contains an empty list.</p><p>A second list, <code class="literal">rows</code>, contains at position <span class="emphasis"><em>k</em></span> a list of column indexes of the nonzero elements in row <span class="emphasis"><em>k</em></span>.  Here is an example in <span class="strong"><strong>Row-Based linked List Format (LIL)</strong></span> format:</p><pre class="programlisting">import scipy.sparse as sp&#13;
A = array([[1,0,2,0],[0,0,0,0], [3.,0.,0.,0.], [1.,0.,0.,4.]]) &#13;
AS = sp.lil_matrix(A)&#13;
AS.data     # returns array([[1.0, 2.0], [], [3.0], [1.0, 4.0]], dtype=object)&#13;
AS.rows     # returns array([[0, 2], [], [0], [0, 3]], dtype=object)&#13;
AS.nnz      # returns 5</pre><div class="section" title="Altering and slicing matrices in LIL format"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec5"/>Altering and slicing matrices in LIL format</h4></div></div></div><p>The LIL format is the one best suited for slicing, that is, extracting submatrices in LIL format, and for changing the sparsity pattern by inserting nonzero elements. Slicing is demonstrated by the next example:</p><pre class="programlisting">BS = AS[1:3,0:2]&#13;
BS.data     # returns array([[], [3.0]], dtype=object)&#13;
BS.rows     # returns array([[], [0]], dtype=object)</pre><p>Insertion of a new nonzero element automatically updates the attributes:</p><pre class="programlisting">AS[0,1] = 17 &#13;
AS.data # returns array([[1.0, 17.0, 2.0], [], [3.0], [1.0, 4.0]])&#13;
AS.rows              # returns array([[0, 1, 2], [], [0], [0, 3]])&#13;
AS.nnz               # returns 6</pre><p>These operations are discouraged in the other sparse matrix formats as they are extremely inefficient.</p></div></div></div><div class="section" title="Generating sparse matrices"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec74"/>Generating sparse matrices</h2></div></div></div><p>The NumPy commands <code class="literal">eye</code>, <code class="literal">identity</code>, <code class="literal">diag</code>, and <code class="literal">rand</code> have their sparse counterparts. They take an additional argument; it specifies the sparse matrix format of the resulting matrix.</p><p>The following commands generate the identity matrix but in different sparse matrix formats:</p><pre class="programlisting">import scipy.sparse as sp&#13;
sp.eye(20,20,format = 'lil') &#13;
sp.spdiags(ones((20,)),0,20,20, format = 'csr') &#13;
sp.identity(20,format ='csc')</pre><p>The <code class="literal">sp.rand</code> command takes an additional argument describing the density of the generated random matrix. A dense matrix has density 1 while a zero matrix has density 0:</p><pre class="programlisting">import scipy.sparse as sp &#13;
AS=sp.rand(20,200,density=0.1,format=’csr’)&#13;
AS.nnz # returns 400</pre><p>There is no direct correspondence to the NumPy command <code class="literal">zeroes</code>. Matrices completely filled with zeros are generated by instantiating the corresponding type with the shape parameters as constructor parameters:</p><pre class="programlisting">import scipy.sparse as sp&#13;
Z=sp.csr_matrix((20,200))&#13;
Z.nnz    # returns 0</pre></div><div class="section" title="Sparse matrix methods"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec75"/>Sparse matrix methods</h2></div></div></div><p>There are methods to convert one sparse type into another or into an array:</p><pre class="programlisting">AS.toarray # converts sparse formats to a numpy array &#13;
AS.tocsr&#13;
AS.tocsc&#13;
AS.tolil</pre><p>The type of a sparse matrix can be inspected by the methods <code class="literal">issparse</code> ,  <code class="literal">isspmatrix_lil</code>, <code class="literal">isspmatrix_csr</code>, and <code class="literal">isspmatrix_csc</code>.</p><p>Elementwise operations <code class="literal">+</code>, <code class="literal">*</code>, <code class="literal">/</code>, and <code class="literal">**</code> on sparse matrices are defined as for NumPy arrays. Regardless of the sparse matrix format of the operands, the result is always a <code class="literal">csr_matrix</code>. Applying elementwise operating functions to sparse matrices requires first transforming them to either CSR or CSC format and applying the functions to their <code class="literal">data</code> attribute, as demonstrated by the next example.</p><p>The elementwise sine of a sparse matrix can be defined by an operation on its <code class="literal">data</code> attribute:</p><pre class="programlisting">import scipy.sparse as sp&#13;
def sparse_sin(A):&#13;
    if not (sp.isspmatrix_csr(A) or sp.isspmatrix_csc(A)):&#13;
        A = A.tocsr()&#13;
A.data = sin(A.data)&#13;
return A</pre><p>For matrix-matrix or matrix-vector multiplications, there is a sparse matrix method, <code class="literal">dot</code>. It returns either a <code class="literal">csr_matrix</code> or a 1D NumPy <code class="literal">array</code>:</p><pre class="programlisting">import scipy.sparse as sp&#13;
A = array([[1,0,2,0],[0,0,0,0],[3.,0.,0.,0.],[1.,0.,0.,4.]])&#13;
AS = sp.csr_matrix(A)&#13;
b = array([1,2,3,4])&#13;
c = AS.dot(b)      # returns array([ 7., 0., 3., 17.]) &#13;
C = AS.dot(AS)     # returns  csr_matrix&#13;
d = dot(AS,b)      # does not return the expected result! &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip22"/>Tip</h3><p>Avoid using NumPy's command <code class="literal">dot</code> on sparse matrices, as this might lead to unexpected results. Use the command <code class="literal">dot</code> from <code class="literal">scipy.sparse</code> instead.</p></div></div><p>Other linear algebra operations such as system solving, least squares, eigenvalues, and singular values are provided by the <code class="literal">scipy.sparse.linalg</code> module.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec48"/>Summary</h1></div></div></div><p>The concept of views is one of the important topics you should have learned from this chapter. Missing this topic will give you a hard time when debugging your code. Boolean arrays occur at various places throughout this book. They are handy and compact tools for avoiding lengthy <code class="literal">if</code> constructions and loops when working with arrays. In nearly all large computational projects, sparse matrices become an issue. You saw how these are handled and which related methods are available.</p></div></body></html>