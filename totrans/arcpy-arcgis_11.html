<html><head></head><body><div class="chapter" title="Chapter&#xA0;11.&#xA0;Network Analyst and Spatial Analyst with ArcPy"><div class="titlepage"><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Network Analyst and Spatial Analyst with ArcPy</h1></div></div></div><p>Use of the ArcGIS for Desktop extensions also benefits from the power of Python and ArcPy. The ability to model routes using a streets dataset or a bus routes dataset using ArcPy will help us convert entire workflows into script tools. Both Network Analysts and Spatial Analysts have access modules built into ArcPy for improved control of their available tools, methods, and properties.</p><p>This chapter will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating a simple network dataset</li><li class="listitem" style="list-style-type: disc">Checking out the extensions</li><li class="listitem" style="list-style-type: disc">The ArcPy Network Analyst module</li><li class="listitem" style="list-style-type: disc">The ArcPy Spatial Analyst module</li></ul></div><div class="section" title="The Network Analyst extension"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec52"/>The Network Analyst extension</h1></div></div></div><p>The ESRI's Network Analyst extension is a powerful tool to enable routing and network connectivity<a id="id396" class="indexterm"/> functionality within ArcGIS. The extension, when used for street routing, allows users to find the quickest path between two points along a road network. The route can be constrained by a number of factors, such as traffic or left turns, to better model road travel. Similar analysis can be run using other types of networks, such as water pipe networks or electrical networks.</p></div></div>
<div class="section" title="Using Network Analyst"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec53"/>Using Network Analyst</h1></div></div></div><p>To use<a id="id397" class="indexterm"/> the Network Analyst extension, the ArcGIS for Desktop Advanced license is required. In ArcCatalog or ArcMap, click on the <span class="strong"><strong>Customize</strong></span> menu and select <span class="strong"><strong>Extensions</strong></span>. Once the Extensions menu is open, click on the checkbox next to turn on the <span class="strong"><strong>Network Analyst Extension.</strong></span>
</p><div class="section" title="Creating a Feature Dataset"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec77"/>Creating a Feature Dataset</h2></div></div></div><p>The first step<a id="id398" class="indexterm"/> to using a network dataset is<a id="id399" class="indexterm"/> to create one within a feature dataset. To do so, we will generate a feature dataset to hold the data of interest. Right-click on the <span class="strong"><strong>File</strong></span> geodatabase that houses the <span class="strong"><strong>Bus Stop</strong></span> data and select <span class="strong"><strong>New</strong></span>, and then select <span class="strong"><strong>Feature Dataset</strong></span> from the <span class="strong"><strong>New</strong></span> menu. Name it <code class="literal">Chapter11Results</code> and click on <span class="strong"><strong>Next</strong></span>.</p><div class="mediaobject"><img src="graphics/8662OS_11_01.jpg" alt="Creating a Feature Dataset"/></div><p>Next, select the <span class="strong"><strong>Spatial Reference System</strong></span> (<span class="strong"><strong>SRS</strong></span>). In this case, we will be using the SRS of the local State Plane zone for San Francisco. It is a projected coordinate system, so select that folder, and then click on the <code class="literal">State Plane</code> folder. Once it is opened, select the folder called <span class="strong"><strong>NAD 1983(US Feet)</strong></span>. From the available reference systems, select the one called <span class="strong"><strong>NAD 1983 StatePlane California III FIPS 0403 (US Feet)</strong></span>. Click on <span class="strong"><strong>Next</strong></span> to go to the next menu.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>This system is also known as 2227 in <span class="strong"><strong>Well Known ID</strong></span> (<span class="strong"><strong>WKID</strong></span>) or <span class="strong"><strong>European Petroleum Survey Group</strong></span> (<span class="strong"><strong>EPSG</strong></span>) systems. More information about these codes is available at <a class="ulink" href="http://spatialreference.org">http://spatialreference.org</a>, a website used to find the thousands of spatial reference systems used throughout the world.</p></div></div><p>Click<a id="id400" class="indexterm"/> on the <span class="strong"><strong>Vertical Coordinate Systems</strong></span> folder <a id="id401" class="indexterm"/>and then select the <span class="strong"><strong>North America</strong></span> folder. Select the <span class="strong"><strong>North American Vertical Datum of 1988 in feet </strong></span>(<span class="strong"><strong>NAVD 1988 US survey feet</strong></span>). This will make it possible to have the vertical and horizontal linear units in the same measurement system. Click on <span class="strong"><strong>Next</strong></span> to go to the next menu.</p><p>The tolerances on the next page are also very important, but we will not cover them in detail here. Accept the defaults and click on <span class="strong"><strong>Finish</strong></span> to finalize the <span class="strong"><strong>Feature Dataset</strong></span>.</p></div><div class="section" title="Importing the datasets"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec78"/>Importing the datasets</h2></div></div></div><p>Import <a id="id402" class="indexterm"/>the bus stops, streets, and bus routes feature classes<a id="id403" class="indexterm"/> into the <code class="literal">Chapter 11 Results Feature Dataset</code>. Right-click on the dataset and select <span class="strong"><strong>Import</strong></span>, and then <span class="strong"><strong>Feature Class (Single)</strong></span>. Add the feature classes one by one to give them a new name that will keep them separated from the versions contained within the <span class="strong"><strong>SanFrancisco Feature Dataset</strong></span>. Importing them will make sure that they are in the correct SRS and that a network dataset can be created.</p></div><div class="section" title="Creating the Network Dataset"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec79"/>Creating the Network Dataset</h2></div></div></div><p>Now<a id="id404" class="indexterm"/> that we have a data container, we can <a id="id405" class="indexterm"/>create a network dataset from the streets feature class. Right-click on the <span class="strong"><strong>Chapter11Results </strong></span>feature dataset and select <span class="strong"><strong>New</strong></span>, and then choose <span class="strong"><strong>Network Dataset</strong></span>.</p><p> </p><div class="mediaobject"><img src="graphics/8662OS_11_02.jpg" alt="Creating the Network Dataset"/></div><p>
</p><p>Call the <a id="id406" class="indexterm"/>
<span class="strong"><strong>Network Dataset</strong></span> <code class="literal">Street_Network</code> and click on <span class="strong"><strong>Next</strong></span>. Select the <span class="strong"><strong>Streets feature class</strong></span> as the class that will participate in<a id="id407" class="indexterm"/> the network dataset and click on <span class="strong"><strong>Next</strong></span> to move to the next menu. Select <span class="strong"><strong>Global Turns</strong></span> to model turns within the network. In the next menu, use the default connectivity settings. Then, accept the <span class="strong"><strong>Using Z Coordinate Values from Geometry</strong></span> setting. Accept the default cost restriction and driving directions settings, and finally click on <span class="strong"><strong>Finish</strong></span> to generate the network dataset. Then, build the network dataset using the final menu. The network dataset is ready to be used.</p></div><div class="section" title="Accessing the Network Dataset using ArcPy"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec80"/>Accessing the Network Dataset using ArcPy</h2></div></div></div><p>Now<a id="id408" class="indexterm"/> that the necessary setup<a id="id409" class="indexterm"/> has been completed, the street_network network dataset can be added to a script for use in generating routes. Because this is a simple analysis, the only impedance value to be used will be the length of the street segments. Through the use of a <code class="literal">SearchCursor</code>, <code class="literal">PointGeometry</code> objects from the bus stops can be accessed and added as locations to be searched:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>import arcpy</strong></span>
<span class="strong"><strong>arcpy.CheckOutExtension("Network")</strong></span>
<span class="strong"><strong>busStops = r'C:\Projects\PacktDB.gdb\Chapter11Results\BusStops'</strong></span>
<span class="strong"><strong>networkDataset = r'C:\Projects\PacktDB.gdb\Chapter11Results\street_network'</strong></span>
<span class="strong"><strong>networkLayer = "streetRoute"</strong></span>
<span class="strong"><strong>impedance = "Length"</strong></span>
<span class="strong"><strong>routeFile = "C:\Projects\Layer\{0}.lyr".format(networkLayer)</strong></span>
<span class="strong"><strong>arcpy.MakeRouteLayer_na(networkDataset,</strong></span>
<span class="strong"><strong>           networkLayer, impedance)</strong></span>
<span class="strong"><strong>print 'layer created'</strong></span>
<span class="strong"><strong>sql = "NAME = '71 IB' AND BUS_SIGNAG = 'Ferry Plaza'"</strong></span>
<span class="strong"><strong>with arcpy.da.SearchCursor(busStops,['SHAPE@', 'STOPID'],sql) as cursor:</strong></span>
<span class="strong"><strong>    for row in cursor:</strong></span>
<span class="strong"><strong>        stopShape = row[0]</strong></span>
<span class="strong"><strong>        print row[1]</strong></span>
<span class="strong"><strong>        arcpy.AddLocations_na(networkLayer,'Stops',stopShape, "", "")      </strong></span>
<span class="strong"><strong>   arcpy.Solve_na(networkLayer,"SKIP")</strong></span>
<span class="strong"><strong>arcpy.SaveToLayerFile_management(networkLayer,routeLayerFile,"RELATIVE")</strong></span>
<span class="strong"><strong>print 'finished'</strong></span>
</pre></div><div class="section" title="Breaking down the script"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec36"/>Breaking down the script</h3></div></div></div><p>Let's dissect<a id="id410" class="indexterm"/> the script, which once finished, will generate a layer file containing the added Stops, and the Routes along streets to best get from the origin stop to the destination stop.</p><p>The script begins by importing the arcPy module. The next line allows us to use the Network Analyst extension:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>arcpy.CheckOutExtension("Network")</strong></span>
</pre></div><p>Using the <code class="literal">arcpy.CheckOutExtension()</code> method to invoke the Network Analyst extension involves passing the correct keyword to the method as a parameter. Once it has been invoked, the tools of the extension can be called and executed in the script.</p><p>Assigning the bus stops feature class and the street_network network dataset to variables, they can then be passed to ArcPy's <code class="literal">MakeRouteLayer_na()</code> method, along with a variable representing the impedance value:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>arcpy.MakeRouteLayer_na(networkDataset,</strong></span>
<span class="strong"><strong>           networkLayer, impedance)</strong></span>
</pre></div><p>The <code class="literal">MakeRouteLayer_na</code> tool produces a <code class="literal">RouteLayer</code> in memory. This blank layer needs to be populated with stops to produce the route(s) between them. For this purpose, we need a <code class="literal">SearchCursor</code> to access the <code class="literal">PointGeometry</code> objects and a SQL statement that will limit the returned results to the line of interest:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sql = "NAME = '71 IB' AND BUS_SIGNAG = 'Ferry Plaza'"</strong></span>
<span class="strong"><strong>with arcpy.da.SearchCursor(busStops,['SHAPE@', 'STOPID'],sql) as cursor:</strong></span>
<span class="strong"><strong>    for row in cursor:</strong></span>
<span class="strong"><strong>        stopShape = row[0]</strong></span>
<span class="strong"><strong>        print row[1]</strong></span>
<span class="strong"><strong>        arcpy.AddLocations_na(networkLayer,'Stops',stopShape,"", "")</strong></span>
</pre></div><p>The Search <a id="id411" class="indexterm"/>Cursor will allow the <span class="strong"><strong>Stops</strong></span> sublayer of the layer produced by the MakeRouteLayer tool to be populated when used in conjunction with the <code class="literal">AddLocations</code> tool. Once populated, the <code class="literal">RouteLayer</code> can be passed to the <span class="strong"><strong>Solve</strong></span> tool to find the routes between the points of interest. Again, the routes are solved based on finding the lowest <span class="strong"><strong>impedance</strong></span> between the two points. In this example, the only impedance is the segment length, but it could be traffic or elevation or other restriction types, if that data is available:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>   arcpy.Solve_na(networkLayer,"SKIP")</strong></span>
<span class="strong"><strong>arcpy.SaveToLayerFile_management(networkLayer,routeLayerFile,"RELATIVE")</strong></span>
</pre></div><p>The final result is a layer file that is written to disk using the <code class="literal">SaveToLayerFile</code> tool.</p><p> </p><div class="mediaobject"><img src="graphics/8662OS_11_03.jpg" alt="Breaking down the script"/></div><p>
</p></div></div></div>
<div class="section" title="The Network Analyst module"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec54"/>The Network Analyst module</h1></div></div></div><p>In an <a id="id412" class="indexterm"/>effort to make the use of the Network Analyst extension more <span class="strong"><strong>Pythonic</strong></span>, the newer Network Analyst (<code class="literal">na</code>) module adjusts how the methods that correspond to the ArcToolbox Network Analyst tools are accessed. Instead of calling the tools directly from ArcPy, the tools are now methods of the <code class="literal">na</code> module. Removing the initials of the Network Analyst toolset also reduces confusion and makes it easier to remember the name of the method. See the difference as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>import arcpy</strong></span>
<span class="strong"><strong>arcpy.CheckOutExtension("Network")</strong></span>
<span class="strong"><strong>busStops = r'C:\Projects\SanFrancisco.gdb\SanFrancisco\Bus_Stops</strong></span>
<span class="strong"><strong>networkDataset = r'C:\Projects\SanFrancisco.gdb\Chapter11Results\street_network'</strong></span>
<span class="strong"><strong>networkLayer = "streetRoute"</strong></span>
<span class="strong"><strong>impedance = "Length"</strong></span>
<span class="strong"><strong>routeLayerFile = "C:\Projects\Layer\{0}_2.lyr".format(networkLayer)arcpy.na.MakeRouteLayer(networkDataset, networkLayer,impedance)</strong></span>
<span class="strong"><strong>print 'layer created'</strong></span>
<span class="strong"><strong>sql = "NAME = '71 IB' AND BUS_SIGNAG = 'Ferry Plaza'"</strong></span>
<span class="strong"><strong>with arcpy.da.SearchCursor(busStops,['SHAPE@','STOPID'],sql) as cursor:</strong></span>
<span class="strong"><strong>    for row in cursor:</strong></span>
<span class="strong"><strong>        stopShape = row[0]</strong></span>
<span class="strong"><strong>        print row[1]</strong></span>
<span class="strong"><strong>        arcpy.na.AddLocations(networkLayer,'Stops', stopShape, "", "")</strong></span>
<span class="strong"><strong>arcpy.na.Solve(networkLayer,"SKIP")</strong></span>
<span class="strong"><strong>arcpy.management.SaveToLayerFile(networkLayer,routeLayerFile,"RELATIVE")</strong></span>
<span class="strong"><strong>print 'finished'</strong></span>
</pre></div><p>The tool<a id="id413" class="indexterm"/> will produce the same layer output as the original script, but the reorganization of the Network Analyst tools into the <code class="literal">na</code> module has made the code more logical. For instance, it makes more sense to call <code class="literal">Solve</code> using <code class="literal">arcpy.na.Solve()</code>, instead of <code class="literal">arcpy.Solve_na()</code>, as it reinforces that <code class="literal">Solve</code> is a method of the Network Analyst (<code class="literal">na</code>) module. As ArcPy continues to be developed, I expect more <span class="strong"><strong>Pythonic</strong></span> code reorganization to occur.</p></div>
<div class="section" title="Accessing the Spatial Analyst Extension"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec55"/>Accessing the Spatial Analyst Extension</h1></div></div></div><p>The <a id="id414" class="indexterm"/>Spatial Analyst Extension is very important to perform analysis on both raster and vector datasets, but it is generally used to perform surface analysis and raster math. These operations are made even easier by the use of ArcPy, as all of the tools available in the Spatial Analyst Toolbox are exposed with the Spatial Analyst access module. This includes the Raster Calculator tools, making map algebra easy by using the tools and operators in simple expressions.</p><div class="section" title="Adding elevation to the bus stops"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec81"/>Adding elevation to the bus stops</h2></div></div></div><p>The <a id="id415" class="indexterm"/>elevation raster "sf_elevation" has been downloaded from NOAA and added to the File Geodatabase. However, it covers the entire Bay Area, and we should write a script to only extract an area of the city of San Francisco as it will reduce the time needed to run our scripts. We'll use a SQL statement as the <code class="literal">where</code> clause to limit the results to the South of Market (SoMa) neighborhood. To do so, let's take advantage of a Search Cursor and the Spatial Analyst access module's Extract by Polygon property:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>import arcpy</strong></span>
<span class="strong"><strong>arcpy.CheckOutExtension("Spatial")</strong></span>
<span class="strong"><strong>busStops = r'C:\Projects\PacktDB.gdb\SanFrancisco\Bus_Stops'</strong></span>
<span class="strong"><strong>sanFranciscoHoods = r'C:\Projects\PacktDB.gdb\SanFrancisco\SFFind_Neighborhoods'</strong></span>
<span class="strong"><strong>sfElevation = r'C:\Projects\PacktDB.gdb\sf_elevation'</strong></span>
<span class="strong"><strong>somaGeometry = []</strong></span>
<span class="strong"><strong>sql = "name = 'South of Market'"</strong></span>
<span class="strong"><strong>with arcpy.da.SearchCursor(sanFranciscoHoods,['SHAPE@XY'],sql,None, True) as cursor:</strong></span>
<span class="strong"><strong>    for row in cursor:</strong></span>
<span class="strong"><strong>       X = row[0][0]</strong></span>
<span class="strong"><strong>        Y = row[0][1]</strong></span>
<span class="strong"><strong>        somaGeometry.append(arcpy.Point(X,Y))</strong></span>
<span class="strong"><strong>somaElev = arcpy.sa.ExtractByPolygon(sfElevation,somaGeometry,"INSIDE")</strong></span>
<span class="strong"><strong>somaOutPath = sfElevation.replace('sf_elevation','SOMA_elev')</strong></span>
<span class="strong"><strong>somaElev.save(somaOutPath)</strong></span>
<span class="strong"><strong>print 'extraction finished'</strong></span>
</pre></div><p>The <code class="literal">ExtractByPolygon()</code> method is a bit misleading, as it does not accept a <code class="literal">Polygon</code> object as a parameter. Instead, it requires a list of <code class="literal">Point</code> objects that represent the vertices of the <a id="id416" class="indexterm"/>area that we want to extract. As the <code class="literal">SearchCursor</code> is iterating through the neighborhoods dataset, a <code class="literal">Polygon</code> object is returned by the cursor. Fortunately, the <code class="literal">SearchCursor</code> has a final parameter, which we have not yet explored, that allows us to extract the individual points or vertices that make up the <code class="literal">Soma</code> neighborhood polygon. By setting the Search Cursor's optional Explode to Points parameter (which converts Polygon objects into coordinate pairs for each vertex) to <code class="literal">True</code>, Point objects can be generated by passing the <code class="literal">XY</code> values of each returned vertex to the <code class="literal">arcpy.Point</code> method. These <code class="literal">Point()</code> objects are appended to the <code class="literal">somaGeometry</code> list and then passed to the Spatial Analyst access module's <code class="literal">ExtractByPolygon</code> method.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>Passing a Polygon Object instead of Point Objects will return an error.</p></div></div></div><div class="section" title="Using Map Algebra to generate elevation in feet"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec82"/>Using Map Algebra to generate elevation in feet</h2></div></div></div><p>We now have a<a id="id417" class="indexterm"/> raster to use to extract elevation values. However, both the original raster and the generated SoMa neighborhood raster contain elevation values in meters, and it would be better to convert them to feet to keep them consistent with the projection of the bus stops. Let's use raster math and the <code class="literal">Times()</code> method to convert the values from meters to feet:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>somaOutPath = sfElevation.replace('sf_elevation','SOMA_elev')</strong></span>
<span class="strong"><strong>outTimes = arcpy.sa.Times(somaOutPath, 3.28084)</strong></span>
<span class="strong"><strong>somaFeetOutPath = sfElevation.replace('sf_elevation','SOMA_feet')</strong></span>
<span class="strong"><strong>outTimes.save(somaFeetOutPath)</strong></span>
</pre></div><p>The <code class="literal">Times()</code> method generates <a id="id418" class="indexterm"/>a new raster to glean the elevation values we need for the bus stops of interest.</p></div><div class="section" title="Adding in the bus stops and getting elevation values"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec83"/>Adding in the bus stops and getting elevation values</h2></div></div></div><p>Now that <a id="id419" class="indexterm"/>we have generated a raster that we <a id="id420" class="indexterm"/>can use to find elevation values in feet, we need to add a new <code class="literal">arcpy.sa()</code> method to generate the points. The <code class="literal">ExtractValuesToPoints()</code> method will generate a new bus stops feature class with a new field that holds the elevation values:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>with arcpy.da.SearchCursor(sanFranciscoHoods,['SHAPE@'],sql) as cursor:</strong></span>
<span class="strong"><strong>    for row in cursor:</strong></span>
<span class="strong"><strong>        somaPoly = row[0]</strong></span>
<span class="strong"><strong>arcpy.MakeFeatureLayer_management(busStops, 'soma_stops')</strong></span>
<span class="strong"><strong>arcpy.SelectLayerByLocation_management("soma_stops", "INTERSECT",somaPoly)</strong></span>
<span class="strong"><strong>outStops = r'C:\Projects\PacktDB.gdb\Chapter11Results\SoMaStops'</strong></span>
<span class="strong"><strong>arcpy.sa.ExtractValuesToPoints("soma_stops", somaOutFeet,outStops,"INTERPOLATE","VALUE_ONLY")</strong></span>
<span class="strong"><strong>print 'points generated'</strong></span>
</pre></div></div></div>
<div class="section" title="The final result"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec56"/>The final result</h1></div></div></div><p>We produced a subset feature class of the bus stops that has the elevation values added as a field. This process could be repeated for the entire city, one neighborhood at a time, or it could be performed with the original elevation raster on the entire bus stops feature class to generate a value for each stop:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>import arcpy</strong></span>
<span class="strong"><strong>arcpy.CheckOutExtension("Spatial")</strong></span>
<span class="strong"><strong>arcpy.env.overwriteOutput = True</strong></span>
<span class="strong"><strong>busStops = r'C:\Projects\PacktDB.gdb\SanFrancisco\Bus_Stops'</strong></span>
<span class="strong"><strong>sanFranciscoHoods = r'C:\Projects\SanFrancisco.gdb\SanFrancisco\SFFind_Neighborhoods'</strong></span>
<span class="strong"><strong>sfElevation = r'C:\Projects\SanFrancisco.gdb\sf_elevation'</strong></span>

<span class="strong"><strong>somaGeometry = []</strong></span>
<span class="strong"><strong>sql = "name = 'South of Market'"</strong></span>
<span class="strong"><strong>with arcpy.da.SearchCursor(sanFranciscoHoods,['SHAPE@XY'],sql,None, True) as cursor:</strong></span>
<span class="strong"><strong>    for row in cursor:</strong></span>
<span class="strong"><strong>        somaGeometry.append(arcpy.Point(row[0][0],row[0][1]))</strong></span>
<span class="strong"><strong>somaElev = arcpy.sa.ExtractByPolygon(sfElevation, somaGeometry,"INSIDE")</strong></span>
<span class="strong"><strong>somaOutput = sfElevation.replace('sf_elevation','SOMA_elev')</strong></span>
<span class="strong"><strong>somaElev.save(somaOutput)</strong></span>
<span class="strong"><strong>print 'extraction finished'</strong></span>

<span class="strong"><strong>somaOutput = sfElevation.replace('sf_elevation','SOMA_elev')</strong></span>
<span class="strong"><strong>outTimes = arcpy.sa.Times(somaOutput, 3.28084)</strong></span>
<span class="strong"><strong>somaOutFeet = sfElevation.replace('sf_elevation','SOMA_feet')</strong></span>
<span class="strong"><strong>outTimes.save(somaOutFeet)</strong></span>
<span class="strong"><strong>print 'conversion complete'</strong></span>

<span class="strong"><strong>with arcpy.da.SearchCursor(sanFranciscoHoods,['SHAPE@'],sql) as cursor:</strong></span>
<span class="strong"><strong>    for row in cursor:</strong></span>
<span class="strong"><strong>        somaPoly = row[0]</strong></span>

<span class="strong"><strong>arcpy.MakeFeatureLayer_management(busStops, 'soma_stops')</strong></span>
<span class="strong"><strong>arcpy.SelectLayerByLocation_management("soma_stops", "INTERSECT",somaPoly)</strong></span>

<span class="strong"><strong>outStops = r'C:\Projects\SanFrancisco.gdb\Chapter11Results\SoMaStops'</strong></span>
<span class="strong"><strong>arcpy.sa.ExtractValuesToPoints("soma_stops", somaOutFeet,outStops,"INTERPOLATE","VALUE_ONLY")</strong></span>
<span class="strong"><strong>print 'points generated'</strong></span>
</pre></div><p>This<a id="id421" class="indexterm"/> script demonstrates well the value <a id="id422" class="indexterm"/>of accessing the advanced extensions in ArcPy and combining them with <code class="literal">SearchCursors</code> and <code class="literal">Geometry</code> objects. The script could be taken even further by adding a <code class="literal">SearchCursor</code> to look through the <code class="literal">outstops</code> dataset and exporting the results to a spreadsheet, or even adding a new field to the original bus stops dataset to populate with the elevation values. It could even be used as impedance values to be entered into a Network Analyst extension analysis—a fun coding task that I hope you will attempt.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec57"/>Summary</h1></div></div></div><p>In this chapter, we covered the basics of using common ArcGIS for Desktop Advanced extensions within ArcPy, with a focus on the Network Analyst access module and the Spatial Analyst access module. We explored how to generate a network and how to create network paths using ArcPy. We also explored how to access Spatial Analyst tools and use them in conjunction with <code class="literal">SearchCursors</code> to work with rasters and vectors for spatial analysis.</p><p>In the next chapter, we will explore some final pieces to the ArcPy puzzle that will allow the creation of advanced scripts and script tools.</p></div></body></html>