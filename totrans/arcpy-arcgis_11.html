<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Network Analyst and Spatial Analyst with ArcPy</h1></div></div></div><p>Use of the ArcGIS for Desktop extensions also benefits from the power of Python and ArcPy. The ability to model routes using a streets dataset or a bus routes dataset using ArcPy will help us convert entire workflows into script tools. Both Network Analysts and Spatial Analysts have access modules built into ArcPy for improved control of their available tools, methods, and properties.</p><p>This chapter will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating a simple network dataset</li><li class="listitem" style="list-style-type: disc">Checking out the extensions</li><li class="listitem" style="list-style-type: disc">The ArcPy Network Analyst module</li><li class="listitem" style="list-style-type: disc">The ArcPy Spatial Analyst module</li></ul></div><div><div><div><div><h1 class="title"><a id="ch11lvl1sec52"/>The Network Analyst extension</h1></div></div></div><p>The ESRI's Network Analyst extension is a powerful tool to enable routing and network connectivity<a id="id396" class="indexterm"/> functionality within ArcGIS. The extension, when used for street routing, allows users to find the quickest path between two points along a road network. The route can be constrained by a number of factors, such as traffic or left turns, to better model road travel. Similar analysis can be run using other types of networks, such as water pipe networks or electrical networks.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec53"/>Using Network Analyst</h1></div></div></div><p>To use<a id="id397" class="indexterm"/> the Network Analyst extension, the ArcGIS for Desktop Advanced license is required. In ArcCatalog or ArcMap, click on the <strong>Customize</strong> menu and select <strong>Extensions</strong>. Once the Extensions menu is open, click on the checkbox next to turn on the <strong>Network Analyst Extension.</strong>
</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec77"/>Creating a Feature Dataset</h2></div></div></div><p>The first step<a id="id398" class="indexterm"/> to using a network dataset is<a id="id399" class="indexterm"/> to create one within a feature dataset. To do so, we will generate a feature dataset to hold the data of interest. Right-click on the <strong>File</strong> geodatabase that houses the <strong>Bus Stop</strong> data and select <strong>New</strong>, and then select <strong>Feature Dataset</strong> from the <strong>New</strong> menu. Name it <code class="literal">Chapter11Results</code> and click on <strong>Next</strong>.</p><div><img src="img/8662OS_11_01.jpg" alt="Creating a Feature Dataset"/></div><p>Next, select the <strong>Spatial Reference System</strong> (<strong>SRS</strong>). In this case, we will be using the SRS of the local State Plane zone for San Francisco. It is a projected coordinate system, so select that folder, and then click on the <code class="literal">State Plane</code> folder. Once it is opened, select the folder called <strong>NAD 1983(US Feet)</strong>. From the available reference systems, select the one called <strong>NAD 1983 StatePlane California III FIPS 0403 (US Feet)</strong>. Click on <strong>Next</strong> to go to the next menu.</p><div><div><h3 class="title"><a id="note22"/>Note</h3><p>This system is also known as 2227 in <strong>Well Known ID</strong> (<strong>WKID</strong>) or <strong>European Petroleum Survey Group</strong> (<strong>EPSG</strong>) systems. More information about these codes is available at <a class="ulink" href="http://spatialreference.org">http://spatialreference.org</a>, a website used to find the thousands of spatial reference systems used throughout the world.</p></div></div><p>Click<a id="id400" class="indexterm"/> on the <strong>Vertical Coordinate Systems</strong> folder <a id="id401" class="indexterm"/>and then select the <strong>North America</strong> folder. Select the <strong>North American Vertical Datum of 1988 in feet </strong>(<strong>NAVD 1988 US survey feet</strong>). This will make it possible to have the vertical and horizontal linear units in the same measurement system. Click on <strong>Next</strong> to go to the next menu.</p><p>The tolerances on the next page are also very important, but we will not cover them in detail here. Accept the defaults and click on <strong>Finish</strong> to finalize the <strong>Feature Dataset</strong>.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec78"/>Importing the datasets</h2></div></div></div><p>Import <a id="id402" class="indexterm"/>the bus stops, streets, and bus routes feature classes<a id="id403" class="indexterm"/> into the <code class="literal">Chapter 11 Results Feature Dataset</code>. Right-click on the dataset and select <strong>Import</strong>, and then <strong>Feature Class (Single)</strong>. Add the feature classes one by one to give them a new name that will keep them separated from the versions contained within the <strong>SanFrancisco Feature Dataset</strong>. Importing them will make sure that they are in the correct SRS and that a network dataset can be created.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec79"/>Creating the Network Dataset</h2></div></div></div><p>Now<a id="id404" class="indexterm"/> that we have a data container, we can <a id="id405" class="indexterm"/>create a network dataset from the streets feature class. Right-click on the <strong>Chapter11Results </strong>feature dataset and select <strong>New</strong>, and then choose <strong>Network Dataset</strong>.</p><p> </p><div><img src="img/8662OS_11_02.jpg" alt="Creating the Network Dataset"/></div><p>
</p><p>Call the <a id="id406" class="indexterm"/>
<strong>Network Dataset</strong> <code class="literal">Street_Network</code> and click on <strong>Next</strong>. Select the <strong>Streets feature class</strong> as the class that will participate in<a id="id407" class="indexterm"/> the network dataset and click on <strong>Next</strong> to move to the next menu. Select <strong>Global Turns</strong> to model turns within the network. In the next menu, use the default connectivity settings. Then, accept the <strong>Using Z Coordinate Values from Geometry</strong> setting. Accept the default cost restriction and driving directions settings, and finally click on <strong>Finish</strong> to generate the network dataset. Then, build the network dataset using the final menu. The network dataset is ready to be used.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec80"/>Accessing the Network Dataset using ArcPy</h2></div></div></div><p>Now<a id="id408" class="indexterm"/> that the necessary setup<a id="id409" class="indexterm"/> has been completed, the street_network network dataset can be added to a script for use in generating routes. Because this is a simple analysis, the only impedance value to be used will be the length of the street segments. Through the use of a <code class="literal">SearchCursor</code>, <code class="literal">PointGeometry</code> objects from the bus stops can be accessed and added as locations to be searched:</p><div><pre class="programlisting">
<strong>import arcpy</strong>
<strong>arcpy.CheckOutExtension("Network")</strong>
<strong>busStops = r'C:\Projects\PacktDB.gdb\Chapter11Results\BusStops'</strong>
<strong>networkDataset = r'C:\Projects\PacktDB.gdb\Chapter11Results\street_network'</strong>
<strong>networkLayer = "streetRoute"</strong>
<strong>impedance = "Length"</strong>
<strong>routeFile = "C:\Projects\Layer\{0}.lyr".format(networkLayer)</strong>
<strong>arcpy.MakeRouteLayer_na(networkDataset,</strong>
<strong>           networkLayer, impedance)</strong>
<strong>print 'layer created'</strong>
<strong>sql = "NAME = '71 IB' AND BUS_SIGNAG = 'Ferry Plaza'"</strong>
<strong>with arcpy.da.SearchCursor(busStops,['SHAPE@', 'STOPID'],sql) as cursor:</strong>
<strong>    for row in cursor:</strong>
<strong>        stopShape = row[0]</strong>
<strong>        print row[1]</strong>
<strong>        arcpy.AddLocations_na(networkLayer,'Stops',stopShape, "", "")      </strong>
<strong>   arcpy.Solve_na(networkLayer,"SKIP")</strong>
<strong>arcpy.SaveToLayerFile_management(networkLayer,routeLayerFile,"RELATIVE")</strong>
<strong>print 'finished'</strong>
</pre></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec36"/>Breaking down the script</h3></div></div></div><p>Let's dissect<a id="id410" class="indexterm"/> the script, which once finished, will generate a layer file containing the added Stops, and the Routes along streets to best get from the origin stop to the destination stop.</p><p>The script begins by importing the arcPy module. The next line allows us to use the Network Analyst extension:</p><div><pre class="programlisting">
<strong>arcpy.CheckOutExtension("Network")</strong>
</pre></div><p>Using the <code class="literal">arcpy.CheckOutExtension()</code> method to invoke the Network Analyst extension involves passing the correct keyword to the method as a parameter. Once it has been invoked, the tools of the extension can be called and executed in the script.</p><p>Assigning the bus stops feature class and the street_network network dataset to variables, they can then be passed to ArcPy's <code class="literal">MakeRouteLayer_na()</code> method, along with a variable representing the impedance value:</p><div><pre class="programlisting">
<strong>arcpy.MakeRouteLayer_na(networkDataset,</strong>
<strong>           networkLayer, impedance)</strong>
</pre></div><p>The <code class="literal">MakeRouteLayer_na</code> tool produces a <code class="literal">RouteLayer</code> in memory. This blank layer needs to be populated with stops to produce the route(s) between them. For this purpose, we need a <code class="literal">SearchCursor</code> to access the <code class="literal">PointGeometry</code> objects and a SQL statement that will limit the returned results to the line of interest:</p><div><pre class="programlisting">
<strong>sql = "NAME = '71 IB' AND BUS_SIGNAG = 'Ferry Plaza'"</strong>
<strong>with arcpy.da.SearchCursor(busStops,['SHAPE@', 'STOPID'],sql) as cursor:</strong>
<strong>    for row in cursor:</strong>
<strong>        stopShape = row[0]</strong>
<strong>        print row[1]</strong>
<strong>        arcpy.AddLocations_na(networkLayer,'Stops',stopShape,"", "")</strong>
</pre></div><p>The Search <a id="id411" class="indexterm"/>Cursor will allow the <strong>Stops</strong> sublayer of the layer produced by the MakeRouteLayer tool to be populated when used in conjunction with the <code class="literal">AddLocations</code> tool. Once populated, the <code class="literal">RouteLayer</code> can be passed to the <strong>Solve</strong> tool to find the routes between the points of interest. Again, the routes are solved based on finding the lowest <strong>impedance</strong> between the two points. In this example, the only impedance is the segment length, but it could be traffic or elevation or other restriction types, if that data is available:</p><div><pre class="programlisting">
<strong>   arcpy.Solve_na(networkLayer,"SKIP")</strong>
<strong>arcpy.SaveToLayerFile_management(networkLayer,routeLayerFile,"RELATIVE")</strong>
</pre></div><p>The final result is a layer file that is written to disk using the <code class="literal">SaveToLayerFile</code> tool.</p><p> </p><div><img src="img/8662OS_11_03.jpg" alt="Breaking down the script"/></div><p>
</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec54"/>The Network Analyst module</h1></div></div></div><p>In an <a id="id412" class="indexterm"/>effort to make the use of the Network Analyst extension more <strong>Pythonic</strong>, the newer Network Analyst (<code class="literal">na</code>) module adjusts how the methods that correspond to the ArcToolbox Network Analyst tools are accessed. Instead of calling the tools directly from ArcPy, the tools are now methods of the <code class="literal">na</code> module. Removing the initials of the Network Analyst toolset also reduces confusion and makes it easier to remember the name of the method. See the difference as follows:</p><div><pre class="programlisting">
<strong>import arcpy</strong>
<strong>arcpy.CheckOutExtension("Network")</strong>
<strong>busStops = r'C:\Projects\SanFrancisco.gdb\SanFrancisco\Bus_Stops</strong>
<strong>networkDataset = r'C:\Projects\SanFrancisco.gdb\Chapter11Results\street_network'</strong>
<strong>networkLayer = "streetRoute"</strong>
<strong>impedance = "Length"</strong>
<strong>routeLayerFile = "C:\Projects\Layer\{0}_2.lyr".format(networkLayer)arcpy.na.MakeRouteLayer(networkDataset, networkLayer,impedance)</strong>
<strong>print 'layer created'</strong>
<strong>sql = "NAME = '71 IB' AND BUS_SIGNAG = 'Ferry Plaza'"</strong>
<strong>with arcpy.da.SearchCursor(busStops,['SHAPE@','STOPID'],sql) as cursor:</strong>
<strong>    for row in cursor:</strong>
<strong>        stopShape = row[0]</strong>
<strong>        print row[1]</strong>
<strong>        arcpy.na.AddLocations(networkLayer,'Stops', stopShape, "", "")</strong>
<strong>arcpy.na.Solve(networkLayer,"SKIP")</strong>
<strong>arcpy.management.SaveToLayerFile(networkLayer,routeLayerFile,"RELATIVE")</strong>
<strong>print 'finished'</strong>
</pre></div><p>The tool<a id="id413" class="indexterm"/> will produce the same layer output as the original script, but the reorganization of the Network Analyst tools into the <code class="literal">na</code> module has made the code more logical. For instance, it makes more sense to call <code class="literal">Solve</code> using <code class="literal">arcpy.na.Solve()</code>, instead of <code class="literal">arcpy.Solve_na()</code>, as it reinforces that <code class="literal">Solve</code> is a method of the Network Analyst (<code class="literal">na</code>) module. As ArcPy continues to be developed, I expect more <strong>Pythonic</strong> code reorganization to occur.</p></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec55"/>Accessing the Spatial Analyst Extension</h1></div></div></div><p>The <a id="id414" class="indexterm"/>Spatial Analyst Extension is very important to perform analysis on both raster and vector datasets, but it is generally used to perform surface analysis and raster math. These operations are made even easier by the use of ArcPy, as all of the tools available in the Spatial Analyst Toolbox are exposed with the Spatial Analyst access module. This includes the Raster Calculator tools, making map algebra easy by using the tools and operators in simple expressions.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec81"/>Adding elevation to the bus stops</h2></div></div></div><p>The <a id="id415" class="indexterm"/>elevation raster "sf_elevation" has been downloaded from NOAA and added to the File Geodatabase. However, it covers the entire Bay Area, and we should write a script to only extract an area of the city of San Francisco as it will reduce the time needed to run our scripts. We'll use a SQL statement as the <code class="literal">where</code> clause to limit the results to the South of Market (SoMa) neighborhood. To do so, let's take advantage of a Search Cursor and the Spatial Analyst access module's Extract by Polygon property:</p><div><pre class="programlisting">
<strong>import arcpy</strong>
<strong>arcpy.CheckOutExtension("Spatial")</strong>
<strong>busStops = r'C:\Projects\PacktDB.gdb\SanFrancisco\Bus_Stops'</strong>
<strong>sanFranciscoHoods = r'C:\Projects\PacktDB.gdb\SanFrancisco\SFFind_Neighborhoods'</strong>
<strong>sfElevation = r'C:\Projects\PacktDB.gdb\sf_elevation'</strong>
<strong>somaGeometry = []</strong>
<strong>sql = "name = 'South of Market'"</strong>
<strong>with arcpy.da.SearchCursor(sanFranciscoHoods,['SHAPE@XY'],sql,None, True) as cursor:</strong>
<strong>    for row in cursor:</strong>
<strong>       X = row[0][0]</strong>
<strong>        Y = row[0][1]</strong>
<strong>        somaGeometry.append(arcpy.Point(X,Y))</strong>
<strong>somaElev = arcpy.sa.ExtractByPolygon(sfElevation,somaGeometry,"INSIDE")</strong>
<strong>somaOutPath = sfElevation.replace('sf_elevation','SOMA_elev')</strong>
<strong>somaElev.save(somaOutPath)</strong>
<strong>print 'extraction finished'</strong>
</pre></div><p>The <code class="literal">ExtractByPolygon()</code> method is a bit misleading, as it does not accept a <code class="literal">Polygon</code> object as a parameter. Instead, it requires a list of <code class="literal">Point</code> objects that represent the vertices of the <a id="id416" class="indexterm"/>area that we want to extract. As the <code class="literal">SearchCursor</code> is iterating through the neighborhoods dataset, a <code class="literal">Polygon</code> object is returned by the cursor. Fortunately, the <code class="literal">SearchCursor</code> has a final parameter, which we have not yet explored, that allows us to extract the individual points or vertices that make up the <code class="literal">Soma</code> neighborhood polygon. By setting the Search Cursor's optional Explode to Points parameter (which converts Polygon objects into coordinate pairs for each vertex) to <code class="literal">True</code>, Point objects can be generated by passing the <code class="literal">XY</code> values of each returned vertex to the <code class="literal">arcpy.Point</code> method. These <code class="literal">Point()</code> objects are appended to the <code class="literal">somaGeometry</code> list and then passed to the Spatial Analyst access module's <code class="literal">ExtractByPolygon</code> method.</p><div><div><h3 class="title"><a id="note23"/>Note</h3><p>Passing a Polygon Object instead of Point Objects will return an error.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec82"/>Using Map Algebra to generate elevation in feet</h2></div></div></div><p>We now have a<a id="id417" class="indexterm"/> raster to use to extract elevation values. However, both the original raster and the generated SoMa neighborhood raster contain elevation values in meters, and it would be better to convert them to feet to keep them consistent with the projection of the bus stops. Let's use raster math and the <code class="literal">Times()</code> method to convert the values from meters to feet:</p><div><pre class="programlisting">
<strong>somaOutPath = sfElevation.replace('sf_elevation','SOMA_elev')</strong>
<strong>outTimes = arcpy.sa.Times(somaOutPath, 3.28084)</strong>
<strong>somaFeetOutPath = sfElevation.replace('sf_elevation','SOMA_feet')</strong>
<strong>outTimes.save(somaFeetOutPath)</strong>
</pre></div><p>The <code class="literal">Times()</code> method generates <a id="id418" class="indexterm"/>a new raster to glean the elevation values we need for the bus stops of interest.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec83"/>Adding in the bus stops and getting elevation values</h2></div></div></div><p>Now that <a id="id419" class="indexterm"/>we have generated a raster that we <a id="id420" class="indexterm"/>can use to find elevation values in feet, we need to add a new <code class="literal">arcpy.sa()</code> method to generate the points. The <code class="literal">ExtractValuesToPoints()</code> method will generate a new bus stops feature class with a new field that holds the elevation values:</p><div><pre class="programlisting">
<strong>with arcpy.da.SearchCursor(sanFranciscoHoods,['SHAPE@'],sql) as cursor:</strong>
<strong>    for row in cursor:</strong>
<strong>        somaPoly = row[0]</strong>
<strong>arcpy.MakeFeatureLayer_management(busStops, 'soma_stops')</strong>
<strong>arcpy.SelectLayerByLocation_management("soma_stops", "INTERSECT",somaPoly)</strong>
<strong>outStops = r'C:\Projects\PacktDB.gdb\Chapter11Results\SoMaStops'</strong>
<strong>arcpy.sa.ExtractValuesToPoints("soma_stops", somaOutFeet,outStops,"INTERPOLATE","VALUE_ONLY")</strong>
<strong>print 'points generated'</strong>
</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec56"/>The final result</h1></div></div></div><p>We produced a subset feature class of the bus stops that has the elevation values added as a field. This process could be repeated for the entire city, one neighborhood at a time, or it could be performed with the original elevation raster on the entire bus stops feature class to generate a value for each stop:</p><div><pre class="programlisting">
<strong>import arcpy</strong>
<strong>arcpy.CheckOutExtension("Spatial")</strong>
<strong>arcpy.env.overwriteOutput = True</strong>
<strong>busStops = r'C:\Projects\PacktDB.gdb\SanFrancisco\Bus_Stops'</strong>
<strong>sanFranciscoHoods = r'C:\Projects\SanFrancisco.gdb\SanFrancisco\SFFind_Neighborhoods'</strong>
<strong>sfElevation = r'C:\Projects\SanFrancisco.gdb\sf_elevation'</strong>

<strong>somaGeometry = []</strong>
<strong>sql = "name = 'South of Market'"</strong>
<strong>with arcpy.da.SearchCursor(sanFranciscoHoods,['SHAPE@XY'],sql,None, True) as cursor:</strong>
<strong>    for row in cursor:</strong>
<strong>        somaGeometry.append(arcpy.Point(row[0][0],row[0][1]))</strong>
<strong>somaElev = arcpy.sa.ExtractByPolygon(sfElevation, somaGeometry,"INSIDE")</strong>
<strong>somaOutput = sfElevation.replace('sf_elevation','SOMA_elev')</strong>
<strong>somaElev.save(somaOutput)</strong>
<strong>print 'extraction finished'</strong>

<strong>somaOutput = sfElevation.replace('sf_elevation','SOMA_elev')</strong>
<strong>outTimes = arcpy.sa.Times(somaOutput, 3.28084)</strong>
<strong>somaOutFeet = sfElevation.replace('sf_elevation','SOMA_feet')</strong>
<strong>outTimes.save(somaOutFeet)</strong>
<strong>print 'conversion complete'</strong>

<strong>with arcpy.da.SearchCursor(sanFranciscoHoods,['SHAPE@'],sql) as cursor:</strong>
<strong>    for row in cursor:</strong>
<strong>        somaPoly = row[0]</strong>

<strong>arcpy.MakeFeatureLayer_management(busStops, 'soma_stops')</strong>
<strong>arcpy.SelectLayerByLocation_management("soma_stops", "INTERSECT",somaPoly)</strong>

<strong>outStops = r'C:\Projects\SanFrancisco.gdb\Chapter11Results\SoMaStops'</strong>
<strong>arcpy.sa.ExtractValuesToPoints("soma_stops", somaOutFeet,outStops,"INTERPOLATE","VALUE_ONLY")</strong>
<strong>print 'points generated'</strong>
</pre></div><p>This<a id="id421" class="indexterm"/> script demonstrates well the value <a id="id422" class="indexterm"/>of accessing the advanced extensions in ArcPy and combining them with <code class="literal">SearchCursors</code> and <code class="literal">Geometry</code> objects. The script could be taken even further by adding a <code class="literal">SearchCursor</code> to look through the <code class="literal">outstops</code> dataset and exporting the results to a spreadsheet, or even adding a new field to the original bus stops dataset to populate with the elevation values. It could even be used as impedance values to be entered into a Network Analyst extension analysis—a fun coding task that I hope you will attempt.</p></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec57"/>Summary</h1></div></div></div><p>In this chapter, we covered the basics of using common ArcGIS for Desktop Advanced extensions within ArcPy, with a focus on the Network Analyst access module and the Spatial Analyst access module. We explored how to generate a network and how to create network paths using ArcPy. We also explored how to access Spatial Analyst tools and use them in conjunction with <code class="literal">SearchCursors</code> to work with rasters and vectors for spatial analysis.</p><p>In the next chapter, we will explore some final pieces to the ArcPy puzzle that will allow the creation of advanced scripts and script tools.</p></div></body></html>