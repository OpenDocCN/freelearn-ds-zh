["```py\n      $ cd ~/virtualenvs\n      $ virtualenv --no-site-packages postgis-cb-env\n      $ source postgis-cb-env/bin/activate\n```", "```py\n      $ pip install simplejson\n      $ pip install psycopg2\n      $ pip install numpy\n      $ pip install requests\n      $ pip install gdal\n      $ pip install geopy\n```", "```py\n      $ ls /home/capooti/virtualenv/postgis-cb-env/lib/\n           python2.7/site-packages\n```", "```py\n      > python ez_setup.py\n      > python get-pip.py\n      > pip install requests\n      > pip install geopy\n```", "```py\n      postgis_cookbook=# CREATE SCHEMA chp08;\n```", "```py\n      $ ogr2ogr -f PostgreSQL -s_srs EPSG:4269 -t_srs EPSG:4326 \n      -lco GEOMETRY_NAME=the_geom -nln chp08.cities \n      PG:\"dbname='postgis_cookbook' user='me' \n      password='mypassword'\" -where \"POP_2000 $ 100000\" citiesx020.shp\n\n```", "```py\n    postgis_cookbook=# ALTER TABLE chp08.cities \n    ADD COLUMN temperature real;\n```", "```py\n      $ source postgis-cb-env/bin/activate\n```", "```py\n CREATE TABLE chp08.wstations \n      ( \n        id bigint NOT NULL, \n        the_geom geometry(Point,4326), \n        name character varying(48), \n        temperature real, \n        CONSTRAINT wstations_pk PRIMARY KEY (id ) \n      ); \n```", "```py\n        { \n          \"message\": \"accurate\", \n          \"cod\": \"200\", \n          \"count\": 10, \n          \"list\": [ \n            { \n              \"id\": 529315, \n              \"name\": \"Marinki\", \n              \"coord\": { \n              \"lat\": 55.0944, \n              \"lon\": 37.03 \n            }, \n            \"main\": { \n              \"temp\": 272.15, \n              \"pressure\": 1011, \n              \"humidity\": 80, \n              \"temp_min\": 272.15, \n              \"temp_max\": 272.15 \n            },       \"dt\": 1515114000, \n            \"wind\": { \n              \"speed\": 3, \n              \"deg\": 140 \n            }, \n            \"sys\": { \n              \"country\": \"\" \n            }, \n            \"rain\": null, \n            \"snow\": null, \n            \"clouds\": { \n              \"all\": 90 \n            }, \n            \"weather\": [ \n              { \n                \"id\": 804, \n                \"main\": \"Clouds\", \n                \"description\": \"overcast clouds\", \n                \"icon\": \"04n\" \n              } \n            ] \n        }, \n```", "```py\n        import sys \n        import requests \n        import simplejson as json \n        import psycopg2 \n\n        def GetWeatherData(lon, lat, key): \n          \"\"\" \n            Get the 10 closest weather stations data for a given point. \n          \"\"\" \n          # uri to access the JSON openweathermap web service \n          uri = ( \n            'https://api.openweathermap.org/data/2.5/find?\n             lat=%s&lon=%s&cnt=10&appid=%s' \n            % (lat, lon, key)) \n          print 'Fetching weather data: %s' % uri \n          try: \n            data = requests.get(uri) \n            print 'request status: %s' % data.status_code \n            js_data = json.loads(data.text) \n            return js_data['list'] \n          except: \n            print 'There was an error getting the weather data.' \n            print sys.exc_info()[0] \n            return [] \n\n        def AddWeatherStation(station_id, lon, lat, name, temperature): \n          \"\"\" \n            Add a weather station to the database, but only if it does \n            not already exists. \n          \"\"\" \n          curws = conn.cursor() \n          curws.execute('SELECT * FROM chp08.wstations WHERE id=%s',\n                        (station_id,)) \n          count = curws.rowcount \n          if count==0: # we need to add the weather station \n              curws.execute( \n            \"\"\"INSERT INTO chp08.wstations (id, the_geom, name,\n               temperature) VALUES (%s, ST_GeomFromText('POINT(%s %s)',\n               4326), %s, %s)\"\"\",\n            (station_id, lon, lat, name, temperature) \n          ) \n          curws.close() \n          print 'Added the %s weather station to the database.' % name \n          return True \n        else: # weather station already in database \n          print 'The %s weather station is already in the database.' % name \n          return False \n\n        # program starts here \n        # get a connection to the database \n        conn = psycopg2.connect('dbname=postgis_cookbook user=me \n                                 password=password') \n        # we do not need transaction here, so set the connection \n        # to autocommit mode \n        conn.set_isolation_level(0) \n\n        # open a cursor to update the table with weather data \n        cur = conn.cursor() \n\n        # iterate all of the cities in the cities PostGIS layer, \n        # and for each of them grap the actual temperature from the \n        # closest weather station, and add the 10 \n        # closest stations to the city to the wstation PostGIS layer \n        cur.execute(\"\"\"SELECT ogc_fid, name, \n          ST_X(the_geom) AS long, ST_Y(the_geom) AS lat\n          FROM chp08.cities;\"\"\") \n        for record in cur: \n          ogc_fid = record[0] \n          city_name = record[1] \n          lon = record[2] \n          lat = record[3] \n          stations = GetWeatherData(lon, lat, 'YOURKEY') \n          print stations \n          for station in stations: \n            print station \n            station_id = station['id'] \n            name = station['name'] \n            # for weather data we need to access the 'main' section in the\n            # json 'main': {'pressure': 990, 'temp': 272.15, 'humidity': 54} \n            if 'main' in station: \n              if 'temp' in station['main']: \n                temperature = station['main']['temp'] \n            else: \n              temperature = -9999 \n              # in some case the temperature is not available \n            # \"coord\":{\"lat\":55.8622,\"lon\":37.395} \n            station_lat = station['coord']['lat'] \n            station_lon = station['coord']['lon'] \n            # add the weather station to the database \n            AddWeatherStation(station_id, station_lon, station_lat, \n                              name, temperature) \n            # first weather station from the json API response is always \n            # the closest to the city, so we are grabbing this temperature \n            # and store in the temperature field in cities PostGIS layer \n            if station_id == stations[0]['id']: \n              print 'Setting temperature to %s for city %s' \n                    % (temperature, city_name) \n              cur2 = conn.cursor() \n              cur2.execute( \n                'UPDATE chp08.cities SET temperature=%s WHERE ogc_fid=%s', \n                (temperature, ogc_fid)) \n              cur2.close() \n\n        # close cursor, commit and close connection to database \n        cur.close() \n        conn.close() \n```", "```py\n      (postgis-cb-env)$ python get_weather_data.py\n      Added the PAMR weather station to the database.\n      Setting temperature to 268.15 for city Anchorage\n      Added the PAED weather station to the database.\n      Added the PANC weather station to the database.\n      ...\n      The KMFE weather station is already in the database.\n      Added the KOPM weather station to the database.\n      The KBKS weather station is already in the database.\n```", "```py\n      $ source postgis-cb-env/bin/activate\n```", "```py\n      (postgis-cb-env)$ pip install gdal\n      (postgis-cb-env)$ pip install simplejson\n```", "```py\n        {    \n          \"geonames\": [ \n            { \n              \"summary\": \"London is the capital and most populous city of \n                 England and United Kingdom. Standing on the River Thames,\n                 London has been a major settlement for two millennia, \n                 its history going back to its founding by the Romans, \n                 who named it Londinium (...)\", \n              \"elevation\": 8, \n              \"geoNameId\": 2643743, \n              \"feature\": \"city\", \n              \"lng\": -0.11832, \n              \"countryCode\": \"GB\", \n              \"rank\": 100, \n              \"thumbnailImg\": \"http://www.geonames.org/img/wikipedia/\n                               43000/thumb-42715-100.jpg\", \n              \"lang\": \"en\", \n              \"title\": \"London\", \n              \"lat\": 51.50939, \n              \"wikipediaUrl\": \"en.wikipedia.org/wiki/London\" \n            }, \n            { \n              \"summary\": \"New London is a city and a port of entry on the \n                 northeast coast of the United States. It is located at \n                 the mouth of the Thames River in New London County, \n                 southeastern Connecticut. New London is located about from \n                 the state capital of Hartford, \n                 from Boston, Massachusetts, from Providence, Rhode (...)\", \n              \"elevation\": 27, \n              \"feature\": \"landmark\", \n              \"lng\": -72.10083333333333, \n              \"countryCode\": \"US\", \n              \"rank\": 100, \n              \"thumbnailImg\": \"http://www.geonames.org/img/wikipedia/\n                              160000/thumb-159123-100.jpg\", \n              \"lang\": \"en\", \n              \"title\": \"New London, Connecticut\", \n              \"lat\": 41.355555555555554, \n              \"wikipediaUrl\": \"en.wikipedia.org/wiki/\n                               New_London%2C_Connecticut\" \n            },... \n          ]\n        } \n```", "```py\n      $ vi names.txt\n\n      London\n      Rome\n      Boston\n      Chicago\n      Madrid\n      Paris\n      ...\n```", "```py\n        import sys \n        import requests \n        import simplejson as json \n        from osgeo import ogr, osr \n\n        MAXROWS = 10 \n        USERNAME = 'postgis' #enter your username here \n\n        def CreatePGLayer(): \n          \"\"\" \n            Create the PostGIS table. \n          \"\"\" \n          driver = ogr.GetDriverByName('PostgreSQL') \n          srs = osr.SpatialReference() \n          srs.ImportFromEPSG(4326) \n          ogr.UseExceptions() \n          pg_ds = ogr.Open(\"PG:dbname='postgis_cookbook' host='localhost' \n             port='5432' user='me' password='password'\", update = 1) \n          pg_layer = pg_ds.CreateLayer('wikiplaces', srs = srs, \n                geom_type=ogr.wkbPoint, options = [ \n            'DIM=3', \n             # we want to store the elevation value in point z coordinate \n            'GEOMETRY_NAME=the_geom', \n            'OVERWRITE=YES', \n            # this will drop and recreate the table every time \n            'SCHEMA=chp08', \n          ]) \n          # add the fields \n          fd_title = ogr.FieldDefn('title', ogr.OFTString) \n          pg_layer.CreateField(fd_title) \n          fd_countrycode = ogr.FieldDefn('countrycode', ogr.OFTString) \n          pg_layer.CreateField(fd_countrycode) \n          fd_feature = ogr.FieldDefn('feature', ogr.OFTString) \n          pg_layer.CreateField(fd_feature) \n          fd_thumbnail = ogr.FieldDefn('thumbnail', ogr.OFTString) \n          pg_layer.CreateField(fd_thumbnail) \n          fd_wikipediaurl = ogr.FieldDefn('wikipediaurl', ogr.OFTString) \n          pg_layer.CreateField(fd_wikipediaurl) \n          return pg_ds, pg_layer \n\n        def AddPlacesToLayer(places): \n        \"\"\" \n          Read the places dictionary list and add features in the \n          PostGIS table for each place. \n        \"\"\" \n        # iterate every place dictionary in the list \n        print \"places: \", places \n        for place in places: \n          lng = place['lng'] \n          lat = place['lat'] \n          z = place.get('elevation') if 'elevation' in place else 0 \n          # we generate a point representation in wkt, \n          # and create an ogr geometry \n          point_wkt = 'POINT(%s %s %s)' % (lng, lat, z) \n          point = ogr.CreateGeometryFromWkt(point_wkt) \n          # we create a LayerDefn for the feature using the one \n          # from the layer \n          featureDefn = pg_layer.GetLayerDefn() \n          feature = ogr.Feature(featureDefn) \n          # now time to assign the geometry and all the  \n          # other feature's fields, if the keys are contained \n          # in the dictionary (not always the GeoNames \n          # Wikipedia Fulltext Search contains all of the information) \n          feature.SetGeometry(point) \n          feature.SetField('title', \n            place['title'].encode(\"utf-8\") if 'title' in place else '') \n          feature.SetField('countrycode', \n            place['countryCode'] if 'countryCode' in place else '') \n          feature.SetField('feature', \n            place['feature'] if 'feature' in place else '') \n          feature.SetField('thumbnail', \n            place['thumbnailImg'] if 'thumbnailImg' in place else '') \n          feature.SetField('wikipediaurl', \n            place['wikipediaUrl'] if 'wikipediaUrl' in place else '') \n          # here we create the feature (the INSERT SQL is issued here) \n          pg_layer.CreateFeature(feature) \n          print 'Created a places titled %s.' % place['title'] \n\n        def GetPlaces(placename): \n          \"\"\" \n            Get the places list for a given placename. \n          \"\"\" \n          # uri to access the JSON GeoNames Wikipedia Fulltext Search \n          # web service \n          uri = ('http://api.geonames.org/wikipediaSearchJSON?\n              formatted=true&q=%s&maxRows=%s&username=%s&style=full' \n              % (placename, MAXROWS, USERNAME)) \n          data = requests.get(uri) \n          js_data = json.loads(data.text) \n          return js_data['geonames'] \n\n        def GetNamesList(filepath): \n          \"\"\" \n            Open a file with a given filepath containing place names \n            and return a list. \n          \"\"\" \n          f = open(filepath, 'r') \n          return f.read().splitlines() \n\n        # first we need to create a PostGIS table to contains the places \n        # we must keep the PostGIS OGR dataset and layer global, \n        # for the reasons \n        # described here: http://trac.osgeo.org/gdal/wiki/PythonGotchas \n        from osgeo import gdal \n        gdal.UseExceptions() \n        pg_ds, pg_layer = CreatePGLayer()\n        try: \n          # query geonames for each name and store found \n          # places in the table \n          names = GetNamesList('names.txt') \n          print names \n            for name in names: \n            AddPlacesToLayer(GetPlaces(name)) \n        except Exception as e: \n          print(e) \n          print sys.exc_info()[0] \n```", "```py\n      (postgis-cb-env)$ python import_places.py\n```", "```py\n      postgis_cookbook=# select ST_AsText(the_geom), title,\n        countrycode, feature from chp08.wikiplaces;\n```", "```py\n (60 rows) \n```", "```py\n      $ sudo apt-get install postgresql-plpython-9.1\n```", "```py\n        {\n          message: \"\",\n          cod: \"200\",\n          calctime: \"\",\n          cnt: 1,\n          list: [\n            {\n              id: 9191,\n              dt: 1369343192,\n              name: \"100704-1\",\n              type: 2,\n              coord: {\n                lat: 13.7408,\n                lon: 100.5478\n              },\n              distance: 6.244,\n              main: {\n                temp: 300.37\n              },\n              wind: {\n                speed: 0,\n                deg: 141\n              },\n              rang: 30,\n              rain: {\n                1h: 0,\n                24h: 3.302,\n                today: 0\n              }\n            }\n          ]  \n        } \n```", "```py\n        CREATE OR REPLACE FUNCTION chp08.GetWeather(lon float, lat float)\n          RETURNS float AS $$\n          import urllib2\n          import simplejson as json\n          data = urllib2.urlopen(\n            'http://api.openweathermap.org/data/\n             2.1/find/station?lat=%s&lon=%s&cnt=1'\n            % (lat, lon))\n          js_data = json.load(data)\n          if js_data['cod'] == '200': \n          # only if cod is 200 we got some effective results\n            if int(js_data['cnt'])>0: \n            # check if we have at least a weather station\n              station = js_data['list'][0]\n              print 'Data from weather station %s' % station['name']\n              if 'main' in station:\n                if 'temp' in station['main']:\n                  temperature = station['main']['temp'] - 273.15 \n                  # we want the temperature in Celsius\n                else:\n                  temperature = None\n          else:\n            temperature = None\n          return temperature \n        $$ LANGUAGE plpythonu; \n```", "```py\n postgis_cookbook=# SELECT chp08.GetWeather(100.49, 13.74);\n getweather \n      ------------ \n      27.22 \n      (1 row) \n```", "```py\n postgis_cookbook=# SELECT name, temperature,\n      chp08.GetWeather(ST_X(the_geom), ST_Y(the_geom)) \n      AS temperature2 FROM chp08.cities LIMIT 5; \n      name     | temperature | temperature2 \n      -------------+-------------+-------------- \n      Minneapolis |      275.15 |           15 \n      Saint Paul  |      274.15 |           16 \n      Buffalo     |      274.15 |        19.44 \n      New York    |      280.93 |        19.44 \n      Jersey City |      282.15 |        21.67 \n      (5 rows) \n```", "```py\n CREATE OR REPLACE FUNCTION chp08.GetWeather(geom geometry)\n RETURNS float AS $$ \n      BEGIN \n        RETURN chp08.GetWeather(ST_X(ST_Centroid(geom)),\n               ST_Y(ST_Centroid(geom)));\n END; \n      $$ LANGUAGE plpgsql; \n```", "```py\n postgis_cookbook=# SELECT chp08.GetWeather(\n        ST_GeomFromText('POINT(-71.064544 42.28787)')); \n        getweather \n      ------------ \n      23.89 \n      (1 row) \n```", "```py\n postgis_cookbook=# SELECT name, temperature,\n      chp08.GetWeather(the_geom) AS temperature2 \n      FROM chp08.cities LIMIT 5; \n      name     | temperature | temperature2 \n      -------------+-------------+-------------- \n      Minneapolis |      275.15 |        17.22 \n      Saint Paul  |      274.15 |           16 \n      Buffalo     |      274.15 |        18.89 \n      New York    |      280.93 |        19.44 \n      Jersey City |      282.15 |        21.67 \n      (5 rows) \n```", "```py\n geonameid         : integer id of record in geonames  database \n      name              : name of geographical point (utf8) varchar(200) \n      asciiname         : name of geographical point in  plain \n                          ascii characters, varchar(200) \n      alternatenames    : alternatenames, comma separated varchar(5000) \n      latitude          : latitude in decimal degrees (wgs84) \n      longitude         : longitude in decimal degrees (wgs84) \n      ... \n```", "```py\n      $ ogrinfo CSV:IT.txt IT -al -so\n```", "```py\n      $ ogrinfo CSV:IT.txt IT -where \"NAME = 'San Gimignano'\"\n```", "```py\n $ ogr2ogr -f PostgreSQL -s_srs EPSG:4326 -t_srs EPSG:4326 \n      -lco GEOMETRY_NAME=the_geom -nln chp08.geonames \n      PG:\"dbname='postgis_cookbook' user='me' password='mypassword'\" \n      CSV:IT.txt -sql \"SELECT NAME, ASCIINAME FROM IT\" \n```", "```py\n postgis_cookbook=# SELECT ST_AsText(the_geom), name \n      FROM chp08.geonames LIMIT 10;\n```", "```py\n CREATE OR REPLACE FUNCTION chp08.Get_Closest_PlaceNames(\n        in_geom geometry, num_results int DEFAULT 5, \n        OUT geom geometry, OUT place_name character varying)\n RETURNS SETOF RECORD AS $$\n BEGIN\n RETURN QUERY\n SELECT the_geom as geom, name as place_name\n FROM chp08.geonames\n ORDER BY the_geom <-> ST_Centroid(in_geom) LIMIT num_results;\n END; \n      $$ LANGUAGE plpgsql; \n```", "```py\n postgis_cookbook=# SELECT * FROM chp08.Get_Closest_PlaceNames(\n        ST_PointFromText('POINT(13.5 42.19)', 4326), 10); \n```", "```py\n postgis_cookbook=# SELECT * FROM chp08.Get_Closest_PlaceNames(\n      ST_PointFromText('POINT(13.5 42.19)', 4326)); \n```", "```py\n CREATE OR REPLACE FUNCTION chp08.Find_PlaceNames(search_string text,\n num_results int DEFAULT 5,\n OUT geom geometry,\n OUT place_name character varying)\n RETURNS SETOF RECORD AS $$\n BEGIN\n RETURN QUERY\n SELECT the_geom as geom, name as place_name\n FROM chp08.geonames\n WHERE name @@ to_tsquery(search_string)\n LIMIT num_results;\n END; \n      $$ LANGUAGE plpgsql; \n```", "```py\n postgis_cookbook=# SELECT * FROM chp08.Find_PlaceNames('Rocca', 10);\n```", "```py\n      $ ogrinfo --version GDAL 2.1.2, released 2016/10/24\n      $ ogrinfo --formats | grep -i osm\n      -> \"OSM -vector- (rov): OpenStreetMap XML and PBF\"\n```", "```py\n      $ sudo apt-get install postgresql-contrib-9.1\n```", "```py\n      postgis_cookbook=# CREATE EXTENSION pg_trgm;\n      CREATE EXTENSION\n```", "```py\n      $ source postgis-cb-env/bin/activate\n```", "```py\n      (postgis-cb-env)$ pip install pygdal\n      (postgis-cb-env)$ pip install psycopg2\n```", "```py\n $ ogrinfo lazio.pbf\n Had to open data source read-only.\n INFO: Open of `lazio.pbf'\n using driver `OSM' successful.\n 1: points (Point)\n 2: lines (Line String)\n 3: multilinestrings (Multi Line String)\n 4: multipolygons (Multi Polygon) \n      5: other_relations (Geometry Collection)\n```", "```py\n $ ogr2ogr -f PostgreSQL -lco GEOMETRY_NAME=the_geom \n      -nln chp08.osm_roads \n      PG:\"dbname='postgis_cookbook' user='me' \n      password='mypassword'\" lazio.pbf lines \n```", "```py\n postgis_cookbook=# SELECT name, \n        similarity(name, 'via benedetto croce') AS sml,\n        ST_AsText(ST_Centroid(the_geom)) AS the_geom\n FROM chp08.osm_roads\n WHERE name % 'via benedetto croce'\n ORDER BY sml DESC, name; \n```", "```py\n postgis_cookbook=# SELECT name, \n        name <-> 'via benedetto croce' AS weight\n FROM chp08.osm_roads\n ORDER BY weight LIMIT 10;\n```", "```py\n        import sys \n        import psycopg2 \n\n        class OSMGeocoder(object): \n          \"\"\" \n            A class to provide geocoding features using an OSM \n            dataset in PostGIS. \n          \"\"\" \n\n          def __init__(self, db_connectionstring): \n            # initialize db connection parameters \n            self.db_connectionstring = db_connectionstring \n\n          def geocode(self, placename): \n            \"\"\" \n              Geocode a given place name. \n            \"\"\" \n            # here we create the connection object \n            conn = psycopg2.connect(self.db_connectionstring) \n            cur = conn.cursor() \n            # this is the core sql query, using trigrams to detect  \n            # streets similar to a given placename \n            sql = \"\"\" \n              SELECT name, name <-> '%s' AS weight, \n              ST_AsText(ST_Centroid(the_geom)) as  point \n              FROM chp08.osm_roads \n              ORDER BY weight LIMIT 10; \n            \"\"\" % placename \n            # here we execute the sql and return all of the results \n            cur.execute(sql) \n            rows = cur.fetchall() \n            cur.close() \n            conn.close() \n            return rows \n```", "```py\n        if __name__ == '__main__': \n          # the user must provide at least two parameters, the place name \n          # and the connection string to PostGIS \n          if len(sys.argv) < 3 or len(sys.argv) > 3: \n            print \"usage: <placename> <connection string>\" \n            raise SystemExit \n          placename = sys.argv[1] \n          db_connectionstring = sys.argv[2] \n          # here we instantiate the geocoder, providing the needed \n          # PostGIS connection parameters \n          geocoder = OSMGeocoder(db_connectionstring) \n          # here we query the geocode method, for getting the  \n          # geocoded points for the given placename \n          results = geocoder.geocode(placename) \n          print results \n```", "```py\n (postgis-cb-env)$ python osmgeocoder.py \"Via Benedetto Croce\" \n        \"dbname=postgis_cookbook user=me password=mypassword\"\n [('Via Benedetto Croce', 0.0, 'POINT(12.6999095325807\n                                           42.058016054317)'),...\n```", "```py\n      Via Delle Sette Chiese\n      Via Benedetto Croce\n      Lungotevere Degli Inventori\n      Viale Marco Polo\n      Via Cavour\n```", "```py\n        from osmgeocoder import OSMGeocoder\n        from osgeo import ogr, osr\n\n        # here we read the file\n        f = open('streets.txt')\n        streets = f.read().splitlines()\n        f.close()\n\n        # here we create the PostGIS layer using gdal/ogr\n        driver = ogr.GetDriverByName('PostgreSQL')\n        srs = osr.SpatialReference()\n        srs.ImportFromEPSG(4326)\n        pg_ds = ogr.Open(\n          \"PG:dbname='postgis_cookbook' host='localhost' port='5432' \n             user='me' password='mypassword'\", update = 1 )\n           pg_layer = pg_ds.CreateLayer('geocoded_points', srs = srs, \n                 geom_type=ogr.wkbPoint, options = [\n             'GEOMETRY_NAME=the_geom',\n             'OVERWRITE=YES', \n               # this will drop and recreate the table every time\n             'SCHEMA=chp08',\n          ])\n          # here we add the field to the PostGIS layer\n          fd_name = ogr.FieldDefn('name', ogr.OFTString)\n          pg_layer.CreateField(fd_name)\n          print 'Table created.'\n\n          # now we geocode all of the streets in the file \n          # using the osmgeocoder class\n          geocoder = OSMGeocoder('dbname=postgis_cookbook user=me \n                                  password=mypassword')\n          for street in streets:\n            print street\n            geocoded_street = geocoder.geocode(street)[0]\n            print geocoded_street\n            # format is\n            # ('Via delle Sette Chiese', 0.0,\n            #  'POINT(12.5002166330412 41.859774874774)')\n            point_wkt = geocoded_street[2]\n            point = ogr.CreateGeometryFromWkt(point_wkt)\n            # we create a LayerDefn for the feature using the \n            # one from the layer\n            featureDefn = pg_layer.GetLayerDefn()\n            feature = ogr.Feature(featureDefn)\n            # now we store the feature geometry and \n            # the value for the name field\n            feature.SetGeometry(point)\n            feature.SetField('name', geocoded_street[0])\n            # finally we create the feature \n            # (an INSERT command is issued only here) \n            pg_layer.CreateFeature(feature) \n```", "```py\n (postgis-cb-env)capooti@ubuntu:~/postgis_cookbook/working/chp08$  \n      python geocode_streets.py\n Table created.\n Via Delle Sette Chiese\n ('Via delle Sette Chiese', 0.0, \n       'POINT(12.5002166330412 41.859774874774)')\n ...\n Via Cavour \n      ('Via Cavour', 0.0, 'POINT(12.7519263341222 41.9631244835521)') \n```", "```py\n      $ sudo pip install geopy\n```", "```py\n      > pip install geopy\n```", "```py\n      $ sudo apt-get install postgresql-plpython-9.1\n```", "```py\n $ psql -U me postgis_cookbook\n psql (9.1.6, server 9.1.8)\n Type \"help\" for help. \n      postgis_cookbook=# CREATE EXTENSION plpythonu; \n```", "```py\n        CREATE OR REPLACE FUNCTION chp08.Geocode(address text)\n          RETURNS geometry(Point,4326) AS $$\n          from geopy import geocoders\n          g = geocoders.GoogleV3()\n          place, (lat, lng) = g.geocode(address)\n          plpy.info('Geocoded %s for the address: %s' % (place, address))\n          plpy.info('Longitude is %s, Latitude is %s.' % (lng, lat))\n          plpy.info(\"SELECT ST_GeomFromText('POINT(%s %s)', 4326)\" \n                    % (lng, lat))\n          result = plpy.execute(\"SELECT ST_GeomFromText('POINT(%s %s)',\n                                4326) AS point_geocoded\" % (lng, lat))\n          geometry = result[0][\"point_geocoded\"]\n          return geometry \n        $$ LANGUAGE plpythonu; \n```", "```py\n postgis_cookbook=# SELECT chp08.Geocode('Viale Ostiense 36, Rome');\n INFO:  Geocoded Via Ostiense, 36, 00154 Rome, \n      Italy for the address: Viale Ostiense 36, Rome\n CONTEXT:  PL/Python function \"geocode\"\n INFO:  Longitude is 12.480457, Latitude is 41.874345.\n CONTEXT:  PL/Python function \"geocode\"\n INFO:  SELECT ST_GeomFromText('POINT(12.480457 41.874345)', 4326)\n CONTEXT:  PL/Python function \"geocode\"\n geocode \n      ---------------------------------------------------- \n      0101000020E6100000BF44BC75FEF52840E7357689EAEF4440 \n      (1 row) \n```", "```py\n        CREATE OR REPLACE FUNCTION chp08.Geocode(address text,\n                                                 api text DEFAULT 'google')\n        RETURNS geometry(Point,4326) AS $$\n        from geopy import geocoders\n        plpy.info('Geocoing the given address using the %s api' % (api))\n        if api.lower() == 'geonames':\n          g = geocoders.GeoNames()\n        elif api.lower() == 'geocoderdotus':\n          g = geocoders.GeocoderDotUS()\n        else: # in all other cases, we use google\n          g = geocoders.GoogleV3()\n        try:\n          place, (lat, lng) = g.geocode(address)\n          plpy.info('Geocoded %s for the address: %s' % (place, address))\n           plpy.info('Longitude is %s, Latitude is %s.' % (lng, lat))\n          result = plpy.execute(\"SELECT ST_GeomFromText('POINT(%s %s)',\n                                4326) AS point_geocoded\" % (lng, lat))\n          geometry = result[0][\"point_geocoded\"]\n          return geometry\n        except:\n          plpy.warning('There was an error in the geocoding process,\n                        setting geometry to Null.')\n          return None \n        $$ LANGUAGE plpythonu; \n```", "```py\n postgis_cookbook=# SELECT chp08.Geocode('161 Court Street, \n                         Brooklyn, NY');\n INFO:  Geocoing the given address using the google api\n CONTEXT:  PL/Python function \"geocode2\"\n INFO:  Geocoded 161 Court Street, Brooklyn, NY 11201, \n             USA for the address: 161 Court Street, Brooklyn, NY\n CONTEXT:  PL/Python function \"geocode2\"\n INFO:  Longitude is -73.9924659, Latitude is 40.688665.\n CONTEXT:  PL/Python function \"geocode2\"\n INFO:  SELECT ST_GeomFromText('POINT(-73.9924659 40.688665)', 4326)\n CONTEXT:  PL/Python function \"geocode2\"\n geocode2\n ----------------------------------------------------\n 0101000020E61000004BB9B18F847F52C02E73BA2C26584440 \n      (1 row) \n```", "```py\n postgis_cookbook=# SELECT chp08.Geocode('161 Court Street, \n                         Brooklyn, NY', 'GeocoderDotUS');\n INFO:  Geocoing the given address using the GeocoderDotUS api\n CONTEXT:  PL/Python function \"geocode2\"\n INFO:  Geocoded 161 Court St, New York, NY 11201 for the address: 161 \n             Court Street, Brooklyn, NY\n CONTEXT:  PL/Python function \"geocode2\"\n INFO:  Longitude is -73.992809, Latitude is 40.688774.\n CONTEXT:  PL/Python function \"geocode2\"\n INFO:  SELECT ST_GeomFromText('POINT(-73.992809 40.688774)', 4326)\n CONTEXT:  PL/Python function \"geocode2\"\n geocode2\n ----------------------------------------------------\n 0101000020E61000002A8BC22E8A7F52C0E52A16BF29584440 \n      (1 row)\n```", "```py\n      $ source postgis-cb-env/bin/activate\n```", "```py\n      (postgis-cb-env)$ pip uninstall gdal\n      (postgis-cb-env)$ pip install numpy\n      (postgis-cb-env)$ pip install gdal\n```", "```py\n      $ gdalinfo NETCDF:\"soilw.mon.ltm.v2.nc\"\n```", "```py\n      $  gdalinfo NETCDF:\"soilw.mon.ltm.v2.nc\":soilw\n```", "```py\n      ...(12 bands)...\n```", "```py\n        import sys\n          from osgeo import gdal, ogr, osr\n          from osgeo.gdalconst import GA_ReadOnly, GA_Update\n\n        def netcdf2postgis(file_nc, pg_connection_string,\n                           postgis_table_prefix):\n          # register gdal drivers\n          gdal.AllRegister()\n          # postgis driver, needed to create the tables\n          driver = ogr.GetDriverByName('PostgreSQL')\n          srs = osr.SpatialReference()\n          # for simplicity we will assume all of the bands in the datasets\n          # are in the same spatial reference, wgs 84\n          srs.ImportFromEPSG(4326)\n\n          # first, check if dataset exists\n          ds = gdal.Open(file_nc, GA_ReadOnly)\n          if ds is None:\n            print 'Cannot open ' + file_nc\n            sys.exit(1)\n\n          # 1\\. iterate subdatasets\n          for sds in ds.GetSubDatasets():\n            dataset_name = sds[0]\n            variable = sds[0].split(':')[-1]\n            print 'Importing from %s the variable %s...' %\n                  (dataset_name, variable)\n            # open subdataset and read its properties\n            sds = gdal.Open(dataset_name, GA_ReadOnly)\n            cols = sds.RasterXSize\n            rows = sds.RasterYSize\n            bands = sds.RasterCount\n\n            # create a PostGIS table for the subdataset variable\n            table_name = '%s_%s' % (postgis_table_prefix, variable)\n            pg_ds = ogr.Open(pg_connection_string, GA_Update )\n            pg_layer = pg_ds.CreateLayer(table_name, srs = srs, \n            geom_type=ogr.wkbPoint, options = [\n              'GEOMETRY_NAME=the_geom',\n              'OVERWRITE=YES', \n                # this will drop and recreate the table every time\n              'SCHEMA=chp08',\n             ])\n            print 'Table %s created.' % table_name\n\n            # get georeference transformation information\n            transform = sds.GetGeoTransform()\n            pixelWidth = transform[1]\n            pixelHeight = transform[5]\n            xOrigin = transform[0] + (pixelWidth/2)\n            yOrigin = transform[3] - (pixelWidth/2)\n\n            # 2\\. iterate subdataset bands and append them to data\n            data = []\n            for b in range(1, bands+1):\n              band = sds.GetRasterBand(b)\n              band_data = band.ReadAsArray(0, 0, cols, rows)\n              data.append(band_data)\n              # here we add the fields to the table, a field for each band\n              # check datatype (Float32, 'Float64', ...)\n              datatype = gdal.GetDataTypeName(band.DataType)\n              ogr_ft = ogr.OFTString # default for a field is string\n              if datatype in ('Float32', 'Float64'):\n                ogr_ft = ogr.OFTReal\n              elif datatype in ('Int16', 'Int32'):\n                ogr_ft = ogr.OFTInteger\n              # here we add the field to the PostGIS layer\n              fd_band = ogr.FieldDefn('band_%s' % b, ogr_ft)\n              pg_layer.CreateField(fd_band)\n              print 'Field band_%s created.' % b\n\n            # 3\\. iterate rows and cols\n            for r in range(0, rows):\n              y = yOrigin + (r * pixelHeight)\n              for c in range(0, cols):\n                x = xOrigin + (c * pixelWidth)\n                # for each cell, let's add a point feature\n                # in the PostGIS table\n                point_wkt = 'POINT(%s %s)' % (x, y)\n                point = ogr.CreateGeometryFromWkt(point_wkt)\n                featureDefn = pg_layer.GetLayerDefn()\n                feature = ogr.Feature(featureDefn)\n                # now iterate bands, and add a value for each table's field\n                for b in range(1, bands+1):\n                  band = sds.GetRasterBand(1)\n                  datatype = gdal.GetDataTypeName(band.DataType)\n                  value = data[b-1][r,c]\n                  print 'Storing a value for variable %s in point x: %s, \n                   y: %s, band: %s, value: %s' % (variable, x, y, b, value)\n                  if datatype in ('Float32', 'Float64'):\n                    value = float(data[b-1][r,c])\n                  elif datatype in ('Int16', 'Int32'):\n                    value = int(data[b-1][r,c])\n                  else:\n                    value = data[r,c]\n                  feature.SetField('band_%s' % b, value)\n                # set the feature's geometry and finalize its creation\n                feature.SetGeometry(point) \n                pg_layer.CreateFeature(feature) \n```", "```py\n        if __name__ == '__main__':\n          # the user must provide at least three parameters, \n          # the netCDF file path, the PostGIS GDAL connection string \n          # and the prefix suffix to use for PostGIS table names\n          if len(sys.argv) < 4 or len(sys.argv) > 4:\n            print \"usage: <netCDF file path> <GDAL PostGIS connection \n                   string><PostGIS table prefix>\"\n            raise SystemExit\n          file_nc = sys.argv[1]\n          pg_connection_string = sys.argv[2]\n          postgis_table_prefix = sys.argv[3] \n          netcdf2postgis(file_nc, pg_connection_string,\n                         postgis_table_prefix) \n```", "```py\n (postgis-cb-env)$ python netcdf2postgis.py\n NETCDF:\"soilw.mon.ltm.v2.nc\"\n \"PG:dbname='postgis_cookbook' host='localhost'\n port='5432' user='me' password='mypassword'\" netcdf\n Importing from NETCDF:\"soilw.mon.ltm.v2.nc\":\n climatology_bounds the variable climatology_bounds...\n ...\n Importing from NETCDF:\"soilw.mon.ltm.v2.nc\":soilw the \n        variable soilw...\n Table netcdf_soilw created.\n Field band_1 created.\n Field band_2 created.\n ...\n Field band_11 created.\n Field band_12 created.\n Storing a value for variable soilw in point x: 0.25,\n y: 89.75, band: 2, value: -9.96921e+36\n Storing a value for variable soilw in point x: 0.25,\n y: 89.75, band: 3, value: -9.96921e+36 \n      ... \n```"]