- en: Chapter 5. Working with Basic Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章：处理基本对象
- en: In the previous chapters, you learned how to create several basic types of objects,
    including atomic vectors, lists, and data frames to store data. You learned how
    to create functions to store logic. Given these building blocks of R script, you
    learned about different types of expressions to control the flow of logic involving
    basic objects. Now, we are getting familiar with the basic grammar and syntax
    of the R programming language. It's time to build a vocabulary of R using built-in
    functions to work with basic objects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了如何创建几种基本类型的对象，包括原子向量、列表和数据框来存储数据。你学习了如何创建函数来存储逻辑。在了解了R脚本的这些构建块之后，你学习了不同类型的表达式来控制涉及基本对象逻辑流程。现在，我们正在熟悉R编程语言的基本语法和句法。是时候使用内置函数构建R的词汇表，以处理基本对象了。
- en: The real power of R lies in the enormous amount of functions it provides. Getting
    to know a variety of basic functions is extremely useful, and it will save you
    time and boost your productivity.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: R的真正力量在于它提供的巨大数量的函数。了解各种基本函数非常有用，这将节省你的时间并提高你的生产力。
- en: Although R is mainly a statistical computing environment, many basic functions
    are not related to any statistics but to more fundamental tasks such as inspecting
    the environment, converting texts to numbers, and performing logical operations.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然R主要是一个统计计算环境，但许多基本功能与任何统计无关，而是与更基础的任务相关，例如检查环境、将文本转换为数字以及执行逻辑运算。
- en: 'In this chapter, you will get to know a wide range of basic yet most useful
    functions in R, including:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解R中广泛的基本但非常有用的函数，包括：
- en: Object functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象函数
- en: Logical functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑函数
- en: Math functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数学函数
- en: Numeric methods
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数值方法
- en: Statistical functions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统计函数
- en: Apply-family functions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apply族函数
- en: Using object functions
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用对象函数
- en: In the previous chapter, you learned about some functions that work with the
    environment and packages. In this section, we will get to know some basic functions
    that deal with objects in general. More specifically, I will introduce you to
    more functions to access the type and dimensions of a data object. You will get
    an impression of how these concepts can be combined and how they work together.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了关于与环境和包一起工作的某些函数。在本节中，我们将了解一些处理对象的基本函数。更具体地说，我将向你介绍更多用于访问数据对象类型和大小的函数。你将了解这些概念如何结合以及它们是如何协同工作的。
- en: Testing object types
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试对象类型
- en: Although everything in R is an object, objects have different types.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然R中的所有内容都是一个对象，但对象有不同的类型。
- en: Suppose the object we are dealing with is user-defined. We will create a function
    that behaves in different ways according to the type of the input object. For
    example, we need to create a function named `take_it` that returns the first element
    if the input object as an atomic vector (for example, numeric vector, character
    vector, or logical vector), but returns a user-defined element if the input object
    is a list of data and index.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在处理的对象是用户定义的。我们将创建一个函数，该函数根据输入对象的类型以不同的方式表现。例如，我们需要创建一个名为`take_it`的函数，如果输入对象是一个原子向量（例如，数值向量、字符向量或逻辑向量），则返回第一个元素，但如果输入对象是一个包含数据和索引的列表，则返回用户定义的元素。
- en: For example, if the input is a numeric vector such as `c(1, 2, 3)`, then the
    function should return its first element `1`. If the input is a character vector
    such as `c("a", "b", "c")`, then the function should return `a`. However, if the
    input is a list `list(data = c("a", "b", "c"), index = 3)`, then the function
    should return the third element `(index = 3)` of `data`, that is, `c`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果输入是一个数值向量，如`c(1, 2, 3)`，则该函数应返回其第一个元素`1`。如果输入是一个字符向量，如`c("a", "b", "c")`，则该函数应返回`a`。然而，如果输入是一个列表`list(data
    = c("a", "b", "c"), index = 3)`，则该函数应返回`data`的第三个元素（索引=3），即`c`。
- en: 'To create such a function, we can imagine the functions and logic flow that
    might appear in it. First, as the output of the function depends on the type of
    input, we need to use one of the `is.*` functions to tell whether the input is
    of a certain type. Second, as the function behaves differently due to the type
    of input, we need to use conditional expressions such as `if else` to branch the
    logic. Finally, if the function basically takes out an element from the input,
    we need to use an element-extraction operator. Now, the implementation of the
    function becomes pretty clear:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这样的函数，我们可以想象其中可能出现的函数和逻辑流程。首先，由于函数的输出取决于输入类型，我们需要使用 `is.*` 中的一个函数来判断输入是否为特定类型。其次，由于函数的行为因输入类型而异，我们需要使用条件表达式如
    `if else` 来分支逻辑。最后，如果函数基本上是从输入中提取一个元素，我们需要使用元素提取运算符。现在，函数的实现变得相当清晰：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding function behaves differently as `x` takes different types. When `x`
    takes an atomic vector (for example, a numeric vector), the function extracts
    its first element. When `x` takes a list of `data` and `index`, the function extracts
    the element with the index of `index` from `x$data`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数的行为因 `x` 的不同类型而异。当 `x` 是一个原子向量（例如，一个数值向量）时，函数提取其第一个元素。当 `x` 是 `data` 和 `index`
    的列表时，函数从 `x$data` 中提取 `index` 的元素：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For unsupported input types, the function is supposed to stop with an error
    message rather than return any value. For example, `take_it` cannot handle the `function`
    input. Note that we can pass any function around to other functions as an argument,
    just like any other object. However, in this case, if `mean` as a function is
    passed to it, then it will turn to the `else` condition and stop:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不支持输入类型，函数应该停止并显示错误消息，而不是返回任何值。例如，`take_it` 无法处理 `function` 输入。请注意，我们可以将任何函数作为参数传递给其他函数，就像传递任何其他对象一样。然而，在这种情况下，如果将
    `mean` 作为函数传递给它，那么它将变成 `else` 条件并停止：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'What if the input is indeed a list but does not contain any of the expected
    elements, `data` and `index`? Just do an experiment with a list of `input` (instead
    of `data`), without any `index` element:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入确实是一个列表但不包含任何预期的元素，`data` 和 `index`，会怎样呢？只需对 `input`（而不是 `data`）的列表进行实验，没有任何
    `index` 元素：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It might surprise you that the function does not produce an error. The output
    is `NULL` because `x$data` is `NULL` and extracting any value from `NULL` is also `NULL`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会让你感到惊讶的是，函数没有产生错误。输出是 `NULL`，因为 `x$data` 是 `NULL`，并且从 `NULL` 中提取任何值也是 `NULL`：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'However, if the list only contains `data` but misses `index`, the function
    will end up in an error:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果列表只包含 `data` 但缺少 `index`，函数最终将导致错误：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The error occurs because `x$index` turns out to be `NULL`, and extracting value
    from a vector by `NULL` produces an error:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 错误发生是因为 `x$index` 结果为 `NULL`，并且通过 `NULL` 提取向量中的值会产生错误：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The third possibility is a bit similar to the first case in which `NULL[[2]]`
    returns `NULL`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种可能性与第一种情况有点相似，其中 `NULL[[2]]` 返回 `NULL`：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: From the earlier exceptions, it is normal to see that the error message is not
    so informative if you are not very familiar with these edge cases in which `NULL`
    is involved in the computation. For more complicated cases, if those errors do
    happen, you probably won't be able to find out the exact causes in a short period
    of time. One good solution is to check the input yourself in the implementation
    of the function and reflect the assumptions made to the arguments.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从早期的异常中，如果你不太熟悉涉及 `NULL` 的这些边缘情况，通常你会看到错误消息不是很具有信息性。对于更复杂的情况，如果确实发生了这些错误，你可能无法在短时间内找出确切的错误原因。一个很好的解决方案是在函数的实现中自己检查输入，并将所做的假设反映到参数上。
- en: 'To handle the preceding cases of misuse, the following implementation takes
    into account whether the type of each argument is desired:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理上述误用的情况，以下实现考虑了每个参数的类型是否所需：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For the case where `x` is a list, we check whether `x$data` is not null and
    is an atomic vector. If so, then we check if `x$index` is properly specified as
    a single-element numeric vector, or a scalar. If any of the conditions is violated,
    the function stops with an informative error message telling the user what is
    wrong with the input.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `x` 是列表的情况，我们检查 `x$data` 是否不为空且是一个原子向量。如果是这样，那么我们检查 `x$index` 是否被正确指定为一个单元素数值向量或一个标量。如果任何条件被违反，函数将停止并显示一个有信息的错误消息，告诉用户输入有什么问题。
- en: 'There are also quirky behaviors of the built-in checker functions. For example,
    `is.atomic(NULL)` returns `TRUE`. Therefore, if list `x` does not contain an element
    called `data`, the positive branch of `if (is.atomic(x$data))` can still be triggered,
    which also leads to `NULL`. With some argument checking, the code is now more
    robust and can produce more informative error messages when the assumptions are
    violated:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 内置检查函数也有一些古怪的行为。例如，`is.atomic(NULL)` 返回 `TRUE`。因此，如果列表 `x` 不包含名为 `data` 的元素，`if
    (is.atomic(x$data))` 的正分支仍然会被触发，这也会导致 `NULL`。通过一些参数检查，现在的代码更加健壮，当假设被违反时可以产生更详细的错误信息：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Another possible implementation of this function is using the S3 dispatch, which
    will be covered in a later chapter on object-oriented programming.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数的另一种可能的实现是使用 S3 分发，这将在后面的面向对象编程章节中讲解。
- en: Accessing object classes and types
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问对象类和类型
- en: Apart from using `is.*` functions, we can also use `class()` or `typeof()` to
    implement this function. Before directly accessing the type of an object, it is
    useful to know how these two functions differ from each other.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用 `is.*` 函数外，我们还可以使用 `class()` 或 `typeof()` 来实现此功能。在直接访问对象的类型之前，了解这两个函数之间的区别是有用的。
- en: The following examples demonstrate the difference between the output of `class()`
    and `typeof()` when they are called upon different types of objects.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了当 `class()` 和 `typeof()` 被调用在不同类型的对象上时，它们输出的区别。
- en: For each object `x`, `class()` and `typeof()` are called and then `str()` is
    called to show its structure.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个对象 `x`，会调用 `class()` 和 `typeof()`，然后调用 `str()` 来显示其结构。
- en: 'For a numeric vector:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数值向量：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For an integer vector:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于整数向量：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For a character vector:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于字符向量：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For a list:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于列表：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For a data frame:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据框：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can see that `typeof()` returns the low-level internal type of an object,
    while `class()` returns the high-level class of an object. One contrast we have
    mentioned before is that `data.frame` is in essence a `list` with equal-length
    list elements. Therefore, a data frame has the class of `data.frame` for data
    frame related functions to recognize, but `typeof()` still tells it is a `list`
    internally.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`typeof()` 返回对象的低级内部类型，而 `class()` 返回对象的高级类别。我们之前提到的一个对比是，`data.frame`
    本质上是一个具有等长列表元素的 `list`。因此，数据框具有 `data.frame` 类别，以便相关函数可以识别，但 `typeof()` 仍然从内部告知它是一个
    `list`。
- en: The topic is related to the S3 object-oriented programming mechanism and will
    be covered in detail in a later chapter. However, it is still useful to mention
    the difference between `class()` and `typeof()` here.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个主题与 S3 面向对象编程机制相关，将在后面的章节中详细讲解。然而，在这里提及 `class()` 和 `typeof()` 之间的区别仍然是有用的。
- en: From the preceding output, it is also clear that `str()`, which we introduced
    in the previous chapter, shows the structure of an object. For vectors in the
    object, it usually shows their internal type (`typeof()`).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，也可以清楚地看到 `str()`，我们在上一章中介绍过，显示了对象的结构。对于对象中的向量，它通常显示它们的内部类型（`typeof()`）。
- en: Accessing data dimensions
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问数据维度
- en: Matrices, arrays, and data frames have the property of dimensions in addition
    to classes and types.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵、数组和数据框除了具有类和类型外，还具有维度的属性。
- en: Getting data dimensions
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取数据维度
- en: 'In R, a vector is by construction a one-dimensional data structure:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中，向量是按构造为一维数据结构：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The same underlying data can be represented with more dimensions, which can
    be accessed via `dim()`, `nrow()`, or `ncol()`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的底层数据可以用更多的维度来表示，这些维度可以通过 `dim()`、`nrow()` 或 `ncol()` 访问：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first preceding expression creates a four-column matrix from numeric vector
    `vec`. The matrix has the class of `matrix`, while `typoef()` preserves `double`
    from `vec`. Since a matrix is a dimensional data structure, `dim()` shows its
    dimensions in vector form. The `nrow()` and `ncol()` functions are shortcuts to
    access its number of rows and columns. If you read the source code of these two
    shortcuts, you will find that they are nothing special, but they return the first
    and second elements of `dim()` of the same input, respectively.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个前置表达式从数值向量 `vec` 创建了一个四列矩阵。该矩阵具有 `matrix` 类别，而 `typoef()` 保留了 `vec` 中的 `double`。由于矩阵是一个维度的数据结构，`dim()`
    以向量形式显示其维度。`nrow()` 和 `ncol()` 函数是访问其行数和列数的快捷方式。如果你阅读这两个快捷方式的源代码，你会发现它们并没有什么特别之处，但它们分别返回相同输入的
    `dim()` 的第一和第二个元素。
- en: 'Higher dimensional data is usually represented by an array. For example, the
    same data `vec` can also be represented in three dimensions, that is, to access
    one element, you need to specify three positions in the three dimensions in turn:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 高维数据通常用数组表示。例如，相同的 `vec` 数据也可以在三个维度上表示，即要访问一个元素，需要依次指定三个维度中的位置：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Similar to `matrix`, an array has a class of `array` but still preserves the
    type of the underlying data. The length of the output of `dim()` is the number
    of dimensions needed to represent the data.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `matrix` 类似，数组有一个 `array` 类，但仍然保留了底层数据的类型。`dim()` 的输出长度是表示数据所需的维度数。
- en: 'Another data structure that has a notion of dimensions is a data frame. However,
    a data frame is fundamentally different from a matrix. A matrix is derived from
    a vector but adds a dimensional property. On the other hand, a data frame is derived
    from a list but adds a constraint that each list element must have the same length:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个具有维度概念的数据结构是数据框。然而，数据框与矩阵在本质上是有区别的。矩阵是从向量派生出来的，但增加了维度属性。另一方面，数据框是从列表派生出来的，但增加了每个列表元素必须具有相同长度的约束：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: However, `dim()`, `nrow()`, and `ncol()` are still useful for data frames.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`dim()`、`nrow()` 和 `ncol()` 对于数据框仍然很有用。
- en: Reshaping data structures
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新塑形数据结构
- en: The syntax of `dim(x) <- y` means change the value of dimensions of `x` to `y`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`dim(x) <- y` 的语法表示将 `x` 的维度值更改为 `y`。'
- en: 'For a plain vector, the expression converts the vector to a matrix with the
    specified dimensions:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个普通向量，该表达式将向量转换为具有指定维度的矩阵：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can see that the class of the object changes from `numeric` to `matrix`,
    and the type of the object remains unchanged.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，对象的类从 `numeric` 变为 `matrix`，而对象的类型保持不变。
- en: 'For a matrix, the expression reshapes the matrix:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于矩阵，该表达式会重新塑形矩阵：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It is useful to understand that changing the dimension of a vector, matrix,
    or array only alters the representation and accessing methods of the object and
    does not change the underlying data stored in memory. Therefore, it should be
    no surprise that a matrix is reshaped to an array as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有助于理解的是，改变向量、矩阵或数组的维度只会改变对象的表示和访问方法，而不会改变存储在内存中的底层数据。因此，矩阵被重塑为以下数组的情况并不令人惊讶：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'It should be obvious that `dim(x) <- y` works only if `prod(y)` equals `length(x)`,
    that is, the product of all dimensions must be equal to the length of the data
    elements. Otherwise, an error will occur:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`dim(x) <- y` 仅在 `prod(y)` 等于 `length(x)` 时才有效，也就是说，所有维度的乘积必须等于数据元素的长度。否则，将发生错误：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Iterating over one dimension
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历一个维度
- en: 'A data frame is often a collection of records, and each row represents a record.
    It is common to iterate over all records stored in a data frame. Let''s look at
    the following data frame:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框通常是一组记录的集合，每一行代表一条记录。遍历数据框中存储的所有记录是很常见的。让我们看看以下数据框：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For this data frame, we can iterate over the rows by printing the values of
    the variables using a `for` loop over `1:nrow(x)`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个数据框，我们可以通过使用 `for` 循环遍历 `1:nrow(x)` 来打印变量的值：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Using logical functions
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用逻辑函数
- en: A logical vector only takes `TRUE` or `FALSE` and is mostly used to filter data.
    In practice, it is common to create joint conditions by multiple logical vectors
    where a number of logical operators and functions may involve.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑向量只接受 `TRUE` 或 `FALSE`，主要用于过滤数据。在实践中，通常通过多个逻辑向量创建联合条件，其中可能涉及多个逻辑运算符和函数。
- en: Logical operators
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: 'Like many other programming languages, R enables a few operators to do basic
    logical calculations. The following table demonstrates what they do:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他编程语言一样，R 允许使用一些运算符进行基本的逻辑计算。以下表格展示了它们的功能：
- en: '| **Symbol** | **Description** | **Example** | **Result** |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **描述** | **示例** | **结果** |'
- en: '| `&` | Vectorized AND | `c(T, T) & c(T, F)` | `c(TRUE, FALSE)` |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `&` | 向量化 AND | `c(T, T) & c(T, F)` | `c(TRUE, FALSE)` |'
- en: '| `&#124;` | Vectorized OR | `c(T, T) &#124; c(T, F)` | `c(TRUE, TRUE)` |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `|` | 向量化 OR | `c(T, T) | c(T, F)` | `c(TRUE, TRUE)` |'
- en: '| `&&` | Univariate AND | `c(T, T) && c(F, T)` | `FALSE` |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `&&` | 单变量 AND | `c(T, T) && c(F, T)` | `FALSE` |'
- en: '| `&#124;&#124;` | Univariate OR | `c(T, T) &#124;&#124; c(F, T)` | `TRUE`
    |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `||` | 单变量 OR | `c(T, T) || c(F, T)` | `TRUE` |'
- en: '| `!` | Vectorized NOT | `!c(T, F)` | `c(FALSE, TRUE)` |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `!` | 向量化 NOT | `!c(T, F)` | `c(FALSE, TRUE)` |'
- en: '| `%in%` | Vectorized IN | c`(1, 2) %in% c(1, 3, 4, 5)` | `c(TRUE, FALSE)`
    |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `%in%` | 向量化 IN | `c(1, 2) %in% c(1, 3, 4, 5)` | `c(TRUE, FALSE)` |'
- en: Note that in an `if` expression, `&&` and `||` are often used to perform logical
    calculations that are only needed to yield a single-element logical vector. However,
    the potential risk of using `&&` is that if it is made to work with multi-element
    vectors, it will silently ignore all but the first element of the vectors on both
    sides. The following example demonstrates the difference in behavior of using
    either `&&` or `&` in conditional statements.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`if`表达式中，`&&`和`||`通常用于执行仅需要产生单个元素逻辑向量的逻辑计算。然而，使用`&&`的潜在风险是，如果它被用来与多元素向量一起工作，它将默默地忽略两侧向量中除了第一个元素之外的所有元素。以下示例演示了在条件语句中使用`&&`或`&`时的行为差异。
- en: 'The following code creates a `test_direction` function that tells the monotonicity
    of supplied argument values. We''ll build on this example through the next section.
    If the values of `x`, `y`, and `z` are monotonically increasing, the function
    returns `1`; if they are monotonically decreasing, the function returns `-1`.
    Otherwise, it returns `0`. Note that the function uses `&` to perform a vectorized
    AND operation:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建了一个`test_direction`函数，用于判断提供的参数值的单调性。我们将在下一节中基于此示例进行构建。如果`x`、`y`和`z`的值单调递增，则函数返回`1`；如果它们单调递减，则函数返回`-1`。否则，它返回`0`。请注意，该函数使用`&`执行向量化的AND操作：
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If the arguments are supplied scalar numbers, the function works perfectly:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供的参数是标量数字，该函数将完美运行：
- en: '[PRE26]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Note that `&` performs a vectorized calculation and thus returns a multi-element
    vector if one argument has more than one element. However, `if` only works with
    a single-value logical vector; otherwise, it would produce a warning:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`&`执行向量化计算，因此如果其中一个参数有多个元素，则返回多元素向量。然而，`if`只与单个值的逻辑向量一起工作；否则，它会产生警告：
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If we replace both `&` operators present in `test_direction2` with `&&` and
    create a new function `test_direction2`, the function would look as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`test_direction2`中出现的两个`&`运算符都替换为`&&`并创建一个新的函数`test_direction2`，该函数将如下所示：
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, the two example test cases may have different behaviors. For scalar input,
    the behavior of the two versions are exactly the same:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这两个示例测试用例可能会有不同的行为。对于标量输入，两个版本的行为完全相同：
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'However, for multi-element input, `test_direction2` silently ignores the second
    element of each input vector and thus does not produce any warnings:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于多元素输入，`test_direction2`会默默地忽略每个输入向量的第二个元素，因此不会产生任何警告：
- en: '[PRE30]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Finally, which is the correct use, `&` or `&&`? It all depends on your demand.
    What behavior do you expect under all circumstances? What do you expect if the
    input is scalar values or multi-element vectors? If you expect the function to
    tell you whether all elements in the same position of each input vector have monotonicity,
    then both uses are incorrect in part and require the use of logical aggregation
    functions, to be introduced in the next section.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，哪种用法是正确的，`&`还是`&&`？这完全取决于你的需求。你期望在所有情况下有什么行为？如果输入是标量值或多元素向量，你期望什么？如果你期望函数告诉你每个输入向量中相同位置的元素是否具有单调性，那么这两种用法在部分情况下都是不正确的，需要使用将在下一节中介绍的逻辑聚合函数。
- en: Logical functions
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑函数
- en: In this section, we will look at aggregating logical vectors and finding the
    true elements.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看聚合逻辑向量和查找真元素。
- en: Aggregating logical vectors
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 聚合逻辑向量
- en: In addition to the binary logical operators, a few logical aggregation functions
    are very useful, as we mentioned earlier.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，除了二元逻辑运算符之外，还有一些逻辑聚合函数非常有用，正如我们之前提到的。
- en: 'The most commonly used two logical aggregation functions are `any()` and `all()`.
    The `any()` function returns `TRUE` if any (for example, at least one) element
    of the given logical vector is `TRUE`; otherwise, it will return `FALSE`. The `all()`
    function returns `TRUE` if all elements of the given logical vector are `TRUE`;
    otherwise, it will return `FALSE`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的两个逻辑聚合函数是`any()`和`all()`。`any()`函数如果给定逻辑向量中的任何（例如，至少一个）元素为`TRUE`，则返回`TRUE`；否则，它将返回`FALSE`。`all()`函数如果给定逻辑向量中的所有元素都是`TRUE`，则返回`TRUE`；否则，它将返回`FALSE`：
- en: '[PRE31]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'One common point of the two functions is that they only return a single `TRUE`
    or `FALSE` value and never return a multi-element logical vector. Therefore, to
    implement a function that meets the demand in the previous section, use `all()`
    and `&` together in the `if` conditions:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数的一个共同点是，它们只返回一个`TRUE`或`FALSE`值，永远不会返回多元素逻辑向量。因此，为了实现上一节中所需的功能，请在`if`条件中使用`all()`和`&`一起：
- en: '[PRE32]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'For scalar input, `test_all_direction()` behaves exactly the same with the `test_direction()`
    and `test_direction2()` functions:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于标量输入，`test_all_direction()` 与 `test_direction()` 和 `test_direction2()` 函数的行为完全相同：
- en: '[PRE33]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'For vector input, the function tests whether `c(1, 2, 3)` and `c(2, 3, 4)`
    have (the same) monotonicity:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于向量输入，该函数测试 `c(1, 2, 3)` 和 `c(2, 3, 4)` 是否具有（相同的）单调性：
- en: '[PRE34]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following code is a counterexample in which the elements at position `2`,
    that is, `c(2, 4, 4)`, have no monotonicity:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一个反例，其中位置 `2` 的元素，即 `c(2, 4, 4)`，没有单调性：
- en: '[PRE35]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The value returned by the function is thus meaningful because it correctly implements
    the demand of testing whether all elements at each position in the three input
    vectors have monotonicity.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 函数返回的值因此是有意义的，因为它正确实现了测试三个输入向量中每个位置的所有元素是否具有单调性的需求。
- en: 'The function has several possible variations that instead uses `any()` or `&&`.
    You may try to figure out the underlying demand (what are these functions trying
    to do?) of each of the following versions:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数有几种可能的变体，它们使用 `any()` 或 `&&`。你可以尝试弄清楚每个以下版本的潜在需求（这些函数试图做什么？）：
- en: '[PRE36]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Asking which elements are TRUE
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询哪些元素是 `TRUE`
- en: 'The logical operations we introduced earlier usually return a logical vector
    to indicate whether a certain condition is `TRUE` or `FALSE`. It is also useful
    to know which elements satisfy those conditions. The `which()` function returns
    the positions (or indices) of `TRUE` elements in a logical vector:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前介绍的逻辑运算通常返回一个逻辑向量，以指示某个条件是否为 `TRUE` 或 `FALSE`。了解哪些元素满足这些条件也是有用的。`which()`
    函数返回逻辑向量中 `TRUE` 元素的位置（或索引）：
- en: '[PRE37]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If we take a closer look at what happens, it should be clear that at first,
    `abs(x) >= 1.5` is evaluated to be a logical vector, and then, `which()` returns
    the positions of those `TRUE` elements in that logical vector.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细观察发生了什么，应该很清楚，首先，`abs(x) >= 1.5` 被评估为一个逻辑向量，然后，`which()` 返回该逻辑向量中 `TRUE`
    元素的位置。
- en: 'The mechanism is quite similar when we use a logical condition to filter elements
    from a vector or list:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用逻辑条件从向量或列表中过滤元素时，机制相当类似：
- en: '[PRE38]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the preceding example, `x >= 1.5` is evaluated to be a logical vector. Then,
    it is used to select elements in `x` corresponding to `TRUE` values.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`x >= 1.5` 被评估为一个逻辑向量。然后，它被用来选择 `x` 中对应于 `TRUE` 值的元素。
- en: 'A special case is that we can even use a logical vector with all `FALsE` values.
    A zero-length numeric vector is returned since the logical vector only contains `FALSE`
    values, and thus, no element in `x` is singled out:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特殊情况是，我们甚至可以使用所有值为 `FALSE` 的逻辑向量。返回一个零长度的数值向量，因为逻辑向量只包含 `FALSE` 值，因此 `x` 中没有元素被单独选中：
- en: '[PRE39]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Dealing with missing values
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理缺失值
- en: 'Real-world data often contains missing values represented by `NA`. The following
    numeric vector is a simple example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 实际数据通常包含用 `NA` 表示的缺失值。以下是一个简单的数值向量示例：
- en: '[PRE40]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Arithmetic calculations with missing values also produce missing values:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用缺失值的算术计算也会产生缺失值：
- en: '[PRE41]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To take this into account, a logical vector has to accept not only `TRUE` and `FALSE`
    values but also `NA` values to represent unknown truthfulness:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了考虑这一点，逻辑向量必须接受不仅 `TRUE` 和 `FALSE` 值，还要接受 `NA` 值来表示未知真实性：
- en: '[PRE42]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'As a consequence, logical aggregation functions such as `any()` and `all()`
    have to deal with missing values too:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，像 `any()` 和 `all()` 这样的逻辑聚合函数也必须处理缺失值：
- en: '[PRE43]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The preceding output demonstrates the default behavior of `any()` when it deals
    with a logical vector that contains missing values. More specifically, if any
    element in the input vector is `TRUE`, then the function will return `TRUE`. If
    no element in the input vector is `TRUE` in which any missing value is present,
    then the function will return `NA`. Otherwise, if the input vector contains only `FALSE`,
    then the function will return `FALSE`. To verify the preceding logic, just run
    the following code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出展示了 `any()` 在处理包含缺失值的逻辑向量时的默认行为。更具体地说，如果输入向量中的任何元素是 `TRUE`，则该函数将返回 `TRUE`。如果输入向量中没有
    `TRUE` 元素且存在任何缺失值，则该函数将返回 `NA`。否则，如果输入向量只包含 `FALSE`，则该函数将返回 `FALSE`。要验证前面的逻辑，只需运行以下代码：
- en: '[PRE44]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To directly ignore all missing values, just specify `na.rm = TRUE` in the call:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要直接忽略所有缺失值，只需在调用中指定 `na.rm = TRUE`：
- en: '[PRE45]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'A similar but somehow opposite logic applies to `all()`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `all()`，类似的但某种程度上相反的逻辑适用：
- en: '[PRE46]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If any element in the input vector is `FALSE`, then the function will return `FALSE`.
    If no element in the input vector is `FALSE` in which any missing value is present,
    then the function will return `NA`. Otherwise, if the input vector contains only `TRUE`,
    then it will return `TRUE`. To verify the logic, just run the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入向量中的任何元素为`FALSE`，则该函数将返回`FALSE`。如果输入向量中没有`FALSE`元素，但存在任何缺失值，则该函数将返回`NA`。否则，如果输入向量只包含`TRUE`，则它将返回`TRUE`。为了验证逻辑，只需运行以下代码：
- en: '[PRE47]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Similarly, `na.rm = TRUE` forces the function to directly ignore all missing
    values:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`na.rm = TRUE`强制函数直接忽略所有缺失值：
- en: '[PRE48]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Apart from logical aggregation functions, data filtering also behaves differently
    when missing values involve. For example, the following code will preserve the
    missing values at corresponding positions of the logical vector produced by `x
    >= 0`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 除了逻辑聚合函数外，当涉及缺失值时，数据过滤的行为也会有所不同。例如，以下代码将保留由`x >= 0`产生的逻辑向量中相应位置的缺失值：
- en: '[PRE49]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'By contrast, `which()` does not preserve the missing values present in the
    input logical vector:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`which()`不会保留输入逻辑向量中存在的缺失值：
- en: '[PRE50]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Therefore, the vector subsetted by the indices does not contain missing values
    in the following case:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在以下情况下，通过索引子集的向量不包含缺失值：
- en: '[PRE51]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Logical coercion
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑强制转换
- en: Some functions that are supposed to take logical input also accept non-logical
    vectors such as numeric vectors. However, the behavior of the function may not
    be different from what they do with logical vectors. This is because the non-logical
    vectors are coerced to logical values.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一些应该接受逻辑输入的函数也接受非逻辑向量，例如数值向量。然而，函数的行为可能与它们与逻辑向量处理的行为不同。这是因为非逻辑向量被强制转换为逻辑值。
- en: 'For example, if we put a numeric vector in the `if` condition, it will be coerced:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们把一个数值向量放入`if`条件中，它将被强制转换：
- en: '[PRE52]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In R, all non-zero values in a numeric vector or integer vector can be coerced
    to `TRUE`, only zero values will be coerced to `FALSE`, and string values cannot
    be coerced to logical values:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在R中，数值向量或整数向量中的所有非零值都可以被强制转换为`TRUE`，只有零值会被强制转换为`FALSE`，字符串值不能被强制转换为逻辑值：
- en: '[PRE53]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Using math functions
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数学函数
- en: Mathematical functions are an essential part in all computing environments.
    R provides several groups of basic math functions.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 数学函数是所有计算环境中的基本组成部分。R提供了几组基本数学函数。
- en: Basic functions
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本函数
- en: 'The basic functions include square root, and exponential and logarithm functions
    as the following table shows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 基本函数包括平方根、指数和对数函数，如下表所示：
- en: '![Basic functions](img/B05263_05_07.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![基本函数](img/B05263_05_07.jpg)'
- en: 'Note that `sqrt()` only works with real numbers. If a negative number is supplied, `NaN`
    will be produced:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`sqrt()`只适用于实数。如果提供负数，将产生`NaN`：
- en: '[PRE54]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In R, numeric values can be finite, infinite (`Inf` and `-Inf`), and `NaN` values.
    The following code will produce infinite values.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在R中，数值可以是有限的、无限的（`Inf`和`-Inf`）或`NaN`值。以下代码将产生无限值。
- en: 'First, produce a positively infinite value:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，产生一个正无穷值：
- en: '[PRE55]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then, produce a negatively infinite value:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，产生一个负无穷值：
- en: '[PRE56]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'There are several test functions to check whether a numeric value is finite,
    infinite, or `NaN`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个测试函数可以检查一个数值是否有限、无限或`NaN`：
- en: '[PRE57]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Using `is.infinite()`, how can we check whether a numeric value is `-Inf`?
    Inequality still works with infinite values in R:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`is.infinite()`，我们如何检查一个数值是否为`-Inf`？在R中，不等式仍然适用于无限值：
- en: '[PRE58]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Therefore, we can test the number with `is.infinite()` and compare the elements
    to 0 at the same time:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以使用`is.infinite()`测试数字，并同时比较元素与0：
- en: '[PRE59]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Like `sqrt()`, if the input value goes beyond the domain of `log` function,
    that is, `x > 0`, then the function returns `NaN` with a warning:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 与`sqrt()`类似，如果输入值超出了`log`函数的定义域，即`x > 0`，则该函数将返回带有警告的`NaN`：
- en: '[PRE60]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Number rounding functions
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字舍入函数
- en: 'The following functions are used to round numbers in different ways:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数用于以不同方式舍入数字：
- en: '| **Symbol** | **Example** | **Value** |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **示例** | **值** |'
- en: '| [x] log | `ceiling(10.6)` | 11 |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| [x] log | `ceiling(10.6)` | 11 |'
- en: '| [x] log | `floor(9.5)` | 9 |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| [x] log | `floor(9.5)` | 9 |'
- en: '| truncate | `trunc(1.5)` | 1 |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| truncate | `trunc(1.5)` | 1 |'
- en: '| round | `round(pi,3)` | 3.142 |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| round | `round(pi,3)` | 3.142 |'
- en: '| significant numbers | `signif(pi, 3)` | 3.14 |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 有效数字 | `signif(pi, 3)` | 3.14 |'
- en: Previously, we showed that using `options(digits =)` can modify the number of
    digits to display, but this does not change the actual number of digits to remember.
    The preceding functions round the numbers and may cause potential loss of information.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们展示了使用 `options(digits =)` 可以修改显示的数字位数，但这不会改变实际要记住的数字位数。前面的函数会四舍五入数字，可能会造成潜在的信息丢失。
- en: For example, if the input number `1.50021` is already precise, then rounding
    it to `1` digit will result in `1.5` and the other digits (information) are lost.
    Therefore, you should make sure if the digits to drop are indeed ignorable due
    to imprecision or noise before performing any rounding.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果输入数字 `1.50021` 已经很精确，那么将其四舍五入到 `1` 位将得到 `1.5`，而其他数字（信息）则丢失。因此，在执行任何四舍五入之前，你应该确保要丢弃的数字确实因为不精确或噪声而可以忽略。
- en: Trigonometric functions
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 三角函数
- en: 'The following table lists the most commonly used trigonometric functions:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了最常用的三角函数：
- en: '| **Symbol** | **Example** | **Value** |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **示例** | **值** |'
- en: '| `sin (x)` | `sin(0)` | 0 |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `sin (x)` | `sin(0)` | 0 |'
- en: '| `cos (x)` | `cos(0)` | 1 |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `cos (x)` | `cos(0)` | 1 |'
- en: '| `tan (x)` | `tan(0)` | 0 |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `tan (x)` | `tan(0)` | 0 |'
- en: '| `arcsin (x)` | `asin(1)` | 1.5707963 |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `arcsin (x)` | `asin(1)` | 1.5707963 |'
- en: '| `arcos (x)` | `acos(1)` | 0 |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `arco (x)` | `acos(1)` | 0 |'
- en: '| `arctan (x)` | `atan(1)` | 0.7853982 |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `arctan (x)` | `atan(1)` | 0.7853982 |'
- en: 'R also provides a numeric version of `π`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: R 还提供了 `π` 的数值版本：
- en: '[PRE61]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In maths, equation *sin (π) = 0 *strictly holds. However, the same formula
    does not lead to 0 in R or any other typical numeric computing software due to
    some precision issues of floating numbers:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，方程 *sin (π) = 0* 严格成立。然而，由于浮点数的某些精度问题，相同的公式在 R 或任何其他典型的数值计算软件中不会导致 0：
- en: '[PRE62]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: To compare numbers with near equality, use `all.equal()` instead. While `sin(pi)
    == 0` returns `FALSE`, `all.equal(sin(pi), 0)` returns `TRUE` with the default
    tolerance of `1.5e-8`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要比较近似相等的数字，请使用 `all.equal()`。虽然 `sin(pi) == 0` 返回 `FALSE`，但 `all.equal(sin(pi),
    0)` 在默认容差 `1.5e-8` 下返回 `TRUE`。
- en: 'Another three functions are provided to make it precise when the input is a
    multiple of `π`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了另外三个函数，以便在输入是 `π` 的倍数时进行精确计算：
- en: '| **Symbol** | **Example** | **Value** |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **示例** | **值** |'
- en: '| `sin (πx)` | `sinpi(1)` | 0 |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `sin (πx)` | `sinpi(1)` | 0 |'
- en: '| `cos (πx)` | `cospi(0)` | 1 |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `cos (πx)` | `cospi(0)` | 1 |'
- en: '| `tan (πx)` | `tanpi(1)` | 0 |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `tan (πx)` | `tanpi(1)` | 0 |'
- en: Hyperbolic functions
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 双曲函数
- en: 'Similar to other computing software, hyperbolic functions are provided as shown
    in the following table:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他计算软件类似，双曲函数提供如下表所示：
- en: '| **Symbol** | **Example** | **Value** |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **示例** | **值** |'
- en: '| `sinh (x)` | `sinh(1)` | 1.1752012 |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `sinh (x)` | `sinh(1)` | 1.1752012 |'
- en: '| `cosh (x)` | `cosh(1)` | 1.5430806 |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| `cosh (x)` | `cosh(1)` | 1.5430806 |'
- en: '| `tanh (x)` | `tanh(1)` | 0.7615942 |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| `tanh (x)` | `tanh(1)` | 0.7615942 |'
- en: '| `arcsinh (x)` | `asinh(1)` | 0.8813736 |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| `arcsinh (x)` | `asinh(1)` | 0.8813736 |'
- en: '| `arccosh (x)` | `acosh(1)` | 0 |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| `arccosh (x)` | `acosh(1)` | 0 |'
- en: '| `arctanh (x)` | `atanh(0)` | 0 |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| `arctanh (x)` | `atanh(0)` | 0 |'
- en: Extreme functions
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 极端函数
- en: 'It is common to calculate the maximum or minimum values of some numbers. The
    following table lists and demonstrates the simple use of `max()` and `min()`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 计算某些数字的最大值或最小值是很常见的。以下表格列出了 `max()` 和 `min()` 的简单用法：
- en: '| **Symbol** | **Example** | **Value** |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **示例** | **值** |'
- en: '| `max(...)` | `max(1, 2, 3)` | 3 |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `max(...)` | `max(1, 2, 3)` | 3 |'
- en: '| `min(...)` | `min(1, 2, 3)` | 1 |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `min(...)` | `min(1, 2, 3)` | 1 |'
- en: 'These two functions work not only with multiple scalar arguments but also with
    a vector input:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数不仅支持多个标量参数，还支持向量输入：
- en: '[PRE63]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Also, they work with multiple vector input:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它们还支持多个向量输入：
- en: '[PRE64]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The output demonstrates that `max()` returns the maximal value among all values
    of all input vectors and `min()` returns vice versa.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 输出表明 `max()` 返回所有输入向量的所有值中的最大值，而 `min()` 返回相反的值。
- en: 'What if we want to obtain maximal or minimal values of each position among
    all vectors? Look at the following lines of code:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要获得所有向量中每个位置的最大值或最小值呢？看看下面的代码行：
- en: '[PRE65]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This basically finds the maximal value among all numbers at position 1, then
    at position 2, and so on, which has the same output as the following code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是在位置 1 的所有数字中找到最大值，然后在位置 2，依此类推，其输出与以下代码相同：
- en: '[PRE66]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This is called the **parallel maxima**. The twin function `pmin()` works to
    find the **parallel minima**:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为**并行最大值**。双胞胎函数 `pmin()` 用于找到**并行最小值**：
- en: '[PRE67]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: These two functions can be very useful to quickly compose a vectorized function
    with specific functions as floor and/or ceiling. For example, suppose `spread()`
    is a piecewise function. If the input is less than `-5`, the value is `-5`. If
    the input is between `-5` to `5`, the value is input. If the input is greater
    than `5`, then the value is `5`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数可以非常有用，可以快速组合具有特定函数（如 floor 和/或 ceiling）的向量化函数。例如，假设 `spread()` 是一个分段函数。如果输入小于
    `-5`，则值为 `-5`。如果输入在 `-5` 到 `5` 之间，则值为输入。如果输入大于 `5`，则值为 `5`。
- en: 'A naive implementation uses `if` to branch the pieces:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简单的实现是使用 `if` 来分支片段：
- en: '[PRE68]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The function works with scalar input, but it is not automatically vectorized:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数与标量输入一起工作，但它不会自动向量化：
- en: '[PRE69]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'One method is to use `pmin()` and `pmax()`, and the function will be automatically
    vectorized:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是使用 `pmin()` 和 `pmax()`，函数将自动向量化：
- en: '[PRE70]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Another method is to use `ifelse()`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用 `ifelse()`：
- en: '[PRE71]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The previous two functions, `spread2()` and `spread3()`, both have the same
    graphics:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个函数 `spread2()` 和 `spread3()` 都有相同的图形：
- en: '![Extreme functions](img/image_05_048.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![极值函数](img/image_05_048.jpg)'
- en: Applying numeric methods
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用数值方法
- en: In the previous sections, you learned about a number of functions that range
    from inspecting data structures to math and logical operations. These functions
    are fundamental to solving problems such as root finding and doing calculus. As
    a computing environment, R already implements various tools of good performance
    so that users do not have to reinvent the wheel. In the following sections, you
    will learn the built-in functions designed for root finding and calculus.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了关于从检查数据结构到数学和逻辑运算的许多函数。这些函数对于解决诸如根查找和微积分等问题是基本的。作为一个计算环境，R 已经实现了各种高性能工具，以便用户不必重新发明轮子。在接下来的章节中，你将学习为根查找和微积分设计的内置函数。
- en: Root finding
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 根查找
- en: 'Root finding is a commonly encountered task. Suppose we want to find the roots
    of the following equation:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 根查找是一个常见任务。假设我们想找到以下方程的根：
- en: '*x2 + x - 2= 0*'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '*x2 + x - 2= 0*'
- en: 'To manually find the roots, we can transform the preceding equation in product
    terms:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 要手动查找根，我们可以将前面的方程转换为乘积形式：
- en: '*(x+2)(x-1)= 0*'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '*(x+2)(x-1)= 0*'
- en: Therefore, the roots of the equation are *x1= -2* and *x[2]= 1*.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，方程的根是 *x1= -2* 和 *x[2]= 1*。
- en: 'In R, `polyroot()` can find roots of a polynomial equation in the form of:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中，`polyroot()` 可以找到以下形式的多项式方程的根：
- en: '![Root finding](img/image_05_056.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![根查找](img/image_05_056.jpg)'
- en: 'For the preceding problem, we need to specify the polynomial coefficient vector
    from zero order to the term of the highest order present in the equation. In this
    case, the vector is `c(-2, 1, 1)` to represent the coefficients in the increasing
    order of power:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前面的问题，我们需要指定从零次项到方程中出现的最高次项的系数向量。在这种情况下，向量是 `c(-2, 1, 1)`，以表示按幂次增加的系数：
- en: '[PRE72]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The function always returns a complex vector in which each element is a complex
    number in the form of `a + bi`. On the one hand, if the function surely has only
    real roots, you can use `Re()` to extract the real parts of the complex roots:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数总是返回一个复数向量，其中每个元素都是形式为 `a + bi` 的复数。一方面，如果函数确实只有实根，你可以使用 `Re()` 提取复根的实部：
- en: '[PRE73]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'On the other hand, the type of output implies that `polyroot()` has the capability
    to find complex roots of a polynomial equation. The simplest one is as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，输出类型表明 `polyroot()` 有能力找到多项式方程的复根。最简单的一个如下：
- en: '![Root finding](img/image_05_058.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![根查找](img/image_05_058.jpg)'
- en: 'To find its complex roots, just specify a polynomial coefficient vector:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到其复根，只需指定一个多项式系数向量：
- en: '[PRE74]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'A slightly more complex example is to find the roots of the following equation:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 一个稍微复杂一点的例子是找到以下方程的根：
- en: '![Root finding](img/image_05_060.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![根查找](img/image_05_060.jpg)'
- en: '[PRE75]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Note that all complex roots are found. To verify, just replace `x` with `r`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有复根都被找到了。为了验证，只需将 `x` 替换为 `r`：
- en: '[PRE76]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Due to some numeric computing issues, the preceding expression does not strictly
    go to zero, but it gets extremely near. If you only care about 8 digits of the
    error, use the `round()` function, and you will find that the roots are valid:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一些数值计算问题，前面的表达式并没有严格趋近于零，但它非常接近。如果你只关心 8 位误差，使用 `round()` 函数，你会发现根是有效的：
- en: '[PRE77]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'As for general numeric root finding for equation *f(x)=0*, the `uniroot()`
    function, as its name suggests, can be useful to find one root. A simple example
    is to find the root of the following equation:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 对于方程**f(x)=0**的一般数值根查找，`uniroot()`函数，正如其名所示，可以用来找到一个根。一个简单的例子是找到以下方程的根：
- en: '![Root finding](img/image_05_064.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![根查找](img/image_05_064.jpg)'
- en: 'Within the following range:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下范围内：
- en: '![Root finding](img/image_05_065.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![根查找](img/image_05_065.jpg)'
- en: .
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: .
- en: 'The plot generated is as shown:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图示如下：
- en: '![Root finding](img/image_05_068.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: 在以下范围内：
- en: 'The curve of the function shows that the root lies in **[-1.0,0.5]**. Using `uniroot()`
    with the function and interval will return a list containing the approximate root,
    the function value at that point, the number of iteration it takes, and the estimated
    precision of the root:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的曲线显示根位于**[-1.0,0.5]**。使用带有函数和区间的`uniroot()`将返回一个包含近似根、该点的函数值、迭代次数和根的估计精度的列表：
- en: '[PRE78]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'A more complex example is to find a root of the following equation:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更复杂的例子是找到以下方程的根：
- en: '![Root finding](img/image_05_072.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![根查找](img/image_05_072.jpg)'
- en: 'Within the following range:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '![根查找](img/image_05_068.jpg)'
- en: '![Root finding](img/image_05_073.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![根查找](img/image_05_073.jpg)'
- en: .
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: .
- en: 'The plot generated is as shown:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图示如下：
- en: '![Root finding](img/image_05_076.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![根查找](img/image_05_076.jpg)'
- en: 'It is obvious that the equation has two roots from **-2** to **2**. However, `uniroot()`
    is only capable of finding one root at a time, and it''s best that the function
    is monotonic in the interval to search. If we directly let it find a root in the **[-2,2] **interval,
    the function produces an error:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，该方程在**-2**到**2**之间有两个根。然而，`uniroot()`一次只能找到一个根，并且最好是在搜索区间内函数是单调的。如果我们直接让它在这个**[-2,2]**区间内找到一个根，函数会产生错误：
- en: '[PRE79]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We have to make sure that the function values of both ends of the interval
    have opposite signs. We can separate the interval into two smaller ones and find
    roots in a separate manner:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保区间两端的函数值具有相反的符号。我们可以将区间分成两个更小的区间，并分别找到根：
- en: '[PRE80]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'An even more complex equation is as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更复杂的方程如下：
- en: '![Root finding](img/image_05_080.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![根查找](img/image_05_080.jpg)'
- en: 'Within the following range:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下范围内：
- en: '![Root finding](img/image_05_081.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![根查找](img/image_05_081.jpg)'
- en: .
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: .
- en: 'The plot generated is as shown:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图示如下：
- en: '![Root finding](img/image_05_084.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![根查找](img/image_05_084.jpg)'
- en: 'The curve shows that the equation has even more roots. The following code only
    finds one in the **[0,1]** interval:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 曲线显示该方程还有更多的根。以下代码只在**[0,1]**区间找到了一个：
- en: '[PRE81]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: In some of the preceding root-finding function calls, we directly pass a function
    to `uniroot()` without giving the function a name. They are called **anonymous
    functions**. We will cover this concept in detail in later chapters.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些先前的根查找函数调用中，我们直接将一个函数传递给`uniroot()`而没有给函数命名。它们被称为**匿名函数**。我们将在后面的章节中详细讨论这个概念。
- en: Calculus
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微积分
- en: In addition to root finding, numeric methods in base R also include computing
    basic calculus.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 除了根查找之外，R的基础数值方法还包括计算基本微积分。
- en: Derivatives
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导数
- en: '`D()` computes the derivative of a function symbolically with respect to given
    variables.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`D()`函数可以针对给定的变量符号地计算函数的导数。'
- en: 'For example, derive *dx²/dx*:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，求导 *dx²/dx*：
- en: '[PRE82]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Derive *dsin(x)cos(xy)/dx*:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 求导 *dsin(x)cos(xy)/dx*：
- en: '[PRE83]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Thanks to the `quote()` function, it keeps the expression unevaluated so that
    the symbols are directly accessible as they are written.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了`quote()`函数，它保持表达式未评估，因此符号可以直接以它们书写的方式直接访问。
- en: 'Since the derivative is also an unevaluated expression, we can evaluate it,
    given all necessary symbols by calling `eval()`:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 由于导数也是一个未评估的表达式，我们可以通过调用`eval()`来评估它，给定所有必要的符号：
- en: '[PRE84]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: In the preceding example, `quote()` creates an expression object and `eval()`
    evaluates a given expression with specified symbols. Expression object gives R
    the power of meta programming. We will cover this topic in [Chapter 9](ch09.html
    "Chapter 9.  Metaprogramming"), *Metaprogramming*.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`quote()`创建了一个表达式对象，而`eval()`使用指定的符号评估一个给定的表达式。表达式对象赋予了R元编程的能力。我们将在第9章[元编程](ch09.html
    "第9章。元编程")中讨论这个主题。
- en: Integration
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 积分
- en: 'R also supports numeric integration. Here, we do not have to write the expression
    but provide a function since it is not symbolic computation. For instance, the
    following formula is a problem of definite integral. It basically calculates the
    area below the sine curve from *0* to *pi/2*. R provides built-in function, `integrate()`,
    to solve such problems with great flexibility as long as the mathematical function
    can be represented by an R function:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: R 还支持数值积分。在这里，我们不需要编写表达式，只需提供一个函数即可，因为这不是符号计算。例如，以下公式是一个定积分问题。它基本上计算了从 *0* 到
    *pi/2* 的正弦曲线下的面积。R 提供了内置函数 `integrate()`，可以灵活地解决这类问题，只要数学函数可以用 R 函数表示：
- en: '![Integration](img/image_05_094.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![积分](img/image_05_094.jpg)'
- en: '[PRE85]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The result looks like a numeric value, but it seems to take some other information.
    In fact, it is a list:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 结果看起来像是一个数值，但它似乎还包含了一些其他信息。实际上，它是一个列表：
- en: '[PRE86]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Since it is a numerical computation, it inherits all the pros and cons of such
    computing techniques.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个数值计算，它继承了此类计算技术的所有优点和缺点。
- en: Using statistical functions
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用统计函数
- en: R is highly productive in doing statistical computing and modeling since it
    provides a good variety of functions ranging from random sampling to statistical
    testing. The functions in the same category share a common interface. In this
    section, I will demonstrate a number of examples so that you can draw inferences
    about the usage of other similar functions.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: R 在进行统计计算和建模方面非常高效，因为它提供了从随机抽样到统计测试的丰富函数。同一类别的函数具有共同的接口。在本节中，我将演示一些示例，以便您可以推断出其他类似函数的用法。
- en: Sampling from a vector
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从向量中抽样
- en: 'In statistics, the study of a population often begins with a random sample
    of it. The `sample()` function is designed for drawing a random sample from a
    given vector or list. In default, `sample()` draws a sample without replacement.
    For example, the following code draws a sample of five from a numeric vector without
    replacement:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在统计学中，对总体进行研究通常从对其的随机样本开始。`sample()` 函数旨在从给定的向量或列表中抽取随机样本。默认情况下，`sample()` 进行无替换抽样。例如，以下代码从数值向量中抽取五个样本，不进行替换：
- en: '[PRE87]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'With `replace = TRUE`, the sampling is done with replacement:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `replace = TRUE`，抽样是带替换进行的：
- en: '[PRE88]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Although `sample()` is often used to draw samples from a numeric vector, it
    also works with other types of vectors:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `sample()` 函数通常用于从数值向量中抽取样本，但它也适用于其他类型的向量：
- en: '[PRE89]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'It even works with lists:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 它甚至可以与列表一起使用：
- en: '[PRE90]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'In fact, `sample()` is capable of sampling from any object that supports subsetting
    with brackets (`[]`). In addition, it supports weighted sampling, that is, you
    can specify a probability for each element:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`sample()` 能够从任何支持使用方括号 (`[]`) 进行子集操作的任何对象中进行抽样。此外，它支持加权抽样，即您可以指定每个元素的概率：
- en: '[PRE91]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'We can use `table()` to see the number of occurrences of each value:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `table()` 来查看每个值的出现次数：
- en: '[PRE92]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Working with random distributions
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理随机分布
- en: In numeric simulations, it is more often the case that we need to draw samples
    from a random distribution rather than from a given vector. R provides a good
    variety of built-in functions to work with popular probability distributions.
    In this section, we will see how R provides basic statistical tools to work with
    R objects that represent sample data. These tools can be used to work mainly with
    numeric vectors.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在数值模拟中，我们通常需要从随机分布中抽取样本，而不是从给定的向量中抽取。R 提供了丰富的内置函数来处理流行的概率分布。在本节中，我们将看到 R 如何提供基本的统计工具来处理代表样本数据的
    R 对象。这些工具主要用于处理数值向量。
- en: In R, it is very easy to generate random numbers following a statistical distribution.
    The most commonly used two distributions are uniform distribution and normal distribution.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中，生成遵循统计分布的随机数非常容易。最常用的两种分布是均匀分布和正态分布。
- en: 'In a statistical sense, it is equally probable to draw any value from a uniform
    distribution within a given range. We can call `runif(n)` to generate `n` random
    numbers from a uniform distribution over **[0,1]**:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在统计学上，从给定范围内的均匀分布中抽取任何值是等可能的。我们可以调用 `runif(n)` 来生成来自 **[0,1]** 范围内的均匀分布的 `n`
    个随机数：
- en: '[PRE93]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'To generate random numbers within a non-default interval, specify `min` and `max`:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 要在非默认区间内生成随机数，请指定 `min` 和 `max`：
- en: '[PRE94]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'If we generate 1000 random numbers using `runif(1000)` and draw the points,
    we will get a scatter plot (a plot to show X-Y points) as follows:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `runif(1000)` 生成 1000 个随机数并绘制点，我们将得到一个散点图（用于显示 X-Y 点的图）如下：
- en: '![Working with random distributions](img/image_05_097.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![处理随机分布](img/image_05_097.jpg)'
- en: The histogram shows that the random numbers we generated distribute almost evenly
    across each interval from 0 to 1, which is consistent with uniform distribution.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图显示，我们生成的随机数在从0到1的每个区间内分布几乎均匀，这与均匀分布一致。
- en: 'Another distribution that is most commonly seen in the real world is the normal
    distribution. Similar to `runif()`, we can use `rnorm()` to generate random numbers
    following a standard normal distribution:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中最常见的另一个分布是正态分布。类似于`runif()`，我们可以使用`rnorm()`来生成遵循标准正态分布的随机数：
- en: '[PRE95]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'You may notice that the random generator functions share the same interface.
    The first argument of both `runif()` and `rnorm()` is `n`, the number of values
    to generate, and the rest of the arguments are the parameters of the random distribution
    itself. As for a normal distribution, its parameters are `mean` and standard deviation
    (`sd`):'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到随机生成器函数具有相同的接口。`runif()`和`rnorm()`的第一个参数都是`n`，表示要生成的值的数量，其余参数是随机分布本身的参数。对于正态分布，其参数是均值和标准差（`sd`）：
- en: '[PRE96]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The plot generated is as shown:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图形如下所示：
- en: '![Working with random distributions](img/image_05_098.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![处理随机分布](img/image_05_098.jpg)'
- en: From the preceding graphics, it is obvious that the points are not evenly distributed
    but concentrate on the mean instead. As we know, statistical distributions can
    be described by certain formulas. To access these formulas in theory, R provides
    a family of functions for each built-in random distribution. More specifically,
    for uniform distribution, R provides its probability density function `dunif()`,
    cumulative density function `punif()`, quantile function `qunif()`, and random
    generator `runif()`. For normal distribution, the corresponding names are `dnorm()`, `pnorm()`,
    and `qnorm()`. The same naming scheme of density function, cumulative density
    function, quantile function, as well as random generator also applies to other
    distributions R supports.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图形中可以看出，点并不是均匀分布，而是集中在均值附近。众所周知，统计分布可以用某些公式来描述。为了在理论上访问这些公式，R为每个内置随机分布提供了一组函数。更具体地说，对于均匀分布，R提供了其概率密度函数`dunif()`，累积密度函数`punif()`，分位数函数`qunif()`和随机生成器`runif()`。对于正态分布，相应的名称是`dnorm()`，`pnorm()`和`qnorm()`。密度函数、累积密度函数、分位数函数以及随机生成器的相同命名方案也适用于R支持的其他分布。
- en: In addition to these two most commonly used statistical distributions, R also
    provides functions for discrete distributions, such as binomial distribution,
    and continuous distributions, such as exponential distribution. You can run `?Distributions`
    to see a full list of supported distributions. The features of those distributions
    are beyond the scope of this book. If you are not familiar with them but are interested
    in the features of these distributions, you may read any textbook  on probability
    theory or visit Wikipedia ([https://en.wikipedia.org/wiki/Probability_distribution](https://en.wikipedia.org/wiki/Probability_distribution))
    for more details.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这两种最常用的统计分布之外，R还提供了用于离散分布（如二项分布）和连续分布（如指数分布）的函数。您可以通过运行`?Distributions`来查看支持的完整分布列表。这些分布的特性超出了本书的范围。如果您不熟悉它们但对这些分布的特性感兴趣，您可以阅读任何概率论教科书或访问维基百科（[https://en.wikipedia.org/wiki/Probability_distribution](https://en.wikipedia.org/wiki/Probability_distribution)）以获取更多详细信息。
- en: R supports many distributions, and each of them has corresponding functions.
    Fortunately we don't need to remember a lot of different function names because
    they all follow the same naming convention.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: R支持许多分布，每个分布都有相应的函数。幸运的是，我们不需要记住很多不同的函数名，因为它们都遵循相同的命名约定。
- en: Computing summary statistics
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算汇总统计量
- en: For a given dataset, we often need some summary statistics to get an initial
    impression on it. R provides a set of functions to compute summary statistics
    for a numeric vector, including mean, median, standard deviation, variance, maximum,
    minimum, range, and quantiles. For multiple numeric vectors, we can compute the
    covariance matrix and correlation matrix.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的数据集，我们通常需要一些汇总统计量来对其有一个初步的了解。R提供了一套函数来计算数值向量的汇总统计量，包括均值、中位数、标准差、方差、最大值、最小值、范围和分位数。对于多个数值向量，我们可以计算协方差矩阵和相关性矩阵。
- en: 'The following examples show how we use the built-in functions to compute these
    summary statistics. First, we generate a random numeric vector of length 50 from
    standard normal distribution:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了我们如何使用内置函数来计算这些汇总统计量。首先，我们从一个标准正态分布中生成一个长度为50的随机数值向量：
- en: '[PRE97]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'To compute the arithmetic sample mean value of `x`, we call `mean()`:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算`x`的算术样本均值，我们调用`mean()`：
- en: '[PRE98]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'This is equivalent to:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于：
- en: '[PRE99]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'However, `mean()` supports trimming a fraction of observations from each end
    of the input data:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`mean()`支持从输入数据的两端修剪一定比例的观测值：
- en: '[PRE100]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: If `x` contains a few outliers far from other values, the mean value obtained
    from the preceding equation should be more robust since the outliers are omitted
    from the input.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`x`包含一些远离其他值的异常值，从前面方程获得的平均值应该更稳健，因为异常值被从输入中省略了。
- en: 'An alternative measure of the representative location of a sample data is the
    sample median. For a given sample, half of the observations are higher than the
    median, and the other half are lower than the median. The median can be a robust
    measure if there are a few extreme values in the data. For `x`, the sample median
    is:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 样本数据代表性位置的另一种度量方法是样本中位数。对于一个给定的样本，一半的观测值高于中位数，另一半的观测值低于中位数。如果数据中存在一些极端值，中位数可以是一个稳健的度量。对于`x`，样本中位数是：
- en: '[PRE101]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'In addition to location measures such as mean and median, variation measures
    are important too. To compute the standard deviation of a numeric vector, we use
    `sd()`:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 除了均值和中位数等位置度量值之外，变异度量值也很重要。要计算数值向量的标准差，我们使用`sd()`：
- en: '[PRE102]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'To compute the variance, we use `var()`:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算方差，我们使用`var()`：
- en: '[PRE103]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'To simply get the extreme values in the data, we use `min()` and `max()`:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 要简单地获取数据中的极端值，我们使用`min()`和`max()`：
- en: '[PRE104]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Alternatively, you can use `range()` to directly get both:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用`range()`直接获取这两个值：
- en: '[PRE105]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Sometimes, the data is not regularly distributed. In this case, the location
    measures and variation measures suffer from such irregularity and may produce
    misleading results. Here, we should probably take a look at the values at critical
    quantiles of the data:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，数据不是正态分布的。在这种情况下，位置度量值和变异度量值会受到这种不规则性的影响，并可能产生误导性的结果。在这里，我们可能需要查看数据的临界分位数处的值：
- en: '[PRE106]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'To see more quantiles, specify more values for the `probs` argument:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看更多分位数，为`probs`参数指定更多值：
- en: '[PRE107]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'If the data is not regularly distributed, the gap of values between two quantiles
    can be very large or small, compared to others. A shortcut for this is to use
    `summary()`, which directly gives the most commonly used summary statistics, including
    four quantiles, median, and mean:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据不是正态分布的，两个分位数之间的值差可能非常大或非常小，与其他值相比。一个快捷方法是使用`summary()`，它直接给出最常用的汇总统计量，包括四个分位数、中位数和平均值：
- en: '[PRE108]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Note that the minimum values and the maximum values are the 0 percent quantile
    and 100 percent quantile, respectively.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，最小值和最大值分别是0百分位数和100百分位数。
- en: 'In fact, `summary()` is a generic function that works for many types of objects
    and has different behaviors. For example, `summary()` works with data frames too:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`summary()`是一个通用函数，适用于许多类型的对象，并且具有不同的行为。例如，`summary()`与数据框一起工作：
- en: '[PRE109]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: It can be seen that for a numeric column, `summary()` shows the summary statistics.
    For columns of other types, it may just simply show a table of value occurrences.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看出，对于数值列，`summary()`显示汇总统计量。对于其他类型的列，它可能只是简单地显示值出现的表格。
- en: Computing covariance and correlation matrix
  id: totrans-393
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算协方差和相关性矩阵
- en: The preceding examples introduced the most commonly used summary statistics
    for one vector. For two or more vectors, we can compute the covariance matrix
    and the correlation matrix.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子介绍了单个向量最常用的汇总统计量。对于两个或更多向量，我们可以计算协方差矩阵和相关性矩阵。
- en: 'The following code generates another vector that is correlated with `x`:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码生成另一个与`x`相关的向量：
- en: '[PRE110]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'We can compute the covariance between `x` and `y`:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以计算`x`和`y`之间的协方差：
- en: '[PRE111]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'We can also compute the correlation coefficient:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以计算相关系数：
- en: '[PRE112]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'These two functions also work with more than two vectors. If we need to compute
    the covariance and correlation matrix of more than two vectors, we need to input
    a matrix or a data frame. In the following example, we generate another random
    vector `z` of the same length of `x`. This time, `z` follows a uniform distribution
    and does not depend on either `x` or `y`. We use `cbind()` to create a three-column
    matrix and compute the covariance matrix of them:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数也适用于超过两个向量。如果我们需要计算超过两个向量的协方差和相关性矩阵，我们需要输入一个矩阵或数据框。在以下示例中，我们生成另一个长度与 `x`
    相同的随机向量 `z`。这次，`z` 遵循均匀分布，并且不依赖于 `x` 或 `y`。我们使用 `cbind()` 创建一个三列矩阵，并计算它们的协方差矩阵：
- en: '[PRE113]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Similarly, we can call `cor()` directly with the matrix to compute the correlation
    matrix.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以直接使用矩阵调用 `cor()` 来计算相关性矩阵。
- en: '[PRE114]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Since `y` is generated by a linear relationship with `x`, plus some noise, we
    should expect that `x` and `y` are highly correlated, but the same thing should
    not happen with `z`. The correlation matrix looks consistent with our expectation.
    To draw such a conclusion in a statistical sense, we need to perform rigorous
    statistical tests, which is beyond the scope of this book.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `y` 是由与 `x` 的线性关系以及一些噪声生成的，我们应该预期 `x` 和 `y` 之间高度相关，但与 `z` 发生相同的事情不应该发生。相关矩阵看起来与我们的预期一致。要在统计意义上得出这样的结论，我们需要进行严格的统计测试，但这超出了本书的范围。
- en: Using apply-family functions
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 apply-family 函数
- en: Previously, we talked about using a `for` loop to repeat evaluating an expression
    with an iterator on a vector or list. In practice, however, the `for` loop is
    almost the last choice because an alternative way is much cleaner and easier to
    write and read when each iteration is independent of each other.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 此前，我们讨论了使用 `for` 循环在向量或列表上重复评估带有迭代器的表达式。然而，在实践中，`for` 循环几乎是最后的选择，因为当每个迭代独立于其他迭代时，另一种方式要干净得多，也更容易编写和阅读。
- en: 'For example, the following code uses `for` to create a list of three independent,
    normally distributed random vectors whose length is specified by vector `len`:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码使用 `for` 创建一个包含三个独立、正态分布随机向量（其长度由向量 `len` 指定）的列表：
- en: '[PRE115]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'The preceding example is simple, but the code is quite redundant compared to
    the implementation with `lapply`:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例很简单，但与使用 `lapply` 的实现相比，代码相当冗余：
- en: '[PRE116]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The `lapply` version is much simpler. It applies `rnorm()` on each element in `len`
    and puts each result into a list.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`lapply` 版本要简单得多。它将 `rnorm()` 应用于 `len` 中的每个元素，并将每个结果放入一个列表中。'
- en: From the preceding example, we should realize that it is only possible if R
    allows us to pass functions as ordinary objects. Fortunately, it is true. Functions
    in R are treated just like objects and can be passed around as arguments, just
    as we showed in the section on numeric methods. This feature largely boosts the
    flexibility of coding.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的示例中，我们应该意识到，这只有在 R 允许我们将函数作为普通对象传递时才可能。幸运的是，这是真的。R 中的函数被当作对象对待，可以作为参数传递，就像我们在数值方法部分所展示的那样。这个特性在很大程度上提高了代码的灵活性。
- en: Each apply-family function is a so-called **higher-order function** that accepts
    a function as an argument. We will introduce this concept in detail later.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 每个apply-family 函数都是一个所谓的 **高阶函数**，它接受一个函数作为参数。我们将在稍后详细介绍这个概念。
- en: lapply
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: lapply
- en: The `lapply()` function, as we previously demonstrated, takes a vector and a
    function as its arguments. It simply applies the function to each element in the
    given vector and finally returns a list that contains all the results.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`lapply()` 函数，正如我们之前所演示的，它接受一个向量和函数作为其参数。它简单地将函数应用于给定向量的每个元素，并最终返回一个包含所有结果的列表。'
- en: This function is useful when each iteration is independent of the other. In
    this case, we don't have to explicitly create an iterator.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 当每个迭代独立于其他迭代时，此函数非常有用。在这种情况下，我们不必显式创建迭代器。
- en: 'It works not only with vectors but also with lists. Suppose we have a list
    of students:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 它不仅适用于向量，也适用于列表。假设我们有一个学生列表：
- en: '[PRE117]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Now, we need to create a character vector in which each element is formatted
    as follows:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个字符向量，其中每个元素格式如下：
- en: '[PRE118]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Note that `sprintf()` is useful to format text by replacing the placeholders
    (for example, `%s` for string, `%d` for integer) with corresponding input arguments.
    Here is an example:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`sprintf()` 有助于通过替换占位符（例如，`%s` 用于字符串，`%d` 用于整数）来格式化文本。以下是一个示例：
- en: '[PRE119]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Now, first, we are sure that an iteration is working on `students`, and each
    is independent. In other words, the computation for James has nothing to do with
    that for Jenny, and so on. Therefore, we can use `lapply` to do the work:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，首先，我们确信迭代正在对`students`进行操作，并且每个迭代都是独立的。换句话说，对詹姆斯的计算与珍妮的计算没有任何关系，以此类推。因此，我们可以使用`lapply`来完成这项工作：
- en: '[PRE120]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: The preceding code uses an anonymous function which is a function that is not
    assigned to a symbol. In other words, the function is only temporal and has no
    name. Of course, we can explicitly bind the function to a symbol, that is, give
    it a name, and use that name in `lapply`.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用了一个匿名函数，这是一种没有分配给符号的函数。换句话说，这个函数是临时的，没有名字。当然，我们可以明确地将函数绑定到符号上，即给它一个名字，并在`lapply`中使用这个名字。
- en: Despite this, the code is quite straightforward. For each element `s` in `students`,
    the function decides the type of the student and pastes their interests together,
    separated by commas. It then puts the information in a format we want.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，代码相当简单。对于`students`中的每个元素`s`，函数会决定学生的类型并将他们的兴趣粘贴在一起，用逗号分隔。然后，它将信息放入我们想要的格式中。
- en: Fortunately, a major part of how we use `lapply` also works with other apply-family
    functions, but their iterating mechanism or the type of results may be different.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们使用`lapply`的大部分方法也适用于其他apply家族函数，但它们的迭代机制或结果类型可能不同。
- en: sapply
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: sapply
- en: List is not always a favorable container for the results. Sometimes, we want
    them to be put in a simple vector or a matrix. The `sapply` function simplifies
    the result according to its structure.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 列表并不总是结果的有利容器。有时，我们希望它们被放入一个简单的向量或矩阵中。`sapply`函数根据其结构简化结果。
- en: 'Suppose we apply a square on each element of `1:10`. If we do it with `lapply`,
    we will have a list of squared numbers. This result looks a bit heavy and redundant
    because the resulted list is actually a list of single-valued numeric vectors.
    However, we might want to keep the results still as a vector:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们对`1:10`中的每个元素应用平方。如果我们用`lapply`来做，我们将得到一个平方数的列表。这个结果看起来有点冗余，因为结果列表实际上是一个单值数值向量的列表。然而，我们可能仍然希望将结果保持为向量：
- en: '[PRE121]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'If the applying function returns a multi-element vector each time, `sapply`
    will put the results into a matrix in which each returned vector occupies a column:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用函数每次都返回一个多元素向量，`sapply`会将结果放入一个矩阵中，其中每个返回的向量占据一列：
- en: '[PRE122]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: vapply
  id: totrans-435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: vapply
- en: 'Although `sapply` is very handy and smart, the smartness may sometimes become
    a risk. Suppose we have a list of input numbers:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`sapply`非常方便且智能，但有时这种智能可能会变成风险。假设我们有一个输入数字的列表：
- en: '[PRE123]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'If we want to get a numeric vector of the squared numbers for each number in
    `x`, `sapply` can be easy to use because it automatically tries to simplify the
    data structure of the result:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要获取`x`中每个数字的平方数的数值向量，`sapply`可以很容易地使用，因为它会自动尝试简化结果的数据结构：
- en: '[PRE124]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'However, if the input data has some mistakes or corruption, `sapply()` will
    silently accept the input and may return an unexpected value. For example, let''s
    assume that the third element of `x` has mistakenly got an additional element:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果输入数据存在一些错误或损坏，`sapply()`将静默地接受输入并可能返回一个意外的值。例如，假设`x`的第三个元素错误地多了一个元素：
- en: '[PRE125]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Then, `sapply()` finds that it can no longer be simplified to a matrix and
    thus returns a list:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`sapply()`发现它不能再简化为一个矩阵，因此返回一个列表：
- en: '[PRE126]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'If we use `vapply()` in the first place, the mistake will be spotted very soon.
    The `vapply()` function has an additional argument that specifies the template
    of the returned value from each iteration. In the following code, the template
    is `numeric(2)`, which means each iteration should return a numeric vector of
    two elements. If the template is violated, the function will end up in an error:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们首先使用`vapply()`，错误将很快被发现。`vapply()`函数有一个额外的参数，指定了每次迭代返回值的模板。在以下代码中，模板是`numeric(2)`，这意味着每个迭代应该返回一个包含两个元素的数值向量。如果模板被违反，函数将最终出错：
- en: '[PRE127]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'For the original and correct input, `vapply()` returns exactly the same matrix
    as `sapply()` did:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 对于原始和正确的输入，`vapply()`返回与`sapply()`完全相同的矩阵：
- en: '[PRE128]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: In conclusion, `vapply` is the safer version of `sapply` as it performs additional
    template checking. In practical use, if the template can be determined, it is
    better to use `vapply()` than `sapply()`.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，`vapply`是`sapply`更安全版本，因为它执行额外的模板检查。在实际应用中，如果可以确定模板，最好使用`vapply()`而不是`sapply()`。
- en: mapply
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: mapply
- en: 'While `lappy()` and `sapply()` both iterate over one vector, `mapply()` iterates
    over multiple vectors. In other words, `mapply` is a multivariate version of `sapply`:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`lappy()`和`sapply()`都遍历一个向量，但`mapply()`遍历多个向量。换句话说，`mapply`是`sapply`的多变量版本：
- en: '[PRE129]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'The iterating function is allowed to return not only scalar values but multi-element
    vectors. Then, `mapply()` will simplify the result, just like `sapply()` does:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代函数不仅可以返回标量值，还可以返回多元素向量。然后，`mapply()`将简化结果，就像`sapply()`做的那样：
- en: '[PRE130]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '`Map` is the multivariate version of `lapply` and hence, always returns a list:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map`是`lapply`的多变量版本，因此总是返回一个列表：'
- en: '[PRE131]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: apply
  id: totrans-456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: apply
- en: 'The `apply` function applies a function on a given margin or dimension of a
    given matrix or array. For example, to calculate the sum of each row, which is
    the first dimension, we need to specify `MARGIN = 1` so that `sum` is applied
    to a row (numeric vector) sliced from the matrix in each iteration:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply`函数在给定的矩阵或数组的给定边缘或维度上应用一个函数。例如，要计算每一行的总和，即第一维度，我们需要指定`MARGIN = 1`，这样`sum`函数就会在每次迭代中对从矩阵中切分的一行（数值向量）应用：'
- en: '[PRE132]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'To calculate the sum of each column, which is the second dimension, we need
    to specify `MARGIN=2` so that `sum` is applied to a column sliced from `mat` in
    each iteration:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算每一列的总和，即第二维度，我们需要指定`MARGIN=2`，这样`sum`函数就会在每次迭代中对从`mat`中切分的每一列应用：
- en: '[PRE133]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'The `apply` function also supports array input and matrix output:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply`函数也支持数组输入和矩阵输出：'
- en: '[PRE134]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'To build a matrix that shows the max and min value for each column, run the
    following code:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个显示每列最大和最小值的矩阵，运行以下代码：
- en: '[PRE135]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'To build a matrix that shows the max and min value for each row, run the following
    code:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个显示每行最大和最小值的矩阵，运行以下代码：
- en: '[PRE136]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Summary
  id: totrans-467
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to work basic objects by demonstrating the
    use of built-in functions. They are the vocabulary of R in practice. You learned
    some basic functions to test and get object types and to access and reshape data
    dimensions. You learned about a number of logical operators and functions to filter
    data.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你通过演示内置函数的使用来学习如何处理基本对象。它们是R在实际应用中的词汇。你学习了测试和获取对象类型的基本函数，以及访问和重塑数据维度的函数。你还了解了一些逻辑运算符和函数，用于过滤数据。
- en: To work with numeric data structures, you learned basic math functions, built-in
    numeric methods to find roots and do calculus, and some statistical functions
    to perform random sampling and make summaries of data. You also understood the
    apply-family functions that make it easier to iterate and collect results.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理数值数据结构，你学习了基本的数学函数，内置的数值方法来寻找根和进行微积分，以及一些统计函数来执行随机抽样和数据的总结。你还了解了apply族函数，这些函数使得迭代和收集结果变得更加容易。
- en: Another important category of data is string, which is represented by character
    vectors. In the next chapter, you will learn string-manipulation techniques to
    facilitate text analysis.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的数据类型是字符串，它由字符向量表示。在下一章中，你将学习字符串操作技术，以促进文本分析。
