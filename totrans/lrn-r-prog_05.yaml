- en: Chapter 5. Working with Basic Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, you learned how to create several basic types of objects,
    including atomic vectors, lists, and data frames to store data. You learned how
    to create functions to store logic. Given these building blocks of R script, you
    learned about different types of expressions to control the flow of logic involving
    basic objects. Now, we are getting familiar with the basic grammar and syntax
    of the R programming language. It's time to build a vocabulary of R using built-in
    functions to work with basic objects.
  prefs: []
  type: TYPE_NORMAL
- en: The real power of R lies in the enormous amount of functions it provides. Getting
    to know a variety of basic functions is extremely useful, and it will save you
    time and boost your productivity.
  prefs: []
  type: TYPE_NORMAL
- en: Although R is mainly a statistical computing environment, many basic functions
    are not related to any statistics but to more fundamental tasks such as inspecting
    the environment, converting texts to numbers, and performing logical operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will get to know a wide range of basic yet most useful
    functions in R, including:'
  prefs: []
  type: TYPE_NORMAL
- en: Object functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logical functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Math functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numeric methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statistical functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply-family functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using object functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned about some functions that work with the
    environment and packages. In this section, we will get to know some basic functions
    that deal with objects in general. More specifically, I will introduce you to
    more functions to access the type and dimensions of a data object. You will get
    an impression of how these concepts can be combined and how they work together.
  prefs: []
  type: TYPE_NORMAL
- en: Testing object types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although everything in R is an object, objects have different types.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose the object we are dealing with is user-defined. We will create a function
    that behaves in different ways according to the type of the input object. For
    example, we need to create a function named `take_it` that returns the first element
    if the input object as an atomic vector (for example, numeric vector, character
    vector, or logical vector), but returns a user-defined element if the input object
    is a list of data and index.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if the input is a numeric vector such as `c(1, 2, 3)`, then the
    function should return its first element `1`. If the input is a character vector
    such as `c("a", "b", "c")`, then the function should return `a`. However, if the
    input is a list `list(data = c("a", "b", "c"), index = 3)`, then the function
    should return the third element `(index = 3)` of `data`, that is, `c`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create such a function, we can imagine the functions and logic flow that
    might appear in it. First, as the output of the function depends on the type of
    input, we need to use one of the `is.*` functions to tell whether the input is
    of a certain type. Second, as the function behaves differently due to the type
    of input, we need to use conditional expressions such as `if else` to branch the
    logic. Finally, if the function basically takes out an element from the input,
    we need to use an element-extraction operator. Now, the implementation of the
    function becomes pretty clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function behaves differently as `x` takes different types. When `x`
    takes an atomic vector (for example, a numeric vector), the function extracts
    its first element. When `x` takes a list of `data` and `index`, the function extracts
    the element with the index of `index` from `x$data`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For unsupported input types, the function is supposed to stop with an error
    message rather than return any value. For example, `take_it` cannot handle the `function`
    input. Note that we can pass any function around to other functions as an argument,
    just like any other object. However, in this case, if `mean` as a function is
    passed to it, then it will turn to the `else` condition and stop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'What if the input is indeed a list but does not contain any of the expected
    elements, `data` and `index`? Just do an experiment with a list of `input` (instead
    of `data`), without any `index` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It might surprise you that the function does not produce an error. The output
    is `NULL` because `x$data` is `NULL` and extracting any value from `NULL` is also `NULL`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if the list only contains `data` but misses `index`, the function
    will end up in an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The error occurs because `x$index` turns out to be `NULL`, and extracting value
    from a vector by `NULL` produces an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The third possibility is a bit similar to the first case in which `NULL[[2]]`
    returns `NULL`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: From the earlier exceptions, it is normal to see that the error message is not
    so informative if you are not very familiar with these edge cases in which `NULL`
    is involved in the computation. For more complicated cases, if those errors do
    happen, you probably won't be able to find out the exact causes in a short period
    of time. One good solution is to check the input yourself in the implementation
    of the function and reflect the assumptions made to the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle the preceding cases of misuse, the following implementation takes
    into account whether the type of each argument is desired:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: For the case where `x` is a list, we check whether `x$data` is not null and
    is an atomic vector. If so, then we check if `x$index` is properly specified as
    a single-element numeric vector, or a scalar. If any of the conditions is violated,
    the function stops with an informative error message telling the user what is
    wrong with the input.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also quirky behaviors of the built-in checker functions. For example,
    `is.atomic(NULL)` returns `TRUE`. Therefore, if list `x` does not contain an element
    called `data`, the positive branch of `if (is.atomic(x$data))` can still be triggered,
    which also leads to `NULL`. With some argument checking, the code is now more
    robust and can produce more informative error messages when the assumptions are
    violated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Another possible implementation of this function is using the S3 dispatch, which
    will be covered in a later chapter on object-oriented programming.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing object classes and types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Apart from using `is.*` functions, we can also use `class()` or `typeof()` to
    implement this function. Before directly accessing the type of an object, it is
    useful to know how these two functions differ from each other.
  prefs: []
  type: TYPE_NORMAL
- en: The following examples demonstrate the difference between the output of `class()`
    and `typeof()` when they are called upon different types of objects.
  prefs: []
  type: TYPE_NORMAL
- en: For each object `x`, `class()` and `typeof()` are called and then `str()` is
    called to show its structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a numeric vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'For an integer vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'For a character vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'For a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'For a data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We can see that `typeof()` returns the low-level internal type of an object,
    while `class()` returns the high-level class of an object. One contrast we have
    mentioned before is that `data.frame` is in essence a `list` with equal-length
    list elements. Therefore, a data frame has the class of `data.frame` for data
    frame related functions to recognize, but `typeof()` still tells it is a `list`
    internally.
  prefs: []
  type: TYPE_NORMAL
- en: The topic is related to the S3 object-oriented programming mechanism and will
    be covered in detail in a later chapter. However, it is still useful to mention
    the difference between `class()` and `typeof()` here.
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding output, it is also clear that `str()`, which we introduced
    in the previous chapter, shows the structure of an object. For vectors in the
    object, it usually shows their internal type (`typeof()`).
  prefs: []
  type: TYPE_NORMAL
- en: Accessing data dimensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Matrices, arrays, and data frames have the property of dimensions in addition
    to classes and types.
  prefs: []
  type: TYPE_NORMAL
- en: Getting data dimensions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In R, a vector is by construction a one-dimensional data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The same underlying data can be represented with more dimensions, which can
    be accessed via `dim()`, `nrow()`, or `ncol()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The first preceding expression creates a four-column matrix from numeric vector
    `vec`. The matrix has the class of `matrix`, while `typoef()` preserves `double`
    from `vec`. Since a matrix is a dimensional data structure, `dim()` shows its
    dimensions in vector form. The `nrow()` and `ncol()` functions are shortcuts to
    access its number of rows and columns. If you read the source code of these two
    shortcuts, you will find that they are nothing special, but they return the first
    and second elements of `dim()` of the same input, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Higher dimensional data is usually represented by an array. For example, the
    same data `vec` can also be represented in three dimensions, that is, to access
    one element, you need to specify three positions in the three dimensions in turn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Similar to `matrix`, an array has a class of `array` but still preserves the
    type of the underlying data. The length of the output of `dim()` is the number
    of dimensions needed to represent the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another data structure that has a notion of dimensions is a data frame. However,
    a data frame is fundamentally different from a matrix. A matrix is derived from
    a vector but adds a dimensional property. On the other hand, a data frame is derived
    from a list but adds a constraint that each list element must have the same length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: However, `dim()`, `nrow()`, and `ncol()` are still useful for data frames.
  prefs: []
  type: TYPE_NORMAL
- en: Reshaping data structures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The syntax of `dim(x) <- y` means change the value of dimensions of `x` to `y`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a plain vector, the expression converts the vector to a matrix with the
    specified dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the class of the object changes from `numeric` to `matrix`,
    and the type of the object remains unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a matrix, the expression reshapes the matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'It is useful to understand that changing the dimension of a vector, matrix,
    or array only alters the representation and accessing methods of the object and
    does not change the underlying data stored in memory. Therefore, it should be
    no surprise that a matrix is reshaped to an array as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'It should be obvious that `dim(x) <- y` works only if `prod(y)` equals `length(x)`,
    that is, the product of all dimensions must be equal to the length of the data
    elements. Otherwise, an error will occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Iterating over one dimension
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A data frame is often a collection of records, and each row represents a record.
    It is common to iterate over all records stored in a data frame. Let''s look at
    the following data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'For this data frame, we can iterate over the rows by printing the values of
    the variables using a `for` loop over `1:nrow(x)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Using logical functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A logical vector only takes `TRUE` or `FALSE` and is mostly used to filter data.
    In practice, it is common to create joint conditions by multiple logical vectors
    where a number of logical operators and functions may involve.
  prefs: []
  type: TYPE_NORMAL
- en: Logical operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like many other programming languages, R enables a few operators to do basic
    logical calculations. The following table demonstrates what they do:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Description** | **Example** | **Result** |'
  prefs: []
  type: TYPE_TB
- en: '| `&` | Vectorized AND | `c(T, T) & c(T, F)` | `c(TRUE, FALSE)` |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;` | Vectorized OR | `c(T, T) &#124; c(T, F)` | `c(TRUE, TRUE)` |'
  prefs: []
  type: TYPE_TB
- en: '| `&&` | Univariate AND | `c(T, T) && c(F, T)` | `FALSE` |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;&#124;` | Univariate OR | `c(T, T) &#124;&#124; c(F, T)` | `TRUE`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `!` | Vectorized NOT | `!c(T, F)` | `c(FALSE, TRUE)` |'
  prefs: []
  type: TYPE_TB
- en: '| `%in%` | Vectorized IN | c`(1, 2) %in% c(1, 3, 4, 5)` | `c(TRUE, FALSE)`
    |'
  prefs: []
  type: TYPE_TB
- en: Note that in an `if` expression, `&&` and `||` are often used to perform logical
    calculations that are only needed to yield a single-element logical vector. However,
    the potential risk of using `&&` is that if it is made to work with multi-element
    vectors, it will silently ignore all but the first element of the vectors on both
    sides. The following example demonstrates the difference in behavior of using
    either `&&` or `&` in conditional statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code creates a `test_direction` function that tells the monotonicity
    of supplied argument values. We''ll build on this example through the next section.
    If the values of `x`, `y`, and `z` are monotonically increasing, the function
    returns `1`; if they are monotonically decreasing, the function returns `-1`.
    Otherwise, it returns `0`. Note that the function uses `&` to perform a vectorized
    AND operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If the arguments are supplied scalar numbers, the function works perfectly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `&` performs a vectorized calculation and thus returns a multi-element
    vector if one argument has more than one element. However, `if` only works with
    a single-value logical vector; otherwise, it would produce a warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If we replace both `&` operators present in `test_direction2` with `&&` and
    create a new function `test_direction2`, the function would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the two example test cases may have different behaviors. For scalar input,
    the behavior of the two versions are exactly the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'However, for multi-element input, `test_direction2` silently ignores the second
    element of each input vector and thus does not produce any warnings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Finally, which is the correct use, `&` or `&&`? It all depends on your demand.
    What behavior do you expect under all circumstances? What do you expect if the
    input is scalar values or multi-element vectors? If you expect the function to
    tell you whether all elements in the same position of each input vector have monotonicity,
    then both uses are incorrect in part and require the use of logical aggregation
    functions, to be introduced in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Logical functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will look at aggregating logical vectors and finding the
    true elements.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregating logical vectors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to the binary logical operators, a few logical aggregation functions
    are very useful, as we mentioned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most commonly used two logical aggregation functions are `any()` and `all()`.
    The `any()` function returns `TRUE` if any (for example, at least one) element
    of the given logical vector is `TRUE`; otherwise, it will return `FALSE`. The `all()`
    function returns `TRUE` if all elements of the given logical vector are `TRUE`;
    otherwise, it will return `FALSE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'One common point of the two functions is that they only return a single `TRUE`
    or `FALSE` value and never return a multi-element logical vector. Therefore, to
    implement a function that meets the demand in the previous section, use `all()`
    and `&` together in the `if` conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'For scalar input, `test_all_direction()` behaves exactly the same with the `test_direction()`
    and `test_direction2()` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'For vector input, the function tests whether `c(1, 2, 3)` and `c(2, 3, 4)`
    have (the same) monotonicity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is a counterexample in which the elements at position `2`,
    that is, `c(2, 4, 4)`, have no monotonicity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The value returned by the function is thus meaningful because it correctly implements
    the demand of testing whether all elements at each position in the three input
    vectors have monotonicity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function has several possible variations that instead uses `any()` or `&&`.
    You may try to figure out the underlying demand (what are these functions trying
    to do?) of each of the following versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Asking which elements are TRUE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The logical operations we introduced earlier usually return a logical vector
    to indicate whether a certain condition is `TRUE` or `FALSE`. It is also useful
    to know which elements satisfy those conditions. The `which()` function returns
    the positions (or indices) of `TRUE` elements in a logical vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: If we take a closer look at what happens, it should be clear that at first,
    `abs(x) >= 1.5` is evaluated to be a logical vector, and then, `which()` returns
    the positions of those `TRUE` elements in that logical vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'The mechanism is quite similar when we use a logical condition to filter elements
    from a vector or list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, `x >= 1.5` is evaluated to be a logical vector. Then,
    it is used to select elements in `x` corresponding to `TRUE` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'A special case is that we can even use a logical vector with all `FALsE` values.
    A zero-length numeric vector is returned since the logical vector only contains `FALSE`
    values, and thus, no element in `x` is singled out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Dealing with missing values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Real-world data often contains missing values represented by `NA`. The following
    numeric vector is a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Arithmetic calculations with missing values also produce missing values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'To take this into account, a logical vector has to accept not only `TRUE` and `FALSE`
    values but also `NA` values to represent unknown truthfulness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'As a consequence, logical aggregation functions such as `any()` and `all()`
    have to deal with missing values too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding output demonstrates the default behavior of `any()` when it deals
    with a logical vector that contains missing values. More specifically, if any
    element in the input vector is `TRUE`, then the function will return `TRUE`. If
    no element in the input vector is `TRUE` in which any missing value is present,
    then the function will return `NA`. Otherwise, if the input vector contains only `FALSE`,
    then the function will return `FALSE`. To verify the preceding logic, just run
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'To directly ignore all missing values, just specify `na.rm = TRUE` in the call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'A similar but somehow opposite logic applies to `all()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If any element in the input vector is `FALSE`, then the function will return `FALSE`.
    If no element in the input vector is `FALSE` in which any missing value is present,
    then the function will return `NA`. Otherwise, if the input vector contains only `TRUE`,
    then it will return `TRUE`. To verify the logic, just run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, `na.rm = TRUE` forces the function to directly ignore all missing
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Apart from logical aggregation functions, data filtering also behaves differently
    when missing values involve. For example, the following code will preserve the
    missing values at corresponding positions of the logical vector produced by `x
    >= 0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'By contrast, `which()` does not preserve the missing values present in the
    input logical vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, the vector subsetted by the indices does not contain missing values
    in the following case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Logical coercion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some functions that are supposed to take logical input also accept non-logical
    vectors such as numeric vectors. However, the behavior of the function may not
    be different from what they do with logical vectors. This is because the non-logical
    vectors are coerced to logical values.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we put a numeric vector in the `if` condition, it will be coerced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In R, all non-zero values in a numeric vector or integer vector can be coerced
    to `TRUE`, only zero values will be coerced to `FALSE`, and string values cannot
    be coerced to logical values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Using math functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mathematical functions are an essential part in all computing environments.
    R provides several groups of basic math functions.
  prefs: []
  type: TYPE_NORMAL
- en: Basic functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The basic functions include square root, and exponential and logarithm functions
    as the following table shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic functions](img/B05263_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that `sqrt()` only works with real numbers. If a negative number is supplied, `NaN`
    will be produced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In R, numeric values can be finite, infinite (`Inf` and `-Inf`), and `NaN` values.
    The following code will produce infinite values.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, produce a positively infinite value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, produce a negatively infinite value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several test functions to check whether a numeric value is finite,
    infinite, or `NaN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `is.infinite()`, how can we check whether a numeric value is `-Inf`?
    Inequality still works with infinite values in R:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, we can test the number with `is.infinite()` and compare the elements
    to 0 at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Like `sqrt()`, if the input value goes beyond the domain of `log` function,
    that is, `x > 0`, then the function returns `NaN` with a warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Number rounding functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following functions are used to round numbers in different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Example** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| [x] log | `ceiling(10.6)` | 11 |'
  prefs: []
  type: TYPE_TB
- en: '| [x] log | `floor(9.5)` | 9 |'
  prefs: []
  type: TYPE_TB
- en: '| truncate | `trunc(1.5)` | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| round | `round(pi,3)` | 3.142 |'
  prefs: []
  type: TYPE_TB
- en: '| significant numbers | `signif(pi, 3)` | 3.14 |'
  prefs: []
  type: TYPE_TB
- en: Previously, we showed that using `options(digits =)` can modify the number of
    digits to display, but this does not change the actual number of digits to remember.
    The preceding functions round the numbers and may cause potential loss of information.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if the input number `1.50021` is already precise, then rounding
    it to `1` digit will result in `1.5` and the other digits (information) are lost.
    Therefore, you should make sure if the digits to drop are indeed ignorable due
    to imprecision or noise before performing any rounding.
  prefs: []
  type: TYPE_NORMAL
- en: Trigonometric functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following table lists the most commonly used trigonometric functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Example** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| `sin (x)` | `sin(0)` | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `cos (x)` | `cos(0)` | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `tan (x)` | `tan(0)` | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `arcsin (x)` | `asin(1)` | 1.5707963 |'
  prefs: []
  type: TYPE_TB
- en: '| `arcos (x)` | `acos(1)` | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `arctan (x)` | `atan(1)` | 0.7853982 |'
  prefs: []
  type: TYPE_TB
- en: 'R also provides a numeric version of `π`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'In maths, equation *sin (π) = 0 *strictly holds. However, the same formula
    does not lead to 0 in R or any other typical numeric computing software due to
    some precision issues of floating numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: To compare numbers with near equality, use `all.equal()` instead. While `sin(pi)
    == 0` returns `FALSE`, `all.equal(sin(pi), 0)` returns `TRUE` with the default
    tolerance of `1.5e-8`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another three functions are provided to make it precise when the input is a
    multiple of `π`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Example** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| `sin (πx)` | `sinpi(1)` | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `cos (πx)` | `cospi(0)` | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `tan (πx)` | `tanpi(1)` | 0 |'
  prefs: []
  type: TYPE_TB
- en: Hyperbolic functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to other computing software, hyperbolic functions are provided as shown
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Example** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| `sinh (x)` | `sinh(1)` | 1.1752012 |'
  prefs: []
  type: TYPE_TB
- en: '| `cosh (x)` | `cosh(1)` | 1.5430806 |'
  prefs: []
  type: TYPE_TB
- en: '| `tanh (x)` | `tanh(1)` | 0.7615942 |'
  prefs: []
  type: TYPE_TB
- en: '| `arcsinh (x)` | `asinh(1)` | 0.8813736 |'
  prefs: []
  type: TYPE_TB
- en: '| `arccosh (x)` | `acosh(1)` | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `arctanh (x)` | `atanh(0)` | 0 |'
  prefs: []
  type: TYPE_TB
- en: Extreme functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is common to calculate the maximum or minimum values of some numbers. The
    following table lists and demonstrates the simple use of `max()` and `min()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Symbol** | **Example** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| `max(...)` | `max(1, 2, 3)` | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| `min(...)` | `min(1, 2, 3)` | 1 |'
  prefs: []
  type: TYPE_TB
- en: 'These two functions work not only with multiple scalar arguments but also with
    a vector input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, they work with multiple vector input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The output demonstrates that `max()` returns the maximal value among all values
    of all input vectors and `min()` returns vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we want to obtain maximal or minimal values of each position among
    all vectors? Look at the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'This basically finds the maximal value among all numbers at position 1, then
    at position 2, and so on, which has the same output as the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'This is called the **parallel maxima**. The twin function `pmin()` works to
    find the **parallel minima**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: These two functions can be very useful to quickly compose a vectorized function
    with specific functions as floor and/or ceiling. For example, suppose `spread()`
    is a piecewise function. If the input is less than `-5`, the value is `-5`. If
    the input is between `-5` to `5`, the value is input. If the input is greater
    than `5`, then the value is `5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A naive implementation uses `if` to branch the pieces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The function works with scalar input, but it is not automatically vectorized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'One method is to use `pmin()` and `pmax()`, and the function will be automatically
    vectorized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Another method is to use `ifelse()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous two functions, `spread2()` and `spread3()`, both have the same
    graphics:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Extreme functions](img/image_05_048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Applying numeric methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, you learned about a number of functions that range
    from inspecting data structures to math and logical operations. These functions
    are fundamental to solving problems such as root finding and doing calculus. As
    a computing environment, R already implements various tools of good performance
    so that users do not have to reinvent the wheel. In the following sections, you
    will learn the built-in functions designed for root finding and calculus.
  prefs: []
  type: TYPE_NORMAL
- en: Root finding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Root finding is a commonly encountered task. Suppose we want to find the roots
    of the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*x2 + x - 2= 0*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To manually find the roots, we can transform the preceding equation in product
    terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '*(x+2)(x-1)= 0*'
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the roots of the equation are *x1= -2* and *x[2]= 1*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In R, `polyroot()` can find roots of a polynomial equation in the form of:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Root finding](img/image_05_056.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For the preceding problem, we need to specify the polynomial coefficient vector
    from zero order to the term of the highest order present in the equation. In this
    case, the vector is `c(-2, 1, 1)` to represent the coefficients in the increasing
    order of power:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The function always returns a complex vector in which each element is a complex
    number in the form of `a + bi`. On the one hand, if the function surely has only
    real roots, you can use `Re()` to extract the real parts of the complex roots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, the type of output implies that `polyroot()` has the capability
    to find complex roots of a polynomial equation. The simplest one is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Root finding](img/image_05_058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To find its complex roots, just specify a polynomial coefficient vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'A slightly more complex example is to find the roots of the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Root finding](img/image_05_060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that all complex roots are found. To verify, just replace `x` with `r`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Due to some numeric computing issues, the preceding expression does not strictly
    go to zero, but it gets extremely near. If you only care about 8 digits of the
    error, use the `round()` function, and you will find that the roots are valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'As for general numeric root finding for equation *f(x)=0*, the `uniroot()`
    function, as its name suggests, can be useful to find one root. A simple example
    is to find the root of the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Root finding](img/image_05_064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Within the following range:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Root finding](img/image_05_065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: .
  prefs: []
  type: TYPE_NORMAL
- en: 'The plot generated is as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Root finding](img/image_05_068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The curve of the function shows that the root lies in **[-1.0,0.5]**. Using `uniroot()`
    with the function and interval will return a list containing the approximate root,
    the function value at that point, the number of iteration it takes, and the estimated
    precision of the root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'A more complex example is to find a root of the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Root finding](img/image_05_072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Within the following range:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Root finding](img/image_05_073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: .
  prefs: []
  type: TYPE_NORMAL
- en: 'The plot generated is as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Root finding](img/image_05_076.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It is obvious that the equation has two roots from **-2** to **2**. However, `uniroot()`
    is only capable of finding one root at a time, and it''s best that the function
    is monotonic in the interval to search. If we directly let it find a root in the **[-2,2] **interval,
    the function produces an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to make sure that the function values of both ends of the interval
    have opposite signs. We can separate the interval into two smaller ones and find
    roots in a separate manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'An even more complex equation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Root finding](img/image_05_080.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Within the following range:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Root finding](img/image_05_081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: .
  prefs: []
  type: TYPE_NORMAL
- en: 'The plot generated is as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Root finding](img/image_05_084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The curve shows that the equation has even more roots. The following code only
    finds one in the **[0,1]** interval:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: In some of the preceding root-finding function calls, we directly pass a function
    to `uniroot()` without giving the function a name. They are called **anonymous
    functions**. We will cover this concept in detail in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Calculus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to root finding, numeric methods in base R also include computing
    basic calculus.
  prefs: []
  type: TYPE_NORMAL
- en: Derivatives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`D()` computes the derivative of a function symbolically with respect to given
    variables.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, derive *dx²/dx*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Derive *dsin(x)cos(xy)/dx*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to the `quote()` function, it keeps the expression unevaluated so that
    the symbols are directly accessible as they are written.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the derivative is also an unevaluated expression, we can evaluate it,
    given all necessary symbols by calling `eval()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, `quote()` creates an expression object and `eval()`
    evaluates a given expression with specified symbols. Expression object gives R
    the power of meta programming. We will cover this topic in [Chapter 9](ch09.html
    "Chapter 9.  Metaprogramming"), *Metaprogramming*.
  prefs: []
  type: TYPE_NORMAL
- en: Integration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'R also supports numeric integration. Here, we do not have to write the expression
    but provide a function since it is not symbolic computation. For instance, the
    following formula is a problem of definite integral. It basically calculates the
    area below the sine curve from *0* to *pi/2*. R provides built-in function, `integrate()`,
    to solve such problems with great flexibility as long as the mathematical function
    can be represented by an R function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Integration](img/image_05_094.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The result looks like a numeric value, but it seems to take some other information.
    In fact, it is a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Since it is a numerical computation, it inherits all the pros and cons of such
    computing techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Using statistical functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: R is highly productive in doing statistical computing and modeling since it
    provides a good variety of functions ranging from random sampling to statistical
    testing. The functions in the same category share a common interface. In this
    section, I will demonstrate a number of examples so that you can draw inferences
    about the usage of other similar functions.
  prefs: []
  type: TYPE_NORMAL
- en: Sampling from a vector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In statistics, the study of a population often begins with a random sample
    of it. The `sample()` function is designed for drawing a random sample from a
    given vector or list. In default, `sample()` draws a sample without replacement.
    For example, the following code draws a sample of five from a numeric vector without
    replacement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'With `replace = TRUE`, the sampling is done with replacement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Although `sample()` is often used to draw samples from a numeric vector, it
    also works with other types of vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'It even works with lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, `sample()` is capable of sampling from any object that supports subsetting
    with brackets (`[]`). In addition, it supports weighted sampling, that is, you
    can specify a probability for each element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use `table()` to see the number of occurrences of each value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Working with random distributions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In numeric simulations, it is more often the case that we need to draw samples
    from a random distribution rather than from a given vector. R provides a good
    variety of built-in functions to work with popular probability distributions.
    In this section, we will see how R provides basic statistical tools to work with
    R objects that represent sample data. These tools can be used to work mainly with
    numeric vectors.
  prefs: []
  type: TYPE_NORMAL
- en: In R, it is very easy to generate random numbers following a statistical distribution.
    The most commonly used two distributions are uniform distribution and normal distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a statistical sense, it is equally probable to draw any value from a uniform
    distribution within a given range. We can call `runif(n)` to generate `n` random
    numbers from a uniform distribution over **[0,1]**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'To generate random numbers within a non-default interval, specify `min` and `max`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'If we generate 1000 random numbers using `runif(1000)` and draw the points,
    we will get a scatter plot (a plot to show X-Y points) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with random distributions](img/image_05_097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The histogram shows that the random numbers we generated distribute almost evenly
    across each interval from 0 to 1, which is consistent with uniform distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another distribution that is most commonly seen in the real world is the normal
    distribution. Similar to `runif()`, we can use `rnorm()` to generate random numbers
    following a standard normal distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'You may notice that the random generator functions share the same interface.
    The first argument of both `runif()` and `rnorm()` is `n`, the number of values
    to generate, and the rest of the arguments are the parameters of the random distribution
    itself. As for a normal distribution, its parameters are `mean` and standard deviation
    (`sd`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The plot generated is as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with random distributions](img/image_05_098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding graphics, it is obvious that the points are not evenly distributed
    but concentrate on the mean instead. As we know, statistical distributions can
    be described by certain formulas. To access these formulas in theory, R provides
    a family of functions for each built-in random distribution. More specifically,
    for uniform distribution, R provides its probability density function `dunif()`,
    cumulative density function `punif()`, quantile function `qunif()`, and random
    generator `runif()`. For normal distribution, the corresponding names are `dnorm()`, `pnorm()`,
    and `qnorm()`. The same naming scheme of density function, cumulative density
    function, quantile function, as well as random generator also applies to other
    distributions R supports.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to these two most commonly used statistical distributions, R also
    provides functions for discrete distributions, such as binomial distribution,
    and continuous distributions, such as exponential distribution. You can run `?Distributions`
    to see a full list of supported distributions. The features of those distributions
    are beyond the scope of this book. If you are not familiar with them but are interested
    in the features of these distributions, you may read any textbook  on probability
    theory or visit Wikipedia ([https://en.wikipedia.org/wiki/Probability_distribution](https://en.wikipedia.org/wiki/Probability_distribution))
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: R supports many distributions, and each of them has corresponding functions.
    Fortunately we don't need to remember a lot of different function names because
    they all follow the same naming convention.
  prefs: []
  type: TYPE_NORMAL
- en: Computing summary statistics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a given dataset, we often need some summary statistics to get an initial
    impression on it. R provides a set of functions to compute summary statistics
    for a numeric vector, including mean, median, standard deviation, variance, maximum,
    minimum, range, and quantiles. For multiple numeric vectors, we can compute the
    covariance matrix and correlation matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following examples show how we use the built-in functions to compute these
    summary statistics. First, we generate a random numeric vector of length 50 from
    standard normal distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'To compute the arithmetic sample mean value of `x`, we call `mean()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'This is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'However, `mean()` supports trimming a fraction of observations from each end
    of the input data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: If `x` contains a few outliers far from other values, the mean value obtained
    from the preceding equation should be more robust since the outliers are omitted
    from the input.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative measure of the representative location of a sample data is the
    sample median. For a given sample, half of the observations are higher than the
    median, and the other half are lower than the median. The median can be a robust
    measure if there are a few extreme values in the data. For `x`, the sample median
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to location measures such as mean and median, variation measures
    are important too. To compute the standard deviation of a numeric vector, we use
    `sd()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'To compute the variance, we use `var()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'To simply get the extreme values in the data, we use `min()` and `max()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use `range()` to directly get both:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, the data is not regularly distributed. In this case, the location
    measures and variation measures suffer from such irregularity and may produce
    misleading results. Here, we should probably take a look at the values at critical
    quantiles of the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'To see more quantiles, specify more values for the `probs` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'If the data is not regularly distributed, the gap of values between two quantiles
    can be very large or small, compared to others. A shortcut for this is to use
    `summary()`, which directly gives the most commonly used summary statistics, including
    four quantiles, median, and mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Note that the minimum values and the maximum values are the 0 percent quantile
    and 100 percent quantile, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, `summary()` is a generic function that works for many types of objects
    and has different behaviors. For example, `summary()` works with data frames too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: It can be seen that for a numeric column, `summary()` shows the summary statistics.
    For columns of other types, it may just simply show a table of value occurrences.
  prefs: []
  type: TYPE_NORMAL
- en: Computing covariance and correlation matrix
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding examples introduced the most commonly used summary statistics
    for one vector. For two or more vectors, we can compute the covariance matrix
    and the correlation matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code generates another vector that is correlated with `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'We can compute the covariance between `x` and `y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also compute the correlation coefficient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'These two functions also work with more than two vectors. If we need to compute
    the covariance and correlation matrix of more than two vectors, we need to input
    a matrix or a data frame. In the following example, we generate another random
    vector `z` of the same length of `x`. This time, `z` follows a uniform distribution
    and does not depend on either `x` or `y`. We use `cbind()` to create a three-column
    matrix and compute the covariance matrix of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, we can call `cor()` directly with the matrix to compute the correlation
    matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Since `y` is generated by a linear relationship with `x`, plus some noise, we
    should expect that `x` and `y` are highly correlated, but the same thing should
    not happen with `z`. The correlation matrix looks consistent with our expectation.
    To draw such a conclusion in a statistical sense, we need to perform rigorous
    statistical tests, which is beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Using apply-family functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, we talked about using a `for` loop to repeat evaluating an expression
    with an iterator on a vector or list. In practice, however, the `for` loop is
    almost the last choice because an alternative way is much cleaner and easier to
    write and read when each iteration is independent of each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following code uses `for` to create a list of three independent,
    normally distributed random vectors whose length is specified by vector `len`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example is simple, but the code is quite redundant compared to
    the implementation with `lapply`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: The `lapply` version is much simpler. It applies `rnorm()` on each element in `len`
    and puts each result into a list.
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding example, we should realize that it is only possible if R
    allows us to pass functions as ordinary objects. Fortunately, it is true. Functions
    in R are treated just like objects and can be passed around as arguments, just
    as we showed in the section on numeric methods. This feature largely boosts the
    flexibility of coding.
  prefs: []
  type: TYPE_NORMAL
- en: Each apply-family function is a so-called **higher-order function** that accepts
    a function as an argument. We will introduce this concept in detail later.
  prefs: []
  type: TYPE_NORMAL
- en: lapply
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `lapply()` function, as we previously demonstrated, takes a vector and a
    function as its arguments. It simply applies the function to each element in the
    given vector and finally returns a list that contains all the results.
  prefs: []
  type: TYPE_NORMAL
- en: This function is useful when each iteration is independent of the other. In
    this case, we don't have to explicitly create an iterator.
  prefs: []
  type: TYPE_NORMAL
- en: 'It works not only with vectors but also with lists. Suppose we have a list
    of students:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to create a character vector in which each element is formatted
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `sprintf()` is useful to format text by replacing the placeholders
    (for example, `%s` for string, `%d` for integer) with corresponding input arguments.
    Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, first, we are sure that an iteration is working on `students`, and each
    is independent. In other words, the computation for James has nothing to do with
    that for Jenny, and so on. Therefore, we can use `lapply` to do the work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses an anonymous function which is a function that is not
    assigned to a symbol. In other words, the function is only temporal and has no
    name. Of course, we can explicitly bind the function to a symbol, that is, give
    it a name, and use that name in `lapply`.
  prefs: []
  type: TYPE_NORMAL
- en: Despite this, the code is quite straightforward. For each element `s` in `students`,
    the function decides the type of the student and pastes their interests together,
    separated by commas. It then puts the information in a format we want.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, a major part of how we use `lapply` also works with other apply-family
    functions, but their iterating mechanism or the type of results may be different.
  prefs: []
  type: TYPE_NORMAL
- en: sapply
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: List is not always a favorable container for the results. Sometimes, we want
    them to be put in a simple vector or a matrix. The `sapply` function simplifies
    the result according to its structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we apply a square on each element of `1:10`. If we do it with `lapply`,
    we will have a list of squared numbers. This result looks a bit heavy and redundant
    because the resulted list is actually a list of single-valued numeric vectors.
    However, we might want to keep the results still as a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'If the applying function returns a multi-element vector each time, `sapply`
    will put the results into a matrix in which each returned vector occupies a column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: vapply
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although `sapply` is very handy and smart, the smartness may sometimes become
    a risk. Suppose we have a list of input numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to get a numeric vector of the squared numbers for each number in
    `x`, `sapply` can be easy to use because it automatically tries to simplify the
    data structure of the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if the input data has some mistakes or corruption, `sapply()` will
    silently accept the input and may return an unexpected value. For example, let''s
    assume that the third element of `x` has mistakenly got an additional element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, `sapply()` finds that it can no longer be simplified to a matrix and
    thus returns a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use `vapply()` in the first place, the mistake will be spotted very soon.
    The `vapply()` function has an additional argument that specifies the template
    of the returned value from each iteration. In the following code, the template
    is `numeric(2)`, which means each iteration should return a numeric vector of
    two elements. If the template is violated, the function will end up in an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'For the original and correct input, `vapply()` returns exactly the same matrix
    as `sapply()` did:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: In conclusion, `vapply` is the safer version of `sapply` as it performs additional
    template checking. In practical use, if the template can be determined, it is
    better to use `vapply()` than `sapply()`.
  prefs: []
  type: TYPE_NORMAL
- en: mapply
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While `lappy()` and `sapply()` both iterate over one vector, `mapply()` iterates
    over multiple vectors. In other words, `mapply` is a multivariate version of `sapply`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'The iterating function is allowed to return not only scalar values but multi-element
    vectors. Then, `mapply()` will simplify the result, just like `sapply()` does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '`Map` is the multivariate version of `lapply` and hence, always returns a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: apply
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `apply` function applies a function on a given margin or dimension of a
    given matrix or array. For example, to calculate the sum of each row, which is
    the first dimension, we need to specify `MARGIN = 1` so that `sum` is applied
    to a row (numeric vector) sliced from the matrix in each iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'To calculate the sum of each column, which is the second dimension, we need
    to specify `MARGIN=2` so that `sum` is applied to a column sliced from `mat` in
    each iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'The `apply` function also supports array input and matrix output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'To build a matrix that shows the max and min value for each column, run the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'To build a matrix that shows the max and min value for each row, run the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to work basic objects by demonstrating the
    use of built-in functions. They are the vocabulary of R in practice. You learned
    some basic functions to test and get object types and to access and reshape data
    dimensions. You learned about a number of logical operators and functions to filter
    data.
  prefs: []
  type: TYPE_NORMAL
- en: To work with numeric data structures, you learned basic math functions, built-in
    numeric methods to find roots and do calculus, and some statistical functions
    to perform random sampling and make summaries of data. You also understood the
    apply-family functions that make it easier to iterate and collect results.
  prefs: []
  type: TYPE_NORMAL
- en: Another important category of data is string, which is represented by character
    vectors. In the next chapter, you will learn string-manipulation techniques to
    facilitate text analysis.
  prefs: []
  type: TYPE_NORMAL
