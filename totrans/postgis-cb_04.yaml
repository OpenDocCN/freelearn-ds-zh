- en: Working with Vector Data – Advanced Recipes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与矢量数据一起工作 - 高级技巧
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Improving proximity filtering with KNN
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 KNN 改进邻近过滤
- en: Improving proximity filtering with KNN – advanced
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 KNN 改进邻近过滤 - 高级
- en: Rotating geometries
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转几何形状
- en: Improving ST_Polygonize
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进 ST_Polygonize
- en: Translating, scaling, and rotating geometries – advanced
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平移、缩放和旋转几何形状 - 高级
- en: Detailed building footprints from LiDAR
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从激光雷达获取详细的建筑足迹
- en: Creating a fixed number of clusters from a set of points
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一组点创建固定数量的聚类
- en: Calculating a Voronoi diagrams
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算 Voronoi 图
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Beyond being a spatial database with the capacity to store and query spatial
    data, PostGIS is a very powerful analytical tool. What this means to the user
    is a tremendous capacity to expose and encapsulate deep spatial analyses right
    within a PostgreSQL database.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 除了作为一个能够存储和查询空间数据的空间数据库之外，PostGIS 还是一个非常强大的分析工具。这意味着对于用户来说，在 PostgreSQL 数据库中暴露和封装深层空间分析的能力是巨大的。
- en: 'The recipes in this chapter can roughly be divided into four main sections:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的食谱大致可以分为四个主要部分：
- en: 'Highly optimized queries:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高度优化的查询：
- en: Improving proximity filtering with KNN
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 KNN 改进邻近过滤
- en: Improving proximity filtering with KNN – advanced
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 KNN 改进邻近过滤 - 高级
- en: 'Using the database to create and modify geometries:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据库创建和修改几何形状：
- en: Rotating geometries
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转几何形状
- en: Improving ST_Polygonize
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进 ST_Polygonize
- en: Translating, scaling, and rotating geometries – advanced
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平移、缩放和旋转几何形状 - 高级
- en: Getting detailed building footprints from LiDAR
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从激光雷达获取详细的建筑足迹
- en: 'Creating a fixed number of clusters from a set of points:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一组点创建固定数量的聚类：
- en: Using the PostGIS function, `ST_ClusterKMeans`, to create K clusters from a
    set of points
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 PostGIS 函数 `ST_ClusterKMeans` 从一组点创建 K 个聚类
- en: Using a minimum bounding circle to visually represent the clusters with the `ST_
    MinimumBoundingCircle` function
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用最小边界圆通过 `ST_MinimumBoundingCircle` 函数可视地表示聚类
- en: 'Calculating a Voronoi diagram:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算 Voronoi 图：
- en: Using the `ST_VoronoiPolygon` function in order to calculate Voronoi diagrams
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ST_VoronoiPolygon` 函数来计算 Voronoi 图
- en: Improving proximity filtering with KNN
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 KNN 改进邻近过滤
- en: The basic question that we seek to answer in this recipe is the fundamental
    distance question, *which are the five coffee shops closest to me?* It turns out
    that while it is a fundamental question, it's not always easy to answer, though
    we will make this possible in this recipe. We will approach this in two steps.
    The first step with which we'll approach this is in a simple heuristic way, which
    will allow us to come to a solution quickly. Then, we'll take advantage of the
    deeper PostGIS functionality to make the solution faster and more general with
    a **k-Nearest Neighbor** (**KNN**) approach.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个食谱中试图回答的基本问题是基本距离问题，*离我最近的五家咖啡店是哪些？* 虽然这是一个基本问题，但并不总是容易回答，尽管我们将在本食谱中使其成为可能。我们将分两步进行。第一步我们将以简单启发式的方式接近这个问题，这将使我们能够快速找到解决方案。然后，我们将利用更深入的
    PostGIS 功能，通过 **k-Nearest Neighbor** （**KNN**）方法使解决方案更快、更通用。
- en: A concept that we need to understand from the outset is that of a spatial index.
    A spatial index, like other database indexes, functions like a book index. It
    is a special construct to make looking for things inside our table easier, much
    in the way a book index helps us find content in a book faster. In the case of
    a spatial index, it helps us find faster ways, when things are in space. Therefore,
    by using a spatial index in our geographic searches, we can speed up our searches
    by orders of magnitude.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一开始就需要理解的一个概念是空间索引。空间索引，就像其他数据库索引一样，就像一本书的索引一样工作。它是一个特殊的结构，使得在表中查找内容变得更加容易，就像书索引帮助我们更快地找到书中的内容一样。在空间索引的情况下，它帮助我们找到在空间中查找事物更快的方法。因此，通过在我们的地理搜索中使用空间索引，我们可以以数量级的方式加快搜索速度。
- en: To learn more about spatial indexes, see [http://en.wikipedia.org/wiki/Spatial_index#Spatial_index](http://en.wikipedia.org/wiki/Spatial_index#Spatial_index).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于空间索引的信息，请参阅 [http://en.wikipedia.org/wiki/Spatial_index#Spatial_index](http://en.wikipedia.org/wiki/Spatial_index#Spatial_index)。
- en: Getting ready
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will start by loading our data. Our data is the address records from Cuyahoga
    County, Ohio, USA:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先加载数据。我们的数据是美国俄亥俄州库耶霍加县的地址记录：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As this dataset may take a while to load, you can alternatively load a subset:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此数据集可能需要一段时间才能加载，您可以另外加载一个子集：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We specified the `-I` flag in order to request that a spatial index be created
    upon the import of this data.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定了`-I`标志，以便在导入这些数据时创建空间索引。
- en: 'Let us start by seeing how many records we are dealing with:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看我们正在处理多少条记录：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We have, in this address table, almost half a million address records, which
    is not an insubstantial number to perform a query.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个地址表中，我们几乎有五十万个地址记录，这对于执行查询来说不是一个小数目。
- en: How to do it...
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: KNN is an approach of searching for an arbitrary number of points closest to
    a given point. Without the right tools, this can be a very slow process that requires
    testing the distance between the point of interest and all the possible neighbors.
    The problem with this approach is that the search becomes exponentially slower
    with a greater number of points. Let's start with this naive approach and then
    improve on it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: KNN是一种寻找与给定点最近的任意数量点的搜索方法。如果没有合适的工具，这可能会是一个非常缓慢的过程，需要测试感兴趣点与所有可能的邻居之间的距离。这种方法的缺点是，随着点的数量增加，搜索速度会呈指数级下降。让我们从这种朴素的方法开始，然后对其进行改进。
- en: 'Suppose we were interested in finding the 10 records closest to the geographic
    location -81.738624, 41.396679\. The naive approach would be to transform this
    value into our local coordinate system and compare the distance to each point
    in the database from the search point, order those values by distance, and limit
    the search to the first 10 closest records (it is not recommended that you run
    the following query as it could run indefinitely):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们感兴趣的是找到距离地理坐标-81.738624, 41.396679最近的10条记录。朴素的方法是将这个值转换成我们的本地坐标系，并从搜索点比较数据库中每个点到点的距离，按距离排序，并将搜索限制在最近的10条记录（不建议运行以下查询，因为它可能会无限期地运行）：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is a fine approach for smaller datasets. This is a logical, simple, fast
    approach for a relatively small numbers of records; however, this approach scales
    very poorly, getting exponentially slower with the addition of records (with 500,000
    points, this would take a very long time).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于较小的数据集，这是一个很好的方法。对于相对较小的记录数量，这是一个逻辑简单、快速的方法；然而，这种方法的可扩展性非常差，随着记录的增加，速度会呈指数级下降（有50万个点时，这将花费很长时间）。
- en: 'An alternative is to only compare the point of interest to the ones known to
    be close by setting a search distance. So, for example, in the following diagram,
    we have a star that represents the current location, and we want to know the 10
    closest addresses. The grid in the diagram is 100 feet long, so we can search
    for the points within 200 feet, then measure the distance to each of these points,
    and return the closest 10 points:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是仅将感兴趣点与已知靠近的点进行比较，通过设置搜索距离。例如，在下面的图中，我们有一个代表当前位置的星号，我们想知道最近的10个地址。图中的网格长度为100英尺，因此我们可以在200英尺范围内搜索点，然后测量这些点到每个点的距离，并返回最近的10个点：
- en: '![](img/f955df93-9fac-4334-9970-590159d7af79.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f955df93-9fac-4334-9970-590159d7af79.png)'
- en: 'Thus, our approach to answer this question is to limit the search using the
    `ST_DWithin` operator to only search for records within a certain distance. `ST_DWithin`
    uses our spatial index, so the initial distance search is fast and the list of
    returned records should be short enough to do the same pair-wise distance comparison
    we did earlier in this section. In our case here, we could limit the search to
    within 200 feet:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们回答这个问题的方法是通过使用`ST_DWithin`运算符限制搜索，只搜索一定距离内的记录。`ST_DWithin`使用我们的空间索引，因此初始距离搜索很快，返回的记录列表应该足够短，以便进行与之前在本节中相同的成对距离比较。在我们的案例中，我们可以将搜索限制在200英尺以内：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output for the previous query is as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 之前查询的输出如下：
- en: '![](img/d5dd72ff-d4fd-453d-965a-1ef237c81bba.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d5dd72ff-d4fd-453d-965a-1ef237c81bba.png)'
- en: This approach performs well so long as our search window, `ST_DWithin`, is the
    right size for the data. The problem with this approach is that, in order to optimize
    it, we need to know how to set a search window that is about the right size. Any
    larger than the right size and the query will run more slowly than we'd like.
    Any smaller than the right size and we might not get all the points back that
    we need. Inherently, we don't know this ahead of time, so we can only hope for
    the best guess.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们的搜索窗口`ST_DWithin`适合数据，这种方法就会表现良好。这种方法的缺点是，为了优化它，我们需要知道如何设置一个大致合适的搜索窗口。如果比合适的尺寸大，查询将比我们希望的运行得更慢。如果比合适的尺寸小，我们可能不会得到我们需要的所有点。本质上，我们事先不知道这一点，所以我们只能寄希望于最好的猜测。
- en: 'In this same dataset, if we apply the same query in another location, the output
    will return no points because the 10 closest points are further than 200 feet
    away. We can see this in the following diagram:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个相同的数据集中，如果我们将在另一个位置应用相同的查询，输出将返回没有点，因为最近的10个点距离超过200英尺。我们可以在下面的图中看到这一点：
- en: '![](img/5adf9ef6-709d-4f4f-9d36-289a4e6b6d01.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5adf9ef6-709d-4f4f-9d36-289a4e6b6d01.png)'
- en: Fortunately, for PostGIS 2.0+ we can leverage the distance operators (`<->`
    and `<#>`) to do indexed nearest neighbor searches. This makes for very fast KNN
    searches that don't require us to guess ahead of time how far away we need to
    search. Why are the searches fast? The spatial index helps of course, but in the
    case of the distance operator, we are using the structure of the index itself,
    which is hierarchical, to very quickly sort our neighbors.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，对于PostGIS 2.0+，我们可以利用距离运算符（`<->`和`<#>`）来进行索引最近邻搜索。这使得KNN搜索非常快，而且不需要我们提前猜测需要搜索多远。为什么搜索这么快？当然，空间索引有所帮助，但在距离运算符的情况下，我们正在使用索引本身的分层结构，以非常快速地排序我们的邻居。
- en: 'When used in an `ORDER BY` clause, the distance operator uses the index:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当在`ORDER BY`子句中使用时，距离运算符使用索引：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This approach requires no prior knowledge of how far the nearest neighbors might
    be. It also scales very well, returning thousands of records in not more than
    the time it takes to return a few records. It is sometimes slower than using `ST_DWithin`,
    depending on how small our search distance is and how large the dataset we are
    dealing with is. But the trade-off is that we don't need to make a guess of our
    search distance and for large queries, it can be much faster than the naive approach.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法不需要事先知道最近邻可能有多远。它也具有良好的可扩展性，在返回少量记录所需的时间内可以返回数千条记录。它有时比使用`ST_DWithin`慢，这取决于我们的搜索距离有多小以及我们处理的数据集有多大。但权衡是，我们不需要猜测搜索距离，对于大型查询，它可能比原始方法快得多。
- en: How it works...
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: What makes this magic possible is that PostGIS uses an R-tree index. This means
    that the index itself is sorted hierarchically based on spatial information. As
    demonstrated, we can leverage the structure of the index in sorting distances
    from a given arbitrary location, and thus use the index to directly return the
    sorted records. This means that the structure of the spatial index itself helps
    us answer such fundamental questions quickly and inexpensively.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使这种魔法成为可能的是，PostGIS使用R树索引。这意味着索引本身是根据空间信息进行分层排序的。正如演示的那样，我们可以利用索引的结构来对从给定任意位置的距离进行排序，从而直接使用索引返回排序后的记录。这意味着空间索引的结构本身帮助我们快速且经济地回答这样的基本问题。
- en: More information about KNN and R-tree can be found at [http://workshops.boundlessgeo.com/postgis-intro/knn.html](http://workshops.boundlessgeo.com/postgis-intro/knn.html)
    and [https://en.wikipedia.org/wiki/R-tree](https://en.wikipedia.org/wiki/R-tree).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 关于KNN和R树的更多信息可以在[http://workshops.boundlessgeo.com/postgis-intro/knn.html](http://workshops.boundlessgeo.com/postgis-intro/knn.html)和[https://en.wikipedia.org/wiki/R-tree](https://en.wikipedia.org/wiki/R-tree)找到。
- en: See also
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Improving proximity filtering with KNN – advanced* recipe
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用KNN改进邻近度过滤 – 高级*配方'
- en: Improving proximity filtering with KNN – advanced
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用KNN改进邻近度过滤 – 高级
- en: In the preceding recipe, we wanted to answer the simple question of which are
    the nearest 10 locations to a given point. There is another simple question with
    a surprisingly sophisticated answer. The question is how do we approach this problem
    when we want to traverse an entire dataset and test each record for its nearest
    neighbors?
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配方中，我们想要回答一个简单的问题：给定点的最近10个位置是哪些。还有一个简单的问题，其答案却出人意料地复杂。问题是，当我们想要遍历整个数据集并测试每个记录的最近邻时，我们如何解决这个问题？
- en: 'Our problem is as follows: for each point in our table, we are interested in
    the angle to the nearest object in another table. A case demonstrating this scenario
    is if we want to represent address points as building-like squares rotated to
    align with an adjacent road, similar to the historic **United States Geological
    Survey** (**USGS**) quadrangle maps, as shown in the following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的问题如下：对于表格中的每个点，我们感兴趣的是到另一个表格中最近物体的角度。一个演示这种场景的例子是，如果我们想将地址点表示为与相邻道路对齐的类似建筑的方块，类似于历史上的**美国地质调查局**（**USGS**）四边形地图，如下面的截图所示：
- en: '![](img/7a57964b-3e25-475a-a04b-49fb729b4a2f.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a57964b-3e25-475a-a04b-49fb729b4a2f.png)'
- en: For larger buildings, USGS quads show the buildings' footprints, but for residential
    buildings below their minimum threshold, the points are just rotated squares—a
    nice cartographic effect that could easily be replicated with address points.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更大的建筑，USGS四分图显示了建筑的足迹，但对于低于其最小阈值的住宅建筑，点只是旋转的正方形——这是一种很好的制图效果，可以用地址点轻松复制。
- en: Getting ready
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'As in the previous recipe, we will start off by loading our data. Our data
    is the address records from Cuyahoga County, Ohio, USA. If you loaded this in
    the previous recipe, there is no need to reload the data. If you have not loaded
    the data yet, run the following command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的配方一样，我们将从加载数据开始。我们的数据是美国俄亥俄州库亚霍加县的地址记录。如果您在之前的配方中已加载此数据，则无需重新加载数据。如果您尚未加载数据，请运行以下命令：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As this dataset may take a while to load, you can alternatively load a subset
    using the following command:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个数据集可能需要一段时间才能加载，您可以使用以下命令加载一个子集：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The address points will serve as a proxy for our building structures. However,
    to align our structure to the nearby streets, we will need a `streets` layer.
    We will use Cuyahoga County''s street centerline data for this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 地址点将作为我们建筑结构的代理。然而，为了将我们的结构对齐到附近的街道，我们需要一个`streets`层。我们将使用库亚霍加县的街道中心线数据：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Before we commence, we have to consider another aspect of using indexes, which
    we didn't need to consider in our previous KNN recipe. When our KNN approach used
    only points, our indexing was exact—the bounding box of a point is effectively
    a point. As bounding boxes are what indexes are built around, our indexing estimates
    of distance perfectly reflected the actual distances between our points. In the
    case of non-point geometries, as is our example here, the bounding box is an approximation
    of the lines to which we will be comparing our points. Put another way, what this
    means is that our nearest neighbor may not be our very nearest neighbor, but is
    likely our approximate nearest neighbor, or one of our nearest neighbors.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们必须考虑使用索引的另一个方面，这是我们之前KNN配方中不需要考虑的。当我们的KNN方法只使用点时，我们的索引是精确的——点的边界框实际上就是一个点。由于边界框是索引建立的基础，我们的索引距离估计完美地反映了我们点之间的实际距离。在我们的例子中，即非点几何的情况下，边界框是我们将要比较的点所在线的近似。换句话说，这意味着我们的最近邻可能不是我们非常近的邻居，但很可能是我们的近似最近邻，或者是我们最近邻之一。
- en: 'In practice, we apply a heuristic approach: we simply gather slightly more
    than the number of nearest neighbors we are interested in and then sort them based
    on the actual distance in order to gather only the number we are interested in.
    In this way, we only need to sort a small number of records.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，我们采用一种启发式方法：我们简单地收集比我们感兴趣的最近邻数量稍多的记录，然后根据实际距离对它们进行排序，以便只收集我们感兴趣的记录。这样，我们只需要对少量记录进行排序。
- en: How to do it...
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Insofar as KNN is a nuanced approach to these problems, forcing KNN to run on
    all the records in a dataset takes what I like to call a venerable and age-old
    approach. In other words, it requires a bit of a hack.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于KNN是解决这些问题的细微方法，强迫KNN在数据集的所有记录上运行，我称之为一种古老而值得尊敬的方法。换句话说，这需要一点点的“黑客”技巧。
- en: 'More on the general solution to using KNN within a function can be found in
    Alexandre Neto''s post on the PostGIS users list at the following link:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于在函数中使用KNN的一般解决方案，可以在Alexandre Neto在PostGIS用户列表上的帖子中找到，链接如下：
- en: '[http://lists.osgeo.org/pipermail/postgis-users/2012-May/034017.html](http://lists.osgeo.org/pipermail/postgis-users/2012-May/034017.html)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://lists.osgeo.org/pipermail/postgis-users/2012-May/034017.html](http://lists.osgeo.org/pipermail/postgis-users/2012-May/034017.html)'
- en: In SQL, the typical way to loop is to use a `SELECT` statement. For our case,
    we don't have a function that does KNN looping through the records in a table
    to use; we simply have an operator that allows us to efficiently order our returning
    records by distance from a given record. The workaround is to write a temporary
    function and thus be able to use `SELECT` to loop through the records for us.
    The cost is the creation and deletion of the function, plus the work done by the
    query, and the combination of costs is well worth the *hackiness* of the approach.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQL中，典型的循环方式是使用`SELECT`语句。在我们的情况下，我们没有函数可以通过在表中的记录上执行KNN循环来使用；我们只有一个允许我们按给定记录的距离有效地排序返回记录的操作符。解决方案是编写一个临时函数，从而能够使用`SELECT`为我们循环记录。代价是函数的创建和删除，以及查询的工作，这两种代价的组合是这种方法的“黑客式”的代价。
- en: 'First, consider the following function:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，考虑以下函数：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we can use this function quite easily:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以非常容易地使用这个函数：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you have loaded the whole address dataset, this will take a while.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经加载了整个地址数据集，这将需要一段时间。
- en: 'If we choose to, we can optionally drop the function so that extra functions
    are not left in our database:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择，我们可以选择性地删除函数，这样就不会在我们的数据库中留下额外的函数：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the next recipe, *Rotating geometries*, the calculated angle will be used
    to build new geometries.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个菜谱中，*旋转几何形状*，将使用计算出的角度来构建新的几何形状。
- en: How it works...
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Our function is simple, KNN magic aside. As an input to the function, we allow
    geometry, as shown in the following query:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的功能很简单，除了KNN魔法之外。作为函数的输入，我们允许几何形状，如下面的查询所示：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding function returns a floating-point value.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数返回一个浮点值。
- en: 'We then use a `WITH` statement to create a temporary table, which returns the
    five closest lines to our point of interest. Remember, as the index uses bounding
    boxes, we don''t really know which line is the closest, so we gather a few extra
    points and then filter them based on distance. This idea is implemented in the
    following query:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`WITH`语句创建一个临时表，该表返回到我们感兴趣点的五个最近线。记住，由于索引使用边界框，我们实际上不知道哪条线是最接近的，所以我们收集一些额外的点，然后根据距离过滤它们。这个想法在以下查询中实现：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that we are actually returning to columns. The first column is `dist,`
    in which we calculate the distance to the nearest five road lines. Note that this
    operation is performed after the `ORDER BY` and `LIMIT` functions have been used
    as filters, so this does not take much computation. Then, we use `ST_Azimuth`
    to calculate the angle from our point to the closest points (`ST_ClosestPoint`)
    on each of our nearest five lines. In summary, what returns with our temporary
    `index_query` table is the distance to the nearest five lines and the respective
    rotation angles to the nearest five lines.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们实际上是在返回到列。第一列是`dist`，在其中我们计算到最近五条道路线的距离。注意，这个操作是在使用`ORDER BY`和`LIMIT`函数作为过滤器之后执行的，所以这并不需要太多的计算。然后，我们使用`ST_Azimuth`来计算从我们的点到最近五条线上的最近点的角度。总的来说，我们的临时`index_query`表返回的是到最近五条线的距离以及到最近五条线的相应旋转角度。
- en: 'If we recall, however, we were not looking for the angle to the nearest five
    but to the true nearest road line. For this, we order the results by distance
    and further use `LIMIT 1`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们回想起来，我们寻找的不是到最近的五个角度，而是到真正的最近道路线的角度。为此，我们按距离排序结果，并进一步使用`LIMIT 1`：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: See also
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Improving proximity filtering with KNN* recipe
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用KNN改进邻近过滤*菜谱'
- en: Rotating geometries
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 旋转几何形状
- en: Among the many functions that PostGIS provides, geometry manipulation is a very
    powerful addition. In this recipe, we will explore a simple example of using the
    `ST_Rotate` function to rotate geometries. We will use a function from the *Improving
    proximity filtering with KNN – advanced* recipe to calculate our rotation values.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在PostGIS提供的许多函数中，几何形状操作是一个非常强大的补充。在这个菜谱中，我们将探索使用`ST_Rotate`函数旋转几何形状的简单示例。我们将使用*使用KNN改进邻近过滤
    - 高级*菜谱中的函数来计算我们的旋转值。
- en: Getting ready
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: '`ST_Rotate` has a few variants: `ST_RotateX`, `ST_RotateY`, and `ST_RotateZ`,
    with the `ST_Rotate` function serving as an alias for `ST_RotateZ`. Thus, for
    two-dimensional cases, `ST_Rotate` is a typical use case.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`ST_Rotate`有几个变体：`ST_RotateX`、`ST_RotateY`和`ST_RotateZ`，其中`ST_Rotate`函数是`ST_RotateZ`的别名。因此，对于二维情况，`ST_Rotate`是一个典型用例。'
- en: In the *Improving proximity filtering with KNN – advanced* recipe, our function
    calculated the angle to the nearest road from a building's centroid or address
    point. We can symbolize that building's point according to that rotation factor
    as a square symbol, but more interestingly, we can explicitly build the area of
    that footprint in real space and rotate it to match our calculated rotation angle.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在*使用KNN改进邻近过滤 - 高级*菜谱中，我们的函数计算了从建筑中心点或地址点到最近道路的角度。我们可以根据那个旋转因子将那个建筑点的位置表示为一个正方形符号，但更有趣的是，我们可以明确地在实际空间中构建该足迹区域，并将其旋转以匹配我们计算出的旋转角度。
- en: How to do it...
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Recall our function from the *Improving proximity filtering with KNN – advanced*
    recipe:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下*使用KNN改进邻近过滤 - 高级*菜谱中的函数：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This function will calculate the geometry''s angle to the nearest road line.
    Now, to construct geometries using this calculation, run the following function:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将计算几何形状到最近道路线的角度。现在，为了使用这个计算构建几何形状，运行以下函数：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the first step, we are taking each of the points and first applying a buffer
    of 20 feet to them:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们对每个点首先应用20英尺的缓冲区：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, we calculate the envelope of the buffer, providing us with a square around
    that buffered area. This is a quick and easy way to create a square geometry of
    a specified size from a point:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们计算缓冲区的边界，为我们提供了一个围绕该缓冲区的正方形。这是从点创建指定大小正方形几何体的快速简单方法：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, we use `ST_Rotate` to rotate the geometry to the appropriate angle.
    Here is where the query becomes harder to read. The `ST_Rotate` function takes
    two arguments:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `ST_Rotate` 将几何体旋转到适当的角。在这里，查询变得难以阅读。`ST_Rotate` 函数接受两个参数：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The geometry we are using is the newly calculated geometry from the buffering
    and envelope creation. The angle is the one we calculate using our `chp04.angle_to_street`
    function. Finally, the origin around which we rotate is the input point itself,
    resulting in the following portion of our query:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用的是从缓冲和边界创建中计算出的新几何体。角度是我们使用 `chp04.angle_to_street` 函数计算出的角度。最后，我们旋转的起点是输入点本身，导致以下查询部分：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This gives us some really nice cartography, as shown in the following diagram:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了一些非常漂亮的制图，如下面的图所示：
- en: '![](img/c7bef09c-e81c-4b13-bd96-394873f1a030.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7bef09c-e81c-4b13-bd96-394873f1a030.png)'
- en: See also
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Improving proximity filtering with KNN – advanced* recipe
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用KNN改进邻近度过滤 - 高级* 方法'
- en: The *Translating, scaling, and rotating geometries – advanced* recipe
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*转换、缩放和旋转几何体 - 高级* 方法'
- en: Improving ST_Polygonize
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进ST_Polygonize
- en: In this short recipe, we will be using a common coding pattern in use when geometries
    are being constructed with `ST_Polygonize` and formalizing it into a function
    for reuse.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的食谱中，我们将使用在构建几何体时使用 `ST_Polygonize` 的常见编码模式，并将其形式化为可重用的函数。
- en: '`ST_Polygonize` is a very useful function. You can pass a set of *unioned*
    lines or an array of lines to `ST_Polygonize`, and the function will construct
    polygons from the input. `ST_Polygonize` does so aggressively insofar as it will
    construct all possible polygons from the inputs. One frustrating aspect of the
    function is that it does not return a multi-polygon, but instead returns a geometry
    collection. Geometry collections can be problematic in third-party tools for interacting
    with PostGIS as so many third party tools don''t have mechanisms in place for
    recognizing and displaying geometry collections.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`ST_Polygonize` 是一个非常有用的函数。你可以向 `ST_Polygonize` 传递一组 *联合* 的线或线数组，该函数将从输入中构建多边形。`ST_Polygonize`
    会非常积极地构建所有可能的多边形。该函数的一个令人沮丧的方面是它不会返回多边形，而是返回一个几何集合。几何集合在第三方工具中与PostGIS交互时可能会出现问题，因为许多第三方工具没有识别和显示几何集合的机制。'
- en: The pattern we will formalize here is the commonly recommended approach for
    changing geometry collections into mutlipolygons when it is appropriate to do
    so. This approach will be useful not only for `ST_Polygonize`, which we will use
    in the subsequent recipe, but can also be adapted for other cases where a function
    returns geometry collections, which are, for all practical purposes, multi-polygons.
    Hence, this is why it merits its own dedicated recipe.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里将形式化的模式是当需要将几何集合转换为多边形时通常推荐的方法。这种方法不仅对 `ST_Polygonize` 有用，我们将在后续的食谱中使用它，还可以适应其他情况，其中函数返回几何集合，在所有实际应用中，这些几何集合都是多边形。因此，它值得有一个专门的食谱。
- en: Getting ready
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The basic pattern for handling geometry collections is to use `ST_Dump` to convert
    them to a dump type, extract the geometry portion of the dump, collect the geometry,
    and then convert this collection into a multi-polygon. The dump type is a special
    PostGIS type that is a combination of the geometries and an index number for the
    geometries. It's typical to use `ST_Dump` to convert from a geometry collection
    to a dump type and then do further processing on the data from there. Rarely is
    a dump object used directly, but it is typically an intermediate type of data.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 处理几何集合的基本模式是使用 `ST_Dump` 将其转换为转储类型，提取转储的几何部分，收集几何体，然后将此集合转换为多边形。转储类型是一种特殊的PostGIS类型，它是几何体和几何体索引号的组合。通常使用
    `ST_Dump` 将几何集合转换为转储类型，然后从那里进一步处理数据。很少直接使用转储对象，但它通常是数据的中介类型。
- en: How to do it...
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'We expect this function to take a geometry and return a multi-polygon geometry:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望这个函数接收一个几何体并返回一个多边形几何体：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For readability, we will use a `WITH` statement to construct the series of
    transformations in geometry. First, we will polygonize:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高可读性，我们将使用`WITH`语句构建几何形状的一系列变换。首先，我们将多边形化：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, we will dump:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将输出：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, we can collect and construct a multi-polygon from our result:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从我们的结果中收集和构建一个多边形：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Put this together into a single function:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些合并成一个单独的函数：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, we can polygonize directly from a set of closed lines and skip the typical
    intermediate step when we use the `ST_Polygonize` function of having to handle
    a geometry collection.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以直接从一组闭合线条中多边形化，并跳过使用`ST_Polygonize`函数时的典型中间步骤，即处理几何集合。
- en: See also
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Translating, scaling, and rotating geometries – advanced* recipe
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*转换、缩放和旋转几何形状 – 高级*菜谱'
- en: Translating, scaling, and rotating geometries – advanced
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换、缩放和旋转几何形状 – 高级
- en: Often, in a spatial database, we are interested in making explicit the representation
    of geometries that are implicit in the data. In the example that we will use here,
    the explicit portion of the geometry is a single point coordinate where a field
    survey plot has taken place. In the following screenshot, this explicit location
    is the dot. The implicit geometry is the actual extent of the field survey, which
    includes 10 subplots arranged in a 5 x 2 array and rotated according to a bearing.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在空间数据库中，我们感兴趣的是明确表示数据中隐含的几何形状。在我们将要使用的示例中，几何形状的显式部分是一个单点坐标，其中进行了现场调查绘图。在下面的屏幕截图中，这个显式位置是点。隐含的几何形状是实际现场调查的范围，包括10个子图，排列成5
    x 2的阵列，并按照方位角旋转。
- en: 'These subplots are the purple squares in the following diagram:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这些子图是以下图中紫色方块：
- en: '![](img/b4f9a6f4-68fb-4557-a442-c966ba78e9b3.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b4f9a6f4-68fb-4557-a442-c966ba78e9b3.png)'
- en: Getting ready
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: There are a number of ways for us to approach this problem. In the interest
    of simplicity, we will first construct our grid and then rotate it in place. Also,
    we could in principle use a `ST_Buffer` function in combination with `ST_Extent`
    to construct the squares in our resultant geometry, but, as `ST_Extent` uses floating-point
    approximations of the geometry for the sake of efficiency, this could result in
    some mismatches at the edges of our subplots.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以解决这个问题。为了简化，我们首先构建我们的网格，然后就地旋转它。此外，原则上我们可以使用`ST_Buffer`函数与`ST_Extent`结合来构建结果几何中的正方形，但是，由于`ST_Extent`为了效率而使用几何形状的浮点近似，这可能导致子图边缘出现一些不匹配。
- en: The approach we will use for the construction of the subplots is to construct
    the grid with a series of `ST_MakeLine` and use `ST_Node` to *flatten* or node
    the results. This ensures that we have all of our lines properly intersecting
    each other. `ST_Polygonize` will then construct our multi-polygon geometry for
    us. We will leverage this function through our wrapper function from the *Improving
    ST_Polygonize* recipe.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建子图的途径是使用一系列`ST_MakeLine`构建网格，并使用`ST_Node`来*展平*或节点化结果。这确保了我们的所有线条都正确地相交。然后`ST_Polygonize`将为我们构建多边形几何形状。我们将通过从*改进ST_Polygonize*菜谱中的包装函数利用这个功能。
- en: Our plots are 10 units on a side, in a 5 x 2 array. As such, we can imagine
    a function to which we pass our plot origin, and the function returns a multi-polygon
    of all the subplot geometries. One additional element to consider is that the
    orientation of the layout of our plots is rotated to a bearing. We expect the
    function to actually use two inputs, so origin and rotation will be the variables
    that we will pass to our function.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的图表边长为10个单位，排列成5 x 2的阵列。因此，我们可以想象一个函数，我们向其中传递我们的图表原点，该函数返回所有子图几何形状的多边形。需要考虑的一个额外元素是，我们图表布局的朝向已经旋转到方位角。我们期望该函数实际上使用两个输入，因此原点和旋转将是我们将传递给函数的变量。
- en: How to do it...
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We can consider geometry and a float value as the inputs, and we want the function
    to return geometry:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将几何形状和浮点值作为输入，并希望函数返回几何形状：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In order to construct the subplots, we will require three lines running parallel
    to the *X* axis:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建子图，我们需要三条与*X*轴平行的线：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And we will require six lines running parallel to the *Y* axis:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要六条与*Y*轴平行的线：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To use these for polygon construction, we will require them to have nodes where
    they cross and touch. A `UNION ALL` function will combine these lines in a single
    record; `ST_Union` will provide the geometric processing necessary to construct
    the nodes of interest and will combine our lines into a single entity ready for
    `chp04.polygonize_to_multi`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要将这些用于多边形构造，我们需要它们在交叉和接触的地方有节点。一个 `UNION ALL` 函数将把这些线合并到单个记录中；`ST_Union` 将提供必要的几何处理来构建感兴趣的节点，并将我们的线合并成一个准备用于
    `chp04.polygonize_to_multi` 的单一实体：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'But we have not created polygons yet, just lines. The final step, using our
    `polygonize_to_multi` function, finishes the work for us:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们还没有创建多边形，只是线。最后一步，使用我们的 `polygonize_to_multi` 函数，为我们完成了工作：
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The combined query is as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 合并查询如下：
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This function, shown in the preceding section, essentially draws the geometry
    from a single input point and rotation value. It does so by using nine instances
    of `ST_MakeLine`. Typically, one might use `ST_MakeLine` in combination with `ST_MakePoint`
    to accomplish this. We bypass this need by having the function consume a point
    geometry as an input. We can, therefore, use `ST_Translate` to move this point
    geometry to the endpoints of the lines of interest in order to construct our lines
    with `ST_MakeLine`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的该函数，本质上是从单个输入点和旋转值中绘制几何形状。它是通过使用九个 `ST_MakeLine` 实例来做到这一点的。通常，人们可能会将 `ST_MakeLine`
    与 `ST_MakePoint` 结合使用来完成这项任务。我们通过使函数消耗一个点几何作为输入来绕过这种需求。因此，我们可以使用 `ST_Translate`
    将此点几何移动到感兴趣线的端点，以便使用 `ST_MakeLine` 构建我们的线。
- en: 'One final step, of course, is to test the use of our new geometry constructing
    function:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，最后一步是测试我们新的几何构造函数的使用：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The different grids generated by the previous functions are the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 之前函数生成的不同网格如下：
- en: '![](img/ac3d5118-8daf-44eb-8849-6361be7f277a.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ac3d5118-8daf-44eb-8849-6361be7f277a.png)'
- en: See also
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Improving ST_Polygonize* recipe
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*改进 ST_Polygonize* 配方'
- en: The *Improving proximity filtering with KNN – advanced* recipe
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 KNN 提高邻近性过滤 - 高级* 配方'
- en: Detailed building footprints from LiDAR
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LiDAR的详细建筑足迹
- en: Frequently, with spatial analyses, we receive data in one form that seems quite
    promising but we need it in another more extensive form. LiDAR is an excellent
    solution for such problems; LiDAR data is laser scanned either from an airborne
    platform, such as a fixed-wing plane or helicopter, or from a ground unit. LiDAR
    devices typically return a cloud of points referencing absolute or relative positions
    in space. As a raw dataset, they are often not as useful as they are once they
    have been processed. Many LiDAR datasets are classified into land cover types,
    so a LiDAR dataset, in addition to having data that contains *x*, *y*, and *z*
    values for all the points sampled across a space, will often contain LiDAR points
    that are classified as ground, vegetation, tall vegetation, buildings, and so
    on.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在空间分析中，我们经常收到一种形式的数据，看起来很有前景，但我们需要的是另一种更广泛的形式。激光雷达是解决这类问题的绝佳方案；激光雷达数据是通过空中平台，如固定翼飞机或直升机，或地面单元进行激光扫描的。激光雷达设备通常返回一个点云，这些点参考空间中的绝对或相对位置。作为一个原始数据集，它们在未经处理的情况下通常不如处理后的有用。许多激光雷达数据集被分类为土地覆盖类型，因此，除了包含空间中所有采样点的
    *x*、*y* 和 *z* 值的数据外，激光雷达数据集通常还包含被分类为地面、植被、高大植被、建筑物等的数据。
- en: 'As useful as this is, the data is intensive, that is, it has discreet points,
    rather than extensive, as polygon representations of such data would be. This
    recipe was developed as a simple method to use PostGIS to transform the intensive
    LiDAR samples of buildings into extensive building footprints:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这很有用，但数据密集，也就是说，它有离散的点，而不是广泛的，因为多边形表示这样的数据将会是广泛的。这个配方被开发为一个简单的方法，使用 PostGIS
    将密集的激光雷达建筑样本转换为广泛的建筑足迹：
- en: '![](img/6e57df89-b74d-4a2a-a83a-b6cbc28a6b75.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e57df89-b74d-4a2a-a83a-b6cbc28a6b75.png)'
- en: Getting ready
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The LiDAR dataset we will use is a 2006 collection, which was classified into
    ground, tall vegetation (> 20 feet), buildings, and so on. One characteristic
    of the analysis that follows is that we assume the classification to be correct,
    and so we are not revisiting the quality of the classification or attempting to
    improve it within PostGIS.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的激光雷达数据集是 2006 年的收集，它被分类为地面、高大植被（> 20 英尺）、建筑物等。接下来分析的一个特点是，我们假设分类是正确的，因此我们不会重新检查分类的质量或尝试在
    PostGIS 中改进它。
- en: A characteristic of the LiDAR dataset is that a sample point exists for relatively
    flat surfaces at approximately no fewer than 1 for every 5 feet. This will inform
    you about how we manipulate the data.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: LiDAR数据集的一个特点是，对于相对平坦的表面，每5英尺至少存在一个样本点。这将告诉你我们如何处理数据。
- en: 'First, let''s load our dataset using the following command:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用以下命令加载数据集：
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How to do it...
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The simplest way to convert point data to polygon data would be to buffer the
    points by their known separation:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 将点数据转换为多边形数据的最简单方法是通过它们的已知分离来缓冲点：
- en: '[PRE34]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can imagine, however, that such a simplistic approach might look strange:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以想象，这种简单的方法可能看起来很奇怪：
- en: '![](img/3cce7f71-f083-4a35-9990-3a393b100a05.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3cce7f71-f083-4a35-9990-3a393b100a05.png)'
- en: 'As such, it would be good to perform a union of these geometries in order to
    dissolve the internal boundaries:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最好将这些几何形状进行合并，以溶解内部边界：
- en: '[PRE35]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, we can see the start of some simple building footprints:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到一些简单建筑轮廓的起点：
- en: '![](img/312afb52-48b9-4d06-8316-e3218c7dea96.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/312afb52-48b9-4d06-8316-e3218c7dea96.png)'
- en: 'While this is marginally better, the result is quite lumpy. We will use the
    `ST_Simplify_PreserveTopology` function to simplify the polygons and then grab
    just the external ring to remove the internal holes:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这略有改善，但结果相当粗糙。我们将使用`ST_Simplify_PreserveTopology`函数简化多边形，然后仅获取外部环以移除内部空洞：
- en: '[PRE36]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, we have simplified versions of our buffered geometries:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了我们缓冲几何形状的简化版本：
- en: '![](img/e1acae8e-9162-4d4b-9563-ef7281bac776.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e1acae8e-9162-4d4b-9563-ef7281bac776.png)'
- en: There are two things to note here. The larger the building, relative to the
    density of the sampling, the better it looks. We might query to eliminate smaller
    buildings, which are likely to degenerate when this approach is used, depending
    on the density of our LiDAR data.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两点需要注意。与采样密度相比，建筑越大，看起来就越好。我们可能会查询以消除较小的建筑，这些建筑在使用这种方法时可能会退化，具体取决于我们LiDAR数据的密度。
- en: How it works...
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To put it informally, our buffering technique effectively lumps together or
    clusters adjacent samples. This is possible only because we have regularly sampled
    data, but that is OK. The density and scan patterns for the LiDAR data are typical
    of such datasets, so we can expect this approach to be applicable to other datasets.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 不正式地说，我们的缓冲技术有效地将相邻样本聚在一起或聚类。这仅因为我们有规则采样数据，但这没关系。LiDAR数据的密度和扫描模式是此类数据集的典型特征，因此我们可以预期这种方法适用于其他数据集。
- en: The `ST_Union` function converts these discreet buffered points into a single
    record with dissolved internal boundaries. To complete the clustering, we simply
    need to use `ST_Dump` to convert these boundaries back to discreet polygons so
    that we can utilize individual building footprints. Finally, we simplify the pattern
    with `ST_SimplifyPreserveTopology` and extract the external ring, or use `ST_ExteriorRing`
    outside these polygons, which removes the holes inside the building footprints.
    Since `ST_ExteriorRing` returns a line, we have to reconstruct our polygon. We
    use `chp04.polygonize_to_multi`, a function we wrote in the *Improving ST_Polygonize*
    recipe, to handle just such occasions. In addition, you can check the *Normalizing
    internal overlays* recipe in [Chapter 2](dec6904b-477f-4c16-a90f-7563a36c4652.xhtml), *Structures
    That Work*, in order to learn how to correct polygons with possible geographical
    errors.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`ST_Union`函数将这些离散缓冲点转换为一个具有溶解内部边界的单一记录。为了完成聚类，我们只需使用`ST_Dump`将这些边界转换回离散多边形，这样我们就可以利用单个建筑轮廓。最后，我们使用`ST_SimplifyPreserveTopology`简化模式并提取外部环，或者在这些多边形外部使用`ST_ExteriorRing`，以移除建筑轮廓内部的空洞。由于`ST_ExteriorRing`返回一条线，我们必须重建我们的多边形。我们使用`chp04.polygonize_to_multi`函数，这是我们写在*改进ST_Polygonize*菜谱中的一个函数，来处理这样的情况。此外，您还可以查看[第2章](dec6904b-477f-4c16-a90f-7563a36c4652.xhtml)中的*正常化内部叠加*菜谱，以了解如何纠正可能存在地理错误的
    polygons。'
- en: Creating a fixed number of clusters from a set of points
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从一组点创建固定数量的聚类
- en: 'In PostGIS version 2.3, some cluster functionalities were introduced. In this
    recipe, we will explore `ST_ClusterKMeans`, a function that aggregates geometries
    into *k* clusters and retrieves the *id* of the assigned cluster for each geometry
    in the input. The general syntax for the function is as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在PostGIS 2.3版本中，引入了一些聚类功能。在这个菜谱中，我们将探索`ST_ClusterKMeans`函数，该函数将几何形状聚合到*k*个聚类中，并为输入中的每个几何形状检索分配的聚类*id*。该函数的一般语法如下：
- en: '[PRE37]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Getting ready
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will use the earthquake dataset included in the source from
    [Chapter 3](68d3e400-24be-4757-ab79-5b395dd79f3c.xhtml), *Working with Vector
    Data – The Basics*, as our input geometries for the function. We also need to
    define the number of clusters that the function will output; the value of *k*
    for this example will be 10\. You could play with this value and see the different
    cluster arrangements the function outputs; the greater the value for *k*, the
    smaller the number of geometries each cluster will contain.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将使用[第3章](68d3e400-24be-4757-ab79-5b395dd79f3c.xhtml)，“使用矢量数据 - 基础”中包含的地震数据集作为函数的输入几何形状。我们还需要定义函数将输出的聚类数量；本例中*k*的值将是10。您可以尝试调整这个值，看看函数输出的不同聚类排列；*k*的值越大，每个聚类包含的几何形状数量就越少。
- en: If you have not previously imported the earthquake data into the [Chapter 3](68d3e400-24be-4757-ab79-5b395dd79f3c.xhtml),
    *Working with Vector Data – The Basics*, schema, refer to the *Getting ready*
    section of the *GIS analysis with spatial joins* recipe.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前没有将地震数据导入到[第3章](68d3e400-24be-4757-ab79-5b395dd79f3c.xhtml)，“使用矢量数据 - 基础”模式，请参阅“准备就绪”部分的“使用空间连接进行GIS分析”食谱。
- en: 'Once we have created the `chp03.earthquake` table, we will need two tables.
    The first one will contain the centroid geometries of the clusters and their respective
    IDs, which the `ST_ClusterKMeans` function retrieves. The second table will have
    the geometries for the minimum bounding circle for each cluster. To do so, run
    the following SQL commands:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了`chp03.earthquake`表，我们还需要两个表。第一个表将包含聚类的质心几何形状及其相应的ID，这是`ST_ClusterKMeans`函数检索到的。第二个表将包含每个聚类的最小边界圆的几何形状。为此，运行以下SQL命令：
- en: '[PRE38]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How to do it...
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will then populate the centroid table by generating the cluster ID for each
    geometry in `chp03.earthquakes` using the `ST_ClusterKMeans` function, and then
    we will use the `ST_Centroid` function to calculate the 10 centroids for each
    cluster:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将通过使用`ST_ClusterKMeans`函数为`chp03.earthquakes`中的每个几何形状生成聚类ID来填充质心表，然后我们将使用`ST_Centroid`函数计算每个聚类的10个质心：
- en: '[PRE39]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If we check the inserted rows with the following command:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用以下命令检查插入的行：
- en: '[PRE40]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output will be as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '![](img/44c789c0-15a0-49db-8617-fb7727593e18.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/44c789c0-15a0-49db-8617-fb7727593e18.png)'
- en: 'Then, insert the corresponding minimum bounding circles for the clusters in
    the `chp04.earthq_circ` table. Execute the following SQL command:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`chp04.earthq_circ`表中插入对应聚类的最小边界圆。执行以下SQL命令：
- en: '[PRE41]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In a desktop GIS, import all three tables as layers (`chp03.earthquakes`, `chp04.earthq_cent`,
    and `chp04.earthq_circ`) in order to visualize them and understand the clustering.
    Note that circles may overlap; however, this does not mean that clusters do as
    well, since each point belongs to one and only one cluster, but the minimum bounding
    circle for a cluster may overlap with another minimum bounding circle for another
    cluster:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在桌面GIS中，将三个表（`chp03.earthquakes`、`chp04.earthq_cent`和`chp04.earthq_circ`）作为图层导入，以便可视化它们并理解聚类。请注意，圆圈可能会重叠；然而，这并不意味着聚类也如此，因为每个点只属于一个聚类，但一个聚类的最小边界圆可能与另一个聚类的最小边界圆重叠：
- en: '![](img/60c745cb-ede9-418c-af5e-9f1d49a93198.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/60c745cb-ede9-418c-af5e-9f1d49a93198.png)'
- en: Calculating Voronoi diagrams
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算Voronoi图
- en: In the 2.3 version, PostGIS provides a way to create Voronoi diagrams from the
    vertices of a geometry; this will work only with versions of GEOS greater than
    or equal to 3.5.0.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在2.3版本中，PostGIS提供了一种从几何形状的顶点创建Voronoi图的方法；这仅适用于GEOS版本大于或等于3.5.0的情况。
- en: 'The following is a Voronoi diagram generated from a set of address points.
    Note how the points from which the diagram was generated are equidistant to the
    lines that divide them. Packed soap bubbles viewed from above form a similar network
    of shapes:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从一组地址点生成的Voronoi图。注意，生成图所用的点与分割它们的线等距。从上方观察到的肥皂泡堆积形成类似形状的网络：
- en: '![](img/1cce9415-80d2-4771-93f1-4da9254591e3.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1cce9415-80d2-4771-93f1-4da9254591e3.png)'
- en: Voronoi diagrams are a space-filling approach that are useful for a variety
    of spatial analysis problems. We can use these to create space filling polygons
    around points, the edges of which are equidistant from all the surrounding points.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Voronoi图是一种空间填充方法，对于各种空间分析问题非常有用。我们可以使用这些方法在点周围创建空间填充多边形，其边缘与所有周围点等距。
- en: 'More information about Voronoi diagrams can be found at the following link:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Voronoi图更详细的信息可以在以下链接中找到：
- en: '[http://en.wikipedia.org/wiki/Voronoi_diagram](http://en.wikipedia.org/wiki/Voronoi_diagram)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[维诺图](http://en.wikipedia.org/wiki/Voronoi_diagram)'
- en: 'The PostGIS function `ST_VoronoiPolygons()`, receives the following parameters:
    a geometry from which to build the Voronoi diagram, a tolerance, which is a float
    that will tell the function the distance within which vertices will be treated
    as equivalent for the output, and an `extent_to` geometry that will tell the extend
    of the diagram if this geometry is bigger than the calculated output from the
    input vertices. For this recipe, we will not use tolerance, which defaults to
    0.0 units, `nor extend_to`, which is set to `NULL` by default.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: PostGIS函数`ST_VoronoiPolygons()`接收以下参数：用于构建Voronoi图的几何形状，一个容差值，它是一个浮点数，将告诉函数在哪个距离内顶点将被视为等效输出，以及一个`extent_to`几何形状，它将告诉如果这个几何形状大于从输入顶点计算出的输出范围，则图的范围。对于这个菜谱，我们将不使用容差，它默认为0.0单位，也不使用`extend_to`，它默认设置为`NULL`。
- en: Getting ready
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will create a small arbitrary point dataset to feed into our function around
    which we will calculate the Voronoi diagram:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个小的任意点数据集，将其输入到我们的函数中，我们将围绕这个函数计算Voronoi图：
- en: '[PRE42]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: How to do it...
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'With preparations in place, now we are ready to create the Voronoi diagram.
    First, we will create the table that will contain the `MultiPolygon`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 准备就绪后，我们现在可以创建Voronoi图。首先，我们将创建一个包含`MultiPolygon`的表：
- en: '[PRE43]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, to calculate the Voronoi diagram, we use `ST_Collect` in order to provide
    a `MultiPoint` object for the `ST_VoronoiPolygons` function. The output of this
    alone would be a `GeometryCollection`; however, we are interested in getting a
    `MultiPolygon` instead, so we need to use the `ST_CollectionExtract` function,
    which when given the number `3` as the second parameter, extracts all polygons
    from a `GeometryCollection`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了计算Voronoi图，我们使用`ST_Collect`来为`ST_VoronoiPolygons`函数提供一个`MultiPoint`对象。仅此输出的结果将是`GeometryCollection`；然而，我们感兴趣的是得到一个`MultiPolygon`，因此我们需要使用`ST_CollectionExtract`函数，当第二个参数为`3`时，它会从一个`GeometryCollection`中提取所有多边形：
- en: '[PRE44]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If we import the layers for `voronoi_test_points` and `voronoi_diagram` into
    a desktop GIS, we get the following Voronoi diagram of the randomly generated
    points:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`voronoi_test_points`和`voronoi_diagram`层导入桌面GIS中，我们得到以下随机生成点的Voronoi图：
- en: '![](img/5ce90b85-864c-4b16-853d-b4be6f6f7c7b.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5ce90b85-864c-4b16-853d-b4be6f6f7c7b.png)'
- en: 'Now we can process much larger datasets. The following is a Voronoi diagram
    derived from the address points from the *Improving proximity filtering with KNN
    – advanced* recipe, with the coloration based on the azimuth to the nearest street,
    also calculated in that recipe:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以处理更大的数据集了。以下是从 *改进KNN的邻近性过滤 - 高级* 菜谱中提取的地址点生成的Voronoi图，颜色基于到最近街道的方位角，该方位角也在该菜谱中计算：
- en: '![](img/8925a02c-213f-409e-be59-8116de57596c.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8925a02c-213f-409e-be59-8116de57596c.png)'
