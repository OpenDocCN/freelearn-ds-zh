- en: Chapter 3. Designing the Visual Look of Our Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now come to the part where we want to design how our application will
    look and feel. For this **graphical user interface** (**GUI**), we take the path
    of least resistance and go with the **Tkinter** library since this is a standard
    built-in library in the official Python installations, at least for Windows and
    Mac. Other reasons for choosing Tkinter is that it is fairly easy to use and is
    slightly more Pythonic than some of the newer third-party GUI libraries.
  prefs: []
  type: TYPE_NORMAL
- en: If you have not used Tkinter before, you should still be able to follow along.
    The basic idea of Tkinter is that you create widget classes for each graphical
    element of your GUI, defining their look and placement. Complex elements can be
    created by nesting widgets within widgets. You can also bind functions to user
    interaction events.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn more about Tkinter, I highly recommend using John W. Shipman's reference
    guide, available from [http://infohost.nmt.edu/tcc/help/pubs/tkinter/tkinter.pdf](http://infohost.nmt.edu/tcc/help/pubs/tkinter/tkinter.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter you will:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up the general code structure to make a themed and highly customizable GIS
    application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a toolbox of specialized user interface widgets that can connect to our
    underlying GIS functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use this toolbox of widgets to glue together the visual design and layout of
    our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to test run our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the GUI package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We begin the chapter by setting up the structural skeleton for our application
    GUI. This should be logically separate from the rest of our code so we give it
    a subpackage of its own. Inside the top level `pythongis` folder, create a package
    folder called `app` with an `__init__.py` file inside it. Have it import the rest
    of the modules we will be creating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To make our `app` package accessible from our top level `pythongis` package,
    we similarly need to import it in `pythongis/__init__.py` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The purpose of the `app` package is that we should be able to define how our
    GUI looks and behaves, and with a single line of code, `pythongis.app.run()`,
    we should be able to invoke it. The actual definition and layout of our GUI should
    be contained in a module we call `app/builder.py` (which we return to at the end
    of the chapter). The builder in turn relies on a set of predefined GUI building
    blocks, which we define in a subpackage folder called `app/toolkit`. This toolkit''s
    `__init__.py` file imports the building block modules that we are going to create
    throughout the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In addition to our builder and toolkit, we also need an `app/dialogues.py` module
    that defines application-specific dialogue windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last but not least, an important part of an application structure is how to
    access icons and images. To make our icons readily available to any widget that
    may need them, we create an `app/icons` package. This `package` folder is where
    we will save all our icons. When an application widget needs an icon, it simply
    asks the `icons` package for the icon name and size via `get()` and in return
    receives a Tkinter compatible `PhotoImage` object. Create its `__init__.py` file
    now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you created all of these, we should be ready to go. Your `app` folder
    structure should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the GUI package](img/5407OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating the toolkit building blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can start designing our GUI layout, we have to create the `toolkit`
    package containing the underlying building blocks or design elements that we will
    be using. Tkinter already provides a set of basic GUI element or **widget** classes,
    such as `Buttons`, `Labels`, or `CheckBoxes`, with methods for placing them in
    the application window or nested within each other. To stay consistent with this
    logic, we subclass these Tkinter widgets and expand on them to make our own specialized
    building block widgets. This way our GUI code becomes consistent, stable, and
    reusable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `toolkit` package, we want to have a few widgets readily available:
    icon buttons, toolbars, a ribbon tab system, a status bar, a panel overview to
    contain data layers, a map widget, and pop-up window templates. We also need a
    way for our buttons to connect with and execute geospatial work tasks from our
    GIS code library, so we make a command dispatch tool. However, before we start
    making widgets, let''s set up an easy way to style them.'
  prefs: []
  type: TYPE_NORMAL
- en: Themed styling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To give our application a sense of style, we have to define things like background
    color or text font in each and every one of our toolkit widgets. To make this
    styling more flexible, we centralize the styling instructions into a separate
    module which we call `app/toolkit/theme.py`. The various widgets can then import
    the styling instructions from this theme module, which can be easily changed and
    modified as we develop our application, or perhaps even as a customizable feature
    by the end user.
  prefs: []
  type: TYPE_NORMAL
- en: 'When specifying colors in Tkinter, you can either specify hex color strings
    or names of colors predefined by Tkinter. Let''s make the main background color
    of our application a light grey, with five different shades all the way up until
    pure white. We also want some more unique colors for highlighting purposes, one
    with two shades of orange, and an alternative one with two shades of blue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the full list of valid Tkinter color names and their appearance, see [http://wiki.tcl.tk/37701](http://wiki.tcl.tk/37701).
  prefs: []
  type: TYPE_NORMAL
- en: 'The type and size of font one uses is also a crucial part of application design,
    so we decide to use the trendy Segoe font used in Windows 8\. Tkinter fonts can
    be specified with a tuple containing the font name, size, and optionally the type
    of emphasis. We create two main shades of text fonts, one normal and one weaker
    one for less important background text. We also create two types of title/header
    text fonts for extra emphasis, one normal and one white, in case we need to display
    text on darker backgrounds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Basic buttons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we can begin making widgets. Although Tkinter already comes with **Button**
    widgets, we will create some of our own so that each button we create is already
    styled in the way that we want, and we can simplify the process of giving them
    icons. Therefore, we create our first module which we call `app/toolkit/buttons.py`
    in the `toolkit` package. At the top, we import some necessary things:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we import our theme module and define the style we will use for buttons
    as dictionary entries. Under normal circumstances we want buttons to have a light
    background color with a flat relief. Once the mouse pointer hovers over the button,
    it *lights up* with a highlight color that turns into an even stronger color if
    clicked on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement a Button widget that follows this style, we make a Button widget
    that subclasses the standard Tkinter button and takes our readily formatted style
    dictionary as keyword arguments. We also define that it should light up as defined
    in our hover-dictionary every time the mouse passes over the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We also add some commonly needed buttons, such as an **Ok** button with an
    *Enter*/*Return* keyboard shortcut that runs a specified function when activated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Buttons with icons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our application, we want to illustrate what our buttons do by using small
    icon images, but as you will soon see, giving icons to buttons in Tkinter requires
    several custom steps that can quickly become a dull task. Therefore, we create
    a specialized icon button that does these steps for us.
  prefs: []
  type: TYPE_NORMAL
- en: To create the `IconButton` class, we take our styled button class as the starting
    point, and all we have to do is add a `set_icon` method. This method retrieves
    the image via the `icons` package with a size that fits the button, styles the
    way the image is placed inside the button, assigns it, and stores it as one of
    the button's attributes so it doesn't get garbage collected.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Toolbars
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Buttons should not just be placed randomly around. Instead, we want to group
    together sets of logically related buttons into areas known as **toolbars**. We
    create the `app/toolkit/toolbars.py` module and start it off with the necessary
    imports and style setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The toolbar area is itself a subclass of the Tkinter frame and will consist
    of a frame area into which buttons will be packed side by side, and a text area
    on the bottom specifying the purpose of the toolbar. For now, we just create the
    generic `Toolbar` class with a convenient `add_button` method so we can later
    build and populate specialized toolbars by subclassing this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The Ribbon tab system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next up is the **Ribbon** widget, which, inspired by newer versions of Microsoft
    Office, will give our application not only a sleek modern look, but also the level
    of organization and simplicity that we need, to avoid scaring off the not-so-technical
    users of our application. Just like related buttons were grouped together into
    toolbars in the previous section, toolbars can here be grouped into the Ribbon
    tab areas at the top of the window that can be switched and flipped-between, like
    a notebook, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Ribbon tab system](img/5407OS_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After creating the `app/toolkit/ribbon.py` module in the `toolkit` package,
    we begin with importing and styling, using a subtle grey highlight effect for
    the tab selectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Ribbon` class itself is a frame, with a top area for tab selectors, and
    the bottom area for displaying the currently selected tab area for related toolbars.
    Tabs are created as separate instances and added with the `add_tab` method, which
    will create a tab selector for that tab, which also lights up when the mouse hovers
    over it. A `switch` method will be called when a tab selector is pushed, which
    raises its tab area into view over all other tabs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When we use the Ribbon''s `add_tab` method it returns to us a `Tab` class,
    which it is up to us to populate with buttons and other content. For convenience,
    we give the `Tab` class an `add_toolbar` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The bottom status bar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another important GUI element is the status bar, which can contain one or more
    pieces of information or statuses and tends to be placed at the bottom of the
    application window meshed into the background. We create the `app/toolkit/statusbar.py`
    module and do the usual imports and styling in the beginning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The StatusBar widget itself is simply a frame that contains one or more status
    widgets. Here is the code for the `StatusBar` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We then make a base class for all status widgets called `Status` and some subclasses
    of it for displaying projection name, zoom level, and mouse pointer coordinates,
    without any event bindings or behavior since this will be controlled by a parent
    widget. A special TaskStatus widget can be set to `start()` and will turn orange
    along with a task description provided by the caller. It will return to normal
    once the `stop` method is called, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The layers pane
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A crucial element in most GIS applications is the layers pane, which displays
    and allows access to the loaded data and shows their symbols and in which order
    they are rendered to the map. After initiating our new `app/toolkit/layers.py`
    module, we start it with some imports and styling. Note that we also import our
    top-level `pythongis` package and our `dispatch` module because this layer''s
    pane needs to be able to load and render data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'For now we only create the styled `LayersPane` class, with a title header text
    saying **Layers** and a main list area where individual loaded layers will show
    up. More about these layer items, how to load them, and their appearance and behavior
    will be dealt with more naturally in [Chapter 4](ch04.html "Chapter 4. Rendering
    Our Geodata"), *Rendering Our Geodata*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The Map widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Last but not least, we cannot have a GIS without a Map widget for interactively
    viewing geographic data. Create the `app/toolkit/map.py` module and start it off
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the layers pane, we begin developing the Map widget more fully in [Chapter
    4](ch04.html "Chapter 4. Rendering Our Geodata"), *Rendering Our Geodata*, so
    for now we only make the initial `MapView` class. Eventually, we want our Map
    widget to be able to hold a rendered map image and let the user pan around and
    zoom in and out of it, so we make it a subclass of the Tkinter **Canvas** widget.
    Since the `MapView` class will be calling some potentially heavy rendering operations
    later on, we also need a way to link it to a status bar in order to report its
    progress:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Pop-up windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Later in the book, there are several times we will need to open additional windows
    on top of our main GUI window, whether it be an error message or an options or
    tool menu. In our `toolkit` package, we therefore want to define some window templates.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These window templates are not the same as the actual windows specific to our
    application, which are defined throughout the book as part of the `app/dialogues.py`
    module we created earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a module for window templating as `app/toolkit/popups.py` and begin
    with some imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create some basic pop-up windows and templates. This includes a simple
    warning `popup_message` function that can be used to raise errors in the GUI,
    as well as a basic `Window` class template with ideal positioning and size, used
    as the starting point for any other window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We also create another template, this time specifically for building tool options
    input frames. This will not be a window, but a Tkinter frame that can be placed
    inside any other widget, representing some tool or functionality where the user
    can customize settings or parameters and decide to run the tool or cancel. Let''s
    create this generic `RunToolFrame` class, which consists of an input area where
    all the options will be built to the left, a help area on the right, and a button
    for running the tool on the bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pop-up windows](img/5407OS_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the code to create the `RunToolFrame` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To make things easier for us later, we also give it simple methods for defining
    which options to pass to the target operation, which it uses to automatically
    create the appropriate input widgets. The most powerful feature here is `add_option_input()`
    which adds a customizable option widget and has several arguments that can be
    tweaked and combined to produce widgets for many different value types. This requires
    two arguments: `label`—the text to display next to the input widget, and `valuetype`—a
    function to convert input values as retrieved from the widget (which is always
    text) into the type that the target operation expects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If no other arguments are specified, this method adds an unnamed list argument
    to the target function, or by specifying `argname` you can make it a keyword argument.
    When the `multi` argument is true, the user is given an entry widget for freely
    typing in values and adding it to a list of option values, and if the `choices`
    argument is also true then the user is limited to choose one or more items from
    a list of choices. Setting the `choices` argument without the `multi` argument
    lets the user choose only a single value from a drop-down list of choices. The
    `default` argument defines the starting value of the widget, and `minval` and
    `maxval` tries to ensure that the final argument is greater than, less than, or
    between certain limits. Finally, there is also an `add_hidden_option` method that
    sets an option without having it show up as customizable widget. Take a look at
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have ways to build a series of customizable parameter widgets in the
    window, but we still do not know what action or target operation should be run
    once the user is ready to run the tool window. This action must be given as a
    function able to receive the input widget parameters to `set_target_method()`.
    Doing so remembers the target function for later and retrieves the `doc` string
    from the given function and displays it to the user in the help area of the window.
    Also, we don''t want to lock the GUI while the function is running, so the target
    function is dispatched in a new thread (more on this shortly). Using `assign_statusbar()`
    lets it inform a linked status bar while awaiting the results. We must also set
    a function to be run once processing the results is finished, using `set_finished_method()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Dispatching heavy tasks to thread workers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In later chapters, we will begin adding a specific GIS code to be run whenever
    we click on different buttons. Many GIS tasks can be quite heavy duty and take
    some time to finish. If we just run this lengthy code from within our Tkinter
    main event handling loop, then we will end up freezing our application while waiting
    for it to finish. To avoid such freezing, the long-running thread must be run
    in a thread other than our GUI, while our GUI checks at regular intervals to see
    if the results are in.
  prefs: []
  type: TYPE_NORMAL
- en: Since we expect to call on such heavy tasks quite frequently via button clicks,
    we simplify the threading procedure by creating an `app/toolkit/dispatch.py` module
    to do the work for us. Whenever a GUI tool or button needs to run any type of
    geospatial task or workload, we simply send the function and arguments over to
    the dispatch's `request_results` method. That method will immediately return a
    **Queue communications object**, which we must then send to `after_completion()`
    to check for the results at regular intervals without blocking any new GUI events
    or interaction, and run the specified function for processing the results once
    completed. If an exception is raised during the threaded processing, it will be
    returned to the application for proper handling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Using the toolkit to build the GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have created the fundamental GUI building blocks, we just need
    to put them all together to create our first application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the toolkit to build the GUI](img/5407OS_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To do so, reopen the empty `app/builder.py` module we created at the beginning
    of this chapter. Let''s create a basic GUI widget that represents the entirety
    of our application, populated with our widgets in a traditional layout:'
  prefs: []
  type: TYPE_NORMAL
- en: Our Ribbon widget at the top
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our LayersPane on the left
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The MapView on the right
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The StatusBar container at the bottom
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we create a `run` function, which is separate from the GUI class,
    that simply creates the main Tkinter root window, packs our GUI widget inside
    it, and runs the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Make this function directly available from the `app` package, by adding the
    following to `app/__init__.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Testing our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Provided you followed all of the instructions correctly, you should now be
    able to use the previous `run` function to begin exploring the application we
    have built so far. As we add more features throughout the book, you will likely
    want to call on this function repeatedly for testing purposes. Therefore, we add
    a ready-made script that does this for us called `guitester.py`, saving it in
    the same directory where our `pythongis` package is located to make the latter
    directly importable. The script only needs the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run `guitester.py` now, it should open an application that looks like
    this on Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing our application](img/5407OS_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will also likely want to start collecting a few vector and raster files
    that you can use to test with the application later on. A good place to get them
    is [http://www.naturalearthdata.com/](http://www.naturalearthdata.com/), and they
    are all in the same WGS84 coordinate system.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we have made the basics of our application, one which doesn't
    do much right now but that is ready to be extended further as we continue to add
    new geospatial functionality. You learned to create a solid toolkit foundation
    of tools and widgets that we can use to build our GUI in a separate and flexible
    builder module, some of which will be extended in later chapters. The main missing
    piece, before we can say we have a functional GIS application, is to visualize
    data in our map widget. This is what we turn to in the next chapter.
  prefs: []
  type: TYPE_NORMAL
