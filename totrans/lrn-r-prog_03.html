<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Managing Your Workspace"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Managing Your Workspace</h1></div></div></div><p>If the behavior of R objects is compared to game rules, then the workspace can be compared to the playground. To play the game well, you need to familiarize yourself not only with the rules, but also with the playground. In this chapter, I will introduce to you some basic but important skills to manage your workspace. These skills include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using the working directory</li><li class="listitem" style="list-style-type: disc">Inspecting the working environment</li><li class="listitem" style="list-style-type: disc">Modifying global options</li><li class="listitem" style="list-style-type: disc">Managing the library of packages</li></ul></div><div class="section" title="R's working directory"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec20"/>R's working directory</h1></div></div></div><p>An R session always starts in a directory, no matter whether it is launched as an R terminal or in RStudio. The directory in which R is running is called the <span class="strong"><strong>working directory</strong></span> of the R session. When you access other files on your hard drive, you can use either absolute paths (for example, <code class="literal">D:\Workspaces\test-project\data\2015.csv</code>) in most cases or relative paths (for example, <code class="literal">data\2015.csv</code>) with the right working directory (in this case, <code class="literal">D:\Workspaces\test-project</code>).</p><p>The use of relative paths to the working directory does not change the file paths, but the way you specify them is shorter. It also makes your scripts more portable. Imagine you are writing some R scripts to produce graphics according to a bunch of data files in a directory. If you write the directory as an absolute path, then anyone else who wants to run your script on their own computer would have to modify the paths in your code to the location of the data in their hard drives. However, if you write the directory as a relative path, then if the data is kept in the same relative location, the script will work without any modification.</p><p>In an R terminal, you can get the current working directory of the running R session using <code class="literal">getwd()</code>. By default, commandR starts a new R session from your user directory, and RStudio runs an R session in the background from your user documents directory.</p><p>Apart from the defaults, you can choose a directory and create an R project in RStudio. Then, every time you open that project, the working directory is the location of the project, which makes it super easy to access files in the project directory using relative paths, which improves the portability of the project.</p><div class="section" title="Creating an R project in RStudio"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec44"/>Creating an R project in RStudio</h2></div></div></div><p>To create a new project, simply go to <span class="strong"><strong>File </strong></span>| <span class="strong"><strong>New Project</strong></span> or click the Project drop-down menu in the top-right corner of the main window and choose <span class="strong"><strong>New Project</strong></span>. A window will appear, and you can create a new directory or choose an existing directory on your hard drive as the project directory:</p><div class="mediaobject"><img src="graphics/image_03_001.jpg" alt="Creating an R project in RStudio"/></div><p>Once you choose a local directory, the project will be created there. An R project is nothing but a <code class="literal">.Rproj</code> file that stores some settings. If you open such a project file in RStudio, the settings in it will be applied, and the working directory will be set to the directory in which the project file is located.</p><p>Another useful point in using RStudio to work in a project is that auto-completion makes writing file paths much more efficient. When you are typing a string of either an absolute or relative file path, press <span class="emphasis"><em>Tab</em></span> and RStudio will list the files in that directory:</p><div class="mediaobject"><img src="graphics/image_03_002.jpg" alt="Creating an R project in RStudio"/></div></div><div class="section" title="Comparing absolute and relative paths"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec45"/>Comparing absolute and relative paths</h2></div></div></div><p>Since I'm writing this book with RMarkdown in RStudio, the working directory is the directory of my book project:</p><pre class="programlisting">getwd()&#13;
## [1] "D:/Workspaces/learn-r-programming"&#13;
</pre><p>You may notice that the working directory mentioned earlier uses <code class="literal">/</code> instead of <code class="literal">\</code>. In Windows operating systems, <code class="literal">\</code> is the default path separator, but this symbol is already used to make special characters. For example, when you create a character vector, you can use <code class="literal">\n</code> to represent a new line:</p><pre class="programlisting">"Hello\nWorld"&#13;
## [1] "Hello\nWorld"&#13;
</pre><p>Special characters are preserved when the character vector is directly printed as a representation of the string. However, if you add <code class="literal">cat()</code> to it, the string will be written in the console with the escape characters translated to the characters they represent:</p><pre class="programlisting">cat("Hello\nWorld")&#13;
## Hello 
## World&#13;
</pre><p>The second word starts by a new line (<code class="literal">\n</code>) as normal. However, if <code class="literal">\</code> is so special, how should we write <code class="literal">\</code> itself? Just use <code class="literal">\\</code>:</p><pre class="programlisting">cat("The string with '' is translated")&#13;
## The string with '' is translated&#13;
</pre><p>That is why we should use <code class="literal">\\</code> or <code class="literal">/</code> in paths in Windows operating systems since both are supported. In Unix-like operating systems, such as macOS and Linux, things are easier: always use <code class="literal">/</code>. If you are using Windows and misuse <code class="literal">\</code> to refer to a file, an error will occur:</p><pre class="programlisting">filename &lt;- "d:\data\test.csv" &#13;
## Error: '\d' is an unrecognized escape in character string starting ""d:\d"&#13;
</pre><p>Instead, you need to write it like this:</p><pre class="programlisting">filename &lt;- "d:\\data\\test.csv"&#13;
</pre><p>Fortunately, we can use <code class="literal">/</code> in Windows in most cases, which makes the same code runnable in nearly all popular operating systems using relative paths:</p><pre class="programlisting">absolute_filename &lt;- "d:/data/test.csv"&#13;
relative_filename &lt;- "data/test.csv"&#13;
</pre><p>Instead of getting the working directory using <code class="literal">getwd()</code>, we can also set the working directory of the current R session using <code class="literal">setwd()</code>. However, this is almost always not recommended because it can direct all relative paths in a script to another directory and make everything go wrong.</p><p>Therefore, a good practice is to create an R project to start your work.</p></div><div class="section" title="Managing project files"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec46"/>Managing project files</h2></div></div></div><p>Once we create a project in RStudio, a <code class="literal">.Rproj</code> file is also created in the project directory in which there is no other file at the moment. Since R is related to statistical computing and data visualization, an R project mainly contains R scripts that do statistical computing (or other programming tasks), data files (such as <code class="literal">.csv</code> files), documents (such as Markdown files), and sometimes output graphics.</p><p>If different types of file are mixed up in the project directory, it will be increasingly more difficult to manage these project files, especially as input data accumulates or output data and graphics clutter the directory.</p><p>A recommended practice is to create subdirectories to contain different types of files resulting from different types of tasks.</p><p>For example, the following directory structure is plain, with all files together:</p><pre class="programlisting">project/&#13;
- household.csv &#13;
- population.csv &#13;
- national-income.png &#13;
- popluation-density.png &#13;
- utils.R &#13;
- import-data.R &#13;
- check-data.R &#13;
- plot.R &#13;
- README.md &#13;
- NOTES.md</pre><p>By contrast, the following directory structure is much cleaner and nicer to work with:</p><pre class="programlisting">project/ &#13;
- data/ &#13;
  - household.csv &#13;
  - population.csv &#13;
- graphics/ &#13;
  - national-income.png &#13;
  - popluation-density.png &#13;
- R/ &#13;
  - utils.R &#13;
  - import-data.R &#13;
  - check-data.R &#13;
  - plot.R &#13;
- README.md &#13;
- NOTES.md</pre><p>In the preceding directory structures, directories are represented in the form of <code class="literal">directory/</code> and files in the form of <code class="literal">file-name.ext</code>. In most cases, the second structure is recommended because, as project needs and tasks become more complex, the first structure will end up in a mess while the second structure will remain tidy.</p><p>Apart from the structure issue, it is common to write the project introduction in <code class="literal">README.md</code> and put additional notes in <code class="literal">NOTES.md</code>. These two documents are Markdown documents (<code class="literal">.md</code>), and it is worth becoming familiar with its extremely simple syntax. Read <span class="emphasis"><em>Daring Fireball: Markdown Syntax Documentation</em></span> (<a class="ulink" href="https://daringfireball.net/projects/markdown/syntax">https://daringfireball.net/projects/markdown/syntax</a>) and <span class="emphasis"><em>GitHub Help: Markdown Basics</em></span> (<a class="ulink" href="https://help.github.com/articles/markdown-basics/">https://help.github.com/articles/markdown-basics/</a>) for details. We will cover the topic of combining R and Markdown in <a class="link" href="ch15.html" title="Chapter 15. Boosting Productivity">Chapter 15</a>, <span class="emphasis"><em>Boosting Productivity</em></span>.</p><p>Now the working directory is ready. In the next section, you will learn various methods to inspect the working environment in an R session.</p></div></div></div>
<div class="section" title="Inspecting the environment"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Inspecting the environment</h1></div></div></div><p>In R, every expression is evaluated within a specific environment. An environment is a collection of symbols and their bindings. When we bind a value to a symbol, call a function, or refer to a name, R will find the symbols in the current environment. If you type commands in the RStudio console, your commands are evaluated in the <span class="strong"><strong>Global Environment</strong></span>.</p><p>For example, when we start a fresh R session in a terminal or RStudio, we start working within an empty global environment. In other words, there is no symbol defined in this environment. If we run <code class="literal">x &lt;- c(1, 2, 3)</code>, the numeric vector <code class="literal">c(1, 2, 3)</code> is bound to symbol <code class="literal">x</code> in the global environment. Then, the global environment has one binding that maps <code class="literal">x</code> to the vector <code class="literal">c(1, 2, 3)</code>. In other words, if you evaluate <code class="literal">x</code>, then you will get its value.</p><div class="section" title="Inspecting existing symbols"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec47"/>Inspecting existing symbols</h2></div></div></div><p>In addition to manipulating vectors and lists as we did in the previous chapter, we need to know some basic functions to inspect and manipulate our working environment. The most basic but useful function to inspect the collection of objects we are working with is <code class="literal">objects()</code>. The function returns a character vector of the names of existing objects in the current environment.</p><p>In a fresh R session, there should not be any symbol in the current environment:</p><pre class="programlisting">objects()&#13;
## character(0)&#13;
</pre><p>Let's assume we create the following objects:</p><pre class="programlisting">x &lt;- c(1, 2, 3)&#13;
y &lt;- c("a", "b", "c")&#13;
z &lt;- list(m = 1:5, n = c("x", "y", "z"))&#13;
</pre><p>Then, you will get a character vector of the existing object names:</p><pre class="programlisting">objects()&#13;
## [1] "x" "y" "z"&#13;
</pre><p>Many developers prefer <code class="literal">ls()</code> as an alias of <code class="literal">objects()</code>:</p><pre class="programlisting">ls()&#13;
## [1] "x" "y" "z"&#13;
</pre><p>In most cases, especially when you are working in RStudio, you don't have to use <code class="literal">objects()</code> or <code class="literal">ls()</code> to see what symbols have been created because the <span class="strong"><strong>Environment</strong></span> pane shows all symbols available in the global environment:</p><div class="mediaobject"><img src="graphics/image_03_003.jpg" alt="Inspecting existing symbols"/></div><p>The <span class="strong"><strong>Environment</strong></span> pane shows symbols and their values in a compact representation. You can interact with objects in it by expanding a list or data frame and viewing the vectors inside.</p><p>In addition to the list view, the <span class="strong"><strong>Environment</strong></span> pane also provides an alternative grid view. The grid view shows not only the names, types, and the value structures of existing objects, but also their object sizes:</p><div class="mediaobject"><img src="graphics/image_03_004.jpg" alt="Inspecting existing symbols"/></div><p>Although the <span class="strong"><strong>Environment</strong></span> pane in RStudio makes it straightforward to inspect all existing variables, <code class="literal">objects()</code> or <code class="literal">ls()</code> can be still useful when RStudio is not available, when you write a function to work with their names, or the objects are provided dynamically in different manners.</p></div><div class="section" title="Viewing the structure of an object"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec48"/>Viewing the structure of an object</h2></div></div></div><p>In the <span class="strong"><strong>Environment</strong></span> pane, the compact representation of an object comes from the <code class="literal">str()</code> function, which prints the structure of a given object.</p><p>For example, when <code class="literal">str()</code> is applied to a simple numeric vector, it shows its type, positions, and a preview of its values:</p><pre class="programlisting">x&#13;
## [1] 1 2 3&#13;
str(x)&#13;
## num [1:3] 1 2 3</pre><p>If the vector has more than 10 elements, <code class="literal">str()</code> will only show the first 10:</p><pre class="programlisting">str(1:30)&#13;
## int [1:30] 1 2 3 4 5 6 7 8 9 10 ...</pre><p>For a list, directly evaluating it in the console or using <code class="literal">print()</code> will show the elements in a verbose form:</p><pre class="programlisting">z&#13;
## $m
## [1] 1 2 3 4 5
## 
## $n
## [1] "x" "y" "z"</pre><p>Alternatively, <code class="literal">str()</code> shows its type, length, and the structure preview of the elements:</p><pre class="programlisting">str(z)&#13;
## List of 2
## $ m: int [1:5] 1 2 3 4 5
## $ n: chr [1:3] "x" "y" "z"</pre><p>Let's assume we created the following nested list:</p><pre class="programlisting">nested_list &lt;- list(m = 1:15, n = list("a", c(1, 2, 3)),
   p = list(x = 1:10, y = c("a", "b")),
   q = list(x = 0:9, y = c("c", "d")))</pre><p>Directly printing will show all its elements and tell us how we can access them which can be long and unnecessary in most cases:</p><pre class="programlisting">nested_list&#13;
## $m
## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
## 
## $n
## $n[[1]]
## [1] "a"
## 
## $n[[2]]
## [1] 1 2 3
## 
## 
## $p
## $p$x
## [1] 1 2 3 4 5 6 7 8 9 10
## 
## $p$y
## [1] "a" "b"
## 
## 
## $q
## $q$x
## [1] 0 1 2 3 4 5 6 7 8 9
## 
## $q$y
## [1] "c" "d"</pre><p>To get a compact representation that is easier to view and work with, call <code class="literal">str()</code> with a list:</p><pre class="programlisting">str(nested_list)&#13;
## List of 4
## $ m: int [1:15] 1 2 3 4 5 6 7 8 9 10 ...
## $ n:List of 2
## ..$ : chr "a"
## ..$ : num [1:3] 1 2 3
## $ p:List of 2
## ..$ x: int [1:10] 1 2 3 4 5 6 7 8 9 10
## ..$ y: chr [1:2] "a" "b"
## $ q:List of 2
## ..$ x: int [1:10] 0 1 2 3 4 5 6 7 8 9
## ..$ y: chr [1:2] "c" "d"</pre><p>While <code class="literal">str()</code> shows the structure of an object, <code class="literal">ls.str()</code> shows the structure of the current environment:</p><pre class="programlisting">ls.str()&#13;
## nested_list : List of 4
## $ m: int [1:15] 1 2 3 4 5 6 7 8 9 10 ...
## $ n:List of 2
## $ p:List of 2
## $ q:List of 2
## x : num [1:3] 1 2 3
## y : chr [1:3] "a" "b" "c"
## z : List of 2
## $ m: int [1:5] 1 2 3 4 5
## $ n: chr [1:3] "x" "y" "z"</pre><p>Its functionality is similar to that of the <span class="strong"><strong>Environment</strong></span> pane in RStudio and can be useful when you need to inspect a customized environment or only show the structures of some particular variables.</p><p>One filter for <code class="literal">ls.str()</code> is the mode argument. You can show the structures of all values that are list objects:</p><pre class="programlisting">ls.str(mode = "list")&#13;
## nested_list : List of 4
## $ m: int [1:15] 1 2 3 4 5 6 7 8 9 10 ...
## $ n:List of 2
## $ p:List of 2
## $ q:List of 2
## z : List of 2
## $ m: int [1:5] 1 2 3 4 5
## $ n: chr [1:3] "x" "y" "z"</pre><p>The other filter is the pattern argument, which specifies the pattern of the names to match. The pattern is expressed in a <span class="strong"><strong>regular expression</strong></span>. If you want to show the structures of all variables whose names contain only one character, you can run the following command:</p><pre class="programlisting">ls.str(pattern = "^\\w$")&#13;
## x : num [1:3] 1 2 3
## y : chr [1:3] "a" "b" "c"
## z : List of 2
## $ m: int [1:5] 1 2 3 4 5
## $ n: chr [1:3] "x" "y" "z"</pre><p>If you want to show the structures of all list objects whose names contain only one character, you can use both pattern and mode at the same time:</p><pre class="programlisting">ls.str(pattern = "^\\w$", mode = "list")&#13;
## z : List of 2
## $ m: int [1:5] 1 2 3 4 5
## $ n: chr [1:3] "x" "y" "z"</pre><p>If you're put off by commands such as <code class="literal">^\\w$</code>, don't worry. This pattern matches all strings in the form of <code class="literal">(string begin)(any one word character like a, b, c)(string end)</code>. We will cover this powerful tool in <a class="link" href="ch06.html" title="Chapter 6. Working with Strings">Chapter 6</a>, <span class="emphasis"><em>Working with Strings</em></span>.</p></div><div class="section" title="Removing symbols"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec49"/>Removing symbols</h2></div></div></div><p>So far, we have only created symbols. Sometimes, it can be useful to remove them. The <code class="literal">remove()</code> function, or equivalently <code class="literal">rm()</code>, removes existing symbols from the environment.</p><p>Before removing <code class="literal">x</code>, the symbols in the environment are as follows:</p><pre class="programlisting">ls()&#13;
## [1] "nested_list" "x" "y" "z"</pre><p>Then, we will use <code class="literal">rm()</code> to remove <code class="literal">x</code> from the environment:</p><pre class="programlisting">rm(x)
ls()&#13;
## [1] "nested_list" "y" "z"</pre><p>Note that the function also works with variable names in strings. Therefore, <code class="literal">rm("x")</code> has exactly the same effect. We can also remove multiple symbols in one function call:</p><pre class="programlisting">rm(y, z)
ls()&#13;
## [1] "nested_list"</pre><p>If the symbol to be removed does not exist in the environment, a warning will appear:</p><pre class="programlisting">rm(x)&#13;
## Warning in rm(x): object 'x' not found</pre><p>The <code class="literal">rm()</code> function can also remove all symbols specified by a character vector of symbol names:</p><pre class="programlisting">p &lt;- 1:10
q &lt;- seq(1, 20, 5)
v &lt;- c("p", "q")
rm(list = v)&#13;
## [1] "nested_list" "v"</pre><p>If we want to clear all the bindings in an environment, we can combine <code class="literal">rm()</code> and <code class="literal">ls()</code> and call the function like this:</p><pre class="programlisting">rm(list = ls())
ls()&#13;
## character(0)</pre><p>Now there's no symbol in the environment.</p><p>In many cases, removing symbols is not necessary, but it can be useful to remove very large objects that occupy a big area of memory. If R feels memory pressure, it will clean up unused objects with no bindings.</p></div></div>
<div class="section" title="Modifying global options"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Modifying global options</h1></div></div></div><p>Instead of creating, inspecting, and removing objects in the working environment, R options have effects in the global scale of the current R session. We can call <code class="literal">getOption()</code> to see the value of a given option and call <code class="literal">options()</code> to modify one.</p><div class="section" title="Modifying the number of digits to print"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec50"/>Modifying the number of digits to print</h2></div></div></div><p>In RStudio, when you type <code class="literal">getOption(&lt;Tab&gt;)</code>, you can see a list of available options and their descriptions. A commonly used option, for instance, is the number of digits to display. Sometimes, it is not sufficient when we deal with numbers requiring higher precision. In an R session, the number of digits printed on screen is entirely managed by digits. We can call <code class="literal">getOption()</code> to see the current value of digits and call <code class="literal">options()</code> to set <code class="literal">digits</code> to a larger number:</p><div class="mediaobject"><img src="graphics/image_03_005.jpg" alt="Modifying the number of digits to print"/></div><p>When an R session starts, the default value of digits is 7. To demonstrate its effect, run the following code:</p><pre class="programlisting">123.12345678&#13;
## [1] 123.1235</pre><p>It is obvious that the 11-digit number is only shown with 7 digits. This means the last few decimal digits are gone; the printer only displays the number with 7 digits. To verify no precision is lost because of <code class="literal">digits = 7</code>, see the output of the following code:</p><pre class="programlisting">0.10000002&#13;
## [1] 0.1&#13;
0.10000002 -0.1&#13;
## [1] 2e-08</pre><p>If the numbers are rounded to the seventh decimal place by default, then <code class="literal">0.10000002</code> should be rounded to <code class="literal">0.1</code> and the second expression should result in <code class="literal">0</code>. However, apparently, this does not happen because <code class="literal">digits = 7</code> only means the number of numeric digits to be displayed rather than rounded up.</p><p>However, in some cases, the number before the decimal point can be large, and we don't want to ignore digits following the decimal point. Without modifying digits, the following number will only display the integer part:</p><pre class="programlisting">1234567.12345678&#13;
## [1] 1234567</pre><p>If we want to see more digits printed, we need to increase digits from the default value 7 to a higher number:</p><pre class="programlisting">getOption("digits")&#13;
## [1] 7&#13;
1e10 + 0.5&#13;
## [1] 1e + 10&#13;
options(digits = 15)
1e10 + 0.5&#13;
## [1] 10000000000.5</pre><p>Note that once, <code class="literal">options()</code> is called, the modified options take effect immediately and may affect the behavior of all subsequent commands. To reset options, use this command:</p><pre class="programlisting">options(digits = 7)
1e10 + 0.5&#13;
## [1] 1e + 10</pre></div><div class="section" title="Modifying the warning level"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec51"/>Modifying the warning level</h2></div></div></div><p>Another options example managing the warning level by specifying the value of the <code class="literal">warn</code> option:</p><pre class="programlisting">getOption("warn")&#13;
## [1] 0</pre><p>By default, the warning level is <code class="literal">0</code>, which means a warning is a warning and an error is an error. In this state, a warning will be displayed but will not stop the code, while an error terminates the code immediately. If multiple warnings occur, they will be combined and displayed together. For example, the following conversion from a string to a numeric vector will produce a warning and result in a missing value:</p><pre class="programlisting">as.numeric("hello")&#13;
## Warning: NAs introduced by coercion&#13;
## [1] NA</pre><p>We can make it completely silent and still get a missing value from the unsuccessful conversion:</p><pre class="programlisting">options(warn = -1)
as.numeric("hello")&#13;
## [1] NA</pre><p>Then, the warning is gone. Making the warning messages disappear is almost always a bad idea. It will make potential errors silent. You can (or cannot) realize something is wrong from the final result. The recommendation is to be strict in your code and save a lot of time debugging it.</p><p>Setting warn to 1 or 2 will make buggy code fail fast. When <code class="literal">warn = 0</code>, the default behavior for evaluating a function call is to first return the value and then show all the warning messages together, if any. To demonstrate this behavior, the following function is called with two strings:</p><pre class="programlisting">f &lt;- function(x, y) {
as.numeric(x) + as.numeric(y)
}</pre><p>At the default warning level, all warning messages are shown after the function returns:</p><pre class="programlisting">options(warn = 0)
f("hello", "world")&#13;
## [1] NA
## Warning messages:
## 1: In f("hello", "world") : NAs introduced by coercion
## 2: In f("hello", "world") : NAs introduced by coercion</pre><p>The function coerces two input arguments to numeric vectors. As the input arguments are both strings, two warnings will be produced, but will only appear after the function returns. If the preceding function does some heavy work and takes a considerable period of time, you won't see any warning before you get the final result but in fact the intermediate computing has been way off the correct results for quite a while.</p><p>This prompts the use of <code class="literal">warn = 1</code>, which forces the warning message to be printed as soon as a warning is produced:</p><pre class="programlisting">options(warn = 1)&#13;
f("hello", "world")&#13;
## Warning in f("hello", "world") : NAs introduced by coercion
## Warning in f("hello", "world") : NAs introduced by coercion
## [1] NA</pre><p>The result is the same, but the warning messages appear ahead of the result. If the function is time-consuming, we should be able to see the warning messages first. So, we can choose to stop the code and check whether something is wrong.</p><p>A warning level is even stricter. The <code class="literal">warn = 2</code> argument directly regards any warning as an error.</p><pre class="programlisting">options(warn = 2)
f("hello", "world")&#13;
## Error in f("hello", "world") : 
## (converted from warning) NAs introduced by coercion</pre><p>These options have effects in the global scale. Therefore, it is convenient to manage common aspects of an R session, but it can also be dangerous to change options. Just like changing the working directory may invalidate all relative paths in the script from running, changing global options may break all subsequent code that is based on incompatible assumptions of the global options.</p><p>In general, it is not recommended to modify global options unless absolutely necessary.</p></div></div>
<div class="section" title="Managing the library of packages"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Managing the library of packages</h1></div></div></div><p>In R, packages play an indispensable role in data analysis and visualization. In fact, R itself is only a tiny core and is built on several basic packages. A package is a container of predefined functions, which are often designed to be general enough to solve a certain range of problems. Using a well-designed package, we don't have to reinvent the wheel again and again, which allows us to focus more on the problem we are trying to solve.</p><p>R is powerful not only because of its rich source of packages, but also because of the well-maintained package archive system called <span class="emphasis"><em>The Comprehensive R Archive Network</em></span>, or CRAN (<a class="ulink" href="http://cran.r-project.org/">http://cran.r-project.org/</a>). The source code of R and thousands of packages is archived in this system. At the time of writing, there are 7,750 active packages on CRAN maintained by more than 4,500 package maintainers around the world. Every week, more than 100 packages will be updated and more than 2 million package downloads happen. You can check out the table of packages at <a class="ulink" href="https://cran.rstudio.com/web/packages/">https://cran.rstudio.com/web/packages/</a> in which all the packages currently available are listed.</p><p>Just don't panic when you hear the number of packages on CRAN! The number is large and the coverage is wide, but you only have to learn a small fraction of them. If you focus on the work of a specific field, it is very likely that there are no more than 10 packages that are heavily related to your work and field. Therefore, there's absolutely no need for you to know all the packages (nobody can or even need to), but only the most useful and field-related ones.</p><p>Instead of finding packages in the table, which is not that informative, I recommend that you visit CRAN Task Views (<a class="ulink" href="https://cran.rstudio.com/web/views/">https://cran.rstudio.com/web/views/</a>) and METACRAN <a class="ulink" href="http://www.r-pkg.org/">http://www.r-pkg.org/</a>, and get started by learning about the packages that are most commonly used or closely related to your working field. Before learning how to use a specific package, we need to have a general idea about installing packages from different sources and understand how a package basically works.</p><div class="section" title="Getting to know a package"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec52"/>Getting to know a package</h2></div></div></div><p>A package is a collection of functions to solve a certain range of problems. It can be an implementation of a family of statistical estimators, data-mining methods, database interfaces, or optimization tools. To know more about a package, for example, ggplot2, a super powerful graphics package, several information sources are useful:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Package description page</strong></span> (<a class="ulink" href="https://cran.rstudio.com/web/packages/ggplot2/">https://cran.rstudio.com/web/packages/ggplot2/</a>): The page contains the basic information about the package, including the name, description, version, publishing date, authors, related websites, reference manuals, vignettes, relationship to other packages, and so on. The description page of a package is provided not only by CRAN, but by some other third-party package information websites. METACRAN also provides a description of ggplot2 at <a class="ulink" href="http://www.r-pkg.org/pkg/ggplot2">http://www.r-pkg.org/pkg/ggplot2</a>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Package website (</strong></span><a class="ulink" href="http://ggplot2.org/">http://ggplot2.org/</a>): The webpage contains a description and related resources for the package, such as blogs, tutorials, and books. Not every package has a website, but if one does the website is the official starting point for learning about the package.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Package source code</strong></span> (<a class="ulink" href="https://github.com/hadley/ggplot2">https://github.com/hadley/ggplot2</a>): The authors host the source code of the package on GitHub (<a class="ulink" href="https://github.com">https://github.com</a>), and the page is the source code the package. If you are interested in the implementation of the package functions, you can check out the source code and take a look. If you find some unexpected behavior that looks like a bug, you can report it at <a class="ulink" href="https://github.com/hadley/ggplot2/issues">https://github.com/hadley/ggplot2/issues</a>. Also, you can file an issue at the same place to request a new feature.</li></ul></div><p>After reading the package description, you can try it by installing the package to the R library.</p></div><div class="section" title="Installing packages from CRAN"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec53"/>Installing packages from CRAN</h2></div></div></div><p>CRAN archives R packages and distributes them to more than 120 mirrors around the world. You can visit CRAN Mirrors (<a class="ulink" href="https://cran.r-project.org/mirrors.html">https://cran.r-project.org/mirrors.html</a>) and check out a nearby mirror. If you find one, you can go to <span class="strong"><strong>Tools</strong></span> | <span class="strong"><strong>Global Options</strong></span> and open the following dialog:</p><div class="mediaobject"><img src="graphics/image_03_006.jpg" alt="Installing packages from CRAN"/></div><p>You can change the CRAN mirror to a nearby one or simply use the default mirror. In general, you will experience very fast downloading if you use a nearby mirror. In recent months, some mirrors have started using HTTPS to secure data transfers. If <span class="strong"><strong>Use secure download method for HTTP</strong></span> is checked, then you can only view HTTPS mirrors.</p><p>Once a mirror is chosen, to download and install a package in R becomes extremely easy. Just call <code class="literal">install.packages("ggplot2")</code>, and R will automatically download the package, install it, and sometimes compile it.</p><p>RStudio also provides an easy way to install packages. Just go to the Packages pane and click on <span class="strong"><strong>Install</strong></span>. The following dialog appears:</p><div class="mediaobject"><img src="graphics/image_03_007.jpg" alt="Installing packages from CRAN"/></div><p>As the package description shows, a package may depend on other packages. In other words, when you call a function in the package, the function also calls some functions in other packages, which requires that you also install those packages as well. Fortunately, <code class="literal">install.packages()</code> is smart enough to know the dependency structure of the package to install and will install those packages first.</p><p>In the main page of METACRAN (<a class="ulink" href="http://www.r-pkg.org/">http://www.r-pkg.org/</a>), featured packages are those with the most stars on GitHub. That is, these packages are marked by many GitHub users. You may want to install multiple featured packages in one call, which is naturally allowed if you write the package names as a character vector:</p><pre class="programlisting">install.packages(c("ggplot2", "shiny", "knitr", "dplyr", "data.table"))</pre><p>Then the <code class="literal">install.packages()</code> function automatically resolves the joint dependency structure of all these packages and installs them.</p></div><div class="section" title="Updating packages from CRAN"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec54"/>Updating packages from CRAN</h2></div></div></div><p>By default, the <code class="literal">install.packages()</code> function installs the latest version of the specified packages. Once they are installed, the package version stays fixed. However, the packages may be updated to fix bugs or add new features. Sometimes, an updated version of a package may deprecate functions in older versions with warnings. In these cases, we may keep the package out-of-date, or update it after reading the <code class="literal">NEWS</code> package, which can be found in the package description (for example, <a class="ulink" href="https://cran.r-project.org/web/packages/ggplot2/news.html">https://cran.r-project.org/web/packages/ggplot2/news.html</a>; see this for details about the new version in the case of breaking changes).</p><p>RStudio provides an <span class="strong"><strong>Update</strong></span> button next to <span class="strong"><strong>Install</strong></span> in the package pane. We can also use the following function and choose which packages are going to be updated:</p><pre class="programlisting">update.packages()</pre><p>Both RStudio and the preceding function scan newer versions of packages and install these packages along with dependencies if necessary.</p></div><div class="section" title="Installing packages from online repositories"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec55"/>Installing packages from online repositories</h2></div></div></div><p>Nowadays, many package authors host their work on GitHub because version control and community development are very easy, thanks to the well-designed issue-tracking systems and merge request system. Some authors do not release their work to CRAN, and others only release the stable versions to CRAN and keep new versions under development on GitHub.</p><p>If you want to try the latest development version, which often has new features or has fixed some bugs, you can directly install the package from the online repository using the devtools package.</p><p>First, install the devtools package if it does not appear in your library:</p><pre class="programlisting">install.packages("devtools")</pre><p>Then, use <code class="literal">install_github()</code> in the devtools package to install the latest development version of ggplot2:</p><pre class="programlisting">library(devtools)&#13;
install_github("hadley/ggplot2")</pre><p>The devtools package will download the source code from GitHub and makes it a package in your library. If your library has already got the package, the installation will replace it without asking. If you want to revert the development version to the latest CRAN version, you can run the CRAN installing code again:</p><pre class="programlisting">install.packages("ggplot2")</pre><p>Then, the local version (GitHub version) is replaced by the CRAN version.</p></div><div class="section" title="Using package functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec56"/>Using package functions</h2></div></div></div><p>There are two ways to use the functions in a package. First, we can call <code class="literal">library()</code> to attach the package so that the functions in it can be directly called. Second, we can call <code class="literal">package::function()</code> to only use the function without attaching the whole package to the environment.</p><p>For example, some statistical estimators are not implemented as built-in functions in base R but in other packages. One instance is skewness; the statistical function is provided by the moments package.</p><p>To calculate the skewness of numeric vector <code class="literal">x</code>, we can attach the package first and directly call the function:</p><pre class="programlisting">library(moments)skewness(x)</pre><p>Alternatively, we can call package functions without attaching the package, using <code class="literal">::</code>:</p><pre class="programlisting">moments::skewness(x)</pre><p>The two methods return the same result, but they work in different ways and have a different impact on the environment. More specifically, the first method (using <code class="literal">library()</code>) modifies the search path of symbols, whereas the second method (using <code class="literal">::</code>) does not. When you call <code class="literal">library(moments)</code>, the package is attached and added to the search path so that the package functions are directly available in subsequent code.</p><p>Sometimes, it is useful to see what packages we are using by calling <code class="literal">sessionInfo()</code>:</p><pre class="programlisting">sessionInfo()&#13;
## R version 3.2.3 (2015-12-10)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 10 x64 (build 10586)
## 
## locale:
## [1] LC_COLLATE=English_UnitedStates.1252
## [2] LC_CTYPE=English_UnitedStates.1252
## [3] LC_MONETARY=English_UnitedStates.1252
## [4] LC_NUMERIC=C 
## [5] LC_TIME=English_UnitedStates.1252
## 
## attached base packages:
## [1] stats graphics grDevicesutils datasets 
## [6] methods base 
## 
## loaded via a namespace (and not attached):
## [1] magrittr_1.5formatR_1.2.1tools_3.2.3
## [4] htmltools_0.3yaml_2.1.13stringi_1.0-1 
## [7] rmarkdown_0.9.2knitr_1.12stringr_1.0.0
## [10] digest_0.6.8evaluate_0.8</pre><p>The session info shows the R version and lists the attached packages and loaded packages. When we use <code class="literal">::</code> to access a function in a package, the package is not attached but loaded in memory. In this case, other functions in the package are still not directly available:</p><pre class="programlisting">moments::skewness(c(1, 2, 3, 2, 1))&#13;
## [1] 0.3436216&#13;
sessionInfo()&#13;
## R version 3.2.3 (2015-12-10)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 10 x64 (build 10586)
## 
## locale:
## [1] LC_COLLATE=English_UnitedStates.1252
## [2] LC_CTYPE=English_UnitedStates.1252
## [3] LC_MONETARY=English_UnitedStates.1252
## [4] LC_NUMERIC=C 
## [5] LC_TIME=English_UnitedStates.1252
## 
## attached base packages:
## [1] stats graphics grDevicesutils datasets 
## [6] methods base 
## 
## loaded via a namespace (and not attached):
## [1] magrittr_1.5formatR_1.2.1tools_3.2.3
## [4] htmltools_0.3yaml_2.1.13stringi_1.0-1 
## [7] rmarkdown_0.9.2knitr_1.12stringr_1.0.0
## [10] digest_0.6.8moments_0.14evaluate_0.8</pre><p>This shows that the moments package is loaded but not attached. When we <code class="literal">calllibrary(moments)</code>, the package will be attached:</p><pre class="programlisting">library(moments)sessionInfo()&#13;
## R version 3.2.3 (2015-12-10)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 10 x64 (build 10586)
## 
## locale:
## [1] LC_COLLATE=English_UnitedStates.1252
## [2] LC_CTYPE=English_UnitedStates.1252
## [3] LC_MONETARY=English_UnitedStates.1252
## [4] LC_NUMERIC=C 
## [5] LC_TIME=English_UnitedStates.1252
## 
## attached base packages:
## [1] stats graphics grDevicesutils datasets 
## [6] methods base 
## 
## other attached packages:
## [1] moments_0.14
## 
## loaded via a namespace (and not attached):
## [1] magrittr_1.5formatR_1.2.1tools_3.2.3
## [4] htmltools_0.3yaml_2.1.13stringi_1.0-1 
## [7] rmarkdown_0.9.2knitr_1.12stringr_1.0.0
## [10] digest_0.6.8evaluate_0.8&#13;
skewness(c(1, 2, 3, 2, 1))&#13;
## [1] 0.3436216</pre><p>Then, <code class="literal">skewness()</code> as well as other package functions in moments are directly available.</p><p>An easier way to see attached packages is <code class="literal">search()</code>:</p><pre class="programlisting">search()&#13;
## [1] ".GlobalEnv" "package:moments" 
## [3] "package:stats" "package:graphics" 
## [5] "package:grDevices" "package:utils" 
## [7] "package:datasets" "package:methods" 
## [9] "Autoloads" "package:base"</pre><p>The function returns the current search path of symbols. When you evaluate a function call that uses skewness, it finds a skewness symbol in the current environment first. Then, it goes to <code class="literal">package:moment</code> and the symbol is found. If the package is not attached, the symbol will not be found, so an error will occur. We will cover this symbol-finding mechanism in later chapters.</p><p>To attach a package, <code class="literal">require()</code> is similar to <code class="literal">library()</code>, but it returns a logical value to indicate whether the package is successfully attached:</p><pre class="programlisting">loaded &lt;- require(moments)&#13;
## Loading required package: moments&#13;
loaded&#13;
## [1] TRUE</pre><p>This feature allows the following code to attach a package if it is installed or install it if it is not yet installed:</p><pre class="programlisting">if (!require(moments)) {  install.packages("moments")  library(moments)}</pre><p>However, most uses of the <code class="literal">require()</code> function in user code are not like this. The following is typical:</p><pre class="programlisting">require(moments)</pre><p>This looks equivalent to using <code class="literal">library()</code> but has a silent drawback:</p><pre class="programlisting">require(testPkg)&#13;
## Loading required package: testPkg&#13;
## Warning in library(package, lib.loc = lib.loc,
## character.only = TRUE, logical.return = TRUE, : there is no
## package called 'testPkg'</pre><p>If the package to attach is not installed or even does not exist at all (maybe a typo), <code class="literal">require()</code> only produces a warning instead of an error like that produced by <code class="literal">library()</code>:</p><pre class="programlisting">library(testPkg)&#13;
## Error in library(testPkg): there is no package called 'testPkg'</pre><p>Imagine you are running a long and time-consuming R script that depends on several packages. If you use <code class="literal">require()</code> and unfortunately the computer running your script does not happen to have installed the required packages, the script will only fail later, when the package function is being called and the function is not found. However, if you use <code class="literal">library()</code> instead, the script will stop immediately if the packages do not exist on the running computer. Yihui Xie wrote a blog (<a class="ulink" href="http://yihui.name/en/2014/07/library-vs-require/">http://yihui.name/en/2014/07/library-vs-require/</a>) on this issue and proposes the <span class="emphasis"><em>fail fast</em></span> principle: if the task has to fail, it is better to fail fast.</p></div><div class="section" title="Masking and name conflicts"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec57"/>Masking and name conflicts</h2></div></div></div><p>A fresh R session starts with basic packages automatically attached. The basic packages refer to base, stats, graphics, and so on. With these packages attached, you can calculate the average of a numeric vector using <code class="literal">mean()</code> and the median of it using <code class="literal">median()</code>, without using <code class="literal">base::mean()</code> and <code class="literal">stats::median()</code> or having to manually attach <code class="literal">base</code> and <code class="literal">stats</code> packages.</p><p>In fact, thousands of functions are immediately available from automatically attached packages, and each package defines a number of functions for a particular purpose. Therefore, it is likely that the functions in two packages conflict with each other. For example, suppose two packages A and B both have a function named X. If you attach A and then attach B, the function A::X will be masked by the function B::X. In other words, when you attach A and you call <code class="literal">X()</code>, then A's X is called. Then, you attach B and call <code class="literal">X()</code>; it is now B's X that is called. This mechanism is known as <span class="strong"><strong>masking</strong></span>. The following example shows what happens when masking occurs.</p><p>The powerful data manipulation package dplyr defines a family of functions that make it easier to manipulate tabular data. When we attach the package, some messages are printed to show you that some existing functions are masked by the package functions with the same names:</p><pre class="programlisting">library(dplyr)&#13;
## 
## Attaching package: 'dplyr'&#13;
## The following objects are masked from 'package:stats':
## 
## filter, lag&#13;
## The following objects are masked from 'package:base':
## 
## intersect, setdiff, setequal, union</pre><p>Fortunately, the implementation of these functions in <code class="literal">dplyr</code> does not change the meaning and usage, but generalizes them. These functions are compatible with the masked version. Therefore, you don't have to worry that the masked functions are broken and no longer work.</p><p>Package functions that mask basic functions almost always generalize rather than replace. However, if you have to use two packages in which some functions share the same names, you had better not attach either package; instead, extract the functions from both packages you need, as shown here:</p><pre class="programlisting">fun1 &lt;- package1::some_function
fun2 &lt;- pacakge2::some_function</pre><p>If you happen to attach one package and want to detach it, you can call <code class="literal">unloadNamespace()</code>. For example, we have attached moments and we can detach it:</p><pre class="programlisting">unloadNamespace("moments")</pre><p>As soon as the package is detached, the package functions are no longer directly available:</p><pre class="programlisting">skewness(c(1, 2, 3, 2, 1))&#13;
## Error in eval(expr, envir, enclos): could not find function "skewness"</pre><p>However, you can still use <code class="literal">::</code> to call the function:</p><pre class="programlisting">moments::skewness(c(1, 2, 3, 2, 1))&#13;
## [1] 0.3436216</pre></div><div class="section" title="Checking whether a package is installed"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec58"/>Checking whether a package is installed</h2></div></div></div><p>It is useful to know that <code class="literal">install.packages()</code> performs the installation, while <code class="literal">installed.packages()</code> shows information about the installed packages, which is a matrix of 16 columns that covers a wide range of information:</p><pre class="programlisting">pkgs &lt;- installed.packages()
colnames(pkgs)&#13;
## [1] "Package" "LibPath" 
## [3] "Version" "Priority" 
## [5] "Depends" "Imports" 
## [7] "LinkingTo" "Suggests" 
## [9] "Enhances" "License" 
## [11] "License_is_FOSS" "License_restricts_use"
## [13] "OS_type" "MD5sum" 
## [15] "NeedsCompilation" "Built"</pre><p>This can be useful when you need to check whether a package is installed:</p><pre class="programlisting">c("moments", "testPkg") %in% installed.packages()[, "Package"]&#13;
## [1] TRUE FALSE</pre><p>Sometimes, you need to check the version of a package:</p><pre class="programlisting">installed.packages()["moments", "Version"]&#13;
## [1] "0.14"</pre><p>A simpler way to get the package version is using the following command:</p><pre class="programlisting">packageVersion("moments")&#13;
## [1] '0.14'</pre><p>We can compare two package versions so that we can check whether a package is newer than a given version:</p><pre class="programlisting">packageVersion("moments") &gt;= package_version("0.14")&#13;
## [1] TRUE</pre><p>In fact, we can directly use a string version to perform the comparison:</p><pre class="programlisting">packageVersion("moments") &gt;= "0.14"&#13;
## [1] TRUE</pre><p>Checking package versions can be useful if your scripts depend on some packages that must be equal to or newer than, a specific version. This can be true if your scripts rely on some of the new features introduced in that version. In addition, <code class="literal">packageVersion()</code> will produce an error if a package is not installed, which also makes it check the package installation status.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Summary</h1></div></div></div><p>In this chapter, you learned about the working-directory concept and tools dealing with it. You also explored functions to inspect the working environment, modify global options, and manage the library of packages. Now, you have the basic knowledge to manage your workspace.</p><p>In this next chapter, you will learn several basic expressions, including assignment, condition, and loop. These expressions are the building blocks of program logic. I will show you how to write efficient and robust control-flow expressions in the next chapter.</p></div></body></html>