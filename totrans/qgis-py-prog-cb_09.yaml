- en: Chapter 9. Other Tips and Tricks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating tiles from a QGIS map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a layer to geojson.io
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering map layers based on rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a layer style file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using NULL values in PyQGIS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using generators for layer queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using alpha values to show data density
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `__geo_interface__` protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating points along a line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using expression-based labels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating dynamic forms in QGIS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating length for all the selected lines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a different status bar CRS than the map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating HTML labels in QGIS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using OpenStreetMap's points of interest in QGIS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizing data in 3D with WebGL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizing data on a globe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter provides interesting and valuable QGIS Python tricks that didn't
    fit into any topics in other chapters. Each recipe has a specific purpose, but
    in many cases, a recipe may demonstrate multiple concepts that you'll find useful
    in other programs. All the recipes in this chapter run in the QGIS Python console.
  prefs: []
  type: TYPE_NORMAL
- en: Creating tiles from a QGIS map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe creates a set of Internet web map tiles from your QGIS map. What's
    interesting about this recipe is that once the static map tiles are generated,
    you can serve them up locally or from any web-accessible directory using the client-side
    browser's JavaScript without the need of a map server, or you can serve them (for
    example, distribute them on a portable USB drive).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need to download the zipped shapefile from [https://geospatialpython.googlecode.com/svn/countries.zip](https://geospatialpython.googlecode.com/svn/countries.zip).
  prefs: []
  type: TYPE_NORMAL
- en: Unzip the shapefile to a directory named `shapes` in your `qgis_data` directory.
    Next, create a directory called `tilecache` in your `qgis_data` directory. You
    will also need to install the **QTiles** plugin using the **QGIS Plugin Manager**.
    This plugin is experimental, so make sure that the **Show also experimental plugins**
    checkbox is checked in the QGIS Plugin Manager's **Settings** tab.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will load the shapefile and randomly color each country. We''ll then manipulate
    the **QTiles** plugin using Python to generate map tiles for `5` zoom levels''
    worth of tiles. To do this, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to import all the necessary Python libraries, including the
    QTiles plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we create a color function that can produce random colors. This function
    accepts a mixed color, which defaults to white, to change the overall tone of
    the color palette:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll create a simple callback function for notification of when the
    tile generation is done. This function will normally be used to create a message
    bar or other notification, but we''ll keep things simple here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we set the path to the shapefile and the tile''s output direction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we load the shapefile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, we define the field that is used to color the countries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to get all the features so that we can loop through them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll build our color renderer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we''ll set the layer renderer and add it to the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we''ll set all the properties we need for the image tiles, including the
    map elements and image properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are ready to generate the tiles using the efficient threading system of
    the `QTiles` plugin. We''ll create a thread object and pass it all of the tile
    settings previously mentioned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can connect the finish signal to our simple callback function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we start the tiling process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once you receive the completion message, check the output directory and verify
    that there is an HTML file named `countries.html` and a directory named `countries`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on the `countries.html` page to open it in a browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the map loads, click on the plus symbol (**+**) in the upper-left corner
    twice to zoom the map.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, pan around to see the tiled version of your map load.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can generate up to 16 zoom levels with this plugin. After eight zoom levels,
    the tile generation process takes a long time and the tile set becomes quite large
    on the filesystem, totaling hundreds of megabytes. One way to avoid creating a
    lot of files is to use the **mbtiles** format, which stores all the data in a
    single file. However, you need a web application using GDAL to access it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can see a working example of the output recipe stored in a `github.io` web
    directory at [http://geospatialpython.github.io/qgis/tiles/countries.html](http://geospatialpython.github.io/qgis/tiles/countries.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows the output in a browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/00064.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Adding a layer to geojson.io
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cloud services have become common and geospatial maps are no exception. This
    recipe uses a service named geojson.io, which serves vector layers online, which
    you can upload from QGIS using Python.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need to install the **qgisio** plugin using the **QGIS
    Plugin Manager**.
  prefs: []
  type: TYPE_NORMAL
- en: You will also need a shapefile in a geodetic coordinate system (WGS84) from
    [https://geospatialpython.googlecode.com/svn/union.zip](https://geospatialpython.googlecode.com/svn/union.zip).
  prefs: []
  type: TYPE_NORMAL
- en: Decompress the ZIP file and place it in your `qgis_data` directory named `shapes`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will convert our shapefile to GeoJSON using a temporary file. We''ll then
    use Python to call the **qgisio** plugin in order to upload the data to be displayed
    online. To do this, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to import all the relevant Python libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we set up the layer and get the layer''s name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we establish a temporary file using the Python tempfile module for the
    GeoJSON conversion:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we''ll establish the coordinate reference system needed for the conversion,
    which must be WGS84 Geographic, to work with the cloud service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we can write out the layer as GeoJSON:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can make sure that the conversion didn''t have any problems:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can read the GeoJSON content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then need to remove the temporary file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are ready to upload our GeoJSON to geojson.io using the `qgisio` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can then use the Qt library to open the map in a browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe actually uses two cloud services. The GeoJSON data is stored on
    a [https://github.com](https://github.com) service named Gist that allows you
    to store code snippets such as `JSON`. The geojson.io service can read data from
    Gist.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that sometimes it can take several seconds to several minutes for the generated
    URL to become available online.
  prefs: []
  type: TYPE_NORMAL
- en: 'This screenshot shows the building layer on an OSM map on geojson.io, with
    the GeoJSON displayed next to the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/00065.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are additional advanced services that can serve QGIS maps, including [www.QGISCloud.com](http://www.QGISCloud.com)
    and [www.CartoDB.com](http://www.CartoDB.com), which can also display raster maps.
    Both of these services have free options and QGIS plugins. However, they are far
    more difficult to script from Python if you are trying to automate publishing
    maps to the Web as part of a workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering map layers based on rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rendering rules provide a powerful way to control how and when a layer is displayed
    relative to other layers or to the properties of the layer itself. Using a rule-based
    renderer, this recipe demonstrates how to color code a layer based on an attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need to download a zipped shapefile from [https://geospatialpython.googlecode.com/svn/ms_rails_mstm.zip](https://geospatialpython.googlecode.com/svn/ms_rails_mstm.zip).
  prefs: []
  type: TYPE_NORMAL
- en: Unzip it and place it in the directory named `ms` in your `qgis_data` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this same directory, download and unzip the following shapefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://geospatialpython.googlecode.com/files/Mississippi.zip](https://geospatialpython.googlecode.com/files/Mississippi.zip)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, add this shapefile to the directory as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://geospatialpython.googlecode.com/svn/jackson.zip](https://geospatialpython.googlecode.com/svn/jackson.zip)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will set up a railroad layer, then we''ll set up our rules as Python tuples
    to color code it based on the frequency of use. Finally, we''ll add some other
    layers to the map for reference. To do this, we need to perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to import the QTGui library to work with colors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll set up our data path to avoid typing it repeatedly. Replace this
    string with the path to your `qgis_data` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can load our railroad layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can define our rules as a set of tuples. Each rule defines a label
    and an expression, detailing which attribute values make up that rule, a color
    name, and the minimum/maximum map scale values at which the described features
    are visible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we create a rule-based renderer and a base symbol to begin applying our
    rules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The rules are a hierarchy based on a root rule, so we must access the root
    first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will loop through our rules, clone the default rule, and append our
    custom rule to the tree:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now delete the default rule, which isn''t part of our rendering scheme:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we apply the renderer to our `rails` layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll establish and style a city layer, which will provide a focal point to
    zoom into so that we can easily see the scale-based rendering effect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we''ll set up and style a border layer around both the datasets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we''ll add everything to the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rules are a hierarchical collection of symbols and expressions. Symbols are
    collections of symbol layers. This recipe is relatively simple but contains over
    50 lines of code. Rendering is one of the most complex features to code in QGIS.
    However, rules also have their own sets of properties, separate from layers and
    symbols. Notice that in this recipe, we are able to set labels and filters for
    the rules, properties that are normally relegated to layers. One way to think
    of rules is as separate layers. We can do the same thing by loading our railroad
    layer as a new layer for each rule. Rules are a more compact way to break up the
    rendering for a single layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'This image shows the rendering at a scale where all the rule outputs are visible:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/00066.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a layer style file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Layer styling is one of the most complex aspects of the QGIS Python API. Once
    you've developed the style for a layer, it is often useful to save the styling
    to the **QGIS Markup Language** (**QML**) in the XML format.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need to download the zipped directory named `saveqml` and decompress
    it to your `qgis_data/rasters` directory from [https://geospatialpython.googlecode.com/svn/saveqml.zip](https://geospatialpython.googlecode.com/svn/saveqml.zip).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create a color ramp for a DEM and make it semi transparent to overlay
    a hillshaded tiff of the DEM. We''ll save the style we create to a QML file. To
    do this, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll need the following Python Qt libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll load our two raster layers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll perform a histogram stretch on our DEM for better visualization:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we''ll create a visually pleasing color ramp based on the elevation values
    of the DEM as a renderer and apply it to the layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can add the layers to the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, with this line, we can save the DEM''s styling to a reusable QML file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The QML format is easy to read and can be edited by hand. The `saveNamedStyle()`
    method works on vector layers in the exact same way. Instead of styling the preceding
    code, you can just reference the QML file using the `loadNamedStyle()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: If you save the QML file along with a shapefile and use the same filename (with
    the `.qml` extension), then QGIS will load the style automatically when the shapefile
    is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Using NULL values in PyQGIS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: QGIS can use NULL values as field values. Python has no concept of NULL values.
    The closest type it has is the `None` type. You must be aware of this fact when
    working with Python in QGIS. In this recipe, we'll explore the implications of
    QGIS's NULL values in Python. The computing of a NULL value involves a pointer
    that is an uninitialized, undefined, empty, or meaningless value.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In your `qgis_data/shapes` directory, download the shapefile from [https://geospatialpython.googlecode.com/svn/NullExample.zip](https://geospatialpython.googlecode.com/svn/NullExample.zip),
    which contains some NULL field values, and unzip it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will load the shapefile and grab its first feature. Then, we''ll access
    one of its NULL field values. Next, we''ll run through some tests that allow you
    to see how the NULL values behave in Python. To do this, we need to perform the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll load the shapefile and access its first feature:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll grab one of the NULL field values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we''ll check the NULL value''s type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we''ll see whether the value is the Python `None` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we''ll see whether it is equivalent to `None`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll see whether the value matches the QGIS NULL type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we''ll see whether it is actually NULL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we''ll do a type match to the QGIS NULL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see, the type of the NULL value is `PyQt4.QtCore.QPyNullVariant`.
    This class is a special type injected into the PyQt framework. It is important
    to note the cases where the comparison using the `is` operator returns a different
    value than the `==` operator comparison. You should be aware of the differences
    to avoid unexpected results in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Using generators for layer queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python generators provide an efficient way to process large datasets. A QGIS
    developer named Nathan Woodrow has created a simple Python QGIS query engine that
    uses generators to easily fetch features from QGIS layers. We'll use this engine
    in this recipe to query a layer.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need to install the query engine using `easy_install` or by downloading
    it and adding it to your QGIS Python installation. To use `easy_install`, run
    the following command from a console, which downloads a clone of the original
    code that includes a Python setup file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/GeospatialPython/qquery/archive/master.zip](https://github.com/GeospatialPython/qquery/archive/master.zip)'
  prefs: []
  type: TYPE_NORMAL
- en: You can also download the ZIP file from [https://github.com/NathanW2/qquery/archive/master.zip](https://github.com/NathanW2/qquery/archive/master.zip)
    and copy the contents to your working directory or the `site-packages` directory
    of your QGIS Python installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also need to download the zipped shapefile and decompress it to a
    directory named `ms` in your `qgis_data` directory from the following location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://geospatialpython.googlecode.com/files/MS_UrbanAnC10.zip](https://geospatialpython.googlecode.com/files/MS_UrbanAnC10.zip)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll load a layer containing population data. Then, we''ll use the query
    engine to perform a simple query for an urban area with less than 50,000 people.
    We''ll filter the results to only give us three columns, place name, population
    level, and land area. To do this, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import the query engine module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we set up the path to our shapefile and load it as a vector layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can run the query, which uses Python''s dot notation to perform a `where`
    clause search and then filter using a `select` statement. This line will return
    a generator with the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we''ll use the query''s generator to iterate to the first result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see, this module is quite handy. To perform this same query using
    the default PyQGIS API, it would take nearly four times as much code.
  prefs: []
  type: TYPE_NORMAL
- en: Using alpha values to show data density
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thematic maps often use a color ramp based on a single color to show data density.
    Darker colors show a higher concentration of objects, while lighter colors show
    lower concentrations. You can use a transparency ramp instead of a color ramp
    to show density as well. This technique is useful if you want to overlay the density
    layer on imagery or other vector layers. In this recipe, we'll be using some bear-sighting
    data to show the concentration of bears over an area. We'll use alpha values to
    show the density. We'll use an unusual hexagonal grid to divide the area and a
    rule-based renderer to build the display.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need to install the MMQGIS plugin, which is used to build the hexagonal
    grid using the QGIS **Plugin Manager**.
  prefs: []
  type: TYPE_NORMAL
- en: You also need to download the bear data from [https://geospatialpython.googlecode.com/svn/bear-data.zip](https://geospatialpython.googlecode.com/svn/bear-data.zip),
    unzip the shapefile, and put it in the `ms` directory of your `qgis_data` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will load the bear data. Then, we will use the MMQGIS plugin to generate
    the hexagonal grid. Then, we''ll use the Processing Toolbox to clip the hexagon
    to the bear shapefile, and join the shapefile attribute data to the hexagon grid.
    Finally, we''ll use a rule-based renderer to apply alpha values based on bear-sighting
    density and add the result to the map. To do this, we need to perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import all the libraries we''ll need, including the processing engine,
    the PyQt GUI library for color management, and the MMQGIS plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll set up the paths for all of our input and output shapefiles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can set up the input shapefile as a layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll need the extent of the shapefile to create the grid as well as the width
    and height, in map units:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can use the MMQGIS plugin to generate the grid over the entire shapefile''s
    extent. We''ll use a grid cell size of one-tenth of a degree (approximately 6
    miles):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can clip the grid to the shape of our source data using the Processing
    Toolbox:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to do a spatial join in order to match the source data''s attributes
    based on counties to each grid cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can add this output as a layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we create our rendering rule set as Python tuples, specifying a label,
    value expression, color, and alpha level for the symbols between 0 and 1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then create the default symbol rule renderer and add the rules to the renderer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We remove the default rule:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We apply the renderer to the layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we add the finished density layer to the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The rule-based renderer forms the core of this recipe. However, the hexagonal
    grid provides a more interesting way to visualize statistical data. Like a dot-based
    density map, hexagons are not entirely spatially accurate or precise but make
    it very easy to understand the overall trend of the data. The interesting feature
    of hexagons is their centroid, which is equidistant to each of their neighbors,
    whereas with a square grid, the diagonal neighbors are further away.
  prefs: []
  type: TYPE_NORMAL
- en: 'This image shows how the resulting map will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/00067.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using the __geo_interface__ protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe requires no preparation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create two functions: one for features and one for geometry. We''ll
    then use Python''s dynamic capability to patch the QGIS objects with a `__geo_interface__
    built-in` method. To do this, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll need the Python `json` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll create our function for the features that take a feature as input
    and return a GeoJSON-like object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we''ll create the `geometry` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we''ll patch the QGIS feature and geometry objects with our custom
    built-in to call our functions when the built-in is accessed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is surprisingly simple but exploits some of Python's most interesting
    features. First, note that the feature function actually calls the geometry function
    as part of its output. Also, note that adding the `__geo_interface__` built-in
    function is as simple as using the double-underscore naming convention and Python's
    built-in property method to declare lambda functions as internal to the objects.
    Another interesting Python feature is that the QGIS objects are able to pass themselves
    to our custom functions using the self keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Generating points along a line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can generate points within a polygon in a fairly simple way by using the
    point in polygon method. However, sometimes you may want to generate points along
    a line. You can randomly place points inside the polygon's extent — which is essentially
    just a rectangular polygon — or you can place points at random locations along
    the line at random distances. In this recipe, we'll demonstrate both of these
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will need to download the zipped shapefile and place it in a directory
    named `shapes` in your `qgis_data` directory from the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://geospatialpython.googlecode.com/svn/path.zip](https://geospatialpython.googlecode.com/svn/path.zip)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we will generate random points along a line using a `grass()` function
    in the Processing Toolbox. Then, we''ll generate points within the line''s extent
    using a native QGIS processing function. To do this, we need to perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to import the processing module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we''ll load the line layer onto the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll generate points along the line by specifying the path to the shapefile,
    a maximum distance between the points in map units (meters), the type of feature
    we want to output (vertices), extent, snap tolerance option, minimum distance
    between the points, output type, and output name. We won''t specify the name and
    tell QGIS to load the output automatically:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we''ll create some points within the lines'' extent and load them
    as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first algorithm puts the points on the line. The second places them within
    the vicinity. Both approaches have different use cases.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another option will be to create a buffer around the line at a specified distance
    and clip the output of the second algorithm so that the points aren't near the
    corners of the line extent. The `QgsGeometry` class also has an interpolate which
    allows you to create a point on a line at a specified distance from its origin.
    This is documented at [http://qgis.org/api/classQgsGeometry.html#a8c3bb1b01d941219f2321e6c6c3db7e1](http://qgis.org/api/classQgsGeometry.html#a8c3bb1b01d941219f2321e6c6c3db7e1).
  prefs: []
  type: TYPE_NORMAL
- en: Using expression-based labels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Expressions are a kind of mini-programming language or SQL-like language found
    throughout different QGIS functions to select features. One important use of expressions
    is to control labels. Maps easily become cluttered if you label every single feature.
    Expressions make it easy to limit labels to important features. You can filter
    labels using expressions from within Python, as we will do in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will need to download the zipped shapefile and decompress it to a directory
    named `ms` in your `qgis_data` directory from the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://geospatialpython.googlecode.com/files/MS_UrbanAnC10.zip](https://geospatialpython.googlecode.com/files/MS_UrbanAnC10.zip)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll use the QGIS PAL labeling engine to filter labels based on a field name.
    After loading the layer, we''ll create our PAL settings and write them to the
    layer. Finally, we''ll add the layer to the map. To do this, we need to perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll set up the path to our shapefile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll load our layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we create a labeling object and read the layer''s current labeling settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We create our expression to only label the features whose population field
    is greater than 50,000:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we enable these settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we apply the labeling filter to the layer and add it to the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While labels are a function of the layer, the settings for the labeling engine
    are controlled by an external object and then applied to the layer.
  prefs: []
  type: TYPE_NORMAL
- en: Creating dynamic forms in QGIS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you edit the fields of a layer in QGIS, you have the option of using a
    spreadsheet-like table view or you can use a database-style form view. Forms are
    useful because you can change the design of the form and add interactive features
    that react to user input in order to better control data editing. In this recipe,
    we'll add some custom validation to a form that checks user input for valid values.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will need to download the zipped shapefile and decompress it to a directory
    named `ms` in your `qgis_data` directory from the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://geospatialpython.googlecode.com/files/MS_UrbanAnC10.zip](https://geospatialpython.googlecode.com/files/MS_UrbanAnC10.zip)'
  prefs: []
  type: TYPE_NORMAL
- en: You'll also need to create a blank Python file called `validate.py`, which you'll
    edit as shown in the following steps. Put the `validate.py` file in the `ms` directory
    of your `qgis_data` directory with the shapefile.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll create the two functions we need for our validation engine. Then, we''ll
    use the QGIS interface to attach the action to the layer. Make sure that you add
    the following code to the `validate.py` file in the same directory as the shapefile,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll import the Qt libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll create some global variables for the attribute we''ll be validating
    and the form dialog:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we''ll begin building the function that changes the behavior of the dialog
    and create variables for the field we want to validate and the submit button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We must disconnect the dialog from the action that controls the form acceptance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we reconnect the dialogs, actions to our custom actions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we''ll create the validation function that will reject the form if the
    population field has a value less than 1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, open QGIS and drag and drop the shapefile from your filesystem onto the
    map canvas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the project and give it a name in the same directory as the `validate.py`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the QGIS legend, double-click on the layer name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Fields** tab on the left-hand side of the **Layer Properties**
    dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Fields** tab at the top-right of the screen, enter the following line
    into the **PythonInit Function** field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Click on the **OK** button, in the bottom-right of the **Layer Properties**
    dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, use the identify tool to select a feature.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Feature Properties** dialog, click on the form icon in the top-left
    of the image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the feature form is open, switch back to the **QGIS Legend**, right-click
    on the layer name, and select **Toggle Editing**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch back to the feature form, scroll down to the **POP** field, and change
    the value to `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, click on the **OK** button and verify that you've received the warning
    dialog, which requires the value to be greater than `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `validate.py` file must be in your Python path. Putting this file in the
    same directory as the project makes the functions available. Validation is one
    of the simplest functions you can implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'This screenshot shows the rejection message when the population is set to `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/00068.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Calculating length for all selected lines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you need to calculate the total of a given dataset property, such as length,
    the easiest thing to do is use Python. In this recipe, we'll total the length
    of the railways in a dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need to download a zipped shapefile from [https://geospatialpython.googlecode.com/svn/ms_rails_mstm.zip](https://geospatialpython.googlecode.com/svn/ms_rails_mstm.zip).
  prefs: []
  type: TYPE_NORMAL
- en: Unzip it and place it in directory named `ms` in your `qgis_data` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will load the layer, loop through the features while keeping a running total
    of line lengths, and finally convert the result to kilometers. To do this, we
    need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll set up the path to our shapefile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we''ll load the layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need a variable to total the line lengths:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we loop through the layer, getting the length of each line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we print the total length converted to kilometers and format the string
    to only show two decimal places:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This function is simple, but it's not directly available in the QGIS API. You
    can use a similar technique to total up the area of a set of polygons or perform
    conditional counting.
  prefs: []
  type: TYPE_NORMAL
- en: Using a different status bar CRS than the map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you may want to display a different coordinate system for the mouse
    coordinates in the status bar than what the source data is. With this recipe,
    you can set a different coordinate system without changing the data coordinate
    reference system or the CRS for the map.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Download the zipped shapefile and unzip it to your `qgis_data/ms` directory
    from the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://geospatialpython.googlecode.com/files/MSCities_Geo.zip](https://geospatialpython.googlecode.com/files/MSCities_Geo.zip)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will load our layer, establish a message in the status bar, create a special
    event listener to transform the map coordinates at the mouse''s location to our
    alternate CRS, and then connect the map signal for the mouse''s map coordinates
    to our listener function. To do this, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to import the Qt core library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we will set up the path to the shapefile and load it as a layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we add the layer to the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we create a default message that will be displayed in the status bar
    and will be replaced by the alternate coordinates later, when the event listener
    is active:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we display our default message in the left-hand side of the status bar
    as a placeholder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we create our custom event-listener function to transform the mouse''s
    map location to our custom CRS, which in this case is **EPSG 3815**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we connect the map canvas signal that is emitted when the mouse coordinates
    are updated to our custom event listener:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, verify that when you move the mouse around the map, the status bar
    is updated with the transformed coordinates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The coordinate transformation engine in QGIS is very fast. Normally, QGIS tries
    to transform everything to WGS84 Geographic, but sometimes you need to view coordinates
    in a different reference system.
  prefs: []
  type: TYPE_NORMAL
- en: Creating HTML labels in QGIS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: QGIS map tips allow you to hover the mouse cursor over a feature in order to
    create a popup that displays information. This information is normally a data
    field, but you can also display other types of information using a subset of HTML
    tags. In this recipe, we'll create an HTML map tip that displays a Google Street
    View image at the feature's location.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In your `qgis_data` directory, create a directory named `tmp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also need to download the following zipped shapefile and place it
    in your `qgis_data/nyc` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://geospatialpython.googlecode.com/files/NYC_MUSEUMS_GEO.zip](https://geospatialpython.googlecode.com/files/NYC_MUSEUMS_GEO.zip)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create a function to process the Google data and register it as a QGIS
    function. Then, we''ll load the layer and set its map tip display field. To do
    this, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to import the Python libraries we''ll need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll set a special QGIS Python decorator that registers our function
    as a QGIS function. The first argument, `0`, means that the function won''t accept
    any arguments itself. The second argument, `Python`, defines the group in which
    the function will appear when you use the expression builder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll create a function that accepts a feature and uses its geometry to pull
    down a Google Street View image. We must cache the images locally because the
    Qt widget that displays the map tips only allows you to use local images:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can load the layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we can set the display field using a special QGIS tag with the name of
    our function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we add it to the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Select the map tips tool and hover over the different points to see the Google
    Street View images.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The key to this recipe is the `@qgsfunction` decorator. When you register the
    function in this way, it shows up in the menus for Python functions in expressions.
    The function must also have the parent and value parameters, but we didn't need
    them in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows a Google Street View map tip:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/00069.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you don''t need the function any more, you must unregister it for the function
    to go away. The `unregister` command uses the following convention, referencing
    the function name with a dollar sign:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Using OpenStreetMap's points of interest in QGIS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenStreetMap has an API called Overpass that lets you access OSM data dynamically.
    In this recipe, we'll add some OSM tourism points of interest to a map.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need to use the QGIS **Plugin Manager** to install the **Quick OSM**
    plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also need to download the following shapefile and unzip it to your
    `qgis_data/ms` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://geospatialpython.googlecode.com/svn/MSCoast_geo.zip](https://geospatialpython.googlecode.com/svn/MSCoast_geo.zip)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will load our base layer that defines the area of interest. Then, we''ll
    use the Processing Toolbox to build a query for OSM, download the data, and add
    it to the map. To do this, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to import the `processing` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to load the base layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we''ll need the layer''s extents for the processing algorithms:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we create the query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The Quick OSM algorithm has a bug in its output, so we''ll create a properly
    formatted XML tag and perform a string replace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we download the OSM data using our query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We define the names of the shapefiles we will create from the OSM output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we convert the OSM data to shapefiles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We place the points as a layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we can add them to a map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Quick OSM plugin manages the Overpass API. What's interesting about this
    plugin is that it provides processing algorithms in addition to a GUI interface.
    The processing algorithm that creates the query unfortunately formats the `bbox-query`
    tag improperly, so we need to work around this issue with the string replace.
    The API returns an OSM XML file that we must convert to shapefiles for use in
    QGIS.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing data in 3D with WebGL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: QGIS displays data in a two-dimensions even if the data is three-dimensional.
    However, most modern browsers can display 3D data using the WebGL standard. In
    this recipe, we'll use the **Qgis2threejs** plugin to display QGIS data in 3D
    in a browser.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will need to download some raster elevation data in the zipped directory
    and place it in your `qgis_data` directory from the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://geospatialpython.googlecode.com/svn/saveqml.zip](https://geospatialpython.googlecode.com/svn/saveqml.zip)'
  prefs: []
  type: TYPE_NORMAL
- en: You will also need to install the **Qgis2threejs** plugin using the QGIS **Plugin
    Manager**.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will set up a color ramp for a DEM draped over a hillshade image and use
    the plugin to create a WebGL page in order to display the data. To do this, we
    need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will need to import the relevant libraries and the **Qgis2threejs**
    plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll disable QGIS automatic reprojection to keep the data display in
    meters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can load our raster layers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can create the color ramp renderer for the DEM layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we''re ready to add the raster layers to the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To create the WebGL interface, we need to take control of the plugin''s GUI
    dialog, but we will keep it hidden:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we must create a dictionary of the properties required by the plugin.
    The most important is the layer ID of the DEM layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will apply these properties to the plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We must set the output file for the HTML page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the next step, we must override the method that saves the properties, otherwise
    it overwrites the properties we set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we are ready to run the plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: On your filesystem, navigate to the HTML output page and open it in a browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the help instructions to move the 3D elevation display around.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This plugin is absolutely not designed for script-level access. However, Python
    is so flexible that we can even script the plugin at the GUI level and avoid displaying
    the GUI, so it is seamless to the user. The only glitch in this approach is that
    the save method overwrites the properties we set, so we must insert a dummy function
    that prevents this overwrite.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows the WebGL viewer in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/00070.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Visualizing data on a globe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ever since the release of Google Earth, *spinning globe* applications have become
    a useful and popular method of geographic exploration. QGIS has an experimental
    plugin called **QGIS Globe**, which is similar to Google Earth; however, it is
    extremely unstable. In this recipe, we'll display a layer in Google Earth.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need to use the QGIS **Plugin Manager** to install the **MMQGIS** plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you have Google Earth installed from [https://www.google.com/earth/](https://www.google.com/earth/).
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also need the following dataset from a previous recipe. It is a zipped
    directory called `ufo` which you should uncompress to your `qgis_data` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://geospatialpython.googlecode.com/svn/ufo.zip](https://geospatialpython.googlecode.com/svn/ufo.zip)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will load our layer and set up the attribute we want to use for the Google
    Earth KML output as the descriptor. We''ll use the MMQIGS plugin to output our
    layer to KML. Finally, we''ll use a cross-platform technique to open the file,
    which will trigger it to open in Google Earth. To do this, we need to perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will import the relevant Python libraries including the plugin. We
    will use the Python `webbrowser` module to launch Google Earth:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we''ll load the layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll set the output path for the KML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we''ll set up the variables needed by the plugin for the KML output which
    make up the layer identifier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can use the plugin to create the KML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we''ll use the `webbrowser` module to open the KML file, which will
    default to opening in Google Earth. We need to add the `file` protocol at the
    beginning of our output for the `webbrowser` module to work:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The MMQGIS plugin does a good job with custom scripts and has easy-to-use functions.
    While our method for automatically launching Google Earth may not work in every
    possible case, it is almost perfect.
  prefs: []
  type: TYPE_NORMAL
