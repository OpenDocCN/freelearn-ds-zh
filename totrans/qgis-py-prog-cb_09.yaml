- en: Chapter 9. Other Tips and Tricks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章。其他技巧和窍门
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下配方：
- en: Creating tiles from a QGIS map
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 QGIS 地图中创建瓦片
- en: Adding a layer to geojson.io
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将图层添加到 geojson.io
- en: Rendering map layers based on rules
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据规则渲染地图图层
- en: Creating a layer style file
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建图层样式文件
- en: Using NULL values in PyQGIS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 PyQGIS 中使用 NULL 值
- en: Using generators for layer queries
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用生成器进行图层查询
- en: Using alpha values to show data density
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 alpha 值显示数据密度
- en: Using the `__geo_interface__` protocol
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `__geo_interface__` 协议
- en: Generating points along a line
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 沿着线生成点
- en: Using expression-based labels
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于表达式的标签
- en: Creating dynamic forms in QGIS
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 QGIS 中创建动态表单
- en: Calculating length for all the selected lines
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算所有选中线的长度
- en: Using a different status bar CRS than the map
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用与地图不同的状态栏 CRS
- en: Creating HTML labels in QGIS
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 QGIS 中创建 HTML 标签
- en: Using OpenStreetMap's points of interest in QGIS
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 QGIS 中使用 OpenStreetMap 的兴趣点
- en: Visualizing data in 3D with WebGL
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 WebGL 在 3D 中可视化数据
- en: Visualizing data on a globe
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在地球上可视化数据
- en: Introduction
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter provides interesting and valuable QGIS Python tricks that didn't
    fit into any topics in other chapters. Each recipe has a specific purpose, but
    in many cases, a recipe may demonstrate multiple concepts that you'll find useful
    in other programs. All the recipes in this chapter run in the QGIS Python console.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了有趣的、有价值的 QGIS Python 技巧，这些技巧没有包含在其他章节的任何主题中。每个配方都有一个特定的目的，但在许多情况下，一个配方可能展示了多个您在其他程序中会发现有用的概念。本章中的所有配方都在
    QGIS Python 控制台中运行。
- en: Creating tiles from a QGIS map
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 QGIS 地图中创建瓦片
- en: This recipe creates a set of Internet web map tiles from your QGIS map. What's
    interesting about this recipe is that once the static map tiles are generated,
    you can serve them up locally or from any web-accessible directory using the client-side
    browser's JavaScript without the need of a map server, or you can serve them (for
    example, distribute them on a portable USB drive).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方从您的 QGIS 地图中创建一组互联网网络地图瓦片。这个配方的有趣之处在于，一旦生成了静态地图瓦片，您可以在本地或从任何可访问的 Web 目录使用客户端浏览器的
    JavaScript 提供它们，而无需地图服务器，或者您可以将它们（例如，在可移动的 USB 驱动器上分发）。
- en: Getting ready
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need to download the zipped shapefile from [https://geospatialpython.googlecode.com/svn/countries.zip](https://geospatialpython.googlecode.com/svn/countries.zip).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要从 [https://geospatialpython.googlecode.com/svn/countries.zip](https://geospatialpython.googlecode.com/svn/countries.zip)
    下载压缩的 shapefile。
- en: Unzip the shapefile to a directory named `shapes` in your `qgis_data` directory.
    Next, create a directory called `tilecache` in your `qgis_data` directory. You
    will also need to install the **QTiles** plugin using the **QGIS Plugin Manager**.
    This plugin is experimental, so make sure that the **Show also experimental plugins**
    checkbox is checked in the QGIS Plugin Manager's **Settings** tab.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 将 shapefile 解压缩到 `qgis_data` 目录中名为 `shapes` 的目录。接下来，在 `qgis_data` 目录中创建一个名为
    `tilecache` 的目录。您还需要使用 **QGIS 插件管理器** 安装 **QTiles** 插件。此插件是实验性的，所以请确保在 QGIS 插件管理器的
    **设置** 选项卡中勾选了 **显示实验性插件** 复选框。
- en: How to do it...
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will load the shapefile and randomly color each country. We''ll then manipulate
    the **QTiles** plugin using Python to generate map tiles for `5` zoom levels''
    worth of tiles. To do this, we need to perform the following steps:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将加载 shapefile 并随机着色每个国家。然后，我们将使用 Python 操作 **QTiles** 插件以生成 `5` 个缩放级别的地图瓦片。为此，我们需要执行以下步骤：
- en: 'First, we need to import all the necessary Python libraries, including the
    QTiles plugin:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要导入所有必要的 Python 库，包括 QTiles 插件：
- en: '[PRE0]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we create a color function that can produce random colors. This function
    accepts a mixed color, which defaults to white, to change the overall tone of
    the color palette:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建一个可以产生随机颜色的颜色函数。此函数接受混合颜色，默认为白色，以改变整个颜色调的基调：
- en: '[PRE1]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we''ll create a simple callback function for notification of when the
    tile generation is done. This function will normally be used to create a message
    bar or other notification, but we''ll keep things simple here:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个简单的回调函数，用于在瓦片生成完成后通知。此函数通常用于创建消息栏或其他通知，但我们将保持简单：
- en: '[PRE2]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we set the path to the shapefile and the tile''s output direction:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们设置 shapefile 的路径和瓦片的输出方向：
- en: '[PRE3]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, we load the shapefile:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们加载 shapefile：
- en: '[PRE4]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After that, we define the field that is used to color the countries:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们定义用于着色国家的字段：
- en: '[PRE5]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we need to get all the features so that we can loop through them:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要获取所有要素，以便我们可以遍历它们：
- en: '[PRE6]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We''ll build our color renderer:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将构建我们的颜色渲染器：
- en: '[PRE7]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, we''ll set the layer renderer and add it to the map:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将设置图层渲染器并将其添加到地图中：
- en: '[PRE8]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we''ll set all the properties we need for the image tiles, including the
    map elements and image properties:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将设置图像瓦片所需的所有属性，包括地图元素和图像属性：
- en: '[PRE9]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We are ready to generate the tiles using the efficient threading system of
    the `QTiles` plugin. We''ll create a thread object and pass it all of the tile
    settings previously mentioned:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们准备好使用`QTiles`插件的效率线程系统生成瓦片。我们将创建一个线程对象，并传递之前提到的所有瓦片设置：
- en: '[PRE10]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, we can connect the finish signal to our simple callback function:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以将完成信号连接到我们的简单回调函数：
- en: '[PRE11]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we start the tiling process:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们开始瓦片处理过程：
- en: '[PRE12]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Once you receive the completion message, check the output directory and verify
    that there is an HTML file named `countries.html` and a directory named `countries`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦收到完成消息，检查输出目录并验证是否存在名为`countries.html`的HTML文件和一个名为`countries`的目录。
- en: Double-click on the `countries.html` page to open it in a browser.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`countries.html`页面，在浏览器中打开它。
- en: Once the map loads, click on the plus symbol (**+**) in the upper-left corner
    twice to zoom the map.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦地图加载，点击左上角的加号符号（**+**）两次以放大地图。
- en: Next, pan around to see the tiled version of your map load.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，四处移动以查看您的地图瓦片版本加载。
- en: How it works...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You can generate up to 16 zoom levels with this plugin. After eight zoom levels,
    the tile generation process takes a long time and the tile set becomes quite large
    on the filesystem, totaling hundreds of megabytes. One way to avoid creating a
    lot of files is to use the **mbtiles** format, which stores all the data in a
    single file. However, you need a web application using GDAL to access it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此插件，您可以生成多达16个缩放级别。在八个缩放级别之后，瓦片生成过程会花费很长时间，瓦片集在文件系统上变得相当大，总计数百兆字节。避免创建大量文件的一种方法是用**mbtiles**格式，它将所有数据存储在一个文件中。但是，您需要一个使用GDAL的Web应用程序来访问它。
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can see a working example of the output recipe stored in a `github.io` web
    directory at [http://geospatialpython.github.io/qgis/tiles/countries.html](http://geospatialpython.github.io/qgis/tiles/countries.html).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在存储在`github.io`网络目录中的输出菜谱的示例中看到工作效果，网址为[http://geospatialpython.github.io/qgis/tiles/countries.html](http://geospatialpython.github.io/qgis/tiles/countries.html)。
- en: 'The following image shows the output in a browser:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了浏览器中的输出：
- en: '![How it works...](img/00064.jpeg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/00064.jpeg)'
- en: Adding a layer to geojson.io
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将图层添加到geojson.io
- en: Cloud services have become common and geospatial maps are no exception. This
    recipe uses a service named geojson.io, which serves vector layers online, which
    you can upload from QGIS using Python.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 云服务已成为常态，地理空间地图也不例外。这个菜谱使用一个名为geojson.io的服务，该服务提供在线矢量图层，您可以使用Python从QGIS上传。
- en: Getting ready
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you will need to install the **qgisio** plugin using the **QGIS
    Plugin Manager**.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，您需要使用**QGIS插件管理器**安装**qgisio**插件。
- en: You will also need a shapefile in a geodetic coordinate system (WGS84) from
    [https://geospatialpython.googlecode.com/svn/union.zip](https://geospatialpython.googlecode.com/svn/union.zip).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要从[https://geospatialpython.googlecode.com/svn/union.zip](https://geospatialpython.googlecode.com/svn/union.zip)获取一个在测地坐标系（WGS84）中的shapefile。
- en: Decompress the ZIP file and place it in your `qgis_data` directory named `shapes`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 解压缩ZIP文件并将其放置在您的`qgis_data`目录中，命名为`shapes`。
- en: How to do it...
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will convert our shapefile to GeoJSON using a temporary file. We''ll then
    use Python to call the **qgisio** plugin in order to upload the data to be displayed
    online. To do this, we need to perform the following steps:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用临时文件将我们的shapefile转换为GeoJSON。然后，我们将使用Python调用**qgisio**插件，以便将数据上传到在线显示。为此，我们需要执行以下步骤：
- en: 'First, we need to import all the relevant Python libraries:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要导入所有相关的Python库：
- en: '[PRE13]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we set up the layer and get the layer''s name:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们设置图层并获取图层的名称：
- en: '[PRE14]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we establish a temporary file using the Python tempfile module for the
    GeoJSON conversion:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用Python的tempfile模块创建一个用于GeoJSON转换的临时文件：
- en: '[PRE15]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we''ll establish the coordinate reference system needed for the conversion,
    which must be WGS84 Geographic, to work with the cloud service:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将建立转换所需的坐标系，这必须是WGS84地理坐标系，以便与云服务协同工作：
- en: '[PRE16]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we can write out the layer as GeoJSON:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以将图层以GeoJSON格式输出：
- en: '[PRE17]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, we can make sure that the conversion didn''t have any problems:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以确保转换没有出现任何问题：
- en: '[PRE18]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, we can read the GeoJSON content:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以读取GeoJSON内容：
- en: '[PRE19]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We then need to remove the temporary file:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要删除临时文件：
- en: '[PRE20]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We are ready to upload our GeoJSON to geojson.io using the `qgisio` module:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以使用`qgisio`模块将我们的GeoJSON上传到geojson.io：
- en: '[PRE21]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can then use the Qt library to open the map in a browser:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以使用Qt库在浏览器中打开地图：
- en: '[PRE22]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: This recipe actually uses two cloud services. The GeoJSON data is stored on
    a [https://github.com](https://github.com) service named Gist that allows you
    to store code snippets such as `JSON`. The geojson.io service can read data from
    Gist.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方实际上使用了两个云服务。GeoJSON数据存储在名为Gist的[https://github.com](https://github.com)服务上，该服务允许您存储代码片段，如`JSON`。geojson.io服务可以读取Gist中的数据。
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that sometimes it can take several seconds to several minutes for the generated
    URL to become available online.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，有时生成可用的URL可能需要几秒钟到几分钟。
- en: 'This screenshot shows the building layer on an OSM map on geojson.io, with
    the GeoJSON displayed next to the map:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这张截图显示了geojson.io上OSM地图上的建筑图层，GeoJSON显示在地图旁边：
- en: '![How it works...](img/00065.jpeg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/00065.jpeg)'
- en: There's more...
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are additional advanced services that can serve QGIS maps, including [www.QGISCloud.com](http://www.QGISCloud.com)
    and [www.CartoDB.com](http://www.CartoDB.com), which can also display raster maps.
    Both of these services have free options and QGIS plugins. However, they are far
    more difficult to script from Python if you are trying to automate publishing
    maps to the Web as part of a workflow.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些额外的先进服务可以用于QGIS地图，包括[www.QGISCloud.com](http://www.QGISCloud.com)和[www.CartoDB.com](http://www.CartoDB.com)，它们也可以显示栅格地图。这两个服务都有免费选项和QGIS插件。然而，如果您尝试将地图发布到Web作为工作流程的一部分进行自动化，那么从Python脚本化这些服务会困难得多。
- en: Rendering map layers based on rules
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据规则渲染地图图层
- en: Rendering rules provide a powerful way to control how and when a layer is displayed
    relative to other layers or to the properties of the layer itself. Using a rule-based
    renderer, this recipe demonstrates how to color code a layer based on an attribute.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染规则提供了一种强大的方式来控制图层相对于其他图层或图层本身的属性如何以及何时显示。使用基于规则的渲染器，本配方演示了如何根据属性对图层进行着色编码。
- en: Getting ready
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need to download a zipped shapefile from [https://geospatialpython.googlecode.com/svn/ms_rails_mstm.zip](https://geospatialpython.googlecode.com/svn/ms_rails_mstm.zip).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要从[https://geospatialpython.googlecode.com/svn/ms_rails_mstm.zip](https://geospatialpython.googlecode.com/svn/ms_rails_mstm.zip)下载一个压缩的shapefile。
- en: Unzip it and place it in the directory named `ms` in your `qgis_data` directory.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 解压它并将其放置在您的`qgis_data`目录下名为`ms`的目录中。
- en: 'In this same directory, download and unzip the following shapefile:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一目录中，下载并解压以下shapefile：
- en: '[https://geospatialpython.googlecode.com/files/Mississippi.zip](https://geospatialpython.googlecode.com/files/Mississippi.zip)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://geospatialpython.googlecode.com/files/Mississippi.zip](https://geospatialpython.googlecode.com/files/Mississippi.zip)'
- en: 'Finally, add this shapefile to the directory as well:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还需要将此shapefile添加到目录中：
- en: '[https://geospatialpython.googlecode.com/svn/jackson.zip](https://geospatialpython.googlecode.com/svn/jackson.zip)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://geospatialpython.googlecode.com/svn/jackson.zip](https://geospatialpython.googlecode.com/svn/jackson.zip)'
- en: How to do it...
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will set up a railroad layer, then we''ll set up our rules as Python tuples
    to color code it based on the frequency of use. Finally, we''ll add some other
    layers to the map for reference. To do this, we need to perform the following
    steps:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设置一个铁路图层，然后我们将设置我们的规则作为Python元组，根据使用频率对其进行着色编码。最后，我们将添加一些其他图层作为参考。为此，我们需要执行以下步骤：
- en: 'First, we need to import the QTGui library to work with colors:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要导入QTGui库来处理颜色：
- en: '[PRE23]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we''ll set up our data path to avoid typing it repeatedly. Replace this
    string with the path to your `qgis_data` directory:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将设置我们的数据路径以避免重复输入。将此字符串替换为您的`qgis_data`目录路径：
- en: '[PRE24]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we can load our railroad layer:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以加载我们的铁路图层：
- en: '[PRE25]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, we can define our rules as a set of tuples. Each rule defines a label
    and an expression, detailing which attribute values make up that rule, a color
    name, and the minimum/maximum map scale values at which the described features
    are visible:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以将我们的规则定义为一系列元组。每个规则定义了一个标签和一个表达式，详细说明了哪些属性值构成了该规则，一个颜色名称，以及描述的特征在最小/最大地图比例值上可见：
- en: '[PRE26]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, we create a rule-based renderer and a base symbol to begin applying our
    rules:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个基于规则的渲染器和基础符号，以便开始应用我们的规则：
- en: '[PRE27]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The rules are a hierarchy based on a root rule, so we must access the root
    first:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 规则基于根规则分层，因此我们首先必须访问根规则：
- en: '[PRE28]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we will loop through our rules, clone the default rule, and append our
    custom rule to the tree:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将遍历我们的规则，克隆默认规则，并将我们的自定义规则追加到树中：
- en: '[PRE29]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can now delete the default rule, which isn''t part of our rendering scheme:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以删除默认规则，该规则不属于我们的渲染方案：
- en: '[PRE30]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we apply the renderer to our `rails` layer:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将渲染器应用到我们的`rails`图层上：
- en: '[PRE31]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We''ll establish and style a city layer, which will provide a focal point to
    zoom into so that we can easily see the scale-based rendering effect:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将建立一个城市图层，它将提供一个焦点以便我们放大，这样我们就可以轻松地看到基于比例的渲染效果：
- en: '[PRE32]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, we''ll set up and style a border layer around both the datasets:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将为两个数据集周围设置并样式化一个边框层：
- en: '[PRE33]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, we''ll add everything to the map:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将所有内容添加到地图中：
- en: '[PRE34]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works...
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: Rules are a hierarchical collection of symbols and expressions. Symbols are
    collections of symbol layers. This recipe is relatively simple but contains over
    50 lines of code. Rendering is one of the most complex features to code in QGIS.
    However, rules also have their own sets of properties, separate from layers and
    symbols. Notice that in this recipe, we are able to set labels and filters for
    the rules, properties that are normally relegated to layers. One way to think
    of rules is as separate layers. We can do the same thing by loading our railroad
    layer as a new layer for each rule. Rules are a more compact way to break up the
    rendering for a single layer.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 规则是符号和表达式的分层集合。符号是符号层的集合。这个配方相对简单，但包含超过50行代码。渲染是QGIS中编码最复杂的特性之一。然而，规则也有它们自己的属性集，与图层和符号分开。请注意，在这个配方中，我们能够为规则设置标签和过滤器，这些属性通常被分配给图层。将规则视为单独图层的一种方式。我们可以通过将我们的铁路图层作为每个规则的新图层来加载，以实现相同的功能。规则是分割单个图层渲染的更紧凑方式。
- en: 'This image shows the rendering at a scale where all the rule outputs are visible:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此图像显示了在所有规则输出都可见的比例尺下的渲染效果：
- en: '![How it works...](img/00066.jpeg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/00066.jpeg)'
- en: Creating a layer style file
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建图层样式文件
- en: Layer styling is one of the most complex aspects of the QGIS Python API. Once
    you've developed the style for a layer, it is often useful to save the styling
    to the **QGIS Markup Language** (**QML**) in the XML format.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图层样式是QGIS Python API中最复杂的方面之一。一旦为图层开发出样式，通常将样式保存到XML格式的**QGIS标记语言**（**QML**）中是非常有用的。
- en: Getting ready
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need to download the zipped directory named `saveqml` and decompress
    it to your `qgis_data/rasters` directory from [https://geospatialpython.googlecode.com/svn/saveqml.zip](https://geospatialpython.googlecode.com/svn/saveqml.zip).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要下载名为`saveqml`的压缩目录，并将其解压缩到您的`qgis_data/rasters`目录中，链接为[https://geospatialpython.googlecode.com/svn/saveqml.zip](https://geospatialpython.googlecode.com/svn/saveqml.zip)。
- en: How to do it...
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will create a color ramp for a DEM and make it semi transparent to overlay
    a hillshaded tiff of the DEM. We''ll save the style we create to a QML file. To
    do this, we need to perform the following steps:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为DEM创建一个颜色渐变，并将其设置为半透明，以叠加DEM的阴影tif图像。我们将创建的样式保存到QML文件中。为此，我们需要执行以下步骤：
- en: 'First, we''ll need the following Python Qt libraries:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要以下Python Qt库：
- en: '[PRE35]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, we''ll load our two raster layers:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将加载我们的两个栅格图层：
- en: '[PRE36]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, we''ll perform a histogram stretch on our DEM for better visualization:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将对DEM执行直方图拉伸以获得更好的可视化效果：
- en: '[PRE37]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, we''ll create a visually pleasing color ramp based on the elevation values
    of the DEM as a renderer and apply it to the layer:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个基于DEM高程值的视觉上令人愉悦的颜色渐变，并将其作为渲染器应用到图层上：
- en: '[PRE38]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, we can add the layers to the map:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以将图层添加到地图中：
- en: '[PRE39]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, with this line, we can save the DEM''s styling to a reusable QML file:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过这一行，我们可以将DEM的样式保存到可重用的QML文件中：
- en: '[PRE40]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: How it works...
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: 'The QML format is easy to read and can be edited by hand. The `saveNamedStyle()`
    method works on vector layers in the exact same way. Instead of styling the preceding
    code, you can just reference the QML file using the `loadNamedStyle()` method:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: QML格式易于阅读，并且可以手动编辑。`saveNamedStyle()`方法在矢量图层上以完全相同的方式工作。您无需对前面的代码进行样式化，只需使用`loadNamedStyle()`方法引用QML文件即可：
- en: '[PRE41]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If you save the QML file along with a shapefile and use the same filename (with
    the `.qml` extension), then QGIS will load the style automatically when the shapefile
    is loaded.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将QML文件与shapefile一起保存，并使用相同的文件名（带有`.qml`扩展名），那么当加载shapefile时，QGIS将自动加载样式：
- en: Using NULL values in PyQGIS
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在PyQGIS中使用NULL值
- en: QGIS can use NULL values as field values. Python has no concept of NULL values.
    The closest type it has is the `None` type. You must be aware of this fact when
    working with Python in QGIS. In this recipe, we'll explore the implications of
    QGIS's NULL values in Python. The computing of a NULL value involves a pointer
    that is an uninitialized, undefined, empty, or meaningless value.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: QGIS可以使用NULL值作为字段值。Python没有NULL值的概念。它最接近的类型是`None`类型。当在QGIS中使用Python时，您必须注意这一点。在这个菜谱中，我们将探讨QGIS的NULL值在Python中的影响。NULL值的计算涉及一个指针，该指针是一个未初始化、未定义、空或无意义的值。
- en: Getting ready
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In your `qgis_data/shapes` directory, download the shapefile from [https://geospatialpython.googlecode.com/svn/NullExample.zip](https://geospatialpython.googlecode.com/svn/NullExample.zip),
    which contains some NULL field values, and unzip it.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`qgis_data/shapes`目录中，从[https://geospatialpython.googlecode.com/svn/NullExample.zip](https://geospatialpython.googlecode.com/svn/NullExample.zip)下载shapefile，该shapefile包含一些NULL字段值，并将其解压缩。
- en: How to do it...
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will load the shapefile and grab its first feature. Then, we''ll access
    one of its NULL field values. Next, we''ll run through some tests that allow you
    to see how the NULL values behave in Python. To do this, we need to perform the
    following steps:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将加载shapefile并获取其第一个要素。然后，我们将访问其一个NULL字段值。接下来，我们将运行一些测试，让您看到NULL值在Python中的行为。为此，我们需要执行以下步骤：
- en: 'First, we''ll load the shapefile and access its first feature:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将加载shapefile并访问其第一个要素：
- en: '[PRE42]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, we''ll grab one of the NULL field values:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将获取一个NULL字段值：
- en: '[PRE43]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, we''ll check the NULL value''s type:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将检查NULL值的类型：
- en: '[PRE44]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, we''ll see whether the value is the Python `None` type:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将查看该值是否是Python的`None`类型：
- en: '[PRE45]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, we''ll see whether it is equivalent to `None`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将查看它是否等同于`None`：
- en: '[PRE46]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, we''ll see whether the value matches the QGIS NULL type:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将查看该值是否与QGIS的NULL类型匹配：
- en: '[PRE47]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then, we''ll see whether it is actually NULL:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将查看它是否实际上是NULL：
- en: '[PRE48]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, we''ll do a type match to the QGIS NULL:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将与QGIS的NULL进行类型匹配：
- en: '[PRE49]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: How it works...
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As you can see, the type of the NULL value is `PyQt4.QtCore.QPyNullVariant`.
    This class is a special type injected into the PyQt framework. It is important
    to note the cases where the comparison using the `is` operator returns a different
    value than the `==` operator comparison. You should be aware of the differences
    to avoid unexpected results in your code.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，NULL值的类型是`PyQt4.QtCore.QPyNullVariant`。这个类是注入到PyQt框架中的一个特殊类型。需要注意的是，使用`is`运算符和`==`运算符比较时，返回的值可能不同。您应该了解这些差异，以避免代码中出现意外结果。
- en: Using generators for layer queries
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用生成器进行图层查询
- en: Python generators provide an efficient way to process large datasets. A QGIS
    developer named Nathan Woodrow has created a simple Python QGIS query engine that
    uses generators to easily fetch features from QGIS layers. We'll use this engine
    in this recipe to query a layer.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Python生成器提供了一种高效处理大数据集的方法。一位名为Nathan Woodrow的QGIS开发者创建了一个简单的Python QGIS查询引擎，该引擎使用生成器轻松地从QGIS图层中检索特征。我们将在这个菜谱中使用这个引擎来查询图层。
- en: Getting ready
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You need to install the query engine using `easy_install` or by downloading
    it and adding it to your QGIS Python installation. To use `easy_install`, run
    the following command from a console, which downloads a clone of the original
    code that includes a Python setup file:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要使用`easy_install`或下载并添加到您的QGIS Python安装中安装查询引擎。要使用`easy_install`，请在控制台中运行以下命令，这将下载原始代码的克隆，包括Python设置文件：
- en: '[PRE50]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[https://github.com/GeospatialPython/qquery/archive/master.zip](https://github.com/GeospatialPython/qquery/archive/master.zip)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/GeospatialPython/qquery/archive/master.zip](https://github.com/GeospatialPython/qquery/archive/master.zip)'
- en: You can also download the ZIP file from [https://github.com/NathanW2/qquery/archive/master.zip](https://github.com/NathanW2/qquery/archive/master.zip)
    and copy the contents to your working directory or the `site-packages` directory
    of your QGIS Python installation.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以从[https://github.com/NathanW2/qquery/archive/master.zip](https://github.com/NathanW2/qquery/archive/master.zip)下载ZIP文件，并将其内容复制到您的工作目录或QGIS
    Python安装的`site-packages`目录中。
- en: 'You will also need to download the zipped shapefile and decompress it to a
    directory named `ms` in your `qgis_data` directory from the following location:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要从以下位置下载压缩的shapefile并将其解压缩到`qgis_data`目录下的`ms`目录中：
- en: '[https://geospatialpython.googlecode.com/files/MS_UrbanAnC10.zip](https://geospatialpython.googlecode.com/files/MS_UrbanAnC10.zip)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://geospatialpython.googlecode.com/files/MS_UrbanAnC10.zip](https://geospatialpython.googlecode.com/files/MS_UrbanAnC10.zip)'
- en: How to do it...
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We''ll load a layer containing population data. Then, we''ll use the query
    engine to perform a simple query for an urban area with less than 50,000 people.
    We''ll filter the results to only give us three columns, place name, population
    level, and land area. To do this, we need to perform the following steps:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将加载包含人口数据的图层。然后，我们将使用查询引擎执行一个针对人口少于 50,000 的城市区域的简单查询。我们将过滤结果，只提供三个列，地点名称、人口水平和土地面积。为此，我们需要执行以下步骤：
- en: 'First, we import the query engine module:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入查询引擎模块：
- en: '[PRE51]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then, we set up the path to our shapefile and load it as a vector layer:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们设置到我们的 shapefile 的路径并将其加载为一个矢量图层：
- en: '[PRE52]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, we can run the query, which uses Python''s dot notation to perform a `where`
    clause search and then filter using a `select` statement. This line will return
    a generator with the result:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以运行查询，该查询使用 Python 的点表示法执行 `where` 子句搜索，然后使用 `select` 语句进行过滤。这一行将返回一个包含结果的生成器：
- en: '[PRE53]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, we''ll use the query''s generator to iterate to the first result:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将使用查询生成器迭代到第一个结果：
- en: '[PRE54]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How it works...
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As you can see, this module is quite handy. To perform this same query using
    the default PyQGIS API, it would take nearly four times as much code.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个模块非常实用。要使用默认的 PyQGIS API 执行此相同查询，代码量将几乎是现在的四倍。
- en: Using alpha values to show data density
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 alpha 值来显示数据密度
- en: Thematic maps often use a color ramp based on a single color to show data density.
    Darker colors show a higher concentration of objects, while lighter colors show
    lower concentrations. You can use a transparency ramp instead of a color ramp
    to show density as well. This technique is useful if you want to overlay the density
    layer on imagery or other vector layers. In this recipe, we'll be using some bear-sighting
    data to show the concentration of bears over an area. We'll use alpha values to
    show the density. We'll use an unusual hexagonal grid to divide the area and a
    rule-based renderer to build the display.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 主题地图通常使用基于单一颜色的颜色渐变来显示数据密度。较暗的颜色表示对象浓度较高，而较浅的颜色表示浓度较低。您也可以使用透明度渐变来显示密度。如果您想在影像或其他矢量图层上叠加密度层，这种技术很有用。在这个配方中，我们将使用一些熊目击数据来显示一个区域内熊的浓度。我们将使用
    alpha 值来显示密度。我们将使用不寻常的六边形网格来划分区域，并使用基于规则的渲染器来构建显示。
- en: Getting ready
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need to install the MMQGIS plugin, which is used to build the hexagonal
    grid using the QGIS **Plugin Manager**.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装 MMQGIS 插件，该插件用于使用 QGIS **插件管理器**构建六边形网格。
- en: You also need to download the bear data from [https://geospatialpython.googlecode.com/svn/bear-data.zip](https://geospatialpython.googlecode.com/svn/bear-data.zip),
    unzip the shapefile, and put it in the `ms` directory of your `qgis_data` directory.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要从 [https://geospatialpython.googlecode.com/svn/bear-data.zip](https://geospatialpython.googlecode.com/svn/bear-data.zip)
    下载熊的数据，解压缩 shapefile，并将其放入 `qgis_data` 目录下的 `ms` 目录。
- en: How to do it...
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will load the bear data. Then, we will use the MMQGIS plugin to generate
    the hexagonal grid. Then, we''ll use the Processing Toolbox to clip the hexagon
    to the bear shapefile, and join the shapefile attribute data to the hexagon grid.
    Finally, we''ll use a rule-based renderer to apply alpha values based on bear-sighting
    density and add the result to the map. To do this, we need to perform the following
    steps:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将加载熊的数据。然后，我们将使用 MMQGIS 插件生成六边形网格。然后，我们将使用处理工具箱将六边形裁剪到熊 shapefile，并将 shapefile
    属性数据连接到六边形网格。最后，我们将使用基于规则的渲染器根据熊目击密度应用 alpha 值并将结果添加到地图上。为此，我们需要执行以下步骤：
- en: 'First, we import all the libraries we''ll need, including the processing engine,
    the PyQt GUI library for color management, and the MMQGIS plugin:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入所有需要的库，包括处理引擎、用于颜色管理的 PyQt GUI 库和 MMQGIS 插件：
- en: '[PRE55]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Next, we''ll set up the paths for all of our input and output shapefiles:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将设置所有输入和输出 shapefile 的路径：
- en: '[PRE56]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, we can set up the input shapefile as a layer:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以设置输入 shapefile 作为图层：
- en: '[PRE57]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We''ll need the extent of the shapefile to create the grid as well as the width
    and height, in map units:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要 shapefile 的范围来创建网格以及地图单位中的宽度和高度：
- en: '[PRE58]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, we can use the MMQGIS plugin to generate the grid over the entire shapefile''s
    extent. We''ll use a grid cell size of one-tenth of a degree (approximately 6
    miles):'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 MMQGIS 插件在整个 shapefile 范围内生成网格。我们将使用十分之一的度（大约 6 英里）的网格单元大小：
- en: '[PRE59]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Then, we can clip the grid to the shape of our source data using the Processing
    Toolbox:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以使用处理工具箱将网格裁剪到源数据的形状：
- en: '[PRE60]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Next, we need to do a spatial join in order to match the source data''s attributes
    based on counties to each grid cell:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要进行空间连接，以便根据县匹配源数据的属性到每个网格单元：
- en: '[PRE61]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, we can add this output as a layer:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以将此输出作为一个图层添加：
- en: '[PRE62]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Next, we create our rendering rule set as Python tuples, specifying a label,
    value expression, color, and alpha level for the symbols between 0 and 1:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建我们的渲染规则集作为 Python 元组，指定符号之间的标签、值表达式、颜色和 alpha 级别（介于 0 和 1）：
- en: '[PRE63]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We then create the default symbol rule renderer and add the rules to the renderer:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们然后创建默认符号规则渲染器并将规则添加到渲染器中：
- en: '[PRE64]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We remove the default rule:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们移除了默认规则：
- en: '[PRE65]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We apply the renderer to the layer:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将渲染器应用到图层上：
- en: '[PRE66]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Finally, we add the finished density layer to the map:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将完成的密度图层添加到地图上：
- en: '[PRE67]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: How it works...
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The rule-based renderer forms the core of this recipe. However, the hexagonal
    grid provides a more interesting way to visualize statistical data. Like a dot-based
    density map, hexagons are not entirely spatially accurate or precise but make
    it very easy to understand the overall trend of the data. The interesting feature
    of hexagons is their centroid, which is equidistant to each of their neighbors,
    whereas with a square grid, the diagonal neighbors are further away.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 规则渲染器是这个菜谱的核心。然而，六边形网格提供了一种更有趣的方式来可视化统计数据。就像基于点的密度图一样，六边形在空间上并不完全准确或精确，但它使得理解数据的整体趋势变得非常容易。六边形的一个有趣特性是它们的质心，它到每个邻居的距离相等，而正方形网格中，对角邻居则更远。
- en: 'This image shows how the resulting map will look:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图片显示了最终地图的样式：
- en: '![How it works...](img/00067.jpeg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/00067.jpeg)'
- en: Using the __geo_interface__ protocol
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 __geo_interface__ 协议
- en: '[PRE68]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Getting ready
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe requires no preparation.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱不需要准备。
- en: How to do it...
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will create two functions: one for features and one for geometry. We''ll
    then use Python''s dynamic capability to patch the QGIS objects with a `__geo_interface__
    built-in` method. To do this, we need to perform the following steps:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两个函数：一个用于特征，一个用于几何。然后我们将使用 Python 的动态能力，通过 `__geo_interface__ 内置` 方法来修补
    QGIS 对象。为此，我们需要执行以下步骤：
- en: 'First, we''ll need the Python `json` module:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要 Python 的 `json` 模块：
- en: '[PRE69]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Next, we''ll create our function for the features that take a feature as input
    and return a GeoJSON-like object:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个用于特征的函数，该函数接受一个特征作为输入并返回一个类似 GeoJSON 的对象：
- en: '[PRE70]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, we''ll create the `geometry` function:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建 `geometry` 函数：
- en: '[PRE71]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Finally, we''ll patch the QGIS feature and geometry objects with our custom
    built-in to call our functions when the built-in is accessed:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将使用我们的自定义内置函数修补 QGIS 特征和几何对象，以便在访问内置函数时调用我们的函数：
- en: '[PRE72]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: How it works...
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe is surprisingly simple but exploits some of Python's most interesting
    features. First, note that the feature function actually calls the geometry function
    as part of its output. Also, note that adding the `__geo_interface__` built-in
    function is as simple as using the double-underscore naming convention and Python's
    built-in property method to declare lambda functions as internal to the objects.
    Another interesting Python feature is that the QGIS objects are able to pass themselves
    to our custom functions using the self keyword.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱出奇地简单，但利用了 Python 的一些最有趣的功能。首先，请注意，特征函数实际上在其输出部分调用了几何函数。另外，请注意，添加 `__geo_interface__`
    内置函数就像使用双下划线命名约定和 Python 的内置属性方法来声明 lambda 函数作为对象的内部一样简单。另一个有趣的 Python 功能是 QGIS
    对象能够使用 self 关键字将自身传递给我们的自定义函数。
- en: Generating points along a line
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 沿着线生成点
- en: You can generate points within a polygon in a fairly simple way by using the
    point in polygon method. However, sometimes you may want to generate points along
    a line. You can randomly place points inside the polygon's extent — which is essentially
    just a rectangular polygon — or you can place points at random locations along
    the line at random distances. In this recipe, we'll demonstrate both of these
    methods.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用点在多边形内的方法以相当简单的方式在多边形内生成点。然而，有时您可能想要在一条线上生成点。您可以在多边形范围内部随机放置点——这本质上只是一个矩形多边形——或者您可以在线上随机距离处随机放置点。在这个菜谱中，我们将演示这两种方法。
- en: Getting ready
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You will need to download the zipped shapefile and place it in a directory
    named `shapes` in your `qgis_data` directory from the following:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要下载压缩的 shapefile 并将其放置在 `qgis_data` 目录中名为 `shapes` 的目录中，如下所示：
- en: '[https://geospatialpython.googlecode.com/svn/path.zip](https://geospatialpython.googlecode.com/svn/path.zip)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://geospatialpython.googlecode.com/svn/path.zip](https://geospatialpython.googlecode.com/svn/path.zip)'
- en: How to do it...
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'First, we will generate random points along a line using a `grass()` function
    in the Processing Toolbox. Then, we''ll generate points within the line''s extent
    using a native QGIS processing function. To do this, we need to perform the following
    steps:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用处理工具箱中的`grass()`函数在一条线上生成随机点。然后，我们将使用QGIS的本地处理函数在线的范围内生成点。为此，我们需要执行以下步骤：
- en: 'First, we need to import the processing module:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要导入处理模块：
- en: '[PRE73]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Then, we''ll load the line layer onto the map:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将线图层加载到地图上：
- en: '[PRE74]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Next, we''ll generate points along the line by specifying the path to the shapefile,
    a maximum distance between the points in map units (meters), the type of feature
    we want to output (vertices), extent, snap tolerance option, minimum distance
    between the points, output type, and output name. We won''t specify the name and
    tell QGIS to load the output automatically:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将通过指定shapefile的路径、点之间的最大地图单位距离（米）、我们想要输出的特征类型（顶点）、范围、捕捉容差选项、点之间的最小距离、输出类型和输出名称来生成线上的点。我们不会指定名称，并告诉QGIS自动加载输出：
- en: '[PRE75]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Finally, we''ll create some points within the lines'' extent and load them
    as well:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将在线的范围内创建一些点并将它们也加载进来：
- en: '[PRE76]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: How it works...
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first algorithm puts the points on the line. The second places them within
    the vicinity. Both approaches have different use cases.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个算法将点放在线上。第二个算法将它们放在附近。这两种方法有不同的使用场景。
- en: There's more...
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Another option will be to create a buffer around the line at a specified distance
    and clip the output of the second algorithm so that the points aren't near the
    corners of the line extent. The `QgsGeometry` class also has an interpolate which
    allows you to create a point on a line at a specified distance from its origin.
    This is documented at [http://qgis.org/api/classQgsGeometry.html#a8c3bb1b01d941219f2321e6c6c3db7e1](http://qgis.org/api/classQgsGeometry.html#a8c3bb1b01d941219f2321e6c6c3db7e1).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是在线周围创建一个指定距离的缓冲区，并剪切第二个算法的输出，以便点不会靠近线范围的角落。`QgsGeometry`类还有一个interpolate方法，允许您在指定距离处创建线上的点。这已在[http://qgis.org/api/classQgsGeometry.html#a8c3bb1b01d941219f2321e6c6c3db7e1](http://qgis.org/api/classQgsGeometry.html#a8c3bb1b01d941219f2321e6c6c3db7e1)中记录。
- en: Using expression-based labels
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用基于表达式的标签
- en: Expressions are a kind of mini-programming language or SQL-like language found
    throughout different QGIS functions to select features. One important use of expressions
    is to control labels. Maps easily become cluttered if you label every single feature.
    Expressions make it easy to limit labels to important features. You can filter
    labels using expressions from within Python, as we will do in this recipe.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式是一种迷你编程语言或类似SQL的语言，在QGIS的不同功能中都可以找到，用于选择特征。表达式的一个重要用途是控制标签。如果为每个特征都添加标签，地图很容易变得杂乱。表达式可以轻松地将标签限制在重要特征上。您可以使用Python中的表达式从内部过滤标签，就像我们在这个菜谱中所做的那样。
- en: Getting ready
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You will need to download the zipped shapefile and decompress it to a directory
    named `ms` in your `qgis_data` directory from the following:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要从以下链接下载压缩的shapefile并将其解压缩到您的`qgis_data`目录中名为`ms`的目录：
- en: '[https://geospatialpython.googlecode.com/files/MS_UrbanAnC10.zip](https://geospatialpython.googlecode.com/files/MS_UrbanAnC10.zip)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://geospatialpython.googlecode.com/files/MS_UrbanAnC10.zip](https://geospatialpython.googlecode.com/files/MS_UrbanAnC10.zip)'
- en: How to do it...
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We''ll use the QGIS PAL labeling engine to filter labels based on a field name.
    After loading the layer, we''ll create our PAL settings and write them to the
    layer. Finally, we''ll add the layer to the map. To do this, we need to perform
    the following steps:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用QGIS PAL标签引擎根据字段名过滤标签。在加载图层后，我们将创建我们的PAL设置并将它们写入图层。最后，我们将图层添加到地图上。为此，我们需要执行以下步骤：
- en: 'First, we''ll set up the path to our shapefile:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将设置shapefile的路径：
- en: '[PRE77]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Next, we''ll load our layer:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将加载我们的图层：
- en: '[PRE78]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now, we create a labeling object and read the layer''s current labeling settings:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建一个标签对象并读取图层的当前标签设置：
- en: '[PRE79]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We create our expression to only label the features whose population field
    is greater than 50,000:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个表达式，仅对人口字段大于50,000的特征进行标签：
- en: '[PRE80]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Then, we enable these settings:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将启用以下设置：
- en: '[PRE81]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Finally, we apply the labeling filter to the layer and add it to the map:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将标签过滤器应用于图层并将其添加到地图上：
- en: '[PRE82]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: How it works...
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: While labels are a function of the layer, the settings for the labeling engine
    are controlled by an external object and then applied to the layer.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当标签是图层的功能时，标签引擎的设置由外部对象控制，然后应用于图层。
- en: Creating dynamic forms in QGIS
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在QGIS中创建动态表单
- en: When you edit the fields of a layer in QGIS, you have the option of using a
    spreadsheet-like table view or you can use a database-style form view. Forms are
    useful because you can change the design of the form and add interactive features
    that react to user input in order to better control data editing. In this recipe,
    we'll add some custom validation to a form that checks user input for valid values.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在QGIS中编辑图层的字段时，您可以选择使用类似电子表格的表格视图或使用数据库样式的表单视图。表单很有用，因为您可以更改表单的设计并添加交互式功能，这些功能会根据用户输入做出反应，以便更好地控制数据编辑。在本菜谱中，我们将向表单添加一些自定义验证，以检查用户输入的有效值。
- en: Getting ready
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You will need to download the zipped shapefile and decompress it to a directory
    named `ms` in your `qgis_data` directory from the following:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要从以下链接下载压缩的shapefile并将其解压缩到您的`qgis_data`目录中名为`ms`的目录中：
- en: '[https://geospatialpython.googlecode.com/files/MS_UrbanAnC10.zip](https://geospatialpython.googlecode.com/files/MS_UrbanAnC10.zip)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://geospatialpython.googlecode.com/files/MS_UrbanAnC10.zip](https://geospatialpython.googlecode.com/files/MS_UrbanAnC10.zip)'
- en: You'll also need to create a blank Python file called `validate.py`, which you'll
    edit as shown in the following steps. Put the `validate.py` file in the `ms` directory
    of your `qgis_data` directory with the shapefile.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要创建一个名为`validate.py`的空Python文件，您将按照以下步骤进行编辑。将`validate.py`文件放在与shapefile相同的`qgis_data`目录的`ms`目录中。
- en: How to do it...
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We''ll create the two functions we need for our validation engine. Then, we''ll
    use the QGIS interface to attach the action to the layer. Make sure that you add
    the following code to the `validate.py` file in the same directory as the shapefile,
    as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建我们验证引擎所需的两个函数。然后，我们将使用QGIS界面将操作附加到图层上。确保您将以下代码添加到与shapefile同一目录下的`validate.py`文件中，如下所示：
- en: 'First, we''ll import the Qt libraries:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将导入Qt库：
- en: '[PRE83]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Next, we''ll create some global variables for the attribute we''ll be validating
    and the form dialog:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将为我们将要验证的属性和表单对话框创建一些全局变量：
- en: '[PRE84]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now, we''ll begin building the function that changes the behavior of the dialog
    and create variables for the field we want to validate and the submit button:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将开始构建更改对话框行为的函数，并为我们要验证的字段和提交按钮创建变量：
- en: '[PRE85]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We must disconnect the dialog from the action that controls the form acceptance:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须断开对话框与控制表单接受的操作的连接：
- en: '[PRE86]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Next, we reconnect the dialogs, actions to our custom actions:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将重新连接对话框，将操作重新连接到我们的自定义操作：
- en: '[PRE87]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Now, we''ll create the validation function that will reject the form if the
    population field has a value less than 1:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个验证函数，如果人口字段值小于1，则拒绝表单：
- en: '[PRE88]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Next, open QGIS and drag and drop the shapefile from your filesystem onto the
    map canvas.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开QGIS并将shapefile从您的文件系统拖放到地图画布上。
- en: Save the project and give it a name in the same directory as the `validate.py`
    file.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存项目并在与`validate.py`文件相同的目录中为其命名。
- en: In the QGIS legend, double-click on the layer name.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在QGIS图例中双击图层名称。
- en: Select the **Fields** tab on the left-hand side of the **Layer Properties**
    dialog.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**图层属性**对话框的左侧选择**字段**选项卡。
- en: 'In the **Fields** tab at the top-right of the screen, enter the following line
    into the **PythonInit Function** field:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕右上角的**字段**选项卡中，将以下行输入到**PythonInit函数**字段中：
- en: '[PRE89]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Click on the **OK** button, in the bottom-right of the **Layer Properties**
    dialog.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**按钮，位于**图层属性**对话框的右下角。
- en: Now, use the identify tool to select a feature.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用识别工具选择一个要素。
- en: In the **Feature Properties** dialog, click on the form icon in the top-left
    of the image.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**要素属性**对话框中，点击图像左上角的表单图标。
- en: Once the feature form is open, switch back to the **QGIS Legend**, right-click
    on the layer name, and select **Toggle Editing**.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦要素表单打开，切换回**QGIS图例**，右键单击图层名称，并选择**切换编辑**。
- en: Switch back to the feature form, scroll down to the **POP** field, and change
    the value to `0`.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换回功能表单，向下滚动到**POP**字段，并将值更改为`0`。
- en: Now, click on the **OK** button and verify that you've received the warning
    dialog, which requires the value to be greater than `0`.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击**确定**按钮并验证您是否收到了警告对话框，该对话框要求值大于`0`。
- en: How it works...
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作用原理...
- en: The `validate.py` file must be in your Python path. Putting this file in the
    same directory as the project makes the functions available. Validation is one
    of the simplest functions you can implement.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`validate.py`文件必须在您的Python路径中。将此文件放在与项目相同的目录中可以使函数可用。验证是您可以实现的简单函数之一。'
- en: 'This screenshot shows the rejection message when the population is set to `0`:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这张截图显示了当人口设置为`0`时的拒绝信息：
- en: '![How it works...](img/00068.jpeg)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/00068.jpeg)'
- en: Calculating length for all selected lines
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算所有选中线的长度
- en: If you need to calculate the total of a given dataset property, such as length,
    the easiest thing to do is use Python. In this recipe, we'll total the length
    of the railways in a dataset.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要计算给定数据集属性的总和，例如长度，最简单的方法是使用Python。在这个菜谱中，我们将计算数据集中铁路的总长度。
- en: Getting ready
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need to download a zipped shapefile from [https://geospatialpython.googlecode.com/svn/ms_rails_mstm.zip](https://geospatialpython.googlecode.com/svn/ms_rails_mstm.zip).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要从[https://geospatialpython.googlecode.com/svn/ms_rails_mstm.zip](https://geospatialpython.googlecode.com/svn/ms_rails_mstm.zip)下载一个压缩的shapefile。
- en: Unzip it and place it in directory named `ms` in your `qgis_data` directory.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 解压它，并将其放置在`qgis_data`目录中名为`ms`的目录中。
- en: How to do it...
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will load the layer, loop through the features while keeping a running total
    of line lengths, and finally convert the result to kilometers. To do this, we
    need to perform the following steps:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将加载图层，在遍历特征的同时保持线长度的累计总和，最后将结果转换为公里。为此，我们需要执行以下步骤：
- en: 'First, we''ll set up the path to our shapefile:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将设置shapefile的路径：
- en: '[PRE90]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Then, we''ll load the layer:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将加载图层：
- en: '[PRE91]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Next, we need a variable to total the line lengths:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个变量来累计线长度：
- en: '[PRE92]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Now, we loop through the layer, getting the length of each line:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们遍历图层，获取每条线的长度：
- en: '[PRE93]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Finally, we print the total length converted to kilometers and format the string
    to only show two decimal places:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将打印转换成公里的总长度，并将字符串格式化为只显示两位小数：
- en: '[PRE94]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: How it works...
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: This function is simple, but it's not directly available in the QGIS API. You
    can use a similar technique to total up the area of a set of polygons or perform
    conditional counting.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数很简单，但它不是直接在QGIS API中可用的。您可以使用类似的技术来计算一组多边形的面积或执行条件计数。
- en: Using a different status bar CRS than the map
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用与地图不同的状态栏CRS
- en: Sometimes, you may want to display a different coordinate system for the mouse
    coordinates in the status bar than what the source data is. With this recipe,
    you can set a different coordinate system without changing the data coordinate
    reference system or the CRS for the map.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能希望在状态栏中显示与源数据不同的鼠标坐标坐标系统。使用这个菜谱，您可以在不更改数据坐标参考系统或地图CRS的情况下设置不同的坐标系统。
- en: Getting ready
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Download the zipped shapefile and unzip it to your `qgis_data/ms` directory
    from the following:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下链接下载压缩的shapefile并将其解压到您的`qgis_data/ms`目录：
- en: '[https://geospatialpython.googlecode.com/files/MSCities_Geo.zip](https://geospatialpython.googlecode.com/files/MSCities_Geo.zip)'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://geospatialpython.googlecode.com/files/MSCities_Geo.zip](https://geospatialpython.googlecode.com/files/MSCities_Geo.zip)'
- en: How to do it...
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will load our layer, establish a message in the status bar, create a special
    event listener to transform the map coordinates at the mouse''s location to our
    alternate CRS, and then connect the map signal for the mouse''s map coordinates
    to our listener function. To do this, we need to perform the following steps:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将加载我们的图层，在状态栏中建立一条信息，创建一个特殊的事件监听器，将鼠标位置的地图坐标转换为我们的备用CRS，然后将地图的鼠标坐标信号连接到我们的监听函数。为此，我们需要执行以下步骤：
- en: 'First, we need to import the Qt core library:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要导入Qt核心库：
- en: '[PRE95]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Then, we will set up the path to the shapefile and load it as a layer:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将设置shapefile的路径并将其作为图层加载：
- en: '[PRE96]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Now, we add the layer to the map:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将图层添加到地图：
- en: '[PRE97]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Next, we create a default message that will be displayed in the status bar
    and will be replaced by the alternate coordinates later, when the event listener
    is active:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个默认消息，该消息将在状态栏中显示，并在事件监听器激活后用备用坐标替换：
- en: '[PRE98]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Then, we display our default message in the left-hand side of the status bar
    as a placeholder:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在状态栏的左侧显示默认消息作为占位符：
- en: '[PRE99]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Now, we create our custom event-listener function to transform the mouse''s
    map location to our custom CRS, which in this case is **EPSG 3815**:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建一个自定义的事件监听器函数，将鼠标的地图位置转换为我们的自定义坐标参考系统（CRS），在这个例子中是**EPSG 3815**：
- en: '[PRE100]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Next, we connect the map canvas signal that is emitted when the mouse coordinates
    are updated to our custom event listener:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将连接地图画布信号，该信号在鼠标坐标更新时发出，并将其连接到我们的自定义事件监听器：
- en: '[PRE101]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Finally, verify that when you move the mouse around the map, the status bar
    is updated with the transformed coordinates.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，验证当你移动鼠标在地图上时，状态栏会更新为转换后的坐标。
- en: How it works...
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The coordinate transformation engine in QGIS is very fast. Normally, QGIS tries
    to transform everything to WGS84 Geographic, but sometimes you need to view coordinates
    in a different reference system.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: QGIS 中的坐标转换引擎非常快。通常，QGIS 会尝试将所有内容转换为 WGS84 地理坐标，但有时你需要以不同的参考系查看坐标。
- en: Creating HTML labels in QGIS
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 QGIS 中创建 HTML 标签
- en: QGIS map tips allow you to hover the mouse cursor over a feature in order to
    create a popup that displays information. This information is normally a data
    field, but you can also display other types of information using a subset of HTML
    tags. In this recipe, we'll create an HTML map tip that displays a Google Street
    View image at the feature's location.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: QGIS 地图提示允许你将鼠标光标悬停在要素上以创建一个弹出窗口，显示信息。这些信息通常是数据字段，但你也可以使用 HTML 标签的子集显示其他类型的信息。在这个菜谱中，我们将创建一个
    HTML 地图提示，在要素的位置显示 Google 街景图像。
- en: Getting ready
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In your `qgis_data` directory, create a directory named `tmp`.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 `qgis_data` 目录中，创建一个名为 `tmp` 的目录。
- en: 'You will also need to download the following zipped shapefile and place it
    in your `qgis_data/nyc` directory:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要下载以下压缩的 shapefile 并将其放置在 `qgis_data/nyc` 目录中：
- en: '[https://geospatialpython.googlecode.com/files/NYC_MUSEUMS_GEO.zip](https://geospatialpython.googlecode.com/files/NYC_MUSEUMS_GEO.zip)'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://geospatialpython.googlecode.com/files/NYC_MUSEUMS_GEO.zip](https://geospatialpython.googlecode.com/files/NYC_MUSEUMS_GEO.zip)'
- en: How to do it...
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will create a function to process the Google data and register it as a QGIS
    function. Then, we''ll load the layer and set its map tip display field. To do
    this, we need to perform the following steps:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个处理 Google 数据的函数并将其注册为 QGIS 函数。然后，我们将加载图层并设置其地图提示显示字段。为此，我们需要执行以下步骤：
- en: 'First, we need to import the Python libraries we''ll need:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要导入我们将需要的 Python 库：
- en: '[PRE102]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Next, we''ll set a special QGIS Python decorator that registers our function
    as a QGIS function. The first argument, `0`, means that the function won''t accept
    any arguments itself. The second argument, `Python`, defines the group in which
    the function will appear when you use the expression builder:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将设置一个特殊的 QGIS Python 装饰器，将我们的函数注册为 QGIS 函数。第一个参数 `0` 表示该函数本身不接受任何参数。第二个参数
    `Python` 定义了当使用表达式构建器时函数将出现的组：
- en: '[PRE103]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'We''ll create a function that accepts a feature and uses its geometry to pull
    down a Google Street View image. We must cache the images locally because the
    Qt widget that displays the map tips only allows you to use local images:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个接受要素并使用其几何形状来拉取 Google 街景图像的函数。我们必须在本地缓存图像，因为显示地图提示的 Qt 小部件只允许你使用本地图像：
- en: '[PRE104]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Now, we can load the layer:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以加载图层：
- en: '[PRE105]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Next, we can set the display field using a special QGIS tag with the name of
    our function:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用一个特殊的 QGIS 标签来设置显示字段，该标签的名称就是我们的函数名：
- en: '[PRE106]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Finally, we add it to the map:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将它添加到地图中：
- en: '[PRE107]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Select the map tips tool and hover over the different points to see the Google
    Street View images.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择地图提示工具，并将鼠标悬停在不同的点上以查看 Google 街景图像。
- en: How it works...
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The key to this recipe is the `@qgsfunction` decorator. When you register the
    function in this way, it shows up in the menus for Python functions in expressions.
    The function must also have the parent and value parameters, but we didn't need
    them in this case.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的关键是 `@qgsfunction` 装饰器。当你以这种方式注册函数时，它会在表达式中以 Python 函数的形式出现在菜单中。该函数还必须具有父级和值参数，但在这个例子中我们不需要它们。
- en: 'The following screenshot shows a Google Street View map tip:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了一个 Google 街景地图提示：
- en: '![How it works...](img/00069.jpeg)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/00069.jpeg)'
- en: There's more...
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If you don''t need the function any more, you must unregister it for the function
    to go away. The `unregister` command uses the following convention, referencing
    the function name with a dollar sign:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不再需要该函数，你必须取消注册它，以便函数消失。`unregister` 命令使用以下约定，使用美元符号引用函数名：
- en: '[PRE108]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Using OpenStreetMap's points of interest in QGIS
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 QGIS 中使用 OpenStreetMap 的兴趣点
- en: OpenStreetMap has an API called Overpass that lets you access OSM data dynamically.
    In this recipe, we'll add some OSM tourism points of interest to a map.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: OpenStreetMap 有一个名为 Overpass 的 API，允许您动态访问 OSM 数据。在这个菜谱中，我们将添加一些 OSM 旅游兴趣点到一个地图上。
- en: Getting ready
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need to use the QGIS **Plugin Manager** to install the **Quick OSM**
    plugin.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要使用 QGIS **插件管理器** 安装 **Quick OSM** 插件。
- en: 'You will also need to download the following shapefile and unzip it to your
    `qgis_data/ms` directory:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要下载以下 shapefile 并将其解压到您的 `qgis_data/ms` 目录中：
- en: '[https://geospatialpython.googlecode.com/svn/MSCoast_geo.zip](https://geospatialpython.googlecode.com/svn/MSCoast_geo.zip)'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://geospatialpython.googlecode.com/svn/MSCoast_geo.zip](https://geospatialpython.googlecode.com/svn/MSCoast_geo.zip)'
- en: How to do it...
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will load our base layer that defines the area of interest. Then, we''ll
    use the Processing Toolbox to build a query for OSM, download the data, and add
    it to the map. To do this, we need to perform the following steps:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将加载定义感兴趣区域的基本图层。然后，我们将使用 Processing 工具箱构建 OSM 查询，下载数据并将其添加到地图中。为此，我们需要执行以下步骤：
- en: 'First, we need to import the `processing` module:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要导入 `processing` 模块：
- en: '[PRE109]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Next, we need to load the base layer:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要加载基本图层：
- en: '[PRE110]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Then, we''ll need the layer''s extents for the processing algorithms:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要处理算法的图层范围：
- en: '[PRE111]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Next, we create the query:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建查询：
- en: '[PRE112]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The Quick OSM algorithm has a bug in its output, so we''ll create a properly
    formatted XML tag and perform a string replace:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Quick OSM 算法在其输出中有一个错误，因此我们将创建一个正确格式的 XML 标签并执行字符串替换：
- en: '[PRE113]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Now, we download the OSM data using our query:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用我们的查询下载 OSM 数据：
- en: '[PRE114]'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'We define the names of the shapefiles we will create from the OSM output:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了从 OSM 输出创建的 shapefile 的名称：
- en: '[PRE115]'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Now, we convert the OSM data to shapefiles:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将 OSM 数据转换为 shapefile：
- en: '[PRE116]'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'We place the points as a layer:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将点作为一个图层放置：
- en: '[PRE117]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Finally, we can add them to a map:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以将它们添加到地图中：
- en: '[PRE118]'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: How it works...
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The Quick OSM plugin manages the Overpass API. What's interesting about this
    plugin is that it provides processing algorithms in addition to a GUI interface.
    The processing algorithm that creates the query unfortunately formats the `bbox-query`
    tag improperly, so we need to work around this issue with the string replace.
    The API returns an OSM XML file that we must convert to shapefiles for use in
    QGIS.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: Quick OSM 插件管理 Overpass API。这个插件有趣的地方在于它除了提供图形用户界面外，还提供了处理算法。不幸的是，创建查询的处理算法格式化
    `bbox-query` 标签不正确，因此我们需要通过字符串替换来解决这个问题。API 返回一个 OSM XML 文件，我们必须将其转换为 shapefile
    以在 QGIS 中使用。
- en: Visualizing data in 3D with WebGL
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 WebGL 在 3D 中可视化数据
- en: QGIS displays data in a two-dimensions even if the data is three-dimensional.
    However, most modern browsers can display 3D data using the WebGL standard. In
    this recipe, we'll use the **Qgis2threejs** plugin to display QGIS data in 3D
    in a browser.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: QGIS 以二维显示数据，即使数据是三维的。然而，大多数现代浏览器可以使用 WebGL 标准显示 3D 数据。在这个菜谱中，我们将使用 **Qgis2threejs**
    插件在浏览器中显示 QGIS 数据的 3D 版本。
- en: Getting ready
  id: totrans-438
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You will need to download some raster elevation data in the zipped directory
    and place it in your `qgis_data` directory from the following:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要从以下链接下载一些栅格高程数据并将其放置在您的 `qgis_data` 目录中：
- en: '[https://geospatialpython.googlecode.com/svn/saveqml.zip](https://geospatialpython.googlecode.com/svn/saveqml.zip)'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://geospatialpython.googlecode.com/svn/saveqml.zip](https://geospatialpython.googlecode.com/svn/saveqml.zip)'
- en: You will also need to install the **Qgis2threejs** plugin using the QGIS **Plugin
    Manager**.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要使用 QGIS **插件管理器** 安装 **Qgis2threejs** 插件。
- en: How to do it...
  id: totrans-442
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will set up a color ramp for a DEM draped over a hillshade image and use
    the plugin to create a WebGL page in order to display the data. To do this, we
    need to perform the following steps:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为覆盖在阴影图像上的 DEM 设置颜色渐变，并使用插件创建一个 WebGL 页面以显示数据。为此，我们需要执行以下步骤：
- en: 'First, we will need to import the relevant libraries and the **Qgis2threejs**
    plugin:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要导入相关的库和 **Qgis2threejs** 插件：
- en: '[PRE119]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Next, we''ll disable QGIS automatic reprojection to keep the data display in
    meters:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将禁用 QGIS 自动重投影以保持数据显示在米为单位：
- en: '[PRE120]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Now, we can load our raster layers:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以加载我们的栅格图层：
- en: '[PRE121]'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Then, we can create the color ramp renderer for the DEM layer:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以为 DEM 图层创建颜色渐变渲染器：
- en: '[PRE122]'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Now, we''re ready to add the raster layers to the map:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们准备将栅格图层添加到地图中：
- en: '[PRE123]'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'To create the WebGL interface, we need to take control of the plugin''s GUI
    dialog, but we will keep it hidden:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建 WebGL 界面，我们需要控制插件的 GUI 对话框，但我们将保持其隐藏：
- en: '[PRE124]'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Next, we must create a dictionary of the properties required by the plugin.
    The most important is the layer ID of the DEM layer:'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须创建一个字典，其中包含插件所需的属性。最重要的是DEM图层的图层ID：
- en: '[PRE125]'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Now, we will apply these properties to the plugin:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将将这些属性应用到插件上：
- en: '[PRE126]'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'We must set the output file for the HTML page:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须设置HTML页面的输出文件：
- en: '[PRE127]'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'In the next step, we must override the method that saves the properties, otherwise
    it overwrites the properties we set:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一步中，我们必须覆盖保存属性的方法，否则它会覆盖我们设置的属性：
- en: '[PRE128]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Now, we are ready to run the plugin:'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已准备好运行插件：
- en: '[PRE129]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: On your filesystem, navigate to the HTML output page and open it in a browser.
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的文件系统中，导航到HTML输出页面并在浏览器中打开它。
- en: Follow the help instructions to move the 3D elevation display around.
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照帮助说明移动3D高程显示。
- en: How it works...
  id: totrans-468
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: This plugin is absolutely not designed for script-level access. However, Python
    is so flexible that we can even script the plugin at the GUI level and avoid displaying
    the GUI, so it is seamless to the user. The only glitch in this approach is that
    the save method overwrites the properties we set, so we must insert a dummy function
    that prevents this overwrite.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 此插件绝对不是为脚本级访问而设计的。然而，Python非常灵活，我们甚至可以在GUI级别脚本化插件并避免显示GUI，因此对用户来说无缝。这种方法中唯一的缺陷是保存方法会覆盖我们设置的属性，因此我们必须插入一个虚拟函数来防止这种覆盖。
- en: 'The following image shows the WebGL viewer in action:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了WebGL查看器的实际效果：
- en: '![How it works...](img/00070.jpeg)'
  id: totrans-471
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/00070.jpeg)'
- en: Visualizing data on a globe
  id: totrans-472
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在球体上可视化数据
- en: Ever since the release of Google Earth, *spinning globe* applications have become
    a useful and popular method of geographic exploration. QGIS has an experimental
    plugin called **QGIS Globe**, which is similar to Google Earth; however, it is
    extremely unstable. In this recipe, we'll display a layer in Google Earth.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Google Earth发布以来，*旋转地球*应用程序已成为地理探索的有用且受欢迎的方法。QGIS有一个名为**QGIS Globe**的实验性插件，它与Google
    Earth类似；然而，它极其不稳定。在本教程中，我们将展示如何在Google Earth中显示一个图层。
- en: Getting ready
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need to use the QGIS **Plugin Manager** to install the **MMQGIS** plugin.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要使用QGIS **插件管理器**来安装**MMQGIS**插件。
- en: Make sure you have Google Earth installed from [https://www.google.com/earth/](https://www.google.com/earth/).
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已从[https://www.google.com/earth/](https://www.google.com/earth/)安装了Google
    Earth。
- en: 'You will also need the following dataset from a previous recipe. It is a zipped
    directory called `ufo` which you should uncompress to your `qgis_data` directory:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要从之前的教程中获取以下数据集。它是一个名为`ufo`的压缩目录，您应该将其解压缩到您的`qgis_data`目录中：
- en: '[https://geospatialpython.googlecode.com/svn/ufo.zip](https://geospatialpython.googlecode.com/svn/ufo.zip)'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://geospatialpython.googlecode.com/svn/ufo.zip](https://geospatialpython.googlecode.com/svn/ufo.zip)'
- en: How to do it...
  id: totrans-479
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will load our layer and set up the attribute we want to use for the Google
    Earth KML output as the descriptor. We''ll use the MMQIGS plugin to output our
    layer to KML. Finally, we''ll use a cross-platform technique to open the file,
    which will trigger it to open in Google Earth. To do this, we need to perform
    the following steps:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将加载我们的图层并设置我们想要用于Google Earth KML输出的属性作为描述符。我们将使用MMQIGS插件将我们的图层输出为KML。最后，我们将使用跨平台技术打开文件，这将触发它在Google
    Earth中打开。为此，我们需要执行以下步骤：
- en: 'First, we will import the relevant Python libraries including the plugin. We
    will use the Python `webbrowser` module to launch Google Earth:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将导入包括插件在内的相关Python库。我们将使用Python的`webbrowser`模块来启动Google Earth：
- en: '[PRE130]'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Now, we''ll load the layer:'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将加载图层：
- en: '[PRE131]'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Next, we''ll set the output path for the KML:'
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将设置KML的输出路径：
- en: '[PRE132]'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Then, we''ll set up the variables needed by the plugin for the KML output which
    make up the layer identifier:'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将设置插件用于KML输出的所需变量，这些变量组成图层标识符：
- en: '[PRE133]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Now, we can use the plugin to create the KML:'
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用此插件创建KML：
- en: '[PRE134]'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Finally, we''ll use the `webbrowser` module to open the KML file, which will
    default to opening in Google Earth. We need to add the `file` protocol at the
    beginning of our output for the `webbrowser` module to work:'
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将使用`webbrowser`模块打开KML文件，它将默认在Google Earth中打开。我们需要在输出中添加`file`协议，以便`webbrowser`模块能够工作：
- en: '[PRE135]'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: How it works...
  id: totrans-493
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The MMQGIS plugin does a good job with custom scripts and has easy-to-use functions.
    While our method for automatically launching Google Earth may not work in every
    possible case, it is almost perfect.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: MMQGIS插件在自定义脚本和易于使用的功能方面做得很好。虽然我们的自动启动Google Earth的方法可能不适用于所有可能的情况，但它几乎是完美的。
