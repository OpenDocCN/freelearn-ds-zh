- en: '*Chapter 3*'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction to NumPy, Pandas,and Matplotlib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of the chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create and manipulate one-dimensional and multi-dimensional arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create and manipulate pandas DataFrames and series objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plot and visualize numerical data using the Matplotlib library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply matplotlib, NumPy, and pandas to calculate descriptive statistics from
    a DataFrame/matrix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, you will learn about the fundamentals of the NumPy, pandas,
    and matplotlib libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding chapters, we have covered some advanced data structures, such
    as stack, queue, iterator, and file operations in Python. In this section, we
    will cover three essential libraries, namely NumPy, pandas, and matplotlib.
  prefs: []
  type: TYPE_NORMAL
- en: NumPy Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the life of a data scientist, reading and manipulating arrays is of prime
    importance, and it is also the most frequently encountered task. These arrays
    could be a one-dimensional list or a multi-dimensional table or a matrix full
    of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: The array could be filled with integers, floating-point numbers, Booleans, strings,
    or even mixed types. However, in the majority of cases, numeric data types are
    predominant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some example scenarios where you will need to handle numeric arrays are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: To read a list of phone numbers and postal codes and extract a certain pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To create a matrix with random numbers to run a Monte Carlo simulation on some
    statistical process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To scale and normalize a sales figure table, with lots of financial and transactional
    data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To create a smaller table of key descriptive statistics (for example, mean,
    median, min/max range, variance, inter-quartile ranges) from a large raw data
    table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To read in and analyze time series data in a one-dimensional array daily, such
    as the stock price of an organization over a year or daily temperature data from
    a weather station
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In short, arrays and numeric data tables are everywhere. As a data wrangling
    professional, the importance of the ability to read and process numeric arrays
    cannot be overstated. In this regard, NumPy arrays will be the most important
    object in Python that you need to know about.
  prefs: []
  type: TYPE_NORMAL
- en: NumPy Array and Features
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**NumPy** and **SciPy** are open source add-on modules for Python that provide
    common mathematical and numerical routines in pre-compiled, fast functions. These
    have grown into highly mature libraries that provide functionality that meets,
    or perhaps exceeds, what is associated with common commercial software such as
    **MATLAB** or **Mathematica**.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the main advantages of the NumPy module is to handle or create one-dimensional
    or multi-dimensional arrays. This advanced data structure/class is at the heart
    of the NumPy package and it serves as the fundamental building block of more advanced
    classes such as **pandas** and **DataFrame**, which we will cover shortly in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: NumPy arrays are different than common Python lists, since Python lists can
    be thought as simple array. NumPy arrays are built for **vectorized** operations
    that process a lot of numerical data with just a single line of code. Many built-in
    mathematical functions in NumPy arrays are written in low-level languages such
    as C or Fortran and pre-compiled for real, fast execution.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: NumPy arrays are optimized data structures for numerical analysis, and that's
    why they are so important to data scientists.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 26: Creating a NumPy Array (from a List)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will create a NumPy array from a list:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To work with NumPy, we must import it. By convention, we give it a short name,
    `np`, while importing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a list with three elements, 1, 2, and 3:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `array` function to convert it into an array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We just created a NumPy array object called `array_1` from the regular Python
    list object, `list_1`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create an array of floating type elements 1.2, 3.4, and 5.6:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s check the type of the newly created object by using the `type` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `type` on `list_1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So, this is indeed different from the regular `list` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 27: Adding Two NumPy Arrays'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This simple exercise will demonstrate the addition of two NumPy arrays, and
    thereby show the key difference between a regular Python list/array and a NumPy
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: Consider `list_1` and `array_1` from the preceding exercise. If you have changed
    the Jupyter notebook, you will have to declare them again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the `+` notation to add two `list_1` object and save the results in `list_2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the same `+` notation to add two `array_1` objects and save the result
    in `array_2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Did you notice the difference? The first print shows a list with 6 elements
    [1, 2, 3, 1, 2, 3]. But the second print shows another NumPy array (or vector)
    with the elements [2, 4, 6], which are just the sum of the individual elements
    of `array_1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'NumPy arrays are like mathematical objects – **vectors**. They are built for
    element-wise operations, that is, when we add two NumPy arrays, we add the first
    element of the first array to the first element of the second array – there is
    an element-to-element correspondence in this operation. This is in contrast to
    Python lists, where the elements are simply appended and there is no element-to-element
    relation. This is the real power of a NumPy array: they can be treated just like
    mathematical vectors.'
  prefs: []
  type: TYPE_NORMAL
- en: A vector is a collection of numbers that can represent, for example, the coordinates
    of points in a three-dimensional space or the color of numbers (RGB) in a picture.
    Naturally, relative order is important for such a collection and as we discussed
    previously, a NumPy array can maintain such order relationships. That's why they
    are perfectly suitable to use in numerical computations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 28: Mathematical Operations on NumPy Arrays'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you know that these arrays are like vectors, we will try some mathematical
    operations on arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'NumPy arrays even support element-wise exponentiation. For example, suppose
    there are two arrays – the elements of the first array will be raised to the power
    of the elements in the second array:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply two arrays using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Divide two arrays using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Raise one array to the second arrays power using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Exercise 29: Advanced Mathematical Operations on NumPy Arrays'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NumPy has all the built-in mathematical functions that you can think of. Here,
    we are going to be creating a list and converting it into a NumPy array. Then,
    we will perform some advanced mathematical operations on that array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we are creating a list and then converting that into a NumPy array. We
    will then show you how to perform some advanced mathematical operations on that
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a list with five elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Convert the list into a NumPy array by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Find the `sine` value of the array by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Find the logarithmic value of the array by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Find the exponential value of the array by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Exercise 30: Generating Arrays Using arange and linspace'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Generation of numerical arrays is a fairly common task. So far, we have been
    doing this by creating a Python list object and then converting that into a NumPy
    array. However, we can bypass that and work directly with native NumPy methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `arange` function creates a series of numbers based on the minimum and
    maximum bounds you give and the step size you specify. Another function, `linspace`,
    creates a series of the fixed numbers of intermediate points between two extremes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a series of numbers using the `arange` method, by using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print numbers using the `arange` function by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For linearly spaced numbers, we can use the `linspace` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Exercise 31: Creating Multi-Dimensional Arrays'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, we have created only one-dimensional arrays. Now, let''s create some
    multi-dimensional arrays (such as a matrix in linear algebra). Just like we created
    the one-dimensional array from a simple flat list, we can create a two-dimensional
    array from a list of lists:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a list of lists and convert it into a two-dimensional NumPy array by
    using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Tuples can be converted into multi-dimensional arrays by using the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Thus, we have created multi-dimensional arrays using Python lists and tuples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 32: The Dimension, Shape, Size, and Data Type of the Two-dimensional
    Array'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following methods let you check the dimension, shape, and size of the array.
    Note that if it''s a 3x2 matrix, that is, it has 3 rows and 2 columns, then the
    shape will be (3,2), but the size will be 6, as 6 = 3x2:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Print the dimension of the matrix using `ndim` by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the size using `size`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the shape of the matrix using `shape`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the dimension type using `dtype`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Exercise 33: Zeros, Ones, Random, Identity Matrices, and Vectors'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we are familiar with basic vector (one-dimensional) and matrix data
    structures in NumPy, we will take a look how to create special matrices easily.
    Often, you may have to create matrices filled with zeros, ones, random numbers,
    or ones in the diagonal:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Print the vector of zeros by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the matrix of zeros by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the matrix of fives by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print an identity matrix by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print an identity matrix with a dimension of 4x4 by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print a matrix of random shape using the `randint` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The sample output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: When creating matrices, you need to pass on tuples of integers as arguments.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Random number generation is a very useful utility and needs to be mastered for
    data science/data wrangling tasks. We will look at the topic of random variables
    and distributions again in the section on statistics and see how NumPy and pandas
    have built-in random number and series generation, as well as manipulation functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 34: Reshaping, Ravel, Min, Max, and Sorting'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`reshape` is the `ravel` function, which flattens any given array into a one-dimensional
    array. It is a very useful action in many machine learning and data analytics
    tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following functions reshape the function. We will first generate a random
    one-dimensional vector of 2-digit numbers and then reshape the vector into multi-dimensional
    vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an array of 30 random integers (sampled from 1 to 99) and reshape it
    into two different forms using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the shape using the `shape` function by using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the arrays a, b, and c using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The sample output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: '"b" is a three-dimensional array – a kind of list of a list of a list.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Ravel file b using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The sample output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Exercise 35: Indexing and Slicing'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Indexing** and **slicing** of NumPy arrays is very similar to regular list
    indexing. We can even step through a vector of elements with a definite step size
    by providing it as an additional argument in the format (start, step, end). Furthermore,
    we can pass a list as the argument to select specific elements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, we will learn about indexing and slicing on one-dimensional
    and multi-dimensional arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In multi-dimensional arrays, you can use two numbers to denote the position
    of an element. For example, if the element is in the third row and second column,
    its indices are 2 and 1 (because of Python's zero-based indexing).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an array of 10 elements and examine its various elements by slicing
    and indexing the array with slightly different syntaxes. Do this by using the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the element in the seventh position by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the elements between the third and sixth positions by using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the elements until the fourth position by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the elements backwards by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the elements using their backward index, skipping three values, by using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new array called `array_2` by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the second, fourth, and ninth elements of the array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a multi-dimensional array by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The sample output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Access the values using double bracket indexing by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The sample output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Access the values using single bracket indexing by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The sample output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Access the values in a multi-dimensional array using a row or column by using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The sample output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the matrix with the specified row and column indices by using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The sample output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the matrix with the specified row and column indices by using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The sample output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Conditional Subsetting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Conditional subsetting** is a way to select specific elements based on some
    numeric condition. It is almost like a shortened version of a SQL query to subset
    elements. See the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The sample output is as follows (note that the exact output will be different
    for you as it is random):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 36: Array Operations (array-array, array-scalar, and universal functions)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NumPy arrays operate just like mathematical matrices, and the operations are
    performed element-wise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create two matrices (multi-dimensional arrays) with random integers and demonstrate
    element-wise mathematical operations such as addition, subtraction, multiplication,
    and division. Show the exponentiation (raising a number to a certain power) operation,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Due to random number generation, your specific output could be different to
    what is shown here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create two matrices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The sample output is as follows (note that the exact output will be different
    for you as it is random):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Perform addition, subtraction, division, and linear combination on the matrices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The sample output is as follows (note that the exact output will be different
    for you as it is random):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Perform the addition of a scalar, exponential matrix cube, and exponential
    square root:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The sample output is as follows (note that the exact output will be different
    for you as it is random):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Stacking Arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Stacking arrays** on top of each other (or side by side) is a useful operation
    for data wrangling. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: NumPy has many other advanced features, mainly related to statistics and linear
    algebra functions, which are used extensively in machine learning and data science
    tasks. However, not all of that is directly useful for beginner level data wrangling,
    so we won't cover it here.
  prefs: []
  type: TYPE_NORMAL
- en: Pandas DataFrames
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The pandas library is a Python package that provides fast, flexible, and expressive
    data structures that are designed to make working with relational or labeled data
    both easy and intuitive. It aims to be the fundamental high-level building block
    for doing practical, real-world data analysis in Python. Additionally, it has
    the broader goal of becoming the most powerful and flexible open source data analysis/manipulation
    tool that's available in any language.
  prefs: []
  type: TYPE_NORMAL
- en: The two primary data structures of pandas, `Series` (one-dimensional) and `DataFrame`
    (two-dimensional), handle the vast majority of typical use cases. Pandas is built
    on top of NumPy and is intended to integrate well within a scientific computing
    environment with many other third-party libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 37: Creating a Pandas Series'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will learn about how to create a pandas series object
    from the data structures that we created previously. If you have imported pandas
    as `pd`, then the function to create a series is simply `pd.Series`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize labels, lists, and a dictionary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import pandas as `pd` by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a series from the `my_data` list by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a series from the `my_data` list along with the `labels` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create a series from the NumPy array, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a series from the dictionary, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Exercise 38: Pandas Series and Data Handling'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The pandas series object can hold many types of data. This is the key to constructing
    a bigger table where multiple series objects are stacked together to create a
    database-like entity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a pandas series with numerical data by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a pandas series with labels by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a pandas series with functions by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a pandas series with a dictionary by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Exercise 39: Creating Pandas DataFrames'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The pandas DataFrame is similar to an Excel table or relational database (SQL)
    table that consists of three main components: the data, the index (or rows), and
    the columns. Under the hood, it is a stack of pandas series objects, which are
    themselves built on top of NumPy arrays. So, all of our previous knowledge of
    NumPy array applies here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a simple DataFrame from a two-dimensional matrix of numbers. First,
    the code draws 20 random integers from the uniform distribution. Then, we need
    to reshape it into a (5,4) NumPy array – 5 rows and 4 columns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the rows labels as `(''A'',''B'',''C'',''D'',''E'')` and column labels
    as `(''W'',''X'',''Y'',''Z'')`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The function to create a DataFrame is `pd.DataFrame` and it is called in next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The sample output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a DataFrame from a Python dictionary of some lists of integers by using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Pass this dictionary as the data argument to the `pd.DataFrame` function. Pass
    on a list of rows or indices. Notice how the dictionary keys became the column
    names and that the values were distributed among multiple rows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The most common way that you will encounter to create a pandas DataFrame will
    be to read tabular data from a file on your local disk or over the internet –
    CSV, text, JSON, HTML, Excel, and so on. We will cover some of these in the next
    chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise 40: Viewing a DataFrame Partially'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous section, we used `print(df)` to print the whole DataFrame.
    For a large dataset, we would like to print only sections of data. In this exercise,
    we will read a part of the DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following code to create a DataFrame with 25 rows and fill it with
    random numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following code to view only the first five rows of the DataFrame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The sample output is as follows (note that your output could be different due
    to randomness):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.1: First five rows of the DataFrame](img/C11065_03_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 3.1: First five rows of the DataFrame'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: By default, `head` shows only five rows. If you want to see any specific number
    of rows just pass that as an argument.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Print the first eight rows by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The sample output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.2: First eight rows of the DataFrame](img/C11065_03_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 3.2: First eight rows of the DataFrame'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Just like `head` shows the first few rows, `tail` shows the last few rows.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Print the DataFrame using the `tail` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The sample output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.3: Last ten rows of the DataFrame](img/C11065_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: Last ten rows of the DataFrame'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Indexing and Slicing Columns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two methods for indexing and slicing columns from a DataFrame. They
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DOT method**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bracket method**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The DOT method is good to find specific element. The bracket method is intuitive
    and easy to follow. In this method, you can access the data by the generic name/header
    of the column.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code illustrates these concepts. Execute them in your Jupyter
    notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows (a screenshot is shown here because the actual column
    is long):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/C11065_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: Rows of the ''X'' columns'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This is the output showing the type of column:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5: Type of ‘X’ column](img/C11065_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5: Type of ''X'' column'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This is the output showing the X and Z column indexed by passing a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6: Rows of the ‘Y’ columns](img/C11065_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.6: Rows of the ''Y'' columns'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This is the output showing the type of the pair of column:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7: Type of ‘Y’ column](img/C11065_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.7: Type of ''Y'' column'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For more than one column, the object turns into a DataFrame. But for a single
    column, it is a pandas series object.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing and Slicing Rows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Indexing and slicing rows in a DataFrame can also be done using following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Label-based ''loc'' method**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Index based ''iloc'' method**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `loc` method is intuitive and easy to follow. In this method, you can access
    the data by the generic name of the row. On the other hand, the `iloc` method
    allows you to access the rows by their numerical index. It can be very useful
    for a large table with thousands of rows, especially when you want to iterate
    over the table in a loop with a numerical counter. The following code illustrate
    the concepts of `iloc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'The sample output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8: Output of loc and iloc methods](img/C11065_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.8: Output of the loc and iloc methods'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Exercise 41: Creating and Deleting a New Column or Row'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the most common tasks in data wrangling is creating or deleting columns
    or rows of data from your DataFrame. Sometimes, you want to create a new column
    based on some mathematical operation or transformation involving the existing
    columns. This is similar to manipulating database records and inserting a new
    column based on simple transformations. We show some of these concepts in the
    following code blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new column using the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The sample output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.9: Output after adding a new column](img/C11065_03_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 3.9: Output after adding a new column'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Drop a column using the `df.drop` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The sample output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.10: Output after dropping a column](img/C11065_03_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 3.10: Output after dropping a column'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Drop a specific row using the `df.drop` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The sample output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.11: Output after dropping a row](img/C11065_03_11.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 3.11: Output after dropping a row'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Dropping methods creates a copy of the DataFrame and does not change the original
    DataFrame.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Change the original DataFrame by setting the `inplace` argument to `True`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A sample output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.12: Output after using the inplace argument](img/C11065_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.12: Output after using the inplace argument'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All the normal operations are not in-place, that is, they do not impact the
    original DataFrame object but return a copy of the original with addition (or
    deletion). The last bit of code shows how to make a change in the existing DataFrame
    with the `inplace=True` argument. Please note that this change is irreversible
    and should be used with caution.
  prefs: []
  type: TYPE_NORMAL
- en: Statistics and Visualization with NumPy and Pandas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the great advantages of using libraries such as NumPy and pandas is that
    a plethora of built-in statistical and visualization methods are available, for
    which we don't have to search for and write new code. Furthermore, most of these
    subroutines are written using C or Fortran code (and pre-compiled), making them
    extremely fast to execute.
  prefs: []
  type: TYPE_NORMAL
- en: Refresher of Basic Descriptive Statistics (and the Matplotlib Library for Visualization)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For any data wrangling task, it is quite useful to extract basic descriptive
    statistics from the data and create some simple visualizations/plots. These plots
    are often the first step in identifying fundamental patterns as well as oddities
    (if present) in the data. In any statistical analysis, descriptive statistics
    is the first step, followed by inferential statistics, which tries to infer the
    underlying distribution or process from which the data might have been generated.
  prefs: []
  type: TYPE_NORMAL
- en: As the inferential statistics are intimately coupled with the machine learning/predictive
    modeling stage of a data science pipeline, descriptive statistics naturally becomes
    associated with the data wrangling aspect.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two broad approaches for descriptive statistical analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Graphical techniques: Bar plots, scatter plots, line charts, box plots, histograms,
    and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Calculation of central tendency and spread: Mean, median, mode, variance, standard
    deviation, range, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this topic, we will demonstrate how you can accomplish both of these tasks
    using Python. Apart from NumPy and pandas, we will need to learn the basics of
    another great package – **matplotlib** – which is the most powerful and versatile
    visualization library in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 42: Introduction to Matplotlib Through a Scatter Plot'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will demonstrate the power and simplicity of matplotlib
    by creating a simple scatter plot from some data about the age, weight, and height
    of a few people:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define simple lists of names, age, weight (in kgs), and height (in
    centimeters):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the most important module from matplotlib, called `pyplot`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create simple scatter plots of age versus weight:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.13: A screenshot of a scatter plot containing age and weight](img/C11065_03_13.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 3.13: A screenshot of a scatter plot containing age and weight'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: The plot can be improved by enlarging the figure size, customizing the aspect
    ratio, adding a title with a proper font size, adding X-axis and Y-axis labels
    with a customized font size, adding grid lines, changing the Y-axis limit to be
    between 0 and 100, adding X and Y-tick marks, customizing the scatter plot's color,
    and changing the size of the scatter dots.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The code for the improved plot is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.14: A screenshot of a scatter plot showing age versus weight](img/C11065_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.14: A screenshot of a scatter plot showing age versus weight'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Observe the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A `tuple (8,6)` is passed as an argument for the figure size.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list comprehension is used inside `Xticks` to create a customized list of
    5-10-15-…-55.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A newline (`\n`) character is used inside the `plt.text()` function to break
    up and distribute the text in two lines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `plt.show()` function is used at the very end. The idea is to keep on adding
    various graphics properties (font, color, axis limits, text, legend, grid, and
    so on) until you are satisfied and then show the plot with one function. The plot
    will not be displayed without this last function call.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Definition of Statistical Measures – Central Tendency and Spread
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A measure of central tendency is a single value that attempts to describe a
    set of data by identifying the central position within that set of data. They
    are also categorized as summary statistics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mean**: Mean is the sum of all values divided by the total number of values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Median**: The median is the middle value. It is the value that splits the
    dataset in half. To find the median, order your data from smallest to largest,
    and then find the data point that has an equal amount of values above it and below
    it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mode**: The mode is the value that occurs the most frequently in your dataset.
    On a bar chart, the mode is the highest bar.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Generally, the mean is a better measure to use for symmetric data and median
    is a better measure for data with a skewed (left or right heavy) distribution.
    For categorical data, you have to use the mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15: A screenshot of a curve showing the mean, median, and mode](img/C11065_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.15: A screenshot of a curve showing the mean, median, and mode'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The spread of the data is a measure of by how much the values in the dataset
    are likely to differ from the mean of the values. If all the values are close
    together then the spread is low; on the other hand, if some or all of the values
    differ by a large amount from the mean (and each other), then there is a large
    spread in the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Variance**: This is the most common measure of spread. Variance is the average
    of the squares of the deviations from the mean. Squaring the deviations ensures
    that negative and positive deviations do not cancel each other out.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Standard Deviation**: Because variance is produced by squaring the distance
    from the mean, its unit does not match that of the original data. Standard deviation
    is a mathematical trick to bring back the parity. It is the positive square root
    of the variance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Random Variables and Probability Distribution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **random variable** is defined as the value of a given variable that represents
    the outcome of a statistical experiment or process.
  prefs: []
  type: TYPE_NORMAL
- en: Although it sounds very formal, pretty much everything around us that we can
    measure can be thought of as a random variable.
  prefs: []
  type: TYPE_NORMAL
- en: The reason behind this is that almost all natural, social, biological, and physical
    processes are the final outcome of a large number of complex processes, and we
    cannot know the details of those fundamental processes. All we can do is observe
    and measure the final outcome.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typical examples of random variables that are around us are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The economic output of a nation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The blood pressure of a patient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The temperature of a chemical process in a factory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number of friends of a person on Facebook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The stock market price of a company
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These values can take any discrete or continuous value and they follow a particular
    pattern (although the pattern may vary over time). Therefore, they can all be
    classified as random variables.
  prefs: []
  type: TYPE_NORMAL
- en: What Is a Probability Distribution?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **probability distribution** is a function that describes the likelihood of
    obtaining the possible values that a random variable can assume. In other words,
    the values of a variable vary based on the underlying probability distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you go to a school and measure the heights of students who have been
    selected randomly. Height is an example of a random variable here. As you measure
    height, you can create a distribution of height. This type of distribution is
    useful when you need to know which outcomes are most likely, the spread of potential
    values, and the likelihood of different results.
  prefs: []
  type: TYPE_NORMAL
- en: The concepts of central tendency and spread are applicable to a distribution
    and are used to describe the properties and behavior of a distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Statisticians generally divide all distributions into two broad categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Discrete distributions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous distributions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discrete Distributions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Discrete probability functions** are also known as **probability mass functions**
    and can assume a discrete number of values. For example, coin tosses and counts
    of events are discrete functions. You can have only heads or tails in a coin toss.
    Similarly, if you''re counting the number of trains that arrive at a station per
    hour, you can count 11 or 12 trains, but nothing in-between.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some prominent discrete distributions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Binomial distribution** to model binary data, such as coin tosses'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Poisson distribution** to model count data, such as the count of library
    book checkouts per hour'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uniform distribution** to model multiple events with the same probability,
    such as rolling a die'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous Distributions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Continuous probability functions** are also known as **probability density
    functions**. You have a continuous distribution if the variable can assume an
    infinite number of values between any two values. Continuous variables are often
    measurements on a real number scale, such as height, weight, and temperature.'
  prefs: []
  type: TYPE_NORMAL
- en: The most well-known continuous distribution is the **normal distribution**,
    which is also known as the **Gaussian distribution** or the **bell curve**. This
    symmetric distribution fits a wide variety of phenomena, such as human height
    and IQ scores.
  prefs: []
  type: TYPE_NORMAL
- en: 'The normal distribution is linked to the famous **68-95-99.7 rule**, which
    describes the percentage of data that falls within 1, 2, or 3 standard deviations
    away from the mean if the data follows a normal distribution. This means that
    you can quickly look at some sample data, calculate the mean and standard deviation,
    and can have a confidence (a statistical measure of uncertainty) that any future
    incoming data will fall within those *68%-95%-99.7%* boundaries. This rule is
    widely used in industries, medicine, economics, and social science:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/C11065_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.16: Curve showing the normal distribution of the famous 68-95-99.7
    rule'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Data Wrangling in Statistics and Visualization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A good data wrangling professional is expected to encounter a dizzying array
    of diverse data sources each day. As we explained previously, due to a multitude
    of complex sub-processes and mutual interactions that give rise to such data,
    they all fall into the category of discrete or continuous random variables.
  prefs: []
  type: TYPE_NORMAL
- en: It will be extremely difficult and confusing to the data wrangler or data science
    team if all of this data continues to be treated as completely random and without
    any shape or pattern. A formal statistical basis must be given to such random
    data streams, and one of the simplest ways to start that process is to measure
    their descriptive statistics.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning a stream of data to a particular distribution function (or a combination
    of many distributions) is actually part of **inferential statistics**. However,
    inferential statistics starts only when descriptive statistics is done alongside
    measuring all the important parameters of the pattern of the data.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, as the front line of a data science pipeline, data wrangling must
    deal with measuring and quantifying such descriptive statistics of the incoming
    data. Along with the formatted and cleaned-up data, the primary job of a data
    wrangler is to hand over these measures (and sometimes accompanying plots) to
    the next team member of analytics.
  prefs: []
  type: TYPE_NORMAL
- en: '**Plotting** and **visualization** also help a data wrangling team identify
    potential outliers and misfits in the incoming data stream and help them to take
    appropriate action. We will see some examples of such tasks in the next chapter,
    where we will identify odd data points by creating scatter plots or histograms
    and either impute or omit the data point.'
  prefs: []
  type: TYPE_NORMAL
- en: Using NumPy and Pandas to Calculate Basic Descriptive Statistics on the DataFrame
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have some basic knowledge of NumPy, pandas, and matplotlib under
    our belt, we can explore a few additional topics related to these libraries, such
    as how we can bring them together for advanced data generation, analysis, and
    visualization.
  prefs: []
  type: TYPE_NORMAL
- en: Random Number Generation Using NumPy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NumPy offers a dizzying array of random number generation utility functions,
    all of which correspond to various statistical distributions, such as uniform,
    binomial, Gaussian normal, Beta/Gamma, and chi-square. Most of these functions
    are extremely useful and appear countless times in advanced statistical data mining
    and machine learning tasks. Having a solid knowledge of them is strongly encouraged
    for all the students taking this book.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will discuss three of the most important distributions that may come
    in handy for data wrangling tasks – uniform, binomial, and gaussian normal. The
    goal here is to show an example of simple function calls that can generate one
    or more random numbers/arrays whenever the user needs them.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The results will be different for each student when they use these functions
    as they are supposed to be random.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 43: Generating Random Numbers from a Uniform Distribution'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will be generating random numbers from a uniform distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate a random integer between `1` and `10`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The sample output is as follows (your output could be different):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Generate a random integer between 1 and 10 but with size=1 as an argument.
    It generates a NumPy array of size 1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The sample output is as follows (your output could be different due to random
    draw):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Therefore, we can easily write the code to generate the outcome of a dice being
    thrown (a normal 6-sided dice) for 10 trials.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How about moving away from the integers and generating some real numbers? Let's
    say that we want to generate artificial data for weights (in kgs) of 20 adults
    and we can measure the accurate weights up to two decimal places.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Generate decimal data using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The sample output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are not only restricted to one-dimensional arrays.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Generate and show a 3x3 matrix with random numbers between `0` and `1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The sample output is as follows (note that your specific output could be different
    due to randomness):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Exercise 44: Generating Random Numbers from a Binomial Distribution and Bar
    Plot'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A binomial distribution is the probability distribution of getting a specific
    number of successes in a specific number of trials of an event with a pre-determined
    chance or probability.
  prefs: []
  type: TYPE_NORMAL
- en: The most obvious example of this is a coin toss. A fair coin may have an equal
    chance of heads or tails, but an unfair coin may have more chances of the head
    coming up or vice versa. We can simulate a coin toss in NumPy in the following
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have a biased coin where the probability of heads is `0.6`. We toss
    this coin ten times and note down the number of heads turning up each time. That
    is one trial or experiment. Now, we can repeat this experiment (10 coin tosses)
    any number of times, say 8 times. Each time, we record the number of heads:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The experiment can be simulated using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The sample output is as follows (note your specific output could be different
    due to randomness):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Plot the result using a bar chart:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The sample output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.17: A screenshot of a graph showing the binomial distribution and
    the bar plot](img/C11065_03_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.17: A screenshot of a graph showing the binomial distribution and
    the bar plot'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Exercise 45: Generating Random Numbers from Normal Distribution and Histograms'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We discussed the normal distribution in the last topic and mentioned that it
    is the most important probability distribution because many pieces of natural,
    social, and biological data follow this pattern closely when the number of samples
    is large. NumPy provides an easy way to generate random numbers corresponding
    to this distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Draw a single sample from a normal distribution by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The sample output is as follows (note that your specific output could be different
    due to randomness):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We know that normal distribution is characterized by two parameters – mean (µ)
    and standard deviation (σ). In fact, the default values for this particular function
    are µ = 0.0 and σ = 1.0.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Suppose we know that the heights of the teenage (12-16 years) students in a
    particular school is distributed normally with a mean height of 155 cm and a standard
    deviation of 10 cm.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Generate a histogram of 100 students by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The sample output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/C11065_03_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.18: Histogram of teenage student''s height'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note the use of the `loc` parameter for the mean (=155) and the `scale` parameter
    for standard deviation (=10). The size parameter is set to 100 for that may samples'
    generation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 46: Calculation of Descriptive Statistics from a DataFrame'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Recollect the `age`, `weight`, and `height` parameters that we defined for the
    plotting exercise. Let's put that data in a DataFrame to calculate various descriptive
    statistics about them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best part of working with a pandas DataFrame is that it has a built-in
    utility function to show all of these descriptive statistics with a single line
    of code. It does this by using the `describe` method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Construct a dictionary with the available series data by using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/C11065_03_19.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 3.19: Output of the created dictionary'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Find the number of rows and columns of the DataFrame by executing the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Obtain a simple `count` (any column can be used for this purpose) by executing
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calculate the `sum` total of age by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calculate the `mean` age by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calculate the `median` weight by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calculate the `maximum` height by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calculate the `standard deviation` of the weights by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note how we are calling the statistical functions directly from a DataFrame
    object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To calculate `percentile`, we can call a function from NumPy and pass on the
    particular column (a pandas series). For example, to calculate the 75th and 25th
    percentiles of age distribution and their difference (called the inter-quartile
    range), use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `describe` command to find a detailed description of the DataFrame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.20: Output of the DataFrame using the describe method](img/C11065_03_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.20: Output of the DataFrame using the describe method'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This function works only on the columns where numeric data is present. It has
    no impact on the non-numeric columns, for example, People in this DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 47: Built-in Plotting Utilities'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'DataFrame also has built-in plotting utilities that wrap around matplotlib
    functions and create basic plots of numeric data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the histogram of the weights by using the `hist` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.21: Histogram of the weights](img/Image60813.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 3.21: Histogram of the weights'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Create a simple scatter plot directly from the DataFrame to plot the relationship
    between weight and heights by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/Image60822.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.22: Weight versus Height scatter plot'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can try regular matplotlib methods around this function call to make your
    plot pretty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 5: Generating Statistics from a CSV File'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Suppose you are working with the famous Boston housing price (from 1960) dataset.
    This dataset is famous in the machine learning community. Many regression problems
    can be formulated, and machine learning algorithms can be run on this dataset.
    You will do perform a basic data wrangling activity (including plotting some trends)
    on this dataset by reading it as a pandas DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The pandas function for reading a CSV file is `read_csv`.
  prefs: []
  type: TYPE_NORMAL
- en: 'These steps will help you complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Load the necessary libraries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read in the Boston housing dataset (given as a `.csv` file) from the local directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the first 10 records. Find the total number of records.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a smaller DataFrame with columns that do not include `CHAS`, `NOX`, `B`,
    and `LSTAT`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the last seven records of the new DataFrame you just created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Plot the histograms of all the variables (columns) in the new DataFrame.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Plot them all at once using a `for` loop. Try to add a unique title to a plot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a scatter plot of crime rate versus price.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Plot using `log10(crime)` versus `price`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate some useful statistics, such as mean rooms per dwelling, median age,
    mean distances to five Boston employment centers, and the percentage of houses
    with a low price (< $20,000).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 292.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we started with the basics of NumPy arrays, including how to
    create them and their essential properties. We discussed and showed how a NumPy
    array is optimized for vectorized element-wise operations and differs from a regular
    Python list. Then, we moved on to practicing various operations on NumPy arrays
    such as indexing, slicing, filtering, and reshaping. We also covered special one-dimensional
    and two-dimensional arrays, such as zeros, ones, identity matrices, and random
    arrays.
  prefs: []
  type: TYPE_NORMAL
- en: In the second major topic of this chapter, we started with pandas series objects
    and quickly moved on to a critically important object – pandas DataFrames. It
    is analogous to Excel or MATLAB or a database tab, but with many useful properties
    for data wrangling. We demonstrated some basic operations on DataFrames, such
    as indexing, subsetting, row and column addition, and deletion.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we covered the basics of plotting with matplotlib, the most widely used
    and popular Python library for visualization. Along with plotting exercises, we
    touched upon refresher concepts of descriptive statistics (such as central tendency
    and measure of spread) and probability distributions (such as uniform, binomial,
    and normal).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover more advanced operation with pandas DataFrames
    that will come in very handy for day-to-day working in a data wrangling job.
  prefs: []
  type: TYPE_NORMAL
