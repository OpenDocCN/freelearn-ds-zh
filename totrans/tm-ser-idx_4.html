<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer030">
<h1 class="chapter-number" id="_idParaDest-91"><a id="_idTextAnchor102"/>4</h1>
<h1 id="_idParaDest-92"><a id="_idTextAnchor103"/>iSAX – The Implementation</h1>
<p>Before continuing with this chapter and starting to write code, make sure that you have a good understanding of the information covered in the previous chapter because this chapter is all about implementing iSAX in Python. As a general principle, if you cannot perform a task manually, you are not going to be able to perform it with the help of a computer – the same principle applies to constructing and using an <span class="No-Break">iSAX index.</span></p>
<p>While reading this chapter, keep in mind that we are creating an iSAX index that<em class="italic"> fits in memory</em> and does not use any external files to store the subsequences of each terminal node. The original iSAX paper suggested the use of external files to store the subsequences of each terminal node mainly because back then, RAM was limited compared to what is the case today, where we can easily have computers with many CPU cores and more than 64 GB of RAM. As a result, the use of RAM makes the entire process much faster than if we used disk files. However, if you do not have lots of RAM on your system and are working with large time series, you might end up using swap space, which slows down <span class="No-Break">the process.</span></p>
<p>In this chapter, we are going to cover the following <span class="No-Break">main topics:</span></p>
<ul>
<li>A quick look at the <strong class="source-inline">isax</strong> <span class="No-Break">Python package</span></li>
<li>The class for <span class="No-Break">storing subsequences</span></li>
<li>The class for <span class="No-Break">iSAX nodes</span></li>
<li>The class for entire <span class="No-Break">iSAX indexes</span></li>
<li>Explaining the <span class="No-Break">missing parts</span></li>
<li>Exploring the <span class="No-Break">remaining files</span></li>
<li>Using the iSAX <span class="No-Break">Python package</span></li>
</ul>
<h1 id="_idParaDest-93"><a id="_idTextAnchor104"/>Technical requirements</h1>
<p>The GitHub repository with the code can be found at <a href="https://github.com/PacktPublishing/Time-Series-Indexing">https://github.com/PacktPublishing/Time-Series-Indexing</a>. The code for each chapter is in its own directory. Therefore, the code for this chapter can be found in the <strong class="source-inline">ch04</strong> folder and the <span class="No-Break"><strong class="source-inline">ch04</strong></span><span class="No-Break"> subfolders.</span></p>
<p>The first section takes a quick look at the Python package that we have developed for the purposes of this chapter, which strangely enough is called <strong class="source-inline">isax</strong>, before going into <span class="No-Break">more detail.</span></p>
<p class="callout-heading">What about bugs?</p>
<p class="callout">We have tried <a id="_idIndexMarker223"/>our best to give bug-free code. However, bugs might appear in any program, especially when a program is longer than 100 lines! That is why it is crucial to understand the principles behind the operation and construction of an iSAX index and the SAX representation to be able to understand that there might be a small or bigger issue with the code, or be able to port the existing implementation to a different programming language. I wrote the Python version of iSAX using a Java implementation from a colleague as my <span class="No-Break">starting point.</span></p>
<h1 id="_idParaDest-94"><a id="_idTextAnchor105"/>A quick look at the iSAX Python package</h1>
<p>In this section, we <a id="_idIndexMarker224"/>will take a first look at the iSAX Python package to get a better idea of the supported functionality. Although we will begin with the code from the <strong class="source-inline">sax</strong> package we developed in <a href="B14769_02_MA.xhtml#_idTextAnchor053"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, we are going to rename that package <strong class="source-inline">isax</strong> and create additional source code, which is <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">isax.py</strong></span><span class="No-Break">.</span></p>
<p>The structure of the <strong class="source-inline">isax</strong> directory with the Python files is going to be <span class="No-Break">as follows:</span></p>
<pre class="source-code">
$ tree isax/
isax/
├── SAXalphabet
├── __init__.py
├── isax.py
├── sax.py
├── tools.py
└── variables.py
1 directory, 6 files</pre>
<p>So, in total, we have six files. You already know five of them from the <strong class="source-inline">sax</strong> package. The only new one is the <strong class="source-inline">isax.py</strong> source code file, which is the core file for this chapter. Additionally, we are going to add more global variables to the <strong class="source-inline">variables.py</strong> file and some functions <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">tools.py</strong></span><span class="No-Break">.</span></p>
<p>The list of methods found in the <strong class="source-inline">isax.py</strong> file, which excludes <strong class="source-inline">__init__()</strong> functions, is <span class="No-Break">the following:</span></p>
<pre class="source-code">
$ grep -w def isax/isax.py | grep -v __init__
    def insert(self, ts, ISAX):
    def nTimeSeries(self):
    def insert(self, ts_node):</pre>
<p>The reason that <a id="_idIndexMarker225"/>we are talking about methods and not functions is that each function is attached to a Python class, which automatically makes it a method of <span class="No-Break">that class.</span></p>
<p>Additionally, if we also include <strong class="source-inline">__init__()</strong> functions in the output, then we might get a good prediction of the number of classes found in that Python file. In that case, you might want to run <strong class="source-inline">grep -w def -n1 </strong><span class="No-Break"><strong class="source-inline">isax/isax.py</strong></span><span class="No-Break"> instead:</span></p>
<pre class="source-code">
$ grep -w def -n1 isax/isax.py
5-class TS:
6:    def __init__(self, ts, segments):
7-        self.index = 0
--
11-class Node:
12:    def __init__(self, sax_word):
13-        self.left = None
--
19-    # Follow algorithm from iSAX paper
20:    def insert(self, ts, ISAX):
21-        # Accessing a subsequence
--
127-
128:    def nTimeSeries(self):
129-        if self.terminalNode == False:
--
141-class iSAX:
142:    def __init__(self):
143-        # This is now a hash table
--
148-
149:    def insert(self, ts_node):
150-        # Array with number of segments</pre>
<p>So, we have <a id="_idIndexMarker226"/>three classes, named <strong class="source-inline">TS</strong>, <strong class="source-inline">Node</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">iSAX</strong></span><span class="No-Break">.</span></p>
<p>The next sections are going to discuss the methods of <strong class="source-inline">isax.py</strong> in relation to the class that they <span class="No-Break">belong to.</span></p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor106"/>The class for storing subsequences</h2>
<p>In this <a id="_idIndexMarker227"/>subsection, we are going to <a id="_idIndexMarker228"/>explain the Python class used for <strong class="bold">storing subsequences</strong>, which is named <strong class="source-inline">TS</strong>. The definition of the class is <span class="No-Break">as follows:</span></p>
<pre class="source-code">
class TS:
    def __init__(self, ts, segments):
        self.index = 0
        self.ts = ts
        self.maxCard = sax.createPAA(ts,
            variables.maximumCardinality, segments)</pre>
<p>When defining an object of that class, we need to provide the <strong class="source-inline">ts</strong> parameter, which is a subsequence stored as a NumPy array, and the number of segments using the <strong class="source-inline">segments</strong> parameter. After that, the <strong class="source-inline">maxCard</strong> field is automatically initialized with the SAX representation of that subsequence with the maximum cardinality. The <strong class="source-inline">index</strong> parameter is optional and keeps the place of the subsequence in the original time series. iSAX does not use the <strong class="source-inline">index</strong> parameter but it is good to have such <span class="No-Break">a field.</span></p>
<p>This class <a id="_idIndexMarker229"/>not have any methods<a id="_idIndexMarker230"/> attached to it, which is not the case with the <strong class="source-inline">Node</strong> class that is <span class="No-Break">presented next.</span></p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor107"/>The class for iSAX nodes</h2>
<p>In this<a id="_idIndexMarker231"/> subsection, we <a id="_idIndexMarker232"/>will explain the Python structure used for <em class="italic">keeping both inner and terminal nodes</em>. This is an important part of the package and <span class="No-Break">its functionality:</span></p>
<pre class="source-code">
class Node:
    def __init__(self, sax_word):
        self.left = None
        self.right = None
        self.terminalNode = False
        self.word = sax_word
        self.children = [TS] * variables.threshold</pre>
<p>If we are dealing with an inner node, then the <strong class="source-inline">terminalNode</strong> field is set to <strong class="source-inline">False</strong>. However, if the Boolean value of the <strong class="source-inline">terminalNode</strong> field is set to <strong class="source-inline">True</strong>, then we are dealing with a <span class="No-Break">terminal node.</span></p>
<p>The <strong class="source-inline">word</strong> field holds the SAX representation of the node. Lastly, the <strong class="source-inline">left</strong> and <strong class="source-inline">right</strong> fields are links to the two children of an inner node, whereas the <strong class="source-inline">children</strong> field is a list that holds the subsequences of a <span class="No-Break">terminal node.</span></p>
<p>The <strong class="source-inline">Node</strong> class has <span class="No-Break">two methods:</span></p>
<ul>
<li><strong class="source-inline">insert()</strong>: This method is used for adding subsequences to <span class="No-Break">a node</span></li>
<li><strong class="source-inline">nTimeSeries()</strong>: This method is used for counting the number of subsequences stored in a <span class="No-Break">terminal node</span></li>
</ul>
<p>Next, let us<a id="_idIndexMarker233"/> talk about the class for representing <a id="_idIndexMarker234"/>entire <span class="No-Break">iSAX indexes.</span></p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor108"/>The class for entire iSAX indexes</h2>
<p>This last<a id="_idIndexMarker235"/> class of the <strong class="source-inline">isax</strong> package<a id="_idIndexMarker236"/> is used to represent entire <span class="No-Break">iSAX indexes:</span></p>
<pre class="source-code">
class <strong class="bold">iSAX</strong>:
    def __init__(self):
        # This is now a hash table
        self.children = {}
        # HashTable for storing Nodes
        self.ht = {}
        self.length = 0</pre>
<p>The <strong class="source-inline">children</strong> field holds the children of the root node – in reality, the instances of the iSAX class are roots of <span class="No-Break">iSAX indexes.</span></p>
<p>The <strong class="source-inline">ht</strong> field, which is a dictionary, holds all the nodes of the iSAX index. Each key is a SAX representation of a node, which is <em class="italic">unique</em>, and each value is a <strong class="source-inline">Node</strong> instance. Lastly, the <strong class="source-inline">length</strong> field holds the number of subsequences stored in the iSAX index and is an <span class="No-Break">optional field.</span></p>
<p>The <strong class="source-inline">iSAX</strong> class has only one method, which is called <strong class="source-inline">insert()</strong> and is used to insert subsequences into the <span class="No-Break">iSAX index.</span></p>
<p class="callout-heading">Why are we using these three classes?</p>
<p class="callout">The implementation<a id="_idIndexMarker237"/> of the iSAX index contains three different entities: subsequences, nodes, and the iSAX index itself, which is represented by the root node of the index. iSAX contains nodes and nodes contain other nodes or subsequences. Each of these entities has its <span class="No-Break">own class.</span></p>
<p>So far, we know the details of the Python classes used in our package. The next section is about <a id="_idIndexMarker238"/>implementing the <span class="No-Break">missing </span><span class="No-Break"><a id="_idIndexMarker239"/></span><span class="No-Break">parts.</span></p>
<h1 id="_idParaDest-98"><a id="_idTextAnchor109"/>Explaining the missing parts</h1>
<p>In this section, we<a id="_idIndexMarker240"/> are going <a id="_idIndexMarker241"/>to show the implementations of the class methods. We begin with the <strong class="source-inline">insert()</strong> function of the <strong class="source-inline">iSAX</strong> class, which should not be confused with the <strong class="source-inline">insert()</strong> function of the <strong class="source-inline">Node</strong> class. In Python and many other programming languages, classes are independent entities, which means they can have methods with the same name as long as they are unique inside the <span class="No-Break">class namespace.</span></p>
<p>We are going to present the code of <strong class="source-inline">Node.insert()</strong> in eight parts. The method accepts two parameters – apart from <strong class="source-inline">self</strong>, which denotes the current <strong class="source-inline">Node</strong> object – which are the subsequences we are trying to insert and the iSAX index that the <strong class="source-inline">Node</strong> instance <span class="No-Break">belongs to.</span></p>
<p>Why do we need an iSAX instance as a parameter? We need that in order to be able to add new nodes to the iSAX index by <span class="No-Break">accessing </span><span class="No-Break"><strong class="source-inline">iSAX.ht</strong></span><span class="No-Break">.</span></p>
<p>The first part of <strong class="source-inline">insert()</strong> is <span class="No-Break">the following:</span></p>
<pre class="source-code">
    # Follow algorithm from iSAX paper
    def insert(self, ts, ISAX):
        # Accessing a subsequence
        variables.nSubsequences += 1
        if <strong class="bold">self.terminalNode</strong>:
            if <strong class="bold">self.nTimeSeries() == variables.threshold</strong>:
                variables.nSplits += 1
                # Going to duplicate self Node
                temp = Node(self.word)
                temp.children = self.children
                temp.terminalNode = True
                # The current Terminal node becomes
                # an inner node
                self.terminalNode = False
                self.children = None</pre>
<p>The first thing that <strong class="source-inline">insert()</strong> does is check whether we are working with a terminal node or not. This happens because if we are dealing with a terminal node, we are going to try to store the given subsequence in the terminal node without any other delay. The second check is whether the terminal node is full or not. If it is full, then <em class="italic">we have a split</em>. First, we duplicate the current node with the <strong class="source-inline">temp = Node(self.word)</strong> statement and the current terminal node becomes an inner node by changing the value of <strong class="source-inline">terminalNode</strong> to <strong class="source-inline">False</strong>. At this point, we have to create two new empty nodes, which are going to become the two children of the current node – the former takes place in the code<a id="_idIndexMarker242"/> excerpt<a id="_idIndexMarker243"/> <span class="No-Break">that follows.</span></p>
<p>The second part of <strong class="source-inline">insert()</strong> is <span class="No-Break">as follows:</span></p>
<pre class="source-code">
                # Create TWO new Terminal nodes
                new1 = Node(temp.word)
                new1.terminalNode = True
                new2 = Node(temp.word)
                new2.terminalNode = True
                n1Segs = new1.word.split('_')
                n2Segs = new2.word.split('_')</pre>
<p>In the previous code, we create two new terminal nodes, which are going to be the children of the node that is going to be split. Both of these new nodes currently have the same SAX representation as the node that is going to be split and become an inner node. The change to their SAX representations, which signifies the split, is going to take place in<a id="_idIndexMarker244"/> the<a id="_idIndexMarker245"/> code <span class="No-Break">that follows.</span></p>
<p>The third part contains the <span class="No-Break">following code:</span></p>
<pre class="source-code">
                # This is where the promotion
                # strategy is selected
                if variables.defaultPromotion:
                    tools.round_robin_promotion(n1Segs)
                else:
                    tools.shorter_first_promotion(n1Segs)
                # New SAX_WORD 1
                <strong class="bold">n1Segs[variables.promote] =</strong>
                    <strong class="bold">n1Segs[variables.promote] + "0"</strong>
                # CONVERT it to string
                new1.word = "_".join(n1Segs)
                # New SAX_WORD 2
                <strong class="bold">n2Segs[variables.promote] =</strong>
                    <strong class="bold">n2Segs[variables.promote] + "1"</strong>
                # CONVERT it to string
                new2.word = "_".join(n2Segs)
                # The inner node has the same
                # SAX word as before but this is
                # not true for the two
                # NEW Terminal nodes, which should
                # be added to the Hash Table
                ISAX.ht[new1.word] = new1
                ISAX.ht[new2.word] = new2
                # Associate the 2 new Nodes with the
                # Node that is being splitted
                self.left = new1
                self.right = new2</pre>
<p>At the beginning of the code excerpt, we deal with the promotion strategy, which is implemented in the <strong class="source-inline">tools.py</strong> file, which is explained in <em class="italic">The tools.py file</em> section and has to do with defining the SAX word (segment) that is going to <span class="No-Break">be promoted.</span></p>
<p>After that, the code creates the two SAX representations of a split using two string operations – this is<a id="_idIndexMarker246"/> the main reason that we store SAX<a id="_idIndexMarker247"/> words as strings and that we are using a list to hold an entire SAX presentation. After that, we convert the SAX representations into strings stored in <strong class="source-inline">new1.word</strong> and <strong class="source-inline">new2.word</strong> and then put the respective nodes into the iSAX index using <strong class="source-inline">ISAX.ht[new1.word] = new1</strong> and <strong class="source-inline">ISAX.ht[new2.word] = new2</strong>. The keys for finding these two nodes in the <strong class="source-inline">iSAX.ht</strong> Python dictionary are their own SAX representations. The last two statements of the code associate the two new terminal nodes with the inner node by defining the <strong class="source-inline">left</strong> and <strong class="source-inline">right</strong> fields of the inner node and, therefore, signifying its <span class="No-Break">two children.</span></p>
<p>The fourth code part of the <strong class="source-inline">Node.insert()</strong> method is <span class="No-Break">as follows:</span></p>
<pre class="source-code">
                <strong class="bold"># Check all TS in original node</strong>
                <strong class="bold"># and put them</strong>
                <strong class="bold"># in one of the two children</strong>
                #
                # This is where the actual
                # SPLITTING takes place
                #
                for i in range(variables.threshold):
                    # Accessing a subsequence
                    variables.nSubsequences += 1
                    # Decrease TS.maxCard to
                    # current Cardinality
                    <strong class="bold">tempCard =</strong>
                        <strong class="bold">tools.promote(temp.children[i],</strong>
                        <strong class="bold">n1Segs)</strong>
                    if tempCard == new1.word:
                        new1.insert(temp.children[i], ISAX)
                    elif tempCard == new2.word:
                        new2.insert(temp.children[i], ISAX)
                    else:
                        if variables.overflow == 0:
                            print("OVERFLOW:", tempCard)
                        variables.overflow =
                            variables.overflow + 1
                # Now insert the INITIAL TS node!
                # self is now an INNER node
                self.insert(ts, ISAX)
                <strong class="bold">if variables.defaultPromotion</strong>:
                    # Next time, promote the next segment
                    Variables.promote = (variables.promote
                        + 1) % variables.segments</pre>
<p>We know for sure<a id="_idIndexMarker248"/> that after we split the subsequences, which<a id="_idIndexMarker249"/> were previously stored in the terminal node that has become an inner node, we are not going to have an overflow. However, we still need to call <strong class="source-inline">self.insert(ts, ISAX)</strong> to insert the subsequence that created the overflow previously and see what is going <span class="No-Break">to happen.</span></p>
<p>The last <strong class="source-inline">if</strong> checks whether we are using the default promotion strategy, which is the Round Robin strategy, and in that case, it changes the promotion segment to the next <span class="No-Break">in order.</span></p>
<p>But how do we know whether there is an overflow situation? If after promoting a subsequence to a higher cardinality than its current one (<strong class="source-inline">tempCard</strong>) that subsequence cannot be assigned to any of the two newly created terminal nodes (<strong class="source-inline">new1.word</strong> or <strong class="source-inline">new2.word</strong>), we know that it has not been promoted. Therefore, we have an overflow condition. This is implemented in the <strong class="source-inline">else:</strong> branch of the <strong class="source-inline">if tempCard == </strong><span class="No-Break"><strong class="source-inline">new1.word:</strong></span><span class="No-Break"> block.</span></p>
<p>The fifth part of <strong class="source-inline">Node.insert()</strong> <span class="No-Break">is next:</span></p>
<pre class="source-code">
            else:
                # TS is added if we have a Terminal node
                self.children[self.nTimeSeries()] = ts</pre>
<p>The code of the previous <strong class="source-inline">else</strong> is executed when we are dealing with a terminal node that is not full. So, we store the given subsequence in the <strong class="source-inline">children</strong> list – this is the ideal way to <a id="_idIndexMarker250"/>add<a id="_idIndexMarker251"/> a new subsequence to an <span class="No-Break">iSAX index.</span></p>
<p>The sixth part of the <strong class="source-inline">insert()</strong> function is <span class="No-Break">as follows:</span></p>
<pre class="source-code">
        else:
            # Otherwise, we are dealing with an INNER node
            # and we should add it to the
            # INNER node by trying
            # to find an existing terminal node
            # or create a new one
            # See whether it is going to be
            # included in the left
            # or the right child
            left = self.left
            right = self.right</pre>
<p>If we are working with an inner node, we have to decide whether the subsequence is going to go to the left or right child according to its SAX representation in order to finally find the terminal node that is going to store that subsequence. This is where the <span class="No-Break">process begins.</span></p>
<p>The seventh part contains the <span class="No-Break">following code:</span></p>
<pre class="source-code">
            leftSegs = left.word.split('_')
            # Promote
            tempCard = tools.promote(ts, leftSegs)</pre>
<p>In the previous code, we change (decrease) the maximum cardinality of the subsequence to fit the cardinality of the left node – we could have used the right node as both nodes use the same cardinality. The <strong class="source-inline">tempCard</strong> variable that holds that new cardinality is going to be used to decide the path that the subsequence is going to follow in the tree until it finds the appropriate <span class="No-Break">terminal node.</span></p>
<p>The last <a id="_idIndexMarker252"/>part<a id="_idIndexMarker253"/> of <strong class="source-inline">Node.insert()</strong> is <span class="No-Break">as follows:</span></p>
<pre class="source-code">
            if tempCard == left.word:
                left.insert(ts, ISAX)
            elif tempCard == right.word:
                right.insert(ts, ISAX)
            else:
                if variables.overflow == 0:
                    print("OVERFLOW:", tempCard, left.word,
                        right.word)
                variables.overflow = variables.overflow + 1
        return</pre>
<p>If <strong class="source-inline">tempCard</strong> does not match the SAX representation of the left or right node, then we know that <em class="italic">it has not been promoted</em>, which means that we have an <span class="No-Break">overflow condition.</span></p>
<p>This is the logic behind the implementation of <strong class="source-inline">Node.insert()</strong> – there exist many comments in the code that you can read, and you can add your own <strong class="source-inline">print()</strong> statements to understand the flow <span class="No-Break">even better.</span></p>
<p class="callout-heading">Why are we storing the maximum cardinality in its subsequence?</p>
<p class="callout">The reason for storing the maximum cardinality of this subsequence is that we can easily decrease that maximum cardinality without having to make difficult calculations such as computing a new SAX representation from scratch. This small optimization makes splitting operations <span class="No-Break">much faster.</span></p>
<p>The other <a id="_idIndexMarker254"/>method <a id="_idIndexMarker255"/>of the <strong class="source-inline">Node</strong> class is called <strong class="source-inline">nTimeSeries()</strong> and has the <span class="No-Break">following implementation:</span></p>
<pre class="source-code">
    def nTimeSeries(self):
        if self.terminalNode == False:
            print("Not a terminal node!")
            return
        n = 0
        for i in range(0, variables.threshold):
            if type(self.children[n]) == TS:
                n = n + 1
        return n</pre>
<p>The presented function returns the number of subsequences stored in a terminal node. First, <strong class="source-inline">nTimeSeries()</strong> makes sure that we are dealing with a terminal node before iterating over the contents of the <strong class="source-inline">children</strong> list. If the data type of the stored value is <strong class="source-inline">TS</strong>, then we have <span class="No-Break">a subsequence.</span></p>
<p>After that, we are going to discuss and explain the <strong class="source-inline">insert()</strong> method of the <strong class="source-inline">iSAX</strong> class, which is presented in three parts. The <strong class="source-inline">iSAX.insert()</strong> method is the method that is being called when<a id="_idIndexMarker256"/> we want to add a subsequence to an <span class="No-Break">iSAX index.</span></p>
<p>The first part of <strong class="source-inline">iSAX.insert()</strong> is <span class="No-Break">as follows:</span></p>
<pre class="source-code">
    def insert(self, ts_node):
        # Array with number of segments
        # For cardinality 1
        segs = [1] * variables.segments
        # Get cardinality 1 from ts_node
        # in order to find its main subtree
        lower_cardinality = tools.lowerCardinality(segs,
            ts_node)
        lower_cardinality_str = ""
        for i in lower_cardinality:
            lower_cardinality_str = lower_cardinality_str +
                "_" + i
        # Remove _ at the beginning
        lower_cardinality_str = lower_cardinality_str[
            1:len(lower_cardinality_str)]</pre>
<p>This first part of the <a id="_idIndexMarker257"/>code finds the child of the root where <a id="_idIndexMarker258"/>the given subsequence is going to be placed. The <strong class="source-inline">lower_cardinality_str</strong> value is used as the key for finding the relevant child of the root node – the <strong class="source-inline">tools.lowerCardinality()</strong> function is explained in <span class="No-Break">a bit.</span></p>
<p>The second part of <strong class="source-inline">iSAX.insert()</strong> contains the <span class="No-Break">following code:</span></p>
<pre class="source-code">
        # Check whether the SAX word with CARDINALITY 1
        # exists in the Hash Table.
        # If not, create it and update Hash Table
        if self.ht.get(lower_cardinality_str) == None:
            n = Node(lower_cardinality_str)
            n.terminalNode = True
            # Add it to the hash table
            self.children[lower_cardinality_str] = n
            self.ht[lower_cardinality_str] = n
            n.insert(ts_node, self)</pre>
<p>If the child of the<a id="_idIndexMarker259"/> root with the <strong class="source-inline">lower_cardinality_str</strong> SAX representation cannot be found, we create the respective root child and add it to the <strong class="source-inline">self.children</strong> hash table (dictionary) and call <strong class="source-inline">insert()</strong> to put the given <span class="No-Break">subsequence there.</span></p>
<p>The last part of <strong class="source-inline">iSAX.insert()</strong> is <span class="No-Break">the following:</span></p>
<pre class="source-code">
        else:
            n = self.ht.get(lower_cardinality_str)
            n.insert(ts_node, self)
        return</pre>
<p>If the child of the root with the <strong class="source-inline">lower_cardinality_str</strong> SAX representation exists, then we try to insert that subsequence, thereby <span class="No-Break">calling </span><span class="No-Break"><strong class="source-inline">insert()</strong></span><span class="No-Break">.</span></p>
<p>At this point, we go from the <strong class="source-inline">iSAX</strong> class level to the <strong class="source-inline">Node</strong> <span class="No-Break">class level.</span></p>
<p>But <strong class="source-inline">isax.py</strong> is not the only file with new code. The next section shows the additions and changes<a id="_idIndexMarker260"/> to<a id="_idIndexMarker261"/> the remaining package files that complete <span class="No-Break">the implementation.</span></p>
<h1 id="_idParaDest-99"><a id="_idTextAnchor110"/>Exploring the remaining files</h1>
<p>Apart from the <strong class="source-inline">isax.py</strong> file, the <strong class="source-inline">isax</strong> Python package is constructed of more source code files, mainly because it is based on the <strong class="source-inline">sax</strong> package. We will begin with the <span class="No-Break"><strong class="source-inline">tools.py</strong></span><span class="No-Break"> file.</span></p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor111"/>The tools.py file</h2>
<p>There are some<a id="_idIndexMarker262"/> additions<a id="_idIndexMarker263"/> to the <strong class="source-inline">tools.py</strong> source code file compared to the version we first saw in <a href="B14769_02_MA.xhtml#_idTextAnchor053"><span class="No-Break"><em class="italic">Chapter 2</em></span></a><em class="italic">, which</em> mainly have to do with the promotion strategy. As said before, we support two promotion strategies: Round Robin and from left <span class="No-Break">to right.</span></p>
<p>The Round Robin strategy is <span class="No-Break">implemented here:</span></p>
<pre class="source-code">
def round_robin_promotion(nSegs):
    # Check if there is a promotion overflow
    n = power_of_two(variables.maximumCardinality)
    t = 0
    while len(nSegs[variables.promote]) == n:
        # Go to the next SAX word and promote it
        Variables.promote = (variables.promote + 1) %
            variables.segments
        t += 1
        if t == variables.segments:
            if variables.overflow == 0:
                print("Non recoverable Promotion overflow!")
            return</pre>
<p>In the Round Robin case, we try to find the first segment on the right of the segment that was used in the previous promotion with fewer digits than the digits specified by the maximum cardinality (a segment that is not full). If the previous promotion took place in the last segment, then we go back to the first segment and begin from scratch. In order to compute the number of binary digits of the maximum cardinality (the length of the SAX word), we use the <strong class="source-inline">power_of_two()</strong> function, which returns <strong class="source-inline">3</strong> for a cardinality of <strong class="source-inline">8</strong>, <strong class="source-inline">4</strong> for a cardinality of <strong class="source-inline">16</strong>, and so on. If we iterate over all the segments of the given SAX representation (<strong class="source-inline">nSegs</strong>) and all have the maximum length, we know that we have an <span class="No-Break">overflow condition.</span></p>
<p>The left-to-right <a id="_idIndexMarker264"/>strategy, which<a id="_idIndexMarker265"/> is also<a id="_idIndexMarker266"/> called <strong class="bold">shorter first</strong>, is <span class="No-Break">implemented here:</span></p>
<pre class="source-code">
def shorter_first_promotion(nSegs):
    length = len(nSegs)
    pos = 0
    min = len(nSegs[pos])
    for i in range(1,length):
        if min &gt; len(nSegs[i]):
            min = len(nSegs[i])
            pos = i
    variables.promote = pos</pre>
<p>The left-to-right promotion strategy iterates over all the segments of the given SAX representation variable (<strong class="source-inline">nSegs</strong>) starting from the left and going to the right and finds the leftmost one with the minimum length. As a result, if both the second and third segments have the same minimum length, the strategy is going to select the second one because it is the leftmost available. After that, it sets <strong class="source-inline">variables.promote</strong> to the selected <span class="No-Break">segment value.</span></p>
<p>Next, we are going to talk about two additional functions that reside in <strong class="source-inline">tools.py</strong>, which are called <strong class="source-inline">promote()</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">lowerCardinality()</strong></span><span class="No-Break">.</span></p>
<p>The <strong class="source-inline">promote()</strong> function is implemented <span class="No-Break">as follows:</span></p>
<pre class="source-code">
def promote(node, segments):
    new_sax_word = ""
    max_array = node.maxCard.split("_")[
        0:variables.segments]
    # segments is an array
    #
    for i in range(variables.segments):
        t = len(segments[i])
        new_sax_word = new_sax_word + "_" +
            max_array[i][0:t]
    # Remove _ from the beginning of the new_sax_word
    new_sax_word = new_sax_word[1:len(new_sax_word)]
    return new_sax_word</pre>
<p>The <strong class="source-inline">promote()</strong> function<a id="_idIndexMarker267"/> copies <a id="_idIndexMarker268"/>the length of the digits of the segments of an existing SAX representation (<strong class="source-inline">node</strong>) to a given subsequence (<strong class="source-inline">s</strong>) in order for both to have the same cardinalities in all their SAX words. This <em class="italic">allows us to compare</em> these two <span class="No-Break">SAX representations.</span></p>
<p>The implementation of <strong class="source-inline">lowerCardinality()</strong> is <span class="No-Break">as follows:</span></p>
<pre class="source-code">
def lowerCardinality(segs, ts_node):
    # Get Maximum Cardinality
    max = ts_node.maxCard
    lowerCardinality = [""] * variables.segments
    # Because max is a string, we need to split.
    # The max string has an
    # underscore character at the end.
    max_array = max.split("_")[0:variables.segments]
    for i in range(variables.segments):
        t = segs[i]
        lowerCardinality[i] = max_array[i][0:t]
    return lowerCardinality</pre>
<p>The <strong class="source-inline">lowerCardinality()</strong> function lowers the cardinalities of a node <em class="italic">in all of its SAX words</em> (segments). This is mainly needed by <strong class="source-inline">iSAX.insert()</strong> to put a subsequence into the appropriate child of the root. After we put a subsequence into the appropriate child of the root, we promote a single segment of the SAX representation of the subsequence at a time to find out its place in the iSAX index. Remember that the keys to all iSAX <a id="_idIndexMarker269"/>nodes<a id="_idIndexMarker270"/> are SAX representations that usually have different cardinalities in <span class="No-Break">their segments.</span></p>
<p class="callout-heading">How to test individual functions</p>
<p class="callout">Personally, I prefer to create small command line utilities to test complex functions on their own, understand their operation, and maybe <span class="No-Break">discover bugs!</span></p>
<p>Let us make two small command-line utilities to showcase the use of <strong class="source-inline">promote()</strong> and <strong class="source-inline">lowerCardinality()</strong> in <span class="No-Break">more detail.</span></p>
<p>First, we demonstrate the <strong class="source-inline">promote()</strong> function in the <strong class="source-inline">usePromote.py</strong> utility, which contains the <span class="No-Break">following code:</span></p>
<pre class="source-code">
#!/usr/bin/env python3
from isax import variables
from isax import isax
import numpy as np
variablesPromote = 0
maximumCardinality = 8
segments = 4
def promote(node, s):
    global segments
    new_sax_word = ""
    max_array = node.maxCard.split("_")[0:segments]
    for i in range(segments):
        t = len(s[i])
        new_sax_word = new_sax_word + "_" +
            max_array[i][0:t]
    new_sax_word = new_sax_word[1:len(new_sax_word)]
    return new_sax_word</pre>
<p>It is important to<a id="_idIndexMarker271"/> remember <a id="_idIndexMarker272"/>that the <strong class="source-inline">promote()</strong> function mimics the lengths of the segments of an existing SAX representation by decreasing the maximum SAX representation of a subsequence (<strong class="source-inline">s</strong>) to match the given SAX representation stored in the <span class="No-Break"><strong class="source-inline">node</strong></span><span class="No-Break"> parameter.</span></p>
<p>The rest of <strong class="source-inline">usePromote.py</strong> is <span class="No-Break">the following:</span></p>
<pre class="source-code">
def main():
    global variablesPromote
    global maximumCardinality
    global segments
    variables.maximumCardinality = maximumCardinality
    ts = np.array([1, 2, 3, 4])
    t = isax.TS(ts, segments)
    SAX_WORD = "0_0_1_1_"
    Segs = SAX_WORD.split('_')
    print("Max cardinality:", t.maxCard)
    SAX_WORD = "00_0_1_1_"
    Segs = SAX_WORD.split('_')
    print("<strong class="bold">P1</strong>:", promote(t, Segs))
    SAX_WORD = "000_0_1_1_"
    Segs = SAX_WORD.split('_')
    print("<strong class="bold">P2</strong>:", promote(t, Segs))
    SAX_WORD = "000_01_1_1_"
    Segs = SAX_WORD.split('_')
    print("<strong class="bold">P3</strong>:", promote(t, Segs))
    SAX_WORD = "000_011_1_100_"
    Segs = SAX_WORD.split('_')
    print("<strong class="bold">P4</strong>:", promote(t, Segs))
if __name__ == '__main__':
    main()</pre>
<p>Everything is hardcoded in <strong class="source-inline">usePromote.py</strong> because we just want to know more about the use of <strong class="source-inline">promote()</strong> and nothing else. However, as <strong class="source-inline">promote()</strong> has many dependencies in the <strong class="source-inline">isax</strong> package, we must put its entire implementation in our script and make the necessary changes to the <span class="No-Break">Python code.</span></p>
<p>Given a subsequence, <strong class="source-inline">ts</strong>, and a <strong class="source-inline">TS</strong> class instance, <strong class="source-inline">t</strong>, we can calculate the SAX representation of <strong class="source-inline">ts</strong> using the maximum cardinality and then decrease it to match the cardinalities of other <span class="No-Break">SAX words.</span></p>
<p>Running <strong class="source-inline">usePromote.py</strong> generates <a id="_idIndexMarker273"/>the<a id="_idIndexMarker274"/> <span class="No-Break">following output:</span></p>
<pre class="source-code">
$ ./usePromote.py
Max cardinality: 000_010_101_111_
P1: 00_0_1_1
P2: 000_0_1_1
P3: 000_01_1_1
P4: 000_010_1_111</pre>
<p>The output shows that the maximum cardinality (<strong class="source-inline">000_010_101_111</strong>) of the given subsequence has been decreased to match the cardinalities of four other <span class="No-Break">SAX words.</span></p>
<p>After that, we demonstrate the <strong class="source-inline">lowerCardinality()</strong> function in the <strong class="source-inline">useLCard.py</strong> utility, which comes with the <span class="No-Break">following code:</span></p>
<pre class="source-code">
#!/usr/bin/env python3
from isax import variables
from isax import tools
from isax import isax
import numpy as np
def main():
    global maximumCardinality
    global segments
    # Used by isax.TS()
    variables.maximumCardinality = 8
    variables.segments = 4
    ts = np.array([1, 2, 3, 4])
    t = isax.TS(ts, variables.segments)
    Segs = [1] * variables.segments
    print(<strong class="bold">tools.lowerCardinality</strong>(Segs ,t))
    Segs = [2] * variables.segments
    print(<strong class="bold">tools.lowerCardinality</strong>(Segs ,t))
    Segs = [3] * variables.segments
    print(<strong class="bold">tools.lowerCardinality</strong>(Segs ,t))
if __name__ == '__main__':
    main()</pre>
<p>This time, we do <a id="_idIndexMarker275"/>not put<a id="_idIndexMarker276"/> the implementation of <strong class="source-inline">lowerCardinality()</strong> in our code because it has fewer dependencies and can be used directly from the <strong class="source-inline">tools.py</strong> file. The parameter that we pass to <strong class="source-inline">lowerCardinality()</strong> is <em class="italic">the number of digits</em> that we want to get in each SAX word. So, <strong class="source-inline">1</strong> means one digit, which means a cardinality of <span class="_-----MathTools-_Math_Number">2</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Number">1</span>, and <strong class="source-inline">3</strong> means three digits, which computes to a cardinality of <span class="No-Break"><span class="_-----MathTools-_Math_Number">2</span></span><span class="No-Break"><span class="_-----MathTools-_Math_Base"> </span></span><span class="No-Break"><span class="_-----MathTools-_Math_Number">3</span></span><span class="No-Break">.</span></p>
<p>Once again, everything is hardcoded in <strong class="source-inline">useLCard.py</strong> because we just want to know more about the use of <strong class="source-inline">lowerCardinality()</strong> and nothing more. Running <strong class="source-inline">useLCard.py</strong> produces the <span class="No-Break">following output:</span></p>
<pre class="source-code">
$ ./useLCard.py
['0', '0', '1', '1']
['00', '01', '10', '11']
['000', '010', '101', '111']</pre>
<p>So, given a subsequence with a SAX representation of <strong class="source-inline">000_010_101_111</strong>, we calculate its SAX representations for the cardinalities of <strong class="source-inline">2</strong>, <strong class="source-inline">4</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">8</strong></span><span class="No-Break">.</span></p>
<p>Next, we are going to show the changes to <strong class="source-inline">variables.py</strong>, which is the file that holds global variables<a id="_idIndexMarker277"/> that<a id="_idIndexMarker278"/> can be accessed by all the files of the package or the utilities that use the <span class="No-Break"><strong class="source-inline">isax</strong></span><span class="No-Break"> package.</span></p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor112"/>The variables.py file</h2>
<p>This <a id="_idIndexMarker279"/>subsection <a id="_idIndexMarker280"/>presents the contents of the updated <strong class="source-inline">variables.py</strong> file, which contains variables that are accessible from anywhere in <span class="No-Break">the code.</span></p>
<p class="callout-heading">How much functionality is enough?</p>
<p class="callout">Keep in mind that sometimes we might need to include functionality that is going to help with debugging or might be needed in the future, and therefore, we might need to include variables or implement functions that are not going to be used right away or all the time. Just remember to keep a good balance between wanting to support everything and please everyone, which is impossible, and wanting to support the absolute minimum functionality, which usually <span class="No-Break">lacks flexibility.</span></p>
<p>The contents of the <strong class="source-inline">variables.py</strong> file are <span class="No-Break">the following:</span></p>
<pre class="source-code">
# This file includes all variables for the isax package
#
maximumCardinality = 32
breakpointsFile = "SAXalphabet"
# Breakpoints in breakpointsFile
elements = ""
slidingWindowSize = 16
segments = 0
# Maximum number of time series in a terminal node
threshold = 100
# Keeps number of splits
nSplits = 0
# Keep number of accesses of subsequences
nSubsequences = 0
# Currently supporting TWO promotion strategies
defaultPromotion = True
# Number of overflows
overflow = 0
# Floating point precision
precision = 5
# Segment to promote
<strong class="bold">promote</strong> = 0</pre>
<p>The <strong class="source-inline">variables.promote</strong> variable defines the SAX word that is going to be promoted next if there is such a need. Put simply, we create the SAX representation of the two nodes of a split based on the value of <strong class="source-inline">variables.promote</strong> – we promote the segment defined by the value of <strong class="source-inline">variables.promote</strong>. Every time we have a split, <strong class="source-inline">variables.promote</strong> is updated according to the promotion (splitting) strategy and gets ready for the <span class="No-Break">next split.</span></p>
<p>Should you wish to see the changes between two versions of the same file, you can use the <strong class="source-inline">diff(1)</strong> utility. In our case, the difference between the <strong class="source-inline">variables.py</strong> file found in the <strong class="source-inline">ch03</strong> directory <a id="_idIndexMarker281"/>and<a id="_idIndexMarker282"/> the current version is <span class="No-Break">the following:</span></p>
<pre class="source-code">
2c2
&lt; # This file includes all variables for the sax package
---
&gt; # This file includes all variables for the isax package
13a14,16
&gt; # Breakpoints in breakpointsFile
&gt; elements = ""
&gt;
20,21c23,24
&lt; # Breakpoints in breakpointsFile
&lt; elements = ""
---
&gt; # Maximum number of time series in a terminal node
&gt; threshold = 100
22a26,37
&gt; # Keeps number of splits
&gt; nSplits = 0
&gt;
&gt; # Keeps number of accesses of subsequences
&gt; nSubsequences = 0
&gt;
&gt; # Currently supporting TWO promotion strategies
&gt; defaultPromotion = True
&gt;
&gt; # Number of overflows
&gt; overflow = 0
&gt;
24a40,42
&gt;
&gt; # Segment to promote
&gt; promote = 0</pre>
<p>Lines beginning with <strong class="source-inline">&gt;</strong> show the contents of <strong class="source-inline">ch04/isax/variables.py</strong>, whereas lines beginning <a id="_idIndexMarker283"/>with <strong class="source-inline">&lt;</strong> show<a id="_idIndexMarker284"/> statements <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">ch03/sax/variables.py</strong></span><span class="No-Break">.</span></p>
<p>The next subsection discusses <strong class="source-inline">sax.py</strong>, which did not change <span class="No-Break">that much.</span></p>
<h2 id="_idParaDest-102"><a id="_idTextAnchor113"/>The sax.py file</h2>
<p>The <strong class="source-inline">sax.py</strong> file does<a id="_idIndexMarker285"/> have<a id="_idIndexMarker286"/> any practical changes. However, we should make changes to its <strong class="source-inline">import</strong> statements as it is no longer an autonomous package but a part of another package with a different name. Therefore, we need to change the following <span class="No-Break">two statements:</span></p>
<pre class="source-code">
from sax import sax
from sax import variables</pre>
<p>We replace them with <span class="No-Break">these statements:</span></p>
<pre class="source-code">
from isax import sax
from isax import variables</pre>
<p>Apart from that, there is no need for <span class="No-Break">additional changes.</span></p>
<p>Now that we know the source code of the <strong class="source-inline">isax</strong> package, it is time to see that code <span class="No-Break">in action.</span></p>
<h1 id="_idParaDest-103"><a id="_idTextAnchor114"/>Using the iSAX Python package</h1>
<p>In this section, we are<a id="_idIndexMarker287"/> going to use the <strong class="source-inline">isax</strong> Python package to develop practical command-line utilities. But first, we are going to learn how to read the iSAX parameters from <span class="No-Break">the users.</span></p>
<h2 id="_idParaDest-104"><a id="_idTextAnchor115"/>Reading the iSAX parameters</h2>
<p>This subsection <a id="_idIndexMarker288"/>illustrates how to read the iSAX parameters, including the filenames with the time series, and how to give default values to some of them. Although we saw relevant code in <a href="B14769_02_MA.xhtml#_idTextAnchor053"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, this time, the process is explained in more detail. Additionally, the code is also going to show how we use these input parameters to set up the relevant variables located inside the <strong class="source-inline">./isax/variables.py</strong> file. As a reminder, variables stored in <strong class="source-inline">./isax/variables.py</strong>, or other similar files – it just happens that we are using <strong class="source-inline">./isax/variables.py</strong> – are accessible from anywhere in our code as long as we have successfully imported the <span class="No-Break">relevant file.</span></p>
<p class="callout-heading">What we need to create an iSAX index</p>
<p class="callout">As a reminder, to <a id="_idIndexMarker289"/>create an iSAX index, we need a time series and a threshold value, which is the maximum number of subsequences that a terminal node can hold, as well as a segment value and a cardinality value. Last, we need a sliding <span class="No-Break">window size.</span></p>
<p>As a rule of thumb, when working with global variables, it is better to use long and descriptive names. Additionally, it is also a good practice to give default values to <span class="No-Break">global parameters.</span></p>
<p>The Python code of <strong class="source-inline">parameters.py</strong> is <span class="No-Break">shown here:</span></p>
<pre class="source-code">
#!/usr/bin/env python3
import argparse
from isax import variables
def main():
    parser = argparse.ArgumentParser()
    parser.<strong class="bold">add_argument</strong>("-s", "--segments",
        dest = "segments", default = "4",
        help="Number of Segments", <strong class="bold">type=int</strong>)
    parser.<strong class="bold">add_argument</strong>("-c", "--cardinality",
        dest = "cardinality", default = "32",
        help="Cardinality", <strong class="bold">type=int</strong>)
    parser.<strong class="bold">add_argument</strong>("-w", "--window", dest = "window",
        default = "16", help="Sliding Window Size",
        <strong class="bold">type=int</strong>)
    parser.<strong class="bold">add_argument</strong>("TS1")
    args = parser.parse_args()
    <strong class="bold">variables.segments</strong> = <strong class="bold">args.segments</strong>
    <strong class="bold">variables.maximumCardinality</strong> = args.cardinality
    <strong class="bold">variables.slidingWindowSize</strong> = args.window
    windowSize = <strong class="bold">variables.slidingWindowSize</strong>
    maxCardinality = <strong class="bold">variables.maximumCardinality</strong>
    f1 = args.TS1
    print("Time Series:", f1, "Window Size:", windowSize)
    print("Maximum Cardinality:", maxCardinality,
        "Segments:", variables.segments)
if __name__ == '__main__':
    main()</pre>
<p>All the work is done by the <strong class="source-inline">argparse</strong> package and the <strong class="source-inline">parser.add_argument()</strong> statements that are used for defining command-line parameters and options. The <strong class="source-inline">dest</strong> parameter defines the name of the parameter – this name is going to be used later to read the value of <span class="No-Break">the parameter.</span></p>
<p>One of the other parameters of <strong class="source-inline">parser.add_argument()</strong> is called <strong class="source-inline">type</strong> and allows us to define the data type of the parameter. This can save you from lots of issues and code for <a id="_idIndexMarker290"/>converting strings into actual values, so use <strong class="source-inline">type</strong> <span class="No-Break">when possible.</span></p>
<p>After that, we call <strong class="source-inline">parser.parse_args()</strong> and we are ready to read any <strong class="source-inline">rgparse</strong> parameter <span class="No-Break">we want.</span></p>
<p>Running <strong class="source-inline">parameters.py</strong> produces the <span class="No-Break">following output:</span></p>
<pre class="source-code">
$ ./parameters.py -s 2 -c 32 -w 16 ts1.gz
Time Series: ts1.gz Window Size: 16
Maximum Cardinality: 32 Segments: 2</pre>
<p>In case of an error, <strong class="source-inline">parameters.py</strong> generates the <span class="No-Break">following output:</span></p>
<pre class="source-code">
$ ./parameters.py -s 1 -c cardinality ts1.gz
usage: parameters.py [-h] [-s SEGMENTS] [-c CARDINALITY] [-w WINDOW] TS1
parameters.py: error: argument -c/--cardinality: invalid int value: 'cardinality'</pre>
<p>In this case, the error is that the <strong class="source-inline">cardinality</strong> parameter is a string, whereas we are expecting an integer. The error output is <span class="No-Break">very informative.</span></p>
<p>If a required parameter is missing, <strong class="source-inline">parameters.py</strong> generates the <span class="No-Break">following output:</span></p>
<pre class="source-code">
$ ./parameters.py
usage: parameters.py [-h] [-s SEGMENTS] [-c CARDINALITY] [-w WINDOW] TS1
parameters.py: error: the following arguments are required: TS1</pre>
<p>The next section<a id="_idIndexMarker291"/> shows how we process the subsequences of a time series in order to create an <span class="No-Break">iSAX index.</span></p>
<h2 id="_idParaDest-105"><a id="_idTextAnchor116"/>How to process subsequences to create an iSAX index</h2>
<p>This is a really <a id="_idIndexMarker292"/>important subsection because here, we explain the Python structure that is used to store the data for each subsequence of an <span class="No-Break">iSAX index.</span></p>
<p class="callout-heading">The code does not lie!</p>
<p class="callout">If you have doubts about the fields and the data stored in each subsequence, check out the Python code to learn more. The documentation might lie but the code <span class="No-Break">never does.</span></p>
<p>The <strong class="source-inline">subsequences.py</strong> script shows how we create the subsequences, how we store them in a Python data structure, and how we might <span class="No-Break">process them:</span></p>
<pre class="source-code">
#!/usr/bin/env python3
import argparse
import numpy as np
import pandas as pd
from isax import sax
from isax import variables
class TS:
    def __init__(self, ts, index):
        self.ts = ts
        self.sax = sax.createPAA(ts,
            variables.maximumCardinality,
            variables.segments)
        self.index = index
def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("-w", "--window", dest = "window",
        default = "16", help="Sliding Window Size",
        type=int)
    parser.add_argument("-s", "--segments",
        dest = "segments", default = "4",
        help="Number of Segments", type=int)
    parser.add_argument("-c", "--cardinality",
        dest = "cardinality", default = "32",
        help="Cardinality", type=int)
    parser.add_argument("TS")
    args = parser.parse_args()
    windowSize = args.window
    variables.segments = args.segments
    variables.maximumCardinality = args.cardinality
    file = args.TS</pre>
<p>We define the <strong class="source-inline">TS</strong> class <a id="_idIndexMarker293"/>again and use that version in <strong class="source-inline">subsequences.py</strong> in order to be able to make more changes to the <strong class="source-inline">TS</strong> class without the danger of altering the code of the <strong class="source-inline">isax</strong> package. Before now, we have read the parameters of the program and we are ready to read the <span class="No-Break">time series:</span></p>
<pre class="source-code">
    ts = pd.read_csv(file, names=['values'],
        compression='gzip', header = None)
    ts_numpy = ts.to_numpy()
    length = len(ts_numpy)</pre>
<p>Currently, we have the time series stored as a NumPy array using the <span class="No-Break"><strong class="source-inline">ts_numpy</strong></span><span class="No-Break"> variable:</span></p>
<pre class="source-code">
    # Split sequence into subsequences
    n = 0
    for i in range(<strong class="bold">length - windowSize + 1</strong>):
        # Get the actual subsequence
        ts = ts_numpy[i:i+windowSize]
        # Create new TS node based on ts
        ts_node = TS(<strong class="bold">sax.normalize(ts)</strong>, i)
        n = n + n</pre>
<p>The <strong class="source-inline">for</strong> loop splits the<a id="_idIndexMarker294"/> time series into subsequences based on the sliding window size. The normalized version of each subsequence is stored in a <strong class="source-inline">TS()</strong> structure that has three members: the normalized version of the subsequence (<strong class="source-inline">ts</strong>), the SAX representation of the subsequence (<strong class="source-inline">sax</strong>), and the place of the subsequence in the time series (<strong class="source-inline">index</strong>). The last member of the <strong class="source-inline">TS()</strong> structure allows us to find the original version of the subsequence, should we want to <span class="No-Break">do so.</span></p>
<p>Now, check the <span class="No-Break">following code:</span></p>
<pre class="source-code">
    print("Created", n, "TS() nodes")
if __name__ == '__main__':
    main()</pre>
<p>After we finish, the script prints the number of subsequences that have <span class="No-Break">been processed.</span></p>
<p>Only after we have stored the SAX representation of a subsequence in its Python structure based on the maximum cardinality are we ready to put that subsequence into the iSAX index. So, the next step, which is not presented here, is putting each <strong class="source-inline">TS()</strong> node into an <span class="No-Break">iSAX index.</span></p>
<p>The output of <strong class="source-inline">subsequences.py</strong> gives you information about the number of subsequences that have <span class="No-Break">been processed:</span></p>
<pre class="source-code">
$ ./subsequences.py ts1.gz
Created 35 TS() nodes</pre>
<p>In summary, this<a id="_idIndexMarker295"/> is the way we are going to process subsequences in order to add them to an iSAX index. In the next subsection, we are going to create our first <span class="No-Break">iSAX index!</span></p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor117"/>Creating our first iSAX index</h2>
<p>In this section, we<a id="_idIndexMarker296"/> are going to create an iSAX index for the first time. But first, we are going to present the Python utility for doing that. The Python code of <strong class="source-inline">createiSAX.py</strong> is presented in four parts. The first part is <span class="No-Break">the following:</span></p>
<pre class="source-code">
#!/usr/bin/env python3
from isax import variables
from isax import isax
from isax import tools
from isax import sax
import sys
import pandas as pd
import numpy as np
import time
import argparse
def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("-s", "--segments",
        dest = "segments", default = "16",
        help="Number of Segments", type=int)
    parser.add_argument("-c", "--cardinality",
        dest = "cardinality", default = "16",
        help="Cardinality", type=int)
    parser.add_argument("-w", "--windows", dest = "window",
        default = "16", help="Sliding Window Size",
        type=int)
    parser.add_argument("-t", "--threshold",
        dest = "threshold", default = "1000",
        help="Threshold for split", type=int)
    parser.add_argument("-p", "--promotion",
        action='store_true',
        help="Define Promotion Strategy")
    parser.add_argument("TSfile")
    args = parser.parse_args()</pre>
<p>This first part is <a id="_idIndexMarker297"/>about the <strong class="source-inline">import</strong> statements and reading the required parameters <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">argparse</strong></span><span class="No-Break">.</span></p>
<p>The second part of <strong class="source-inline">createiSAX.py</strong> is <span class="No-Break">the following:</span></p>
<pre class="source-code">
    variables.segments = args.segments
    variables.maximumCardinality = args.cardinality
    variables.slidingWindowSize = args.window
    variables.threshold = args.threshold
    variables.defaultPromotion = args.promotion
    file = args.TSfile
    maxCardinality = variables.maximumCardinality
    segments = variables.segments
    windowSize = variables.slidingWindowSize
    if tools.power_of_two(maxCardinality) == -1:
        print("Not a power of 2:", maxCardinality)
        sys.exit()
    if variables.segments &gt; variables.slidingWindowSize:
        print("Segments:", variables.segments,
            "Sliding window:", variables.slidingWindowSize)
        print("Sliding window size should be bigger than #
            of segments.")
        sys.exit()
    print("Max Cardinality:", maxCardinality, "Segments:",
        variables.segments,
        "Sliding Window:", variables.slidingWindowSize,
        "Threshold:", variables.threshold,
        "Default Promotion:", variables.defaultPromotion)</pre>
<p>In this part of <strong class="source-inline">createiSAX.py</strong>, we assign the parameters to the relevant local and global variables and make some tests to make sure that the parameters make sense. The reason for using local variables is to have smaller variable names to work with. The <strong class="source-inline">print()</strong> statement outputs the parameters on <span class="No-Break">the screen.</span></p>
<p>The third part of <strong class="source-inline">createiSAX.py</strong> contains the <span class="No-Break">following code:</span></p>
<pre class="source-code">
    ts = pd.read_csv(file, names=['values'],
        compression='gzip')
    ts_numpy = ts.to_numpy()
    length = len(ts_numpy)
    #
    # Initialize iSAX index
    #
    ISAX = isax.iSAX()</pre>
<p>In this part, we read <a id="_idIndexMarker298"/>the compressed time series file and create the NumPy variable that holds the entire time series. After that, we initialize a variable to hold the iSAX index. As the name of the class is <strong class="source-inline">iSAX</strong>, the relevant variable is initialized as an instance of the <span class="No-Break"><strong class="source-inline">isax.iSAX()</strong></span><span class="No-Break"> class.</span></p>
<p>The last part of <strong class="source-inline">createiSAX.py</strong> contains the <span class="No-Break">following code:</span></p>
<pre class="source-code">
    # Split sequence into subsequences
    for i in range(length - windowSize + 1):
        # Get the subsequence
        ts = ts_numpy[i:i+windowSize]
        # Create new TS node based on ts
        ts_node = isax.TS(ts, segments)
        ISAX.insert(ts_node)
if __name__ == '__main__':
    main()</pre>
<p>This last part splits the time series according to the sliding window size, creates the <strong class="source-inline">TS()</strong> objects, and inserts them into the iSAX index using the <strong class="source-inline">insert()</strong> method of the <strong class="source-inline">iSAX</strong> class using the <strong class="source-inline">ISAX</strong> variable – remember that it is <strong class="source-inline">iSAX.insert()</strong> that <span class="No-Break">calls </span><span class="No-Break"><strong class="source-inline">Node.insert()</strong></span><span class="No-Break">.</span></p>
<p>Running <strong class="source-inline">createiSAX.py</strong> produces the <span class="No-Break">following output:</span></p>
<pre class="source-code">
$ ./createiSAX.py ts1.gz
Max Cardinality: 16 Segments: 16 Sliding Window: 16 Threshold: 1000 Default Promotion: False
$ ./createiSAX.py
usage: createiSAX.py [-h] [-s SEGMENTS] [-c CARDINALITY] [-w WINDOW] [-t THRESHOLD] [-p] TSfile
createiSAX.py: error: the following arguments are required: TSfile</pre>
<p>The good thing is that <strong class="source-inline">createiSAX.py</strong> has default values for all iSAX parameters. However, providing <a id="_idIndexMarker299"/>the path for the file that holds the time series <span class="No-Break">is required.</span></p>
<p>In the next subsection, we are going to develop a command-line utility that counts the total number of subsequences in an <span class="No-Break">iSAX index.</span></p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor118"/>Counting the subsequences of an iSAX index</h2>
<p>This is a really <a id="_idIndexMarker300"/>handy utility that not only shows <em class="italic">how to traverse an entire iSAX index</em> but also allows you to count all the subsequences of an iSAX index and make sure that you have not missed any subsequences in the process, which can be used for <span class="No-Break">testing purposes.</span></p>
<p>The code of <strong class="source-inline">countSub.py</strong> that does the counting is the following – the rest of the implementation is the same as <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">createiSAX.py</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
    # Visit all entries in Dictionary
    # Count TS in Terminal Nodes
    sum = 0
    for k in <strong class="bold">ISAX.ht</strong>:
        t = ISAX.ht[k]
        if t.terminalNode:
            sum += t.nTimeSeries()
    print(length - windowSize + 1, sum)</pre>
<p>The code visits the <strong class="source-inline">ISAX.ht</strong> field of an iSAX class because this is where <em class="italic">all the nodes </em>of the iSAX index are kept. If we are working with a terminal node, then we call the <strong class="source-inline">nTimeSeries()</strong> method to find the number of subsequences that are stored in that terminal node. We do that for all the terminal nodes, and we are done. The last statement prints both the theoretical number of subsequences as well as the actual number of subsequences found in the iSAX index. As long as these two values are the same, we <span class="No-Break">are good.</span></p>
<p>Running <strong class="source-inline">countSub.py</strong> on a small time series, which you can find in the <strong class="source-inline">ch04</strong> directory, generates<a id="_idIndexMarker301"/> the following kind <span class="No-Break">of output:</span></p>
<pre class="source-code">
$ ./countSub.py ts1.gz
Max Cardinality: 16 Segments: 16 Sliding Window: 16 Threshold: 1000 Default Promotion: False
35 35</pre>
<p>The subsection that follows shows the time it takes to construct an <span class="No-Break">iSAX index.</span></p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor119"/>How long does it take to create an iSAX index?</h2>
<p>In this subsection, we<a id="_idIndexMarker302"/> are going to compute the time it takes a computer to create an iSAX index. The main reason for any delays in the construction phase of iSAX is the splitting of nodes and the rearrangement of the subsequences. The more extensive splitting we have, the more time it takes to generate <span class="No-Break">the index.</span></p>
<p>The code of <strong class="source-inline">howMuchTime.py</strong> that computes the time it takes to create the iSAX index is the following – the rest of the implementation is the same as <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">createiSAX.py</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
    start_time = time.time()
    print("--- %.5f seconds ---" % (time.time() –
        start_time))</pre>
<p>The first statement is located right before we begin reading the time series file using <strong class="source-inline">pd.read_csv()</strong> and the second statement is right after we finish splitting and inserting the time series into the <span class="No-Break">iSAX index.</span></p>
<p>The output of <strong class="source-inline">howMuchTime.py</strong> when processing <strong class="source-inline">ts1.gz</strong> is similar to <span class="No-Break">the following:</span></p>
<pre class="source-code">
$ ./howMuchTime.py -w 2 -s 2 ts1.gz
Max Cardinality: 16 Segments: 2 Sliding Window: 2 Threshold: 1000 Default Promotion: False
--- 0.00833 seconds ---</pre>
<p>As <strong class="source-inline">ts1.gz</strong> is a small time series with 50 elements, the output is not that interesting. Therefore, let us try using <strong class="source-inline">howMuchTime.py</strong> on bigger <span class="No-Break">time series.</span></p>
<p>The next output shows the time it took <strong class="source-inline">howMuchTime.py</strong> to create an iSAX index for a time series with 500,000 elements on a macOS machine with 32 GB of RAM and an Apple M1 Max CPU – you can create a time series with the same length on your own and try the same command <a id="_idIndexMarker303"/>or use the provided file, which is <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">500k.gz</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
$ ./howMuchTime.py 500k.gz
Max Cardinality: 16 Segments: 16 Sliding Window: 16 Threshold: 1000 Default Promotion: False
--- 114.80277 seconds ---</pre>
<p>The <strong class="source-inline">500k.gz</strong> file was created using the <span class="No-Break">following commands:</span></p>
<pre class="source-code">
$ ./ch01/synthetic_data.py 500000 -1 1 &gt; 500k
$ gzip 500k</pre>
<p>The following output shows the time it took <strong class="source-inline">howMuchTime.py</strong> to create an iSAX index for a time series with 2,000,000 elements on a macOS machine with 32 GB of RAM and an Apple M1 Max CPU – you can create a time series with the same or a bigger length on your own and try the same command or use the provided file, which is <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">2M.gz</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
$ ./howMuchTime.py 2M.gz
Max Cardinality: 16 Segments: 16 Sliding Window: 16 Threshold: 1000 Default Promotion: False
--- 450.37358 seconds ---</pre>
<p>The <strong class="source-inline">2M.gz</strong> file was created using the <span class="No-Break">following commands:</span></p>
<pre class="source-code">
$ ./ch01/synthetic_data.py 2000000 -10 10 &gt; 2M
$ gzip 2M</pre>
<p>One interesting conclusion that we can make is that for a time series that is four times bigger, it took our program about four times longer to build. However, this is not always <span class="No-Break">the case.</span></p>
<p>Additionally, the time it took to create an iSAX index does not tell the whole story, especially when testing on a busy machine or a slow machine with a little amount of RAM. What is more important is the number of node splits as well as the number of accesses to subsequences that were made. The minimum number of accesses to subsequences is equal to the subsequences of the time series. However, when splits take place, we must revisit the involved subsequences in order to distribute them according to the newly created SAX representations and terminal nodes. The splits and the revisiting of<a id="_idIndexMarker304"/> subsequences increase the construction time of <span class="No-Break">the iSAX.</span></p>
<p>Therefore, we are going to create a modified version of <strong class="source-inline">howMuchTime.py</strong> that also prints the number of node splits, as well as the total number of subsequence accesses. The name of the new utility is <strong class="source-inline">accessSplit.py</strong>. The statements that do the counting of the splits and the subsequence accessing are already present in <strong class="source-inline">isax/isax.py</strong> and we just need to access two global variables, which are <strong class="source-inline">variables.nSplits</strong> and <strong class="source-inline">variables.nSubsequences</strong>, to get <span class="No-Break">the results.</span></p>
<p>Running <strong class="source-inline">accessSplit.py</strong> with the default parameters on <strong class="source-inline">500k.gz</strong> produces the following kind <span class="No-Break">of output:</span></p>
<pre class="source-code">
$ ./accessSplit.py 500k.gz
Max Cardinality: 16 Segments: 16 Sliding Window: 16 Threshold: 1000 Default Promotion: False
Number of splits: 0
Number of subsequence accesses: 499985</pre>
<p>What does this output tell us? It tells us that there was no split! In practice, this means that the root node of that particular iSAX index has terminal nodes only as children. Is this good or bad? In general, this means that <em class="italic">the index works like a hash table</em> where the hash function is the function for calculating the SAX representation. Most of the time, this is not the desirable form that we want an index to have because we could have used a hash table in the <span class="No-Break">first place!</span></p>
<p>If we run <strong class="source-inline">accessSplit.py</strong> on the same time series using different parameters, we are going to get a totally different output regarding the construction of the <span class="No-Break">iSAX index:</span></p>
<pre class="source-code">
$ ./accessSplit.py -w 1024 -s 8 -c 32 500k.gz
Max Cardinality: 32 Segments: 8 Sliding Window: 1024 Threshold: 1000 Default Promotion: False
Number of splits: 4733
Number of subsequence accesses: 16370018</pre>
<p>What does this output tell us? It tells us that even on a relatively small time series, the iSAX parameters play a huge role in the creation time of the iSAX index. However, the number of<a id="_idIndexMarker305"/> subsequence accesses is around 33 times the total number of subsequences of the time series, which is pretty big and therefore not <span class="No-Break">very efficient.</span></p>
<p>Let us now try <strong class="source-inline">accessSplit.py</strong> on a bigger time series, which is <strong class="source-inline">2M.gz</strong>, and see <span class="No-Break">what happens:</span></p>
<pre class="source-code">
$ ./accessSplit.py 2M.gz
Max Cardinality: 16 Segments: 16 Sliding Window: 16 Threshold: 1000 Default Promotion: False
Number of splits: 0
Number of subsequence accesses: 1999985</pre>
<p>As before, we are using the iSAX index as a hash table, which is not the desired behavior. Let us try using different <span class="No-Break">parameters instead:</span></p>
<pre class="source-code">
$ ./accessSplit.py -s 8 -c 32 2M.gz
Max Cardinality: 32 Segments: 8 Sliding Window: 16 Threshold: 1000 Default Promotion: False
Number of splits: 3039
Number of subsequence accesses: 13694075</pre>
<p>This time, the number of accesses to subsequences is around seven times the length of the time series, which is more realistic than when we were working with the <span class="No-Break"><strong class="source-inline">500k.gz</strong></span><span class="No-Break"> file.</span></p>
<p>We are going to <a id="_idIndexMarker306"/>work with <strong class="source-inline">accessSplit.py</strong> again in <a href="B14769_05.xhtml#_idTextAnchor124"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>. But for now, we are going to learn more about the overflow of <span class="No-Break">iSAX indexes.</span></p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor120"/>Dealing with iSAX overflows</h2>
<p>In this subsection, we <a id="_idIndexMarker307"/>are going to experiment with an overflow situation. Keep in mind that a dedicated global parameter exists in <strong class="source-inline">variables.py</strong> that holds the number of subsequences that were ignored due to overflow. Among other things, this helps you fix the iSAX parameters faster as you know how bad the overflow is. Usually, the easiest way to fix an overflow is by increasing the threshold value, but this might have serious implications when searching an iSAX index or comparing an iSAX index with <span class="No-Break">another one.</span></p>
<p>The Python code of <strong class="source-inline">overflow.py</strong> has only one change compared to <strong class="source-inline">createiSAX.py</strong>, which is the following statement because the SAX representation that created the overflow is printed <span class="No-Break">by default:</span></p>
<pre class="source-code">
print("Number of overflows:", variables.overflow)</pre>
<p>This mainly happens because the functionality is built into the <strong class="source-inline">isax</strong> package, which automatically prints a message when the first overflow takes place, and we just have to access the <strong class="source-inline">variables.overflow</strong> variable to find out the total number <span class="No-Break">of overflows.</span></p>
<p>The output of <strong class="source-inline">overflow.py</strong> when working with the <strong class="source-inline">500k.gz</strong> time series includes the <span class="No-Break">following information:</span></p>
<pre class="source-code">
$ ./overflow.py -w 1024 -s 8 500k.gz
Max Cardinality: 16 Segments: 8 Sliding Window: 1024 Threshold: 1000 Default Promotion: False
OVERFLOW: 1000_0111_0111_1000_1000_0111_0111_1000
Number of overflows: 303084</pre>
<p>The previous output tells us that the first SAX representation that caused an overflow was <strong class="source-inline">1000_0111_0111_1000_1000_0111_0111_1000</strong> and that we had <strong class="source-inline">303084</strong> overflows in total – we might have more SAX representations that cause an overflow, but we have decided to print just the first one. This means that <strong class="source-inline">303084</strong> subsequences were not inserted into the iSAX index, which is a very large number compared to the length of the <span class="No-Break">time series.</span></p>
<p>Let us now try the same command using the other promotion strategy and see <span class="No-Break">what happens:</span></p>
<pre class="source-code">
$ ./overflow.py -w 1024 -s 8 500k.gz -p
Max Cardinality: 16 Segments: 8 Sliding Window: 1024 Threshold: 1000 Default Promotion: True
Non recoverable Promotion overflow!
OVERFLOW: 1000_0111_0111_1000_1000_0111_0111_1000
Number of overflows: 303084</pre>
<p>It turns out that we got the same kind of overflow and the exact same number of total overflows. This makes perfect sense as the overflow situation does not have to do with the promotion<a id="_idIndexMarker308"/> strategy but with the SAX representations. <em class="italic">A different promotion strategy might change the shape of an iSAX index a little, but it has nothing to do with the </em><span class="No-Break"><em class="italic">overflow situation.</em></span></p>
<p>As <strong class="source-inline">303084</strong> is a big number, we might need to drastically increase the capacity of the iSAX index but without creating an unnecessarily big iSAX index. So, with that in mind, we can try to resolve the overflow situation by changing the parameters of the iSAX index. Let us try to do so then by increasing the <span class="No-Break">threshold value:</span></p>
<pre class="source-code">
$ ./overflow.py -w 1024 -s 8 -c 16 -t 1500 500k.gz
Max Cardinality: 16 Segments: 8 Sliding Window: 1024 Threshold: 1500 Default Promotion: False
OVERFLOW: 0111_1000_1000_1000_1000_0111_0111_0111
Number of overflows: 176454</pre>
<p>So, it looks like we cut the number of overflows in half, which is a good thing for a start. However, although we are using the same cardinality as before, it is a different SAX representation (<strong class="source-inline">0111_1000_1000_1000_1000_0111_0111_0111</strong>) that caused the first overflow this time, which means that the increased threshold value solved the overflow condition that took place earlier with the <strong class="source-inline">1000_0111_0111_1000_1000_0111_0111_1000</strong> <span class="No-Break">SAX representation.</span></p>
<p>Let us give it another try by increasing the <strong class="source-inline">cardinality</strong> value and at the same time decreasing the <span class="No-Break">threshold value:</span></p>
<pre class="source-code">
$ ./overflow.py -w 1024 -s 8 -c 32 -t 500 500k.gz
Max Cardinality: 32 Segments: 8 Sliding Window: 1024 Threshold: 500 Default Promotion: False
Number of overflows: 0</pre>
<p>So, we finally found a triplet of parameters that works for the <strong class="source-inline">1024</strong> sliding window size and the <span class="No-Break"><strong class="source-inline">500k.gz</strong></span><span class="No-Break"> dataset.</span></p>
<p>Is there a recipe for finding out which parameters work and which do not work? No, as it mainly depends on the values of the dataset and the sliding window size. The more you work and experiment with iSAX indexes, the more you are going to understand which parameters work<a id="_idIndexMarker309"/> best for a given dataset and sliding <span class="No-Break">window size.</span></p>
<p>So, in this last section, we learned about iSAX overflows and presented a technique for solving <span class="No-Break">such situations.</span></p>
<h1 id="_idParaDest-110"><a id="_idTextAnchor121"/>Summary</h1>
<p>In this chapter, we saw and went through the implementation details of the <strong class="source-inline">isax</strong> Python package, which allows us to create iSAX indexes. Please make sure that you understand the code and most importantly know how to use <span class="No-Break">the code.</span></p>
<p>Additionally, we implemented many command-line utilities that allow us to create iSAX indexes and understand what happens behind the scenes regarding the splits and subsequence accesses as well as the overflow conditions. Having a better understanding of the structure of an iSAX index allows us to select better indexes and avoid using <span class="No-Break">poor ones.</span></p>
<p>The next chapter is going to put iSAX indexes into practice by showing how to search and join <span class="No-Break">iSAX indexes.</span></p>
<h1 id="_idParaDest-111"><a id="_idTextAnchor122"/>Useful links</h1>
<ul>
<li>The <strong class="source-inline">argparse</strong> <span class="No-Break">package: </span><a href="https://docs.python.org/3/library/argparse.xhtml"><span class="No-Break">https://docs.python.org/3/library/argparse.xhtml</span></a></li>
<li>The NumPy Python <span class="No-Break">package: </span><a href="https://numpy.org/"><span class="No-Break">https://numpy.org/</span></a></li>
</ul>
<h1 id="_idParaDest-112"><a id="_idTextAnchor123"/>Exercises</h1>
<p>Try to work through the <span class="No-Break">following exercises:</span></p>
<ul>
<li>Create a synthetic dataset with 100,000 elements with values from <em class="italic">-10 to 10</em> and construct an iSAX index with 4 segments, a cardinality of 64, and a threshold value of <strong class="source-inline">1000</strong>. How much time did it take your machine to create the iSAX index? Are there <span class="No-Break">any overflows?</span></li>
<li>Create a synthetic dataset with 100,000 elements with values from <em class="italic">-1 to 1</em> and construct an iSAX index with 4 segments, a cardinality of 64, and a threshold value of <strong class="source-inline">1000</strong>. How much time did it take your machine to create that <span class="No-Break">iSAX index?</span></li>
<li>Create a synthetic dataset with 500,000 elements with values from <em class="italic">0 to 10</em> and construct an iSAX index with 4 segments, a cardinality of 64, and a threshold value of <strong class="source-inline">1000</strong>. How much time did it take your machine to create the <span class="No-Break">iSAX index?</span></li>
<li>Create a synthetic dataset with 500,000 elements with values from <em class="italic">0 to 10</em> and construct an iSAX index with 4 segments, a cardinality of 64, and a threshold value of <strong class="source-inline">1000</strong>. How many splits and accesses to subsequences took place? What happens if you increase the threshold value <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">1500</strong></span><span class="No-Break">?</span></li>
<li>Create a synthetic dataset with 150,000 elements with values from <em class="italic">-1 to 1</em> and construct an iSAX index with 4 segments, a cardinality of 64, and a threshold value of <strong class="source-inline">1000</strong>. Are there any overflows? How many splits were performed for the construction of the <span class="No-Break">iSAX index?</span></li>
<li>Experiment with <strong class="source-inline">accessSplit.py</strong> on <strong class="source-inline">2M.gz</strong> using various iSAX parameters. Which parameters seem to work best? Do not forget that high threshold values have a great impact on searching; so, in general, do not use huge threshold values to lower the number <span class="No-Break">of splits.</span></li>
<li>Experiment with <strong class="source-inline">accessSplit.py</strong> on <strong class="source-inline">500k.gz</strong> using various iSAX parameters. Which parameters seem to <span class="No-Break">work best?</span></li>
</ul>
</div>
</div></body></html>