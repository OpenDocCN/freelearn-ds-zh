<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-91"><a id="_idTextAnchor102"/>4</h1>
<h1 id="_idParaDest-92"><a id="_idTextAnchor103"/>iSAX – The Implementation</h1>
<p>Before continuing with this chapter and starting to write code, make sure that you have a good understanding of the information covered in the previous chapter because this chapter is all about implementing iSAX in Python. As a general principle, if you cannot perform a task manually, you are not going to be able to perform it with the help of a computer – the same principle applies to constructing and using an iSAX index.</p>
<p>While reading this chapter, keep in mind that we are creating an iSAX index that<em class="italic"> fits in memory</em> and does not use any external files to store the subsequences of each terminal node. The original iSAX paper suggested the use of external files to store the subsequences of each terminal node mainly because back then, RAM was limited compared to what is the case today, where we can easily have computers with many CPU cores and more than 64 GB of RAM. As a result, the use of RAM makes the entire process much faster than if we used disk files. However, if you do not have lots of RAM on your system and are working with large time series, you might end up using swap space, which slows down the process.</p>
<p>In this chapter, we are going to cover the following main topics:</p>
<ul>
<li>A quick look at the <code>isax</code> Python package</li>
<li>The class for storing subsequences</li>
<li>The class for iSAX nodes</li>
<li>The class for entire iSAX indexes</li>
<li>Explaining the missing parts</li>
<li>Exploring the remaining files</li>
<li>Using the iSAX Python package</li>
</ul>
<h1 id="_idParaDest-93"><a id="_idTextAnchor104"/>Technical requirements</h1>
<p>The GitHub repository with the code can be found at <a href="https://github.com/PacktPublishing/Time-Series-Indexing">https://github.com/PacktPublishing/Time-Series-Indexing</a>. The code for each chapter is in its own directory. Therefore, the code for this chapter can be found in the <code>ch04</code> folder and the <code>ch04</code> subfolders.</p>
<p>The first section takes a quick look at the Python package that we have developed for the purposes of this chapter, which strangely enough is called <code>isax</code>, before going into more detail.</p>
<p class="callout-heading">What about bugs?</p>
<p class="callout">We have tried <a id="_idIndexMarker223"/>our best to give bug-free code. However, bugs might appear in any program, especially when a program is longer than 100 lines! That is why it is crucial to understand the principles behind the operation and construction of an iSAX index and the SAX representation to be able to understand that there might be a small or bigger issue with the code, or be able to port the existing implementation to a different programming language. I wrote the Python version of iSAX using a Java implementation from a colleague as my starting point.</p>
<h1 id="_idParaDest-94"><a id="_idTextAnchor105"/>A quick look at the iSAX Python package</h1>
<p>In this section, we <a id="_idIndexMarker224"/>will take a first look at the iSAX Python package to get a better idea of the supported functionality. Although we will begin with the code from the <code>sax</code> package we developed in <a href="B14769_02_MA.xhtml#_idTextAnchor053"><em class="italic">Chapter 2</em></a>, we are going to rename that package <code>isax</code> and create additional source code, which is named <code>isax.py</code>.</p>
<p>The structure of the <code>isax</code> directory with the Python files is going to be as follows:</p>
<pre class="source-code">
$ tree isax/
isax/
├── SAXalphabet
├── __init__.py
├── isax.py
├── sax.py
├── tools.py
└── variables.py
1 directory, 6 files</pre>
<p>So, in total, we have six files. You already know five of them from the <code>sax</code> package. The only new one is the <code>isax.py</code> source code file, which is the core file for this chapter. Additionally, we are going to add more global variables to the <code>variables.py</code> file and some functions to <code>tools.py</code>.</p>
<p>The list of methods found in the <code>isax.py</code> file, which excludes <code>__init__()</code> functions, is the following:</p>
<pre class="source-code">
$ grep -w def isax/isax.py | grep -v __init__
    def insert(self, ts, ISAX):
    def nTimeSeries(self):
    def insert(self, ts_node):</pre>
<p>The reason that <a id="_idIndexMarker225"/>we are talking about methods and not functions is that each function is attached to a Python class, which automatically makes it a method of that class.</p>
<p>Additionally, if we also include <code>__init__()</code> functions in the output, then we might get a good prediction of the number of classes found in that Python file. In that case, you might want to run <code>grep -w def -n1 </code><code>isax/isax.py</code> instead:</p>
<pre class="source-code">
$ grep -w def -n1 isax/isax.py
5-class TS:
6:    def __init__(self, ts, segments):
7-        self.index = 0
--
11-class Node:
12:    def __init__(self, sax_word):
13-        self.left = None
--
19-    # Follow algorithm from iSAX paper
20:    def insert(self, ts, ISAX):
21-        # Accessing a subsequence
--
127-
128:    def nTimeSeries(self):
129-        if self.terminalNode == False:
--
141-class iSAX:
142:    def __init__(self):
143-        # This is now a hash table
--
148-
149:    def insert(self, ts_node):
150-        # Array with number of segments</pre>
<p>So, we have <a id="_idIndexMarker226"/>three classes, named <code>TS</code>, <code>Node</code>, and <code>iSAX</code>.</p>
<p>The next sections are going to discuss the methods of <code>isax.py</code> in relation to the class that they belong to.</p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor106"/>The class for storing subsequences</h2>
<p>In this <a id="_idIndexMarker227"/>subsection, we are going to <a id="_idIndexMarker228"/>explain the Python class used for <code>TS</code>. The definition of the class is as follows:</p>
<pre class="source-code">
class TS:
    def __init__(self, ts, segments):
        self.index = 0
        self.ts = ts
        self.maxCard = sax.createPAA(ts,
            variables.maximumCardinality, segments)</pre>
<p>When defining an object of that class, we need to provide the <code>ts</code> parameter, which is a subsequence stored as a NumPy array, and the number of segments using the <code>segments</code> parameter. After that, the <code>maxCard</code> field is automatically initialized with the SAX representation of that subsequence with the maximum cardinality. The <code>index</code> parameter is optional and keeps the place of the subsequence in the original time series. iSAX does not use the <code>index</code> parameter but it is good to have such a field.</p>
<p>This class <a id="_idIndexMarker229"/>not have any methods<a id="_idIndexMarker230"/> attached to it, which is not the case with the <code>Node</code> class that is presented next.</p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor107"/>The class for iSAX nodes</h2>
<p>In this<a id="_idIndexMarker231"/> subsection, we <a id="_idIndexMarker232"/>will explain the Python structure used for <em class="italic">keeping both inner and terminal nodes</em>. This is an important part of the package and its functionality:</p>
<pre class="source-code">
class Node:
    def __init__(self, sax_word):
        self.left = None
        self.right = None
        self.terminalNode = False
        self.word = sax_word
        self.children = [TS] * variables.threshold</pre>
<p>If we are dealing with an inner node, then the <code>terminalNode</code> field is set to <code>False</code>. However, if the Boolean value of the <code>terminalNode</code> field is set to <code>True</code>, then we are dealing with a terminal node.</p>
<p>The <code>word</code> field holds the SAX representation of the node. Lastly, the <code>left</code> and <code>right</code> fields are links to the two children of an inner node, whereas the <code>children</code> field is a list that holds the subsequences of a terminal node.</p>
<p>The <code>Node</code> class has two methods:</p>
<ul>
<li><code>insert()</code>: This method is used for adding subsequences to a node</li>
<li><code>nTimeSeries()</code>: This method is used for counting the number of subsequences stored in a terminal node</li>
</ul>
<p>Next, let us<a id="_idIndexMarker233"/> talk about the class for representing <a id="_idIndexMarker234"/>entire iSAX indexes.</p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor108"/>The class for entire iSAX indexes</h2>
<p>This last<a id="_idIndexMarker235"/> class of the <code>isax</code> package<a id="_idIndexMarker236"/> is used to represent entire iSAX indexes:</p>
<pre class="source-code">
class <strong class="bold">iSAX</strong>:
    def __init__(self):
        # This is now a hash table
        self.children = {}
        # HashTable for storing Nodes
        self.ht = {}
        self.length = 0</pre>
<p>The <code>children</code> field holds the children of the root node – in reality, the instances of the iSAX class are roots of iSAX indexes.</p>
<p>The <code>ht</code> field, which is a dictionary, holds all the nodes of the iSAX index. Each key is a SAX representation of a node, which is <em class="italic">unique</em>, and each value is a <code>Node</code> instance. Lastly, the <code>length</code> field holds the number of subsequences stored in the iSAX index and is an optional field.</p>
<p>The <code>iSAX</code> class has only one method, which is called <code>insert()</code> and is used to insert subsequences into the iSAX index.</p>
<p class="callout-heading">Why are we using these three classes?</p>
<p class="callout">The implementation<a id="_idIndexMarker237"/> of the iSAX index contains three different entities: subsequences, nodes, and the iSAX index itself, which is represented by the root node of the index. iSAX contains nodes and nodes contain other nodes or subsequences. Each of these entities has its own class.</p>
<p>So far, we know the details of the Python classes used in our package. The next section is about <a id="_idIndexMarker238"/>implementing the missing <a id="_idIndexMarker239"/>parts.</p>
<h1 id="_idParaDest-98"><a id="_idTextAnchor109"/>Explaining the missing parts</h1>
<p>In this section, we<a id="_idIndexMarker240"/> are going <a id="_idIndexMarker241"/>to show the implementations of the class methods. We begin with the <code>insert()</code> function of the <code>iSAX</code> class, which should not be confused with the <code>insert()</code> function of the <code>Node</code> class. In Python and many other programming languages, classes are independent entities, which means they can have methods with the same name as long as they are unique inside the class namespace.</p>
<p>We are going to present the code of <code>Node.insert()</code> in eight parts. The method accepts two parameters – apart from <code>self</code>, which denotes the current <code>Node</code> object – which are the subsequences we are trying to insert and the iSAX index that the <code>Node</code> instance belongs to.</p>
<p>Why do we need an iSAX instance as a parameter? We need that in order to be able to add new nodes to the iSAX index by accessing <code>iSAX.ht</code>.</p>
<p>The first part of <code>insert()</code> is the following:</p>
<pre class="source-code">
    # Follow algorithm from iSAX paper
    def insert(self, ts, ISAX):
        # Accessing a subsequence
        variables.nSubsequences += 1
        if <strong class="bold">self.terminalNode</strong>:
            if <strong class="bold">self.nTimeSeries() == variables.threshold</strong>:
                variables.nSplits += 1
                # Going to duplicate self Node
                temp = Node(self.word)
                temp.children = self.children
                temp.terminalNode = True
                # The current Terminal node becomes
                # an inner node
                self.terminalNode = False
                self.children = None</pre>
<p>The first thing that <code>insert()</code> does is check whether we are working with a terminal node or not. This happens because if we are dealing with a terminal node, we are going to try to store the given subsequence in the terminal node without any other delay. The second check is whether the terminal node is full or not. If it is full, then <em class="italic">we have a split</em>. First, we duplicate the current node with the <code>temp = Node(self.word)</code> statement and the current terminal node becomes an inner node by changing the value of <code>terminalNode</code> to <code>False</code>. At this point, we have to create two new empty nodes, which are going to become the two children of the current node – the former takes place in the code<a id="_idIndexMarker242"/> excerpt<a id="_idIndexMarker243"/> that follows.</p>
<p>The second part of <code>insert()</code> is as follows:</p>
<pre class="source-code">
                # Create TWO new Terminal nodes
                new1 = Node(temp.word)
                new1.terminalNode = True
                new2 = Node(temp.word)
                new2.terminalNode = True
                n1Segs = new1.word.split('_')
                n2Segs = new2.word.split('_')</pre>
<p>In the previous code, we create two new terminal nodes, which are going to be the children of the node that is going to be split. Both of these new nodes currently have the same SAX representation as the node that is going to be split and become an inner node. The change to their SAX representations, which signifies the split, is going to take place in<a id="_idIndexMarker244"/> the<a id="_idIndexMarker245"/> code that follows.</p>
<p>The third part contains the following code:</p>
<pre class="source-code">
                # This is where the promotion
                # strategy is selected
                if variables.defaultPromotion:
                    tools.round_robin_promotion(n1Segs)
                else:
                    tools.shorter_first_promotion(n1Segs)
                # New SAX_WORD 1
                <strong class="bold">n1Segs[variables.promote] =</strong>
                    <strong class="bold">n1Segs[variables.promote] + "0"</strong>
                # CONVERT it to string
                new1.word = "_".join(n1Segs)
                # New SAX_WORD 2
                <strong class="bold">n2Segs[variables.promote] =</strong>
                    <strong class="bold">n2Segs[variables.promote] + "1"</strong>
                # CONVERT it to string
                new2.word = "_".join(n2Segs)
                # The inner node has the same
                # SAX word as before but this is
                # not true for the two
                # NEW Terminal nodes, which should
                # be added to the Hash Table
                ISAX.ht[new1.word] = new1
                ISAX.ht[new2.word] = new2
                # Associate the 2 new Nodes with the
                # Node that is being splitted
                self.left = new1
                self.right = new2</pre>
<p>At the beginning of the code excerpt, we deal with the promotion strategy, which is implemented in the <code>tools.py</code> file, which is explained in <em class="italic">The tools.py file</em> section and has to do with defining the SAX word (segment) that is going to be promoted.</p>
<p>After that, the code creates the two SAX representations of a split using two string operations – this is<a id="_idIndexMarker246"/> the main reason that we store SAX<a id="_idIndexMarker247"/> words as strings and that we are using a list to hold an entire SAX presentation. After that, we convert the SAX representations into strings stored in <code>new1.word</code> and <code>new2.word</code> and then put the respective nodes into the iSAX index using <code>ISAX.ht[new1.word] = new1</code> and <code>ISAX.ht[new2.word] = new2</code>. The keys for finding these two nodes in the <code>iSAX.ht</code> Python dictionary are their own SAX representations. The last two statements of the code associate the two new terminal nodes with the inner node by defining the <code>left</code> and <code>right</code> fields of the inner node and, therefore, signifying its two children.</p>
<p>The fourth code part of the <code>Node.insert()</code> method is as follows:</p>
<pre class="source-code">
                <strong class="bold"># Check all TS in original node</strong>
                <strong class="bold"># and put them</strong>
                <strong class="bold"># in one of the two children</strong>
                #
                # This is where the actual
                # SPLITTING takes place
                #
                for i in range(variables.threshold):
                    # Accessing a subsequence
                    variables.nSubsequences += 1
                    # Decrease TS.maxCard to
                    # current Cardinality
                    <strong class="bold">tempCard =</strong>
                        <strong class="bold">tools.promote(temp.children[i],</strong>
                        <strong class="bold">n1Segs)</strong>
                    if tempCard == new1.word:
                        new1.insert(temp.children[i], ISAX)
                    elif tempCard == new2.word:
                        new2.insert(temp.children[i], ISAX)
                    else:
                        if variables.overflow == 0:
                            print("OVERFLOW:", tempCard)
                        variables.overflow =
                            variables.overflow + 1
                # Now insert the INITIAL TS node!
                # self is now an INNER node
                self.insert(ts, ISAX)
                <strong class="bold">if variables.defaultPromotion</strong>:
                    # Next time, promote the next segment
                    Variables.promote = (variables.promote
                        + 1) % variables.segments</pre>
<p>We know for sure<a id="_idIndexMarker248"/> that after we split the subsequences, which<a id="_idIndexMarker249"/> were previously stored in the terminal node that has become an inner node, we are not going to have an overflow. However, we still need to call <code>self.insert(ts, ISAX)</code> to insert the subsequence that created the overflow previously and see what is going to happen.</p>
<p>The last <code>if</code> checks whether we are using the default promotion strategy, which is the Round Robin strategy, and in that case, it changes the promotion segment to the next in order.</p>
<p>But how do we know whether there is an overflow situation? If after promoting a subsequence to a higher cardinality than its current one (<code>tempCard</code>) that subsequence cannot be assigned to any of the two newly created terminal nodes (<code>new1.word</code> or <code>new2.word</code>), we know that it has not been promoted. Therefore, we have an overflow condition. This is implemented in the <code>else:</code> branch of the <code>if tempCard == </code><code>new1.word:</code> block.</p>
<p>The fifth part of <code>Node.insert()</code> is next:</p>
<pre class="source-code">
            else:
                # TS is added if we have a Terminal node
                self.children[self.nTimeSeries()] = ts</pre>
<p>The code of the previous <code>else</code> is executed when we are dealing with a terminal node that is not full. So, we store the given subsequence in the <code>children</code> list – this is the ideal way to <a id="_idIndexMarker250"/>add<a id="_idIndexMarker251"/> a new subsequence to an iSAX index.</p>
<p>The sixth part of the <code>insert()</code> function is as follows:</p>
<pre class="source-code">
        else:
            # Otherwise, we are dealing with an INNER node
            # and we should add it to the
            # INNER node by trying
            # to find an existing terminal node
            # or create a new one
            # See whether it is going to be
            # included in the left
            # or the right child
            left = self.left
            right = self.right</pre>
<p>If we are working with an inner node, we have to decide whether the subsequence is going to go to the left or right child according to its SAX representation in order to finally find the terminal node that is going to store that subsequence. This is where the process begins.</p>
<p>The seventh part contains the following code:</p>
<pre class="source-code">
            leftSegs = left.word.split('_')
            # Promote
            tempCard = tools.promote(ts, leftSegs)</pre>
<p>In the previous code, we change (decrease) the maximum cardinality of the subsequence to fit the cardinality of the left node – we could have used the right node as both nodes use the same cardinality. The <code>tempCard</code> variable that holds that new cardinality is going to be used to decide the path that the subsequence is going to follow in the tree until it finds the appropriate terminal node.</p>
<p>The last <a id="_idIndexMarker252"/>part<a id="_idIndexMarker253"/> of <code>Node.insert()</code> is as follows:</p>
<pre class="source-code">
            if tempCard == left.word:
                left.insert(ts, ISAX)
            elif tempCard == right.word:
                right.insert(ts, ISAX)
            else:
                if variables.overflow == 0:
                    print("OVERFLOW:", tempCard, left.word,
                        right.word)
                variables.overflow = variables.overflow + 1
        return</pre>
<p>If <code>tempCard</code> does not match the SAX representation of the left or right node, then we know that <em class="italic">it has not been promoted</em>, which means that we have an overflow condition.</p>
<p>This is the logic behind the implementation of <code>Node.insert()</code> – there exist many comments in the code that you can read, and you can add your own <code>print()</code> statements to understand the flow even better.</p>
<p class="callout-heading">Why are we storing the maximum cardinality in its subsequence?</p>
<p class="callout">The reason for storing the maximum cardinality of this subsequence is that we can easily decrease that maximum cardinality without having to make difficult calculations such as computing a new SAX representation from scratch. This small optimization makes splitting operations much faster.</p>
<p>The other <a id="_idIndexMarker254"/>method <a id="_idIndexMarker255"/>of the <code>Node</code> class is called <code>nTimeSeries()</code> and has the following implementation:</p>
<pre class="source-code">
    def nTimeSeries(self):
        if self.terminalNode == False:
            print("Not a terminal node!")
            return
        n = 0
        for i in range(0, variables.threshold):
            if type(self.children[n]) == TS:
                n = n + 1
        return n</pre>
<p>The presented function returns the number of subsequences stored in a terminal node. First, <code>nTimeSeries()</code> makes sure that we are dealing with a terminal node before iterating over the contents of the <code>children</code> list. If the data type of the stored value is <code>TS</code>, then we have a subsequence.</p>
<p>After that, we are going to discuss and explain the <code>insert()</code> method of the <code>iSAX</code> class, which is presented in three parts. The <code>iSAX.insert()</code> method is the method that is being called when<a id="_idIndexMarker256"/> we want to add a subsequence to an iSAX index.</p>
<p>The first part of <code>iSAX.insert()</code> is as follows:</p>
<pre class="source-code">
    def insert(self, ts_node):
        # Array with number of segments
        # For cardinality 1
        segs = [1] * variables.segments
        # Get cardinality 1 from ts_node
        # in order to find its main subtree
        lower_cardinality = tools.lowerCardinality(segs,
            ts_node)
        lower_cardinality_str = ""
        for i in lower_cardinality:
            lower_cardinality_str = lower_cardinality_str +
                "_" + i
        # Remove _ at the beginning
        lower_cardinality_str = lower_cardinality_str[
            1:len(lower_cardinality_str)]</pre>
<p>This first part of the <a id="_idIndexMarker257"/>code finds the child of the root where <a id="_idIndexMarker258"/>the given subsequence is going to be placed. The <code>lower_cardinality_str</code> value is used as the key for finding the relevant child of the root node – the <code>tools.lowerCardinality()</code> function is explained in a bit.</p>
<p>The second part of <code>iSAX.insert()</code> contains the following code:</p>
<pre class="source-code">
        # Check whether the SAX word with CARDINALITY 1
        # exists in the Hash Table.
        # If not, create it and update Hash Table
        if self.ht.get(lower_cardinality_str) == None:
            n = Node(lower_cardinality_str)
            n.terminalNode = True
            # Add it to the hash table
            self.children[lower_cardinality_str] = n
            self.ht[lower_cardinality_str] = n
            n.insert(ts_node, self)</pre>
<p>If the child of the<a id="_idIndexMarker259"/> root with the <code>lower_cardinality_str</code> SAX representation cannot be found, we create the respective root child and add it to the <code>self.children</code> hash table (dictionary) and call <code>insert()</code> to put the given subsequence there.</p>
<p>The last part of <code>iSAX.insert()</code> is the following:</p>
<pre class="source-code">
        else:
            n = self.ht.get(lower_cardinality_str)
            n.insert(ts_node, self)
        return</pre>
<p>If the child of the root with the <code>lower_cardinality_str</code> SAX representation exists, then we try to insert that subsequence, thereby calling <code>insert()</code>.</p>
<p>At this point, we go from the <code>iSAX</code> class level to the <code>Node</code> class level.</p>
<p>But <code>isax.py</code> is not the only file with new code. The next section shows the additions and changes<a id="_idIndexMarker260"/> to<a id="_idIndexMarker261"/> the remaining package files that complete the implementation.</p>
<h1 id="_idParaDest-99"><a id="_idTextAnchor110"/>Exploring the remaining files</h1>
<p>Apart from the <code>isax.py</code> file, the <code>isax</code> Python package is constructed of more source code files, mainly because it is based on the <code>sax</code> package. We will begin with the <code>tools.py</code> file.</p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor111"/>The tools.py file</h2>
<p>There are some<a id="_idIndexMarker262"/> additions<a id="_idIndexMarker263"/> to the <code>tools.py</code> source code file compared to the version we first saw in <a href="B14769_02_MA.xhtml#_idTextAnchor053"><em class="italic">Chapter 2</em></a><em class="italic">, which</em> mainly have to do with the promotion strategy. As said before, we support two promotion strategies: Round Robin and from left to right.</p>
<p>The Round Robin strategy is implemented here:</p>
<pre class="source-code">
def round_robin_promotion(nSegs):
    # Check if there is a promotion overflow
    n = power_of_two(variables.maximumCardinality)
    t = 0
    while len(nSegs[variables.promote]) == n:
        # Go to the next SAX word and promote it
        Variables.promote = (variables.promote + 1) %
            variables.segments
        t += 1
        if t == variables.segments:
            if variables.overflow == 0:
                print("Non recoverable Promotion overflow!")
            return</pre>
<p>In the Round Robin case, we try to find the first segment on the right of the segment that was used in the previous promotion with fewer digits than the digits specified by the maximum cardinality (a segment that is not full). If the previous promotion took place in the last segment, then we go back to the first segment and begin from scratch. In order to compute the number of binary digits of the maximum cardinality (the length of the SAX word), we use the <code>power_of_two()</code> function, which returns <code>3</code> for a cardinality of <code>8</code>, <code>4</code> for a cardinality of <code>16</code>, and so on. If we iterate over all the segments of the given SAX representation (<code>nSegs</code>) and all have the maximum length, we know that we have an overflow condition.</p>
<p>The left-to-right <a id="_idIndexMarker264"/>strategy, which<a id="_idIndexMarker265"/> is also<a id="_idIndexMarker266"/> called <strong class="bold">shorter first</strong>, is implemented here:</p>
<pre class="source-code">
def shorter_first_promotion(nSegs):
    length = len(nSegs)
    pos = 0
    min = len(nSegs[pos])
    for i in range(1,length):
        if min &gt; len(nSegs[i]):
            min = len(nSegs[i])
            pos = i
    variables.promote = pos</pre>
<p>The left-to-right promotion strategy iterates over all the segments of the given SAX representation variable (<code>nSegs</code>) starting from the left and going to the right and finds the leftmost one with the minimum length. As a result, if both the second and third segments have the same minimum length, the strategy is going to select the second one because it is the leftmost available. After that, it sets <code>variables.promote</code> to the selected segment value.</p>
<p>Next, we are going to talk about two additional functions that reside in <code>tools.py</code>, which are called <code>promote()</code> and <code>lowerCardinality()</code>.</p>
<p>The <code>promote()</code> function is implemented as follows:</p>
<pre class="source-code">
def promote(node, segments):
    new_sax_word = ""
    max_array = node.maxCard.split("_")[
        0:variables.segments]
    # segments is an array
    #
    for i in range(variables.segments):
        t = len(segments[i])
        new_sax_word = new_sax_word + "_" +
            max_array[i][0:t]
    # Remove _ from the beginning of the new_sax_word
    new_sax_word = new_sax_word[1:len(new_sax_word)]
    return new_sax_word</pre>
<p>The <code>promote()</code> function<a id="_idIndexMarker267"/> copies <a id="_idIndexMarker268"/>the length of the digits of the segments of an existing SAX representation (<code>node</code>) to a given subsequence (<code>s</code>) in order for both to have the same cardinalities in all their SAX words. This <em class="italic">allows us to compare</em> these two SAX representations.</p>
<p>The implementation of <code>lowerCardinality()</code> is as follows:</p>
<pre class="source-code">
def lowerCardinality(segs, ts_node):
    # Get Maximum Cardinality
    max = ts_node.maxCard
    lowerCardinality = [""] * variables.segments
    # Because max is a string, we need to split.
    # The max string has an
    # underscore character at the end.
    max_array = max.split("_")[0:variables.segments]
    for i in range(variables.segments):
        t = segs[i]
        lowerCardinality[i] = max_array[i][0:t]
    return lowerCardinality</pre>
<p>The <code>lowerCardinality()</code> function lowers the cardinalities of a node <em class="italic">in all of its SAX words</em> (segments). This is mainly needed by <code>iSAX.insert()</code> to put a subsequence into the appropriate child of the root. After we put a subsequence into the appropriate child of the root, we promote a single segment of the SAX representation of the subsequence at a time to find out its place in the iSAX index. Remember that the keys to all iSAX <a id="_idIndexMarker269"/>nodes<a id="_idIndexMarker270"/> are SAX representations that usually have different cardinalities in their segments.</p>
<p class="callout-heading">How to test individual functions</p>
<p class="callout">Personally, I prefer to create small command line utilities to test complex functions on their own, understand their operation, and maybe discover bugs!</p>
<p>Let us make two small command-line utilities to showcase the use of <code>promote()</code> and <code>lowerCardinality()</code> in more detail.</p>
<p>First, we demonstrate the <code>promote()</code> function in the <code>usePromote.py</code> utility, which contains the following code:</p>
<pre class="source-code">
#!/usr/bin/env python3
from isax import variables
from isax import isax
import numpy as np
variablesPromote = 0
maximumCardinality = 8
segments = 4
def promote(node, s):
    global segments
    new_sax_word = ""
    max_array = node.maxCard.split("_")[0:segments]
    for i in range(segments):
        t = len(s[i])
        new_sax_word = new_sax_word + "_" +
            max_array[i][0:t]
    new_sax_word = new_sax_word[1:len(new_sax_word)]
    return new_sax_word</pre>
<p>It is important to<a id="_idIndexMarker271"/> remember <a id="_idIndexMarker272"/>that the <code>promote()</code> function mimics the lengths of the segments of an existing SAX representation by decreasing the maximum SAX representation of a subsequence (<code>s</code>) to match the given SAX representation stored in the <code>node</code> parameter.</p>
<p>The rest of <code>usePromote.py</code> is the following:</p>
<pre class="source-code">
def main():
    global variablesPromote
    global maximumCardinality
    global segments
    variables.maximumCardinality = maximumCardinality
    ts = np.array([1, 2, 3, 4])
    t = isax.TS(ts, segments)
    SAX_WORD = "0_0_1_1_"
    Segs = SAX_WORD.split('_')
    print("Max cardinality:", t.maxCard)
    SAX_WORD = "00_0_1_1_"
    Segs = SAX_WORD.split('_')
    print("<strong class="bold">P1</strong>:", promote(t, Segs))
    SAX_WORD = "000_0_1_1_"
    Segs = SAX_WORD.split('_')
    print("<strong class="bold">P2</strong>:", promote(t, Segs))
    SAX_WORD = "000_01_1_1_"
    Segs = SAX_WORD.split('_')
    print("<strong class="bold">P3</strong>:", promote(t, Segs))
    SAX_WORD = "000_011_1_100_"
    Segs = SAX_WORD.split('_')
    print("<strong class="bold">P4</strong>:", promote(t, Segs))
if __name__ == '__main__':
    main()</pre>
<p>Everything is hardcoded in <code>usePromote.py</code> because we just want to know more about the use of <code>promote()</code> and nothing else. However, as <code>promote()</code> has many dependencies in the <code>isax</code> package, we must put its entire implementation in our script and make the necessary changes to the Python code.</p>
<p>Given a subsequence, <code>ts</code>, and a <code>TS</code> class instance, <code>t</code>, we can calculate the SAX representation of <code>ts</code> using the maximum cardinality and then decrease it to match the cardinalities of other SAX words.</p>
<p>Running <code>usePromote.py</code> generates <a id="_idIndexMarker273"/>the<a id="_idIndexMarker274"/> following output:</p>
<pre class="source-code">
$ ./usePromote.py
Max cardinality: 000_010_101_111_
P1: 00_0_1_1
P2: 000_0_1_1
P3: 000_01_1_1
P4: 000_010_1_111</pre>
<p>The output shows that the maximum cardinality (<code>000_010_101_111</code>) of the given subsequence has been decreased to match the cardinalities of four other SAX words.</p>
<p>After that, we demonstrate the <code>lowerCardinality()</code> function in the <code>useLCard.py</code> utility, which comes with the following code:</p>
<pre class="source-code">
#!/usr/bin/env python3
from isax import variables
from isax import tools
from isax import isax
import numpy as np
def main():
    global maximumCardinality
    global segments
    # Used by isax.TS()
    variables.maximumCardinality = 8
    variables.segments = 4
    ts = np.array([1, 2, 3, 4])
    t = isax.TS(ts, variables.segments)
    Segs = [1] * variables.segments
    print(<strong class="bold">tools.lowerCardinality</strong>(Segs ,t))
    Segs = [2] * variables.segments
    print(<strong class="bold">tools.lowerCardinality</strong>(Segs ,t))
    Segs = [3] * variables.segments
    print(<strong class="bold">tools.lowerCardinality</strong>(Segs ,t))
if __name__ == '__main__':
    main()</pre>
<p>This time, we do <a id="_idIndexMarker275"/>not put<a id="_idIndexMarker276"/> the implementation of <code>lowerCardinality()</code> in our code because it has fewer dependencies and can be used directly from the <code>tools.py</code> file. The parameter that we pass to <code>lowerCardinality()</code> is <em class="italic">the number of digits</em> that we want to get in each SAX word. So, <code>1</code> means one digit, which means a cardinality of 2 1, and <code>3</code> means three digits, which computes to a cardinality of 2 3.</p>
<p>Once again, everything is hardcoded in <code>useLCard.py</code> because we just want to know more about the use of <code>lowerCardinality()</code> and nothing more. Running <code>useLCard.py</code> produces the following output:</p>
<pre class="source-code">
$ ./useLCard.py
['0', '0', '1', '1']
['00', '01', '10', '11']
['000', '010', '101', '111']</pre>
<p>So, given a subsequence with a SAX representation of <code>000_010_101_111</code>, we calculate its SAX representations for the cardinalities of <code>2</code>, <code>4</code>, and <code>8</code>.</p>
<p>Next, we are going to show the changes to <code>variables.py</code>, which is the file that holds global variables<a id="_idIndexMarker277"/> that<a id="_idIndexMarker278"/> can be accessed by all the files of the package or the utilities that use the <code>isax</code> package.</p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor112"/>The variables.py file</h2>
<p>This <a id="_idIndexMarker279"/>subsection <a id="_idIndexMarker280"/>presents the contents of the updated <code>variables.py</code> file, which contains variables that are accessible from anywhere in the code.</p>
<p class="callout-heading">How much functionality is enough?</p>
<p class="callout">Keep in mind that sometimes we might need to include functionality that is going to help with debugging or might be needed in the future, and therefore, we might need to include variables or implement functions that are not going to be used right away or all the time. Just remember to keep a good balance between wanting to support everything and please everyone, which is impossible, and wanting to support the absolute minimum functionality, which usually lacks flexibility.</p>
<p>The contents of the <code>variables.py</code> file are the following:</p>
<pre class="source-code">
# This file includes all variables for the isax package
#
maximumCardinality = 32
breakpointsFile = "SAXalphabet"
# Breakpoints in breakpointsFile
elements = ""
slidingWindowSize = 16
segments = 0
# Maximum number of time series in a terminal node
threshold = 100
# Keeps number of splits
nSplits = 0
# Keep number of accesses of subsequences
nSubsequences = 0
# Currently supporting TWO promotion strategies
defaultPromotion = True
# Number of overflows
overflow = 0
# Floating point precision
precision = 5
# Segment to promote
<strong class="bold">promote</strong> = 0</pre>
<p>The <code>variables.promote</code> variable defines the SAX word that is going to be promoted next if there is such a need. Put simply, we create the SAX representation of the two nodes of a split based on the value of <code>variables.promote</code> – we promote the segment defined by the value of <code>variables.promote</code>. Every time we have a split, <code>variables.promote</code> is updated according to the promotion (splitting) strategy and gets ready for the next split.</p>
<p>Should you wish to see the changes between two versions of the same file, you can use the <code>diff(1)</code> utility. In our case, the difference between the <code>variables.py</code> file found in the <code>ch03</code> directory <a id="_idIndexMarker281"/>and<a id="_idIndexMarker282"/> the current version is the following:</p>
<pre class="source-code">
2c2
&lt; # This file includes all variables for the sax package
---
&gt; # This file includes all variables for the isax package
13a14,16
&gt; # Breakpoints in breakpointsFile
&gt; elements = ""
&gt;
20,21c23,24
&lt; # Breakpoints in breakpointsFile
&lt; elements = ""
---
&gt; # Maximum number of time series in a terminal node
&gt; threshold = 100
22a26,37
&gt; # Keeps number of splits
&gt; nSplits = 0
&gt;
&gt; # Keeps number of accesses of subsequences
&gt; nSubsequences = 0
&gt;
&gt; # Currently supporting TWO promotion strategies
&gt; defaultPromotion = True
&gt;
&gt; # Number of overflows
&gt; overflow = 0
&gt;
24a40,42
&gt;
&gt; # Segment to promote
&gt; promote = 0</pre>
<p>Lines beginning with <code>&gt;</code> show the contents of <code>ch04/isax/variables.py</code>, whereas lines beginning <a id="_idIndexMarker283"/>with <code>&lt;</code> show<a id="_idIndexMarker284"/> statements from <code>ch03/sax/variables.py</code>.</p>
<p>The next subsection discusses <code>sax.py</code>, which did not change that much.</p>
<h2 id="_idParaDest-102"><a id="_idTextAnchor113"/>The sax.py file</h2>
<p>The <code>sax.py</code> file does<a id="_idIndexMarker285"/> have<a id="_idIndexMarker286"/> any practical changes. However, we should make changes to its <code>import</code> statements as it is no longer an autonomous package but a part of another package with a different name. Therefore, we need to change the following two statements:</p>
<pre class="source-code">
from sax import sax
from sax import variables</pre>
<p>We replace them with these statements:</p>
<pre class="source-code">
from isax import sax
from isax import variables</pre>
<p>Apart from that, there is no need for additional changes.</p>
<p>Now that we know the source code of the <code>isax</code> package, it is time to see that code in action.</p>
<h1 id="_idParaDest-103"><a id="_idTextAnchor114"/>Using the iSAX Python package</h1>
<p>In this section, we are<a id="_idIndexMarker287"/> going to use the <code>isax</code> Python package to develop practical command-line utilities. But first, we are going to learn how to read the iSAX parameters from the users.</p>
<h2 id="_idParaDest-104"><a id="_idTextAnchor115"/>Reading the iSAX parameters</h2>
<p>This subsection <a id="_idIndexMarker288"/>illustrates how to read the iSAX parameters, including the filenames with the time series, and how to give default values to some of them. Although we saw relevant code in <a href="B14769_02_MA.xhtml#_idTextAnchor053"><em class="italic">Chapter 2</em></a>, this time, the process is explained in more detail. Additionally, the code is also going to show how we use these input parameters to set up the relevant variables located inside the <code>./isax/variables.py</code> file. As a reminder, variables stored in <code>./isax/variables.py</code>, or other similar files – it just happens that we are using <code>./isax/variables.py</code> – are accessible from anywhere in our code as long as we have successfully imported the relevant file.</p>
<p class="callout-heading">What we need to create an iSAX index</p>
<p class="callout">As a reminder, to <a id="_idIndexMarker289"/>create an iSAX index, we need a time series and a threshold value, which is the maximum number of subsequences that a terminal node can hold, as well as a segment value and a cardinality value. Last, we need a sliding window size.</p>
<p>As a rule of thumb, when working with global variables, it is better to use long and descriptive names. Additionally, it is also a good practice to give default values to global parameters.</p>
<p>The Python code of <code>parameters.py</code> is shown here:</p>
<pre class="source-code">
#!/usr/bin/env python3
import argparse
from isax import variables
def main():
    parser = argparse.ArgumentParser()
    parser.<strong class="bold">add_argument</strong>("-s", "--segments",
        dest = "segments", default = "4",
        help="Number of Segments", <strong class="bold">type=int</strong>)
    parser.<strong class="bold">add_argument</strong>("-c", "--cardinality",
        dest = "cardinality", default = "32",
        help="Cardinality", <strong class="bold">type=int</strong>)
    parser.<strong class="bold">add_argument</strong>("-w", "--window", dest = "window",
        default = "16", help="Sliding Window Size",
        <strong class="bold">type=int</strong>)
    parser.<strong class="bold">add_argument</strong>("TS1")
    args = parser.parse_args()
    <strong class="bold">variables.segments</strong> = <strong class="bold">args.segments</strong>
    <strong class="bold">variables.maximumCardinality</strong> = args.cardinality
    <strong class="bold">variables.slidingWindowSize</strong> = args.window
    windowSize = <strong class="bold">variables.slidingWindowSize</strong>
    maxCardinality = <strong class="bold">variables.maximumCardinality</strong>
    f1 = args.TS1
    print("Time Series:", f1, "Window Size:", windowSize)
    print("Maximum Cardinality:", maxCardinality,
        "Segments:", variables.segments)
if __name__ == '__main__':
    main()</pre>
<p>All the work is done by the <code>argparse</code> package and the <code>parser.add_argument()</code> statements that are used for defining command-line parameters and options. The <code>dest</code> parameter defines the name of the parameter – this name is going to be used later to read the value of the parameter.</p>
<p>One of the other parameters of <code>parser.add_argument()</code> is called <code>type</code> and allows us to define the data type of the parameter. This can save you from lots of issues and code for <a id="_idIndexMarker290"/>converting strings into actual values, so use <code>type</code> when possible.</p>
<p>After that, we call <code>parser.parse_args()</code> and we are ready to read any <code>rgparse</code> parameter we want.</p>
<p>Running <code>parameters.py</code> produces the following output:</p>
<pre class="source-code">
$ ./parameters.py -s 2 -c 32 -w 16 ts1.gz
Time Series: ts1.gz Window Size: 16
Maximum Cardinality: 32 Segments: 2</pre>
<p>In case of an error, <code>parameters.py</code> generates the following output:</p>
<pre class="source-code">
$ ./parameters.py -s 1 -c cardinality ts1.gz
usage: parameters.py [-h] [-s SEGMENTS] [-c CARDINALITY] [-w WINDOW] TS1
parameters.py: error: argument -c/--cardinality: invalid int value: 'cardinality'</pre>
<p>In this case, the error is that the <code>cardinality</code> parameter is a string, whereas we are expecting an integer. The error output is very informative.</p>
<p>If a required parameter is missing, <code>parameters.py</code> generates the following output:</p>
<pre class="source-code">
$ ./parameters.py
usage: parameters.py [-h] [-s SEGMENTS] [-c CARDINALITY] [-w WINDOW] TS1
parameters.py: error: the following arguments are required: TS1</pre>
<p>The next section<a id="_idIndexMarker291"/> shows how we process the subsequences of a time series in order to create an iSAX index.</p>
<h2 id="_idParaDest-105"><a id="_idTextAnchor116"/>How to process subsequences to create an iSAX index</h2>
<p>This is a really <a id="_idIndexMarker292"/>important subsection because here, we explain the Python structure that is used to store the data for each subsequence of an iSAX index.</p>
<p class="callout-heading">The code does not lie!</p>
<p class="callout">If you have doubts about the fields and the data stored in each subsequence, check out the Python code to learn more. The documentation might lie but the code never does.</p>
<p>The <code>subsequences.py</code> script shows how we create the subsequences, how we store them in a Python data structure, and how we might process them:</p>
<pre class="source-code">
#!/usr/bin/env python3
import argparse
import numpy as np
import pandas as pd
from isax import sax
from isax import variables
class TS:
    def __init__(self, ts, index):
        self.ts = ts
        self.sax = sax.createPAA(ts,
            variables.maximumCardinality,
            variables.segments)
        self.index = index
def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("-w", "--window", dest = "window",
        default = "16", help="Sliding Window Size",
        type=int)
    parser.add_argument("-s", "--segments",
        dest = "segments", default = "4",
        help="Number of Segments", type=int)
    parser.add_argument("-c", "--cardinality",
        dest = "cardinality", default = "32",
        help="Cardinality", type=int)
    parser.add_argument("TS")
    args = parser.parse_args()
    windowSize = args.window
    variables.segments = args.segments
    variables.maximumCardinality = args.cardinality
    file = args.TS</pre>
<p>We define the <code>TS</code> class <a id="_idIndexMarker293"/>again and use that version in <code>subsequences.py</code> in order to be able to make more changes to the <code>TS</code> class without the danger of altering the code of the <code>isax</code> package. Before now, we have read the parameters of the program and we are ready to read the time series:</p>
<pre class="source-code">
    ts = pd.read_csv(file, names=['values'],
        compression='gzip', header = None)
    ts_numpy = ts.to_numpy()
    length = len(ts_numpy)</pre>
<p>Currently, we have the time series stored as a NumPy array using the <code>ts_numpy</code> variable:</p>
<pre class="source-code">
    # Split sequence into subsequences
    n = 0
    for i in range(<strong class="bold">length - windowSize + 1</strong>):
        # Get the actual subsequence
        ts = ts_numpy[i:i+windowSize]
        # Create new TS node based on ts
        ts_node = TS(<strong class="bold">sax.normalize(ts)</strong>, i)
        n = n + n</pre>
<p>The <code>for</code> loop splits the<a id="_idIndexMarker294"/> time series into subsequences based on the sliding window size. The normalized version of each subsequence is stored in a <code>TS()</code> structure that has three members: the normalized version of the subsequence (<code>ts</code>), the SAX representation of the subsequence (<code>sax</code>), and the place of the subsequence in the time series (<code>index</code>). The last member of the <code>TS()</code> structure allows us to find the original version of the subsequence, should we want to do so.</p>
<p>Now, check the following code:</p>
<pre class="source-code">
    print("Created", n, "TS() nodes")
if __name__ == '__main__':
    main()</pre>
<p>After we finish, the script prints the number of subsequences that have been processed.</p>
<p>Only after we have stored the SAX representation of a subsequence in its Python structure based on the maximum cardinality are we ready to put that subsequence into the iSAX index. So, the next step, which is not presented here, is putting each <code>TS()</code> node into an iSAX index.</p>
<p>The output of <code>subsequences.py</code> gives you information about the number of subsequences that have been processed:</p>
<pre class="source-code">
$ ./subsequences.py ts1.gz
Created 35 TS() nodes</pre>
<p>In summary, this<a id="_idIndexMarker295"/> is the way we are going to process subsequences in order to add them to an iSAX index. In the next subsection, we are going to create our first iSAX index!</p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor117"/>Creating our first iSAX index</h2>
<p>In this section, we<a id="_idIndexMarker296"/> are going to create an iSAX index for the first time. But first, we are going to present the Python utility for doing that. The Python code of <code>createiSAX.py</code> is presented in four parts. The first part is the following:</p>
<pre class="source-code">
#!/usr/bin/env python3
from isax import variables
from isax import isax
from isax import tools
from isax import sax
import sys
import pandas as pd
import numpy as np
import time
import argparse
def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("-s", "--segments",
        dest = "segments", default = "16",
        help="Number of Segments", type=int)
    parser.add_argument("-c", "--cardinality",
        dest = "cardinality", default = "16",
        help="Cardinality", type=int)
    parser.add_argument("-w", "--windows", dest = "window",
        default = "16", help="Sliding Window Size",
        type=int)
    parser.add_argument("-t", "--threshold",
        dest = "threshold", default = "1000",
        help="Threshold for split", type=int)
    parser.add_argument("-p", "--promotion",
        action='store_true',
        help="Define Promotion Strategy")
    parser.add_argument("TSfile")
    args = parser.parse_args()</pre>
<p>This first part is <a id="_idIndexMarker297"/>about the <code>import</code> statements and reading the required parameters using <code>argparse</code>.</p>
<p>The second part of <code>createiSAX.py</code> is the following:</p>
<pre class="source-code">
    variables.segments = args.segments
    variables.maximumCardinality = args.cardinality
    variables.slidingWindowSize = args.window
    variables.threshold = args.threshold
    variables.defaultPromotion = args.promotion
    file = args.TSfile
    maxCardinality = variables.maximumCardinality
    segments = variables.segments
    windowSize = variables.slidingWindowSize
    if tools.power_of_two(maxCardinality) == -1:
        print("Not a power of 2:", maxCardinality)
        sys.exit()
    if variables.segments &gt; variables.slidingWindowSize:
        print("Segments:", variables.segments,
            "Sliding window:", variables.slidingWindowSize)
        print("Sliding window size should be bigger than #
            of segments.")
        sys.exit()
    print("Max Cardinality:", maxCardinality, "Segments:",
        variables.segments,
        "Sliding Window:", variables.slidingWindowSize,
        "Threshold:", variables.threshold,
        "Default Promotion:", variables.defaultPromotion)</pre>
<p>In this part of <code>createiSAX.py</code>, we assign the parameters to the relevant local and global variables and make some tests to make sure that the parameters make sense. The reason for using local variables is to have smaller variable names to work with. The <code>print()</code> statement outputs the parameters on the screen.</p>
<p>The third part of <code>createiSAX.py</code> contains the following code:</p>
<pre class="source-code">
    ts = pd.read_csv(file, names=['values'],
        compression='gzip')
    ts_numpy = ts.to_numpy()
    length = len(ts_numpy)
    #
    # Initialize iSAX index
    #
    ISAX = isax.iSAX()</pre>
<p>In this part, we read <a id="_idIndexMarker298"/>the compressed time series file and create the NumPy variable that holds the entire time series. After that, we initialize a variable to hold the iSAX index. As the name of the class is <code>iSAX</code>, the relevant variable is initialized as an instance of the <code>isax.iSAX()</code> class.</p>
<p>The last part of <code>createiSAX.py</code> contains the following code:</p>
<pre class="source-code">
    # Split sequence into subsequences
    for i in range(length - windowSize + 1):
        # Get the subsequence
        ts = ts_numpy[i:i+windowSize]
        # Create new TS node based on ts
        ts_node = isax.TS(ts, segments)
        ISAX.insert(ts_node)
if __name__ == '__main__':
    main()</pre>
<p>This last part splits the time series according to the sliding window size, creates the <code>TS()</code> objects, and inserts them into the iSAX index using the <code>insert()</code> method of the <code>iSAX</code> class using the <code>ISAX</code> variable – remember that it is <code>iSAX.insert()</code> that calls <code>Node.insert()</code>.</p>
<p>Running <code>createiSAX.py</code> produces the following output:</p>
<pre class="source-code">
$ ./createiSAX.py ts1.gz
Max Cardinality: 16 Segments: 16 Sliding Window: 16 Threshold: 1000 Default Promotion: False
$ ./createiSAX.py
usage: createiSAX.py [-h] [-s SEGMENTS] [-c CARDINALITY] [-w WINDOW] [-t THRESHOLD] [-p] TSfile
createiSAX.py: error: the following arguments are required: TSfile</pre>
<p>The good thing is that <code>createiSAX.py</code> has default values for all iSAX parameters. However, providing <a id="_idIndexMarker299"/>the path for the file that holds the time series is required.</p>
<p>In the next subsection, we are going to develop a command-line utility that counts the total number of subsequences in an iSAX index.</p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor118"/>Counting the subsequences of an iSAX index</h2>
<p>This is a really <a id="_idIndexMarker300"/>handy utility that not only shows <em class="italic">how to traverse an entire iSAX index</em> but also allows you to count all the subsequences of an iSAX index and make sure that you have not missed any subsequences in the process, which can be used for testing purposes.</p>
<p>The code of <code>countSub.py</code> that does the counting is the following – the rest of the implementation is the same as in <code>createiSAX.py</code>:</p>
<pre class="source-code">
    # Visit all entries in Dictionary
    # Count TS in Terminal Nodes
    sum = 0
    for k in <strong class="bold">ISAX.ht</strong>:
        t = ISAX.ht[k]
        if t.terminalNode:
            sum += t.nTimeSeries()
    print(length - windowSize + 1, sum)</pre>
<p>The code visits the <code>ISAX.ht</code> field of an iSAX class because this is where <em class="italic">all the nodes </em>of the iSAX index are kept. If we are working with a terminal node, then we call the <code>nTimeSeries()</code> method to find the number of subsequences that are stored in that terminal node. We do that for all the terminal nodes, and we are done. The last statement prints both the theoretical number of subsequences as well as the actual number of subsequences found in the iSAX index. As long as these two values are the same, we are good.</p>
<p>Running <code>countSub.py</code> on a small time series, which you can find in the <code>ch04</code> directory, generates<a id="_idIndexMarker301"/> the following kind of output:</p>
<pre class="source-code">
$ ./countSub.py ts1.gz
Max Cardinality: 16 Segments: 16 Sliding Window: 16 Threshold: 1000 Default Promotion: False
35 35</pre>
<p>The subsection that follows shows the time it takes to construct an iSAX index.</p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor119"/>How long does it take to create an iSAX index?</h2>
<p>In this subsection, we<a id="_idIndexMarker302"/> are going to compute the time it takes a computer to create an iSAX index. The main reason for any delays in the construction phase of iSAX is the splitting of nodes and the rearrangement of the subsequences. The more extensive splitting we have, the more time it takes to generate the index.</p>
<p>The code of <code>howMuchTime.py</code> that computes the time it takes to create the iSAX index is the following – the rest of the implementation is the same as in <code>createiSAX.py</code>:</p>
<pre class="source-code">
    start_time = time.time()
    print("--- %.5f seconds ---" % (time.time() –
        start_time))</pre>
<p>The first statement is located right before we begin reading the time series file using <code>pd.read_csv()</code> and the second statement is right after we finish splitting and inserting the time series into the iSAX index.</p>
<p>The output of <code>howMuchTime.py</code> when processing <code>ts1.gz</code> is similar to the following:</p>
<pre class="source-code">
$ ./howMuchTime.py -w 2 -s 2 ts1.gz
Max Cardinality: 16 Segments: 2 Sliding Window: 2 Threshold: 1000 Default Promotion: False
--- 0.00833 seconds ---</pre>
<p>As <code>ts1.gz</code> is a small time series with 50 elements, the output is not that interesting. Therefore, let us try using <code>howMuchTime.py</code> on bigger time series.</p>
<p>The next output shows the time it took <code>howMuchTime.py</code> to create an iSAX index for a time series with 500,000 elements on a macOS machine with 32 GB of RAM and an Apple M1 Max CPU – you can create a time series with the same length on your own and try the same command <a id="_idIndexMarker303"/>or use the provided file, which is called <code>500k.gz</code>:</p>
<pre class="source-code">
$ ./howMuchTime.py 500k.gz
Max Cardinality: 16 Segments: 16 Sliding Window: 16 Threshold: 1000 Default Promotion: False
--- 114.80277 seconds ---</pre>
<p>The <code>500k.gz</code> file was created using the following commands:</p>
<pre class="source-code">
$ ./ch01/synthetic_data.py 500000 -1 1 &gt; 500k
$ gzip 500k</pre>
<p>The following output shows the time it took <code>howMuchTime.py</code> to create an iSAX index for a time series with 2,000,000 elements on a macOS machine with 32 GB of RAM and an Apple M1 Max CPU – you can create a time series with the same or a bigger length on your own and try the same command or use the provided file, which is called <code>2M.gz</code>:</p>
<pre class="source-code">
$ ./howMuchTime.py 2M.gz
Max Cardinality: 16 Segments: 16 Sliding Window: 16 Threshold: 1000 Default Promotion: False
--- 450.37358 seconds ---</pre>
<p>The <code>2M.gz</code> file was created using the following commands:</p>
<pre class="source-code">
$ ./ch01/synthetic_data.py 2000000 -10 10 &gt; 2M
$ gzip 2M</pre>
<p>One interesting conclusion that we can make is that for a time series that is four times bigger, it took our program about four times longer to build. However, this is not always the case.</p>
<p>Additionally, the time it took to create an iSAX index does not tell the whole story, especially when testing on a busy machine or a slow machine with a little amount of RAM. What is more important is the number of node splits as well as the number of accesses to subsequences that were made. The minimum number of accesses to subsequences is equal to the subsequences of the time series. However, when splits take place, we must revisit the involved subsequences in order to distribute them according to the newly created SAX representations and terminal nodes. The splits and the revisiting of<a id="_idIndexMarker304"/> subsequences increase the construction time of the iSAX.</p>
<p>Therefore, we are going to create a modified version of <code>howMuchTime.py</code> that also prints the number of node splits, as well as the total number of subsequence accesses. The name of the new utility is <code>accessSplit.py</code>. The statements that do the counting of the splits and the subsequence accessing are already present in <code>isax/isax.py</code> and we just need to access two global variables, which are <code>variables.nSplits</code> and <code>variables.nSubsequences</code>, to get the results.</p>
<p>Running <code>accessSplit.py</code> with the default parameters on <code>500k.gz</code> produces the following kind of output:</p>
<pre class="source-code">
$ ./accessSplit.py 500k.gz
Max Cardinality: 16 Segments: 16 Sliding Window: 16 Threshold: 1000 Default Promotion: False
Number of splits: 0
Number of subsequence accesses: 499985</pre>
<p>What does this output tell us? It tells us that there was no split! In practice, this means that the root node of that particular iSAX index has terminal nodes only as children. Is this good or bad? In general, this means that <em class="italic">the index works like a hash table</em> where the hash function is the function for calculating the SAX representation. Most of the time, this is not the desirable form that we want an index to have because we could have used a hash table in the first place!</p>
<p>If we run <code>accessSplit.py</code> on the same time series using different parameters, we are going to get a totally different output regarding the construction of the iSAX index:</p>
<pre class="source-code">
$ ./accessSplit.py -w 1024 -s 8 -c 32 500k.gz
Max Cardinality: 32 Segments: 8 Sliding Window: 1024 Threshold: 1000 Default Promotion: False
Number of splits: 4733
Number of subsequence accesses: 16370018</pre>
<p>What does this output tell us? It tells us that even on a relatively small time series, the iSAX parameters play a huge role in the creation time of the iSAX index. However, the number of<a id="_idIndexMarker305"/> subsequence accesses is around 33 times the total number of subsequences of the time series, which is pretty big and therefore not very efficient.</p>
<p>Let us now try <code>accessSplit.py</code> on a bigger time series, which is <code>2M.gz</code>, and see what happens:</p>
<pre class="source-code">
$ ./accessSplit.py 2M.gz
Max Cardinality: 16 Segments: 16 Sliding Window: 16 Threshold: 1000 Default Promotion: False
Number of splits: 0
Number of subsequence accesses: 1999985</pre>
<p>As before, we are using the iSAX index as a hash table, which is not the desired behavior. Let us try using different parameters instead:</p>
<pre class="source-code">
$ ./accessSplit.py -s 8 -c 32 2M.gz
Max Cardinality: 32 Segments: 8 Sliding Window: 16 Threshold: 1000 Default Promotion: False
Number of splits: 3039
Number of subsequence accesses: 13694075</pre>
<p>This time, the number of accesses to subsequences is around seven times the length of the time series, which is more realistic than when we were working with the <code>500k.gz</code> file.</p>
<p>We are going to <a id="_idIndexMarker306"/>work with <code>accessSplit.py</code> again in <a href="B14769_05.xhtml#_idTextAnchor124"><em class="italic">Chapter 5</em></a>. But for now, we are going to learn more about the overflow of iSAX indexes.</p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor120"/>Dealing with iSAX overflows</h2>
<p>In this subsection, we <a id="_idIndexMarker307"/>are going to experiment with an overflow situation. Keep in mind that a dedicated global parameter exists in <code>variables.py</code> that holds the number of subsequences that were ignored due to overflow. Among other things, this helps you fix the iSAX parameters faster as you know how bad the overflow is. Usually, the easiest way to fix an overflow is by increasing the threshold value, but this might have serious implications when searching an iSAX index or comparing an iSAX index with another one.</p>
<p>The Python code of <code>overflow.py</code> has only one change compared to <code>createiSAX.py</code>, which is the following statement because the SAX representation that created the overflow is printed by default:</p>
<pre class="source-code">
print("Number of overflows:", variables.overflow)</pre>
<p>This mainly happens because the functionality is built into the <code>isax</code> package, which automatically prints a message when the first overflow takes place, and we just have to access the <code>variables.overflow</code> variable to find out the total number of overflows.</p>
<p>The output of <code>overflow.py</code> when working with the <code>500k.gz</code> time series includes the following information:</p>
<pre class="source-code">
$ ./overflow.py -w 1024 -s 8 500k.gz
Max Cardinality: 16 Segments: 8 Sliding Window: 1024 Threshold: 1000 Default Promotion: False
OVERFLOW: 1000_0111_0111_1000_1000_0111_0111_1000
Number of overflows: 303084</pre>
<p>The previous output tells us that the first SAX representation that caused an overflow was <code>1000_0111_0111_1000_1000_0111_0111_1000</code> and that we had <code>303084</code> overflows in total – we might have more SAX representations that cause an overflow, but we have decided to print just the first one. This means that <code>303084</code> subsequences were not inserted into the iSAX index, which is a very large number compared to the length of the time series.</p>
<p>Let us now try the same command using the other promotion strategy and see what happens:</p>
<pre class="source-code">
$ ./overflow.py -w 1024 -s 8 500k.gz -p
Max Cardinality: 16 Segments: 8 Sliding Window: 1024 Threshold: 1000 Default Promotion: True
Non recoverable Promotion overflow!
OVERFLOW: 1000_0111_0111_1000_1000_0111_0111_1000
Number of overflows: 303084</pre>
<p>It turns out that we got the same kind of overflow and the exact same number of total overflows. This makes perfect sense as the overflow situation does not have to do with the promotion<a id="_idIndexMarker308"/> strategy but with the SAX representations. <em class="italic">A different promotion strategy might change the shape of an iSAX index a little, but it has nothing to do with the </em><em class="italic">overflow situation.</em></p>
<p>As <code>303084</code> is a big number, we might need to drastically increase the capacity of the iSAX index but without creating an unnecessarily big iSAX index. So, with that in mind, we can try to resolve the overflow situation by changing the parameters of the iSAX index. Let us try to do so then by increasing the threshold value:</p>
<pre class="source-code">
$ ./overflow.py -w 1024 -s 8 -c 16 -t 1500 500k.gz
Max Cardinality: 16 Segments: 8 Sliding Window: 1024 Threshold: 1500 Default Promotion: False
OVERFLOW: 0111_1000_1000_1000_1000_0111_0111_0111
Number of overflows: 176454</pre>
<p>So, it looks like we cut the number of overflows in half, which is a good thing for a start. However, although we are using the same cardinality as before, it is a different SAX representation (<code>0111_1000_1000_1000_1000_0111_0111_0111</code>) that caused the first overflow this time, which means that the increased threshold value solved the overflow condition that took place earlier with the <code>1000_0111_0111_1000_1000_0111_0111_1000</code> SAX representation.</p>
<p>Let us give it another try by increasing the <code>cardinality</code> value and at the same time decreasing the threshold value:</p>
<pre class="source-code">
$ ./overflow.py -w 1024 -s 8 -c 32 -t 500 500k.gz
Max Cardinality: 32 Segments: 8 Sliding Window: 1024 Threshold: 500 Default Promotion: False
Number of overflows: 0</pre>
<p>So, we finally found a triplet of parameters that works for the <code>1024</code> sliding window size and the <code>500k.gz</code> dataset.</p>
<p>Is there a recipe for finding out which parameters work and which do not work? No, as it mainly depends on the values of the dataset and the sliding window size. The more you work and experiment with iSAX indexes, the more you are going to understand which parameters work<a id="_idIndexMarker309"/> best for a given dataset and sliding window size.</p>
<p>So, in this last section, we learned about iSAX overflows and presented a technique for solving such situations.</p>
<h1 id="_idParaDest-110"><a id="_idTextAnchor121"/>Summary</h1>
<p>In this chapter, we saw and went through the implementation details of the <code>isax</code> Python package, which allows us to create iSAX indexes. Please make sure that you understand the code and most importantly know how to use the code.</p>
<p>Additionally, we implemented many command-line utilities that allow us to create iSAX indexes and understand what happens behind the scenes regarding the splits and subsequence accesses as well as the overflow conditions. Having a better understanding of the structure of an iSAX index allows us to select better indexes and avoid using poor ones.</p>
<p>The next chapter is going to put iSAX indexes into practice by showing how to search and join iSAX indexes.</p>
<h1 id="_idParaDest-111"><a id="_idTextAnchor122"/>Useful links</h1>
<ul>
<li>The <code>argparse</code> package: <a href="https://docs.python.org/3/library/argparse.xhtml">https://docs.python.org/3/library/argparse.xhtml</a></li>
<li>The NumPy Python package: <a href="https://numpy.org/">https://numpy.org/</a></li>
</ul>
<h1 id="_idParaDest-112"><a id="_idTextAnchor123"/>Exercises</h1>
<p>Try to work through the following exercises:</p>
<ul>
<li>Create a synthetic dataset with 100,000 elements with values from <em class="italic">-10 to 10</em> and construct an iSAX index with 4 segments, a cardinality of 64, and a threshold value of <code>1000</code>. How much time did it take your machine to create the iSAX index? Are there any overflows?</li>
<li>Create a synthetic dataset with 100,000 elements with values from <em class="italic">-1 to 1</em> and construct an iSAX index with 4 segments, a cardinality of 64, and a threshold value of <code>1000</code>. How much time did it take your machine to create that iSAX index?</li>
<li>Create a synthetic dataset with 500,000 elements with values from <em class="italic">0 to 10</em> and construct an iSAX index with 4 segments, a cardinality of 64, and a threshold value of <code>1000</code>. How much time did it take your machine to create the iSAX index?</li>
<li>Create a synthetic dataset with 500,000 elements with values from <em class="italic">0 to 10</em> and construct an iSAX index with 4 segments, a cardinality of 64, and a threshold value of <code>1000</code>. How many splits and accesses to subsequences took place? What happens if you increase the threshold value to <code>1500</code>?</li>
<li>Create a synthetic dataset with 150,000 elements with values from <em class="italic">-1 to 1</em> and construct an iSAX index with 4 segments, a cardinality of 64, and a threshold value of <code>1000</code>. Are there any overflows? How many splits were performed for the construction of the iSAX index?</li>
<li>Experiment with <code>accessSplit.py</code> on <code>2M.gz</code> using various iSAX parameters. Which parameters seem to work best? Do not forget that high threshold values have a great impact on searching; so, in general, do not use huge threshold values to lower the number of splits.</li>
<li>Experiment with <code>accessSplit.py</code> on <code>500k.gz</code> using various iSAX parameters. Which parameters seem to work best?</li>
</ul>
</div>
</div></body></html>