<html><head></head><body><div class="chapter" title="Chapter&#xA0;11.&#xA0;Using Force"><div class="titlepage"><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Using Force</h1></div></div></div><p>In this chapter we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using gravity and charge</li><li class="listitem" style="list-style-type: disc">Generating momentum</li><li class="listitem" style="list-style-type: disc">Setting the link constraint</li><li class="listitem" style="list-style-type: disc">Using force to assist visualization</li><li class="listitem" style="list-style-type: disc">Manipulating force</li><li class="listitem" style="list-style-type: disc">Building a force-directed graph</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec76"/>Introduction</h1></div></div></div><div class="blockquote"><blockquote class="blockquote"><p>Use the force, Luke!</p><p>A master's words of wisdom to his apprentice</p></blockquote></div><p>In this chapter we are going to cover one of the most fascinating aspects of D3: <a id="id600" class="indexterm"/>force. Force simulation<a id="id601" class="indexterm"/> is one of the most awe-inspiring techniques that you can add to your visualization. Through a number of highly interactive and fully-functional examples, we will help you explore not only the typical application of D3 force (for example, the force-directed graph), but also other essential aspects of force manipulation.</p><p>D3 force simulation support was created not as a separate capability, but rather as an additional D3 layout. As we have mentioned in <a class="link" href="ch09.html" title="Chapter 9. Lay Them Out">Chapter 9</a>, <span class="emphasis"><em>Lay Them Out</em></span>, D3 layouts are non-visual data oriented layout management programs designed to be used with different visualization. Force layout <a id="id602" class="indexterm"/>was originally created for the purpose of implementing a specific visualization type called <a id="id603" class="indexterm"/>
<span class="strong"><strong>force-directed graph</strong></span>. Its implementation uses standard <span class="strong"><strong>verlet integration</strong></span>
<a id="id604" class="indexterm"/> based particle motion simulation with support for simple constraints. </p><p>In other words, D3 implements a numeric method that is capable of loosely simulating Newton's equation of motion on particle level and with simple constraints simulated as links between particles. This kind of layout, of course, was ideal in implementing a force-directed graph; however, we will also discover through recipes in this chapter that force layout is capable of generating many other interesting visualization effects due to its flexibility in custom force manipulation. The application of the techniques introduced in this chapter go even beyond the data visualization realm and has practical applications in many other domains, for example, user interface design. Of course, we will also cover the classical application of force layout: the force-directed graph in this chapter.</p></div></div>
<div class="section" title="Using gravity and charge"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec77"/>Using gravity and charge</h1></div></div></div><p>In this recipe we will introduce you to the first two fundamental forces: gravity<a id="id605" class="indexterm"/> and <a id="id606" class="indexterm"/>charge. As we have mentioned before, one objective of force layout's design is to loosely simulate Newton's equation of motion with particles, and one major feature of this simulation is the force of charge. Additionally, force layout also implements pseudo gravity or more accurately a weak geometric constraint typically centered on the SVG that can be leveraged to keep your visualization from escaping the SVG canvas. In the following example we will learn how these two fundamental, and sometimes opposing forces, can be leveraged to generate various effects with a particle system.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec221"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter11/gravity-and-charge.html">https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter11/gravity-and-charge.html</a>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec222"/>How to do it...</h2></div></div></div><p>In the following example we<a id="id607" class="indexterm"/> will <a id="id608" class="indexterm"/>experiment with the force layout gravity and charge settings so you can better understand different opposing forces involved and their interaction:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/javascript"&gt;
    var w = 1280, h = 800,
        force = d3.layout.force()
            .size([w ,h])
            .gravity(0)
            .charge(0)
            .friction(0.7);

    var svg = d3.select("body")
        .append("svg")
            .attr("width", w)
            .attr("height", h);

    force.on("tick", function () {
        svg.selectAll("circle")
            .attr("cx", function (d) {return d.x;})
            .attr("cy", function (d) {return d.y;});
    });

    svg.on("mousemove", function () {
        var point = d3.mouse(this),
            node = {x: point[0], y: point[1]}; // &lt;-A

        svg.append("circle")
                .data([node])
            .attr("class", "node")
            .attr("cx", function (d) {return d.x;})
            .attr("cy", function (d) {return d.y;})
            .attr("r", 1e-6)
        .transition()
            .attr("r", 4.5)
        .transition()
            .delay(7000)
            .attr("r", 1e-6)
            .each("end", function () {
                force.nodes().shift(); // &lt;-B
            })
            .remove();

        force.nodes().push(node); // &lt;-C
        force.start(); // &lt;-D
    });

    function changeForce(charge, gravity) {
        force.charge(charge).gravity(gravity);
    }
&lt;/script&gt;

&lt;div class="control-group"&gt;
    &lt;button onclick="changeForce(0, 0)"&gt;
        No Force
    &lt;/button&gt;
    &lt;button onclick="changeForce(-60, 0)"&gt;
        Mutual Repulsion
    &lt;/button&gt;
    &lt;button onclick="changeForce(60, 0)"&gt;
        Mutual Attraction
    &lt;/button&gt;
    &lt;button onclick="changeForce(0, 0.02)"&gt;
        Gravity
    &lt;/button&gt;
    &lt;button onclick="changeForce(-30, 0.1)"&gt;
        Gravity with Repulsion
    &lt;/button&gt;    
&lt;/div&gt;</pre></div><p>This recipe generates a <a id="id609" class="indexterm"/>force-enabled particle system that is capable of operating in the<a id="id610" class="indexterm"/> modes shown in the following diagram:</p><div class="mediaobject"><img src="graphics/2162OS_11_01.jpg" alt="How to do it..."/><div class="caption"><p>Force Simulation Modes</p></div></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec223"/>How it works...</h2></div></div></div><p>Before we get our hands dirty with the preceding code example, let's first dig a little bit deeper into the concept of gravity, charge, and friction so we can have an easier time understanding all the magic number settings we will use in this recipe.</p><div class="section" title="Charge"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec14"/>Charge</h3></div></div></div><p>Charge <a id="id611" class="indexterm"/>is specified to simulate mutual n-body forces among the particles. A negative value results in a mutual node repulsion while a positive value results in a mutual node attraction. The default value for charge is <code class="literal">-30</code>. Charge value can also be a function that will be evaluated for each node whenever the force simulation starts.</p></div><div class="section" title="Gravity"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec15"/>Gravity</h3></div></div></div><p>Gravity simulation<a id="id612" class="indexterm"/> in force layout is not designed to simulate physical gravity, which can be simulated using positive charge. Instead, it is implemented as a weak geometric constraint similar to a virtual spring connecting to each node from the center of the layout. The default gravitational strength is set to <code class="literal">0.1</code>. As the nodes get further away from the center the gravitational strength gets stronger in linear proportion to the distance while near the center of the layout the gravitational strength is almost zero. Hence, gravity will always overcome repulsive charge at some point, therefore, preventing nodes from escaping the layout.</p></div><div class="section" title="Friction"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec16"/>Friction</h3></div></div></div><p>Friction<a id="id613" class="indexterm"/> in D3 force layout does not represent a standard physical coefficient of friction, but it is rather implemented as a velocity decay. At each tick of the simulation particle, velocity is scaled down by a specified friction. Thus a value of <code class="literal">1</code> corresponds to a frictionless environment while a value of <code class="literal">0</code> freezes all particles in place since they lose their velocity immediately. Values outside the range of <code class="literal">[0, 1]</code> are not recommended since they might destabilize the layout.</p><p>Alright, now with the dry definition behind us, let's take a look at how these forces can be leveraged to generate interesting visual effects.</p></div><div class="section" title="Setting up zero force layout"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec17"/>Setting up zero force layout</h3></div></div></div><p>First, we simply <a id="id614" class="indexterm"/>set up force layout with neither gravity nor charge. The force layout can be created using the <code class="literal">d3.layout.force</code> function:</p><div class="informalexample"><pre class="programlisting">var w = 1280, h = 800,
        force = d3.layout.force()
            .size([w ,h])
            .gravity(0)
            .charge(0)
            .friction(0.7);</pre></div><p>Here, we set the size of the layout to the size of our SVG graphic, which is a common approach though not mandatory. In some use cases you might find it useful to have a layout larger or smaller than your SVG. At the same time, we disable both gravity and charge while setting the <code class="literal">friction</code> to <code class="literal">0.7</code>. With this setting in place, we then create additional nodes represented as <code class="literal">svg:circle</code> on SVG whenever the user moves the mouse:</p><div class="informalexample"><pre class="programlisting">svg.on("mousemove", function () {
        var point = d3.mouse(this),
            <span class="strong"><strong>node = {x: point[0], y: point[1]}; // &lt;-A</strong></span>

        svg.append("circle")
                .data([node])
            .attr("class", "node")
            .attr("cx", function (d) {return d.x;})
            .attr("cy", function (d) {return d.y;})
            .attr("r", 1e-6)
        .transition()
            .attr("r", 4.5)
        .transition()
            .delay(7000)
            .attr("r", 1e-6)
            .each("end", function () {
                <span class="strong"><strong>force.nodes().shift(); // &lt;-B</strong></span>
            })
            .remove();

        <span class="strong"><strong>force.nodes().push(node); // &lt;-C</strong></span>
        <span class="strong"><strong>force.start(); // &lt;-D</strong></span>
});</pre></div><p>Node object was created <a id="id615" class="indexterm"/>initially on line A with its coordinates set to the current mouse location. Like all other D3 layouts, force layout is not aware and has no visual elements. Therefore, every node we create needs to be added to the layout's nodes array on line C and removed when visual representation of these nodes was removed on line B. On line D we call the <code class="literal">start</code> function to start force simulation. With zero gravity and charge the layout essentially lets us place a string of nodes with our mouse movement as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/2162OS_11_02.jpg" alt="Setting up zero force layout"/><div class="caption"><p>No Gravity or Charge</p></div></div></div><div class="section" title="Setting up mutual repulsion"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec18"/>Setting up mutual repulsion</h3></div></div></div><p>In the next mode, we will set <a id="id616" class="indexterm"/>the charge to a negative value while still keeping gravity to zero in order to generate a mutual repulsive force field:</p><div class="informalexample"><pre class="programlisting">function changeForce(charge, gravity) {
    force.charge(charge).gravity(gravity);
}
changeForce(-60, 0);</pre></div><p>These lines tell force layout to apply <code class="literal">-60</code> charge on each node and update the node's <code class="literal">{x, y}</code> coordinate accordingly, based on the simulation result on each tick. However, only doing this is still not enough to move the particles on SVG since the layout has no knowledge of the visual elements. Next, we need to write some code to connect the data that are being manipulated by force layout to our graphical elements. Following is the code to do that:</p><div class="informalexample"><pre class="programlisting">force.on("tick", function () {
        svg.selectAll("circle")
            .attr("cx", function (d) {return d.x;})
            .attr("cy", function (d) {return d.y;});
});</pre></div><p>Here, we register a <code class="literal">tick</code> event listener function that updates all circle elements to its new position based on the <a id="id617" class="indexterm"/>force layout's calculation. Tick listener is triggered on each tick of the simulation. At each tick we set the <code class="literal">cx</code> and <code class="literal">cy</code> attribute to be the <code class="literal">x</code> and <code class="literal">y</code> values on <code class="literal">d</code>. This is because we have already bound the node object as datum to these circle elements, therefore, they already contain the new coordinates calculated by force layout. This effectively establishes force layout's control over all the particles.</p><p>Other than <code class="literal">tick</code>, force layout also supports some other events:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">start</code>: Triggered when simulation starts</li><li class="listitem" style="list-style-type: disc"><code class="literal">tick</code>: Triggered on each tick of the simulation</li><li class="listitem" style="list-style-type: disc"><code class="literal">end</code>: Triggered when simulation ends</li></ul></div><p>This force setting generates the following visual effect:</p><div class="mediaobject"><img src="graphics/2162OS_11_03.jpg" alt="Setting up mutual repulsion"/><div class="caption"><p>Mutual Repulsion</p></div></div></div><div class="section" title="Setting up mutual attraction"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec19"/>Setting up mutual attraction</h3></div></div></div><p>When we change the charge to a positive <a id="id618" class="indexterm"/>value, it generates mutual attraction among the particles:</p><div class="informalexample"><pre class="programlisting">function changeForce(charge, gravity) {
    force.charge(charge).gravity(gravity);
}
changeForce(60, 0);</pre></div><p>This generates the following visual effect:</p><div class="mediaobject"><img src="graphics/2162OS_11_04.jpg" alt="Setting up mutual attraction"/><div class="caption"><p>Mutual Attraction</p></div></div></div><div class="section" title="Setting up gravity"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec20"/>Setting up gravity</h3></div></div></div><p>When we turn on <a id="id619" class="indexterm"/>gravity and turn off charge then it generates a similar effect as the mutual attraction; however, you can notice the linear scaling of gravitational pull as the mouse moves away from the center:</p><div class="informalexample"><pre class="programlisting">function changeForce(charge, gravity) {
    force.charge(charge).gravity(gravity);
}
changeForce(0, 0.02);</pre></div><p>With gravity <a id="id620" class="indexterm"/>alone this recipe generates the following effect:</p><div class="mediaobject"><img src="graphics/2162OS_11_05.jpg" alt="Setting up gravity"/><div class="caption"><p>Gravity</p></div></div></div><div class="section" title="Using gravity with repulsion"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec21"/>Using gravity with repulsion</h3></div></div></div><p>Finally, we can turn<a id="id621" class="indexterm"/> on both gravity and mutual repulsion. The result is an <a id="id622" class="indexterm"/>equilibrium of forces that keeps all particles somewhat stable neither escaping the layout nor colliding with each other:</p><div class="informalexample"><pre class="programlisting">function changeForce(charge, gravity) {
    force.charge(charge).gravity(gravity);
}
changeForce(-30, 0.1);</pre></div><p>Here is what this force equilibrium looks like:</p><div class="mediaobject"><img src="graphics/2162OS_11_06.jpg" alt="Using gravity with repulsion"/><div class="caption"><p>Gravity with Repulsion</p></div></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec224"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Verlet<a id="id623" class="indexterm"/> integration: <a class="ulink" href="http://en.wikipedia.org/wiki/Verlet_integration">http://en.wikipedia.org/wiki/Verlet_integration</a></li><li class="listitem" style="list-style-type: disc">Scalable, Versatile and Simple Constrained Graph Layout: <a class="ulink" href="http://www.csse.monash.edu.au/~tdwyer/Dwyer2009FastConstraints.pdf">http://www.csse.monash.edu.au/~tdwyer/Dwyer2009FastConstraints.pdf</a></li><li class="listitem" style="list-style-type: disc">Physical<a id="id624" class="indexterm"/> simulation: <a class="ulink" href="http://www.gamasutra.com/resource_guide/20030121/jacobson_pfv.htm">http://www.gamasutra.com/resource_guide/20030121/jacobson_pfv.htm</a></li><li class="listitem" style="list-style-type: disc">The content of this chapter is inspired by Mike Bostock's brilliant talk on D3 Force: <a class="ulink" href="http://mbostock.github.io/d3/talk/20110921/">http://mbostock.github.io/d3/talk/20110921/</a></li><li class="listitem" style="list-style-type: disc"><a class="link" href="ch10.html" title="Chapter 10. Interacting with your Visualization">Chapter 10</a>, <span class="emphasis"><em>Interacting with your Visualization</em></span>, for more details on how to interact with the mouse in D3</li><li class="listitem" style="list-style-type: disc">D3 Force Layout API document for more details on force layout: <a class="ulink" href="https://github.com/mbostock/d3/wiki/Force-Layout">https://github.com/mbostock/d3/wiki/Force-Layout</a></li></ul></div></div></div>
<div class="section" title="Generating momentum"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec78"/>Generating momentum</h1></div></div></div><p>In our previous recipe we have<a id="id625" class="indexterm"/> touched upon force layout node object and its <code class="literal">{x, y}</code> attributes, which determine where a node locates on the layout. In this recipe we will discuss another interesting aspect of physical motion simulation: momentum. D3 force layout has built-in support for momentum simulation which relies on the <code class="literal">{px, py}</code> attributes on the node object. Let's see how this can be done in the example described in this recipe.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec225"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter11/momentum-and-friction.html">https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter11/momentum-and-friction.html</a>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec226"/>How to do it...</h2></div></div></div><p>In this recipe we will modify the previous recipe by first disabling both gravity and charge then giving newly added node some initial velocity. As a result now the faster you move the mouse higher the initial velocity and momentum will be for each node. Here is the code to do that:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/javascript"&gt;
    var force = d3.layout.force()
            .gravity(0)
            .charge(0)
            .friction(0.95);

    var svg = d3.select("body").append("svg:svg");

    force.on("tick", function () {
        // omitted, same as previous recipe
       ...
    });

    var previousPoint;

    svg.on("mousemove", function () {
        var point = d3.mouse(this),
            node = {
                x: point[0],
                y: point[1],
                px: previousPoint ? previousPoint[0] : point[0],
                py: previousPoint ? previousPoint[1] : point[1]
            };

        previousPoint = point;

        // omitted, same as previous recipe
       ...
    });
&lt;/script&gt; </pre></div><p>This recipe generates a <a id="id626" class="indexterm"/>particle system with initial directional velocity proportional to the user's mouse movement as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/2162OS_11_07.jpg" alt="How to do it..."/><div class="caption"><p>Momentum</p></div></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec227"/>How it works...</h2></div></div></div><p>The overall structure <a id="id627" class="indexterm"/>of this recipe is very similar to the previous one. It also generates particles as the user moves the mouse around. Moreover, once the force simulation starts, the particle position is fully controlled by force layout in its <code class="literal">tick</code> event listener function. However, in this recipe we have turned off both gravity and charge so that we can focus more clearly on momentum alone. We left some friction so the velocity decay making simulation look more realistic. Here is our force layout configuration:</p><div class="informalexample"><pre class="programlisting">var force = d3.layout.force()
            .gravity(0)
            .charge(0)
            .friction(0.95);</pre></div><p>The major difference in this recipe is that we keep track of not only the current mouse position, but also the previous mouse position. Additionally, whenever the user moves the mouse we generate a node object containing the current location <code class="literal">{x, y}</code> as well as the previous location <code class="literal">{px, py}</code>:</p><div class="informalexample"><pre class="programlisting">    var previousPoint;

    svg.on("mousemove", function () {
        var point = d3.mouse(this),
            node = {
                x: point[0],
                y: point[1],
                px: previousPoint ? previousPoint[0] : point[0],
                py: previousPoint ? previousPoint[1] : point[1]
            };

        previousPoint = point;
        ...
    }</pre></div><p>Since user mouse location is sampled on fixed interval, the faster the user moves the mouse the further apart these two positions will be. This property plus the directional information gained from these two positions are nicely translated automatically by force layout into initial momentum for each particle we create as we have demonstrated in this recipe.</p><p>Besides the <code class="literal">{x, y, px, py}</code> attributes we have discussed so far, force layout node object also supports some other useful attributes that we will list here for your reference:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">index</code>: Zero-based index of the node within the nodes array.</li><li class="listitem" style="list-style-type: disc"><code class="literal">x</code>: The x-coordinate of the current node position.</li><li class="listitem" style="list-style-type: disc"><code class="literal">y</code>: The y-coordinate of the current node position.</li><li class="listitem" style="list-style-type: disc"><code class="literal">px</code>: The x-coordinate of the previous node position.</li><li class="listitem" style="list-style-type: disc"><code class="literal">py</code>: The y-coordinate of the previous node position.</li><li class="listitem" style="list-style-type: disc"><code class="literal">fixed</code>: A Boolean indicating if the node position is locked.</li><li class="listitem" style="list-style-type: disc"><code class="literal">weight</code>: The node weight; the number of associated links. Links are used to connect nodes in a <a id="id628" class="indexterm"/>force layout, which we will cover in depth in the next recipe.</li></ul></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec228"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Interacting with mouse events</em></span> recipe in <a class="link" href="ch10.html" title="Chapter 10. Interacting with your Visualization">Chapter 10</a>, <span class="emphasis"><em>Interacting with your Visualization</em></span>, for more details on how to interact with the mouse in D3</li><li class="listitem" style="list-style-type: disc">D3 Force Layout Nodes API for more details on force layout node attributes <a class="ulink" href="https://github.com/mbostock/d3/wiki/Force-Layout#wiki-nodes">https://github.com/mbostock/d3/wiki/Force-Layout#wiki-nodes</a></li></ul></div></div></div>
<div class="section" title="Setting the link constraint"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec79"/>Setting the link constraint</h1></div></div></div><p>So far we have covered some important aspects of the force layout such as gravity, charge, friction, and momentum. In this recipe we will discuss another critical functionality: links. As we have mentioned in the introduction section, D3 force layout implements a scalable simple graph constraint, and in this recipe we will demonstrate how link constraint can be<a id="id629" class="indexterm"/> leveraged in conjunction with other forces.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec229"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter11/link-constraint.html">https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter11/link-constraint.html</a>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec230"/>How to do it...</h2></div></div></div><p>In this recipe, whenever the user clicks their mouse we will generate a force-directed ring of particles constrained by links between nodes. Here is how it is implemented:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/javascript"&gt;
    var force = d3.layout.force()
            .gravity(0.1)
            .charge(-30)
            .friction(0.95)
            .linkDistance(20)
            .linkStrength(1);

    var duration = 60000; // in milliseconds

    var svg = d3.select("body").append("svg:svg");

    force.size([1100, 600])
        .on("tick", function () {
            // omitted, will be discussed in details later
            ...
        });

    function offset() {
        return Math.random() * 100;
    }

    function createNodes(point) {
        var numberOfNodes = Math.round(Math.random() * 10);
        var nodes = [];

        for (var i = 0; i &lt; numberOfNodes; ++i) {
            nodes.push({
                x: point[0] + offset(), 
                y: point[1] + offset()
            });
        }

        return nodes;
    }

    function createLinks(nodes) {
        // omitted, will be discussed in details later
        ...
    }

    svg.on("click", function () {
        var point = d3.mouse(this),
                nodes = createNodes(point),
                links = createLinks(nodes);

        nodes.forEach(function (node) {
            svg.append("circle")
                    .data([node])
                .attr("class", "node")
                .attr("cx", function (d) {return d.x;})
                .attr("cy", function (d) {return d.y;})
                .attr("r", 1e-6)
                .call(force.drag)
                    .transition()
                .attr("r", 7)
                    .transition()
                    .delay(duration)
                .attr("r", 1e-6)
                .each("end", function () {force.nodes().shift();})
                .remove();
        });

        links.forEach(function (link) {
            // omitted, will be discussed in details later
            ...
        });

        nodes.forEach(function (n) {force.nodes().push(n);});
        links.forEach(function (l) {force.links().push(l);});

        force.start();
    });
&lt;/script&gt;</pre></div><p>This recipe generates <a id="id630" class="indexterm"/>force-directed particle rings on a mouse click as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/2162OS_11_08.jpg" alt="How to do it..."/><div class="caption"><p>Force-Directed Particle Rings</p></div></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec231"/>How it works...</h2></div></div></div><p>Link constraint<a id="id631" class="indexterm"/> adds another useful dimension to force assisted visualization. In this recipe we set up our force layout with the following parameters:</p><div class="informalexample"><pre class="programlisting">var force = d3.layout.force()
            .gravity(0.1)
            .charge(-30)
            .friction(0.95)
            .linkDistance(20)
            .linkStrength(1);</pre></div><p>Besides gravity, charge, and friction, this time we have two additional parameters: link distance and link strength. Both parameters are exclusively link related:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">linkDistance</code>: Could be a <a id="id632" class="indexterm"/>constant or a function; defaults to 20 pixels. Link distances are evaluated when the layout starts, and it is implemented as weak geometric constraints. For each tick of the layout, the distance between each pair of linked nodes is computed and compared to the target distance; the links are then moved towards each other or away from each other.</li><li class="listitem" style="list-style-type: disc"><code class="literal">linkStength</code>: Could be a <a id="id633" class="indexterm"/>constant or a function; defaults to 1. Link strength sets the strength (rigidity) of links with value in the range of <code class="literal">[0, 1]</code>. Link strength is also evaluated on layout start.</li></ul></div><p>When the user clicks<a id="id634" class="indexterm"/> their mouse, a random number of nodes are being created and put under force layout's control similar to what we have done in the previous recipes. The major addition in this recipe is the link creation and its control logic is shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">    function createLinks(nodes) {
        var links = [];
        for (var i = 0; i &lt; nodes.length; ++i) { // &lt;-A
            if(i == nodes.length - 1) 
                links.push(
                    {source: nodes[i], target: nodes[0]}
                );
            else
                links.push(
                    {source: nodes[i], target: nodes[i + 1]}
                );
        }
        return links;
    }
...
svg.on("click", function () {
        var point = d3.mouse(this),
                nodes = createNodes(point),
                links = createLinks(nodes);
    ...

        links.forEach(function (link) {
            svg.append("line") // &lt;-B
                    .data([link])
                .attr("class", "line")
                .attr("x1", function (d) {
                   return d.source.x;
                    })
                .attr("y1", function (d) {
                   return d.source.y;
})
                .attr("x2", function (d) {
                   return d.target.x;
                    })
                .attr("y2", function (d) {
                   return d.target.y;
    })
                    .transition()
                    .delay(duration)
                .style("stroke-opacity", 1e-6)
                .each("end", function () {
                   force.links().shift();
    })
                .remove();
        });

        nodes.forEach(function (n) {force.nodes().push(n);});
        links.forEach(function (l) { // &lt;-C
          force.links().push(l);
   });

        force.start();
}</pre></div><p>In the <code class="literal">createLinks</code> function, <code class="literal">n-1</code> link objects were created connecting a set of nodes into a ring (for loop on line A). Each<a id="id635" class="indexterm"/> link object must have two attributes specified as <code class="literal">source</code> and <code class="literal">target</code>, telling force layout which pair of nodes are connected by this link object. Once created, we decided to visualize the links in this recipe using <code class="literal">svg:line</code> element (line B). We will see in the next recipe that this does not have to always be the case. As a matter of fact, you can use pretty much anything; you can imagine to visualize (including hiding them, but retain the links for layout computation) the links as long as it makes sense for the audience of your visualization. After that we also need to add link objects to force layout's links array (on line C) so they can be put under force layout's control. Finally, we need to translate the positioning data generated by force layout to SVG implementation in the <code class="literal">tick</code> function for each link similar to what we did for the nodes:</p><div class="informalexample"><pre class="programlisting">force.size([1100, 600])
        .on("tick", function () {
            svg.selectAll("circle")
                .attr("cx", function (d) {return d.x;})
                .attr("cy", function (d) {return d.y;});

            svg.selectAll("line")
                .attr("x1", function (d) {return d.source.x;})
                .attr("y1", function (d) {return d.source.y;})
                .attr("x2", function (d) {return d.target.x;})
                .attr("y2", function (d) {return d.target.y;});
        });</pre></div><p>As we can see here, D3 force layout has again done most of the heavy lifting, therefore, all we need to do is simply set <code class="literal">{x1, y1}</code> and <code class="literal">{x2, y2}</code> on the <code class="literal">svg:line</code> elements in the <code class="literal">tick</code> function. For reference, the following screenshot is what a link object looks like after it has been <a id="id636" class="indexterm"/>manipulated by force layout:</p><div class="mediaobject"><img src="graphics/2162OS_11_09.jpg" alt="How it works..."/><div class="caption"><p>Link Object</p></div></div><p>One last additional technique worth mentioning in this recipe is force-enabled dragging. All nodes generated by this recipe are "draggable" and force layout automatically re-computes all forces and constraints as user drags the rings around as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/2162OS_11_10.jpg" alt="How it works..."/><div class="caption"><p>Dragging with Force Layout</p></div></div><p>D3 force layout <a id="id637" class="indexterm"/>has dragging built-in, hence, this fancy effect is quite easily achieved by simply calling <code class="literal">force.drag</code> on the <code class="literal">svg:circle</code> selection (line D):</p><div class="informalexample"><pre class="programlisting">nodes.forEach(function (node) {
            svg.append("circle")
                    .data([node])
                .attr("class", "node")
                ...
                .call(force.drag) // &lt;-D
                    .transition()
                ...
                .each("end", function () {force.nodes().shift();})
                .remove();
        });</pre></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec232"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Scalable, Versatile and Simple Constrained Graph Layout: <a class="ulink" href="http://www.csse.monash.edu.au/~tdwyer/Dwyer2009FastConstraints.pdf">http://www.csse.monash.edu.au/~tdwyer/Dwyer2009FastConstraints.pdf</a></li><li class="listitem" style="list-style-type: disc"><code class="literal">force.links()</code>: <a class="ulink" href="https://github.com/mbostock/d3/wiki/Force-Layout#wiki-links">https://github.com/mbostock/d3/wiki/Force-Layout#wiki-links</a></li><li class="listitem" style="list-style-type: disc"><code class="literal">force.linkDistance()</code>: <a class="ulink" href="https://github.com/mbostock/d3/wiki/Force-Layout#wiki-linkDistance">https://github.com/mbostock/d3/wiki/Force-Layout#wiki-linkDistance</a></li><li class="listitem" style="list-style-type: disc"><code class="literal">force.linkStrength()</code>: <a class="ulink" href="https://github.com/mbostock/d3/wiki/Force-Layout#wiki-linkStrength">https://github.com/mbostock/d3/wiki/Force-Layout#wiki-linkStrength</a></li><li class="listitem" style="list-style-type: disc"><code class="literal">force.drag</code>: <a class="ulink" href="https://github.com/mbostock/d3/wiki/Force-Layout#wiki-drag">https://github.com/mbostock/d3/wiki/Force-Layout#wiki-drag</a></li></ul></div></div></div>
<div class="section" title="Using force to assist visualization"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec80"/>Using force to assist visualization</h1></div></div></div><p>So far we have<a id="id638" class="indexterm"/> learned to use force layout visualizing particles and<a id="id639" class="indexterm"/> links similar to how you would use force layout in its classic application, the forced-directed graph. This kind of visualization is what force layout was designed for in the first place. However, this is by no means the only way to utilize force in your visualization. In this recipe we will explore techniques that I call force-assisted visualization. With this technique you can add some randomness and arbitrariness into your visualization by leveraging force.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec233"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter11/arbitrary-visualization.html">https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter11/arbitrary-visualization.html</a>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec234"/>How to do it...</h2></div></div></div><p>In this recipe we will generate bubbles on user mouse click. The bubbles are made of <code class="literal">svg:path</code> elements filled with gradient color. The <code class="literal">svg:path</code> elements are not strictly controlled by force layout though they are influenced by force, therefore, giving them the randomness required to simulate a bubble in real-life:</p><div class="informalexample"><pre class="programlisting">&lt;svg&gt;
    &lt;defs&gt;
        &lt;radialGradient id="gradient" cx="50%" cy="50%" r="100%" fx="50%" fy="50%"&gt;
            &lt;stop offset="0%" style="stop-color:blue;stop-opacity:0"/&gt;
            &lt;stop offset="100%" style="stop-color:rgb(255,255,255);stop-opacity:1"/&gt;
        &lt;/radialGradient&gt;
    &lt;/defs&gt;
&lt;/svg&gt;

&lt;script type="text/javascript"&gt;
    var force = d3.layout.force()
            .gravity(0.1)
            .charge(-30)
            .friction(0.95)
            .linkDistance(20)
            .linkStrength(0.5);

    var duration = 10000;

    var svg = d3.select("svg");

    var line = d3.svg.line()
            .interpolate("basis-closed")
            .x(function(d){return d.x;})
            .y(function(d){return d.y;});

    force.size([svg.node().clientWidth, svg.node().clientHeight])
        .on("tick", function () {
            // omitted, will be discussed in details later
            ...
        });

    function offset() {
        return Math.random() * 100;
    }

    function createNodes(point) {
        // omitted, same as previous recipe
       ...
    }

    function createLinks(nodes) {
        // omitted, same as previous recipe
       ...
    }

    svg.on("click", function () {
        // omitted, will be discussed in details later
        ...
    });
&lt;/script&gt;</pre></div><p>This recipe generates<a id="id640" class="indexterm"/> force assisted bubbles on user mouse click as <a id="id641" class="indexterm"/>shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/2162OS_11_11.jpg" alt="How to do it..."/><div class="caption"><p>Force Assisted Bubbles</p></div></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec235"/>How it works...</h2></div></div></div><p>This recipe is<a id="id642" class="indexterm"/> built on top of what we have done in the previous <a id="id643" class="indexterm"/>recipe, therefore, its overall approach is quite similar to the last recipe in which we created force controlled particle rings on user mouse click. The major difference between this recipe and the last one is in this one we decided to use <code class="literal">d3.svg.line</code> generator to create the <code class="literal">svg:path</code> element that outlines our bubbles instead of using <code class="literal">svg:circle</code> and <code class="literal">svg:line</code>:</p><div class="informalexample"><pre class="programlisting">var line = d3.svg.line() // &lt;-A
            .interpolate("basis-closed")
            .x(function(d){return d.x;})
            .y(function(d){return d.y;});
...
svg.on("click", function () {
        var point = d3.mouse(this),
                nodes = createNodes(point),
                links = createLinks(nodes);

        var circles = svg.append("path")
                .data([nodes])
            .attr("class", "bubble")
            .attr("fill", "url(#gradient)") // &lt;-B
            .attr("d", function(d){return line(d);}) // &lt;-C
                .transition().delay(duration)
            .attr("fill-opacity", 0)
            .attr("stroke-opacity", 0)
            .each("end", function(){d3.select(this).remove();});

        nodes.forEach(function (n) {force.nodes().push(n);});
        links.forEach(function (l) {force.links().push(l);});

        force.start();
});</pre></div><p>On line A we created a line generator with <code class="literal">basis-closed</code> interpolation mode since this gives us the smoothest outline for our bubble. Whenever user clicks the mouse a <code class="literal">svg:path</code> element was created connecting all nodes (line C). Additionally, we also fill the bubble with our pre-defined gradient to give it a nice glow (line B). Finally, we also need to implement the force based positioning in the <code class="literal">tick</code> function:</p><div class="informalexample"><pre class="programlisting">force.size([svg.node().clientWidth, svg.node().clientHeight])
        .on("tick", function () {
            svg.selectAll("path")
                .attr("d", line);
        });</pre></div><p>In the <code class="literal">tick</code> function<a id="id644" class="indexterm"/> we <a id="id645" class="indexterm"/>simply re-invoke the line generator function to <a id="id646" class="indexterm"/>update the <code class="literal">d</code> attribute for each path thus animating the bubbles using force layout computation.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec236"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">SVG Gradients and Patterns: <a class="ulink" href="http://www.w3.org/TR/SVG/pservers.html">http://www.w3.org/TR/SVG/pservers.html</a></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Using line generator</em></span> recipe in <a class="link" href="ch07.html" title="Chapter 7. Getting into Shape">Chapter 7</a>, <span class="emphasis"><em>Getting into Shape</em></span>, for more information on D3 line generator</li></ul></div></div></div>
<div class="section" title="Manipulating force"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec81"/>Manipulating force</h1></div></div></div><p>So far we have explored many interesting aspects and applications of D3 force layout; however, in all of these prior recipes we simply apply force layout's computation (gravity, charge, friction, and momentum) directly to our visualization. In this recipe we will go one step further to implement custom force manipulation, hence creating our own type of force.</p><p>In this recipe we will first <a id="id647" class="indexterm"/>generate five sets of colored particles then we assign corresponding colors and categorical force pull to user's touch, hence pulling only the particles that match the color. Since this recipe is a bit complex, I will give an example here: if I touch the visualization with my first finger it will generate a blue circle and pull all blue particles to that circle, while my second touch will generate an orange circle and only pull the orange particles. This type of force manipulation is commonly referred to as categorical multi-foci.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec237"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter11/multi-foci.html">https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter11/multi-foci.html</a>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec238"/>How to do it...</h2></div></div></div><p>Here is how you can achieve this in code:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/javascript"&gt;
    var svg = d3.select("body").append("svg:svg"),
            colors = d3.scale.category10(),
            w = 900,
            h = 600;

    svg.attr("width", w).attr("height", h);

    var force = d3.layout.force()
            .gravity(0.1)
            .charge(-30)
            .size([w, h]);

    var nodes = force.nodes(),
            centers = [];

    for (var i = 0; i &lt; 5; ++i) {
        for (var j = 0; j &lt; 50; ++j) {
            nodes.push({x: w / 2 + offset(), 
              y: h / 2 + offset(), 
              color: colors(i), // &lt;-A
              type: i}); // &lt;-B
        }
    }

    function offset() {
        return Math.random() * 100;
    }

    svg.selectAll("circle")
                .data(nodes).enter()
            .append("circle")
            .attr("class", "node")
            .attr("cx", function (d) {return d.x;})
            .attr("cy", function (d) {return d.y;})
            .attr("fill", function(d){return d.color;})
            .attr("r", 1e-6)
                .transition()
            .attr("r", 4.5);

    force.on("tick", function(e) {
          // omitted, will discuss in detail
    ...
    });

    d3.select("body")
        .on("touchstart", touch)
        .on("touchend", touch);

    function touch() {
        // omitted, will discuss in detail
        ...
    }

    force.start();
&lt;/script&gt;</pre></div><p>This recipe generates <a id="id648" class="indexterm"/>multi-categorical foci on touch as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/2162OS_11_12.jpg" alt="How to do it..."/><div class="caption"><p>Multi-Categorical Foci on Touch</p></div></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec239"/>How it works...</h2></div></div></div><p>The first step of this<a id="id649" class="indexterm"/> recipe is to create colored particles and standard force equilibrium between gravity and repulsion. All node objects contain separate color and type ID attributes (line A and B) so they can be easily identified later. Next, we need to create a <code class="literal">svg:circle</code> element on user touch to represent the touch point:</p><div class="informalexample"><pre class="programlisting">function touch() {
        d3.event.preventDefault();

        centers = d3.touches(svg.node());

        var g = svg.selectAll("g.touch")
                .data(centers, function (d) {
                    return d.identifier;
                });

        g.enter()
            .append("g")
            .attr("class", "touch")
            .attr("transform", function (d) {
                return "translate(" + d[0] + "," + d[1] + ")";
            })
            .append("circle")
                .attr("class", "touch")
                .attr("fill", function(d){
                   return colors(d.identifier);
                })
                    .transition()
                .attr("r", 50);

        g.exit().remove();

        force.resume();
}</pre></div><p>Once the touch point is<a id="id650" class="indexterm"/> identified, all custom force magic is implemented in the <code class="literal">tick</code> function. Now, let's take a look at the <code class="literal">tick</code> function:</p><div class="informalexample"><pre class="programlisting">force.on("tick", function(e) {
          var k = e.alpha * .2;
          nodes.forEach(function(node) {
            var center = centers[node.type];
            if(center){
                node.x += (center[0] - node.x) * k; // &lt;-C
                node.y += (center[1] - node.y) * k; // &lt;-D
            }
          });

          svg.selectAll("circle")
              .attr("cx", function(d) { return d.x; })
              .attr("cy", function(d) { return d.y; });
});</pre></div><p>The first new concept we encounter here is the alpha parameter. Alpha is an internal cooling parameter used by force layout. Alpha starts with <code class="literal">0.1</code> and moves towards <code class="literal">0</code> as layout ticks. In simpler<a id="id651" class="indexterm"/> terms the higher the alpha value the more chaotic the forces are and as alpha approaches <code class="literal">0</code> the layout becomes more stable. In this implementation we leverage the alpha value to make our custom force implementation cool down in synchronous with other built-in forces, since the movements of the particles are calculated with <code class="literal">k</code> coefficient (a derivative of alpha) on line C and D moving them closer to the matching touch point.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec240"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Interacting with a multi-touch device</em></span> recipe in <a class="link" href="ch10.html" title="Chapter 10. Interacting with your Visualization">Chapter 10</a>, <span class="emphasis"><em>Interacting with your Visualization</em></span>, for more information on D3 multi-touch support</li></ul></div></div></div>
<div class="section" title="Building a force-directed graph"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec82"/>Building a force-directed graph</h1></div></div></div><p>At last, we will show how to<a id="id652" class="indexterm"/> implement a force-directed graph, the classic application of D3 force layout. However, we believe with all the techniques and knowledge you have gained so far from this chapter implementing force-directed graph should feel quite straightforward.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec241"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter11/force-directed-graph.html">https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter11/force-directed-graph.html</a>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec242"/>How to do it...</h2></div></div></div><p>In this recipe we will visualize the flare data set as a force-directed tree (tree is a special type of graph):</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/javascript"&gt;
    var w = 1280,
        h = 800,
        z = d3.scale.category20c();

    var force = d3.layout.force()
        .size([w, h]);

    var svg = d3.select("body").append("svg")
        .attr("width", w)
        .attr("height", h);

    d3.json("/data/flare.json", function(root) {
      var nodes = flatten(root),
          links = d3.layout.tree().links(nodes); // &lt;-B

      force
          .nodes(nodes)
          .links(links)
          .start();

      var link = svg.selectAll("line")
          .data(links)
        .enter().insert("line")
          .style("stroke", "#999")
          .style("stroke-width", "1px");

      var node = svg.selectAll("circle.node")
          .data(nodes)
        .enter().append("circle")
          .attr("r", 4.5)
          .style("fill", function(d) { 
             return z(d.parent &amp;&amp; d.parent.name); 
})
          .style("stroke", "#000")
          .call(force.drag);

      force.on("tick", function(e) {
        link.attr("x1", function(d) { return d.source.x; })
            .attr("y1", function(d) { return d.source.y; })
            .attr("x2", function(d) { return d.target.x; })
            .attr("y2", function(d) { return d.target.y; });

        node.attr("cx", function(d) { return d.x; })
            .attr("cy", function(d) { return d.y; });
      });
    });

    function flatten(root) { // &lt;-A
      var nodes = [];
      function traverse(node, depth) {
        if (node.children) {
          node.children.forEach(function(child) {
            child.parent = node;
            traverse(child, depth + 1);
          });
        }
        node.depth = depth;
        nodes.push(node);
      }
      traverse(root, 1);
      return nodes;
    }
&lt;/script&gt;</pre></div><p>This recipe visualizes<a id="id653" class="indexterm"/> hierarchical flare data set as a force-directed tree:</p><div class="mediaobject"><img src="graphics/2162OS_11_13.jpg" alt="How to do it..."/><div class="caption"><p>Force-Directed Graph (Tree)</p></div></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec243"/>How it works...</h2></div></div></div><p>As we can already see, <a id="id654" class="indexterm"/>this recipe is pretty short and a quarter of the code was actually devoted to data processing. This is due to the fact that force-directed graph is what force layout was designed for in the first place. Thus there is really not much to do other than simply apply the layout with correct data structure. First, we flatten the hierarchical data set in flatten function (line A) since this is what force layout expects. Second, we leverage the <code class="literal">d3.layout.tree.links</code> function to generate proper linkage between tree nodes. The <code class="literal">d3.layout.tree.links</code> function returns an array of link objects representing links from parent to child for each given node object, in other words, builds the tree structure. Once the data is properly formatted the rest of this recipe applies standard force layout usage with hardly any customization at all.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec244"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Building a tree</em></span> recipe in <a class="link" href="ch09.html" title="Chapter 9. Lay Them Out">Chapter 9</a>, <span class="emphasis"><em>Lay Them Out</em></span>, for more information on D3 tree layout</li><li class="listitem" style="list-style-type: disc">For more information on force-directed graphs, visit the site: <a class="ulink" href="http://en.wikipedia.org/wiki/Force-directed_graph_drawing">http://en.wikipedia.org/wiki/Force-directed_graph_drawing</a></li></ul></div></div></div></body></html>