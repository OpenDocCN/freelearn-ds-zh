<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer246" class="Content">
			<h1 id="_idParaDest-245"><em class="italics"><a id="_idTextAnchor292"/>Chapter 8</em></h1>
		</div>
		<div id="_idContainer247" class="Content">
			<h1 id="_idParaDest-246"><a id="_idTextAnchor293"/>RDBMS and SQL</h1>
		</div>
		<div id="_idContainer248" class="Content">
			<h2>Learning Objectives</h2>
			<p>By the end of this chapter, you will be able to:</p>
			<ul>
				<li class="bullets">Apply the basics of RDBMS to query databases using Python</li>
				<li class="bullets">Convert data from SQL into a pandas DataFrame</li>
			</ul>
			<p>This chapter explains the concepts of databases, including their creation, manipulation and control, and transforming tables into pandas DataFrames.</p>
		</div>
		<div id="_idContainer264" class="Content">
			<h2 id="_idParaDest-247"><a id="_idTextAnchor294"/>Introduction</h2>
			<p>This chapter of our data journey is focused on <strong class="keyword">RDBMS</strong> (Relational Database Management Systems) and <strong class="keyword">SQL</strong> (Structured Query Language). In the previous chapter, we stored and read data from a file. In this chapter, we will read structured data, design access to the data, and create query interfaces for databases.</p>
			<p>Data has been stored in RDBMS format for years. The reasons behind it are as follows:</p>
			<ul>
				<li>RDBMS is one of the safest ways to store, manage, and retrieve data.</li>
				<li>They are backed by a solid mathematical foundation (relational algebra and calculus) and they expose an efficient and intuitive declarative language – SQL – for easy interaction.</li>
				<li>Almost every language has a rich set of libraries to interact with different RDBMS and the tricks and methods of using them are well tested and well understood.</li>
				<li>Scaling an RDBMS is a pretty well-understood task and there are a bunch of well trained, experienced professionals to do this job (DBA or database administrator).</li>
			</ul>
			<p>As we can see in the following chart, the market of DBMS is big. This chart was produced based on market research that was done by <strong class="bold">Gartner, Inc.</strong> in <strong class="bold">2016</strong>:</p>
			<div>
				<div id="_idContainer249" class="IMG---Figure">
					<img src="Images/C11065_08_01.jpg" alt="Figure 8.1 Commercial database market share in 2016" width="1029" height="476"/>
				</div>
			</div>
			<h6>Figure 8.1 Commercial database market share in 2016</h6>
			<p>We will learn and play around with some basic and fundamental concepts of database and database management systems in this chapter.</p>
			<h2 id="_idParaDest-248">R<a id="_idTextAnchor295"/>efresher of RDBMS and SQL</h2>
			<p>An RDBMS is a piece of software that manages data (represented for the end user in a tabular form) on physical hard disks and is built using the Codd's relational model. Most of the databases that we encounter today are RDBMS. In recent years, there has been a huge industry shift toward a newer kind of database management system, called <strong class="keyword">NoSQL</strong> (<strong class="keyword">MongoDB</strong>, <strong class="keyword">CouchDB</strong>, <strong class="keyword">Riak</strong>, and so on). These systems, although in some aspects they follow some of the rules of RDBMS, in most cases reject or modify them.</p>
			<h3 id="_idParaDest-249"><a id="_idTextAnchor296"/>How is an RDBMS Structured?</h3>
			<p>The RDBMS structure consists of three main elements, namely the storage engine, query engine, and log management. Here is a diagram that shows the structure of a RDBMS:</p>
			<div>
				<div id="_idContainer250" class="IMG---Figure">
					<img src="Images/C11065_08_02.jpg" alt="Figure 8.2 RDBMS structure" width="1800" height="1369"/>
				</div>
			</div>
			<h6>Figure 8.2 RDBMS structure</h6>
			<p>The following are the main concepts of any RDBMS structure:</p>
			<ul>
				<li><strong class="keyword">Storage engine</strong>: This is the part of the RDBMS that is responsible for storing the data in an efficient way and also to give it back when asked for, in an efficient way. As an end user of the RDBMS system (an application developer is considered an end user of an RDBMS), we will never need to interact with this layer directly.</li>
				<li><strong class="keyword">Query engine</strong>: This is the part of the RDBMS that allows us to create data objects (tables, views, and so on), manipulate them (create and delete columns, create/delete/update rows, and so on), and query them (read rows) using a simple yet powerful language.</li>
				<li><strong class="keyword">Log management</strong>: This part of the RDBMS is responsible for creating and maintaining the logs. If you are wondering why the log is such an important thing, then you should look into how replication and partitions are handled in a modern RDBMS (such as PostgreSQL) using something called <strong class="keyword">Write Ahead Log</strong> (or WAL for short).</li>
			</ul>
			<p>We will focus on the query engine in this chapter.</p>
			<h3 id="_idParaDest-250"><a id="_idTextAnchor297"/>SQL</h3>
			<p><strong class="bold">S</strong>tructured <strong class="bold">Q</strong>uery <strong class="bold">L</strong>anguage or <strong class="keyword">SQL</strong> (pronounced sequel), as it is commonly known, is a domain-specific language that was originally designed based on E.F. Codd's relational model and is widely used in today's databases to define, insert, manipulate, and retrieve data from them. It can be further sub-divided into four smaller sub-languages, namely <strong class="bold">DDL</strong> (Data Definition Language), <strong class="bold">DML</strong> (Data Manipulation Language), <strong class="bold">DQL</strong> (Data Query Language), and <strong class="bold">DCL</strong> (Data Control Language). There are several advantages of using SQL, with some of them being as follows:</p>
			<ul>
				<li>It is based on a solid mathematical framework and thus it is easy to understand.</li>
				<li>It is a declarative language, which means that we actually never tell it how to do its job. We almost always tell it what to do. This frees us from a big burden of writing custom code for data management. We can be more focused on the actual query problem we are trying to solve instead of bothering about how to create and maintain a data store.</li>
				<li>It gives you a fast and readable way to deal with data.</li>
				<li>SQL gives you out-of-the-box ways to get multiple pieces of data with a single query.</li>
			</ul>
			<p>The main areas of focus for the following topic will be DDL, DML, and DQL. The DCL part is more for database administrators.</p>
			<ul>
				<li><strong class="bold">DDL</strong>: This is how we define our data structure in SQL. As RDBMS is mainly designed and built with structured data in mind, we have to tell an RDBMS engine beforehand what our data is going to look like. We can update this definition at a later point in time, but an initial one is a must. This is where we will write statements such as <strong class="inline">CREATE</strong> <strong class="inline">TABLE</strong> or <strong class="inline">DROP</strong> <strong class="inline">TABLE</strong> or <strong class="inline">ALTER</strong> <strong class="inline">TABLE</strong>. <h4>Note</h4><p class="callout">Notice the use of uppercase letters. It is not a specification and you can use lowercase letters, but it is a widely followed convention and we will use that in this book.</p></li>
				<li><strong class="bold">DML</strong>: DML is the part of SQL that let us insert, delete, or update a certain data point (a row) in a previously defined data object (a table). This is the part of SQL which contains statements such as <strong class="inline">INSERT</strong> <strong class="inline">INTO</strong>, <strong class="inline">DELETE</strong> <strong class="inline">FROM</strong>, or <strong class="inline">UPDATE</strong>.</li>
				<li><strong class="bold">DQL</strong>: With DQL, we enable ourselves to query the data stored in a RDBMS, which was defined by DDL and inserted using DML. It gives us enormous power and flexibility to not only query data out of a single object (table), but also to extract relevant data from all the related objects using queries. The frequently used query that's used to retrieve data is the <strong class="inline">SELECT</strong> command. We will also see and use the concepts of the primary key, foreign key, index, joins, and so on.</li>
			</ul>
			<p>Once you define and insert data in a database, it can be represented as follows:</p>
			<div>
				<div id="_idContainer251" class="IMG---Figure">
					<img src="Images/C11065_08_03.jpg" alt="Figure 8.3 Table displaying sample data" width="686" height="271"/>
				</div>
			</div>
			<h6>Figure 8.3 Table displaying sample data</h6>
			<p>Another thing to remember about RDBMS is relations. Generally, in a table, we have one or more columns that will have unique values for each row in the table. We call them <strong class="keyword">primary keys</strong> for the table. We should be aware that we will encounter unique values across the rows, which are not primary keys. The main difference between them and primary keys is the fact that a primary key cannot be null.</p>
			<p>By using the primary key of one table and mentioning it as a foreign key in another table, we can establish relations between two tables. A certain table can be related to any finite number of tables. The relations can be 1:1, which means that each row of the second table is uniquely related to one row of the first table, or 1 :N, N:1, or N: M. An example of relations is as follows:</p>
			<div>
				<div id="_idContainer252" class="IMG---Figure">
					<img src="Images/C11065_08_04.jpg" alt="Figure 8.4 Diagram showing relations" width="1032" height="410"/>
				</div>
			</div>
			<h6>Figure 8.4 Diagram showing relations</h6>
			<p>With this brief refresher, we are now ready to jump into hands-on exercises and write some SQL to store and retrieve data.</p>
			<h2 id="_idParaDest-251">Usin<a id="_idTextAnchor298"/>g an RDBMS (MySQL/PostgreSQL/SQLite)</h2>
			<p>In this topic, we will focus on how to write some basic SQL commands, as well as how to connect to a database from Python and use it effectively within Python. The database we will choose here is SQLite. There are other databases, such as <strong class="inline">Oracle</strong>, <strong class="inline">MySQL</strong>, <strong class="inline">Postgresql</strong>, and <strong class="inline">DB2</strong>. The main tricks that you are going to learn here will not change based on what database you are using. But for different databases, you will need to install different third-party Python libraries (such as <strong class="inline">Psycopg2</strong> for <strong class="inline">Postgresql</strong>, and so on). The reason they all behave the same way (apart for some small details) is the fact that they all adhere to <strong class="inline">PEP249</strong> (commonly known as Python DB API 2). </p>
			<p>This is a good standardization and saves us a lot of headaches while porting from one RDBMS to another.</p>
			<h4>Note</h4>
			<p class="callout">Most of the industry standard projects which are written in Python and use some kind of RDBMS as the data store, most often relay on an ORM or Object Relational Mapper. An ORM is a high-level library in Python which makes many tasks, while dealing with RDBMS, easier. It also exposes a more Pythonic API than writing raw SQL inside Python code.</p>
			<h3 id="_idParaDest-252">Exer<a id="_idTextAnchor299"/><a id="_idTextAnchor300"/>cise 107: Connecting to Database in SQLite</h3>
			<p>In this exercise, we will look into the first step toward using a RDBMS in Python code. All we are going to do is connect to a database and then close the connection. We will also learn about the best way to do this:</p>
			<ol>
				<li>Import the <strong class="inline">sqlite3</strong> library of Python by using the following command:<p class="snippet">import sqlite3</p></li>
				<li>Use the <strong class="inline">connect</strong> function to connect to a database. If you already have some experience with databases, then you will notice that we are not using any <strong class="inline">server address</strong>, <strong class="inline">user name</strong>, <strong class="inline">password</strong>, or other credentials to connect to a database. This is because these fields are not mandatory in <strong class="inline">sqlite3,</strong> unlike in <strong class="inline">Postgresql</strong> or <strong class="inline">MySQL</strong>. The main database engine of SQLite is embedded:<p class="snippet">conn = sqlite3.connect("chapter.db")</p></li>
				<li>Close the connection, as follows:<p class="snippet">conn.close()</p><p>This <strong class="inline">conn</strong> object is the main connection object, and we will need that to get a second type of object in the future once we want to interact with the database. We need to be careful about closing any open connection to our database.</p></li>
				<li>Use the same <strong class="inline">with</strong> statement from Python, just like we did for files, and connect to the database, as follows:<p class="snippet">with sqlite3.connect("chapter.db") as conn:</p><p class="snippet">    pass</p></li>
			</ol>
			<p>In this exercise, we have connected to a database using Python.</p>
			<h3 id="_idParaDest-253">Exer<a id="_idTextAnchor301"/>cise 108: DDL and DML Commands in SQLite</h3>
			<p>In this exercise, we will look at how we can create a table, and we will also insert data in it.</p>
			<p>As the name suggests, DDL (Data Definition Language) is the way to communicate to the database engine in advance to define what the data will look like. The database engine creates a table object based on the definition provided and prepares it.</p>
			<p>To create a table in SQL, use the <strong class="inline">CREATE</strong> <strong class="inline">TABLE</strong> SQL clause. This will need the table name and the table definition. Table name is a unique identifier for the database engine to find and use the table for all future transactions. It can be anything (any alphanumeric string), as long as it is unique. We add the table definition in the form of (column_name_1 data_type, column_name_2 data type, … ). For our purpose, we will use the <strong class="inline">text</strong> and <strong class="inline">integer</strong> datatypes, but usually a standard database engine supports many more datatypes, such as float, double, date time, Boolean, and so on. We will also need to specify a primary key. A primary key is a unique, non-null identifier that's used to uniquely identify a row in a table. In our case, we use email as a primary key. A primary key can be an integer or text.</p>
			<p>The last thing you need to know is that unless you call a <strong class="inline">commit</strong> on the series of operations you just performed (together, we formally call them a <strong class="inline">transaction</strong>), nothing will be actually performed and reflected in the database. This property is called <strong class="keyword">atomicity</strong>. In fact, for a database to be industry standard (to be useable in real life), it needs to follow the ACID (Atomicity, Consistency, Isolation, Durability) properties:</p>
			<ol>
				<li value="1">Use SQLite's <strong class="inline">connect</strong> function to connect to the <strong class="inline">chapter.db</strong> database, as follows:<p class="snippet">with sqlite3.connect("chapter.db") as conn:</p><h4>Note</h4><p class="callout">This code will work once you add the snippet from step 3.</p></li>
				<li>Create a cursor object by calling <strong class="inline">conn.cursor()</strong>. The cursor object acts as a medium to communicate with the database. Create a table in Python, as follows:<p class="snippet">    cursor = conn.cursor()</p><p class="snippet">    cursor.execute("CREATE TABLE IF NOT EXISTS user (email text, first_name text, last_name text, address text, age integer, PRIMARY KEY (email))")</p></li>
				<li>Insert rows into the database that you created, as follows:<p class="snippet">cursor.execute("INSERT INTO user VALUES ('bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasy City', 31)")</p><p class="snippet">cursor.execute("INSERT INTO user VALUES ('tom@web.com', 'Tom', 'Fake', '456 Fantasy lane, Fantasu City', 39)")</p></li>
				<li>Commit to the database:<p class="snippet">conn.commit()</p></li>
			</ol>
			<p>This will create the table and write two rows to it with data.</p>
			<h3 id="_idParaDest-254">Read<a id="_idTextAnchor302"/><a id="_idTextAnchor303"/>ing Data from a Database in SQLite</h3>
			<p>In the preceding exercise, we created a table and stored data in it. Now, we will learn how to read the data that's stored in this database.</p>
			<p>The <strong class="inline">SELECT</strong> clause is immensely powerful, and it is really important for a data practitioner to master <strong class="inline">SELECT</strong> and everything related to it (such as conditions, joins, group-by, and so on).</p>
			<p>The <em class="italics">*</em> after <strong class="inline">SELECT</strong> tells the engine to select all of the columns from the table. It is a useful shorthand. We have not mentioned any condition for the selection (such as above a certain age, first name starting with a certain sequence of letters, and so on). We are practically telling the database engine to select all the rows and all the columns from the table. It is time-consuming and less effective if we have a huge table. Hence, we would want to use the <strong class="inline">LIMIT</strong> clause to limit the number of rows we want.</p>
			<p>You can use the <strong class="inline">SELECT</strong> clause in SQL to retrieve data, as follows:</p>
			<p class="snippet">with sqlite3.connect("chapter.db") as conn:</p>
			<p class="snippet">    cursor = conn.cursor()</p>
			<p class="snippet">    rows = cursor.execute('SELECT * FROM user')</p>
			<p class="snippet">    for row in rows:</p>
			<p class="snippet">        print(row)</p>
			<p>The output is as follows:</p>
			<div>
				<div id="_idContainer253" class="IMG---Figure">
					<img src="Images/Image61892.jpg" alt="" width="558" height="42"/>
				</div>
			</div>
			<h6>Figure 8.5: Output of the SELECT clause</h6>
			<p>The syntax to use the <strong class="inline">SELECT</strong> clause with a <strong class="inline">LIMIT</strong> as follows:</p>
			<p class="snippet">SELECT * FROM &lt;table_name&gt; LIMIT 50;</p>
			<h4>Note</h4>
			<p class="callout">This syntax is a sample code and  will not work on Jupyter notebook.</p>
			<p>This will select all the columns, but only the first 50 rows from the table.</p>
			<h3 id="_idParaDest-255">Exerc<a id="_idTextAnchor304"/>ise 109: Sorting Values that are Present in the Database</h3>
			<p>In this exercise, we will use the <strong class="inline">ORDER BY</strong> clause to sort the rows of user table with respect to age:</p>
			<ol>
				<li value="1">Sort the <strong class="inline">chapter.db</strong> by <strong class="inline">age</strong> in descending order, as follows:<p class="snippet">with sqlite3.connect("chapter.db") as conn:</p><p class="snippet">    cursor = conn.cursor()</p><p class="snippet">    rows = cursor.execute('SELECT * FROM user ORDER BY age DESC')</p><p class="snippet">    for row in rows:</p><p class="snippet">        print(row)</p><p>The output is as follows:</p><div id="_idContainer254" class="IMG---Figure"><img src="Images/Image61902.jpg" alt="" width="621" height="38"/></div><h6>Figure 8.6: Output of data displaying age in descending order</h6></li>
				<li>Sort the <strong class="inline">chapter.db</strong> by <strong class="inline">age</strong> in ascending order, as follows:<p class="snippet">with sqlite3.connect("chapter.db") as conn:</p><p class="snippet">    cursor = conn.cursor()</p><p class="snippet">    rows = cursor.execute('SELECT * FROM user ORDER BY age')</p><p class="snippet">    for row in rows:</p><p class="snippet">        print(row)</p></li>
				<li>The output is as follows:</li>
			</ol>
			<div>
				<div id="_idContainer255" class="IMG---Figure">
					<img src="Images/Image61910.jpg" alt="" width="626" height="46"/>
				</div>
			</div>
			<h6>Figure 8.7: Output of data displaying age in ascending order</h6>
			<p>Notice that we don't need to specify the order as <strong class="inline">ASC</strong> to sort it into ascending order.</p>
			<h3 id="_idParaDest-256">Exercis<a id="_idTextAnchor305"/><a id="_idTextAnchor306"/>e 110: Altering the Structure of a Table and Updating the New Fields</h3>
			<p>In this exercise, we are going to add a column using <strong class="inline">ALTER</strong> and <strong class="inline">UPDATE</strong> the values in the newly added column.</p>
			<p>The <strong class="inline">UPDATE</strong> command is used to edit/update any row after it has been inserted. Be careful when using it because using <strong class="inline">UPDATE</strong> without selective clauses (such as <strong class="inline">WHERE</strong>) affects the entire table:</p>
			<ol>
				<li value="1">Establish the connection with the database by using the following command:<p class="snippet">with sqlite3.connect("chapter.db") as conn:</p><p class="snippet">    cursor = conn.cursor()</p></li>
				<li>Add another column in the <strong class="inline">user</strong> table and fill it with <strong class="inline">null</strong> values by using the following command:<p class="snippet">cursor.execute("ALTER TABLE user ADD COLUMN gender text")</p></li>
				<li>Update all of the values of <strong class="inline">gender</strong> so that they are <strong class="inline">M</strong> by using the following command:<p class="snippet">cursor.execute("UPDATE user SET gender='M'")</p><p class="snippet">conn.commit()</p></li>
				<li>To check the altered table, execute the following command:<p class="snippet">rows = cursor.execute('SELECT * FROM user')</p><p class="snippet">for row in rows:</p><p class="snippet">        print(row)</p></li>
			</ol>
			<div>
				<div id="_idContainer256" class="IMG---Figure">
					<img src="Images/Image61918.jpg" alt="" width="598" height="45"/>
				</div>
			</div>
			<h6>Figure 8.8: Output after altering the table</h6>
			<p>We have updated the entire table by setting the gender of all the users as <strong class="inline">M</strong>, where <strong class="inline">M</strong> stands for male.</p>
			<h3 id="_idParaDest-257">Exercise<a id="_idTextAnchor307"/> 111: Grouping Values in Tables</h3>
			<p>In this exercise, we will learn about a concept that we have already learned about in pandas. This is the <strong class="inline">GROUP</strong> <strong class="inline">BY</strong> clause. The <strong class="inline">GROUP</strong> <strong class="inline">BY</strong> clause is a technique that's used to retrieve distinct values from the database and place them in  individual buckets.</p>
			<p>The following diagram explains how the GROUP BY clause works:</p>
			<div>
				<div id="_idContainer257" class="IMG---Figure">
					<img src="Images/Image61926.jpg" alt="" width="645" height="332"/>
				</div>
			</div>
			<h6>Figure 8.9: Illustration of the GROUP BY clause on a table</h6>
			<p>In the preceding diagram, we can see that the <strong class="inline">Col3</strong> column has only two unique values across all rows, A and B.</p>
			<p>The command that's used to check the total number of rows belonging to each group is as follows:</p>
			<p class="snippet">SELECT count(*), col3 FROM table1 GROUP BY col3</p>
			<p>Add female users to the table and group them based on the gender:</p>
			<ol>
				<li value="1">Add a female user to the table:<p class="snippet">cursor.execute("INSERT INTO user VALUES ('shelly@www.com', 'Shelly', 'Milar', '123, Ocean View Lane', 39, 'F')")</p></li>
				<li>Run the following code to see the count by each gender:<p class="snippet">rows = cursor.execute("SELECT COUNT(*), gender FROM user GROUP BY gender")</p><p class="snippet">for row in rows:</p><p class="snippet">        print(row)</p><p>The output is as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer258" class="IMG---Figure">
					<img src="Images/Image61935.jpg" alt="" width="1382" height="99"/>
				</div>
			</div>
			<h6>Figure 8.10: Output of the GROUP BY clause</h6>
			<h3 id="_idParaDest-258"><a id="_idTextAnchor308"/>Relation Mapping in Databases</h3>
			<p>We have been working with a single table and altering it, as well as reading back the data. However, the real power of an RDBMS comes from the handling of relationships among different objects (tables). In this section, we are going to create a new table called <strong class="inline">comments</strong> and link it with the user table in a 1: N relationship. This means that one user can have multiple comments. The way we are going to do this is by adding the <strong class="inline">user</strong> table's primary key as a foreign key in the <strong class="inline">comments</strong> table. This will create a 1: N relationship.</p>
			<p>When we link two tables, we need to specify to the database engine what should be done if the parent row is deleted, which has many children in the other table. As we can see in the following diagram, we are asking what happens at the place of the question marks when we delete row1 of the user table:</p>
			<div>
				<div id="_idContainer259" class="IMG---Figure">
					<img src="Images/Image61944.jpg" alt="" width="581" height="155"/>
				</div>
			</div>
			<h6>Figure 8.11: Illustration of relations</h6>
			<p>In a non-RDBMS situation, this situation can quickly become difficult and messy to manage and maintain. However, with an RDBMS, all we have to tell the database engine, in very precise ways, is what to do when a situation like this occurs. The database engine will do the rest for us. We use <strong class="inline">ON</strong> <strong class="inline">DELETE</strong> to tell the engine what we do with all the rows of a table when the parent row gets deleted. The following code illustrates these concepts:</p>
			<p class="snippet">with sqlite3.connect("chapter.db") as conn:</p>
			<p class="snippet">    cursor = conn.cursor()</p>
			<p class="snippet">    cursor.execute("PRAGMA foreign_keys = 1")</p>
			<p class="snippet">    sql = """</p>
			<p class="snippet">        CREATE TABLE comments (</p>
			<p class="snippet">            user_id text,</p>
			<p class="snippet">            comments text,</p>
			<p class="snippet">            FOREIGN KEY (user_id) REFERENCES user (email) </p>
			<p class="snippet">            ON DELETE CASCADE ON UPDATE NO ACTION</p>
			<p class="snippet">        )</p>
			<p class="snippet">    """</p>
			<p class="snippet">    cursor.execute(sql)</p>
			<p class="snippet">    conn.commit()</p>
			<p>The <strong class="inline">ON</strong> <strong class="inline">DELETE</strong> <strong class="inline">CASCADE</strong> line informs the database engine that we want to delete all the children rows when the parent gets deleted. We can also define actions for <strong class="inline">UPDATE</strong>. In this case, there is nothing to do on <strong class="inline">UPDATE</strong>.</p>
			<p>The <strong class="inline">FOREIGN KEY</strong> modifier modifies a column definition (<strong class="inline">user_id</strong>, in this case) and marks it as a foreign key, which is related to the primary key (<strong class="inline">email</strong>, in this case) of another table.</p>
			<p>You may notice the strange looking <strong class="inline">cursor.execute("PRAGMA foreign_keys = 1")</strong> line in the code. It is there just because SQLite does not use the normal foreign key features by default. It is this line that enables that feature. It is typical to SQLite and we won't need it for any other databases.</p>
			<h3 id="_idParaDest-259">Adding Rows<a id="_idTextAnchor309"/><a id="_idTextAnchor310"/> in the comments Table</h3>
			<p>We have created a table called comments. In this section, we will dynamically generate an insert query, as follows:</p>
			<p class="snippet">with sqlite3.connect("chapter.db") as conn:</p>
			<p class="snippet">    cursor = conn.cursor()</p>
			<p class="snippet">    cursor.execute("PRAGMA foreign_keys = 1")</p>
			<p class="snippet">    sql = "INSERT INTO comments VALUES ('{}', '{}')"</p>
			<p class="snippet">    rows = cursor.execute('SELECT * FROM user ORDER BY age')</p>
			<p class="snippet">    for row in rows:</p>
			<p class="snippet">        email = row[0]</p>
			<p class="snippet">        print("Going to create rows for {}".format(email))</p>
			<p class="snippet">        name = row[1] + " " + row[2]</p>
			<p class="snippet">        for i in range(10):</p>
			<p class="snippet">            comment = "This is comment {} by {}".format(i, name)</p>
			<p class="snippet">            conn.cursor().execute(sql.format(email, comment))</p>
			<p class="snippet">    conn.commit()</p>
			<p>Pay attention to how we dynamically generate the insert query so that we can insert 10 comments for each user.</p>
			<h3 id="_idParaDest-260"><a id="_idTextAnchor311"/>Joins</h3>
			<p>In this exercise, we will learn how to exploit the relationship we just built. This means that if we have the primary key from one table, we can recover all the data needed from that table and also all the linked rows from the child table. To achieve this, we will use something called a <strong class="keyword">join</strong>.</p>
			<p>A join is basically a way to retrieve linked rows from two tables using any kind of primary key - foreign key relation that they have. There are many types of join, such as <strong class="inline">INNER</strong>, <strong class="inline">LEFT OUTER</strong>, <strong class="inline">RIGHT OUTER</strong>, <strong class="inline">FULL OUTER</strong>, and <strong class="inline">CROSS</strong>. They are used in different situations. However, most of the time, in simple 1: N relations, we end up using an <strong class="inline">INNER</strong> join. In <em class="italics">Chapter 1: Introduction to Data Wrangling with Python</em>, we learned about sets, then we can view an <strong class="inline">INNER</strong> <strong class="inline">JOIN</strong> as an intersection of two sets. The following diagram illustrate the concepts:</p>
			<div>
				<div id="_idContainer260" class="IMG---Figure">
					<img src="Images/Image61953.jpg" alt="" width="1800" height="596"/>
				</div>
			</div>
			<h6>Figure 8.12: Intersection Join</h6>
			<p>Here, A represents one table and B represents another. The meaning of having common members is to have a relationship between them. It takes all of the rows of A and compares them with all of the rows of B to find the matching rows that satisfy the join predicate. This can quickly become a complex and time-consuming operation. Joins can be very expensive operations. Usually, we use some kind of <strong class="inline">where</strong> clause, after we specify the join, to shorten the scope of rows that are fetched from table A or B to perform the matching.</p>
			<p>In our case, our first table, <strong class="inline">user</strong>, has three entries, with the primary key being the <strong class="inline">email</strong>. We can make use of this in our query  to get comments just from <strong class="inline">Bob</strong>:</p>
			<p class="snippet">with sqlite3.connect("chapter.db") as conn:</p>
			<p class="snippet">    cursor = conn.cursor()s</p>
			<p class="snippet">    cursor.execute("PRAGMA foreign_keys = 1")</p>
			<p class="snippet">    sql = """</p>
			<p class="snippet">        SELECT * FROM comments </p>
			<p class="snippet">        JOIN user ON comments.user_id = user.email</p>
			<p class="snippet">        WHERE user.email='bob@example.com'</p>
			<p class="snippet">    """</p>
			<p class="snippet">    rows = cursor.execute(sql)</p>
			<p class="snippet">    for row in rows:</p>
			<p class="snippet">        print(row)</p>
			<p>The output is as follows:</p>
			<p class="snippet">('bob@example.com', 'This is comment 0 by Bob Codd', 'bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasu City', 31, None)</p>
			<p class="snippet">('bob@example.com', 'This is comment 1 by Bob Codd', 'bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasu City', 31, None)</p>
			<p class="snippet">('bob@example.com', 'This is comment 2 by Bob Codd', 'bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasu City', 31, None)</p>
			<p class="snippet">('bob@example.com', 'This is comment 3 by Bob Codd', 'bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasu City', 31, None)</p>
			<p class="snippet">('bob@example.com', 'This is comment 4 by Bob Codd', 'bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasu City', 31, None)</p>
			<p class="snippet">('bob@example.com', 'This is comment 5 by Bob Codd', 'bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasu City', 31, None)</p>
			<p class="snippet">('bob@example.com', 'This is comment 6 by Bob Codd', 'bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasu City', 31, None)</p>
			<p class="snippet">('bob@example.com', 'This is comment 7 by Bob Codd', 'bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasu City', 31, None)</p>
			<p class="snippet">('bob@example.com', 'This is comment 8 by Bob Codd', 'bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasu City', 31, None)</p>
			<p class="snippet">('bob@example.com', 'This is comment 9 by Bob Codd', 'bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasu City', 31, None)</p>
			<h6>Figure 8.13: Output of the Join query</h6>
			<h3 id="_idParaDest-261"><a id="_idTextAnchor312"/>Retrieving Specific Columns from a JOIN query</h3>
			<p>In the previous exercise, we saw that we can use a JOIN to fetch the related rows from two tables. However, if we look at the results, we will see that it returned all the columns, thus combining both tables. This is not very concise. What about if we only want to see the emails and the related comments, and not all the data?</p>
			<p>There is some nice shorthand code that lets us do this:</p>
			<p class="snippet">with sqlite3.connect("chapter.db") as conn:</p>
			<p class="snippet">    cursor = conn.cursor()</p>
			<p class="snippet">    cursor.execute("PRAGMA foreign_keys = 1")</p>
			<p class="snippet">    sql = """</p>
			<p class="snippet">        SELECT comments.* FROM comments</p>
			<p class="snippet">        JOIN user ON comments.user_id = user.email</p>
			<p class="snippet">        WHERE user.email='bob@example.com'</p>
			<p class="snippet">    """</p>
			<p class="snippet">    rows = cursor.execute(sql)</p>
			<p class="snippet">    for row in rows:</p>
			<p class="snippet">        print(row)</p>
			<p>Just by changing the <strong class="inline">SELECT</strong> statement, we made our final result look as follows:</p>
			<p class="snippet">('bob@example.com', 'This is comment 0 by Bob Codd')</p>
			<p class="snippet">('bob@example.com', 'This is comment 1 by Bob Codd')</p>
			<p class="snippet">('bob@example.com', 'This is comment 2 by Bob Codd')</p>
			<p class="snippet">('bob@example.com', 'This is comment 3 by Bob Codd')</p>
			<p class="snippet">('bob@example.com', 'This is comment 4 by Bob Codd')</p>
			<p class="snippet">('bob@example.com', 'This is comment 5 by Bob Codd')</p>
			<p class="snippet">('bob@example.com', 'This is comment 6 by Bob Codd')</p>
			<p class="snippet">('bob@example.com', 'This is comment 7 by Bob Codd')</p>
			<p class="snippet">('bob@example.com', 'This is comment 8 by Bob Codd')</p>
			<p class="snippet">('bob@example.com', 'This is comment 9 by Bob Codd')</p>
			<h3 id="_idParaDest-262"><a id="_idTextAnchor313"/>Exercise 112: Deleting Rows</h3>
			<p>In this exercise, we are going to delete a row from the user table and observe the effects it will have on the <strong class="inline">comments</strong> table. Be very careful when running this command as it can have a destructive effect on the data. Please keep in mind that it has to almost always be run accompanied by a <strong class="inline">WHERE</strong> clause so that we delete just a part of the data and not everything:</p>
			<ol>
				<li value="1">To delete a row from a table, we use the <strong class="inline">DELETE</strong> clause in <strong class="inline">SQL</strong>. To run delete on the <strong class="inline">user</strong> table, we are going to use the following code:<p class="snippet">with sqlite3.connect("chapter.db") as conn:</p><p class="snippet">    cursor = conn.cursor()</p><p class="snippet">    cursor.execute("PRAGMA foreign_keys = 1")</p><p class="snippet">    cursor.execute("DELETE FROM user WHERE email='bob@example.com'")</p><p class="snippet">    conn.commit()</p></li>
				<li>Perform the <strong class="inline">SELECT</strong> operation on the user table:<p class="snippet">with sqlite3.connect("chapter.db") as conn:</p><p class="snippet">    cursor = conn.cursor()</p><p class="snippet">    cursor.execute("PRAGMA foreign_keys = 1")</p><p class="snippet">    rows = cursor.execute("SELECT * FROM user")</p><p class="snippet">    for row in rows:</p><p class="snippet">        print(row)</p><p>Observe that the user Bob has been deleted.</p><p>Now, moving on to the <strong class="inline">comments</strong> table, we have to remember that we had mentioned <strong class="inline">ON DELETE CASCADE</strong> while creating the table. The database engine knows that if a row is deleted from the parent table (<strong class="inline">user</strong>), all the related rows from the child tables (<strong class="inline">comments</strong>) will have to be deleted.</p></li>
				<li>Perform a select operation on the comments table by using the following command:<p class="snippet">with sqlite3.connect("chapter.db") as conn:</p><p class="snippet">    cursor = conn.cursor()</p><p class="snippet">    cursor.execute("PRAGMA foreign_keys = 1")</p><p class="snippet">    rows = cursor.execute("SELECT * FROM comments")</p><p class="snippet">    for row in rows:</p><p class="snippet">        print(row)</p><p>The output is as follows:</p><p class="snippet">('tom@web.com', 'This is comment 0 by Tom Fake')</p><p class="snippet">('tom@web.com', 'This is comment 1 by Tom Fake')</p><p class="snippet">('tom@web.com', 'This is comment 2 by Tom Fake')</p><p class="snippet">('tom@web.com', 'This is comment 3 by Tom Fake')</p><p class="snippet">('tom@web.com', 'This is comment 4 by Tom Fake')</p><p class="snippet">('tom@web.com', 'This is comment 5 by Tom Fake')</p><p class="snippet">('tom@web.com', 'This is comment 6 by Tom Fake')</p><p class="snippet">('tom@web.com', 'This is comment 7 by Tom Fake')</p><p class="snippet">('tom@web.com', 'This is comment 8 by Tom Fake')</p><p class="snippet">('tom@web.com', 'This is comment 9 by Tom Fake')</p><p>We can see that all of the rows related to Bob are deleted.</p></li>
			</ol>
			<h3 id="_idParaDest-263">Updating Spe<a id="_idTextAnchor314"/><a id="_idTextAnchor315"/>cific Values in a Table</h3>
			<p>In this exercise, we will see how we can update rows in a table. We have already looked at this in the past but, as we mentioned, at a table level only. Without WHERE, updating is often a bad idea.</p>
			<p>Combine UPDATE with WHERE to selectively update the first name of the user with the email address <a href="mailto:tom@web.com"><strong class="inline">tom@web.com</strong></a><strong class="inline">:</strong></p>
			<p class="snippet">with sqlite3.connect("chapter.db") as conn:</p>
			<p class="snippet">    cursor = conn.cursor()</p>
			<p class="snippet">    cursor.execute("PRAGMA foreign_keys = 1")</p>
			<p class="snippet">    cursor.execute("UPDATE user set first_name='Chris' where email='tom@web.com'")</p>
			<p class="snippet">    conn.commit()</p>
			<p class="snippet">    rows = cursor.execute("SELECT * FROM user")</p>
			<p class="snippet">    for row in rows:</p>
			<p class="snippet">        print(row)</p>
			<p>The output is as follows:</p>
			<div>
				<div id="_idContainer261" class="IMG---Figure">
					<img src="Images/Image61961.jpg" alt="" width="1356" height="94"/>
				</div>
			</div>
			<h6>Figure 8.14: Output of the update query</h6>
			<h3 id="_idParaDest-264">Exercise 113:<a id="_idTextAnchor316"/><a id="_idTextAnchor317"/> RDBMS and DataFrames</h3>
			<p>We have looked into many fundamental aspects of storing and querying data from a database, but as a data wrangling expert, we need our data to be packed and presented as a DataFrame so that we can perform quick and convenient operations on them:</p>
			<ol>
				<li value="1">Import <strong class="inline">pandas</strong> using the following code:<p class="snippet">import pandas as pd</p></li>
				<li>Create a columns list with <strong class="inline">email</strong>, <strong class="inline">first name</strong>, <strong class="inline">last name</strong>, <strong class="inline">age</strong>, <strong class="inline">gender</strong>, and <strong class="inline">comments</strong> as column names. Also, create an empty data list:<p class="snippet">columns = ["Email", "First Name", "Last Name", "Age", "Gender", "Comments"]</p><p class="snippet">data = []</p></li>
				<li>Connect to <strong class="inline">chapter.db</strong> using <strong class="inline">SQLite</strong> and obtain a cursor, as follows:<p class="snippet">with sqlite3.connect("chapter.db") as conn:</p><p class="snippet">    cursor = conn.cursor()</p><p class="snippet">Use the execute method from the cursor to set "PRAGMA foreign_keys = 1"</p><p class="snippet">    cursor.execute("PRAGMA foreign_keys = 1")</p></li>
				<li>Create a <strong class="inline">sql</strong> variable that will contain the <strong class="inline">SELECT</strong> command and use the <strong class="inline">join</strong> command to join the databases:<p class="snippet">sql = """</p><p class="snippet">        SELECT user.email, user.first_name, user.last_name, user.age, user.gender, comments.comments FROM comments</p><p class="snippet">        JOIN user ON comments.user_id = user.email</p><p class="snippet">        WHERE user.email = 'tom@web.com'</p><p class="snippet">    """</p></li>
				<li>Use the <strong class="inline">execute</strong> method of cursor to execute the <strong class="inline">sql</strong> command:<p class="snippet">    rows = cursor.execute(sql)</p></li>
				<li>Append the rows to the data list:<p class="snippet">    for row in rows:</p><p class="snippet">        data.append(row)</p></li>
				<li>Create a DataFrame using the data list:<p class="snippet">df = pd.DataFrame(data, columns=columns)</p></li>
				<li>We have created the DataFrame using the data list. You can print the values into the DataFrame using <strong class="inline">df.head</strong>.</li>
			</ol>
			<h3 id="_idParaDest-265"><a id="_idTextAnchor318"/>Activity 11: Retrieving Data Correctly From Databases</h3>
			<p>In this activity, we have the persons table:</p>
			<div>
				<div id="_idContainer262" class="IMG---Figure">
					<img src="Images/Image61971.jpg" alt="" width="997" height="314"/>
				</div>
			</div>
			<h6>Figure 8.15: The persons table</h6>
			<p>We have the pets table:</p>
			<div>
				<div id="_idContainer263" class="IMG---Figure">
					<img src="Images/Image61987.jpg" alt="" width="934" height="322"/>
				</div>
			</div>
			<h6>Figure 8.16: The pets table</h6>
			<p>As we can see, the <strong class="inline">id</strong> column in the persons table (which is an integer) serves as the primary key for that table and as a foreign key for the pet table, which is linked via the <strong class="inline">owner_id</strong> column.</p>
			<p>The persons table has the following columns:</p>
			<ul>
				<li><strong class="inline">first_name</strong>: The first name of the person</li>
				<li><strong class="inline">last_name</strong>: The last name of the person (can be "null")</li>
				<li><strong class="inline">age</strong>: The age of the person</li>
				<li><strong class="inline">city</strong>: The city from where he/she is from</li>
				<li><strong class="inline">zip_code</strong>: The zip code of the city</li>
			</ul>
			<p>The pets table has the following columns:</p>
			<ul>
				<li><strong class="inline">pet_name</strong>: The name of the pet.</li>
				<li><strong class="inline">pet_type</strong>: What type of pet it is, for example, cat, dog, and so on. Due to a lack of further information, we do not know which number represents what, but it is an integer and can be null.</li>
				<li><strong class="inline">treatment_done</strong>: It is also an integer column, and 0 here represents "No", whereas 1 represents "Yes".</li>
			</ul>
			<p>The name of the SQLite DB is <strong class="inline">petsdb</strong> and it is supplied along with the Activity notebook.</p>
			<p>These steps will help you complete this activity:</p>
			<ol>
				<li value="1">Connect to <strong class="inline">petsDB</strong> and check whether the connection has been successful.</li>
				<li>Find the different age groups in the persons database.</li>
				<li>Find the age group that has the maximum number of people.</li>
				<li>Find the people who do not have a last name.</li>
				<li>Find out how many people have more than one pet.</li>
				<li>Find out how many pets have received treatment.</li>
				<li>Find out how many pets have received treatment and the type of pet is known.</li>
				<li>Find out how many pets are from the city called <strong class="inline">east port</strong>.</li>
				<li>Find out how many pets are from the city called <strong class="inline">east port</strong> and who received a treatment.<h4>Note</h4><p class="callout">The solution for this activity can be found on page 324.</p></li>
			</ol>
			<h2 id="_idParaDest-266"><a id="_idTextAnchor319"/>Summary</h2>
			<p>We have come to the end of the database chapter. We have learned how to connect to SQLite using Python. We have brushed up on the basics of relational databases and learned how to open and close a database. We then learned how to export this relational database into Python DataFrames.</p>
			<p>In the next chapter, we will be performing data wrangling on real-world datasets.</p>
		</div>
	</div>



  </body></html>