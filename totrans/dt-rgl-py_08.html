<html><head></head><body><div><div><h1 id="_idParaDest-245"><em class="italics"><a id="_idTextAnchor292"/>Chapter 8</em></h1>
		</div>
		<div><h1 id="_idParaDest-246"><a id="_idTextAnchor293"/>RDBMS and SQL</h1>
		</div>
		<div><h2>Learning Objectives</h2>
			<p>By the end of this chapter, you will be able to:</p>
			<ul>
				<li class="bullets">Apply the basics of RDBMS to query databases using Python</li>
				<li class="bullets">Convert data from SQL into a pandas DataFrame</li>
			</ul>
			<p>This chapter explains the concepts of databases, including their creation, manipulation and control, and transforming tables into pandas DataFrames.</p>
		</div>
		<div><h2 id="_idParaDest-247"><a id="_idTextAnchor294"/>Introduction</h2>
			<p>This chapter of our data journey is focused on <strong class="keyword">RDBMS</strong> (Relational Database Management Systems) and <strong class="keyword">SQL</strong> (Structured Query Language). In the previous chapter, we stored and read data from a file. In this chapter, we will read structured data, design access to the data, and create query interfaces for databases.</p>
			<p>Data has been stored in RDBMS format for years. The reasons behind it are as follows:</p>
			<ul>
				<li>RDBMS is one of the safest ways to store, manage, and retrieve data.</li>
				<li>They are backed by a solid mathematical foundation (relational algebra and calculus) and they expose an efficient and intuitive declarative language – SQL – for easy interaction.</li>
				<li>Almost every language has a rich set of libraries to interact with different RDBMS and the tricks and methods of using them are well tested and well understood.</li>
				<li>Scaling an RDBMS is a pretty well-understood task and there are a bunch of well trained, experienced professionals to do this job (DBA or database administrator).</li>
			</ul>
			<p>As we can see in the following chart, the market of DBMS is big. This chart was produced based on market research that was done by <strong class="bold">Gartner, Inc.</strong> in <strong class="bold">2016</strong>:</p>
			<div><div><img src="img/C11065_08_01.jpg" alt="Figure 8.1 Commercial database market share in 2016" width="1029" height="476"/>
				</div>
			</div>
			<h6>Figure 8.1 Commercial database market share in 2016</h6>
			<p>We will learn and play around with some basic and fundamental concepts of database and database management systems in this chapter.</p>
			<h2 id="_idParaDest-248">R<a id="_idTextAnchor295"/>efresher of RDBMS and SQL</h2>
			<p>An RDBMS is a piece of software that manages data (represented for the end user in a tabular form) on physical hard disks and is built using the Codd's relational model. Most of the databases that we encounter today are RDBMS. In recent years, there has been a huge industry shift toward a newer kind of database management system, called <strong class="keyword">NoSQL</strong> (<strong class="keyword">MongoDB</strong>, <strong class="keyword">CouchDB</strong>, <strong class="keyword">Riak</strong>, and so on). These systems, although in some aspects they follow some of the rules of RDBMS, in most cases reject or modify them.</p>
			<h3 id="_idParaDest-249"><a id="_idTextAnchor296"/>How is an RDBMS Structured?</h3>
			<p>The RDBMS structure consists of three main elements, namely the storage engine, query engine, and log management. Here is a diagram that shows the structure of a RDBMS:</p>
			<div><div><img src="img/C11065_08_02.jpg" alt="Figure 8.2 RDBMS structure" width="1800" height="1369"/>
				</div>
			</div>
			<h6>Figure 8.2 RDBMS structure</h6>
			<p>The following are the main concepts of any RDBMS structure:</p>
			<ul>
				<li><strong class="keyword">Storage engine</strong>: This is the part of the RDBMS that is responsible for storing the data in an efficient way and also to give it back when asked for, in an efficient way. As an end user of the RDBMS system (an application developer is considered an end user of an RDBMS), we will never need to interact with this layer directly.</li>
				<li><strong class="keyword">Query engine</strong>: This is the part of the RDBMS that allows us to create data objects (tables, views, and so on), manipulate them (create and delete columns, create/delete/update rows, and so on), and query them (read rows) using a simple yet powerful language.</li>
				<li><strong class="keyword">Log management</strong>: This part of the RDBMS is responsible for creating and maintaining the logs. If you are wondering why the log is such an important thing, then you should look into how replication and partitions are handled in a modern RDBMS (such as PostgreSQL) using something called <strong class="keyword">Write Ahead Log</strong> (or WAL for short).</li>
			</ul>
			<p>We will focus on the query engine in this chapter.</p>
			<h3 id="_idParaDest-250"><a id="_idTextAnchor297"/>SQL</h3>
			<p><strong class="bold">S</strong>tructured <strong class="bold">Q</strong>uery <strong class="bold">L</strong>anguage or <strong class="keyword">SQL</strong> (pronounced sequel), as it is commonly known, is a domain-specific language that was originally designed based on E.F. Codd's relational model and is widely used in today's databases to define, insert, manipulate, and retrieve data from them. It can be further sub-divided into four smaller sub-languages, namely <strong class="bold">DDL</strong> (Data Definition Language), <strong class="bold">DML</strong> (Data Manipulation Language), <strong class="bold">DQL</strong> (Data Query Language), and <strong class="bold">DCL</strong> (Data Control Language). There are several advantages of using SQL, with some of them being as follows:</p>
			<ul>
				<li>It is based on a solid mathematical framework and thus it is easy to understand.</li>
				<li>It is a declarative language, which means that we actually never tell it how to do its job. We almost always tell it what to do. This frees us from a big burden of writing custom code for data management. We can be more focused on the actual query problem we are trying to solve instead of bothering about how to create and maintain a data store.</li>
				<li>It gives you a fast and readable way to deal with data.</li>
				<li>SQL gives you out-of-the-box ways to get multiple pieces of data with a single query.</li>
			</ul>
			<p>The main areas of focus for the following topic will be DDL, DML, and DQL. The DCL part is more for database administrators.</p>
			<ul>
				<li><code>CREATE</code> <code>TABLE</code> or <code>DROP</code> <code>TABLE</code> or <code>ALTER</code> <code>TABLE</code>. <h4>Note</h4><p class="callout">Notice the use of uppercase letters. It is not a specification and you can use lowercase letters, but it is a widely followed convention and we will use that in this book.</p></li>
				<li><code>INSERT</code> <code>INTO</code>, <code>DELETE</code> <code>FROM</code>, or <code>UPDATE</code>.</li>
				<li><code>SELECT</code> command. We will also see and use the concepts of the primary key, foreign key, index, joins, and so on.</li>
			</ul>
			<p>Once you define and insert data in a database, it can be represented as follows:</p>
			<div><div><img src="img/C11065_08_03.jpg" alt="Figure 8.3 Table displaying sample data" width="686" height="271"/>
				</div>
			</div>
			<h6>Figure 8.3 Table displaying sample data</h6>
			<p>Another thing to remember about RDBMS is relations. Generally, in a table, we have one or more columns that will have unique values for each row in the table. We call them <strong class="keyword">primary keys</strong> for the table. We should be aware that we will encounter unique values across the rows, which are not primary keys. The main difference between them and primary keys is the fact that a primary key cannot be null.</p>
			<p>By using the primary key of one table and mentioning it as a foreign key in another table, we can establish relations between two tables. A certain table can be related to any finite number of tables. The relations can be 1:1, which means that each row of the second table is uniquely related to one row of the first table, or 1 :N, N:1, or N: M. An example of relations is as follows:</p>
			<div><div><img src="img/C11065_08_04.jpg" alt="Figure 8.4 Diagram showing relations" width="1032" height="410"/>
				</div>
			</div>
			<h6>Figure 8.4 Diagram showing relations</h6>
			<p>With this brief refresher, we are now ready to jump into hands-on exercises and write some SQL to store and retrieve data.</p>
			<h2 id="_idParaDest-251">Usin<a id="_idTextAnchor298"/>g an RDBMS (MySQL/PostgreSQL/SQLite)</h2>
			<p>In this topic, we will focus on how to write some basic SQL commands, as well as how to connect to a database from Python and use it effectively within Python. The database we will choose here is SQLite. There are other databases, such as <code>Oracle</code>, <code>MySQL</code>, <code>Postgresql</code>, and <code>DB2</code>. The main tricks that you are going to learn here will not change based on what database you are using. But for different databases, you will need to install different third-party Python libraries (such as <code>Psycopg2</code> for <code>Postgresql</code>, and so on). The reason they all behave the same way (apart for some small details) is the fact that they all adhere to <code>PEP249</code> (commonly known as Python DB API 2). </p>
			<p>This is a good standardization and saves us a lot of headaches while porting from one RDBMS to another.</p>
			<h4>Note</h4>
			<p class="callout">Most of the industry standard projects which are written in Python and use some kind of RDBMS as the data store, most often relay on an ORM or Object Relational Mapper. An ORM is a high-level library in Python which makes many tasks, while dealing with RDBMS, easier. It also exposes a more Pythonic API than writing raw SQL inside Python code.</p>
			<h3 id="_idParaDest-252">Exer<a id="_idTextAnchor299"/><a id="_idTextAnchor300"/>cise 107: Connecting to Database in SQLite</h3>
			<p>In this exercise, we will look into the first step toward using a RDBMS in Python code. All we are going to do is connect to a database and then close the connection. We will also learn about the best way to do this:</p>
			<ol>
				<li>Import the <code>sqlite3</code> library of Python by using the following command:<pre>import sqlite3</pre></li>
				<li>Use the <code>connect</code> function to connect to a database. If you already have some experience with databases, then you will notice that we are not using any <code>server address</code>, <code>user name</code>, <code>password</code>, or other credentials to connect to a database. This is because these fields are not mandatory in <code>sqlite3,</code> unlike in <code>Postgresql</code> or <code>MySQL</code>. The main database engine of SQLite is embedded:<pre>conn = sqlite3.connect("chapter.db")</pre></li>
				<li>Close the connection, as follows:<pre>conn.close()</pre><p>This <code>conn</code> object is the main connection object, and we will need that to get a second type of object in the future once we want to interact with the database. We need to be careful about closing any open connection to our database.</p></li>
				<li>Use the same <code>with</code> statement from Python, just like we did for files, and connect to the database, as follows:<pre>with sqlite3.connect("chapter.db") as conn:
    pass</pre></li>
			</ol>
			<p>In this exercise, we have connected to a database using Python.</p>
			<h3 id="_idParaDest-253">Exer<a id="_idTextAnchor301"/>cise 108: DDL and DML Commands in SQLite</h3>
			<p>In this exercise, we will look at how we can create a table, and we will also insert data in it.</p>
			<p>As the name suggests, DDL (Data Definition Language) is the way to communicate to the database engine in advance to define what the data will look like. The database engine creates a table object based on the definition provided and prepares it.</p>
			<p>To create a table in SQL, use the <code>CREATE</code> <code>TABLE</code> SQL clause. This will need the table name and the table definition. Table name is a unique identifier for the database engine to find and use the table for all future transactions. It can be anything (any alphanumeric string), as long as it is unique. We add the table definition in the form of (column_name_1 data_type, column_name_2 data type, … ). For our purpose, we will use the <code>text</code> and <code>integer</code> datatypes, but usually a standard database engine supports many more datatypes, such as float, double, date time, Boolean, and so on. We will also need to specify a primary key. A primary key is a unique, non-null identifier that's used to uniquely identify a row in a table. In our case, we use email as a primary key. A primary key can be an integer or text.</p>
			<p>The last thing you need to know is that unless you call a <code>commit</code> on the series of operations you just performed (together, we formally call them a <code>transaction</code>), nothing will be actually performed and reflected in the database. This property is called <strong class="keyword">atomicity</strong>. In fact, for a database to be industry standard (to be useable in real life), it needs to follow the ACID (Atomicity, Consistency, Isolation, Durability) properties:</p>
			<ol>
				<li value="1">Use SQLite's <code>connect</code> function to connect to the <code>chapter.db</code> database, as follows:<pre>with sqlite3.connect("chapter.db") as conn:</pre><h4>Note</h4><p class="callout">This code will work once you add the snippet from step 3.</p></li>
				<li>Create a cursor object by calling <code>conn.cursor()</code>. The cursor object acts as a medium to communicate with the database. Create a table in Python, as follows:<pre>    cursor = conn.cursor()
    cursor.execute("CREATE TABLE IF NOT EXISTS user (email text, first_name text, last_name text, address text, age integer, PRIMARY KEY (email))")</pre></li>
				<li>Insert rows into the database that you created, as follows:<pre>cursor.execute("INSERT INTO user VALUES ('bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasy City', 31)")
cursor.execute("INSERT INTO user VALUES ('tom@web.com', 'Tom', 'Fake', '456 Fantasy lane, Fantasu City', 39)")</pre></li>
				<li>Commit to the database:<pre>conn.commit()</pre></li>
			</ol>
			<p>This will create the table and write two rows to it with data.</p>
			<h3 id="_idParaDest-254">Read<a id="_idTextAnchor302"/><a id="_idTextAnchor303"/>ing Data from a Database in SQLite</h3>
			<p>In the preceding exercise, we created a table and stored data in it. Now, we will learn how to read the data that's stored in this database.</p>
			<p>The <code>SELECT</code> clause is immensely powerful, and it is really important for a data practitioner to master <code>SELECT</code> and everything related to it (such as conditions, joins, group-by, and so on).</p>
			<p>The <em class="italics">*</em> after <code>SELECT</code> tells the engine to select all of the columns from the table. It is a useful shorthand. We have not mentioned any condition for the selection (such as above a certain age, first name starting with a certain sequence of letters, and so on). We are practically telling the database engine to select all the rows and all the columns from the table. It is time-consuming and less effective if we have a huge table. Hence, we would want to use the <code>LIMIT</code> clause to limit the number of rows we want.</p>
			<p>You can use the <code>SELECT</code> clause in SQL to retrieve data, as follows:</p>
			<pre>with sqlite3.connect("chapter.db") as conn:
    cursor = conn.cursor()
    rows = cursor.execute('SELECT * FROM user')
    for row in rows:
        print(row)</pre>
			<p>The output is as follows:</p>
			<div><div><img src="img/Image61892.jpg" alt="" width="558" height="42"/>
				</div>
			</div>
			<h6>Figure 8.5: Output of the SELECT clause</h6>
			<p>The syntax to use the <code>SELECT</code> clause with a <code>LIMIT</code> as follows:</p>
			<pre>SELECT * FROM &lt;table_name&gt; LIMIT 50;</pre>
			<h4>Note</h4>
			<p class="callout">This syntax is a sample code and  will not work on Jupyter notebook.</p>
			<p>This will select all the columns, but only the first 50 rows from the table.</p>
			<h3 id="_idParaDest-255">Exerc<a id="_idTextAnchor304"/>ise 109: Sorting Values that are Present in the Database</h3>
			<p>In this exercise, we will use the <code>ORDER BY</code> clause to sort the rows of user table with respect to age:</p>
			<ol>
				<li value="1">Sort the <code>chapter.db</code> by <code>age</code> in descending order, as follows:<pre>with sqlite3.connect("chapter.db") as conn:
    cursor = conn.cursor()
    rows = cursor.execute('SELECT * FROM user ORDER BY age DESC')
    for row in rows:
        print(row)</pre><p>The output is as follows:</p><div><img src="img/Image61902.jpg" alt="" width="621" height="38"/></div><h6>Figure 8.6: Output of data displaying age in descending order</h6></li>
				<li>Sort the <code>chapter.db</code> by <code>age</code> in ascending order, as follows:<pre>with sqlite3.connect("chapter.db") as conn:
    cursor = conn.cursor()
    rows = cursor.execute('SELECT * FROM user ORDER BY age')
    for row in rows:
        print(row)</pre></li>
				<li>The output is as follows:</li>
			</ol>
			<div><div><img src="img/Image61910.jpg" alt="" width="626" height="46"/>
				</div>
			</div>
			<h6>Figure 8.7: Output of data displaying age in ascending order</h6>
			<p>Notice that we don't need to specify the order as <code>ASC</code> to sort it into ascending order.</p>
			<h3 id="_idParaDest-256">Exercis<a id="_idTextAnchor305"/><a id="_idTextAnchor306"/>e 110: Altering the Structure of a Table and Updating the New Fields</h3>
			<p>In this exercise, we are going to add a column using <code>ALTER</code> and <code>UPDATE</code> the values in the newly added column.</p>
			<p>The <code>UPDATE</code> command is used to edit/update any row after it has been inserted. Be careful when using it because using <code>UPDATE</code> without selective clauses (such as <code>WHERE</code>) affects the entire table:</p>
			<ol>
				<li value="1">Establish the connection with the database by using the following command:<pre>with sqlite3.connect("chapter.db") as conn:
    cursor = conn.cursor()</pre></li>
				<li>Add another column in the <code>user</code> table and fill it with <code>null</code> values by using the following command:<pre>cursor.execute("ALTER TABLE user ADD COLUMN gender text")</pre></li>
				<li>Update all of the values of <code>gender</code> so that they are <code>M</code> by using the following command:<pre>cursor.execute("UPDATE user SET gender='M'")
conn.commit()</pre></li>
				<li>To check the altered table, execute the following command:<pre>rows = cursor.execute('SELECT * FROM user')
for row in rows:
        print(row)</pre></li>
			</ol>
			<div><div><img src="img/Image61918.jpg" alt="" width="598" height="45"/>
				</div>
			</div>
			<h6>Figure 8.8: Output after altering the table</h6>
			<p>We have updated the entire table by setting the gender of all the users as <code>M</code>, where <code>M</code> stands for male.</p>
			<h3 id="_idParaDest-257">Exercise<a id="_idTextAnchor307"/> 111: Grouping Values in Tables</h3>
			<p>In this exercise, we will learn about a concept that we have already learned about in pandas. This is the <code>GROUP</code> <code>BY</code> clause. The <code>GROUP</code> <code>BY</code> clause is a technique that's used to retrieve distinct values from the database and place them in  individual buckets.</p>
			<p>The following diagram explains how the GROUP BY clause works:</p>
			<div><div><img src="img/Image61926.jpg" alt="" width="645" height="332"/>
				</div>
			</div>
			<h6>Figure 8.9: Illustration of the GROUP BY clause on a table</h6>
			<p>In the preceding diagram, we can see that the <code>Col3</code> column has only two unique values across all rows, A and B.</p>
			<p>The command that's used to check the total number of rows belonging to each group is as follows:</p>
			<pre>SELECT count(*), col3 FROM table1 GROUP BY col3</pre>
			<p>Add female users to the table and group them based on the gender:</p>
			<ol>
				<li value="1">Add a female user to the table:<pre>cursor.execute("INSERT INTO user VALUES ('shelly@www.com', 'Shelly', 'Milar', '123, Ocean View Lane', 39, 'F')")</pre></li>
				<li>Run the following code to see the count by each gender:<pre>rows = cursor.execute("SELECT COUNT(*), gender FROM user GROUP BY gender")
for row in rows:
        print(row)</pre><p>The output is as follows:</p></li>
			</ol>
			<div><div><img src="img/Image61935.jpg" alt="" width="1382" height="99"/>
				</div>
			</div>
			<h6>Figure 8.10: Output of the GROUP BY clause</h6>
			<h3 id="_idParaDest-258"><a id="_idTextAnchor308"/>Relation Mapping in Databases</h3>
			<p>We have been working with a single table and altering it, as well as reading back the data. However, the real power of an RDBMS comes from the handling of relationships among different objects (tables). In this section, we are going to create a new table called <code>comments</code> and link it with the user table in a 1: N relationship. This means that one user can have multiple comments. The way we are going to do this is by adding the <code>user</code> table's primary key as a foreign key in the <code>comments</code> table. This will create a 1: N relationship.</p>
			<p>When we link two tables, we need to specify to the database engine what should be done if the parent row is deleted, which has many children in the other table. As we can see in the following diagram, we are asking what happens at the place of the question marks when we delete row1 of the user table:</p>
			<div><div><img src="img/Image61944.jpg" alt="" width="581" height="155"/>
				</div>
			</div>
			<h6>Figure 8.11: Illustration of relations</h6>
			<p>In a non-RDBMS situation, this situation can quickly become difficult and messy to manage and maintain. However, with an RDBMS, all we have to tell the database engine, in very precise ways, is what to do when a situation like this occurs. The database engine will do the rest for us. We use <code>ON</code> <code>DELETE</code> to tell the engine what we do with all the rows of a table when the parent row gets deleted. The following code illustrates these concepts:</p>
			<pre>with sqlite3.connect("chapter.db") as conn:
    cursor = conn.cursor()
    cursor.execute("PRAGMA foreign_keys = 1")
    sql = """
        CREATE TABLE comments (
            user_id text,
            comments text,
            FOREIGN KEY (user_id) REFERENCES user (email) 
            ON DELETE CASCADE ON UPDATE NO ACTION
        )
    """
    cursor.execute(sql)
    conn.commit()</pre>
			<p>The <code>ON</code> <code>DELETE</code> <code>CASCADE</code> line informs the database engine that we want to delete all the children rows when the parent gets deleted. We can also define actions for <code>UPDATE</code>. In this case, there is nothing to do on <code>UPDATE</code>.</p>
			<p>The <code>FOREIGN KEY</code> modifier modifies a column definition (<code>user_id</code>, in this case) and marks it as a foreign key, which is related to the primary key (<code>email</code>, in this case) of another table.</p>
			<p>You may notice the strange looking <code>cursor.execute("PRAGMA foreign_keys = 1")</code> line in the code. It is there just because SQLite does not use the normal foreign key features by default. It is this line that enables that feature. It is typical to SQLite and we won't need it for any other databases.</p>
			<h3 id="_idParaDest-259">Adding Rows<a id="_idTextAnchor309"/><a id="_idTextAnchor310"/> in the comments Table</h3>
			<p>We have created a table called comments. In this section, we will dynamically generate an insert query, as follows:</p>
			<pre>with sqlite3.connect("chapter.db") as conn:
    cursor = conn.cursor()
    cursor.execute("PRAGMA foreign_keys = 1")
    sql = "INSERT INTO comments VALUES ('{}', '{}')"
    rows = cursor.execute('SELECT * FROM user ORDER BY age')
    for row in rows:
        email = row[0]
        print("Going to create rows for {}".format(email))
        name = row[1] + " " + row[2]
        for i in range(10):
            comment = "This is comment {} by {}".format(i, name)
            conn.cursor().execute(sql.format(email, comment))
    conn.commit()</pre>
			<p>Pay attention to how we dynamically generate the insert query so that we can insert 10 comments for each user.</p>
			<h3 id="_idParaDest-260"><a id="_idTextAnchor311"/>Joins</h3>
			<p>In this exercise, we will learn how to exploit the relationship we just built. This means that if we have the primary key from one table, we can recover all the data needed from that table and also all the linked rows from the child table. To achieve this, we will use something called a <strong class="keyword">join</strong>.</p>
			<p>A join is basically a way to retrieve linked rows from two tables using any kind of primary key - foreign key relation that they have. There are many types of join, such as <code>INNER</code>, <code>LEFT OUTER</code>, <code>RIGHT OUTER</code>, <code>FULL OUTER</code>, and <code>CROSS</code>. They are used in different situations. However, most of the time, in simple 1: N relations, we end up using an <code>INNER</code> join. In <em class="italics">Chapter 1: Introduction to Data Wrangling with Python</em>, we learned about sets, then we can view an <code>INNER</code> <code>JOIN</code> as an intersection of two sets. The following diagram illustrate the concepts:</p>
			<div><div><img src="img/Image61953.jpg" alt="" width="1800" height="596"/>
				</div>
			</div>
			<h6>Figure 8.12: Intersection Join</h6>
			<p>Here, A represents one table and B represents another. The meaning of having common members is to have a relationship between them. It takes all of the rows of A and compares them with all of the rows of B to find the matching rows that satisfy the join predicate. This can quickly become a complex and time-consuming operation. Joins can be very expensive operations. Usually, we use some kind of <code>where</code> clause, after we specify the join, to shorten the scope of rows that are fetched from table A or B to perform the matching.</p>
			<p>In our case, our first table, <code>user</code>, has three entries, with the primary key being the <code>email</code>. We can make use of this in our query  to get comments just from <code>Bob</code>:</p>
			<pre>with sqlite3.connect("chapter.db") as conn:
    cursor = conn.cursor()s
    cursor.execute("PRAGMA foreign_keys = 1")
    sql = """
        SELECT * FROM comments 
        JOIN user ON comments.user_id = user.email
        WHERE user.email='bob@example.com'
    """
    rows = cursor.execute(sql)
    for row in rows:
        print(row)</pre>
			<p>The output is as follows:</p>
			<pre>('bob@example.com', 'This is comment 0 by Bob Codd', 'bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasu City', 31, None)
('bob@example.com', 'This is comment 1 by Bob Codd', 'bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasu City', 31, None)
('bob@example.com', 'This is comment 2 by Bob Codd', 'bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasu City', 31, None)
('bob@example.com', 'This is comment 3 by Bob Codd', 'bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasu City', 31, None)
('bob@example.com', 'This is comment 4 by Bob Codd', 'bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasu City', 31, None)
('bob@example.com', 'This is comment 5 by Bob Codd', 'bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasu City', 31, None)
('bob@example.com', 'This is comment 6 by Bob Codd', 'bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasu City', 31, None)
('bob@example.com', 'This is comment 7 by Bob Codd', 'bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasu City', 31, None)
('bob@example.com', 'This is comment 8 by Bob Codd', 'bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasu City', 31, None)
('bob@example.com', 'This is comment 9 by Bob Codd', 'bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasu City', 31, None)</pre>
			<h6>Figure 8.13: Output of the Join query</h6>
			<h3 id="_idParaDest-261"><a id="_idTextAnchor312"/>Retrieving Specific Columns from a JOIN query</h3>
			<p>In the previous exercise, we saw that we can use a JOIN to fetch the related rows from two tables. However, if we look at the results, we will see that it returned all the columns, thus combining both tables. This is not very concise. What about if we only want to see the emails and the related comments, and not all the data?</p>
			<p>There is some nice shorthand code that lets us do this:</p>
			<pre>with sqlite3.connect("chapter.db") as conn:
    cursor = conn.cursor()
    cursor.execute("PRAGMA foreign_keys = 1")
    sql = """
        SELECT comments.* FROM comments
        JOIN user ON comments.user_id = user.email
        WHERE user.email='bob@example.com'
    """
    rows = cursor.execute(sql)
    for row in rows:
        print(row)</pre>
			<p>Just by changing the <code>SELECT</code> statement, we made our final result look as follows:</p>
			<pre>('bob@example.com', 'This is comment 0 by Bob Codd')
('bob@example.com', 'This is comment 1 by Bob Codd')
('bob@example.com', 'This is comment 2 by Bob Codd')
('bob@example.com', 'This is comment 3 by Bob Codd')
('bob@example.com', 'This is comment 4 by Bob Codd')
('bob@example.com', 'This is comment 5 by Bob Codd')
('bob@example.com', 'This is comment 6 by Bob Codd')
('bob@example.com', 'This is comment 7 by Bob Codd')
('bob@example.com', 'This is comment 8 by Bob Codd')
('bob@example.com', 'This is comment 9 by Bob Codd')</pre>
			<h3 id="_idParaDest-262"><a id="_idTextAnchor313"/>Exercise 112: Deleting Rows</h3>
			<p>In this exercise, we are going to delete a row from the user table and observe the effects it will have on the <code>comments</code> table. Be very careful when running this command as it can have a destructive effect on the data. Please keep in mind that it has to almost always be run accompanied by a <code>WHERE</code> clause so that we delete just a part of the data and not everything:</p>
			<ol>
				<li value="1">To delete a row from a table, we use the <code>DELETE</code> clause in <code>SQL</code>. To run delete on the <code>user</code> table, we are going to use the following code:<pre>with sqlite3.connect("chapter.db") as conn:
    cursor = conn.cursor()
    cursor.execute("PRAGMA foreign_keys = 1")
    cursor.execute("DELETE FROM user WHERE email='bob@example.com'")
    conn.commit()</pre></li>
				<li>Perform the <code>SELECT</code> operation on the user table:<pre>with sqlite3.connect("chapter.db") as conn:
    cursor = conn.cursor()
    cursor.execute("PRAGMA foreign_keys = 1")
    rows = cursor.execute("SELECT * FROM user")
    for row in rows:
        print(row)</pre><p>Observe that the user Bob has been deleted.</p><p>Now, moving on to the <code>comments</code> table, we have to remember that we had mentioned <code>ON DELETE CASCADE</code> while creating the table. The database engine knows that if a row is deleted from the parent table (<code>user</code>), all the related rows from the child tables (<code>comments</code>) will have to be deleted.</p></li>
				<li>Perform a select operation on the comments table by using the following command:<pre>with sqlite3.connect("chapter.db") as conn:
    cursor = conn.cursor()
    cursor.execute("PRAGMA foreign_keys = 1")
    rows = cursor.execute("SELECT * FROM comments")
    for row in rows:
        print(row)</pre><p>The output is as follows:</p><pre>('tom@web.com', 'This is comment 0 by Tom Fake')
('tom@web.com', 'This is comment 1 by Tom Fake')
('tom@web.com', 'This is comment 2 by Tom Fake')
('tom@web.com', 'This is comment 3 by Tom Fake')
('tom@web.com', 'This is comment 4 by Tom Fake')
('tom@web.com', 'This is comment 5 by Tom Fake')
('tom@web.com', 'This is comment 6 by Tom Fake')
('tom@web.com', 'This is comment 7 by Tom Fake')
('tom@web.com', 'This is comment 8 by Tom Fake')
('tom@web.com', 'This is comment 9 by Tom Fake')</pre><p>We can see that all of the rows related to Bob are deleted.</p></li>
			</ol>
			<h3 id="_idParaDest-263">Updating Spe<a id="_idTextAnchor314"/><a id="_idTextAnchor315"/>cific Values in a Table</h3>
			<p>In this exercise, we will see how we can update rows in a table. We have already looked at this in the past but, as we mentioned, at a table level only. Without WHERE, updating is often a bad idea.</p>
			<p>Combine UPDATE with WHERE to selectively update the first name of the user with the email address <a href="mailto:tom@web.com"><code>tom@web.com</code></a><code>:</code></p>
			<pre>with sqlite3.connect("chapter.db") as conn:
    cursor = conn.cursor()
    cursor.execute("PRAGMA foreign_keys = 1")
    cursor.execute("UPDATE user set first_name='Chris' where email='tom@web.com'")
    conn.commit()
    rows = cursor.execute("SELECT * FROM user")
    for row in rows:
        print(row)</pre>
			<p>The output is as follows:</p>
			<div><div><img src="img/Image61961.jpg" alt="" width="1356" height="94"/>
				</div>
			</div>
			<h6>Figure 8.14: Output of the update query</h6>
			<h3 id="_idParaDest-264">Exercise 113:<a id="_idTextAnchor316"/><a id="_idTextAnchor317"/> RDBMS and DataFrames</h3>
			<p>We have looked into many fundamental aspects of storing and querying data from a database, but as a data wrangling expert, we need our data to be packed and presented as a DataFrame so that we can perform quick and convenient operations on them:</p>
			<ol>
				<li value="1">Import <code>pandas</code> using the following code:<pre>import pandas as pd</pre></li>
				<li>Create a columns list with <code>email</code>, <code>first name</code>, <code>last name</code>, <code>age</code>, <code>gender</code>, and <code>comments</code> as column names. Also, create an empty data list:<pre>columns = ["Email", "First Name", "Last Name", "Age", "Gender", "Comments"]
data = []</pre></li>
				<li>Connect to <code>chapter.db</code> using <code>SQLite</code> and obtain a cursor, as follows:<pre>with sqlite3.connect("chapter.db") as conn:
    cursor = conn.cursor()
Use the execute method from the cursor to set "PRAGMA foreign_keys = 1"
    cursor.execute("PRAGMA foreign_keys = 1")</pre></li>
				<li>Create a <code>sql</code> variable that will contain the <code>SELECT</code> command and use the <code>join</code> command to join the databases:<pre>sql = """
        SELECT user.email, user.first_name, user.last_name, user.age, user.gender, comments.comments FROM comments
        JOIN user ON comments.user_id = user.email
        WHERE user.email = 'tom@web.com'
    """</pre></li>
				<li>Use the <code>execute</code> method of cursor to execute the <code>sql</code> command:<pre>    rows = cursor.execute(sql)</pre></li>
				<li>Append the rows to the data list:<pre>    for row in rows:
        data.append(row)</pre></li>
				<li>Create a DataFrame using the data list:<pre>df = pd.DataFrame(data, columns=columns)</pre></li>
				<li>We have created the DataFrame using the data list. You can print the values into the DataFrame using <code>df.head</code>.</li>
			</ol>
			<h3 id="_idParaDest-265"><a id="_idTextAnchor318"/>Activity 11: Retrieving Data Correctly From Databases</h3>
			<p>In this activity, we have the persons table:</p>
			<div><div><img src="img/Image61971.jpg" alt="" width="997" height="314"/>
				</div>
			</div>
			<h6>Figure 8.15: The persons table</h6>
			<p>We have the pets table:</p>
			<div><div><img src="img/Image61987.jpg" alt="" width="934" height="322"/>
				</div>
			</div>
			<h6>Figure 8.16: The pets table</h6>
			<p>As we can see, the <code>id</code> column in the persons table (which is an integer) serves as the primary key for that table and as a foreign key for the pet table, which is linked via the <code>owner_id</code> column.</p>
			<p>The persons table has the following columns:</p>
			<ul>
				<li><code>first_name</code>: The first name of the person</li>
				<li><code>last_name</code>: The last name of the person (can be "null")</li>
				<li><code>age</code>: The age of the person</li>
				<li><code>city</code>: The city from where he/she is from</li>
				<li><code>zip_code</code>: The zip code of the city</li>
			</ul>
			<p>The pets table has the following columns:</p>
			<ul>
				<li><code>pet_name</code>: The name of the pet.</li>
				<li><code>pet_type</code>: What type of pet it is, for example, cat, dog, and so on. Due to a lack of further information, we do not know which number represents what, but it is an integer and can be null.</li>
				<li><code>treatment_done</code>: It is also an integer column, and 0 here represents "No", whereas 1 represents "Yes".</li>
			</ul>
			<p>The name of the SQLite DB is <code>petsdb</code> and it is supplied along with the Activity notebook.</p>
			<p>These steps will help you complete this activity:</p>
			<ol>
				<li value="1">Connect to <code>petsDB</code> and check whether the connection has been successful.</li>
				<li>Find the different age groups in the persons database.</li>
				<li>Find the age group that has the maximum number of people.</li>
				<li>Find the people who do not have a last name.</li>
				<li>Find out how many people have more than one pet.</li>
				<li>Find out how many pets have received treatment.</li>
				<li>Find out how many pets have received treatment and the type of pet is known.</li>
				<li>Find out how many pets are from the city called <code>east port</code>.</li>
				<li>Find out how many pets are from the city called <code>east port</code> and who received a treatment.<h4>Note</h4><p class="callout">The solution for this activity can be found on page 324.</p></li>
			</ol>
			<h2 id="_idParaDest-266"><a id="_idTextAnchor319"/>Summary</h2>
			<p>We have come to the end of the database chapter. We have learned how to connect to SQLite using Python. We have brushed up on the basics of relational databases and learned how to open and close a database. We then learned how to export this relational database into Python DataFrames.</p>
			<p>In the next chapter, we will be performing data wrangling on real-world datasets.</p>
		</div>
	</div>



  </body></html>