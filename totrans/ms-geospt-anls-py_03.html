<html><head></head><body><div><h1 class="header-title">Introduction to Geospatial Databases</h1>
                
            
            
                
<p>In the previous chapters, you learned how to set up your Python environment and learned about the different libraries available for working with geospatial data using Python. In this chapter, you will start working with data.</p>
<p>Databases provide one of the most popular ways to store large amounts of data, and one of the most popular open source databases is PostgreSQL. PostGIS extends PostgreSQL, adding geographic objects and the ability to query records spatially. When PostgreSQL and PostGIS are combined, they create a powerful geospatial data repository.</p>
<p>Geospatial databases improve on basic relational database queries by allowing you to query your data by location or by location to other features in the database. You can also perform geospatial operations such as measurements of features, distances between features, and converting between projections. Another feature of geospatial databases is the ability to create new geometries from existing features from a buffer, union, or clip operation.</p>
<p>This chapter will cover the basics of geospatial databases. In this chapter, you will learn:</p>
<ul>
<li>How to install PostgreSQL and PostGIS</li>
<li>How to install and use <kbd>pyscopg2</kbd> to connect to the database</li>
<li>How to add data to a database</li>
<li>How to perform basic spatial queries</li>
<li>How to query length and area</li>
<li>How to query for points within a polygon</li>
</ul>
<p>In <a href="4f2388a3-51fc-419f-a827-bbbedbbb6374.xhtml">Chapter 7</a>, <em>Geoprocessing with Geodatabases</em>, we will come back to geospatial databases and you will learn more advanced operations and how to display your data.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Installing PostgreSQL and PostGIS on Windows</h1>
                
            
            
                
<p>You can install PostGIS by installing PostgreSQL and then install PostGIS afterwards, or you can install PostgreSQL and then use Stack Builder, which comes with PostgreSQL, afterwards to add PostGIS. Using Stack Builder allows you to download the desired PostgreSQL version and with a single-click also get the correct PostGIS version.</p>
<p>When I installed PostgreSQL 10, Stack Builder did not include PostGIS. By the time of publication, this should have been added. Screenshots may show a different PostGIS version because I used an old copy of PostgreSQL to show how Stack Builder would work. You can download PostgreSQL from <a href="https://www.postgresql.org/download/">https://www.postgresql.org/download/</a>.</p>
<p>As we proceed, I will walk you through installing PostgreSQL and then using Stack Builder to add PostGIS and a database. After downloading the executable, run it by double-clicking it. You will see the wizard as follows:</p>
<div><img src="img/ab1d1019-4b54-42a0-b5f1-1f1cd85528fd.png" style="width:37.25em;height:29.17em;" width="548" height="429"/></div>
<p>You can choose where to install PostgreSQL, but it is probably best to leave it as the default unless you have a specific reason to locate it elsewhere:</p>
<div><img src="img/55e727f4-2062-405e-827f-12598859f6e4.png" style="width:44.92em;height:35.08em;" width="545" height="426"/></div>
<p>Again, it is probably best to store the data in the default location, which is the same root folder as the PostgreSQL installation:</p>
<div><img src="img/f3ad5f9c-1140-4863-8b4b-eb17aad3b1dd.png" style="width:42.00em;height:32.83em;" width="547" height="427"/></div>
<p>Select the port in which you would like to run PostgreSQL. Applications will expect to find PostgreSQL on this port, so change it at your own risk. More advanced users can reconfigure port channels in the <kbd>.config</kbd> file after installation:</p>
<div><img src="img/c44ddd31-b32a-4e4a-8e34-45d9aafc8ff5.png" style="width:40.58em;height:31.83em;" width="548" height="429"/></div>
<p>Choose your Locale, or select the default. I have selected English, United States:</p>
<div><img src="img/2c973abd-7587-4120-8f29-3d154b0424f0.png" style="width:40.75em;height:32.00em;" width="549" height="431"/></div>
<p>This is where you are presented with the option to launch Stack Builder, and from there, you can install PostGIS. Check the box to begin the installation. The installation should only take a few minutes on a newer system:</p>
<div><img src="img/bea74fd6-ecc5-4a10-ab1d-cf225d5d2536.png" style="width:42.75em;height:33.50em;" width="547" height="429"/></div>
<p>The PostgreSQL installation has been completed and Stack Builder should now be open. Under Spatial Extensions, select the proper version of PostGIS 32 or 64-bit. Notice that it is a bundle and includes other packages such as <kbd>pgRouting</kbd>:</p>
<div><img src="img/e83cd2ff-7710-4050-ae93-9ee1b98b3cd7.png" style="width:48.67em;height:33.50em;" width="604" height="415"/></div>
<p>Now, the install wizard for PostGIS will launch. You have to agree to the terms of the license:</p>
<div><img src="img/900c8a5c-cc61-4955-a87a-92dc35c9a693.png" width="495" height="385"/></div>
<p>You can create a database at any time and this chapter will show you how to, however, it is best to check the Create spatial database box and take care of it now. If you do, your database will be set up and ready to use once PostGIS is installed:</p>
<div><img src="img/06694412-cd98-4d7a-a14c-d28b0adfe055.png" width="494" height="384"/></div>
<p>PostGIS will try to install where PostgreSQL was installed:</p>
<div><img src="img/61781c67-8d35-4f74-bf14-006be7dcbbef.png" width="493" height="382"/></div>
<p>Enter the username, password, and port for the database. The examples in this chapter will use <kbd>postgres</kbd> (username) and <kbd>postgres</kbd> (password). If you select a different username and password combination, remember it. In production, it is best not to use default usernames and passwords as they are well-known and will make you an easy target for hackers:</p>
<div><img src="img/e3b4d560-53a9-4022-9b3f-f697fe853839.png" width="495" height="384"/></div>
<p>Enter the name for the database. The examples we will be looking at will use <kbd>pythonspatial</kbd> as the database name. You will only use the name for the initial connection. The SQL queries in the example will use the table name:</p>
<div><img src="img/b3471575-a2cc-4130-bf5a-5fdcf4ee5b06.png" width="495" height="384"/></div>


            

            
        
    </div>



  
<div><h1 class="header-title">Installing PostgreSQL and PostGIS on Mac</h1>
                
            
            
                
<p>To install PostgreSQL and PostGIS on a Mac, you can use <kbd>Postgres.app</kbd>. You can download the file from <a href="http://postgresapp.com/">http://postgresapp.com/</a>. After the file has downloaded, move it to the <kbd>applications</kbd> folder and double-click it. Click Initialize. You will have a server on <kbd>localhost:5432</kbd>. The username and database name is the same as your Mac user. There is no password.</p>
<p>You should then be able to use the <kbd>psql</kbd> commands to create a new database and enable PostGIS.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Working with PostgreSQL and PostGIS using Python</h1>
                
            
            
                
<p>To connect and manipulate your PostgreSQL database in Python, you will need a library to assist you. <kbd>psyscopg2</kbd> is that library. It provides a wrapper around the official <kbd>libpq</kbd> client library. In this section, we will cover how to install the library, how to connect to the database, and how to add a table and perform basic geospatial queries.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Connecting to PostgreSQL using psycopg2</h1>
                
            
            
                
<p><kbd>pscycopg2</kbd> is the most popular library for working with PostgreSQL in Python. It fully implements the Python DB API 2.0 specification and works with Python 3. In the following sections, you will learn how to install the library, make connections, execute queries, and read the results. You can read the full documentation here: <a href="http://initd.org/psycopg/docs/">http://initd.org/psycopg/docs/</a></p>


            

            
        
    </div>



  
<div><h1 class="header-title">Installing psycopg2</h1>
                
            
            
                
<p class="mce-root">Installing most Python libraries requires you to open your console and type:</p>
<pre><strong>pip install psycopg2</strong></pre>
<p>If that doesn't work, and you are using an Anaconda Python distribution, you can run the <kbd>conda</kbd> command, using:</p>
<pre><strong>conda install -c anaconda psycopg2</strong></pre>
<p>While most Python libraries can be downloaded and installed using:</p>
<pre><strong>python setup.py install</strong></pre>
<p>Since <kbd>psycopg2</kbd> is more advanced than that and requires you to have a C compiler, Python header files, <kbd>libpq</kbd> header files, and the <kbd>pg_config</kbd> program. If you need to install <kbd>psycopg2</kbd> from the source, the link to the instructions is in the following hint box.</p>
<p>To install <kbd>psycopg2</kbd> from the source, the instructions are located at: <a href="http://initd.org/psycopg/docs/install.html#install-from-source">http://initd.org/psycopg/docs/install.html#install-from-source</a></p>


            

            
        
    </div>



  
<div><h1 class="header-title">Connecting to the database and creating a table</h1>
                
            
            
                
<p>You should have created a database when you installed PostGIS. For the examples mentioned as follows, we will use this database.</p>
<p class="mce-root">If you did not create a database during the installation of PostGIS, you can do so using your terminal (command prompt in Windows) and the commands as follows:</p>
<pre class="mce-root"><strong>createdb -U postgres pythonspatial</strong><br/><strong> psql -U postgres -d pythonspatial -c "CREATE EXTENSION postgis;" </strong></pre>
<p class="mce-root">You may need to modify your path. On Windows, the command to do so is shown as follows:</p>
<pre class="mce-root"><strong>set PATH=%PATH%;C:\Program Files\PostgreSQL\10\bin</strong></pre>
<p>To connect to your database, use the following code:</p>
<pre style="padding-left: 60px">import psycopg2<br/><br/>connection = psycopg2.connect(database="pythonspatial",user="postgres", password="postgres")<br/><br/>cursor = connection.cursor()<br/><br/>cursor.execute("CREATE TABLE art_pieces (id SERIAL PRIMARY KEY, code VARCHAR(255), location GEOMETRY)")<br/><br/>connection.commit()</pre>
<p>The code mentioned earlier starts by importing <kbd>psycopg2</kbd>. It then makes a <kbd>connection</kbd> by using the <kbd>connect()</kbd> function and passing the parameters for the database name, the <kbd>user</kbd>, and the <kbd>password</kbd>. It then creates a <kbd>cursor</kbd> which allows you to communicate with the database. You can use the <kbd>execute()</kbd> method of the <kbd>cursor</kbd> to create the table passing SQL statements as strings.</p>
<p>The code executes an SQL command which creates a table named <kbd>art_pieces</kbd> with an <kbd>id</kbd> of type <kbd>SERIAL</kbd> and makes it a <kbd>PRIMARY KEY</kbd>, <kbd>code</kbd> as type <kbd>VARCHAR</kbd> and a length of <kbd>255</kbd>, and the <kbd>location</kbd> as the <kbd>GEOMETRY</kbd> type. The <kbd>SERIAL PRIMARY KEY</kbd> tells PostgreSQL that we want an auto-incremented unique identifier. You can also use the <kbd>BIGSERIAL</kbd> type. The other type that is different is the <kbd>location</kbd> of the <kbd>GEOMETRY</kbd> type. This is the column that will hold the geo portion of our records.</p>
<p>Lastly, you <kbd>commit()</kbd> to make sure the changes are saved. You can also <kbd>close()</kbd> when you are finished, but we will continue further.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Adding data to the table</h1>
                
            
            
                
<p>In the previous section, we created a table. In this section, you will grab data from an open data site and put it on your table so that you can query it in the next section.</p>
<p>Most cities have open data websites and portals. The City of Albuquerque has several ArcServer endpoints with spatial data. The following code will use the <kbd>requests</kbd> Python library to grab public art data and then use <kbd>psycopg2</kbd> to send it to the PostgreSQL database, <kbd>pythonspatial</kbd>:</p>
<pre style="padding-left: 60px">import requests<br/><br/>url='http://coagisweb.cabq.gov/arcgis/rest/services/public/PublicArt/MapServer/0/query'<br/><br/>params={"where":"1=1","outFields":"*","outSR":"4326","f":"json"}<br/><br/>r=requests.get(url,params=params)<br/><br/>data=r.json()<br/><br/>data["features"][0]</pre>
<p>The code which we mentioned earlier imports <kbd>requests</kbd>, then, using the URL to the ArcServer endpoint, it grabs the results of a query asking for all of the data (<kbd>where:1=1</kbd>) and all of the fields (outFields:<kbd>*</kbd>) in <strong>World Geodetic System</strong> (<strong>WGS</strong>) <strong>84</strong> (<kbd>outSR:4326</kbd>), and returns it as a JSON (<kbd>f:json</kbd>).</p>
<p>ArcServer is a GIS Server made by the <strong>Environmental Systems Research Institute</strong> (<strong>ESRI</strong>). It provides a way to serve GIS data using an API and returning JSON. Many government agencies will have an Open Data Portal that utilizes an ArcServer to deliver the data.</p>
<p>The results are loaded into the <kbd>data</kbd> variable. Each record is in the array features (<kbd>data["features"][n]</kbd>). A single record, <kbd>data["features"][0]</kbd>, is shown as follows:</p>
<pre style="padding-left: 60px" class="mce-root"><strong>{'attributes': {'ADDRESS': '4440 Osuna NE',</strong><br/><strong> 'ARTIST': 'David Anderson',</strong><br/><strong> 'ART_CODE': '101',</strong><br/><strong> 'IMAGE_URL': 'http://www.flickr.com/photos/abqpublicart/6831137393/',</strong><br/><strong> 'JPG_URL': 'http://farm8.staticflickr.com/7153/6831137393_fa38634fd7_m.jpg',</strong><br/><strong> 'LOCATION': 'Osuna Median bet.Jefferson/ W.Frontage Rd',</strong><br/><strong> 'OBJECTID': 951737,</strong><br/><strong> 'TITLE': 'Almond Blossom/Astronomy',</strong><br/><strong> 'TYPE': 'public sculpture',</strong><br/><strong> 'X': -106.5918383,</strong><br/><strong> 'Y': 35.1555,</strong><br/><strong> 'YEAR': '1986'},</strong><br/><strong> 'geometry': {'x': -106.59183830022498, 'y': 35.155500000061544}}</strong></pre>
<p>With the <kbd>data</kbd>, you will iterate through the array of <kbd>features</kbd>, inserting the <kbd>ART_CODE</kbd> as <kbd>code</kbd> and creating a <strong>well-known text</strong> (<strong>WKT</strong>) representation of each point.</p>
<p>To learn more about WKT, you can read its Wikipedia entry at: <a href="https://en.wikipedia.org/wiki/Well-known_text">https://en.wikipedia.org/wiki/Well-known_text</a></p>
<p class="mce-root">The following code shows you how to insert the data:</p>
<pre style="padding-left: 60px" class="mce-root">for a in data["features"]:<br/>    code=a["attributes"]["ART_CODE"]<br/>    wkt="POINT("+str(a["geometry"]["x"])+" "+str(a["geometry"]        ["y"])+")"<br/>    if a["geometry"]["x"]=='NaN':<br/>        pass<br/>    else:<br/>        cursor.execute("INSERT INTO art_pieces (code, location)             VALUES ({},<br/>        ST_GeomFromText('{}'))".format(code, wkt))<br/>connection.commit()</pre>
<p>The preceding code iterates through each feature. It assigns <kbd>ART_CODE</kbd> to <kbd>code</kbd>, then constructs the WKT <kbd>(Point(-106.5918 35.1555))</kbd>, and assigns it to <kbd>wkt</kbd>. The code uses <kbd>ART_CODE</kbd> to show how to load other properties into the database.</p>
<p>Data is almost never clean and perfect. This data is no exception. So that it doesn't crash when the <kbd>x</kbd> coordinate is missing, I have added an <kbd>if</kbd><em>,</em> <kbd>else</kbd> statement to skip over missing data. This concept is known as <strong>error handling</strong>, and it is a best practice when constructing <kbd>requests</kbd>. The <kbd>else</kbd> statement is where the data gets inserted. Using <kbd>cursor.execute()</kbd>, you can construct the SQL query.</p>
<p>The query inserts <kbd>art_pieces</kbd> into the database along with the <kbd>code</kbd> and <kbd>location</kbd> fields with values. The first value, for <kbd>code</kbd>, is a placeholder <kbd>{}</kbd>. The second value, for <kbd>location</kbd>, is geometry which we stored as WKT. Because of this, it is inserted using the <kbd>ST_GeomFromText()</kbd> function and a placeholder <kbd>{}</kbd>.</p>
<p>The <kbd>format()</kbd> method is where you pass the variables to fill the placeholders—<kbd>code</kbd>, <kbd>wkt</kbd>. The following code shows what the query will look like when the placeholders are filled in:</p>
<pre style="padding-left: 60px" class="mce-root">INSERT INTO art_pieces (code, location) VALUES (101, ST_GeomFromText('Point(-106.5918 35.1555)'))</pre>
<p>In the previously mentioned code, you created the WKT as a concatenated string. This can be accomplished in a cleaner and more Pythonic fashion by using the Shapely library.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Shapely</h1>
                
            
            
                
<p>Shapely can be installed using:</p>
<pre><strong>pip install shapely</strong></pre>
<p>Or with <kbd>conda</kbd>:</p>
<pre><strong>conda install -c scitools shapely</strong></pre>
<p>Shapely makes the task of creating and working with geometries easier and makes your code cleaner. In the previous code, you concatenated a string to create a WKT representation of a point. Using Shapely, you can create a point and then convert it to WKT. The following code shows you how:</p>
<pre style="padding-left: 60px" class="mce-root">from shapely.geometry import Point, MultiPoint<br/><br/>thepoints=[]<br/><br/>for a in data["features"]:<br/>    code=a["attributes"]["ART_CODE"]<br/>    <strong>p=Point(float(a["geometry"]["x"]),float(a["geometry"]["y"]))</strong><br/>    thepoints.append(p)<br/>    if a["geometry"]["x"]=='NaN':<br/>        pass<br/>    else:<br/>        cursor.execute("INSERT INTO art_pieces (code, location)             VALUES ('{}',<br/>        ST_GeomFromText('{}'))".format(code, <strong>p.wkt</strong>))<br/>connection.commit()</pre>
<p>The previous code imports <kbd>Point</kbd> and <kbd>MultiPoint</kbd> from <kbd>shapely.geometry</kbd>. The code is the same as the previous version until the line in bold. To create a point, you use <kbd>Point(x,y)</kbd> in Shapely. It put all of the points in an array called <kbd>thepoints</kbd> to draw them in a Jupyter Notebook, for which an image is follows. Lastly, the SQL statement passes <kbd>p.wkt</kbd> to <kbd>ST_GeomFromText()</kbd>.</p>
<p>In a Jupyter Notebook, you can print Shapely geometry just by typing the name of the variable holding the geometry and it will draw the end. The public <kbd>art</kbd> points are in the variable <kbd>thepoints</kbd><em>.</em> A <kbd>MultiPoint</kbd> can be created using an array of points, and printing them draws the following image:</p>
<div><img src="img/e5a4bd3c-a6c7-4f3c-a4c3-5240543386ea.png" width="305" height="150"/></div>


            

            
        
    </div>



  
<div><h1 class="header-title">Querying the data</h1>
                
            
            
                
<p class="mce-root">You created a table, added columns for code and location, and populated it using data from another source. Now, you will learn how to query the data and get it out of the database.</p>
<p class="mce-root">While there are spatial SQL queries available to you, you can always just select the data as if it were a non-spatially enabled database so that you can use it as follows:</p>
<pre style="padding-left: 60px" class="mce-root">SELECT * FROM table</pre>
<p class="mce-root">The following code shows the generic <kbd>SELECT</kbd> all query and the results:</p>
<pre style="padding-left: 60px" class="mce-root">cursor.execute("SELECT * from art_pieces")<br/>data=cursor.fetchall()<br/>data</pre>
<p class="mce-root">The result should look as follows:</p>
<pre class="mce-root"><br/><strong> [(1, '101', '010100000025FFBFADE0A55AC06A658B6CE7934140'),</strong><br/><strong> (2, '102', '0101000000CC4E16E181AA5AC0D99F67B3EA8B4140'),</strong><br/><strong> .......,]</strong></pre>
<p class="mce-root">The first number, <kbd>1</kbd>,<kbd>2</kbd>,n, is the <kbd>id</kbd> (the <kbd>SERIAL PRIMARY KEY</kbd>). Next, is the <kbd>code</kbd>. The geometry is the last column. The string of what appears to be random numbers and letters is a <strong>well-known binary</strong> (<strong>WKB</strong>) in hex.</p>
<p class="mce-root">To convert the WKB, you use <kbd>shapely</kbd>. The following code walks you through converting the WKB to a <kbd>shapely</kbd> <kbd>Point</kbd>, and then printing the WKT:</p>
<pre style="padding-left: 60px" class="mce-root">from shapely.wkb import loads<br/>aPoint=loads(data[0][2],hex=True)<br/>aPoint.wkt</pre>
<p class="mce-root">The previous code imports the <kbd>loads()</kbd> method from <kbd>shapely.wkb</kbd>. You must add the <kbd>hex</kbd> parameter and make it equal to <kbd>True</kbd> or you will receive an error. To get the geography column of the first record, you can use <kbd>data[0][2]</kbd> with <kbd>[0]</kbd> as the record and <kbd>[2]</kbd> as the column. Now that you have a <kbd>shapely</kbd> <kbd>Point</kbd>, you can verify it by using <kbd>type(aPoint)</kbd>, you can print it as a WKT using <kbd>aPoint.wkt</kbd>. You should see the result as follows:</p>
<pre style="padding-left: 60px" class="mce-root"><strong>POINT (-106.591838300225 35.15550000006154)</strong></pre>
<p class="mce-root">If you want PostgreSQL to return the data in WKB without hex, you can do so using <kbd>ST_AsBinary()</kbd>. The following code shows you how:</p>
<pre style="padding-left: 60px" class="mce-root">cursor.execute("SELECT id,code,ST_AsBinary(location) from art_pieces")<br/>data=cursor.fetchall()<br/>data[0][2]<br/>from shapely.wkb import loads<br/>pNoHex=loads(bytes(data[0][2]))<br/>pNoHex.wkt</pre>
<p class="mce-root">The previous code wraps the location in <kbd>ST_AsBinary()</kbd>. To load the result into a <kbd>shapely</kbd> <kbd>Point</kbd>, you have to use <kbd>bytes()</kbd>. Then, you can see the WKT using <kbd>pNoHex.wkt</kbd>. You should see the same point as in the previous example.</p>
<p class="mce-root">Binary may come in handy, but you can also query the data and get the geometry back as a WKT:</p>
<pre style="padding-left: 60px" class="mce-root">cursor.execute("SELECT code, ST_AsText(location) from art_pieces")<br/>data = cursor.fetchone()</pre>
<p class="mce-root">The previous code uses <kbd>ST_AsText(geometry column)</kbd> to return the data as a WKT. You can return a column that contains geometry at any time by using <kbd>ST_AsText()</kbd>. Instead of <kbd>fetchall()</kbd>, the code uses <kbd>fetchone()</kbd> to grab a single record. You should see a single record as follows:</p>
<pre style="padding-left: 60px" class="mce-root"><strong>('101', 'POINT(-106.591838300225 35.1555000000615)')</strong></pre>
<p class="mce-root">You can load WKT into a <kbd>shapely</kbd> <kbd>Point</kbd> using <kbd>loads()</kbd>, but you need to import it first, just like you did earlier with WKB:</p>
<pre style="padding-left: 60px" class="mce-root">from shapely.wkt import loads<br/>pb=loads(data[1])<br/>pb.coords[:]</pre>
<p class="mce-root">The previous code import <kbd>loads</kbd> from <kbd>shapely</kbd>—but this time using <kbd>shapely.wkt</kbd>, not <kbd>wkb</kbd>. Otherwise, you load the data the same way as in the previous examples. You can see the coordinates of the <kbd>shapely</kbd> <kbd>Point</kbd> using <kbd>pb.coords[:]</kbd>, or you can see them individually using <kbd>pb.x</kbd> and <kbd>pb.y</kbd>.</p>
<p class="mce-root">The result of <kbd>pb.coords[:]</kbd> will be a coordinate pair, which is shown as follows:</p>
<pre style="padding-left: 60px" class="mce-root"><strong>[(-106.591838300225, 35.1555000000615)]</strong></pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Changing the CRS</h1>
                
            
            
                
<p class="mce-root">The data in the database is using <strong>World Geodetic System 84</strong> (<strong>WGS 84</strong>), latitude and longitude. What if you need the data out in <strong>European Petroleum Survey Group</strong> (<strong>EPSG</strong>) 3857? You can change the spatial reference in your query using <kbd>ST_Transform()</kbd>. The following code shows you how by using PostGIS functions:</p>
<pre style="padding-left: 60px" class="mce-root">cursor.execute("SELECT UpdateGeometrySRID('art_pieces','location',4326)")<br/>cursor.execute("SELECT Find_SRID('public','art_pieces','location')")<br/>cursor.fetchall()</pre>
<p class="mce-root">The previous code makes two queries to the database:</p>
<ul>
<li class="mce-root">Firstly, it assigns a spatial reference system identifier to the geometry column in the table using <kbd>UpdateGeomtrySRID()</kbd>. This needs to be done because the points were put in the table without any reference to an <kbd>SRID</kbd>. So when we try to get the results back using a different coordinate reference system, the database will not know how to transform our coordinates.</li>
<li class="mce-root">Secondly, the code queries the database to tell us what the <kbd>SRID</kbd> is on the geometry column in the table using <kbd>Find_SRID()</kbd>. If you do not have a properly added geometry column, the function will fail.</li>
</ul>
<p class="mce-root">Now that you have an <kbd>SRID</kbd> set on the column in the table, you can query the data and transform it:</p>
<pre style="padding-left: 60px" class="mce-root">cursor.execute("SELECT code, ST_AsTexT(ST_Transform(location,3857)) from art_pieces")<br/>cursor.fetchone()</pre>
<p class="mce-root">The previous code is a basic select <kbd>code</kbd> and <kbd>location</kbd>, as text, from <kbd>art_pieces</kbd>, but now there is an <kbd>ST_Transform</kbd> method. This method takes the column with geometry and the <kbd>SRID</kbd> you want the data sent back in. Now, the piece of art at <kbd>(-106.59, 35.155)</kbd> is returned using <kbd>3857</kbd>, and shown as follows with the transformed coordinates:</p>
<pre style="padding-left: 60px" class="mce-root"><strong>('101', 'POINT(-11865749.1623 4185033.1034)')</strong></pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Buffer</h1>
                
            
            
                
<p class="mce-root">A spatial database allows you to store spatial data, but you can also perform operations on the data and get different geometries back. The most common of these operations would be a buffer. You have a table of points, but using <kbd>ST_Buffer()</kbd>, you can have the database return a polygon around the point with a specified radius. The following code shows you how:</p>
<pre style="padding-left: 60px" class="mce-root">cursor.execute("SELECT ST_AsText(ST_Buffer(a.location,25.00,'quad_segs=2')) from pieces a WHERE a.code='101'")<br/><br/>cursor.fetchall()</pre>
<p class="mce-root">The previous code grabs a record from the table where the art code field equals <kbd>101</kbd>, and selects a buffer with a radius of <kbd>25</kbd> around the <kbd>location</kbd>. The result will be a polygon, which is shown as follows:</p>
<p>When using geography, if the buffer is large, falls between two UTM zones, or crosses the dateline, it may behave unexpectedly.</p>
<pre style="padding-left: 60px" class="mce-root"><br/><strong> 'POLYGON((-106.591563918525 35.1555036055616,-106.591568334295 35.1554595740463,-106.59158312469 35.1554170960907,...,-106.591570047094 35.155547498531,-106.591563918525 35.1555036055616))'</strong></pre>
<p class="mce-root">If you load the polygon into <kbd>shapely</kbd> using the following code, a Jupyter Notebook will draw the polygon:</p>
<pre style="padding-left: 60px" class="mce-root">from shapely.geometry import Polygon<br/>from shapely.wkt import loads<br/>buff=loads(data[0][0])<br/>buff</pre>
<p class="mce-root">The buffer returned from <kbd>ST_Buffer</kbd> as a <kbd>shapely</kbd> polygon is shown as follows:</p>
<p> </p>
<div><img src="img/a0fa316c-3695-4a82-8605-b6fba19a1efc.jpg" style="width:7.08em;height:6.58em;" width="126" height="114"/></div>
<p class="mce-root">You can also pass a parameter to <kbd>ST_Buffer</kbd> for the number of segments you used to draw a quarter of a circle. If you divide the circle into four quadrants, the <kbd>quad_segs</kbd> parameter will draw that many segments in each quadrant. A <kbd>quad_seg</kbd> value of 1 will draw a rotated square, which is shown as follows:</p>
<div><img src="img/a47fc9b9-da9f-4b7f-8201-53e9978887b4.png" style="width:6.83em;height:6.75em;" width="111" height="108"/></div>
<p>Whereas a <kbd>quad_seg</kbd> value of 2 would draw an octagon which is shown as follows:</p>
<div><img src="img/201ce6dd-b0b8-40fe-9947-fb0c52a40f38.png" style="width:7.00em;height:6.92em;" width="110" height="108"/></div>


            

            
        
    </div>



  
<div><h1 class="header-title">Distance and near</h1>
                
            
            
                
<p class="mce-root">In the previous section, you had the database buffer a point and return the polygon. In this section, you will learn how to query the database for the distance between two points, and you will query the database and have it return records based on the distance from a specified point.</p>
<p class="mce-root">The PostGIS function for distance is <kbd>ST_Distance(a,b)</kbd>. You can pass <kbd>a</kbd> and <kbd>b</kbd> as geometry or geography. As <kbd>geography</kbd>, the result will be returned in meters. The following code will get the distance between two points in the database:</p>
<pre style="padding-left: 60px" class="mce-root">cursor.execute("SELECT ST_Distance(a.location::geography,b.location::geography) FROM art_pieces a, art_pieces b where a.name='101' AND b.name='102'")<br/>dist=cursor.fetchall()<br/>dist</pre>
<p class="mce-root">The previous code executes the SQL query for <kbd>ST_Distance()</kbd>, passing the <kbd>location</kbd> column of <kbd>a</kbd> and <kbd>b</kbd> which are records, where the code equals <kbd>101</kbd> and <kbd>102</kbd>. <kbd>::geography</kbd> is how you cast a geometry to a geography in PostGIS. How far are they from each other? They are 9,560.45428363 meters apart.</p>
<p>To convert this to miles use: <kbd>dist[0][0]*0.00062137</kbd>, which makes them 5.940 miles apart.</p>
<p class="mce-root">In the previous example, you used two points from the database, but you can also pass a hard-coded point as in the following code:</p>
<pre style="padding-left: 60px" class="mce-root">cursor.execute("SELECT ST_Distance(a.location::geography,<br/>               ST_GeometryFromText('POINT(-106.5 35.1)')::geography) <br/>               FROM art_pieces a where a.name='101'")<br/><br/>cursor.fetchall()</pre>
<p class="mce-root">The previous code is the same query, but this time you switch out point <kbd>b</kbd> (<kbd>code=102</kbd>) with a hard-coded WKT point. The results of the query should state that the points are 10,391.40637117 meters apart.</p>
<p class="mce-root">And, as in previous examples, you can also use <kbd>shapely</kbd> to pass the WKT of the point, as in the following code:</p>
<pre style="padding-left: 60px" class="mce-root">from shapely.geometry import Point<br/>p=Point(-106.5,35.1)<br/>cursor.execute("SELECT ST_Distance(a.location::geography,<br/>                ST_GeometryFromText('{}')::geography) <br/>                FROM art_pieces a where a.name='101'".format(p.wkt))<br/>cursor.fetchall()</pre>
<p class="mce-root">The previous code creates the point in <kbd>shapely</kbd> and then uses <kbd>format(p.wkt)</kbd> to pass the WKT to the <kbd>{}</kbd> placeholder.</p>
<p class="mce-root">You can get the distance between two points, but what if you want the distance of more than one point from another? To do that, you can remove the <kbd>a.location</kbd> and just use <kbd>location</kbd> as the first point. The following code will return five points and their distances from the specified point:</p>
<pre style="padding-left: 60px" class="mce-root">cursor.execute("SELECT code, ST_Distance(location::geography,<br/>                ST_GeometryFromText('POINT(-106.591838300225<br/>                35.1555000000615)')::geography) <br/>                as d from art_pieces LIMIT 5")<br/>cursor.fetchall()</pre>
<p class="mce-root">The results should look like the data showing the distance in meters:</p>
<pre style="padding-left: 60px" class="mce-root"><strong>[('101', 0.0),</strong><br/><strong> ('102', 9560.45428362),</strong><br/><strong> ('104', 4741.8711304),</strong><br/><strong> ('105', 9871.8424894),</strong><br/><strong> ('106', 7907.8263995)]</strong></pre>
<p class="mce-root">The database returned the first five points in the table with their code and distance from the specified point. If you remove the <kbd>LIMIT</kbd>, you will get all of the points.</p>
<p class="mce-root">By adding an <kbd>ORDER BY</kbd> clause and the k-nearest neighbor operator, you can extend this query to get the closest five points to the specified point. Look at the following code:</p>
<pre style="padding-left: 60px" class="mce-root">cursor.execute("SELECT code, ST_Distance(location::geography,<br/>                ST_GeometryFromText('POINT(-106.591838300225<br/>                35.1555000000615)')::geography) as d from art_pieces <br/>                ORDER BY location&lt;-                                                                <br/>                &gt;ST_GeometryFromText('POINT(-106.591838300225 <br/>                35.1555000000615)') LIMIT 5")<br/>cursor.fetchall()</pre>
<p class="mce-root">The key element in the previous code is the symbol <kbd><em>&lt;-&gt;</em></kbd>. This is the k-nearest neighbor operator. It returns the distance between two geometries. Using <kbd>ORDER BY location &lt;-&gt; ST_GeometryFromText()</kbd>, you are specifying two geometries. Because you set a <kbd>LIMIT</kbd> of <kbd>5</kbd>, the database will return the <kbd>5</kbd> closest points to the one specified—including the point of origin. The results should look like the following points:</p>
<pre style="padding-left: 60px" class="mce-root"><strong>[('101', 0.0),</strong><br/><strong> ('614', 1398.08905864),</strong><br/><strong> ('492', 2384.97632735),</strong><br/><strong> ('570', 3473.81914218),</strong><br/><strong> ('147', 3485.71207698)]</strong></pre>
<p class="mce-root">Notice that the code value is not <kbd>101</kbd>-<kbd>106</kbd> or the first five from the database, and that the distance increases from <kbd>0.0</kbd>. The closest point, code <kbd>101</kbd>, is the point you specified in the query, so it is <kbd>0.0</kbd> meters away.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Lines in the database</h1>
                
            
            
                
<p class="mce-root">The first section of this chapter focused on point operations. Now, we will turn our attention to lines. For the following examples, you will create a new table and insert three lines. The following code will accomplish that:</p>
<pre style="padding-left: 60px" class="mce-root">from shapely.geometry import LineString<br/>from shapely.geometry import MultiLineString<br/><br/>connection = psycopg2.connect(database="pythonspatial",user="postgres",    <br/>    password="postgres")<br/><br/>cursor = c.cursor()<br/>cursor.execute("CREATE TABLE lines (id SERIAL PRIMARY KEY, location GEOMETRY)")<br/>thelines=[]<br/>thelines.append(LineString([(-106.635585,35.086972),(-106.621294,35.124997)]))<br/>thelines.append(LineString([(-106.498309,35.140108),(-106.497010,35.069488)]))<br/>thelines.append(LineString([(-106.663878,35.106459),(-106.586506,35.103979)]))<br/><br/>mls=MultiLineString([((-106.635585,35.086972),(-106.621294,35.124997)),((-106.498309,35.140108),(-106.497010,35.069488)),((-106.663878,35.106459),(-106.586506,35.103979))])<br/><br/>for a in thelines:<br/>    cursor.execute("INSERT INTO lines (location) VALUES  <br/>                (ST_GeomFromText('{}'))".format(a.wkt))<br/>connection.commit()</pre>
<p class="mce-root">The previous code should be familiar. It starts by connecting to the Python spatial database, gets a <kbd>cursor</kbd>, and then creates a table with an <kbd>id</kbd> and a location of the <kbd>geometry</kbd> type. You should import <kbd>shapely LineString</kbd> and <kbd>MultiLine</kbd>, <kbd>Multiline</kbd> is so you can print the lines in the Jupyter notebook. You should create an array of <kbd>lines</kbd> and then loop through them, inserting each into the table using the <kbd>cursor</kbd>. You can then <kbd>commit()</kbd> the changes.</p>
<p class="mce-root">To see that the lines have been added to the database, you can execute the following code:</p>
<pre style="padding-left: 60px" class="mce-root">cursor.execute("SELECT id, ST_AsTexT(location) from lines")<br/>data=cursor.fetchall()<br/>data</pre>
<p class="mce-root">The previous code executes a basic select statement on the new table. There should be three records in the result set, as follows:</p>
<pre style="padding-left: 60px" class="mce-root"><strong>[(1, 'LINESTRING(-106.635585 35.086972,-106.621294 35.124997)'),</strong><br/><strong> (2, 'LINESTRING(-106.498309 35.140108,-106.49701 35.069488)'),</strong><br/><strong> (3, 'LINESTRING(-106.663878 35.106459,-106.586506 35.103979)')]</strong></pre>
<p class="mce-root">If you print the <kbd>mls</kbd> variable (the variable holding a multilinestring in the earlier code) you can see the lines which are shown in the following image:</p>
<div><img src="img/0666d28c-66e1-43e3-9feb-9f9dc54ef43b.png" width="124" height="60"/></div>
<p class="mce-root">Now that you have a database table with a few lines, you can proceed to measure them and find out if they intersect.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Length of a line</h1>
                
            
            
                
<p class="mce-root">Points have no length and if they intersect, they have the same coordinates. Lines, however, have a length and can intersect at a point not specified in the table, between two of the points used to create the line.<br/>
The following code will return the length of all of the <kbd>lines</kbd>:</p>
<pre style="padding-left: 60px" class="mce-root">cu.execute("SELECT id, ST_Length(location::geography) FROM lines ")<br/>cu.fetchall()</pre>
<p class="mce-root">The previous code uses the <kbd>ST_Length</kbd> function. The function will accept both geometry and geography. In this example, <kbd>::geography</kbd> was used to convert the geometry so meters would be returned.</p>
<p class="mce-root">The results are as follows:</p>
<pre style="padding-left: 60px" class="mce-root"><strong>[(1, 4415.21026808109),</strong><br/><strong> (2, 7835.65405408195),</strong><br/><strong> (3, 7059.45840502359)]</strong></pre>
<p class="mce-root">You can add an <kbd>ORDER BY</kbd> clause to the previous query and the database will return the <kbd>lines</kbd> from shortest to longest. The following code adds the clause:</p>
<pre style="padding-left: 60px" class="mce-root">cu.execute("SELECT id, ST_Length(location::geography) <br/>            FROM lines ORDER BY ST_Length(location::geography)")<br/>cu.fetchall()</pre>
<p class="mce-root">Adding <kbd>ORDER BY</kbd> will return the records, swapping the position of <kbd>2</kbd> and <kbd>3</kbd>, as follows:</p>
<pre style="padding-left: 60px" class="mce-root">[(1, 4415.21026808109),<br/> (3, 7059.45840502359),<br/> (2, 7835.65405408195)]</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Intersecting lines</h1>
                
            
            
                
<p class="mce-root">You know the length of the <kbd>lines</kbd>, and by drawing the <kbd>lines</kbd> in a Jupyter Notebook, you know that <kbd>lines 1</kbd> and <kbd>lines 3</kbd> intersect. In PostGIS, you can use the <kbd>ST_Intersects()</kbd> function, passing either geometries or geographies. The database will return either true or false.</p>
<p class="mce-root">The following code will execute the query on <kbd>lines 1</kbd> and <kbd>lines 3</kbd> and return <kbd>True</kbd>:</p>
<pre style="padding-left: 60px" class="mce-root">cu.execute("SELECT ST_Intersects(l.location::geography,ll.location::geometry)<br/>            FROM lines l, lines ll WHERE l.id=1 AND ll.id=3")<br/>cu.fetchall()</pre>
<p class="mce-root">The previous code will return <kbd>True</kbd>, because <kbd>lines 1</kbd> and <kbd>lines 3</kbd> intersect. But where do they intersect? Using <kbd>ST_Intersection()</kbd> will return to the point where the two <kbd>lines</kbd> meet:</p>
<pre style="padding-left: 60px" class="mce-root">cu.execute("SELECT ST_AsText(ST_Intersection(l.location::geography,<br/>            ll.location::geometry)) FROM lines l, lines ll <br/>            WHERE l.id=1 AND ll.id=3")<br/>cu.fetchall()</pre>
<p class="mce-root">By switching from <kbd>ST_Intersects</kbd> to <kbd>ST_Intersection</kbd>, you get a point of contact between the two <kbd>lines</kbd>. The point is as follows:</p>
<pre style="padding-left: 60px" class="mce-root"><strong>[('POINT(-106.628684465508 35.1053370957485)',)]</strong></pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Polygons in the database</h1>
                
            
            
                
<p class="mce-root">You can also store polygons using PostGIS. The following code will create a new table with a single polygon:</p>
<pre style="padding-left: 60px" class="mce-root">from shapely.geometry import Polygon<br/><br/>connection = psycopg2.connect(database="pythonspatial",user="postgres", password="postgres")<br/>cursor = conectionn.cursor()<br/>cursor.execute("CREATE TABLE poly (id SERIAL PRIMARY KEY, location GEOMETRY)")<br/>a=Polygon([(-106.936763,35.958191),(-106.944385,35.239293),<br/>           (-106.452396,35.281908),(-106.407844,35.948708)])<br/>cursor.execute("INSERT INTO poly (location) <br/>             VALUES (ST_GeomFromText('{}'))".format(a.wkt))<br/>connection.commit()</pre>
<p class="mce-root">The previous code is almost identical to the <kbd>Point</kbd> and <kbd>Line</kbd> examples. Make the database connection and then get a <kbd>cursor</kbd>. Use <kbd>execute()</kbd> to create the table. Import <kbd>shapely</kbd>, construct your geometry and insert it into the table. Lastly, <kbd>commit()</kbd> the changes.</p>
<p class="mce-root">The previous examples selected everything from the database and drew the geometry in the Jupyter Notebook. The following code will skip those steps and instead return to the area of the polygon:</p>
<pre style="padding-left: 60px" class="mce-root">cur.execute("SELECT id, ST_Area(location::geography) from poly")<br/>cur.fetchall()</pre>
<p class="mce-root">Using <kbd>ST_Area()</kbd> and the geometry cast to geography, the previous code should return the following value in meters squared:</p>
<pre style="padding-left: 60px" class="mce-root"><strong>[(1, 3550790242.52023)]</strong></pre>
<p class="mce-root">Now that you know there is a polygon in the table, you can learn how to search for a point within a polygon. </p>


            

            
        
    </div>



  
<div><h1 class="header-title">Point in polygon</h1>
                
            
            
                
<p class="mce-root">One of the most common problems is trying to determine whether a point is in the polygon. To solve this problem with PostGIS, you can use <kbd>ST_Contains</kbd> or <kbd>ST_Intersects</kbd>.</p>
<p class="mce-root"><kbd>St_Contains</kbd> takes two geometries and determines whether the first contains the second. </p>
<p>The order matters—<em>a</em> contains <em>b</em>, which is the opposite of <kbd>ST_Within</kbd>, which uses the order <em>b</em>, <em>a</em>.</p>
<p class="mce-root">By using contains, no part of geometry <em>b</em> can be outside of geometry <em>a</em>. The following code solves a <strong>point in polygon</strong> (<strong>PIP</strong>) problem:</p>
<pre style="padding-left: 60px" class="mce-root">isin=Point(-106.558743,35.318618)<br/>cur.execute("SELECT ST_Contains(polygon.location,ST_GeomFromText('{}')) <br/>             FROM poly polygon WHERE polygon.id=1".format(isin.wkt))<br/>cur.fetchall()</pre>
<p>The previous code creates a point and then uses <kbd>ST_Contains(polygon,point)</kbd> and returns <kbd>True</kbd>. The point is in the polygon. You can use <kbd>ST_Contains</kbd> with any other valid geometry. Just remember, it must contain the entire geometry to be true.</p>
<p class="mce-root">Another method to determine whether a point is in a polygon is by using <kbd>ST_Intersects</kbd>. <kbd>ST_Intersects</kbd> will return true if the point, or any other geometry, overlaps, touches, or is within the polygon. <kbd>ST_Intersects</kbd> can take either a geometry or a geography. </p>
<p>The following code will perform a PIP using <kbd>ST_Intersects</kbd>:</p>
<pre style="padding-left: 60px" class="mce-root">isin=Point(-106.558743,35.318618)<br/>cur.execute("SELECT ST_Intersects(ST_GeomFromText('{}')::geography,polygon.location::geometry) FROM poly polygon WHERE polygon.id=1".format(isin.wkt))<br/>cur.fetchall()</pre>
<p class="mce-root">The previous code only differs from the <kbd>ST_Contains</kbd> example by the function that was used and that geometry was used. It also returns <kbd>True</kbd>. When using a polygon and a line, <kbd>ST_Intersects</kbd> will return true if any part of the line touches or is within the polygon. This differs from <kbd>ST_Contains</kbd>.</p>
<p class="mce-root">Using <kbd>ST_Intersection</kbd>, you can get the geometry that represents the intersection. In the <kbd>lines</kbd> example earlier, it was a point. In the case of a polygon and a line, which I will show later on, it will be a line. The following code uses <kbd>ST_Intersection</kbd> to get the <kbd>LineString</kbd> that intersects with the polygon:</p>
<pre style="padding-left: 60px" class="mce-root">isin=LineString([(-106.55,35.31),(-106.40,35.94)])<br/>cur.execute("SELECT ST_AsText(ST_Intersection(polygon.location,ST_GeomFromText('{}'))) <br/>FROM poly polygon WHERE polygon.id=1".format(isin.wkt))<br/>cur.fetchall()</pre>
<p class="mce-root">The previous code is almost identical to the preceding example, except we used intersection versus intersects. The result is the <kbd>LINESTRING</kbd>:</p>
<pre style="padding-left: 60px" class="mce-root"><strong>[('LINESTRING(-106.55 35.31,-106.411712640251 35.8908069109443)',)]</strong></pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>This chapter covered the installation of PostgreSQL and PostGIS as well as <kbd>psycogp2</kbd> and Shapely. Then, we gave a brief overview of the major functions used when working with a spatial database. You should now be familiar with connecting to the database, executing queries to insert data, and how to get your data out. Furthermore, we covered functions that return new geometries, distances, and areas of geometry. Understanding how these functions work should allow you to read the PostGIS documents and be comfortable with forming the SQL statement for that function.</p>
<p>In the next chapter, you will learn about the major data types in GIS and how to use Python code libraries to read and write geospatial data. You will learn how to convert between data types, and how to upload and download data from geospatial databases and remote data sources.</p>


            

            
        
    </div>



  </body></html>