<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Creating the First Python Script"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Creating the First Python Script</h1></div></div></div><p>Now that we have Python configured to fit our needs, we can create Python scripts. This chapter will explore how to use ArcGIS <span class="strong"><strong>ModelBuilder</strong></span> to model a simple analysis as the basis for <a id="id115" class="indexterm"/>our script. ModelBuilder is very useful on its own and for creating Python scripts as it has an operational and a visual component, and all models can be outputted as Python scripts. This will allow us to compare how the more familiar ModelBuilder utilizes tools in the ArcToolbox to how Python handles the same tools. We will also discuss iteration and when it is best to use Python over ModelBuilder.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Modeling a simple analysis using ModelBuilder</li><li class="listitem" style="list-style-type: disc">Exporting the model out to a Python script</li></ul></div><div class="section" title="Prerequisites"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec19"/>Prerequisites</h1></div></div></div><p>"Along with ArcGIS ModelBuilder, a data set and scripts are required."</p><p>For this chapter, the accompanying data and scripts should be downloaded from Packt Publishing's website. The completed scripts are available for comparison purposes and the data will be used for this chapter's analysis.</p><div class="section" title="ModelBuilder"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec31"/>ModelBuilder</h2></div></div></div><p>ArcGIS<a id="id116" class="indexterm"/> has been in development since the 1970s. During that time, it included a variety of programming languages and tools to help GIS analysts automate analyses and map production. These include the Avenue scripting language in the ArcGIS 3x<a id="id117" class="indexterm"/> series and the <span class="strong"><strong>ARC Macro Language</strong></span> (<span class="strong"><strong>AML</strong></span>) in the ARC/Info workstation days, as well as VBScript up until ArcGIS 10x when Python was introduced. Another useful tool introduced in ArcGIS 9x was ModelBuilder, a visual programming environment used for both modeling analysis and creating tools that can be used repeatedly with different input feature classes.</p><p>Another useful feature of ModelBuilder is an export function that allows modelers to create Python scripts directly from a model. This will make it easier to compare how inputs in a ModelBuilder tool are accepted versus how a Python script calls the same tool and supplies the<a id="id118" class="indexterm"/> inputs to it, or how the feature classes that are created are named and placed within the file structure. ModelBuilder is a fantastic tool that will make it easy for a GIS analyst to bridge the gap from normal GIS workflows to automated Python-based workflows.</p></div></div></div>
<div class="section" title="Creating a model and exporting to Python"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Creating a model and exporting to Python</h1></div></div></div><p>This <a id="id119" class="indexterm"/>chapter will depend on the downloadable <code class="literal">SanFrancisco.gdb </code>file geodatabase, available from the Packt Publishing website. The San Francisco <a id="id120" class="indexterm"/>GDB contains data downloaded from <a class="ulink" href="http://data.sfgov.org">data.sfgov.org</a> and the US Census' American Factfinder website available at <a class="ulink" href="http://factfinder2.census.gov">factfinder2.census.gov</a>. All census and geographic data included in the geodatabase is from the 2010 census. The data is contained within a feature dataset called <span class="strong"><strong>SanFrancisco</strong></span>. The data in this feature dataset is in NAD 83 California State Plane Zone 3 and the linear unit of measure is the US Foot (this corresponds to SRID 2227 in the European Petroleum Survey Group, or EPSG, format).</p><p>The analysis we will create with the model, and eventually export to Python for further refinement, will use bus stops along a specific line in San Francisco. These bus stops will be buffered to create a representative region around each bus stop. The buffered areas will then be intersected with census blocks to find out how many people are within each representative region around the bus stops.</p><div class="section" title="Modeling the Select and Buffer tools"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec32"/>Modeling the Select and Buffer tools</h2></div></div></div><p>Using <a id="id121" class="indexterm"/>ModelBuilder, we will first model the basis of the bus <a id="id122" class="indexterm"/>stop analysis. Once it has been modeled, it will be<a id="id123" class="indexterm"/> exported as an automatically generated Python script. Follow<a id="id124" class="indexterm"/> these steps to begin the analysis:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open up <span class="strong"><strong>ArcCatalog</strong></span> and create a folder connection to the folder containing<code class="literal"> SanFrancisco.gdb</code>. Right-click on geodatabase and add a new toolbox called <span class="strong"><strong>Chapter3Tools</strong></span>.</li><li class="listitem">Next, open <span class="strong"><strong>ModelBuilder</strong></span> and create a Model, saving it in the <span class="strong"><strong>Chapter3Tools</strong></span> toolbox as <span class="strong"><strong>Chapter3Model1.</strong></span></li><li class="listitem">Drag the <span class="strong"><strong>Bus_Stops</strong></span> feature class and the <span class="strong"><strong>Select</strong></span> tool from the <span class="strong"><strong>Analysis/Extract</strong></span> toolset in <span class="strong"><strong>ArcToolbox</strong></span>.</li><li class="listitem">Open the <span class="strong"><strong>Select</strong></span> tool and name the output feature class <code class="literal">Inbound71</code>. Make sure that the feature class is written to the <span class="strong"><strong>Chapter3Results</strong></span> feature dataset into the model.</li><li class="listitem">Open the <span class="strong"><strong>Expression </strong></span>SQL Query Builder and create the following SQL expression: <span class="strong"><strong>NAME = '71 IB' AND BUS_SIGNAG = 'Ferry Plaza'</strong></span>.<div class="mediaobject"><img src="graphics/8662OS_03_01.jpg" alt="Modeling the Select and Buffer tools"/></div></li><li class="listitem">The <a id="id125" class="indexterm"/>next step is to add a <span class="strong"><strong>Buffer</strong></span> tool from <a id="id126" class="indexterm"/>the <span class="strong"><strong>Analysis/Proximity</strong></span> toolset. The <span class="strong"><strong>Buffer</strong></span> tool <a id="id127" class="indexterm"/>will be used to create buffers around<a id="id128" class="indexterm"/> each bus stop. The buffered bus stops allow us to intersect with census data in the form of census blocks, creating the representative regions around each bus stop.</li><li class="listitem">Connect the output of the <span class="strong"><strong>Select</strong></span> tool (<span class="strong"><strong>Inbound71</strong></span>) to the <span class="strong"><strong>Buffer</strong></span> tool. Open up the <span class="strong"><strong>Buffer</strong></span> tool and add 400 to the <span class="strong"><strong>Distance</strong></span> field, and make the units <span class="strong"><strong>Feet</strong></span>. Leave the rest of the options blank. Click on <span class="strong"><strong>OK</strong></span> and return to the model.</li></ol></div><div class="mediaobject"><img src="graphics/8662OS_03_02.jpg" alt="Modeling the Select and Buffer tools"/></div></div><div class="section" title="Adding the Intersect tool"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec33"/>Adding the Intersect tool</h2></div></div></div><p>Now that <a id="id129" class="indexterm"/>we have selected the bus line of interest, and buffered<a id="id130" class="indexterm"/> the stops to create representative regions, we will need to intersect the regions with the census blocks to find the population of each representative region:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, add the <span class="strong"><strong>CensusBlocks2010</strong></span> feature class from the <span class="strong"><strong>SanFrancisco</strong></span> feature dataset to the model.</li><li class="listitem">Next, add the <span class="strong"><strong>Intersect</strong></span> tool, located in the <span class="strong"><strong>Analysis/Overlay</strong></span> toolset in <span class="strong"><strong>ArcToolbox</strong></span>. While we could use <span class="strong"><strong>Spatial Join</strong></span> to achieve a similar result, I am using the <span class="strong"><strong>Intersect</strong></span> tool to capture the area of intersect for use later in the model and script.</li></ol></div><p>At this point, our model should look like this:</p><div class="mediaobject"><img src="graphics/8662OS_03_03.jpg" alt="Adding the Intersect tool"/></div></div><div class="section" title="Tallying the analysis results"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec34"/>Tallying the analysis results</h2></div></div></div><p>After we <a id="id131" class="indexterm"/>created this simple analysis, the next step is to <a id="id132" class="indexterm"/>determine the results for each bus stop. Finding the number of people that live in census blocks touched by the 400 feet buffer of each bus stop involves examining each row of data in the final feature class and selecting rows that correspond to the bus stop. Once these are selected, a sum of the selected rows would be calculated either using the <span class="strong"><strong>Field Calculator</strong></span> or the <span class="strong"><strong>Summarize</strong></span> tool. All of these methods will work, and yet none are perfect. They take too long, and worse, are not repeatable automatically if an assumption in the model is adjusted (if the buffer is adjusted from 400 feet to 500 feet, for instance).</p><p>This is where the traditional uses of ModelBuilder begin to fail analysts. It should be easy to instruct the model to select all rows associated with each bus stop, and then generate a summed population figure for each bus stop's representative region. It would be even better to have the model create a spreadsheet to contain the final results of the analysis. It's time to use Python to take this analysis to the next level.</p></div></div>
<div class="section" title="Exporting the model and adjusting the script"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Exporting the model and adjusting the script</h1></div></div></div><p>While <a id="id133" class="indexterm"/>modeling analysis in ModelBuilder has its drawbacks, there is one <a id="id134" class="indexterm"/>fantastic option built into ModelBuilder; the ability to create a model and then export the model to Python. Along with the ArcGIS help documentation, it is the best way to discover the correct Python syntax to use when writing ArcPy scripts.</p><p>Create a folder that can hold the exported scripts next to the <span class="strong"><strong>SanFrancisco </strong></span>geodatabase (for example, <code class="literal">C:\Projects\Scripts</code>). This will hold both the exported scripts that ArcGIS automatically generates, and the versions that we will build from those generated scripts.</p><p>Open the<a id="id135" class="indexterm"/> model called <span class="strong"><strong>Chapter3Model1</strong></span> and click on the <span class="strong"><strong>Model</strong></span> menu <a id="id136" class="indexterm"/>in the upper left. Select <span class="strong"><strong>Export</strong></span> from the menu, and then select <span class="strong"><strong>To Python Script</strong></span>. Save the script in the script folder as <code class="literal">Chapter3Model1.py</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>Note that there is also the option to export the model as a graphic. Creating a graphic of the model is a good way to share what the model is doing with other analysts without the need to share the model and the data, and can also be useful when sharing Python scripts as well.</p></div></div><div class="section" title="The automatically generated script"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec35"/>The automatically generated script</h2></div></div></div><p>Open<a id="id137" class="indexterm"/> the automatically generated script in an IDE. It should look like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># -*- coding: utf-8 -*-</strong></span>
<span class="strong"><strong># ---------------------------------------------------------------------------</strong></span>
<span class="strong"><strong># 8662_Chapter3Model1.py</strong></span>
<span class="strong"><strong># Created on: 2014-04-22 21:59:31.00000</strong></span>
<span class="strong"><strong>#   (generated by ArcGIS/ModelBuilder)</strong></span>
<span class="strong"><strong># Description:</strong></span>
<span class="strong"><strong># ---------------------------------------------------------------------------</strong></span>
<span class="strong"><strong># Import arcpy module</strong></span>
<span class="strong"><strong>import arcpy</strong></span>
<span class="strong"><strong># Local variables:</strong></span>
<span class="strong"><strong>Bus_Stops = "C:\\Projects\\PacktDB.gdb\\SanFrancisco\\Bus_Stops"</strong></span>
<span class="strong"><strong>CensusBlocks2010 = "C:\\Projects\\PacktDB.gdb\\SanFrancisco\\CensusBlocks2010"</strong></span>
<span class="strong"><strong>Inbound71 = "C:\\Projects\\PacktDB.gdb\\Chapter3Results\\Inbound71"</strong></span>
<span class="strong"><strong>Inbound71_400ft_buffer = "C:\\Projects\\PacktDB.gdb\\Chapter3Results\\Inbound71_400ft_buffer"</strong></span>
<span class="strong"><strong>Intersect71Census = "C:\\Projects\\PacktDB.gdb\\Chapter3Results\\Intersect71Census"</strong></span>
<span class="strong"><strong># Process: Select</strong></span>
<span class="strong"><strong>arcpy.Select_analysis(Bus_Stops,</strong></span>
<span class="strong"><strong>                      Inbound71,</strong></span>
<span class="strong"><strong>                      "NAME = '71 IB' AND BUS_SIGNAG = 'Ferry Plaza'")</strong></span>
<span class="strong"><strong># Process: Buffer</strong></span>
<span class="strong"><strong>arcpy.Buffer_analysis(Inbound71,</strong></span>
<span class="strong"><strong>                      Inbound71_400ft_buffer,</strong></span>
<span class="strong"><strong>                      "400 Feet", "FULL", "ROUND", "NONE", "")</strong></span>
<span class="strong"><strong># Process: Intersect</strong></span>
<span class="strong"><strong>arcpy.Intersect_analysis("C:\\Projects\\PacktDB.gdb\\Chapter3Results\\Inbound71_400ft_buffer #;C:\\Projects\\PacktDB.gdb\\SanFrancisco\\CensusBlocks2010 #", Intersect71Census, "ALL", "", "INPUT")</strong></span>
</pre></div><p>Let's <a id="id138" class="indexterm"/>examine this script line by line. The first line is preceded by a pound sign (#), which again means that this line is a comment; however, it is not ignored by the Python interpreter when the script is executed as usual but is used to help Python interpret the encoding of the script as described here: <a class="ulink" href="http://legacy.python.org/dev/peps/pep-0263">http://legacy.python.org/dev/peps/pep-0263</a>.</p><p>The second commented line and the third line are included for decorative purposes. The next four lines, all commented, are used to provide readers with information about the script, what it is called and when it was created, along with a description that is pulled from the model's properties. Another decorative line is included to separate out the informative header from the body of the script visually. While the commented information section is nice to include in a script for other users of the script, it is not necessary.</p><p>The body of the script, or the executable portion of the script, starts with the <code class="literal">import arcpy</code> line. Import statements are, by convention, included at the top of the body of the script. In this instance, the only module that is being imported is ArcPy.</p><p>ModelBuilder's export function creates not only an executable script, but also comments each section to help mark the different sections of the script. The comments let the user know where the variables are located and where the ArcToolbox tools are being executed. The comments will grow to be superfluous as the reader grows to understand the code, but it was nice of ESRI to include the comments.</p><p>Below the import statements are the variables. In this case, the variables represent the file paths to the input and output feature classes. The variable names are derived from the names of the feature classes (the base names of the file paths). The file paths are assigned to the variables using the assignment operator (=), and the parts of the file paths are separated by two backslashes.</p></div></div>
<div class="section" title="File paths in Python"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>File paths in Python</h1></div></div></div><p>It would <a id="id139" class="indexterm"/>be good to review how file paths are used in Python compared to how they are represented in Windows. In Python, file paths are strings, and strings in Python have special characters used to represent tabs (\t), newlines (\n), or carriage returns (\r), among many others. These special characters all incorporate single backslashes, making it very hard to create a file path that uses single backslashes. This would not be a big deal, except that file paths in Windows Explorer all use single backslashes.</p><p>There are a number of methods used to avoid this issue. Python was developed within the Linux environment, where file paths have forward slashes. This more Pythonic representation is also available when using Python in a Windows environment, demonstrated as follows:</p><div class="informalexample"><pre class="programlisting">Windows Explorer: "C:\Projects\PacktDB.gdb\Chapter3Results\Intersect71Census"
Pythonic version:  "C:/Projects/PacktDB.gdb/Chapter3Results/Intersect71Census"</pre></div><p>Within a Python script, the file path with the forward slashes will work, while the Windows Explorer version might cause the script to throw an exception.</p><p>Another method used to avoid the issue with special characters is the one employed by ModelBuilder when it automatically creates the Python scripts from a model. In this case, the backslashes are escaped using a second backslash. The preceding script uses this second method to produce the following results:</p><div class="informalexample"><pre class="programlisting">Python escaped version:  "C:\\Projects\\PacktDB.gdb\\Chapter3Results\\Intersect71Census"</pre></div><p>The third method, which I prefer, is to create what is known as a raw string. This is the same as a regular string, but it includes an <span class="strong"><strong>r</strong></span> before the script begins. This r alerts the Python Interpreter that the following script does not contain any special characters or escape characters. Here is an example of how it is used:</p><div class="informalexample"><pre class="programlisting">Python raw string:  r"C:\Projects\PacktDB.gdb\Chapter3Results\Intersect71Census"</pre></div><p>Using raw strings will make it easier to grab a file path from Windows Explorer and add it to a string inside a script. It will also make it easier to avoid accidentally forgetting to include a set of double backslashes in a file path, which happens all the time and is the cause of many script bugs.</p></div>
<div class="section" title="Continuing the script analysis: the ArcPy tools"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Continuing the script analysis: the ArcPy tools</h1></div></div></div><p>The next, and <a id="id140" class="indexterm"/>most important, section of the script is where the analysis is executed. The same tools that we created in the model, the <span class="strong"><strong>Select</strong></span>, the <span class="strong"><strong>Buffer</strong></span>, and the <span class="strong"><strong>Intersect</strong></span> tools, are included in this section. The same parameters that we supplied in the model are also included here: the inputs and outputs, plus the SQL statement in the Select tool, and the buffer distance in the <span class="strong"><strong>Buffer</strong></span> tool.</p><p>The tool<a id="id141" class="indexterm"/> parameters are supplied to the tools in the script in the same order as they appear in the tool interfaces in the model. Here is the <span class="strong"><strong>Select</strong></span> tool in the script:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>arcpy.Select_analysis(Bus_Stops, Inbound71, "NAME = '71 IB' AND BUS_SIGNAG = 'Ferry Plaza'")</strong></span>
</pre></div><p>It works like this. The arcPy module has a method, or a special property, called <code class="literal">Select_analysis</code>. This method, when called, requires three parameters: the input feature class (or shapefile), the output feature class, and the SQL statement. In this example, the input is represented by the variable <code class="literal">Bus_Stops</code> and the output feature class is represented by the variable <code class="literal">Inbound71</code>, both of which are defined in the variable section. The SQL statement is included as the third parameter. Note that it could also be represented by a variable, if the variable was defined above this line; the SQL statement, as a string, could be assigned to a variable and the variable could replace the SQL statement as the third parameter. Here is an example of parameter replacement using a variable:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sqlStatement = "NAME = '71 IB' AND BUS_SIGNAG = 'Ferry Plaza'"</strong></span>
<span class="strong"><strong>arcpy.Select_analysis(Bus_Stops, Inbound71, sqlStatement)</strong></span>
</pre></div><p>While ModelBuilder is good about assigning input and output feature classes to variables, it does not assign variables to every portion of the parameter. This will be an important thing to correct when we adjust and build our own scripts.</p><p>The <span class="strong"><strong>Buffer</strong></span> tool accepts a similar set of parameters as the <span class="strong"><strong>Select</strong></span> tool. There is an input feature class represented by a variable, an output feature class variable, and the distance that we provided (400 feet in this case), along with a series of parameters that are supplied by default. Note that the parameters rely on keywords, and these key words can be adjusted within the text of the script to adjust the resulting buffer output. For instance, Feet could be adjusted to Meters and the buffer would much larger. Check the help section of the tool to better understand how the other parameters will affect the buffer and to find the key words arguments that will be accepted by the <span class="strong"><strong>Buffer</strong></span> tool in ArcPy. Also, as noted earlier, all of the parameters could be assigned to variables, which can save time if the same parameters are used repeatedly throughout a script.</p><p>Sometimes the supplied parameter is merely an empty string, as is the case here with the last parameter:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>arcpy.Buffer_analysis(Inbound71,Inbound71_400ft_buffer,</strong></span>
<span class="strong"><strong>                      "400 Feet", "FULL", "ROUND", "NONE", "")</strong></span>
</pre></div><p>The empty string, which in this case signifies that there is not a dissolve field for this buffer, is found quite frequently within ArcPy. It could also be represented by two single quotes, but ModelBuilder has been built to use double quotes to encase strings.</p><div class="section" title="The Intersect tool and string manipulation"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec36"/>The Intersect tool and string manipulation</h2></div></div></div><p>The last <a id="id142" class="indexterm"/>tool, the Intersect tool, uses a<a id="id143" class="indexterm"/> different method to represent the files that need to be intersected together when the tool is executed. Because the tool accepts multiple files in the input section (meaning there is no limit to the number of files that can be intersected together in one operation), it stores all of the file paths within one string. The string uses the hash or pound sign (#) to separate the file paths within the input string. This slight deviation must be dealt with if we are to use the Intersect tool in a Script tool. If we are building a tool from this script, we will not know the files that will be intersected before they are run, so we need to know the methods to deal with inserting variables into strings.</p><p>There are three methods to insert variables into strings. Each method has different advantages and disadvantages of a technical nature. It's good to know about all three of them as they have uses beyond our needs here, so let's review them.</p><div class="section" title="The string manipulation method 1–string addition"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec19"/>The string manipulation method 1–string addition</h3></div></div></div><p>String <a id="id144" class="indexterm"/>addition is an odd concept at first as it would not seem <a id="id145" class="indexterm"/>possible to add strings together, unlike integers or floats, which are numbers. However, within Python and other programming languages, this is a normal step. Using the plus sign (+), strings are added together to make longer strings or allow variables to be added to the middle of existing strings. Here are some examples of this process:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; aString = "This is a string"</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; bString = " and this is another string"</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; aString + bString</strong></span>
</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>'This is a string and this is another string'</strong></span>
</pre></div><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; cString = aString + bString</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; cString</strong></span>
</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>'This is a string and this is another string'</strong></span>
</pre></div><p>Two or more strings can be added together, and can even be assigned to a third variable. This process can be useful for situations such as the input string for the Intersect tool. The string can be broken up and variables representing the file paths can be inserted into the middle of the string:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>filePath1 = r"C:\Projects\Inbound71_400ft_buffer"</strong></span>
<span class="strong"><strong>filePath2 =  r"C:\Projects\CensusBlocks2010"</strong></span>
<span class="strong"><strong>arcpy.Intersect_analysis(filePath1 + " #;" + filePath2 + " #", Intersect71Census, "ALL", "", "INPUT")</strong></span>
</pre></div><p>This is <a id="id146" class="indexterm"/>a powerful and useful way to insert the file <a id="id147" class="indexterm"/>paths into the input string. As long as the separators are still included in the string, the string will still be valid and the Intersect tool will run as expected. Here is what the string will look like when the string addition is completed:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; filePath1 = r"C:\Projects\Inbound71_400ft_buffer"</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; filePath2 =  r"C:\Projects\CensusBlocks2010"</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; inputString = filePath1 + " #;" + filePath2 + " #"</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print inputString</strong></span>
</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>C:\Projects\Inbound71_400ft_buffer #;C:\Projects\CensusBlocks2010 #</strong></span>
</pre></div><p>Another similar offshoot of string addition is string multiplication, where strings are multiplied by an integer to produce repeated versions of the string:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt;"string" * 3</strong></span>
</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>'stringstringstring'</strong></span>
</pre></div></div><div class="section" title="The string manipulation method 2–string formatting #1"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec20"/>The string manipulation method 2–string formatting #1</h3></div></div></div><p>The second<a id="id148" class="indexterm"/> method of string manipulation, known <a id="id149" class="indexterm"/>as string formatting, involves adding placeholders into the string that will accept specific kinds of data. This means that these special strings can accept other strings as well as integers and float values. These placeholders use the modulo (%) and a key letter to indicate the type of data to expect. Strings are represented using <span class="strong"><strong>%s</strong></span>, floats are represented using <span class="strong"><strong>%f</strong></span>, and integers are represented using <span class="strong"><strong>%d</strong></span>. The floats can also be adjusted to limit the digits included by adding a modifying number after the modulo. If there is more than one placeholder in a string, the values are passed to the string in a tuple.</p><p>This method has become less popular since the third method discussed in the following section was introduced in Python 2.6, but it is still valuable to know as many older scripts use it. Here is an example of this method:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; origString = "This string has as a placeholder %s"</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; newString = origString % "and this text was added"</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print newString</strong></span>
</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>This string has as a placeholder and this text was added</strong></span>
</pre></div><p>Here is <a id="id150" class="indexterm"/>an example when using a float placeholder:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; floatString1 = "This string has a float here: %f"</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; newString = floatString1 % 1.0</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print newString</strong></span>
</pre></div><p>The output<a id="id151" class="indexterm"/> is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>This string has a float here: 1.000000</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; floatString2 = "This string has a float here: %.1f"</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; newString2 = floatString2 % 1.0</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print newString2</strong></span>
</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>This string has a float here: 1.0</strong></span>
</pre></div><p>Here is an example using an integer placeholder:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; intString = "Here is an integer: %d"</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; newString = intString % 1</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print newString</strong></span>
</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Here is an integer: 1</strong></span>
</pre></div><p>For the <span class="strong"><strong>Intersect</strong></span> tool, the %s symbol can be used to accept the file path string variables:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>filePath1 = r"C:\Projects\Inbound71_400ft_buffer"</strong></span>
<span class="strong"><strong>filePath2 =  r"C:\Projects\CensusBlocks2010"</strong></span>
<span class="strong"><strong>arcpy.Intersect_analysis("%s #;%s #" % (filePath1,filePath2), Intersect71Census, "ALL", "", "INPUT")</strong></span>
</pre></div></div><div class="section" title="The string manipulation method 3–string formatting #2"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec21"/>The string manipulation method 3–string formatting #2 </h3></div></div></div><p>The final method, the most recently introduced, is also known as string formatting. It is similar to the string formatting discussed earlier, with the added benefit of not requiring a specific type of placeholder. The placeholders, or tokens as they are also known, are only required to be in order to be accepted. The format function is built into strings; by adding <code class="literal">.format</code> to the string, and passing in parameters, the string accepts the values:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; formatString = "This string has 3 tokens: {0}, {1}, {2}"</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; newString = formatString.format("String", 2.5, 4)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print newString</strong></span>
<span class="strong"><strong>The output is as follows:</strong></span>
<span class="strong"><strong>This string has 3 tokens: String, 2.5, 4</strong></span>
</pre></div><p>The tokens don't have to be in order within the string, and can even be repeated. The order is<a id="id152" class="indexterm"/> derived from the parameters supplied<a id="id153" class="indexterm"/> to the <code class="literal">.format</code> function that passes the values to the string.</p><p>For the <span class="strong"><strong>Intersect</strong></span> tool, the string formatting would look like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>filePath1 = r"C:\Projects\Inbound71_400ft_buffer"</strong></span>
<span class="strong"><strong>filePath2 =  r"C:\Projects\CensusBlocks2010"</strong></span>
<span class="strong"><strong>arcpy.Intersect_analysis("{0} #;{1} #".format(filePath1,filePath2), Intersect71Census, "ALL", "", "INPUT")</strong></span>
</pre></div><p>The third method has become my go-to method for string manipulation because of the ability to add the values repeatedly and make it possible to avoid supplying the wrong type of data to a specific placeholder, unlike the second method.</p></div></div></div>
<div class="section" title="Adjusting the Script"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Adjusting the Script</h1></div></div></div><p>Now is<a id="id154" class="indexterm"/> the time to take the automatically generated script and adjust it to fit our needs. We want the script to both produce the output data, and to have it analyze the data and tally the results into a spreadsheet. This spreadsheet will hold an averaged population value for each bus stop. The average will be derived from each census block that the buffered representative region surrounding the stops intersected. Save the original script as <code class="literal">Chapter3Model1Modified</code>.<code class="literal">py</code>.</p></div>
<div class="section" title="Adding the CSV module to the script"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Adding the CSV module to the script</h1></div></div></div><p>For this <a id="id155" class="indexterm"/>script, we will use the <span class="strong"><strong>CSV</strong></span> module, a useful<a id="id156" class="indexterm"/> module to create Comma Separated Value spreadsheets. Its simple syntax will make it a useful tool to create script outputs. It should be noted that ArcGIS for Desktop also installs the <span class="strong"><strong>xlrd</strong></span> and <span class="strong"><strong>xlwt</strong></span> modules, used to read or generate Excel spreadsheets respectively, when it is installed.</p><p>Just below the import arcPy line, add <code class="literal">import csv</code>. This will allow us to use the csv module to create the spreadsheet:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># Import arcpy module</strong></span>
<span class="strong"><strong>import arcpy</strong></span>
<span class="strong"><strong>import csv</strong></span>
</pre></div><p>The next adjustment is made to the <span class="strong"><strong>Intersect</strong></span> tool. Notice that the two paths included in the input string are also defined as variables in the variable section. Remove the file paths from the<a id="id157" class="indexterm"/> input strings and replace them with numbered <a id="id158" class="indexterm"/>placeholder tokens, and then add the format function and supply the variables as placeholders:</p><div class="informalexample"><pre class="programlisting"># Process: Intersect
arcpy.Intersect_analysis("{0} #;{1}#".format( ..............  Inbound71_400ft_buffer,CensusBlocks2010),
                         Intersect71Census, "ALL", "", "INPUT")</pre></div><div class="section" title="Accessing the data: Using a cursor"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec37"/>Accessing the data: Using a cursor</h2></div></div></div><p>Now <a id="id159" class="indexterm"/>that the script is in place to generate the raw data we need, we <a id="id160" class="indexterm"/>need a way to access the data held in the output feature class from the <span class="strong"><strong>Intersect</strong></span> tool. This access will allow us to aggregate the rows of data representing each bus stop. We also need something to hold the aggregate data in the memory, to be written to the spreadsheet.</p><p>To accomplish the second part, we will use a Python dictionary. To accomplish the first part, we will use a method built into the ArcPy module: the Data Access Search Cursor.</p><p>The Python dictionary will be added below the <span class="strong"><strong>Intersect</strong></span> tool. A dictionary in Python is created using curly brackets. Add the following line to the script:</p><p>dataDictionary = {}</p><p>This script will use the Bus Stop IDs as keys for the dictionary. The values will be lists, which will hold all of the population values associated with each Bus Stop ID. Add the following lines to generate a Data Cursor:</p><div class="informalexample"><pre class="programlisting">with arcpy.da.SearchCursor(Intersect71Census, ["STOPID","POP10"]) as cursor:
    for row in cursor:
        busStopID = row[0]
        pop10 = row[1]
        if busStopID not in dataDictionary.keys():
            dataDictionary[busStopID] = [pop10]
        else:
            dataDictionary[busStopID].append(pop10)</pre></div><p>This iteration combines a few ideas in Python and ArcPy. The with … as statement is used to create a variable (cursor) that represents the <code class="literal">arcpy.da.SearchCursor</code> object. It could also be written like this:</p><div class="informalexample"><pre class="programlisting">cursor = arcpy.da.SearchCursor(Intersect71Census, ["STOPID","POP10"])</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p>The advantage of the with ... as structure is that the cursor object is erased from memory when the iteration is completed, which eliminates locks on the feature classes being evaluated.</p></div></div><p>The <code class="literal">arcpy.da.SearchCursor()</code> function requires an input feature class, and a list of fields to be returned. Optionally, a SQL statement can limit the number of rows returned.</p><p>The next<a id="id161" class="indexterm"/> line, <code class="literal">for row in cursor</code>, is the iteration through<a id="id162" class="indexterm"/> the data. It is not a normal Pythonic iteration, a distinction that will have ramifications in certain instances. For instance, however, it does allow for row-by-row access to data contained within the supplied feature class. Note that when using a Search Cursor, each row of data is returned as a tuple, which cannot be modified. The data can be accessed using indexes, as shown in the preceding code, where the two members of the tuple are assigned to variables.</p><p>The if/else conditional allows the data to be sorted. As noted earlier, the Bus Stop IDs, which are the first member of the data included in the tuple, will be used as a key. The conditional evaluates whether the Bus Stop ID is included in the dictionary's existing keys (which are contained in a list and accessed using the <code class="literal">dictionary.keys()</code> method). If it is not, it is added to the keys, and assigned a value that is a list containing (at first) one piece of data, the population value contained in that row. If it does exist in the keys, the list is appended with the next population value associated with that Bus Stop ID. With this code, we have now sorted each census block population according to the Bus Stop with which it is associated.</p><p>Next, we need to add code to create the spreadsheet. This code will use the same with ... as structure, and will generate an average population value by using two built-in Python functions, <code class="literal">sum</code>, which creates a sum from a list of numbers, and <code class="literal">len</code>, which will get the length of a list, tuple, or string:</p><div class="informalexample"><pre class="programlisting">with open(r'C:\Projects\Output\Averages.csv', 'wb') as csvfile:
    csvwriter = csv.writer(csvfile, delimiter=',')
    for busStopID in dataDictionary.keys():
        popList = dataDictionary[busStopID]
        averagePop = sum(popList)/len(popList)
        data = [busStopID, averagePop]
        csvwriter.writerow(data)</pre></div><p>The average population value is retrieved from the dictionary using the Bus Stop ID key, and then assigned to the variable <code class="literal">averagePop</code>. The two data pieces, the <code class="literal">BusStopID</code> and the <code class="literal">averatePop</code> variable are then added to a list, which is supplied to a <code class="literal">CSVwriter</code> object, which knows how to accept the data and write it to a file located at the file path supplied to the built-in Python <code class="literal">the open()</code> function, used to create simple files.</p><p>The script is complete, although it is nice to add one more line at the end to give us visual confirmation that the script has run:</p><div class="informalexample"><pre class="programlisting">print "Data Analysis Complete"</pre></div><p>This will<a id="id163" class="indexterm"/> create an output indicating that the script has run. Once <a id="id164" class="indexterm"/>it is done, go to the location of the output csv file and open it, using Excel or Notepad, and see the results of the analysis. Our first script is complete!</p></div></div>
<div class="section" title="The final script"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec26"/>The final script</h1></div></div></div><p>Here is<a id="id165" class="indexterm"/> how the script should look in the end:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># -*- coding: utf-8 -*-</strong></span>
<span class="strong"><strong># ---------------------------------------------------------------------------</strong></span>
<span class="strong"><strong># 8662_Chapter3Model1.py</strong></span>
<span class="strong"><strong># Created on: 2014-04-22 21:59:31.00000</strong></span>
<span class="strong"><strong>#   (generated by ArcGIS/ModelBuilder)</strong></span>
<span class="strong"><strong># Description:</strong></span>
<span class="strong"><strong># ---------------------------------------------------------------------------</strong></span>

<span class="strong"><strong># Import arcpy module</strong></span>
<span class="strong"><strong>import arcpy</strong></span>
<span class="strong"><strong>import csv</strong></span>

<span class="strong"><strong># Local variables:</strong></span>
<span class="strong"><strong>Bus_Stops = r"C:\Projects\PacktDB.gdb\SanFrancisco\Bus_Stops"</strong></span>
<span class="strong"><strong>CensusBlocks2010 = r"C:\Projects\PacktDB.gdb\SanFrancisco\CensusBlocks2010"</strong></span>
<span class="strong"><strong>Inbound71 = r"C:\Projects\PacktDB.gdb\Chapter3Results\Inbound71"</strong></span>
<span class="strong"><strong>Inbound71_400ft_buffer = r"C:\Projects\PacktDB.gdb\Chapter3Results\Inbound71_400ft_buffer"</strong></span>
<span class="strong"><strong>Intersect71Census = r"C:\Projects\PacktDB.gdb\Chapter3Results\Intersect71Census"</strong></span>

<span class="strong"><strong># Process: Select</strong></span>
<span class="strong"><strong>arcpy.Select_analysis(Bus_Stops,</strong></span>
<span class="strong"><strong>                      Inbound71,</strong></span>
<span class="strong"><strong>                      "NAME = '71 IB' AND BUS_SIGNAG = 'Ferry Plaza'")</strong></span>
<span class="strong"><strong># Process: Buffer</strong></span>
<span class="strong"><strong>arcpy.Buffer_analysis(Inbound71,</strong></span>
<span class="strong"><strong>                      Inbound71_400ft_buffer,</strong></span>
<span class="strong"><strong>                      "400 Feet", "FULL", "ROUND", "NONE", "")</strong></span>
<span class="strong"><strong># Process: Intersect</strong></span>
<span class="strong"><strong>arcpy.Intersect_analysis("{0} #;{1} #".format(Inbound71_400ft_buffer,CensusBlocks2010),</strong></span>
<span class="strong"><strong>                         Intersect71Census, "ALL", "", "INPUT")</strong></span>

<span class="strong"><strong>dataDictionary = {}</strong></span>

<span class="strong"><strong>with arcpy.da.SearchCursor(Intersect71Census, ["STOPID","POP10"]) as cursor:</strong></span>
<span class="strong"><strong>    for row in cursor:</strong></span>
<span class="strong"><strong>        busStopID = row[0]</strong></span>
<span class="strong"><strong>        pop10 = row[1]</strong></span>
<span class="strong"><strong>        if busStopID not in dataDictionary.keys():</strong></span>
<span class="strong"><strong>            dataDictionary[busStopID] = [pop10]</strong></span>
<span class="strong"><strong>        else:</strong></span>
<span class="strong"><strong>            dataDictionary[busStopID].append(pop10)</strong></span>

<span class="strong"><strong>with open(r'C:\Projects\Output\Averages2.csv', 'wb') as csvfile:</strong></span>
<span class="strong"><strong>    spamwriter = csv.writer(csvfile, delimiter=',')</strong></span>
<span class="strong"><strong>    for busStopID in dataDictionary.keys():</strong></span>
<span class="strong"><strong>        popList = dataDictionary[busStopID]</strong></span>
<span class="strong"><strong>        averagePop = sum(popList)/len(popList)</strong></span>
<span class="strong"><strong>        data = [busStopID, averagePop]</strong></span>
<span class="strong"><strong>        spamwriter.writerow(data)</strong></span>

<span class="strong"><strong>print "Data Analysis Complete"</strong></span>
</pre></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Summary</h1></div></div></div><p>In this chapter, we covered how to craft a model of an analysis and export it to a script. After discussing the script, we adjusted the script to include a results analysis and summation, which was outputted to a CSV file. In particular, we discussed how to use ModelBuilder to create an analysis and export it as a script, and how to adjust the script to be more Pythonic. We also briefly touched on the use of Search Cursors, which will be covered in greater detail in <a class="link" href="ch05.html" title="Chapter 5. ArcPy Cursors – Search, Insert, and Update">Chapter 5</a>, <span class="emphasis"><em>ArcPy Cursors – Search, Insert, and Update.</em></span> Also, we saw how built-in modules such as the CSV module can be used along with ArcPy to capture analysis output in formatted spreadsheets.</p><p>In the next chapter, we will discuss how to create more complex scripts and build functions to avoid repeating code. These functions will make it possible to write code once and use it forever. This reuse of code will demonstrate how Python goes beyond automation of analysis to become a new productivity toolset.</p></div></body></html>