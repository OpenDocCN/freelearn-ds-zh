- en: Chapter 10. Visualizing Your Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Generating a leaflet web map with Folium
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up TileStache to serve tiles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizing DEM data with Three.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Draping an orthophoto over a DEM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The great part about geospatial analysis is visualization. This chapter is all
    about showing some ways to visualize your analysis results. Up to this point,
    we have used QGIS, leaflet, and Openlayers 3 to see our results. Here, we will
    concentrate on web mapping with some of the newest libraries to publish our data.
  prefs: []
  type: TYPE_NORMAL
- en: Most of this code will mix Python with JavaScript, HTML, and CSS.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An awesome list of visualization techniques and libraries can be found at [http://selection.datavisualization.ch/](http://selection.datavisualization.ch/).
  prefs: []
  type: TYPE_NORMAL
- en: Generating a leaflet web map with Folium
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a web map with your own data is becoming easier with every new web
    mapping library. Folium ([http://folium.readthedocs.org/](http://folium.readthedocs.org/))
    is a small new Python project that can create a simple web map directly from your
    Python code, leveraging the leaflet JavaScript mapping library. This is still
    more than one line, but with under 20 lines of Python code, you can have Folium
    generate a nice web map for you.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Folium requires the Jinja2 template engine alongside Pandas for data binding.
    The nice part about this is that both are simple to install using `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Instructions on using Pandas are also found in [Chapter 1](ch01.html "Chapter 1. Setting
    Up Your Geospatial Python Environment"), *Setting Up Your Geospatial Python Environment*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now make sure that you are in your `/ch10/code/` folder to see the live example
    of Folium as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Folium uses the Jinja2 Python template engine to render the final results and
    Pandas to bind the CSV statistic data. The code begins with importing and then
    defining the data sources. The GeoJSON file of the U.S. State polygons will be
    displayed as a **chloropleth map**. A choropleth map is one that displays data
    values that are classified into a defined set of data ranges, usually based on
    some statistical method. Within the GeoJSON data is a key-filed named `id` with
    a value the U.S. State abbreviation code. This `id` binds the spatial data to
    the statistic CSV column that also includes a corresponding `id` field, hence
    allowing us to connect our two datasets.
  prefs: []
  type: TYPE_NORMAL
- en: Folium then needs to create a `map` object, setting the `map` center coordinates
    alongside a zoom level and a base tile map for our background. In our case, the
    `Stamen Toner` tile set is defined.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we define the vector GeoJSON that is going to appear on top of our
    background map. We need to pass in the path of our source GeoJSON and the Pandas
    data frame object that references our CSV file columns, `State` and `Unemployment`.
    Next, we set the linking key value that connects our CSV with the GeoJSON data.
    The `key_on` parameter reads the `id` GeoJSON properties key in the feature array.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we set the color brewer to a color we want along with the style. The
    legend is a D3 legend that's automatically created for us and is scaled via quantiles.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/50790OS_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting up TileStache to serve tiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have data and want to get it onto the Web, a server of some sort is
    required. TileStache, originally developed by Michal Migurski, is a Python tile
    map server that can pump out vector tiles. Vector tiles are the future of web
    mapping and make web map applications super fast. In the end, you will have a
    `TileStache` instance running and serving up a simple web map.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A few requirements are needed to get TileStache running on your machine, including
    Werkzeug, PIL, SimpleJson, and Modestmaps, so we must first install these. Let''s
    start with running our `pip install` commands like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Getting `TileStache` to run on a full-blown server, such as Nginx or Apache,
    with `mod-python` is beyond the scope of this book but is highly recommended for
    production deployment (for more information on this refer to [http://modpython.org/](http://modpython.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The Python library called `Werkzeug` ([http://werkzeug.pocoo.org/](http://werkzeug.pocoo.org/))
    is the WSGI server for our test application. Mapnik is not required, but go ahead
    and install it to view the demo application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let's download the most recent code from GitHub as a ZIP from [https://github.com/TileStache/TileStache/archive/master.zip](https://github.com/TileStache/TileStache/archive/master.zip).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Use the command-line `git` if you have it installed as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Unpack this into your `/ch10/TileStache-master` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Test and check whether your installation went smoothly by going into your `/ch10/TileStache-master/`
    directory and entering the following command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After running the preceding command, you should see this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now open up your web browser and type in `http://localhost:8080/`; you should
    see some simple text stating `TileStache belows hello`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, try to enter `http://localhost:8080/osm/0/0/0.png`; you will get the following
    output:![How to do it...](img/50790OS_10_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is the map of the world that you should be able to see.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To get a live scrollable map around Vancouver, British Colombia, visit `http://localhost:8080/osm/preview.html#10/49.1725/-123.0719`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visualizing DEM data with Three.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have a great 3D **Digital Elevation Model** (**DEM**) that you may want
    to view on a web page, so your choices are limited only to your imagination and
    programming skills. In this little example based on the great work of Bjorn Sandvik,
    we will explore the methods needed to manipulate a DEM to load a Three.js HTML-based
    web page.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A great plugin that I would highly recommend for QGIS is the **qgis2threejs**
    plugin, written by Minoru Akagi. The Python plugin code is available on GitHub
    at [https://github.com/minorua/Qgis2threejs](https://github.com/minorua/Qgis2threejs)
    where you can find a nice `gdal2threejs.py` converter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting 3D DEM mesh can be viewed in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Visualizing DEM data with Three.js](img/50790OS_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need Jinja2 as our template engine (installed in the first section of this
    chapter) to create our HTML. The remaining requirements include JavaScript and
    our 3D DEM data. Our DEM data is from [Chapter 7](ch07.html "Chapter 7. Raster
    Analysis"), *Raster Analysis*, and is located in the `/ch07/geodata/dem_3857.dem`
    folder, so if you have not already downloaded all the data and code, do so now.
  prefs: []
  type: TYPE_NORMAL
- en: The `gdal_translate` GDAL executable is used to convert our DEM into an ENVI
    `.bin` 16-bit raster. This raster will contain the elevation values that the `threejs`
    library can read to create the 3D mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using an IDE is not always necessary, but in this case, the PyCharm Pro IDE
    is helpful since we are using HTML, JavaScript, and Python to create our results.
    There is also a free PyCharm community edition that I would also recommend but
    it lacks the HTML, JavaScript, and Jinja2 template support.
  prefs: []
  type: TYPE_NORMAL
- en: Three.js is available if you have downloaded the `/ch10/www/js` folder on your
    machine. If not, do so now and download the entire `/ch10/www/` folder. Inside
    it, you will find the folders needed for the output of HTML and the web templates
    used by Jinja2.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll start by running a subprocess call to generate the needed raster with
    elevation data for Three.js. Then, we''ll step into the HTML template code containing
    a single `Jinja2` variable as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our Jinja2 HTML template code only contains one simple variable called `{{
    dem_3d }}` so that you can see what''s happening clearly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our `gdal_translate` does the hard work for us by converting the DEM data into
    a raster format that Three.js can understand. The Jinja2 template HTML code shows
    us the required moving parts, starting with three JavaScript files. `TerrainLoader.js`
    reads this binary `.bin` format raster into the Three.js terrain.
  prefs: []
  type: TYPE_NORMAL
- en: Inside our HTML file, the JavaScript code shows how we can go about creating
    the Three.js scene where the most important part is creating `THREE.PlaneGeometry`.
    We assign each `geometry.vertices` the elevation height in this JavaScript `for`
    loop, assigning each vertex the flat plane of the elevation value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We follow this with `MeshPhongMaterial` so that we can see the mesh on our
    screen as a wireframe. To view the resulting HTML file generated, you need to
    run a local web server and for this, Python comes with `SimpleHTTPServer` out
    of the box. This can be run from the command line as the following Python command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Then, go visit your browser and enter `http://localhost:8080/`; select the `html`
    folder, and then click on the `ch10-03_dem3d_map.html` file.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the PyCharm IDE, you can simply open the HTML file inside PyCharm, move
    your mouse to the upper right-hand corner of the open file, and select a browser,
    such as Chrome, to open a new HTML page. PyCharm will automatically start a web
    server for you and display the 3D terrain in your selected browser.
  prefs: []
  type: TYPE_NORMAL
- en: Draping an orthophoto over a DEM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This time around, we are going to take our previous recipe to the next level
    by draping satellite imagery over our DEM to create a truly impressive 3D interactive
    web map.
  prefs: []
  type: TYPE_NORMAL
- en: '![Draping an orthophoto over a DEM](img/50790OS_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can take a look at other orthophotos from `geogratis.ca` at [http://geogratis.gc.ca/api/en/nrcan-rncan/ess-sst/77618678-421b-4a28-a0a5-b074e5f072ff.html](http://geogratis.gc.ca/api/en/nrcan-rncan/ess-sst/77618678-421b-4a28-a0a5-b074e5f072ff.html).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To drape an orthophoto directly over our DEM, we need to make sure that the
    input DEM and the orthophoto have the same extent and pixel size. For this exercise,
    you need to complete the previous section and have data available in the `/ch10/geodata/092j02_1_1.tif`
    folder. This is the orthophoto that we are going to drape over the DEM.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s dive into some code that''s full of comments for your enlightenment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our Jinja2 HTML template file looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main methodology for draping an orthophoto is the same as seen in the previous
    section, with a slight difference in the way we use the Three.js material rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Data preparation plays the biggest and most important role once again to make
    things jive together. Inside our Python code, `Ch10-04_drapeOrtho.py` uses the
    subprocess call to execute the `gdalwarp` and `gdal_translate` command-line tools.
    Gdalwarp is first used by taking the original orthophoto in EPSG:3157 and converting
    it to the EPSG:3857 Web Mercator format. At the same time, it also cuts the original
    raster to the same extent as our DEM input. This extent is achieved by reading
    the `gdalinfo whistler.bin` raster command-line call.
  prefs: []
  type: TYPE_NORMAL
- en: After this, we need to cut the raster down to size and make a 200 x 200 pixel
    image to match our DEM size. This is followed by using PIL to transform the output
    `.tif` file into a much smaller `.jpg` file that's better suited for web presentations
    and speed.
  prefs: []
  type: TYPE_NORMAL
- en: With the major leg work out of the way, we can use Jinja2 to create our output
    HTML template and pass in two `dem_file`, variables pointing to the original DEM.
    The second variable called `texture_map` points to the newly created whistler
    `.jpg` that's used to drape over the DEM.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final results are written to the `/ch10/www/html/ch10-04_dem3d_map_drape.html`
    folder for you to then open and view in the browser. To view this HTML file, you
    will need to start a local web server from the `/ch10/www/` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Then, visit the browser at `http://localhost.8080/` and you should see a draped
    image on the DEM.
  prefs: []
  type: TYPE_NORMAL
