<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Error Handling</h1></div></div></div><p>In this chapter, we will cover errors, exceptions, and how to find and fix them. Handling exceptions is an important part of writing reliable and usable code. We will introduce the basic built-in exceptions and show how to use and treat exceptions. We'll introduce debugging and show you how to use the built-in Python debugger.</p><div><div><div><div><h1 class="title"><a id="ch10lvl1sec85"/>What are exceptions?</h1></div></div></div><p>One error programmers (even experienced ones) find is when code has incorrect syntax, meaning that the code instructions are not correctly formatted.</p><p>Consider an example of Syntax error:</p><pre class="programlisting">&gt;&gt;&gt; for i in range(10)&#13;
  File “&lt;stdin&gt;”, line 1&#13;
    for i in range(10)&#13;
                      ^&#13;
SyntaxError: invalid syntax</pre><p>The error occurs because of a missing colon at the end of the <code class="literal">for</code> declaration. This is an example of an exception being raised. In the case of <code class="literal">SyntaxError</code>, it tells the programmer that the code has incorrect syntax and also prints the line where the error occurred, with an arrow pointing to where in that line the problem is.</p><p>Exceptions in Python are derived (inherited) from a base class called <code class="literal">Exception</code>. Python comes with a number of built-in exceptions. Some common exception types are listed in <em>Table 10.1,</em> (for full list of built-in exceptions refer to <em><a class="link" href="apa.html" title="Appendix . References">[38]</a></em>).</p><p>Here are two common examples of exceptions. As you might expect, <code class="literal">ZeroDivisionError</code> is raised when you try to divide by zero.</p><pre class="programlisting">def f(x):&#13;
    return 1/x&#13;
&#13;
&gt;&gt;&gt; f(2.5)&#13;
0.4 &#13;
&gt;&gt;&gt; f(0)&#13;
&#13;
Traceback (most recent call last):&#13;
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;&#13;
  File "exception_tests.py", line 3, in f&#13;
    return 1/x&#13;
ZeroDivisionError: integer division or modulo by zero</pre><div><table border="1"><colgroup><col/><col/></colgroup><tbody><tr><td>
<p>
<strong>Exception</strong>
</p>
</td><td>
<p>
<strong>Description</strong>
</p>
</td></tr><tr><td>
<p>
<code class="literal">IndexError</code>
</p>
</td><td>
<p>Index is out of bounds, for example, <code class="literal">v[10]</code> when v only has 5 elements</p>
</td></tr><tr><td>
<p>
<code class="literal">KeyError</code>
</p>
</td><td>
<p>A reference to an undefined dictionary key</p>
</td></tr><tr><td>
<p>
<code class="literal">NameError</code>
</p>
</td><td>
<p>A name not found, for example, an undefined variable</p>
</td></tr><tr><td>
<p>
<code class="literal">LinAlgError</code>
</p>
</td><td>
<p>Errors in the <code class="literal">linalg</code> module, for example, when solving a system with a singular matrix</p>
</td></tr><tr><td>
<p>
<code class="literal">ValueError</code>
</p>
</td><td>
<p>Incompatible data value, for example, when using <code class="literal">dot</code> with incompatible arrays</p>
</td></tr><tr><td>
<p>
<code class="literal">IOError</code>
</p>
</td><td>
<p>I/O operation fails, for example, "file not found"</p>
</td></tr><tr><td>
<p>
<code class="literal">ImportError</code>
</p>
</td><td>
<p>A module or name is not found on import</p>
</td></tr></tbody></table></div><p>Table10.1: Some frequently used built-in exceptions and their meaning</p><p>A division with zero raises <code class="literal">ZeroDivisionError</code> and prints out the file, line, and function name where the error occurred.</p><p>As we have seen before, arrays can only contain elements of the same data type. If you try to assign a value of an incompatible type, a <code class="literal">ValueError</code> is raised. An example, of a value error:</p><pre class="programlisting">&gt;&gt;&gt; a = arange(8.0) &#13;
&gt;&gt;&gt; a &#13;
array([ 0., 1., 2., 3., 4., 5., 6., 7.]) &#13;
&gt;&gt;&gt; a[3] = 'string'&#13;
Traceback (most recent call last): &#13;
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;&#13;
ValueError: could not convert string to float: string</pre><p>Here, <code class="literal">ValueError</code> is raised because the array contains floats and an element cannot be assigned a string value.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec106"/>Basic principles</h2></div></div></div><p>Let's look at the basic principles on how to use exceptions by raising them with <code class="literal">raise</code> and catching them with <code class="literal">try</code> statements.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec28"/>Raising exceptions</h3></div></div></div><p>Creating an error is referred to as raising an exception. You saw some examples of exceptions in the previous section. You can also define your own exceptions, of a predefined type or type-less. Raising an exception is done with the command like this:</p><pre class="programlisting">raise Exception("Something went wrong")</pre><p>It might be tempting to print out error messages when something goes wrong, for example, like this:</p><pre class="programlisting">print("The algorithm did not converge.")</pre><p>This is not recommended for a number of reasons. Firstly, printouts are easy to miss, especially if the message is buried in many other messages being printed to your console. Secondly, and more importantly, it renders your code unusable by other code. The calling code will have no way of knowing that an error occurred and therefore have no way of taking care of it.</p><p>For these reasons, it is always better to raise an exception instead. Exceptions should always contain a descriptive message, for example:</p><pre class="programlisting">raise Exception("The algorithm did not converge.")</pre><p>This message will stand out clearly for the user. It also gives the opportunity for the calling code to know that an error occurred, and to possibly find a remedy.</p><p>Here is a typical example of checking the input inside a function to make sure it is usable before continuing. For an example, a simple check for negative values and the correct data type ensures the intended input of a function to compute factorials:</p><pre class="programlisting">def factorial(n):&#13;
  if not (n &gt;=0 and isinstance(n,(int,int32,int64))):&#13;
    raise ValueError("A positive integer is expected")&#13;
    ...</pre><p>The user of the function will immediately know what the error is, if an incorrect input is given, and it is the user's responsibility to handle the exception. Note the use of the exception name when raising a predefined exception type, in this case <code class="literal">ValueError</code> followed by the message. By specifying the type of the exception, the calling code can decide to handle errors differently depending on what type of error is raised.</p><p>Summing up, it is always better to raise exceptions than to print error messages.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec29"/>Catching exceptions</h3></div></div></div><p>Dealing with an exception is referred to as catching an exception. Checking for exceptions is done with the <code class="literal">try</code> and <code class="literal">except</code> commands.</p><p>An exception stops the program execution flow and looks for the closest <code class="literal">try</code> enclosing block. If the exception is not caught, the program unit is left and it continues searching for the next enclosing <code class="literal">try</code> block in a program unit higher up in the calling stack. If no block is found and the exception is not handled, execution stops entirely; the standard traceback information is displayed.</p><p>Let's look at an example for the <code class="literal">try</code> statement:</p><pre class="programlisting">try:&#13;
    &lt;some code that might raise an exception&gt;&#13;
except ValueError:&#13;
    print("Oops, a ValueError occurred")</pre><p>In this case, if the code inside the <code class="literal">try</code> block raises an error of type <code class="literal">ValueError</code>, the exception will be caught and the message in the <code class="literal">except</code> block printed. If no exception occurs inside the <code class="literal">try</code> block, the <code class="literal">except</code> block is skipped entirely and execution continues.</p><p>The <code class="literal">except</code> statement can catch multiple exceptions. This is done by simply grouping them in a tuple, like this:</p><pre class="programlisting">except (RuntimeError, ValueError, IOError):</pre><p>The <code class="literal">try</code> block can also have multiple <code class="literal">except</code> statements. This makes it possible to handle exceptions differently depending on the type. Let's see an example of multiple exception types:</p><pre class="programlisting">try:&#13;
    f = open('data.txt', 'r')&#13;
    data = f.readline()&#13;
    value = float(data)&#13;
except OSError as oe:&#13;
    print("{}:  {}".format(oe.strerror, oe.filename))&#13;
except ValueError:&#13;
    print("Could not convert data to float.")</pre><p>Here an <code class="literal">OSError</code> will be caught if, for example, the file does not exist; and a <code class="literal">ValueError</code> will be caught if, for example, the data in the first line of the file is not compatible with the float data type.</p><p>In this example we assigned the <code class="literal">OSError</code> to a variable <code class="literal">oe</code> by the keyword <code class="literal">as</code>. This allows to access more details when handling this exception. Here we printed the error string <code class="literal">oe.strerror</code> and the name of the related file <code class="literal">oe.filename</code>. Each error type can have its own set of variables depending on the type. If the file does not exist, in the preceding example, the message will be:</p><pre class="programlisting">I/O error(2): No such file or directory</pre><p>On the other hand, if the file exists but you don’t have permission to open it, the message will be:</p><pre class="programlisting">I/O error(13): Permission denied</pre><p>This is a useful way to format the output when catching exceptions.</p><p>The <code class="literal">try</code>  -  <code class="literal">except</code> combination can be extended with optional <code class="literal">else</code> and <code class="literal">finally</code> blocks. An example of using <code class="literal">else</code> can be seen in section <em>Testing the bisection algorithm</em> of <a class="link" href="ch13.html" title="Chapter 13. Testing">Chapter 13</a>, <em>Testing</em>. Combining <code class="literal">try</code> with <code class="literal">finally</code> gives a useful construction when cleanup work needs to happen at the end:</p><p>An example for making sure a file is closed properly:</p><pre class="programlisting">try:&#13;
    f = open('data.txt', 'r')&#13;
    # some function that does something with the file&#13;
    process_file_data(f) &#13;
except: &#13;
    ... &#13;
finally:&#13;
    f.close()</pre><p>This will make sure that the file is closed at the end no matter what exceptions are thrown while processing the file data. Exceptions that are not handled inside the <code class="literal">try</code> statement are saved and raised after the <code class="literal">finally</code> block. This combination is used in the <code class="literal">with</code> statement; see section <em>Context Managers - the with statement</em>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec107"/>User-defined exceptions</h2></div></div></div><p>Besides the built-in Python exceptions, it is also possible to define your own exceptions. Such user-defined exceptions should inherit from the <code class="literal">Exception</code> base class. This can be useful when you define your own classes like the polynomial class in section <em>Polynomials</em> of <a class="link" href="ch14.html" title="Chapter 14. Comprehensive Examples">Chapter 14</a>, <em>Comprehensive Examples</em>.</p><p>Take a look at this small example of a simple user-defined exception:</p><pre class="programlisting">class MyError(Exception):&#13;
    def __init__(self, expr):&#13;
        self.expr = expr&#13;
    def __str__(self):&#13;
        return str(self.expr)&#13;
&#13;
try:&#13;
   x = random.rand()&#13;
   if x &lt; 0.5:&#13;
      raise MyError(x)&#13;
except MyError as e:&#13;
   print("Random number too small", e.expr)&#13;
else:&#13;
   print(x)</pre><p>A random number is generated. If the number is below 0.5, an exception is thrown and a message that the value is too small is printed. If no exception is raised, the number is printed.</p><p>In this example, you also saw a case of using <code class="literal">else</code> in a <code class="literal">try</code> statement. The block under <code class="literal">else</code> will be executed if no exception occurs.</p><p>It is recommended that you define your exceptions with names that end in <code class="literal">Error</code>, like the naming of the standard built-in exceptions.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec108"/>Context managers - the with statement</h2></div></div></div><p>There is a very useful construction in Python for simplifying exception handling when working with contexts, such as files or databases. The statement encapsulates the <code class="literal">try ... finally</code> structure in one simple command. Here is an example of using <code class="literal">with</code> to read a file:</p><pre class="programlisting">with open('data.txt', 'r') as f:&#13;
    process_file_data(f)</pre><p>This will try to open the file, run the specified operations on the file (for example, reading), and close the file. If anything goes wrong during the execution of <code class="literal">process_file_data</code>, the file is closed properly and then the exception is raised. This is equivalent to:</p><pre class="programlisting">f = open('data.txt', 'r')&#13;
try: &#13;
    # some function that does something with the file &#13;
    process_file_data(f) &#13;
except:&#13;
    ... &#13;
finally:&#13;
    f.close()</pre><p>We will use this option in section <em>File handling</em> of <a class="link" href="ch12.html" title="Chapter 12. Input and Output">Chapter 12</a>, <em>Input and Output</em>, when reading and writing files.</p><p>The preceding file reading example is an example of using context managers. Context managers are Python objects with two special methods, <code class="literal">_ _enter_ _</code> and <code class="literal">_ _exit_ _</code>. Any object of a class that implements these two methods can be used as a context manager. In this example, the file object <code class="literal">f</code>  is a context manager as there are <code class="literal">f._ _enter_ _</code> and <code class="literal">f._ _exit_ _</code> methods.</p><p>The <code class="literal">_ _enter_ _</code> method should implement the initialization instructions, for example, opening a file or a database connection. If this method has a return statement, the returned object is accessed using the <code class="literal">as</code> construct. Otherwise, the <code class="literal">as</code> keyword is omitted. The <code class="literal">_ _exit_ _</code> method contains the cleanup instructions, for example, closing a file or committing transactions and closing a database connection. For more explanations and an example of a self-written context manager, see the section <em>Timing with a context manager</em> of <a class="link" href="ch13.html" title="Chapter 13. Testing">Chapter 13</a>, <em>Testing</em>.</p><p>There are NumPy functions that can be used as context managers. For example, the <code class="literal">load</code> function supports context manager for some file formats. NumPy's function <code class="literal">errstate</code> can be used as a context manager to specify floating-point error handling behavior within a block of code.</p><p>Here is an example of working with errstate and a context manager:
</p><pre class="programlisting">import numpy as np      # note, sqrt in NumPy and SciPy &#13;
                        # behave differently in that example&#13;
with errstate(invalid='ignore'):&#13;
    print(np.sqrt(-1)) # prints 'nan'&#13;
&#13;
with errstate(invalid='warn'):&#13;
    print(np.sqrt(-1)) # prints 'nan' and &#13;
                   # 'RuntimeWarning: invalid value encountered in sqrt'&#13;
&#13;
with errstate(invalid='raise'):&#13;
    print(np.sqrt(-1)) # prints nothing and raises FloatingPointError</pre><p>Refer section <em>Infinite and Not a Number</em> of <a class="link" href="ch02.html" title="Chapter 2. Variables and Basic Types">Chapter 2</a>, <em>Variables and Basic Types</em>, for more details on this example and section <em>Timing with a context manager</em> of <a class="link" href="ch13.html" title="Chapter 13. Testing">Chapter 13</a>, <em>Testing </em>for another example.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec86"/>Finding Errors: Debugging</h1></div></div></div><p>Errors in software code are sometimes referred to as <em>bugs</em>. Debugging is the process of finding and fixing bugs in code. This process can be performed at varying degrees of sophistication. The most efficient way is to use a tool called debugger. Having unittests in place is a good way to identify errors early, refer section <em>Using unittest</em> of <a class="link" href="ch13.html" title="Chapter 13. Testing">Chapter 13</a>, <em>Testing</em>. When it is not obvious where or what the problem is, a debugger is very useful.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec109"/>Bugs</h2></div></div></div><p>There are typically two kinds of bugs:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An exception is raised and not caught.</li><li class="listitem" style="list-style-type: disc">The code does not function properly.</li></ul></div><p>The first case is usually easier to fix. The second can be more difficult as the problem can be a faulty idea or solution, a faulty implementation, or a combination of the two.</p><p>We are only concerned with the first case in what follows, but the same tools can be used to help find why the code does not do what it is supposed to.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec110"/>The stack</h2></div></div></div><p>When an exception is raised, you see the call stack. The call stack contains the trace of all the functions that called the code where the exception was raised.</p><p>A simple stack example:</p><pre class="programlisting">def f():&#13;
   g()&#13;
def g():&#13;
   h()&#13;
def h():&#13;
   1//0&#13;
&#13;
f()</pre><p>The stack in this case is <code class="literal">f</code>,<code class="literal"> g</code>, and <code class="literal">h</code>. The output generated by running this piece of code looks like this:</p><pre class="programlisting">Traceback (most recent call last):&#13;
  File "stack_example.py", line 11, in &lt;module&gt;&#13;
    f() &#13;
  File "stack_example.py", line 3, in f&#13;
    g() &#13;
  File "stack_example.py", line 6, in g&#13;
    h() File "stack_example.py", line 9, in h&#13;
    1//0 &#13;
ZeroDivisionError: integer division or modulo by zero</pre><p>The error is printed. The sequence of functions leading up to the error is shown. The function  <code class="literal">f</code>  on line 11 was called, which in turn called <code class="literal">g</code> and then <code class="literal">h</code>. This caused the <code class="literal">ZeroDivisionError</code>.</p><p>A stack trace reports on the active stack certain point in the execution of a program. A stack trace lets you track the sequence of functions called up to a given point. Often this is after an uncaught exception has been raised. This is sometimes called post-mortem analysis, and the stack trace point is then the place where the exception occurred. Another option is to invoke a stack trace manually to analyze a piece of code where you suspect there is an error, perhaps before the exception occurs.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec111"/>The Python debugger</h2></div></div></div><p>Python comes with its own built-in debugger called pdb. Some development environments come with the debugger integrated. The following process still holds in most of these cases.</p><p>The easiest way to use the debugger is to enable stack tracing at the point in your code that you want to investigate. Here is a simple example of triggering the debugger based on the example mentioned in section <em>Return values </em>of <a class="link" href="ch07.html" title="Chapter 7. Functions">Chapter 7</a>, <em>Functions</em>:</p><pre class="programlisting">import pdb&#13;
&#13;
def complex_to_polar(z):&#13;
    pdb.set_trace() &#13;
    r = sqrt(z.real ** 2 + z.imag ** 2)&#13;
    phi = arctan2(z.imag, z.real)&#13;
    return (r,phi)&#13;
z = 3 + 5j &#13;
r,phi = complex_to_polar(z)&#13;
&#13;
print(r,phi)</pre><p>The <code class="literal">pdb.set_trace()</code> command starts the debugger and enables tracing of subsequent commands. The preceding code will show this:</p><pre class="programlisting">&gt; debugging_example.py(7)complex_to_polar()&#13;
-&gt; r = sqrt(z.real ** 2 + z.imag ** 2) &#13;
(Pdb)</pre><p>The debugger prompt is indicated with (Pdb). The debugger stops the program execution and gives you a prompt that lets you inspect variables, modify variables, step through commands, and so on.</p><p>The current line is printed at each step, so you can follow where you are and what will happen next. Stepping through commands is done with the command <code class="literal">n</code> (next), like this:</p><pre class="programlisting">&gt; debugging_example.py(7)complex_to_polar() &#13;
-&gt; r = sqrt(z.real ** 2 + z.imag ** 2) &#13;
(Pdb) n &#13;
&gt; debugging_example.py(8)complex_to_polar() &#13;
-&gt; phi = arctan2(z.imag, z.real) &#13;
(Pdb) n &#13;
&gt; debugging_example.py(9)complex_to_polar() &#13;
-&gt; return (r,phi) &#13;
(Pdb) &#13;
...</pre><p>The command <code class="literal">n</code> (next)  will continue to the next line and print the line. If you need to see more than one line at the time, the list command <code class="literal">l</code> (list) shows the current line with surrounding code:</p><p>Listing surrounding code in the debugger:</p><pre class="programlisting">&gt; debugging_example.py(7)complex_to_polar() &#13;
-&gt; r = sqrt(z.real ** 2 + z.imag ** 2) &#13;
(Pdb) l&#13;
  2&#13;
  3 import pdb&#13;
  4&#13;
  5 def complex_to_polar(z):&#13;
  6 pdb.set_trace()&#13;
  7 -&gt; r = sqrt(z.real ** 2 + z.imag ** 2)&#13;
  8 phi = arctan2(z.imag, z.real)&#13;
  9 return (r,phi)&#13;
 10&#13;
 11 z = 3 + 5j&#13;
 12 r,phi = complex_to_polar(z) &#13;
(Pdb)</pre><p>Inspection of variables can be done by printing their values to the console using the command <code class="literal">p</code> (print) followed by the variable name. An example of printing variables:</p><pre class="programlisting">&gt; debugging_example.py(7)complex_to_polar() &#13;
-&gt; r = sqrt(z.real ** 2 + z.imag ** 2) &#13;
(Pdb) p z &#13;
(3+5j) (Pdb) n &#13;
&gt; debugging_example.py(8)complex_to_polar() &#13;
-&gt; phi = arctan2(z.imag, z.real) &#13;
(Pdb) p r &#13;
5.8309518948453007 &#13;
(Pdb) c &#13;
(5.8309518948453007, 1.0303768265243125)</pre><p>The <code class="literal">p</code> (print) command will print the variable; command <code class="literal">c</code> (continue) continues execution.</p><p>Changing a variable in mid-execution is useful. Simply assign the new value at the debugger prompt and step or continue the execution.</p><p>An example of changing variables:</p><pre class="programlisting">&gt; debugging_example.py(7)complex_to_polar() &#13;
-&gt; r = sqrt(z.real ** 2 + z.imag ** 2) &#13;
(Pdb) z = 2j &#13;
(Pdb) z &#13;
2j &#13;
(Pdb) c &#13;
(2.0, 1.5707963267948966)</pre><p>Here the variable <code class="literal">z</code> is assigned a new value to be used throughout the remaining code. Note that the final printout has changed.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec112"/>Overview - debug commands</h2></div></div></div><p>In <em>Table 10.2</em>, the most common debug commands are shown. For a full listing and description of commands, (see the documentation <a class="link" href="apa.html" title="Appendix . References">[25]</a> for more information). Note that any Python command also works, for example, assigning values to variables.</p><div><div><h3 class="title"><a id="tip26"/>Tip</h3><p><strong>Short variable names</strong></p><p>If you want to inspect a variable with a name that coincides with any of the debugger's short commands, for example, <code class="literal">h</code>, you must use <code class="literal">!h</code> to display the variable.</p></div></div><div><table border="1"><colgroup><col/><col/></colgroup><tbody><tr><td>
<p>
<strong>Command</strong>
</p>
</td><td>
<p>
<strong>Action</strong>
</p>
</td></tr><tr><td>
<p>
<code class="literal">h</code>
</p>
</td><td>
<p>Help (without arguments, it prints available commands)</p>
</td></tr><tr><td>
<p>
<code class="literal">l</code>
</p>
</td><td>
<p>List the code around the current line</p>
</td></tr><tr><td>
<p>
<code class="literal">q</code>
</p>
</td><td>
<p>Quit (exits the debugger and the execution stops)</p>
</td></tr><tr><td>
<p>
<code class="literal">c</code>
</p>
</td><td>
<p>Continue execution</p>
</td></tr><tr><td>
<p>
<code class="literal">r</code>
</p>
</td><td>
<p>Continue execution until the current function returns</p>
</td></tr><tr><td>
<p>
<code class="literal">n</code>
</p>
</td><td>
<p>Continue execution until the next line</p>
</td></tr><tr><td>
<p>
<code class="literal">p &lt;expression&gt;</code>
</p>
</td><td>
<p>Evaluate and print the expression in the current context</p>
</td></tr></tbody></table></div><p>Table10.2: The most common debug commands for the debugger.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec113"/>Debugging in IPython
</h2></div></div></div><p>IPython comes with a version of the debugger called <code class="literal">ipdb</code>. At the time of writing this book, the differences are very minor but this may change.</p><p>There is a command in IPython that automatically turns on the debugger in case of an exception. This is very useful when experimenting with new ideas or code. An example of how to automatically turn on the debugger in IPython:</p><pre class="programlisting">In [1]: %pdb # this is a so - called IPython magic command &#13;
Automatic pdb calling has been turned ON&#13;
&#13;
In [2]: a = 10&#13;
&#13;
In [3]: b = 0&#13;
&#13;
In [4]: c = a/b&#13;
___________________________________________________________________&#13;
ZeroDivisionError                  Traceback (most recent call last) &#13;
&lt;ipython-input-4-72278c42f391&gt; in &lt;module&gt;() &#13;
—-&gt; 1 c = a/b&#13;
&#13;
ZeroDivisionError: integer division or modulo by zero &#13;
&gt; &lt;ipython-input-4-72278c42f391&gt;(1)&lt;module&gt;()&#13;
      -1 c = a/b&#13;
ipdb&gt;</pre><p>The IPython magic command <code class="literal">%pdb</code> at the IPython prompt automatically enables the debugger when exceptions are raised. Here the debugger prompt shows <code class="literal">ipdb</code> instead to indicate that the debugger is running.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec87"/>Summary</h1></div></div></div><p>The key concepts in this chapter were exceptions and errors. We showed how an exception is raised to be later in another program unit caught. You can define your own exceptions and equip them with messages and current values of given variables.</p><p>Code may return unexpected results without throwing an exception. The technique to localize the source of the erroneous result is called debugging. We introduced debugging methods and hopefully encouraged you to train them so that you have them readily available when needed. The need for serious debugging comes sooner than you might expect.</p></div></body></html>