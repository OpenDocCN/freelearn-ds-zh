- en: Maintenance, Optimization, and Performance Tuning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Organizing the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the correct data privilege mechanism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backing up the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using indexes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clustering for efficiency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing SQL queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Migrating a PostGIS database to a different server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replicating a PostGIS database with streaming replication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Geospatial sharding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paralellizing in PosgtreSQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike prior chapters, this chapter does not discuss the capabilities or applications
    of PostGIS. Instead, it focuses on the techniques for organizing the database,
    improving the query performance, and ensuring the long-term viability of the spatial
    data.
  prefs: []
  type: TYPE_NORMAL
- en: These techniques are frequently ignored by most PostGIS users until it is too
    late - for example, when data has already been lost because of users' actions
    or the performance has already decreased as the volume of data or number of users
    increased.
  prefs: []
  type: TYPE_NORMAL
- en: Such neglect is often due to the amount of time required to learn about each
    technique, as well as the time it takes implement them. This chapter attempts
    to demonstrate each technique in a distilled manner that minimizes the learning
    curve and maximizes the benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important things to consider when creating and using a database
    is how to organize the data. The layout should be decided when you first establish
    the database. The layout can be decided on or changed at a later date, but this
    is almost guaranteed to be a tedious, if not difficult, task. If it is never decided
    on, a database will become disorganized over time and introduce significant hurdles
    when upgrading components or running backups.
  prefs: []
  type: TYPE_NORMAL
- en: By default, a new PostgreSQL database has only one **schemaÂ **- namely, `public`.
    Most users place all the data (their own and third-party modules, such as PostGIS)
    in the `public` schema. Doing so mixes different information from various origins.
    An easy method with which to separate the information is by using schemas. This
    enables us to use one schema for our data and a separate schema for everything
    else.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create a database and install PostGIS in its own schema.
    We will also load some geometries and rasters for future use by other recipes
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the two methods to create a PostGIS-enabled database:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `CREATE EXTENSION` statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the installation SQL scripts with a PostgreSQL client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `CREATE EXTENSION` method is available if you are running PostgreSQL 9.1
    or a later version and is the recommended method for installing PostGIS:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Visit the following link to download the shapefiles for California schools
    and police stations: [http://scec.usc.edu/internships/useit/content/california-emergency-facilities-shapefile](http://scec.usc.edu/internships/useit/content/california-emergency-facilities-shapefile).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps to create and organize a database:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a database named `chapter10` by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a schema named `postgis` in the `chapter10` database, where we will
    install PostGIS. Execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Install PostGIS in the `postgis` schema of the `chapter10` database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you are running PostgreSQL 9.1 or a newer version, use the `CREATE EXTENSION`
    statement:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `WITH SCHEMA` clause of the `CREATE EXTENSION` statement instructs PostgreSQL
    to install PostGIS and its objects in the `postgis` schema.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check whether or not the PostGIS installation has succeeded by running the
    following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '****![](img/f3eebd3c-c546-4bef-ad81-18acf1521025.png)****'
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify the list of relations in the schema, which should include all the ones
    created by the extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](img/60d51d76-e3f4-419e-b465-4e6c9568bb35.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: If you are using `pgAdmin` or a similar database system, you can also check
    on the graphical interface whether the schemas, views, and table were created
    successfully.
  prefs: []
  type: TYPE_NORMAL
- en: The `SET` statement instructs PostgreSQL to consider the `public` and `postgis`
    schemas when processing any SQL statements from our client connection. Without
    the `SET` statement, the `\d` command will not return any relation from the `postgis`
    schema.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prevent the need to manually use the `SET` statement every time a client
    connects to the `chapter10` database, alter the database by executing the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: All future connections and queries to `chapter10` will result in PostgreSQL
    automatically using both `public` and `postgis` schemas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: It may be the case that, for Windows users, this option may not work
    well; in version 9.6.7 it worked but not in version 9.6.3\. If it does not work,
    you may need to clearly define the `search_path` on every command. Both versions
    are provided.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Load the PRISM rasters and San Francisco boundaries geometry, which we used
    in [Chapter 5](9e0e214c-c084-42dc-afdf-e58e021f9094.xhtml), *Working with Raster
    Data*, by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, define the search path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As we did in [Chapter 5](9e0e214c-c084-42dc-afdf-e58e021f9094.xhtml), *Working
    with Raster Data*, we will postprocess the raster filenames to a `date` column
    by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we load the San Francisco boundaries by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, define the search path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy this chapter''s dataset to its own directory by executing the following
    commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the shapefiles for California schools and police stations provided
    by the USEIT program at the University of Southern California. Import the shapefiles
    by executing the following commands; use the spatial index flag `-I` only for
    the police stations shapefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, define the search path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, define the search path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we created a new database and installed PostGIS in its own schema.
    We kept the PostGIS objects separate from our geometries and rasters without installing
    PostGIS in the `public` schema. This separation keeps the `public` schema tidy
    and reduces the accidental modification or deletion of the PostGIS objects. If
    the definition of the search path did not work, then use the explicit definition
    of the schema in all the commands, as shown.
  prefs: []
  type: TYPE_NORMAL
- en: In the following recipes, we will see that our decision to install PostGIS in
    its own schema results in fewer problems when maintaining the database.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the correct data privilege mechanism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PostgreSQL provides a fine-grained privilege system that dictates who can use
    a particular set of data and how that set of data can be accessed by an approved
    user. Because of its granular nature, creating an effective set of privileges
    can be confusing, and may result in undesired behavior. There are different levels
    of access that can be provided, from controlling who can connect to the database
    server itself, to who can query a view, to who can execute a PostGIS function.
  prefs: []
  type: TYPE_NORMAL
- en: The challenges of establishing a good set of privileges can be minimized by
    thinking of the database as an onion. The outermost layer has generic rules and
    each layer inward applies rules that are more specific than the last. An example
    of this is a company's database server that only the company's network can access.
  prefs: []
  type: TYPE_NORMAL
- en: Only one of the company's divisions can access database A, which contains a
    schema for each department. Within one schema, all users can run the `SELECT`
    queries against views, but only specific users can add, update, or delete records
    from tables.
  prefs: []
  type: TYPE_NORMAL
- en: In PostgreSQL, users and groups are known as **roles**. A role can be parent
    to other roles that are themselves parents to even more roles.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we focus on establishing the best set of privileges for the
    `postgis` schema created in the previous recipe. With the right selection of privileges,
    we can control who can use the contents of and apply operations to a geometry,
    geography, or raster column.
  prefs: []
  type: TYPE_NORMAL
- en: One aspect worth mentioning is that the owner of a database object (such as
    the database itself, a schema, or a table) always has full control over that object.
    Unless someone changes the owner, the user who created the database object is
    typically the owner of the object.
  prefs: []
  type: TYPE_NORMAL
- en: Again, when tested in Windows, the functionalities regarding the granting of
    permission worked on version 9.6.7 and did not work in version 9.6.3.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding recipe, we imported several rasters and shapefiles to their
    respective tables. By default, access to those tables is restricted to only the
    user who performed the import operation, also known as the owner. The following
    steps permit other users to access those tables:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create several groups and users in order for this recipe to demonstrate
    and test the privileges set in the `chapter10` database by executing the following
    commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The first two `CREATE ROLE` statements create the groups `group1` and `group2`.
    The last three `CREATE ROLE` statements create three users, with the `user1` and
    `user2` users assigned to `group1` and the `user3` user assigned to `group2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want `group1` and `group2` to have access to the `chapter10` database. We
    want `group1` to be permitted to connect to the database and create temporary
    tables, while `group2` should be granted all database-level privileges, so we
    use the `GRANT` statement as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check whether or not the `GRANT` statement worked by executing the following
    commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '**![](img/f1835127-0ac0-44f9-b76f-1956fc2ac59c.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, `group1` and `group2` are present in the `Access privileges`
    column of the `chapter10` database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one thing in the privileges of `chapter10` that may be of concern
    to us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the privilege listings for `group1` and `group2`, this listing has no
    value before the equal sign (`*=*`). This listing is for the special metagroup
    `public`, which is built into PostgreSQL and to which all users and groups automatically
    belong.
  prefs: []
  type: TYPE_NORMAL
- en: 'We don''t want everyone to have access to the `chapter10` database, so we need
    to use the `REVOKE` statement to remove privileges from the `public` metagroup
    by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what the initial privileges are for the schemas of the `chapter10`
    database by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ba689d1e-20bb-4ea4-8f09-2a12352cbf16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `postgis` schema has no privileges listed. However, this does not mean
    that no one can access the `postgis` schema. Only the owner of the schema -`postgres`,
    in this case - can access it. We will grant access to the `postgis` schema to
    both `group1` and `group2` by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We generally do not want to grant the `CREATE` privilege in the `postgis` schema
    to any user or group. New objects (such as functions, views, and tables) should
    not be added to the `postgis` schema.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want all users and groups to have access to the `postgis` schema, we
    can grant the `USAGE` privilege to the metagroup `public` by executing the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to revoke this privilege, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Before continuing further, we should check that our privileges have been reflected
    in the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**![](img/49120cf3-41f7-4a23-8d50-fd4f88fa7982.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: Granting the `USAGE` privilege to a schema does not allow the granted users
    and groups to use any objects in the schema. The `USAGE` privilege only permits
    the users and groups to view the schema's child objects. Each child object has
    its own set of privileges, which we establish in the remaining steps.
  prefs: []
  type: TYPE_NORMAL
- en: PostGIS comes with more than 1,000 functions. It would be unreasonable to individually
    set privileges for each of those functions. Instead, we grant the `EXECUTE` privilege
    to the metagroup public and then grant and/or revoke privileges to specific functions,
    such as management functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, grant the `EXECUTE` privilege to the metagroup `public` by executing
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, revoke the `EXECUTE` privileges of the `public` metagroup for some functions,
    such as `postgis_full_version()`, by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If there are problems accessing the functions on the `postgis` schema, use
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `GRANT` and `REVOKE` statements do not differentiate between tables and
    views, so care must be taken to ensure that the applied privileges are appropriate
    for the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will grant the `SELECT`, `REFERENCES`, and `TRIGGER` privileges to the `public`
    metagroup on all `postgis` tables and views by executing the following command;
    none of these privileges gives the `public` metagroup the ability to alter the
    tables'' or views'' contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to allow `group1` to be able to insert new records into the `spatial_ref_sys`
    table, so we must execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Groups and users that are not part of `group1` (such as `group2`) can only use
    the `SELECT` statements on `spatial_ref_sys`. Groups and users that are part of
    `group1` can now use the `INSERT` statement to add new spatial reference systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s give `user2`, which is a member of `group1`, the ability to use the
    `UPDATE` and `DELETE` statements on `spatial_ref_sys` by executing the following
    command; we are not going to give anyone the privilege to use the `TRUNCATE` statement
    on `spatial_ref_sys`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'After establishing the privileges, it is always good practice to check that
    they actually work. The best way to do so is by logging into the database as one
    of the users. We will use the `user3` user to do this by executing the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, check that we can run a `SELECT` statement on the `spatial_ref_sys` table
    by executing the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Of if the schema need to be defined, use the following sentence:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](img/3bd3c608-e4e1-409e-a288-db8316e507e8.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try inserting a new record in `spatial_ref_sys` by executing the following
    commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent! Now update the records in `spatial_ref_sys` by executing the following
    commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Run a final check on the `postgis_full_version()` function by executing the
    following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we granted and revoked privileges based on the group or user,
    with security increasing as a group or user descends into the database. This resulted
    in `group1` and `group2` being able to connect to the `chapter10` database and
    use objects found in the `postgis` schema. `group1` could also insert new records
    into the `spatial_ref_sys` table. Only `user2` was permitted to update or delete
    the records of `spatial_ref_sys`.
  prefs: []
  type: TYPE_NORMAL
- en: The `GRANT` and `REVOKE` statements used in this recipe work, but they can be
    tedious to use with a command-line utility, such as `psql`. Instead, use a graphical
    tool, such as pgAdmin, that provides a grant wizard. Such tools also make it easier
    to check the behavior of the database after granting and revoking privileges.
  prefs: []
  type: TYPE_NORMAL
- en: For additional practice, set up the privileges on the `public` schema and child
    objects so that, although `group1` and `group2` will be able to run the `SELECT`
    queries on the tables, only `group2` will be able to use the `INSERT` statement
    on the `caschools` table. You will also want to make sure that an `INSERT` statement
    executed by a user of `group2` actually works.
  prefs: []
  type: TYPE_NORMAL
- en: Backing up the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maintaining functional backups of your data and work is probably the least appreciated,
    yet the most important thing you can do to improve your productivity (and stress
    levels). You may think that you don't need to have backups of your PostGIS database
    because you have the original data imported to the database, but do you remember
    all the work you did to develop the final product? How about the intermediary
    products? Even if you remember every step in the process, how much time will it
    take to create the intermediary and final products?
  prefs: []
  type: TYPE_NORMAL
- en: If any of these questions gives you pause, you need to create a backup for your
    data. Fortunately, PostgreSQL makes the backup process painless, or at least less
    painful than the alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we use PostgreSQL's `pg_dump` utility. The `pg_dump` utility
    ensures that the data being backed up is consistent, even if it is currently in
    use.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use the following steps to back up a database:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start backing up the `chapter10` database by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We use the `-f` flag to specify that the backup should be placed in the `chapter10.backup`
    file. We also use the `-F` flag to set the format of the backup output as custom
    - the most flexible and compressed of `pg_dump's` output formats by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inspect the backup file by outputting the contents onto a SQL file by executing
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: After creating a backup, it is good practice to make sure that the backup is
    valid. We do so with the `pg_restore` PostgreSQL tool. The `-f` flag instructs
    `pg_restore` to emit the restored output to a file instead of a database. The
    emitted output comprises standard SQL statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use a text editor to view `chapter10.sql`. You should see blocks of SQL statements
    for creating tables, filling created tables, and setting privileges, as shown
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '****![](img/e2db1646-4fff-42f8-aa63-7c2bda5be17e.png)****'
  prefs: []
  type: TYPE_NORMAL
- en: 'And the files continue to show information about tables, sequences, and so
    on:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](img/d95a1938-6903-40d5-8808-d5b54a8b0d3d.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we backed up the `chapter10` database using the custom format, we have
    fine-grained control over how `pg_restore` behaves and what it restores. Let''s
    extract only the `public` schema using the `-n` flag, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: If you compare `chapter10_public.sql` to the `chapter10.sql` file exported in
    the preceding step, you will see that the `postgis` schema is not restored.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see, backing up your database is easy in PostgreSQL. Unfortunately,
    backups are meaningless if they are not performed on a regular schedule. If the
    database is lost or corrupted, any work done since the last backup is also lost.
    It is recommended that you perform backups at intervals that minimize the amount
    of work lost. The ideal interval will depend on the frequency of changes made
    to the database.
  prefs: []
  type: TYPE_NORMAL
- en: The `pg_dump` utility can be scheduled to run at regular intervals by adding
    a job to the operating system's task scheduler; the instructions for doing this
    are available in the PostgreSQL wiki at [http://wiki.postgresql.org/wiki/Automated_Backup_on_Windows](http://wiki.postgresql.org/wiki/Automated_Backup_on_Windows)
    and [http://wiki.postgresql.org/wiki/Automated_Backup_on_Linux](http://wiki.postgresql.org/wiki/Automated_Backup_on_Linux).
  prefs: []
  type: TYPE_NORMAL
- en: The `pg_dump` utility is not adequate for all situations. If you have a database
    undergoing constant changes or that is larger than a few tens of gigabytes, you
    will need a backup mechanism far more robust than that discussed in this recipe.
    Information regarding these robust mechanisms can be found in the PostgreSQL documentation
    at [http://www.postgresql.org/docs/current/static/backup.html](http://www.postgresql.org/docs/current/static/backup.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are several third-party backup tools available for establishing
    robust and advanced backup schemes:'
  prefs: []
  type: TYPE_NORMAL
- en: Barman, which is available at [http://www.pgbarman.org](http://www.pgbarman.org)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pg-rman, which is available at [http://code.google.com/p/pg-rman](http://code.google.com/p/pg-rman)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A database index is very much like the index of a book (such as this one). While
    a book's index indicates the pages on which a word is present, a database column
    index indicates the rows in a table that contain a searched-for value. Just as
    a book's index does not indicate exactly where on the page a word is located,
    the database index may not be able to denote the exact location of the searched-for
    value in a row's column.
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL has several types of index, such as `B-Tree`, `Hash`, `GIST`, `SP-GIST`,
    and `GIN`. All of these index types are designed to help queries find matching
    rows faster. What makes the indices different are the underlying algorithms. Generally,
    to keep things simple, almost all PostgreSQL indexes are of the `B-Tree` type.
    PostGIS (spatial) indices are of the `GIST` type.
  prefs: []
  type: TYPE_NORMAL
- en: Geometries, geographies, and rasters are all large, complex objects, and relating
    to or among these objects takes time. Spatial indices are added to the PostGIS
    data types to improve search performance. The performance improvement comes not
    from comparing actual, potentially complex, spatial objects, but rather the simple
    bounding boxes of those objects.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, `psql` will be used as follows to time the queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We will use the `caschools` and `sfpoly` tables loaded in this chapter's first
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The best way to see how a query can be affected by an index is by running the
    query before and after the addition of an index. In this recipe, in order to avoid
    the need to define the schema, all the tables are assumed to be on the public
    schema. The following steps will guide you through the process of optimizing a
    query with an index:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following query, which returns the names of all the schools found in
    San Francisco:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The results from the query do not matter. We are more interested in the time
    it took to run the query. When we run the query three times, it runs with the
    following elapsed times; your numbers may be different from these numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The query ran quickly. But, if the query needs to be run many times (say 1,000
    times), it will take more than 500 seconds to run it that number of times. Can
    the query run faster? Use `EXPLAIN ANALYZE` to see how PostgreSQL runs the query,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding `EXPLAIN ANALYZE` before the query instructs PostgreSQL to return the
    actual plan used to execute the query, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1cedc1ca-7e3d-4fb2-8ac5-5a26b408acc9.png)'
  prefs: []
  type: TYPE_IMG
- en: What is significant in the preceding `QUERY PLAN` is `Join Filter`, which has
    consumed most of the execution time. This may be happening because the `caschools`
    table does not have a spatial index on the `geom` column.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a spatial index to the `geom` column, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Rerun the query from step 1 three times so as to minimize runtime variations.
    With a spatial index, the query ran with the following elapsed query times:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The query did not run much faster with the spatial index. What happened? We
    need to check the `QUERY PLAN`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see whether or not, or even how the `QUERY PLAN` changed in PostgreSQL
    using `EXPLAIN ANALYZE`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/beca8da3-a674-440e-b267-f282a6c016d5.png)'
  prefs: []
  type: TYPE_IMG
- en: The `QUERY PLAN` table is the same as that found in *step 4*. The query is not
    using the spatial index. Why?
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the query, we used `ST_Transform()` to reproject `caschools.geom`
    on the spatial reference system of `sfpoly.geom`. The `ST_Transform()` geometries
    used in the `ST_Intersects()` spatial test were in SRID 3310, but the geometries
    used for the `caschools_geom_idx` index were in SRID 4269\. This difference in
    spatial reference systems prevented the use of the index in the query.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a spatial index that uses geometries projected in the desired
    spatial reference system. An index that uses a function is known as a **functional
    index**. It can be created as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Rerun the query from step 1 three times to get the following output :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: That's better! The duration of the process has decreased from about 135 ms to
    60 ms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the `QUERY PLAN` table as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**![](img/b78beb79-9794-4c27-9580-9892ae640541.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: The plan shows that the query used the `caschools_geom_3310_idx` index. The
    `Index Scan` command was significantly faster than the previously used `Join Filter`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Database indices help us quickly and efficiently find the values we are interested
    in. Generally, a query using an index is faster than one that is not, but the
    performance improvement may not be to the degree found in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additional information about PostgreSQL and PostGIS indices can be found at
    the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.postgresql.org/docs/9.6/static/indexes.html](https://www.postgresql.org/docs/9.6/static/indexes.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://postgis.net/docs/using_postgis_dbmanagement.html#idm2267](https://postgis.net/docs/using_postgis_dbmanagement.html#idm2267)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss query plans in greater detail in a later recipe in this chapter.
    By understanding query plans, it becomes possible to optimize the performance
    of deficient queries.
  prefs: []
  type: TYPE_NORMAL
- en: Clustering for efficiency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most users stop optimizing the performance of a table after adding the appropriate
    indices. This usually happens because the performance reaches a point where it
    is good enough. But what if the table has millions or billions of records? This
    amount of information may not fit in the database server's RAM, thereby forcing
    hard drive access. Generally, table records are stored sequentially on the hard
    drive. But the data being fetched for a query from the hard drive may be accessing
    many different parts of the hard drive. Having to access different parts of a
    hard drive is a known performance limitation.
  prefs: []
  type: TYPE_NORMAL
- en: To mitigate hard drive performance issues, a database table can have its records
    reordered on the hard drive so that similar record data is stored next to or near
    each other. The reordering of a database table is known as **clustering** and
    is used with the `CLUSTER` statement in PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use the California schools (`caschools`) and San Francisco boundaries
    (`sfpoly`) tables for this recipe. If neither table is available, refer to the
    first recipe of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `psql` utility will be used for this recipe''s queries, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use the following steps to cluster a table:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before using the `CLUSTER` statement, check the time at which the query used
    in the previous recipe was executed by executing the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following performance numbers for three query runs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Cluster the `caschools` table using the `caschools_geom_3310_idx` index as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Rerun the query from the first step three times for the following performance
    timings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The performance improvements were not significant.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the `CLUSTER` statement on the `caschools` table did not result in a significant
    performance boost. The lesson here is that, despite the fact that the data is
    physically reordered based on the index information in order to optimize searching,
    there is no guarantee that query performance will improve on a clustered table.
    Clustering should be reserved for tables with many large records only after adding
    the appropriate indices to and optimizing queries for the tables in question.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing SQL queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When an SQL query is received, PostgreSQL runs the query through its planner
    to decide the best execution plan. The best execution plan generally results in
    the fastest query performance. Though the planner usually makes the correct choices,
    on occasion, a specific query will have a suboptimal execution plan.
  prefs: []
  type: TYPE_NORMAL
- en: 'For these situations, the following are several things that can be done to
    change the behavior of the PostgreSQL planner:'
  prefs: []
  type: TYPE_NORMAL
- en: Add appropriate column indices to the tables in question
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the statistics of the database tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rewrite the SQL query by evaluating the query's execution plan and using capabilities
    available in your PostgreSQL installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider changing or adding the layout of the database tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the query planner's configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding indices (the first bullet point) is discussed in a separate recipe found
    in this chapter. Updating statistics (the second point) is generally done automatically
    by PostgreSQL after a certain amount of table activity, but the statistics can
    be manually updated using the `ANALYZE` statement. Changing the database layout
    and the query planner's configuration (the fourth and fifth bullet point, respectively)
    are advanced operations used only when the first three points have already been
    attempted and, thus, will not be discussed further.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe only discusses the third option - that is, optimizing performance
    by rewriting SQL queries.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we will find the nearest police station to every school and
    the distance in meters between each school in San Francisco and its nearest station;
    we will attempt to do this as fast as possible. This will require us to rewrite
    our query many times to be more efficient and take advantage of the new PostgreSQL
    capabilities. For this recipe, ensure that you also include the `capolice` table.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps will guide you through the iterative process required to
    improve query performance:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To find a school''s nearest police station and the distance between each school
    in San Francisco and its nearest station, we will start by executing the following
    query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Generally speaking, this is a crude and simplistic query. The subquery `scpo`
    occurs twice in the query because it needs to compute the shortest distance from
    a school to its nearest police station and the name of the police station closest
    to each school. If each instance of `scpo` took 10 seconds to compute, two instances
    of `scpo` would take 20 seconds. This is very detrimental to performance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note: the time may vary substantially between experiments, depending on the
    machine configuration, database usage, and so on. However, the changes in the
    duration of the experiments will be noticeable and should follow the same improvement
    ratio presented in this section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The query output looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](img/2bd4c201-1c99-4e8b-9d4f-19788c436949.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](img/f80ecca2-dd69-41bc-8517-8620721fe083.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The query results provide the addresses of the schools in San Francisco, the
    addresses of the closest police station to each of those schools, and the distance
    from each school to its closest police station. However, we are also interested
    in getting the answer as fast as possible. With timing turned on in `psql`, we
    get the following performance numbers for three runs of the query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Just by looking at the query in step 1, we can see that there are redundant
    subqueries. Let''s get rid of those duplicates using **common table expressions**
    (**CTEs**), introduced in PostgreSQL 8.4\. CTEs are used to logically and syntactically
    separate a block of SQL from subsequent parts of the query. Since CTEs are logically
    separated, they are run at the start of the query execution and their results
    are cached for subsequent use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Not only is the query syntactically cleaner, but the performance is improved,
    as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The execution times went from more than 5 seconds to less than 3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Though some may stop optimizing this query at this point, we will continue
    to improve the query performance. We can use the window functions, which are another
    PostgreSQL capability introduced in v8.4\. Using the window functions as follows,
    we can get rid of the `JOIN` expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `first_value()` window function to extract the first `police_address`
    and `distance` values for each school sorted by the distance between the school
    and a police station. The improvement is considerable, reducing from almost 3
    seconds to around 1.2 seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it is worth to inspect the execution plan with `EXPLAIN ANALYZE VERBOSE`
    to see what is decreasing the query performance. Because of the verbosity of the
    output, we''ve trimmed it to just the following lines of interest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**![](img/9d14f781-b3a1-4456-8c64-bf3e42a3c659.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: In the `EXPLAIN ANALYZE VERBOSE` output, we want to inspect the values for the
    actual time, which provide the actual start and end times for that part of the
    query. Of all the actual time ranges, the actual time value of 15.047..1186.907
    for the `Nested Loop` (highlighted in the preceding output) is the worst. This
    query step consumes at least 80 percent of the total execution time, so any work
    done to improve performance must be done in this step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The columns returned from the slow `Nested Loop` utility are found in the value
    for the output. Of these columns, `st_distance()` is present only in this step
    and not in any inner step. This means we will need to mitigate the number of calls
    to `ST_Distance()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this step, further query improvements are not possible without running PostgreSQL
    9.1 or a later version. PostgreSQL 9.1 introduced indexed nearest-neighbor searches
    using the `<->` and `<#>` operators to compare the geometries' convex hulls and
    bounding boxes, respectively. For point geometries, both operators result in the
    same answer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s rewrite the query to take advantage of the `<->` operator. The following
    query still uses the CTEs and window functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The query has the following performance numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Wow! Using indexed nearest-neighbor searches with the `<->` operator, we reduced
    our initial query from one second to less than a tenth of a second.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we optimized a query that users may commonly encounter while
    using PostGIS. We started by taking advantage of the PostgreSQL capabilities to
    improve the performance and syntax of our query. When performance could no longer
    improve, we ran `EXPLAIN ANALYZE VERBOSE` to find out what was consuming most
    of the query-execution time. We learned that the `ST_Distance()` function consumed
    the most time from the execution plan. We finally used the `<->` operator of PostgreSQL
    9.1 to dramatically improve the query-execution time to under a second.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of `EXPLAIN ANALYZE VERBOSE` used in this recipe is not easy to
    understand. For complex queries, it is recommended that you use the visual output
    in pgAdmin (discussed in a separate chapter''s recipe) or the color coding provided
    by the [http://explain.depesz.com/](http://explain.depesz.com/) web service, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/26713564-98ba-4901-ae34-3e187fd27ab1.png)'
  prefs: []
  type: TYPE_IMG
- en: Migrating a PostGIS database to a different server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At some point, user databases need to be migrated to a different server. This
    need for server migration could be due to new hardware or a database-server software
    upgrade.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the three methods available for migrating a database:'
  prefs: []
  type: TYPE_NORMAL
- en: Dumping and restoring the database with `pg_dump` and `pg_restore`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing an in-place upgrade of the database with `pg_upgrade`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing streaming replication from one server to another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will use the `dump` and `restore` methods to move user data
    to a new database with a new PostGIS installation. Unlike the other methods, this
    method is the most foolproof, works in all situations, and stores a backup in
    case things don't work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned before, creating a schema specifically to work with PostGIS may
    not work properly for Windows users. Working on the `public` schema is an option
    in order to test the results.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On the command line, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though a backup file was created in this chapter''s third recipe, create
    a new backup file by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new database to which the backup file will be restored by executing
    the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Connect to the `new10`, database and create a `postgis` schema as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the `CREATE EXTENSION command to install the Postgis extension in the
    postgis schema`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure you set the `search_path` parameter to include the `postgis` schema,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Restore only the `public` schema from the backup file to the `new10` database
    by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The `restore` method runs and should not generate errors. If it does, an error
    message such as the following will appear:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: We have now installed PostGIS in the `postgis` schema, but the database server
    can't find the `ST_BandMetadata()` function. If a function cannot be found, it
    is usually an issue with `search_path`. We will fix this issue in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check what `pg_restore` actually does by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at the `COPY` statement for the prism table, everything looks fine.
    But the `search_path` method preceding the table does not include the `postgis`
    schema as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the `search_path` value in `chapter10.sql` to include the `postgis`
    schema by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Run `chapter10.sql` with `psql`, as follows; the original `chapter10.backup`
    file can''t be used because the necessary change can''t be applied to `pg_restore`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This procedure is essentially the standard PostgreSQL backup and restore cycle.
    It may not be simple, but has the benefit of being accessible in terms of the
    tools used and the control available in each step of the process. Though the other
    migration methods may be convenient, they typically require faith in an opaque
    process or the installation of additional software.
  prefs: []
  type: TYPE_NORMAL
- en: Replicating a PostGIS database with streaming replication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The reality of the world is that, given enough time, everything will break.
    This includes the hardware and software of computers running PostgreSQL. To protect
    data in PostgreSQL from corruption or loss, backups are taken using tools such
    as `pg_dump`. However, restoring a database backup can take a very long time,
    during which users cannot use the database.
  prefs: []
  type: TYPE_NORMAL
- en: When downtime must be kept to a minimum or is not acceptable, one or more standby
    servers are used to compensate for the failed primary PostgreSQL server. The data
    on the standby server is kept in sync with the primary PostgreSQL server by streaming
    data as frequently as possible.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, you are strongly discouraged from trying to mix different PostgreSQL
    versions. Primary and standby servers must run the same PostgreSQL version.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will use the streaming replication capability introduced
    in PostgreSQL 9.X. This recipe will use one server with two parallel PostgreSQL
    installations instead of the typical two or more servers, each with one PostgreSQL
    installation. We will use two new database clusters in order to keep things simple.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use the following steps to replicate a PostGIS database:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create directories for the primary and standby database clusters by executing
    the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the database clusters with `initdb` as follows, defining the user
    `me` as the owner of the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: You may opt for avoiding the `--locale=en_US.utf-8` option if an error occurs;
    in that case, the system will adopt the default locale on your computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create directories for the archives of the primary and standby database clusters
    by executing the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Open the `pg_hba.conf` authentication file of the primary cluster with your
    preferred editing application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you''re running PostgreSQL 9.0, add the following text to the end of `pg_hba.conf`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**![](img/09148717-56b5-4ed5-8162-a265d8531a68.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: For PostgreSQL 9.1 or a later version, the configuration lines are already part
    of the `pg_hba.conf` file. You just need to remove the comment character (*#*)
    from the beginning of each matching line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the primary cluster''s `postgresql.conf` configuration file to set the
    streaming replication parameters. Search for each parameter, uncomment and replace
    the assigned value to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'A relative location could also be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'When using Linux or macOS type instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Start PostgreSQL on the primary database cluster by executing the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a base backup of the primary database cluster and copy it to the standby
    database cluster. Before performing the backup, create an exclusion list file
    for `xcopy` (Windows only) by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following to `exclude.txt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the base backup and copy the directory contents from the primary to the
    standby database cluster, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Make the following changes to the standby cluster''s `postgresql.conf` configuration
    file uncommenting these parameters and adjusting the values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'A relative location could also be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'When using Linux or macOS type instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `recovery.conf` configuration file in the standby cluster directory
    by executing the following command for Windows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'For Linux or macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the following in the `recovery.conf` configuration file and save the
    changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Or a relative location could be used also:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'For Linux or macOS use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Start PostgreSQL on the standby database cluster by executing the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Run some simple tests to make sure the replication is working.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `test` database and the `test` table on the primary database server
    by executing the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Connect to the standby database server by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'See if the `test` database is present by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '****![](img/bddc7f6b-50a0-4d2b-99ff-29ae5fc3cb10.png)****'
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect to the `test` database and get the list of tables by executing the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '**![](img/49c1d6eb-9f00-4596-aeca-aba9044138f6.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Get the records, if any, in the `test` table by executing the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**![](img/24afe91f-4db6-429d-9d15-c831d6f64781.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! The streaming replication works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As demonstrated in this recipe, the basic setup for streaming replication is
    straightforward. Changes made to the primary database server are quickly pushed
    to the standby database server.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are third-party applications to help establish, administer, and maintain
    streaming replication on production servers. These applications permit complex
    replication strategies, including multimaster, multistandby, and proper failover.
    A few of these applications include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Pgpool-II, which is available at [http://www.pgpool.net](http://www.pgpool.net)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bucardo, which is available at [http://bucardo.org/wiki/Bucardo](http://bucardo.org/wiki/Bucardo)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Postgres-XC, which is available at [http://postgresxc.wikia.com/wiki/Postgres-XC_Wiki](http://postgresxc.wikia.com/wiki/Postgres-XC_Wiki)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slony-I, which is available at [http://slony.info](http://slony.info)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Geospatial sharding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with large datasets can be challenging for the database engine, especially
    when they are stored in a single table or in a single database. PostgreSQL offers
    an option to split the data into several external databases, with smaller tables,
    that work logically as one. Sharding allows distributing the load of storage and
    processing of a large dataset so that the impact of large local tables is reduced.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most important issues to make it work is the definition of a function
    to classify and evenly distribute the data. Given that this function can be a
    geographical property, sharding can be applied to geospatial data.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will use the `postgres_fdw` extension that allows the creation
    of foreign data wrappers, needed to access data stored in external PostgreSQL
    databases. In order to use this extension, we will need the combination of several
    concepts: server, foreign data wrapper, user mapping, foreign table and table
    inheritance. We will see them in action in this recipe, and you are welcome to
    explore them in detail on the PostgreSQL documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: We will use the fire hotspot dataset and the world country borders shapefile
    used in [Chapter 1](38f20dd1-ca55-47e8-80cd-21670bcb32b2.xhtml), *Moving Data
    in and out of PostGIS*, in order to distribute the records for the hotspot data
    based on a geographical criteria, we will create a new distributed version of
    the hotspot dataset.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the `postgis_cookbook` database for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you did not follow the recipes in [Chapter 1](38f20dd1-ca55-47e8-80cd-21670bcb32b2.xhtml),
    *Moving Data in and out of PostGIS*, be sure to import the hotspots (`Global_24h.csv`)
    in PostGIS. The following steps explain how to do it with `ogr2ogr` (you should
    import the dataset in their original SRID, 4326, to make spatial operations faster):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a session in the `postgis_cookbook` database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new schema `chp10` in the `postgis_cookbook` database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to create the `hotspots_dist` table, that will serve as parent for
    the foreign tables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Exit the `psql` environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Connect to the psql environment as the postgres user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the remote databases, connect them, create the `postgis` extension and
    create the foreign tables that will receive the sharded data. Then, exit the `psql`
    environment. For this, execute the following SQL commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to import the fire dataset, create a GDAL virtual data source composed
    of just one layer derived from the `Global_24h.csv` file. To do so, create a text
    file named `global_24h.vrt` in the same directory where the CSV file is and edit
    it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Import in PostGIS the `Global_24h.csv` file using the `global_24.vrt` virtual
    driver you created in a previous recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the extension `postgres_fdw` in the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the servers that will host the external databases. You need to define
    the name of the database, the host address and the port in which the database
    will receive connections. In this case we will create 4 databases, one per global
    quadrant, according to latitude and longitude in the Mercator SRID. Execute the
    following commands to create the four servers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: For this example, we will be using local databases, but the host parameter can
    be either an IP address or a database file. The user who creates these commands
    will be defined as the local owner of the servers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the user mapping in order to be able to connect to the foreign databases.
    For this, you need to write the login information of the owner of the foreign
    database in their local server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the tables in the foreign databases, based on the local table `chp10.hotspots_dist`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: The name of the table name should preferably be written in lowercase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a function that will calculate the quadrant of the point to be inserted
    in the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Insert the test coordinates (10, 10), (-10, 10) and (-10 -10). The first one
    should be stored in the NE quadrant, the second on the SE quadrant and the third
    on the SW quadrant.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the data insertion in the tables, both the local view and the external
    database `hotspots_quad_NE`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/73fec4b3-0929-4392-a90e-5c99400559aa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As can be seen, the local version shows all the points that were inserted.
    Now, execute the query over a remote database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/f93746d9-a205-44a3-a32d-f313abcd8e9d.png)'
  prefs: []
  type: TYPE_IMG
- en: The remote databases only has the point that it should store, based on the trigger
    function defined earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, insert all the points from the original hotspot table, imported in step
    8\. For this test, we will just insert the geometry information. Execute the following
    SQL sentence:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'As in *step 15*, in order to check if the results were classified and stored
    correctly, execute the following queries, to the local table `hotspots_dist` and
    the remote table `hotsports_quad_ne`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/1d1d5449-6471-42c7-ac60-4122c03183a9.png)'
  prefs: []
  type: TYPE_IMG
- en: The results show the first 10 points stored in the local logical version of
    the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/5232c5f1-508d-4e2a-ba05-33b76503e49b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The results show the first 10 points stored in the remote database with all
    the points in the NE quadrant. The points indeed show that they all have positive
    latitude and longitude values. When presented in a GIS application, the results
    is the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/db9c50fd-d050-4be5-a352-e1f6b3566399.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, a basic setup for geographical sharding is demonstrated. More
    sophisticated functions can be implemented easily on the same proposed structure.
    In addition, for heavy lifting applications purposes, there are some products
    in the market that could be explored, if considered necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example shown was based partly on a GitHub implementation found at the
    following link: [https://gist.github.com/sylr/623bab09edd04d53ee4e](https://gist.github.com/sylr/623bab09edd04d53ee4e).'
  prefs: []
  type: TYPE_NORMAL
- en: Paralellizing in PosgtreSQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to sharding, working with a large amount of rows within a geospatial
    table in postgres, will cause a lot of processing time for a single worker. With
    the release of postgres 9.6, the server is capable of executing queries which
    can be processed by multiple CPUs for a faster answer. According to the postgres
    documentation, depending of the table size and the query plan, there might not
    be a considerable benefit when implementing a parallel query, instead of a serial
    query.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we need a specific version of postgres. It is not mandatory
    for you to download and install the postgres version that will be used. The reason
    is that, some developers might have an already configured postgres database version
    with data, and having multiple servers running within a computer might cause issues
    later.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome this problem, we will make use of a **docker container**. A container
    could be defined as a lightweight instantiation of a software application that
    is isolated from other containers and your computer host. Similar to a virtual
    machine, you could have multiple versions of your software stored inside your
    host, and start multiple containers whenever necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will download docker from [https://docs.docker.com/install/](https://docs.docker.com/install/)
    and install the **Community Edition** (**CE**) version. Then, we will pull an
    already precompiled docker image. Start a Terminal and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'This docker image has PostgreSQL 10 with Postgis 2.4 and SFCGAL plugin. Now
    we need to start an instance given the image. An important part corresponds to
    the `-p 5433:5432`. These arguments maps every connection and request that is
    received at port `5433` in your host (local) computer to the `5432` port of your
    container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can connect to your PostgreSQL container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Where root and `d842288536c9` corresponds to your container username and group
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because we created an isolated instance of your postgres database, we have
    to recreate to use, database name and schema. These operations are optional. However,
    we encourage you to follow this to make this recipe consistent with the rest of
    the book:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the user `me` in your container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Reconnect to the database but now as user `me` to create database and schema:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'You are now connected to database `postgis-cookbook` as user `me`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Insert a layer into the database. In this case, we will make use of the `gis.osm_buildings_a_free_1
    shapefile` from Colombia. Make sure you have these files within the `SHP_PATH`
    before starting the container. This database insertion could be run in two forms:
    First one is inside your docker container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'The second option is in your host computer. Make sure to correctlyÂ set your
    shapefiles path and host port that maps to the `5432` container port. Also, your
    host must have `postgresql-client` installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute parallel query. Using the building table we can execute a `postgis`
    command in parallel. To check how many workers are created, we make use of the
    `EXPLAIN ANALYZE` command. So, for example, if we want to calculate the sum of
    all geometries from the table in a serial query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we modify the `max_parallel_workers` and `max_parallel_workers_per_gather`
    parameters, we activate the parallel query capability of PostgreSQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'This command prints in Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute parallel scans. For example, if we want to select polygons whose area
    is higher than a value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'This query is not executed in parallel. This happens because `ST_Area` function
    is defined with a `COST` value of `10`. A `COST` for PostgreSQL is a positive
    number giving the estimated execution cost for a function. If we increase this
    value to `100`, we can get a parallel plan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have a parallel plan and 3 workers are executing the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute parallel joins. First, we create a point table where we create randomly
    `10` points per polygon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can run a table join between two tables, which does not give us a parallel
    plan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'For this case, we need to modify the parameter `parallel_tuple_cost` which
    sets the planner''s estimate of the cost of transferring one tuple from a parallel
    worker process to another process. Setting the value to `0.001` gives us a parallel
    plan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As demonstrated in this recipe, parallelizing queries in PostgreSQL allows the
    optimization of operations that involve a large dataset. The database engine is
    already capable of implementing parallelism, but defining the proper configuration
    is crucial in order to take advantage of the functionality.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we used the `max_parallel_workers` and the `parallel_tuple_cost`
    to configure the desired amount a parallelism. We could evaluate the performance
    with the `ANALYZE` function.
  prefs: []
  type: TYPE_NORMAL
