- en: Chapter 4. Tipping the Scales
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Using quantitative scales
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using time scale
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ordinal scale
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpolating string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpolating colors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpolating compound object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing custom interpolator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a data visualization developer, one key task that you need to perform over
    and over is to map values from your data domain to visual domain, for example,
    mapping your most recent purchase of a fancy tablet of $453.00 to a 653px-long
    bar, and your last night's pub bill of $23.59 to a 34px-long bar, respectively.
    In a sense, this is what data visualization is all about—mapping data elements
    to their visual metaphor in an efficient and accurate manner. Because this is
    an absolutely essential task in data visualization and animation (animation will
    be discussed in [Chapter 6](ch06.html "Chapter 6. Transition with Style"), *Transition
    with Style*, in detail), D3 provides rich and robust support on this topic, which
    is the focus of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: What are scales?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: D3 provides various constructs called **scales** to help you perform this kind
    of mapping. Proper understanding of these constructs conceptually is crucial to
    become an effective visualization developer. This is because scales are not only
    used to perform the mapping we have mentioned previously, but also to serve as
    fundamental building blocks for many other D3 constructs, such as transition and
    axes.
  prefs: []
  type: TYPE_NORMAL
- en: What are these scales anyway?
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, scales can be thought of as mathematical **functions**. Mathematical
    functions differ from functions defined in imperative programming languages, such
    as JavaScript functions. In mathematics, a function is defined as mapping between
    two sets:'
  prefs: []
  type: TYPE_NORMAL
- en: Let A and B be nonempty sets. A *function f* from A to B is an assignment of
    exactly one element of B to each element of A. We write *f*(a) = b if b is the
    unique element of B assigned by the function *f* to the element a of A.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (Rosen K. H. 2007)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Despite the dryness of this definition, we still could not help but notice how
    nicely it fits the task we need to perform—mapping elements from the data domain
    to visual domain.
  prefs: []
  type: TYPE_NORMAL
- en: Another fundamentally important concept we need to illustrate here is the **domain**
    and **range** of a given function.
  prefs: []
  type: TYPE_NORMAL
- en: If *f* is a function from A to B, we say that A is the **domain** of *f* and
    B is the codomain of *f*. If *f*(a) = b, we say that b is the image of a and a
    is a preimage of b. The **range, or image,** of *f* is the set of all images of
    elements of A. Also, if *f* is a function from A to B, we say that *f* maps A
    to B.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (Rosen K. H. 2007)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To help us understand this concept, let''s take a look at the following illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What are scales?](img/2162OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Function f maps A to B
  prefs: []
  type: TYPE_NORMAL
- en: We can clearly see now, in the preceding illustration for function *f,* the
    domain is set **A** and the range is set **B**. Imagine if set A represents our
    data domain and B represents the visual domain, then a function *f* defined here
    is essentially a scale in D3 that maps elements from set A to set B.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the mathematically inclined readers, scale function in data visualization
    are usually **one-to-one** but not **onto** functions. This is a useful insight
    to know but not critical to the purpose of this book. Therefore, we will not discuss
    it further here.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have discussed the conceptual definition of scale functions in D3, so
    let's take a look at how it can be used to help us develop our visualization project.
  prefs: []
  type: TYPE_NORMAL
- en: Using quantitative scales
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will examine the most commonly-used scales provided by D3—the
    quantitative scales including linear, power, and logarithmic scales.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter4/quantitative-scales.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter4/quantitative-scales.html)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code generates the following output in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/2162OS_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Quantitative scale output
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we have demonstrated some of the most common scales provided
    by D3.
  prefs: []
  type: TYPE_NORMAL
- en: '**Linear Scale**'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code example, we have our data array filled with integers from
    `0` to `10`—as shown on the line marked as `A`—we created a **linear scale** by
    calling the `d3.scale.linear()` function. This returns a linear quantitative scale
    with the default domain set to `[0, 1]` and the default range set to `[0, 1]`.
    Thus the default scale is essentially the **identity function** for numbers. Therefore,
    this default function is not that useful to us, but typically needs to be further
    customized by using its `domain` and `range` functions on line `B` and `C`. In
    this case, we set them both to `[1, 10]`. This scale basically defines the function
    *f(n) = n*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![How it works...](img/2162OS_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Identity scale
  prefs: []
  type: TYPE_NORMAL
- en: 'The second linear scale is a little bit more interesting and it illustrates
    the mapping between two sets better. On line `D`, we set the range as `[1, 20]`,
    which is different from its domain. Hence, now this function is essentially representing
    the following equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '*f(n) = a * n + b*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*1 <= f(n) <= 20*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is by far the most common case when using D3 scales because your data set
    will be an identical match of your visual set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![How it works...](img/2162OS_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Linear scale
  prefs: []
  type: TYPE_NORMAL
- en: In this second scale, D3 will automatically calculate and assign the value of
    constants `a` and `b` to satisfy the equation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some basic algebraic calculation will tell you that `a` is approximately 2.11
    and `b` is -1.11, as in the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: '**Pow Scale**'
  prefs: []
  type: TYPE_NORMAL
- en: The second scale we have created is a **power scale** . On line `E`, we defined
    a power scale with `exponent` of 2\. The `d3.scale.pow()` function returns a default
    power scale function with its `exponent` set as `1`. This scale effectively defines
    the function *f(n) = n^2*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![How it works...](img/2162OS_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Simple power scale
  prefs: []
  type: TYPE_NORMAL
- en: On line `F`, a second power scale was defined, this time with a different range
    set on line `G` with rounding; the `rangeRound()` function works pretty much the
    same as the `range()` function, which sets the range for a scale. However, the
    `rangeRound` function rounds the output number so that there are no decimal fractions.
    This is very handy since scales are commonly used to map elements from the data
    domain to visual domain. So, the output of a scale is very likely to be a number
    describing some visual characteristics, for example, the number of pixels. Avoiding
    sub-pixel numbers is a useful technique that prevents anti-alias in rendering.
  prefs: []
  type: TYPE_NORMAL
- en: The second power scale defines the following function *f(n) = a*n^2 + b, 1 <=
    f(n) <= 10*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![How it works...](img/2162OS_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Power scale
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the linear scale, D3 will automatically find the suitable constants
    `a` and `b` to satisfy the constraints defined by `domain` and `range` on a power
    scale.
  prefs: []
  type: TYPE_NORMAL
- en: '**Log Scale**'
  prefs: []
  type: TYPE_NORMAL
- en: On line `H`, a third kind of quantitative scale was created using the `d3.scale.log()`
    function. The default log scale has a `base` of `10`. Line H essentially defines
    the following mathematical function *f(n) = log(n)*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![How it works...](img/2162OS_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Simple log scale
  prefs: []
  type: TYPE_NORMAL
- en: On line `I`, we customized the log scale to have a domain of `[1, 10]` and a
    rounded range of `[1, 10]`, which defines the following constrained mathematical
    function *f(n) = a*log(n) + b, 1 <= f(n) <= 10*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![How it works...](img/2162OS_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Log scale
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: D3 also provides other additional quantitative scales including quantize, threshold,
    quantile, and identity scales. Due to limited scope in this book and their relatively
    less common usage, they are not discussed here, however, the basic understanding
    of scales discussed and explained here will definitely help your understanding
    of other additional quantitative scales provided by the D3 library. For more information
    on other types of quantitative scales please visit [https://github.com/mbostock/d3/wiki/Quantitative-Scales#wiki-quantitative](https://github.com/mbostock/d3/wiki/Quantitative-Scales#wiki-quantitative)
  prefs: []
  type: TYPE_NORMAL
- en: Using the time scale
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, we perform analysis on a data set that is time- and date-sensitive, therefore,
    D3 provides a built-in time scale to help perform this type of mapping. In this
    recipe, we will learn how to use D3 time scale.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter4/time-scale.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter4/time-scale.html)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s take a look at the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This recipe generates the following visual output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/2162OS_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Time scale
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we have a `Date` range defined on line `A` between January 1,
    2013 and December 31, 2013.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The JavaScript `Date` object starts its month from `0` and day from `1`. Therefore,
    `new Date(2013, 0, 1)` gives you January 1, 2013 while `new Date(2013, 0, 0)`
    actually gives you December 31, 2012.
  prefs: []
  type: TYPE_NORMAL
- en: This range was then used to create a D3 **time scale** on line `B` using the
    `d3.time.scale` function. Similar to quantitative scales, time scale also supports
    separate `domain` and `range` definition, which is used to map date- and time-based
    data points to visual range. In this example, we set the range of the scale to
    `[0, 900]`. This effectively defines a mapping from any date-and-time value in
    time range between January 1, 2013 and December 31, 2013 to a number between 0
    and 900.
  prefs: []
  type: TYPE_NORMAL
- en: With the time scale defined, we can now map any given `Date` object by calling
    the scale function, for example, `time(new Date(2013, 4, 1))` will return `395`
    and `time(new Date(2013, 11, 15))` will return `1147`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'On line `D`, we create our data array consisting 12 months from January to
    December in 2013:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Then, on line `E`, we created 12 cells representing each month in a year using
    the `render` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'To spread the cells horizontally, line `F` performs a mapping from the month
    to the `margin-left` CSS style using the time scale we defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Line `G` generates the label to demonstrating what the scale-based mapping
    produces in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: To generate human-readable strings from a JavaScript `Date` object, we used
    a D3 time formatter on line `H`. D3 ships with a powerful and flexible time-formatting
    library, which is extremely useful when dealing with the `Date` object.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some of the most useful `d3.time.format` patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '`%a`: This is the abbreviated weekday name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%A`: This is the full weekday name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%b`: This is the abbreviated month name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%B`: This is the full month name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%d`: This is the zero-padded day of the month as a decimal number [01,31]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%e`: This is the space-padded day of the month as a decimal number [ 1,31]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%H`: This is the hour (24-hour clock) as a decimal number [00,23]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%I`: This is the hour (12-hour clock) as a decimal number [01,12]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%j`: This is the day of the year as a decimal number [001,366]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%m`: This is the month as a decimal number [01,12]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%M`: This is the minute as a decimal number [00,59]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%L`: This is the milliseconds as a decimal number [000, 999]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%p`: This is the either AM or PM'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%S`: This is the second as a decimal number [00,61]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%x`: This is the date, as "`%m/%d/%Y`"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%X`: This is the time, as "`%H:%M:%S`"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%y`: This is the year without century as a decimal number [00,99]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%Y`: This is the year with century as a decimal number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the complete reference on D3 time format pattern visit the following link:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/mbostock/d3/wiki/Time-Formatting#wiki-format](https://github.com/mbostock/d3/wiki/Time-Formatting#wiki-format)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using the ordinal scale
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some cases, we might need to map our data to some ordinal values, for example,
    `["a", "b", "c"]` or `["#1f77b4", "#ff7f0e", "#2ca02c"]`. So, how can we perform
    this kind of mapping using D3 scales? This recipe is dedicated to address this
    kind of question.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter4/ordinal-scale.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter4/ordinal-scale.html)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This kind of ordinal mapping is quite common in data visualization. For example,
    you might want to map certain data points through categorization into some textual
    value or perhaps into RGB color code, which in turn can be used in CSS styling.
    D3 offers a specialized scale implementation to handle this kind of mapping. We
    will explore its usage here. Here is the code of the `ordinal.scale.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code outputs the following in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/2162OS_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Ordinal scale
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the above code example, a simple data array containing integers from `0`
    to `9` is defined on line `A`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Then an ordinal scale was created using the `d3.scale.ordinal` function on line
    `B`. The domain of this scale was set to our integer array data while range is
    set to a list of alphabets from `a` to `j`.
  prefs: []
  type: TYPE_NORMAL
- en: With this scale defined, we can perform the mapping by simply invoking the scale
    function, for example, `alphabet(0)` will return `a`, `alphabet(4)` will return
    `e`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'On line `C`, the `render` function was defined to generate a number of `div`
    elements on the page to represent the 10 elements in a data array. Each `div`
    has its `background-color` set to scale function''s output or `white` if the output
    is not an RGB color string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'On line `E`, we also set the text of each cell to display scale function''s
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, with all the structures in place, from line `F` to `G`, the `render` function
    was repetitively called with different ordinal scales to produce different visual
    outputs. On line `F`, calling `render` with the `alphabet` ordinal scale produces
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/2162OS_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Alphabetic ordinal scale
  prefs: []
  type: TYPE_NORMAL
- en: 'While on line `G`, calling the `render` function with the built-in `d3.scale.category20c`
    ordinal color scale produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/2162OS_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Color ordinal scale
  prefs: []
  type: TYPE_NORMAL
- en: Because assigning different colors to different elements in visualization is
    a common task, for example, assigning different colors in Pie and Bubble charts,
    D3 provides a number of different built-in ordinal color scales as we have seen
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is quite easy to build your own simple custom ordinal color scale. Just
    create an ordinal scale with the range set to the colors you want to use, for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Interpolating a string
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some cases, you might need to interpolate numbers embedded in a string; perhaps
    a CSS style for font.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will examine how you can do that using D3 scale and interpolation.
    However, before we jump right into string interpolation, a bit of background research
    on interpolator is due and the following section will cover what interpolation
    is and how D3 implements interpolator functions.
  prefs: []
  type: TYPE_NORMAL
- en: Interpolator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the first three recipes, we have gone over three different D3 scale implementations,
    now it is time to delve a little deeper into D3 scales. You are probably already
    asking the question, "How different scale knows what value to use for different
    inputs?" In fact this question can be generalized to:'
  prefs: []
  type: TYPE_NORMAL
- en: We are given the values of a function f(x) at different points x0, x1, … ,xn.
    We want to find approximate values of the function f(x) for "new" x's that lie
    between these points . This process is called **interpolation**.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Kreyszig E & Kreyszig H & Norminton E. J. (2010)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Interpolation is not only important in scale implementation but also essential
    to many other core D3 capabilities, for example, animation and layout management.
    It is because of this essential role, D3 has designed a separate and re-usable
    construct called **interpolator** so that this common cross-functional concern
    can be addressed in a centralized and consistent fashion. Let''s take a simple
    interpolator as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In this simple example, we created a D3 number interpolator with a range of
    `[0, 100]`. The `d3.interpolateNumber` function returns an `interpolate` function
    which we can use to perform number-based interpolations. The `interpolate` function
    is an equivalent to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this function, `a` represents the start of the range and `b` represents the
    end of the range. The parameter `t` passed into the `interpolate()` function,
    is a float-point number ranging from 0 to 1, and it signifies how far the return
    value is from `a`.
  prefs: []
  type: TYPE_NORMAL
- en: D3 provides a number of built-in interpolators. Due to limited scope in this
    book, we will focus on some of the more interesting interpolators for the next
    few recipes; we are ending our discussion on simple number interpolation here.
    Nevertheless, the fundamental approach and mechanism remains the same whether
    it is a number or an RGB color code interpolator.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more details on number and round interpolation, please refer to the D3 reference
    documents at [https://github.com/mbostock/d3/wiki/Transitions#wiki-d3_interpolateNumber](https://github.com/mbostock/d3/wiki/Transitions#wiki-d3_interpolateNumber)
  prefs: []
  type: TYPE_NORMAL
- en: Now with general interpolation concepts behind, let's take a look at how string
    interpolator works in D3.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter4/string-interpolation.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter4/string-interpolation.html)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'String interpolator finds the numbers embedded in the string, then performs
    interpolation using D3 number interpolator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/2162OS_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: String interpolation
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we created a linear scale on line `A` with range specified
    between two strings representing start and end `font` styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the code of the `string-interpolation.html` file, the `font`
    style strings contain `font-size` numbers `12px/30px` and `120px/180px`, which
    we want to interpolate in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: On line `C`, the `render()` function simply creates 10 cells containing each
    one's index numbers (line `E`) styled using interpolated `font` style string calculated
    on line `D`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Though we demonstrated string interpolation in D3 using a CSS font style as
    an example, D3 string interpolator is not only limited handling CSS styles. It
    can basically handle any string, and interpolates the embedded number as long
    as the number matches the following **Regex pattern**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When generating a string using interpolation, very small values, when stringified,
    may get converted to scientific notation, for example, **1e-7**. To avoid this
    particular conversion, you need to keep your value larger than 1e-6.
  prefs: []
  type: TYPE_NORMAL
- en: Interpolating colors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is sometimes necessary to interpolate colors when you are interpolating values
    that do not contain numbers but rather RGB or HSL color code. This recipe addresses
    the question *how can you define* *scales for color codes and perform interpolation
    on them?*
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter4/color-interpolation.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter4/color-interpolation.html)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Color interpolation is such a common operation in visualization that D3 actually
    provides four different kinds of interpolators dedicated for color supporting—RGB,
    HSL, L*a*b*, and HCL color space. In this recipe, we will demonstrate how color
    interpolation can be performed in RGB color space. However, all other color interpolators
    work in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: D3 color interpolate function always returns interpolated color in RGB space
    no matter what the original color space it is since not all browsers support HSL
    or L*a*b* color spaces.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code produces the following visual output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/2162OS_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Color interpolation
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step in this recipe is defining a linear color scale on line `A` with
    its range set as `["white", "#4169e1"]`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: One new technique used in this recipe, that we haven't encountered yet, is the
    **poly-linear scale** , which is defined in the `divergingScale` function on line
    `B`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: A poly-linear scale is a scale with non-uniformed linear progression. It is
    achieved by providing a poly-linear domain on a linear scale as we can see on
    line `C`. You can think of a poly-linear scale as stitching two linear scales
    with different domains together. So this poly-linear color scale is effectively
    the two following linear scales combined together.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: No surprise in the rest of the recipe. The `render()` function defined on line
    `D` generates 20 cells that are numbered by its index and colored using the output
    of two color scales we defined earlier. Clicking the buttons on the web page (such
    as **Pivot at 5**) will show you the effect of pivoting at different positions
    in a poly-linear color scale.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a complete list of supported color keywords in CSS3, please refer to W3C
    official reference [http://www.w3.org/TR/css3-color/#html4](http://www.w3.org/TR/css3-color/#html4)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpolating compound objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There will be cases when what you need to interpolate in your visualization
    is not a simple value but rather an object consisting of multiple and different
    values, for example, a rectangular object with width, height, and color attributes.
    Fortunately, D3 has a built-in support for this type of compound object interpolation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter4/compound-interpolation.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter4/compound-interpolation.html)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will examine how compound object interpolation is performed
    in D3\. The code for the `compound-interpolation.html` file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code generates the following visual output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/2162OS_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Compound object interpolation
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe is different from the previous recipes of this chapter by the fact
    that the scale we use in this recipe has a range defined using two objects rather
    than simple primitive data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We can see on line `A` and `B` that the start and end of the scale range are
    two objects which contain two different kinds of values; one for RGB color and
    the other one for CSS height style. When you interpolate this kind of a scale
    containing compound range, D3 will iterate through each of the fields inside an
    object and recursively apply the simple interpolation rule on each one of them.
    Thus, in other words, for this example, D3 will interpolate the `color` field
    using color interpolation from `#add8e6` to `#4169e1` while using string interpolation
    on height field from `15px` to `150px`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The recursive nature of this algorithm allows D3 to interpolate on even nested
    objects. Therefore you can interpolate on an object like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'A compound scale function, when invoked, returns a compound object that matches
    the given range definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As we can see on line `D` and `E`, the returned value is a compound object,
    and this is why we can access its attribute to retrieve the interpolated values.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Though it is not a common case, if the start and end of your compound scale
    range do not have identical attributes, D3 won''t complain but rather it will
    just treat the missing attribute as a constant. The following scale will render
    the height to be `15px` for all the `div` elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Implementing a custom interpolator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some rare cases, you might find that the built-in D3 interpolators are not
    enough to handle your visualization requirement. In such situations, you can choose
    to implement your own interpolator with specific logic to handle your needs. In
    this recipe, we will examine this approach and demonstrate some interesting use
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter4/custom-interpolator.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter4/custom-interpolator.html)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at two different examples of custom interpolator implementation.
    In the first example, we will implement a custom function capable of interpolating
    price in dollars, while in the second one we will implement custom interpolator
    for alphabets. Here is the code to this implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code generates the following visual output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/2162OS_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Custom interpolation
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first custom interpolator we encounter in this recipe is defined on line
    `A`. The custom interpolator function is a bit more involved, so, let''s take
    a closer look at how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This custom interpolator in the following link was directly extracted from
    D3 Wiki:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/mbostock/d3/wiki/Transitions#wiki-d3_interpolators](https://github.com/mbostock/d3/wiki/Transitions#wiki-d3_interpolators)'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the line `A`, we push an interpolator function into `d3.interpolators`.
    This is a global interpolator registry array that contains all known registered
    interpolators. By default, this registry contains the following interpolators:'
  prefs: []
  type: TYPE_NORMAL
- en: Number interpolator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String interpolator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Color interpolator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object interpolator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array interpolator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any new custom interpolator implementation can be pushed to the tail of the
    interpolators array which then becomes globally available. An interpolator function
    is expected to be a factory function that takes the start of the range (`a`) and
    the end of the range (`b`) as its input parameters while returning an implementation
    of the interpolate function as seen on line `E`. You might be wondering how D3
    knows which interpolator to use when a certain string value is presented. The
    key to this lies on line `B`. Typically we use a variable called `re` defined
    as a regex pattern of `/^\$([0-9,.]+)$/`, which is then used to match both parameter
    `a` and `b` for any number with a leading dollar sign. If both parameters match
    the given pattern then the matching interpolate function is constructed and returned;
    otherwise D3 will continue iterating through `d3.interpolators` array to find
    a suitable interpolator.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of an array, `d3.interpolators` is actually better considered as a FILO
    stack (though not exactly implemented as a stack), where new interpolators can
    be pushed to the top of the stack. When selecting an interpolator, D3 will pop
    and check each suitable interpolator from the top. Therefore, in this case, the
    interpolator pushed later in the stack takes precedence.
  prefs: []
  type: TYPE_NORMAL
- en: The anonymous `interpolate()` function created on line `E` takes a single parameter
    `t` with a value ranging from `0` to `1` indicating how far off the interpolated
    value is from base `a`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You can think of it as a percentage of how far the desired value has traveled
    from `a` to `b`. With that in mind, it becomes clear that in line `F` it performs
    the interpolation and calculates the desired value based on the offset `t`, which
    effectively interpolates a price string.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One thing to watch out for here is that the `b` parameter's value has been changed
    on line `D` from the end of the range to the difference between `a` and `b`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This is generally considered a bad practice for readability. So, in your own
    implementations you should avoid modifying input parameters' value in a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the line `G`, a second custom interpolator was registered to handle single-character
    lowercase alphabets from `a` to `z`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We quickly noticed that this interpolator function follows a very similar pattern
    with the previous one. Firstly, it has a regex pattern defined on line `H` that
    matches single lowercase alphabets. After the matching is conducted on line `I`,
    the start and end of the range `a` and `b` were both converted from `character`
    values into `integer` values. A difference between `a` and `b` was calculated
    on line `J`. The interpolate function again follows exactly the same formula as
    the first interpolator as shown on line `K`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once these custom interpolators are registered with D3, we can define scales
    with corresponding ranges without doing any additional work and we will be able
    to interpolate their values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the `dollarScale` function will automatically use the price interpolator,
    while the `alphabetScale` function will use our alphabet interpolator, respectively.
    No additional work is required when invoking the scale function to obtain the
    value we need, as demonstrated on line `N`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In isolation, custom interpolator does not appear to be a very important concept;
    however, later on when exploring other D3 concepts in [Chapter 6](ch06.html "Chapter 6. Transition
    with Style"), *Transition with Style*, we will explore more powerful techniques
    when custom interpolator is combined with other D3 constructs to achieve interesting
    custom effects.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the regular expression used in this chapter is a new concept or a well-known
    tool in your toolbox and you need a little bit of dusting, you can find a lot
    of useful resources at [http://www.regular-expressions.info](http://www.regular-expressions.info)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
