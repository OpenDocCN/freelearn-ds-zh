<html><head></head><body>
        

                            
                    <h1 class="header-title">Raster Data Processing</h1>
                
            
            
                
<p class="mce-root"><strong>Geographic information systems</strong> (<strong>GIS</strong>)<strong> </strong>are often comprised of points, lines, and polygons. These data types are called vector data. There is, however, another data type in GIS—rasters. In this chapter, you will learn the basics of working with raster data. You will learn how to:</p>
<ul>
<li class="mce-root">Use the <strong>Geospatial Data Abstraction Library</strong> (<strong>GDAL</strong>) to load and query rasters</li>
<li class="mce-root">Use GDAL to modify and save rasters</li>
<li class="mce-root">Use GDAL to create rasters</li>
<li class="mce-root">Load rasters into PostgreSQL</li>
<li class="mce-root">Perform queries on rasters using PostgreSQL</li>
</ul>
<p>Installing GDAL can be difficult. By using virtual environments and running Anaconda, you can simplify this process by using the GUI of the environment.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Raster operations using GDAL</h1>
                
            
            
                
<p class="mce-root">The GDAL library allows you to read and write both vector and raster data. To install GDAL on Windows, you will need the appropriate binaries:</p>
<p>You can download OSGeo4W, which contains the binaries, at: <a href="https://trac.osgeo.org/osgeo4w/">https://trac.osgeo.org/osgeo4w/</a></p>
<p class="mce-root">When you have the binaries, you can install <kbd>gdal</kbd> using <kbd>conda</kbd>, as follows:</p>
<pre class="mce-root"><strong>conda install -c conda-forge gdal</strong></pre>
<p class="mce-root">In the following sections, you will learn how to load and work with a <kbd>.tif</kbd> file.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using the GDAL library to load and query rasters</h1>
                
            
            
                
<p class="mce-root">Now that you have <kbd>gdal</kbd> installed, import it using:</p>
<pre class="mce-root">from osgeo import gdal</pre>
<p class="mce-root">GDAL 2 is the most recent version. If you have an older version of <kbd>gdal</kbd> installed, you may need to import it using the following code:</p>
<pre class="mce-root">import gdal</pre>
<p class="mce-root">If this is the case, you may want to look into upgrading your version of <kbd>gdal</kbd>. Once you have <kbd>gdal</kbd> imported, you can open a raster image. First, let's get an image from the web. The Earth Data Analysis Center at the University of New Mexico maintains the <strong>Resource Geographic Information System</strong> (<strong>RGIS</strong>). In it, you will find New Mexico GIS data. Browse to <a href="http://rgis.unm.edu/">http://rgis.unm.edu/</a> and from the Get Data link, Select <kbd>Shaded Relief</kbd>, <kbd>General</kbd>, and <kbd>New Mexico</kbd>. Then, download the <kbd>Color Shaded Relief of New Mexico (Georeferenced TIFF)</kbd> file.</p>
<p class="mce-root">When you extract the ZIP file, you will have several files. We are only interested in <kbd>nm_relief_color.tif</kbd>. The following code will open TIF using <kbd>gdal</kbd>:</p>
<pre class="mce-root">nmtif = gdal.Open(r'C:\Desktop\ColorRelief\nm_relief_color.tif')<br/>print(nmtif.GetMetadata())</pre>
<p class="mce-root">The previous code opens TIF. It is very similar to opening any file in Python, except you used <kbd>gdal.Open</kbd> instead of the standard Python library <kbd>open</kbd>. The next line prints the metadata from the TIF, and the output is shown as follows:</p>
<pre class="mce-root"><strong>{'AREA_OR_POINT': 'Area', 'TIFFTAG_DATETIME': '2002:12:18 8:10:06', 'TIFFTAG_RESOLUTIONUNIT': '2 (pixels/inch)', 'TIFFTAG_SOFTWARE': 'IMAGINE TIFF Support\nCopyright 1991 - 1999 by ERDAS, Inc. All Rights Reserved\n@(#)$RCSfile: etif.c $ $Revision: 1.9.3.3 $ $Date: 2002/07/29 15:51:11EDT $', 'TIFFTAG_XRESOLUTION': '96', 'TIFFTAG_YRESOLUTION': '96'}</strong></pre>
<p class="mce-root">The previous metadata gives you some basic information such as dates created and revised, the resolution, and pixels per inch. One characteristic of the data we are interested in is the projection. To find it, use the following code:</p>
<pre class="mce-root">nmtif.GetProjection()</pre>
<p class="mce-root">Using the <kbd>GetProjection</kbd> method on the TIF, you will see that we didn't find any. The output of the code is as follows:</p>
<pre class="mce-root"><strong>'LOCAL_CS[" Geocoding information not available Projection Name = Unknown Units = other GeoTIFF Units = other",UNIT["unknown",1]]'</strong></pre>
<p class="mce-root">If you open this TIF in QGIS, you will get a warning that the CRS is undefined and it will default to <kbd>epsg:4326</kbd>. I know that the image is projected and we can find this out by looking at the <kbd>nm_relief_color.tif.xml</kbd> file. If you scroll to the bottom, you will see the values under the XML tag <kbd>&lt;cordsysn&gt;</kbd>, as follows:</p>
<pre class="mce-root"> &lt;cordsysn&gt;<br/> &lt;geogcsn&gt;GCS_North_American_1983&lt;/geogcsn&gt;<br/> &lt;projcsn&gt;NAD_1983_UTM_Zone_13N&lt;/projcsn&gt;<br/> &lt;/cordsysn&gt;</pre>
<p class="mce-root">If you look up the projection at <a href="http://spatialreference.org">spatialreference.org</a>, you will find that it is EPSG:26913. We can use <kbd>gdal</kbd> to set the projection, as shown in the following code:</p>
<pre class="mce-root">from osgeo import osr<br/>p=osr.SpatialReference()<br/>p.ImportFromEPSG(26913)<br/>nmtif.SetProjection(p.ExportToWkt())<br/>nmtif.GetProjection()</pre>
<p class="mce-root">The previous code imports the <kbd>osr</kbd> library. It then uses the library to create a new <kbd>SpatialReference</kbd>. Next, it imports a known reference using <kbd>ImportFromEPSG</kbd> and passes <kbd>26913</kbd>. It then uses <kbd>SetProjection</kbd>, passing the WKT for EPSG:26913. Lastly, it calls <kbd>GetProjection</kbd> so that we can see that the code worked. The results are as follows:</p>
<pre class="mce-root"><strong>'PROJCS["NAD83 / UTM zone 13N",GEOGCS["NAD83",DATUM["North_American_Datum_1983",SPHEROID["GRS 1980",6378137,298.257222101,AUTHORITY["EPSG","7019"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY["EPSG","6269"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4269"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",-105],PARAMETER["scale_factor",0.9996],PARAMETER["false_easting",500000],PARAMETER["false_northing",0],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AXIS["Easting",EAST],AXIS["Northing",NORTH],AUTHORITY["EPSG","26913"]]'</strong></pre>
<p class="mce-root">The previous output is the WKT for EPSG:26913.</p>
<p class="mce-root">Open QGIS and the TIF will load with no warnings. I can add a copy of the Albuquerque streets to it and they will appear exactly where they should. Both sets of data are in EPSG:26913. The following image shows the TIF and the streets in the center of New Mexico-Albuquerque:</p>
<div><img src="img/9b0cef82-d52f-4a47-80a9-8d062160a975.jpg" style="width:25.67em;height:24.17em;"/></div>
<p>Tif of NM with Streets shapefile</p>
<p class="mce-root">Now that we have added a projection, we can save a new version of the TIF:</p>
<pre class="mce-root">geoTiffDriver="GTiff"<br/>driver=gdal.GetDriverByName(geoTiffDriver)<br/>out=driver.CreateCopy("copy.tif",nmtif,strict=0)</pre>
<p class="mce-root">To see that the new file has the spatial reference, use the following code:</p>
<pre class="mce-root">out.GetProjection()</pre>
<p class="mce-root">The previous code will output the <strong>well-known text</strong> (<strong>WKT</strong>) for EPSG:26913, as follows:</p>
<pre class="mce-root"><strong> 'PROJCS["NAD83 / UTM zone 13N",GEOGCS["NAD83",DATUM["North_American_Datum_1983",SPHEROID["GRS 1980",6378137,298.257222101,AUTHORITY["EPSG","7019"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY["EPSG","6269"]], PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]], AUTHORITY["EPSG","4269"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian", -105],PARAMETER["scale_factor",0.9996],PARAMETER["false_easting",500000],PARAMETER["false_northing",0],UNIT["metre",1, AUTHORITY["EPSG","9001"]],AXIS["Easting",EAST],AXIS["Northing",NORTH],AUTHORITY["EPSG","26913"]]'</strong></pre>
<p class="mce-root">A color raster dataset has three bands—red, green, and blue. You can get each of the bands individually using the following code:</p>
<pre class="mce-root">nmtif.RasterCount </pre>
<p>The previous code will return <kbd>3</kbd>. Unlike an array, the bands are indexed 1-n, so a three band raster will have indexes <kbd>1</kbd>, <kbd>2</kbd>, and <kbd>3</kbd>. You can grab a single band by passing the index to <kbd>GetRasterBand()</kbd>, which is shown in the following code:</p>
<pre class="mce-root">band=nmtif.GetRasterBand(1)</pre>
<p>Now that you have a raster band, you can perform queries on it and you can lookup values at positions. To find the value at a specified row and column, you can use the following code:</p>
<pre>values=band.ReadAsArray()</pre>
<p>Now, <kbd>values</kbd> is an array, so you can lookup values by index notation, as follows:</p>
<pre style="padding-left: 60px">values[1100,1100]</pre>
<p>The previous code will return a value of <kbd>216</kbd>. In a single band array, this would be helpful, but in a colored image, you would most likely want to know the color at a location. This would require knowing the value of all three bands. You can do that by using the following code:</p>
<pre>one= nmtif.GetRasterBand(1).ReadAsArray()<br/>two = nmtif.GetRasterBand(2).ReadAsArray()<br/>three= nmtif.GetRasterBand(3).ReadAsArray()<br/>print(str(one[1100,1100])+","+ str(two[1100,1100])+","+str(three[1100,1100]))</pre>
<p>The previous code returns the values—<kbd>216, 189, 157</kbd>. These are the RGB values of the pixel. These three values are composited—overlayed on each other, which, should be the color shown in the following image:</p>
<div><img src="img/e90d25aa-315d-4910-aa30-18aaf8f72450.jpg" style="width:10.67em;height:10.83em;"/></div>
<p>The color represented by the three bands at [1100,1100]</p>
<p>With a band, you have access to several methods for obtaining information about the band. You can get the mean and standard deviation of the values, as shown in the following code:</p>
<pre>one=nmtif.GetRasterBand(1)<br/>two=nmtif.GetRasterBand(2)<br/>three=nmtif.GetRasterBand(3)<br/>one.ComputeBandStats()<br/>two.ComputeBandStats()<br/>three.ComputeBandStats()</pre>
<p>The output is shown as follows:</p>
<pre><strong>(225.05771967375847, 34.08382839593031)</strong><br/><strong>(215.3145137636133, 37.83657996026153)</strong><br/><strong>(195.34890652292185, 53.08308166590347)</strong></pre>
<p class="mce-root">You can also get the minimum and maximum values from a band, as shown in the following code:</p>
<pre class="mce-root">print(str(one.GetMinimum())+","+str(one.GetMaximum()))</pre>
<p class="mce-root">The result should be <kbd>0.0</kbd> and <kbd>255.0</kbd>. </p>
<p class="mce-root">You can also get the description of the band. The following code shows you how to get and set the description:</p>
<pre class="mce-root">two.GetDescription()    # returns 'band_2'<br/>two.SetDescription("The Green Band")<br/>two.GetDescription()    # returns "The Green Band"</pre>
<p>The most obvious thing you may want to do with a raster dataset is to view the raster in Jupyter Notebook. There are several ways to load images in a Jupyter notebook, one being using HTML and an <kbd>&lt;img&gt;</kbd>. In the following code, you are shown how to plot the image using <kbd>matplotlib</kbd>:</p>
<pre class="mce-root">import numpy as np<br/>from matplotlib.pyplot import imshow<br/>%matplotlib inline<br/><br/>data_array=nmtif.ReadAsArray()<br/>x=np.array(data_array[0])<br/># x.shape ---&gt; 6652,6300<br/>w, h =6652, 6300<br/>image = x.reshape(x.shape[0],x.shape[1]) <br/>imshow(image, cmap='gist_earth') </pre>
<p>The previous code imports <kbd>numpy</kbd> and <kbd>matplotlib.pyploy.imshow</kbd>.</p>
<p>NumPy is a popular library for working with arrays. When dealing with rasters, which are arrays, you will benefit from having a strong understanding of the library. Packt published several books on NumPy such as <em>NumPy Cookbook</em>, <em>NumPy Beginners Guide</em>, and <em>Learning NumPy Array,</em> and this<em> </em>would be a good place to start learning more.</p>
<p>It then sets plotting an inline for this notebook. The code then reads in the TIF as an array. It then makes a <kbd>numpy</kbd> array from the first band.</p>
<p>Bands are indexed <em>1</em>-<em>n</em>, but once read in as an array, they become indexed at 0.</p>
<p class="mce-root">To isolate the first band, the code reshapes the array using the width and height. Using <kbd>x.shape</kbd>, you can get them both, and if you index, you can get each one individually. Lastly, using <kbd>imshow</kbd>, the code plots the image using the color map for <kbd>gist_earth</kbd>. The image will display in Jupyter as follows:</p>
<div><img src="img/984bdb86-8302-49b6-bf25-f1854bc4f553.jpg" style="width:19.42em;height:19.08em;"/></div>
<p>Tif in Jupyter using imshow</p>
<p>Now that you know how to load a raster and perform basic operations, you will learn how to create a raster in the following section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using GDAL to create rasters</h1>
                
            
            
                
<p class="mce-root">In the previous section, you learned how to load a raster, perform basic queries, modify it, and save it out as a new file. In this section, you will learn how to create a raster.</p>
<p class="mce-root">A <strong>raster</strong> is an array of values. So to create one, you start by creating an array, as shown in the following code:</p>
<pre class="mce-root"> a_raster=np.array([<br/> [10,10,1,10,10,10,10],<br/> [1,1,1,50,10,10,50],<br/> [10,1,1,51,10,10,50],<br/> [1,1,1,1,50,10,50]])</pre>
<p class="mce-root">The previous code creates a <kbd>numpy</kbd> array with four rows of seven columns. Now that you have the array of data, you will need to set some basic properties. The following code will assign the values to variables and then you will pass them to the raster in the following example:</p>
<pre class="mce-root">coord=(-106.629773,35.105389)<br/>w=10<br/>h=10<br/>name="BigI.tif"</pre>
<p class="mce-root">The following code sets the lower-left corner, width, height, and name for the raster in the variable <kbd>coord</kbd>. It then sets the width and height in pixels. Lastly, it names the raster.</p>
<p class="mce-root">The next step is to create the raster by combining the data and properties. The following code will show you how:</p>
<pre class="mce-root">d=gdal.GetDriverByName("GTiff")<br/>output=d.Create(name,a_raster.shape[1],a_raster.shape[0],1,gdal.GDT_UInt16)<br/>output.SetGeoTransform((coord[0],w,0,coord[1],0,h))<br/>output.GetRasterBand(1).WriteArray(a_raster)<br/>outsr=osr.SpatialReference()<br/>outsr.ImportFromEPSG(4326)<br/>output.SetProjection(outsr.ExportToWkt())<br/>output.FlushCache()</pre>
<p class="mce-root">The previous code assigns the <kbd>GeoTiff</kbd> driver to the variable <kbd>d</kbd>. Then, it uses the driver to create the raster. The create method takes five parameters—the <kbd>name</kbd>, size of <kbd>x</kbd>, size of <kbd>y</kbd>, the number of bands, and the data type. To get the size of <kbd>x</kbd> and <kbd>y</kbd>, you can access <kbd>a_raster.shape</kbd>, which will return (4,7). Indexing <kbd>a_raster.shape</kbd> will give you <kbd>x</kbd> and <kbd>y</kbd> individually.</p>
<div><kbd>Create()</kbd> accepts several data types—starting with <kbd>GDT_</kbd>. Other data types include Unknown, Byte, UInt16, Int16, UInt32, Int32, Float32, Float64, CInt16, CInt32, CFloat32, and Cfloat64.</div>
<p class="mce-root">Next, the code sets the transformation from map to pixel coordinates using the upper-left corner coordinates and the rotation. The rotation is the width and height, and if it is a north up image, then the other parameters are 0.<br/>
To write the data to a band, the code selects the raster band—in this case, you used a single band specified when you called the <kbd>Create()</kbd> method, so passing <kbd>1</kbd> to <kbd>GetRasterBand()</kbd> and <kbd>WriteArray()</kbd> will take the <kbd>numpy</kbd> array.</p>
<p class="mce-root">Now, you will need to assign a spatial reference to the TIF. Create a spatial reference and assign it to <kbd>outsr</kbd>. Then, you can import a spatial reference from the EPSG code. Next, set the projection on the TIF by passing the WKT to the <kbd>SetProjection()</kbd> method.</p>
<p class="mce-root">The last step is to <kbd>FlushCache()</kbd>, which will write the file. If you are done with the TIF, you can set <kbd>output = None</kbd> to clear it. However, you will use it again in the following code snippet, so you will skip that step here.</p>
<p class="mce-root">To prove that the code worked, you can check the projection, as shown in the following code:</p>
<pre style="padding-left: 60px" class="mce-root">output.GetProjection()</pre>
<p class="mce-root">And the output shows that the TIF is in EPSG:4326:</p>
<pre class="mce-root"><strong>'GEOGCS["WGS 84",DATUM["WGS_1984",SPHEROID["WGS 84",6378137,298.257223563,AUTHORITY["EPSG","7030"]],AUTHORITY["EPSG","6326"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4326"]]'</strong></pre>
<p class="mce-root">You can display the TIF in Jupyter and see if it looks like you expected. The following code demonstrates how to plot the <kbd>image</kbd> and inspect your results:</p>
<pre class="mce-root">data=output.ReadAsArray()<br/>w, h =4, 7<br/>image = data.reshape(w,h) #assuming X[0] is of shape (400,) .T<br/>imshow(image, cmap='Blues') #enter bad color to get list<br/>data</pre>
<p class="mce-root">The previous code reads the raster as an array and assigns the width and height. It then creates an <kbd>image</kbd> variable, reshaping the array to the width and height. Lastly, it passes the image to <kbd>imshow()</kbd> and prints the <kbd>data</kbd> in the last line. If everything worked, you will see the following image:</p>
<div><img src="img/2302d703-eddb-442a-abfa-5c20c786d031.png"/></div>
<p>The array values and the raster created from them</p>
<p class="mce-root">The following section will teach you how to use PostgreSQL to work with rasters as an alternative or in conjunction with <kbd>gdal</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Raster operations using PostgreSQL</h1>
                
            
            
                
<p>In the first section of this chapter, you were able to load, display, and query rasters using <kbd>gdal</kbd>. In this section, you will learn how to load and query rasters using a spatial database—PostgreSQL. As you start to model your data, you will most likely hold it in a spatial database. You can leverage your database to perform the queries on your rasters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Loading rasters into PostgreSQL</h1>
                
            
            
                
<p class="mce-root">To load a raster into PostgreSQL, you can use the <kbd>raster2pgsql</kbd> binary. If it is not in your path, you may need to add it. You should be able to find the binary in your PostgreSQL install directory on Windows at <kbd>\PostgreSQL\10\bin</kbd>.</p>
<p class="mce-root">The following command should be executed from your operating system's command line. It will load the TIF you created earlier in this chapter into an existing PostgreSQL database:</p>
<pre class="mce-root"><strong>&gt;raster2pgsql -I -C -s 4326 C:\Users\Paul\Desktop\BigI.tif public.bigi | psql -U postgres -d pythonspatial</strong></pre>
<p class="mce-root">The previous command uses <kbd>raster2pgsql</kbd> with the <kbd>-I</kbd> (creates an index), <kbd>-C</kbd> (adds raster constraints), and <kbd>-s 4326</kbd> (the SRID) parameters. Using the pipe operator on Windows, you send the command to <kbd>psql</kbd>. Psql is run using the <kbd>-U</kbd> <kbd>postgres</kbd> (username) and <kbd>-d pythonspatial</kbd> (database) parameters.</p>
<p>If you are logged in as the Postgres user, you do not need the <kbd>-U</kbd>. Without it, Windows will try to log in to PostgreSQL using the logged in user account, which may not be the same as the PostgreSQL user.</p>
<p class="mce-root">Now that you have the data loaded in PostgreSQL, the following section will show you how you can use Python to query it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Performing queries on rasters using PostgreSQL</h1>
                
            
            
                
<p>With a raster loaded into PostgreSQL, you can query it using Python. The Python library for working with PostgreSQL is <kbd>psycopg2</kbd>. The following code will connect to the database where you loaded the TIF:</p>
<pre class="mce-root">import psycopg2<br/>connection = psycopg2.connect(database="pythonspatial",user="postgres", password="postgres")<br/>cursor = connection.cursor()</pre>
<p class="mce-root">The previous code imports <kbd>psycopg2</kbd>. It then makes a connection passing the database name, username, and password. Lastly, it gets a <kbd>cursor</kbd> object so that you can execute queries.</p>
<p class="mce-root">To see the raster in PostgreSQL, you can execute a select all, as shown in the following code:</p>
<pre class="mce-root">cursor.execute("SELECT * from bigi") <br/>#Big I is the name of the intersection where I-25 and I-40 meet and split Albuquerque in quadrants.<br/>cursor.fetchall()</pre>
<p class="mce-root">The previous code executes a select all statement and prints all the results. There are two columns in the table—rid and <kbd>rast</kbd>. Rid is the unique ID field for the raster. If you had tiled it when running <kbd>raster2pgsql</kbd>, there would be more rows. The <kbd>rast</kbd> column holds the raster data:</p>
<pre class="mce-root"><strong>[(1,</strong><br/><strong> '010000010000000000000024400000000000002440D8B969334EA85AC0D82D02637D8D414000000000000000000000000000000000E61000000700040004000A0A010A0A0A0A010101320A0A320A0101330A0A3201010101320A32')]</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Querying raster metadata</h1>
                
            
            
                
<p class="mce-root">Using PostgreSQL, you can perform various queries on your data. In this section, you will learn how to query the raster for basic metadata and properties. This section will present a few of the many PostgreSQL functions that are available.</p>
<p class="mce-root">You can query the data for a basic text summary. The following code shows you how to use the <kbd>ST_Summary()</kbd> function:</p>
<pre class="mce-root">cursor.execute("select ST_Summary(rast) from bigi;")<br/>cursor.fetchall()</pre>
<p class="mce-root">The summary function takes the raster data column as a parameter and returns a string containing the size of the raster, the bounding box, the number of bands, and if there are no data values in any of the bands. The following is the output from the previous code:</p>
<pre class="mce-root"><strong>[('Raster of 7x4 pixels has 1 band and extent of BOX(-106.629773 35.105389,-36.629773 75.105389)\n band 1 of pixtype 8BUI is in-db with no NODATA value',)]</strong></pre>
<p class="mce-root">Parsing out the individual pieces of information from <kbd>ST_Summary</kbd> would be difficult. You can retrieve this information in a more machine-readable format by using the <kbd>ST_Metadata</kbd> function. You can use the following code to do so:</p>
<pre class="mce-root">cursor.execute("select ST_MetaData(rast) from bigi")<br/>cursor.fetchall()</pre>
<p class="mce-root">The previous code queries the raster for the upper-left <em>X</em> value, the upper-left <em>Y</em> value, the width, the height, the scale of <em>X</em>, the scale of <em>Y</em>, the skew of <em>X</em>, the skew of <em>Y</em>, the SRID, and the number of bands in the raster. The output is shown as follows:</p>
<pre class="mce-root"><strong>[('(-106.629773,35.105389,7,4,10,10,0,0,4326,1)',)]</strong></pre>
<p class="mce-root">The output allows you to select individual pieces of metadata by using index notation, which is a simpler solution to parsing the string provided by <kbd>ST_Summary</kbd>.</p>
<p class="mce-root">You can query for specific and individual attributes of the raster. To get the raster as a single polygon—instead of the two-point box described in the summary—you can use the following code:</p>
<pre class="mce-root">cursor.execute("select ST_AsText(ST_Envelope(rast)) from bigi;")<br/>cursor.fetchall()</pre>
<p class="mce-root">The output of the previous code is the WKT for a vector-polygon-of the raster. It is shown as follows:</p>
<pre class="mce-root"><strong>[('POLYGON((-106.629773 75.105389,-36.629773 75.105389,-36.629773 35.105389,-106.629773 35.105389,-106.629773 75.105389))',)]</strong></pre>
<p class="mce-root">The following code will query the height and width of the raster:</p>
<pre class="mce-root">cursor.execute("select st_height(rast), st_Width(rast) from bigi;") #st_width<br/>cursor.fetchall()</pre>
<p class="mce-root">As you may recall from earlier in the chapter, the raster is <kbd>4x7</kbd>, as shown in the output:</p>
<pre class="mce-root"><strong>[(4, 7)]</strong></pre>
<p class="mce-root">Another piece of metadata that may come in handy is the pixel size. The following code will show you how:</p>
<pre class="mce-root">cursor.execute("select ST_PixelWidth(rast), ST_PixelHeight(rast) from bigi;")<br/>cursor.fetchall()</pre>
<p class="mce-root">Using <kbd>ST_PixelWidth</kbd> and <kbd>ST_PixelHeight</kbd>, you will get the output as follows. This matches the height and width from when you created the raster earlier in the chapter:</p>
<pre class="mce-root"><strong>[(10.0,10.0)]</strong></pre>
<p class="mce-root">You can query the raster for basic statistical information about the data within the cells for a specific band. <kbd>ST_SummaryStats</kbd> provides basic summary statistics for the data values. The following code shows you how to query:</p>
<pre class="mce-root">cursor.execute("select ST_SummaryStats(rast) from bigi;")<br/>cursor.fetchall()</pre>
<p class="mce-root">The output of the previous code returns the count, sum, mean, standard deviation, min, and max for a raster band. You can pass the raster band by passing it as an integer in the second parameter, <kbd>ST_SummaryStats(rast,3)</kbd>. If you do not specify the band, the default is <kbd>1</kbd>. The output is shown as follows:</p>
<pre class="mce-root"><strong>[('(28,431,15.3928571428571,18.5902034218377,1,51)',)]</strong></pre>
<p class="mce-root">You can also query for a histogram of the values in the raster, as shown in the following code:</p>
<pre class="mce-root">cursor.execute("SELECT ST_Histogram(rast,1) from bigi;")<br/>cursor.fetchall()</pre>
<p class="mce-root">The previous code uses <kbd>ST_Histogram</kbd> and passes the raster column and a band. You can pass the number of bins as the third parameter or you can let the function decide. The result is shown as follows:</p>
<pre class="mce-root"><strong>[('(1,9.33333333333333,10,0.357142857142857)',),</strong><br/><strong> ('(9.33333333333333,17.6666666666667,12,0.428571428571429)',),</strong><br/><strong> ('(17.6666666666667,26,0,0)',),</strong><br/><strong> ('(26,34.3333333333333,0,0)',),</strong><br/><strong> ('(34.3333333333333,42.6666666666667,0,0)',),</strong><br/><strong> ('(42.6666666666667,51,6,0.214285714285714)',)]</strong></pre>
<p class="mce-root">The previous output is an array of bins. Each bin contains the minimum value, the maximum value, the count, and the percentage.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Queries returning geometry</h1>
                
            
            
                
<p class="mce-root">The previous queries returned basic information about the raster and returned collections with the data. In PostgreSQL, there are a series of functions that return geometries from queries. This section will cover a few of those functions.</p>
<p class="mce-root">A raster is comprised of a matrix of cells and values. These cells become georeferenced pixels in our raster data. Using PostgreSQL, you can query your raster data for a specific cell and get the polygon representation of that cell back. The following code shows you how:</p>
<pre class="mce-root">cursor.execute("select rid, ST_asText(ST_PixelAsPolygon(rast,7,2)) from bigi;")<br/>cursor.fetchall()</pre>
<p class="mce-root">Using <kbd>ST_PixelAsPolygons</kbd>, you can pass the raster column, the column, and the row of a cell and get back polygon geometry for that cell. By wrapping the query in <kbd>ST_AsText</kbd>, you get back the WKT representation of the polygon instead of the binary.</p>
<p class="mce-root">The following is the result:</p>
<pre class="mce-root"><strong> [(1,</strong><br/><strong> 'POLYGON((-46.629773 45.105389,-36.629773 45.105389,-36.629773   <br/>  55.105389,-46.629773 55.105389,-46.629773 45.105389))')]</strong></pre>
<p class="mce-root">The previous output returned the rid (raster ID) of the pixel. Since you did not tile the raster when loading it into PostgreSQL, all the queries will return a rid of <kbd>1</kbd>.</p>
<p class="mce-root">The previous query returned a polygon, but you can use functions to return points. Using <kbd>ST_PixelAsPoints</kbd> and <kbd>ST_PixelAsCentroids</kbd>, you can retrieve a point for every pixel in the raster dataset.</p>
<p class="mce-root">Using <kbd>ST_PixelAsPoints</kbd>, you can retrieve a point geometry representing the upper-left corner of each pixel. The query also returns the <kbd>x</kbd> and <kbd>y</kbd> of the cell and the value. The following code will show you how:</p>
<pre class="mce-root">cursor.execute("SELECT x, y, val, ST_AsText(geom) FROM (SELECT (ST_PixelAsPoints(rast, 1)).* FROM bigi) as foo;")<br/><br/>cursor.fetchall()</pre>
<p class="mce-root">The previous code has a two-part query. Starting after the <kbd>FROM</kbd> statement, the query selects the pixels as points for band <kbd>1</kbd>. The first statement performs a select on the results and retrieves the point geometry, and the <kbd>x</kbd>, <kbd>y</kbd>, and value of the cell. <kbd>ST_PixelAsPoints</kbd>, by default, does not return data for cells with no values. You can pass the third parameter as false to return cells with no values.</p>
<p class="mce-root">The output of the previous query is an array with a row for each cell. Each row contains the <kbd>x</kbd>,<kbd>y</kbd>, value, and geometry. The results are shown as follows:</p>
<pre class="mce-root"><strong>[(1, 1, 10.0, 'POINT(-106.629773 35.105389)'),</strong><br/><strong> (2, 1, 10.0, 'POINT(-96.629773 35.105389)'),</strong><br/><strong> (3, 1, 1.0, 'POINT(-86.629773 35.105389)'),</strong><br/><strong> (4, 1, 10.0, 'POINT(-76.629773 35.105389)'),</strong><br/><strong> (5, 1, 10.0, 'POINT(-66.629773 35.105389)'),</strong><br/><strong> (6, 1, 10.0, 'POINT(-56.629773 35.105389)'),</strong><br/><strong> (7, 1, 10.0, 'POINT(-46.629773 35.105389)'),</strong><br/><strong> (1, 2, 1.0, 'POINT(-106.629773 45.105389)'),</strong><br/><strong> (2, 2, 1.0, 'POINT(-96.629773 45.105389)'),</strong><br/><strong> (3, 2, 1.0, 'POINT(-86.629773 45.105389)'),</strong><br/><strong> (4, 2, 50.0, 'POINT(-76.629773 45.105389)'),</strong><br/><strong> (5, 2, 10.0, 'POINT(-66.629773 45.105389)'),</strong><br/><strong> (6, 2, 10.0, 'POINT(-56.629773 45.105389)'),</strong><br/><strong> (7, 2, 50.0, 'POINT(-46.629773 45.105389)'),</strong><br/><strong> (1, 3, 10.0, 'POINT(-106.629773 55.105389)'),</strong><br/><strong> (2, 3, 1.0, 'POINT(-96.629773 55.105389)'),</strong><br/><strong> (3, 3, 1.0, 'POINT(-86.629773 55.105389)'),</strong><br/><strong> (4, 3, 51.0, 'POINT(-76.629773 55.105389)'),</strong><br/><strong> (5, 3, 10.0, 'POINT(-66.629773 55.105389)'),</strong><br/><strong> (6, 3, 10.0, 'POINT(-56.629773 55.105389)'),</strong><br/><strong> (7, 3, 50.0, 'POINT(-46.629773 55.105389)'),</strong><br/><strong> (1, 4, 1.0, 'POINT(-106.629773 65.105389)'),</strong><br/><strong> (2, 4, 1.0, 'POINT(-96.629773 65.105389)'),</strong><br/><strong> (3, 4, 1.0, 'POINT(-86.629773 65.105389)'),</strong><br/><strong> (4, 4, 1.0, 'POINT(-76.629773 65.105389)'),</strong><br/><strong> (5, 4, 50.0, 'POINT(-66.629773 65.105389)'),</strong><br/><strong> (6, 4, 10.0, 'POINT(-56.629773 65.105389)'),</strong><br/><strong> (7, 4, 50.0, 'POINT(-46.629773 65.105389)')]</strong></pre>
<p class="mce-root">Using <kbd>ST_PixelAsCentroids</kbd>, you can get a point that represents the centroid of the pixel or cell. The query is identical to the previous example and is shown as follows:</p>
<pre style="padding-left: 60px" class="mce-root">cursor.execute("SELECT x, y, val, ST_AsText(geom) FROM (SELECT (ST_PixelAsCentroids(rast, 1)).* FROM bigi) as foo;")<br/><br/>cursor.fetchall()</pre>
<p class="mce-root">The previous query is in two parts. It first executes the <kbd>ST_PixelAsCentroids</kbd> function and then selects the <kbd>x</kbd>,<kbd>y</kbd>, value, and geometry from that result set. The output is shown as follows. Notice that the points are different than in the previous example:</p>
<pre class="mce-root"><strong>[(1, 1, 10.0, 'POINT(-101.629773 40.105389)'),</strong><br/><strong> (2, 1, 10.0, 'POINT(-91.629773 40.105389)'),</strong><br/><strong> (3, 1, 1.0, 'POINT(-81.629773 40.105389)'),</strong><br/><strong> (4, 1, 10.0, 'POINT(-71.629773 40.105389)'),</strong><br/><strong> (5, 1, 10.0, 'POINT(-61.629773 40.105389)'),</strong><br/><strong> (6, 1, 10.0, 'POINT(-51.629773 40.105389)'),</strong><br/><strong> (7, 1, 10.0, 'POINT(-41.629773 40.105389)'),</strong><br/><strong> (1, 2, 1.0, 'POINT(-101.629773 50.105389)'),</strong><br/><strong> (2, 2, 1.0, 'POINT(-91.629773 50.105389)'),</strong><br/><strong> (3, 2, 1.0, 'POINT(-81.629773 50.105389)'),</strong><br/><strong> (4, 2, 50.0, 'POINT(-71.629773 50.105389)'),</strong><br/><strong> (5, 2, 10.0, 'POINT(-61.629773 50.105389)'),</strong><br/><strong> (6, 2, 10.0, 'POINT(-51.629773 50.105389)'),</strong><br/><strong> (7, 2, 50.0, 'POINT(-41.629773 50.105389)'),</strong><br/><strong> (1, 3, 10.0, 'POINT(-101.629773 60.105389)'),</strong><br/><strong> (2, 3, 1.0, 'POINT(-91.629773 60.105389)'),</strong><br/><strong> (3, 3, 1.0, 'POINT(-81.629773 60.105389)'),</strong><br/><strong> (4, 3, 51.0, 'POINT(-71.629773 60.105389)'),</strong><br/><strong> (5, 3, 10.0, 'POINT(-61.629773 60.105389)'),</strong><br/><strong> (6, 3, 10.0, 'POINT(-51.629773 60.105389)'),</strong><br/><strong> (7, 3, 50.0, 'POINT(-41.629773 60.105389)'),</strong><br/><strong> (1, 4, 1.0, 'POINT(-101.629773 70.105389)'),</strong><br/><strong> (2, 4, 1.0, 'POINT(-91.629773 70.105389)'),</strong><br/><strong> (3, 4, 1.0, 'POINT(-81.629773 70.105389)'),</strong><br/><strong> (4, 4, 1.0, 'POINT(-71.629773 70.105389)'),</strong><br/><strong> (5, 4, 50.0, 'POINT(-61.629773 70.105389)'),</strong><br/><strong> (6, 4, 10.0, 'POINT(-51.629773 70.105389)'),</strong><br/><strong> (7, 4, 50.0, 'POINT(-41.629773 70.105389)')]</strong></pre>
<p class="mce-root">The previously mentioned functions returned geometry for all of the pixels in the raster dataset. Both of these functions have a corresponding function which allows you to specify a single pixel.</p>
<p class="mce-root">Removing the plural from centroids and points will allow you to specify single pixels, but will not return the <kbd>x</kbd>, <kbd>y</kbd>, and value. The following code shows you how to query a single pixel as a centroid:</p>
<pre class="mce-root">cursor.execute("SELECT ST_AsText(ST_PixelAsCentroid(rast,4,1)) FROM bigi;")<br/>cursor.fetchall()</pre>
<p class="mce-root">The previous code uses <kbd>ST_PixelAsCentroid</kbd> and passes the raster, row, and column. The result is a single centroid point geometry for the cell which has been specified. The output is shown as follows:</p>
<pre class="mce-root"><strong>[('POINT(-71.629773 40.105389)',)]</strong></pre>
<p class="mce-root">Wrapping the query in <kbd>ST_AsText</kbd> resulted in the output being returned in WKT.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Queries returning values</h1>
                
            
            
                
<p class="mce-root">The two previous sections returned information about the raster and geometries representing the raster data. This section will show you how to query your raster dataset for values.</p>
<p class="mce-root">To get the value of a specific cell, you use <kbd>ST_Value</kbd>, which is shown as follows:</p>
<pre class="mce-root">cursor.execute("select ST_Value(rast,4,3) from bigi;")<br/>cursor.fetchall()</pre>
<p class="mce-root">The previous code passes the raster, the column, and row to <kbd>ST_Value</kbd>. Optionally, you can pass false if you want don't want to return any data values. The result of the previous query is shown as follows:</p>
<pre class="mce-root"><strong>[(51.0,)]</strong></pre>
<p class="mce-root">The output is the value at the given cell.</p>
<p class="mce-root">If you want to search for all pixels with a given value, you can use <kbd>ST_PixelOfValue</kbd>, as follows:</p>
<pre class="mce-root">cursor.execute("select ST_PixelOfValue(rast,1,50) from bigi;")<br/>cursor.fetchall()</pre>
<p class="mce-root">The previous code passes the band and the value to search for. The result of this query is an array of all (<em>x</em>,<em>y</em>) coordinates, where the value is <kbd>50</kbd>. The output is shown as follows:</p>
<pre class="mce-root"><strong>[('(4,2)',), ('(5,4)',), ('(7,2)',), ('(7,3)',), ('(7,4)',)]</strong></pre>
<p class="mce-root">For each of the coordinates shown earlier, the value is <kbd>50</kbd>.</p>
<p class="mce-root">To summarize the occurrences of every value in the raster, you can query using <kbd>ST_ValueCount</kbd>, as follows:</p>
<pre class="mce-root">cursor.execute("select ST_ValueCount(rast) from bigi;")<br/>cursor.fetchall()</pre>
<p class="mce-root">The previous code passes the raster column to <kbd>ST_ValueCount</kbd>. You can specify a raster band by passing the band as an integer as the second parameter—<kbd>ST_ValueCount(raster,2)</kbd> would be band <kbd>2</kbd>. Otherwise, the default is band <kbd>1</kbd>. The output is as follows:</p>
<pre class="mce-root"><strong>[('(10,12)',), ('(1,10)',), ('(50,5)',), ('(51,1)',)]</strong></pre>
<p class="mce-root">The previous output contains the value and the count in the format of (value, count).</p>
<p class="mce-root">You can also query for the number of times a single value occurs in the data. The following code shows you how:</p>
<pre class="mce-root">cursor.execute("select ST_ValueCount(rast,1,True,50) from bigi;")<br/>cursor.fetchall()</pre>
<p class="mce-root">Using <kbd>ST_ValueCount</kbd> and passing a search value (<kbd>50</kbd>), you will receive the number of times <kbd>50</kbd> occurs as a value in the raster, as follows:</p>
<pre class="mce-root"><strong>[(5,)]</strong></pre>
<p class="mce-root">The previous output shows that <kbd>50</kbd> occurs <kbd>5</kbd> times in the raster dataset.</p>
<p class="mce-root">To return all the values in the raster data, you can use <kbd>ST_DumpValues</kbd>, as follows:</p>
<pre class="mce-root">cursor.execute("select ST_DumpValues(rast,1) from bigi;")<br/>cursor.fetchall()</pre>
<p class="mce-root">The previous code passes the raster column and the band. The results are all the values in the raster as an array. The output is shown as follows:</p>
<pre class="mce-root"><strong>[([[10.0, 10.0, 1.0, 10.0, 10.0, 10.0, 10.0],</strong><br/><strong> [1.0, 1.0, 1.0, 50.0, 10.0, 10.0, 50.0],</strong><br/><strong> [10.0, 1.0, 1.0, 51.0, 10.0, 10.0, 50.0],</strong><br/><strong> [1.0, 1.0, 1.0, 1.0, 50.0, 10.0, 50.0]],)]</strong></pre>
<p class="mce-root">Using the previous output, you can query individual cells using standard Python indexing notation.</p>
<p class="mce-root">The previous queries returned values from a specified cell or by using a specified value. The two queries that are to be followed will return values based on a point geometry.</p>
<p class="mce-root">Using <kbd>ST_NearestValue</kbd>, you can pass a point and get the closest pixel value to that point. If the raster data contained elevation values, you would be querying for the known elevation which is closest to the point. The following code shows you how:</p>
<pre class="mce-root">cursor.execute("select ST_NearestValue(rast,( select ST_SetSRID( ST_MakePoint(-71.629773,60.105389),4326))) from bigi;".format(p.wkt))<br/><br/>cursor.fetchall()</pre>
<p class="mce-root">The previous code passes the raster column and a point to <kbd>ST_NearestValue</kbd>. Starting from the inside out, the point parameter used <kbd>ST_MakePoint</kbd> to make a point from coordinates. The function is wrapped in <kbd>ST_SetSRID</kbd>. <kbd>ST_SetSRID</kbd> takes two parameters—a point and a spatial reference. In this case, the point is <kbd>ST_MakePoint</kbd>, and the spatial reference is ESPG <kbd>4326</kbd>. The result of the previous query is shown as follows:</p>
<pre class="mce-root"><strong>[(51.0,)]</strong></pre>
<p class="mce-root">The value of <kbd>51</kbd> is the closest value to the point. The coordinates in the query are the centroid of the cell (4,3) from the earlier <kbd>ST_PixelAsCentroids</kbd> example. In that example, the value of that point was <kbd>51</kbd>.</p>
<p class="mce-root">To retrieve more than one value near a given point, you can use <kbd>ST_Neighborhood</kbd>, as shown in the following code:</p>
<pre class="mce-root">cursor.execute("select ST_Neighborhood(rast,(select ST_SetSRID( ST_MakePoint(410314,3469015),26913)),1,1) from newmexicoraster;")<br/><br/>cursor.fetchall()</pre>
<p class="mce-root">The <kbd>ST_Neighborhood</kbd> function takes the raster column, a point, and an <kbd>x</kbd>, <kbd>y</kbd> distance value. In the previous code, you used <kbd>ST_MakePoint</kbd> and <kbd>ST_SetSRID</kbd> to create the point. You then passed the point and the distances of <kbd>1</kbd> and <kbd>1</kbd> for the <em>x</em> and <em>y</em> distance parameter. This will return a 3x3 neighborhood, as shown in the following output:</p>
<pre class="mce-root"><strong>[([[255.0, 255.0, 255.0], [255.0, 255.0, 255.0], [255.0, 255.0, 255.0]],)]</strong></pre>
<p class="mce-root">The previous output shows that the values of the surrounding neighborhood are all <kbd>255</kbd>.</p>
<p class="mce-root">Finally, you can select vector geometry as a raster. When querying a vector table which contains Albuquerque Police Area Commands as polygons, the following code will extract a single area command as a raster:</p>
<pre class="mce-root">cursor.execute("SELECT ST_AsPNG(ST_asRaster(geom,150,250,'8BUI')) from areacommand where name like 'FOOTHILLS';")<br/><br/>c=cursor.fetchall()<br/><br/>with open('Foothills.png','wb') as f:<br/>    f.write(c[0][0])<br/>f.close()</pre>
<p class="mce-root">The previous code is a select statement that selects a geometry from the <kbd>areacommand</kbd> table, where the name is <kbd>FOOTHILLS</kbd>. The geometry portion of the query is where you perform the raster conversion.<br/>
<kbd>ST_AsRaster</kbd> takes a geometry, the scale of <kbd>x</kbd>, the scale of <kbd>y</kbd>, and the type of pixels. The <kbd>ST_AsRaster</kbd> function is wrapped in the <kbd>ST_AsPNG</kbd> function. The result is a PNG file in memory view. Using standard Python file operations, the code opens a file, <kbd>Foothills.png</kbd>, in write binary mode, and then writes the memory view <kbd>c[0][0]</kbd> to disk. It then closes the file.</p>
<p class="mce-root">The output is shown in the following image:</p>
<div><img src="img/600bda3e-5c15-45c0-9034-5f66b81197ea.jpg"/></div>
<p>The image showing the foothills as a raster</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, you learned how to use GDAL and PostgreSQL to work with raster data.</p>
<p>First, you learned how to use the GDAL to load and query rasters. You also learned how to use GDAL to modify and save rasters. Then, you learned how to create your own raster data. You learned how to load raster data into PostgreSQL using the <kbd>raster2pgsql</kbd> tool. Once in PostgreSQL, you learned how to query for metadata, attributes, values, and geometry. You learned several common functions within PostgreSQL for raster data analysis. </p>
<p>While this chapter only scratched the surface of working with raster data, you should have enough knowledge now to know how to learn new techniques and methods for working with rasters. In the next chapter, you will learn how to work with vector data in PostgreSQL.</p>
<p> </p>
<p> </p>


            

            
        
    </body></html>