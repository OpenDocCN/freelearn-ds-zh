["```py\n% createdb gps_heatmap\n\n```", "```py\n% psql -d gps_heatmap -c \"CREATE EXTENSION postgis;\"\n\n```", "```py\nimport psycopg2\n\nconnection = psycopg2.connect(database=\"gps_heatmap\",\n                              user=\"postgres\")\ncursor = connection.cursor()\n\ncursor.execute(\"DROP TABLE IF EXISTS roads\")\ncursor.execute(\"CREATE TABLE roads (\" +\n                   \"id SERIAL PRIMARY KEY,\" +\n                   \"name VARCHAR,\" + \n                   \"centerline GEOMETRY)\")\ncursor.execute(\"CREATE INDEX ON roads USING GIST(centerline)\")\n\n connection.commit()\n```", "```py\nimport psycopg2\nfrom osgeo import ogr\n\nconnection = psycopg2.connect(database=\"gps_heatmap\",\n                              user=\"postgres\")\ncursor = connection.cursor()\n\ncursor.execute(\"DELETE FROM roads\")\n```", "```py\nshapefile = ogr.Open(\"roads/improved-nz-road-centrelines-august-2011.shp\")\nlayer = shapefile.GetLayer(0)\n\nfor i in range(layer.GetFeatureCount()):\n    feature = layer.GetFeature(i)\n    geometry = feature.GetGeometryRef()\n\n    if feature.GetField(\"descr\") != None:\n        name = feature.GetField(\"descr\")\n    elif feature.GetField(\"label\") != None:\n        name = feature.GetField(\"label\")\n    else:\n        name = None\n\n    centerline_wkt = geometry.ExportToWkt()\n\n    cursor.execute(\"INSERT INTO roads (name, centerline) \" +\n                   \"VALUES (%s, ST_GeomFromText(%s))\",\n                   (name, centerline_wkt))\n\nconnection.commit()\n```", "```py\ncursor.execute(\"DROP TABLE IF EXISTS road_segments\")\ncursor.execute(\"CREATE TABLE road_segments (\" +\n               \"id SERIAL PRIMARY KEY,\" +\n               \"name VARCHAR,\" + \n               \"centerline GEOMETRY,\" +\n               \"tally INTEGER)\")\ncursor.execute(\"CREATE INDEX ON road_segments USING GIST(centerline)\")\n```", "```py\nimport psycopg2\nimport shapely.wkt\nimport shapely\n\nconnection = psycopg2.connect(database=\"gps_heatmap\",\n                              user=\"postgres\")\ncursor = connection.cursor()\n\ncursor.execute(\"DELETE FROM road_segments\")\n```", "```py\nall_road_ids = []\ncursor.execute(\"SELECT id FROM roads\")\nfor row in cursor:\n    all_road_ids.append(row[0])\n```", "```py\nfor road_id in all_road_ids:\n    cursor.execute(\"SELECT name,ST_AsText(centerline) \" +\n                   \"FROM roads WHERE id=%s\", (road_id,))\n    name,wkt = cursor.fetchone()\n    cur_road = shapely.wkt.loads(wkt)\n```", "```py\n    crossroads = []\n    cursor.execute(\"SELECT ST_AsText(centerline) FROM ROADS\" +\n                   \"WHERE ST_Touches(roads.centerline, \" +\n                   \"ST_GeomFromText(%s)) OR ST_Crosses(\" +\n                   \"roads.centerline, ST_GeomFromText(%s))\",\n                   (wkt, wkt))\n    for row in cursor:\n        crossroad = shapely.wkt.loads(row[0])\n        crossroads.append(crossroad)\n```", "```py\n    for crossroad in crossroads:\n        cur_road = cur_road.difference(crossroad)\n```", "```py\n    segments = []\n    if cur_road.geom_type == \"MultiLineString\":\n        for segment in cur_road.geoms:\n            segments.append(segment)\n    elif cur_road.geom_type == \"LineString\":\n        segments.append(cur_road)\n```", "```py\n    for segment in segments:\n        centerline_wkt = shapely.wkt.dumps(segment)\n        cursor.execute(\"INSERT INTO road_segments (name, \" +\n                       \"centerline, tally) VALUES (%s, \" +\n                       \"ST_GeomFromText(%s), %s)\",\n                       (name, centerline_wkt, 0))\n```", "```py\nconnection.commit()\n```", "```py\n% python init_db.py\n% python import_roads.py\n% python split_roads.py\n% psql gps_heatmap\n# SELECT count(*) from roads;\n1556\n# SELECT count(*) from road_segments;\n3240\n\n```", "```py\ncursor.execute(\"DROP TABLE IF EXISTS directed_segments\")\ncursor.execute(\"CREATE TABLE directed_segments (\" +\n               \"id SERIAL PRIMARY KEY,\" +\n               \"road_segment_id INTEGER,\" +\n               \"centerline GEOMETRY)\")\ncursor.execute(\"CREATE INDEX ON directed_segments USING GIST(centerline)\")\n\ncursor.execute(\"DROP TABLE IF EXISTS endpoints\")\ncursor.execute(\"CREATE TABLE endpoints (\" +\n               \"id SERIAL PRIMARY KEY,\" +\n               \"endpoint GEOMETRY)\")\ncursor.execute(\"CREATE INDEX ON endpoints USING GIST(endpoint)\")\n\ncursor.execute(\"DROP TABLE IF EXISTS endpoint_segments\")\ncursor.execute(\"CREATE TABLE endpoint_segments (\" +\n               \"id SERIAL PRIMARY KEY,\" +\n               \"directed_segment_id INTEGER,\" +\n               \"endpoint_id INTEGER)\")\ncursor.execute(\"CREATE INDEX ON endpoint_segments(directed_segment_id)\")\ncursor.execute(\"CREATE INDEX ON endpoint_segments(endpoint_id)\")\n```", "```py\n% python init_db.py\n% python import_roads.py\n% python split_roads.py\n\n```", "```py\nimport networkx\nimport psycopg2\nimport shapely.wkt\nimport shapely.geometry\n\nconnection = psycopg2.connect(database=\"gps_heatmap\", user=\"postgres\")\ncursor = connection.cursor()\n```", "```py\nnetwork = networkx.Graph()\n\ncursor.execute(\"SELECT id,ST_AsText(centerline) FROM road_segments\")\nfor row in cursor:\n    road_segment_id,wkt = row\n    linestring = shapely.wkt.loads(wkt)\n\n    first_pt = linestring.coords[0]\n    last_pt  = linestring.coords[-1]\n\n    network.add_edge(first_pt, last_pt,\n                     {'road_segment_id' : road_segment_id})\n```", "```py\nsub_graphs = list(networkx.connected_component_subgraphs(network))\nlargest = sub_graphs[0]\n```", "```py\ncursor.execute(\"DELETE FROM endpoints\")\n\nendpoint_ids = {}\nfor node in largest.nodes():\n    point = shapely.geometry.Point(node)\n    wkt = shapely.wkt.dumps(point)\n\n    cursor.execute(\"INSERT INTO endpoints (endpoint) \" +\n                   \"VALUES (ST_GeomFromText(%s)) RETURNING id\",\n                   (wkt,))\n    endpoint_id = cursor.fetchone()[0]\n\n    endpoint_ids[node] = endpoint_id\n```", "```py\ncursor.execute(\"DELETE FROM directed_segments\")\ncursor.execute(\"DELETE FROM endpoint_segments\")\n\nfor node1,node2 in largest.edges():\n    endpoint_id_1 = endpoint_ids[node1]\n    endpoint_id_2 = endpoint_ids[node2]\n    road_segment_id = largest.get_edge_data(node1, node2)['road_segment_id']\n\n    cursor.execute(\"SELECT ST_AsText(centerline) \" +\n                   \"FROM road_segments WHERE id=%s\",\n                   (road_segment_id,))\n    wkt = cursor.fetchone()[0]\n    linestring = shapely.wkt.loads(wkt)\n```", "```py\n    reversed_coords = list(reversed(linestring.coords))\n    if node1 == linestring.coords[0]:\n        forward_linestring = linestring\n        reverse_linestring = shapely.geometry.LineString(reversed_coords)\n    else:\n        reverse_linestring = linestring\n        forward_linestring = shapely.geometry.LineString(reversed_coords)\n```", "```py\n    cursor.execute(\"INSERT INTO directed_segments \" +\n                   \"(road_segment_id,centerline) VALUES \" +\n                   \"(%s, ST_GeomFromText(%s)) RETURNING id\",\n                   (road_segment_id, forward_linestring.wkt))\n    forward_segment_id = cursor.fetchone()[0]\n\n    cursor.execute(\"INSERT INTO directed_segments \" +\n                   \"(road_segment_id,centerline) VALUES \" +\n                   \"(%s, ST_GeomFromText(%s)) RETURNING id\",\n                   (road_segment_id, reverse_linestring.wkt))\n    reverse_segment_id = cursor.fetchone()[0]\n\n    cursor.execute(\"INSERT INTO endpoint_segments \" + \n                       \"(directed_segment_id, endpoint_id) \" +\n\n                       \"VALUES (%s, %s)\", \n\n                       (forward_segment_id, endpoint_id_1))\n\n        cursor.execute(\"INSERT INTO endpoint_segments \" + \n                       \"(directed_segment_id, endpoint_id) \" +\n\n                       \"VALUES (%s, %s)\", \n\n                       (reverse_segment_id, endpoint_id_2))\n```", "```py\nconnection.commit()\n```", "```py\n% python calc_directed_network.py\n\n```", "```py\nimport os\nimport osgeo.ogr\nimport shapely.geometry\nimport shapely.wkt\nimport psycopg2\nimport pyproj\n\ngps_tracks = []\nfor fName in os.listdir(\"gps-data\"):\n    if fName.endswith(\".gpx\"):\n        srcFile = osgeo.ogr.Open(\"gps-data/\" + fName)\n        layer = srcFile.GetLayerByName(\"tracks\")\n\n        for feature_num in range(layer.GetFeatureCount()):\n            feature = layer.GetFeature(feature_num)\n            geometry = feature.GetGeometryRef()\n\n            if geometry.GetGeometryName() == \"MULTILINESTRING\":\n                for geom_num in range(geometry.GetGeometryCount()):\n                    wkt = geometry.GetGeometryRef(geom_num).ExportToWkt()\n                    gps_tracks.append((fName, wkt))\n            elif geometry.GetGeometryName() == \"LINESTRING\":\n                wkt = geometry.ExportToWkt()\n                gps_tracks.append((fName, wkt))\n\nconnection = psycopg2.connect(database=\"gps_heatmap\", user=\"postgres\")\ncursor = connection.cursor()\n```", "```py\ncursor.execute(\"UPDATE road_segments SET tally=0\")\nconnection.commit()\n```", "```py\nfor fName,track_wkt in gps_tracks:\n    print \"Processing \" + fName\n\n    gps_track  = shapely.wkt.loads(track_wkt)\n    gps_points = list(gps_track.coords)\n\n    while len(gps_points) > 0:\n        circle = calc_circle_with_radius(gps_points[0], 10)\n        cursor.execute(\"SELECT count(*) FROM road_segments \" +\n                \"WHERE ST_Intersects(ST_GeomFromText(%s),\" +\n                       \"centerline)\", (circle.wkt,))\n        if cursor.fetchone()[0] == 0:\n            del gps_points[0]\n        else:\n            break\n\n    while len(gps_points) > 0:\n        circle = calc_circle_with_radius(gps_points[-1], 10)\n        cursor.execute(\"SELECT count(*) FROM road_segments \" +\n                \"WHERE ST_Intersects(ST_GeomFromText(%s),\" +\n                       \"centerline)\", (circle.wkt,))\n        if cursor.fetchone()[0] == 0:\n            del gps_points[-1]\n        else:\n            break\n```", "```py\ndef calc_circle_with_radius(center_point, radius):\n    geod = pyproj.Geod(ellps=\"WGS84\")\n    sLong,sLat = center_point\n    eLong,eLat,iHeading = geod.fwd(sLong, sLat, 0, radius)\n    lat_delta = abs(sLat - eLat)\n    return shapely.geometry.Point(sLong, sLat).buffer(lat_delta)\n```", "```py\n    search_distance = 750\n    while True:\n        circle = calc_circle_with_radius(gps_points[0],\n                                         search_distance)\n\n        cursor.execute(\"SELECT id FROM endpoints \" +\n                       \"WHERE ST_Contains(ST_GeomFromText(%s),\" +\n                       \"endpoint)\", (circle.wkt,))\n        possible_endpoints = []\n        for row in cursor:\n            possible_endpoints.append(row[0])\n\n        possible_road_segments = []\n        for endpoint_id in possible_endpoints:\n            cursor.execute(\"SELECT directed_segment_id \" +\n                           \"FROM endpoint_segments \" +\n                           \"WHERE endpoint_id=%s\", (endpoint_id,))\n            for row in cursor:\n                directed_segment_id = row[0]\n                possible_road_segments.append(\n                    (directed_segment_id, endpoint_id))\n\n        route_candidates = []\n        for directed_segment_id,endpoint_id in possible_road_segments:\n            cursor.execute(\"SELECT ST_AsText(centerline) \" +\n                           \"FROM directed_segments WHERE id=%s\",\n                           (directed_segment_id,))\n            wkt = cursor.fetchone()[0]\n            linestring = shapely.wkt.loads(wkt)\n            gps_distance = calc_distance(gps_points[0],\n                                         linestring)\n\n            segment = {\n                'directed_segment_id' : directed_segment_id,\n                'linestring' : linestring,\n                'gps_points': [gps_points[0]],\n                'gps_distances': [gps_distance]}\n            route_segments = [segment]\n\n            candidate = {\n                'segments': route_segments,\n                'directed_segment_ids' : [directed_segment_id],\n                'score': calc_score(route_segments)}\n            route_candidates.append(candidate)\n\n        if len(route_candidates) >= 25:\n            break\n        else:\n            search_distance = search_distance + 100\n            continue\n```", "```py\ndef calc_distance(point, geometry):\n    return shapely.geometry.Point(point).distance(geometry)\n\ndef calc_score(route_segments):\n    total = 0\n    for segment in route_segments:\n        total = total + sum(segment['gps_distances'])\n    return total\n```", "```py\n    for next_point in gps_points[1:]:\n        num_routes_to_process = len(route_candidates)\n        for i in range(num_routes_to_process):\n            route = route_candidates.pop(0)\n            new_candidates = develop_route(next_point, route, route_candidates, cursor)\n            route_candidates.extend(new_candidates)\n```", "```py\n        while len(route_candidates) > 40:\n            highest = None\n            for index,route in enumerate(route_candidates):\n                if highest == None:\n                    highest = index\n                elif route['score'] > route_candidates[highest]['score']:\n                    highest = index\n            del route_candidates[highest]\n```", "```py\n    best_route = None\n    for route in route_candidates:\n        if len(route['segments']) >= 2:\n            if best_route == None:\n                best_route = route\n            elif route['score'] < best_route['score']:\n                best_route = route\n\n    if best_route == None: continue\n\n    for segment in best_route['segments']:\n        cursor.execute(\"SELECT road_segment_id \" +\n                       \"FROM directed_segments WHERE id=%s\",\n                       (segment['directed_segment_id'],))\n        road_segment_id = cursor.fetchone()[0]\n        cursor.execute(\"UPDATE road_segments SET tally=tally+1\" +\n                       \"WHERE id=%s\", (road_segment_id,))\n\nconnection.commit()\n```", "```py\ndef develop_route(next_point, route, route_candidates, cursor):\n    if len(route['segments']) == 1:\n        if point_at_start_of_segment(next_point,\n                                     route['segments'][0]):\n            return []\n\n    last_segment = route['segments'][-1]\n\n    if point_in_route_segment(next_point, last_segment):\n        next_distance = calc_distance(next_point,\n                                      last_segment['linestring'])\n        last_segment['gps_points'].append(next_point)\n        last_segment['gps_distances'].append(next_distance)\n        route['score'] = calc_score(route['segments'])\n        return [route]\n```", "```py\n    last_point = last_segment['linestring'].coords[-1]\n    endpoint = shapely.geometry.Point(last_point)\n\n    cursor.execute(\"SELECT id FROM endpoints \" +\n                   \"WHERE endpoint=ST_GeomFromText(%s)\",\n                   (endpoint.wkt,))\n    endpoint_id = cursor.fetchone()[0]\n```", "```py\n    possible_segment_ids = []\n    cursor.execute(\"SELECT directed_segment_id \" +\n                   \"FROM endpoint_segments \" +\n                   \"WHERE endpoint_id=%s\", (endpoint_id,))\n    for row in cursor:\n        possible_segment_ids.append(row[0])\n```", "```py\n    new_candidates = []\n    for directed_segment_id in possible_segment_ids:\n        cursor.execute(\"SELECT road_segment_id,\" +\n                       \"ST_AsText(centerline) \" +\n                       \"FROM directed_segments \" +\n                       \"WHERE id=%s\", (directed_segment_id,))\n        road_segment_id,wkt = cursor.fetchone()\n        linestring = shapely.wkt.loads(wkt)\n\n        next_distance = calc_distance(next_point, linestring)\n\n        new_segment = {}\n        new_segment['directed_segment_id'] = directed_segment_id\n        new_segment['linestring'] = linestring\n        new_segment['gps_points'] = [next_point]\n        new_segment['gps_distances'] = [next_distance]\n\n        new_candidate = {}\n        new_candidate['segments'] = []\n        new_candidate['segments'].extend(route['segments'])\n        new_candidate['segments'].append(new_segment)\n        new_candidate['directed_segment_ids'] = []\n        new_candidate['directed_segment_ids'].extend(\n                            route['directed_segment_ids'])\n        new_candidate['directed_segment_ids'].append(directed_segment_id)\n\n        if not route_is_valid(new_candidate, route_candidates,\n                              new_candidates):\n            continue\n\n        new_candidate['score'] = calc_score(new_candidate['segments'])\n        new_candidates.append(new_candidate)\n    return new_candidates\n```", "```py\ndef point_at_start_of_segment(next_point, segment):\n    num_points = len(segment['gps_points'])\n    if num_points > 0:\n        average_distance = sum(segment['gps_distances']) / num_points\n\n        startpoint_coord = segment['linestring'].coords[0]\n        startpoint = shapely.geometry.Point(startpoint_coord)\n        endpoint_coord = segment['linestring'].coords[-1]\n        endpoint = shapely.geometry.Point(endpoint_coord)\n\n        distance_to_start = calc_distance(next_point, startpoint)\n        distance_to_end   = calc_distance(next_point, endpoint)\n\n        if distance_to_start < 2 * average_distance:\n            if distance_to_end > 2 * average_distance:\n                return True\n    return False\n```", "```py\ndef point_in_route_segment(point, segment):\n    endpoint = shapely.geometry.Point(segment['linestring'].coords[-1])\n\n    distance_to_linestring = calc_distance(point,\n                                           segment['linestring'])\n    distance_to_endpoint = calc_distance(point, endpoint)\n\n    if distance_to_linestring == distance_to_endpoint:\n        return False\n```", "```py\n    gps_coords = []\n    gps_coords.extend(segment['gps_points'])\n    gps_coords.append(point)\n\n    gps_length = shapely.geometry.LineString(gps_coords).length\n    segment_length = segment['linestring'].length\n\n    if gps_length > segment_length:\n        return False\n```", "```py\n    return True\n```", "```py\ndef route_is_valid(route, route_candidates, new_candidates):\n    route_roads = route['directed_segment_ids']\n\n    for other_route in route_candidates:\n        if route_roads == other_route['directed_segment_ids']:\n            return False\n\n    for other_route in new_candidates:\n        if route_roads == other_route['directed_segment_ids']:\n            return False\n```", "```py\n    if len(route['segments']) >= 2:\n        last_segment = route['segments'][-1]\n        prev_segment = route['segments'][-2]\n\n        last_segment_end   = last_segment['linestring'].coords[-1]\n        prev_segment_start = prev_segment['linestring'].coords[0]\n\n        if last_segment_end == prev_segment_start:\n            return False\n```", "```py\n    directed_segment_ids = set()\n    for segment in route['segments']:\n        directed_segment_id = segment['directed_segment_id']\n        if directed_segment_id in directed_segment_ids:\n            return False\n        else:\n            directed_segment_ids.add(directed_segment_id)\n```", "```py\n    return True\n```", "```py\n% python map_matcher.py\nProcessing ride_2015_01_08.gpx\nProcessing ride_2015_01_11.gpx\nProcessing ride_2015_01_23.gpx\n...\n\n```", "```py\n% psql gps_heatmap\n# SELECT name,tally FROM road_segments WHERE tally > 0 ORDER BY tally DESC;\n 3560 | otonga rd                        |    42\n 6344 | wychwood cres                    |    42\n 3561 | otonga rd                        |    42\n 3557 | otonga rd                        |    42\n 3558 | otonga rd                        |    42\n 3559 | otonga rd                        |    42\n 6343 | wychwood cres                    |    41\n 6246 | springfield rd                   |    19\n 6300 | old taupo rd                     |    19\n\n```", "```py\nimport mapnik\nimport psycopg2\n\nMAX_WIDTH = 1200\nMAX_HEIGHT = 800\nMIN_TALLY = 3\n\nconnection = psycopg2.connect(database=\"gps_heatmap\",\n                              user=\"postgres\")\ncursor = connection.cursor()\n```", "```py\ncursor.execute(\"SELECT max(tally) FROM road_segments\")\nmax_tally = cursor.fetchone()[0]\n\ncursor.execute(\"SELECT ST_XMIN(ST_EXTENT(centerline)), \" +\n               \"ST_YMIN(ST_EXTENT(centerline)), \" +\n               \"ST_XMAX(ST_EXTENT(centerline)), \" +\n               \"ST_YMAX(ST_EXTENT(centerline)) \" +\n               \"FROM road_segments WHERE tally >= %s\" % MIN_TALLY)\nmin_long,min_lat,max_long,max_lat = cursor.fetchone()\n```", "```py\nextent = mapnik.Envelope(min_long, min_lat,  max_long, max_lat)\naspectRatio = extent.width() / extent.height()\n\nmapWidth = MAX_WIDTH\nmapHeight = int(mapWidth / aspectRatio)\nif mapHeight > MAX_HEIGHT:\n    scaleFactor = float(MAX_HEIGHT) / float(mapHeight)\n    mapWidth = int(mapWidth * scaleFactor)\n    mapHeight = int(mapHeight * scaleFactor)\n```", "```py\nmap = mapnik.Map(mapWidth, mapHeight)\nmap.background = mapnik.Color(\"white\")\n```", "```py\nlayer = mapnik.Layer(\"unused_roads\")\nlayer.datasource = mapnik.PostGIS(host='localhost',\n                                  user='postgres',\n                                  password='',\n                                  dbname='gps_heatmap',\n                                  table='road_segments')\nlayer.styles.append(\"unused_road_style\")\nmap.layers.append(layer)\n\nline_symbol = mapnik.LineSymbolizer(mapnik.Color(\"#c0c0c0\"), 1.0)\n\nrule = mapnik.Rule()\nrule.filter = mapnik.Filter(\"[tally] = 0\")\nrule.symbols.append(line_symbol)\n\nstyle = mapnik.Style()\nstyle.rules.append(rule)\nmap.append_style(\"unused_road_style\", style)\n```", "```py\ndef calc_stroke(value, max_value):\n    fraction = float(value) / float(max_value)\n\n    def interpolate(start_value, end_value, fraction):\n        return start_value + (end_value - start_value) * fraction\n\n    r = interpolate(0.7, 0.0, fraction)\n    g = interpolate(0.7, 0.0, fraction)\n    b = interpolate(1.0, 0.4, fraction)\n\n    color = mapnik.Color(int(r*255), int(g*255), int(b*255))\n    width = max(4.0 * fraction, 1.5)\n\n    return mapnik.Stroke(color, width)\n```", "```py\nlayer = mapnik.Layer(\"used_roads\")\nlayer.datasource = mapnik.PostGIS(host='localhost',\n                                  user='postgres',\n                                  password='',\n                                  dbname='gps_heatmap',\n                                  table='road_segments')\nlayer.styles.append(\"used_road_style\")\nmap.layers.append(layer)\n\nstyle = mapnik.Style()\nfor tally in range(1, max_tally+1):\n    line_symbol = mapnik.LineSymbolizer()\n    line_symbol.stroke = calc_stroke(tally, max_tally)\n\n    rule = mapnik.Rule()\n    rule.filter = mapnik.Filter(\"[tally] = %d\" % tally)\n    rule.symbols.append(line_symbol)\n\n    style.rules.append(rule)\nmap.append_style(\"used_road_style\", style)\n```", "```py\nmap.zoom_to_box(extent)\nmapnik.render_to_file(map, \"heatmap.png\", \"png\")\n```"]