<html><head></head><body><div><div><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Mobile Development</h1></div></div></div><p>Mobile web development has caused quite a stir in the last few years. When Apple introduced the iPhone, it didn't support third party plugins such as Flash and Silverlight. This challenged web developers to deliver worthwhile web experiences on the mobile platform with only HTML, CSS, and JavaScript. Proposed feature enhancements such as HTML5, CSS3, and ECMAScript 5 and 6, along with more powerful browsers, have improved the mobile browsing experience.</p><p>Companies and organizations have taken different approaches to delivering the mobile web experience. Some organizations reroute mobile browsers to sites that serve mobile content only (with URLs such as <code class="literal">mobile.example.com</code> or <code class="literal">m.example.com</code> instead of <code class="literal">www.example.com</code>). Others have used responsive design and mobile first strategies to deliver the same content, formatted differently, for phones, tablets, and desktop screens. Still others, such as Facebook, have given up on <a id="id731" class="indexterm"/>mobile web development and focused on mobile apps, using native applications or hybrid web apps.</p><p>In this chapter, we'll look at the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What makes developing for mobile devices different from desktop website development</li><li class="listitem" style="list-style-type: disc">How to use the ArcGIS compact build</li><li class="listitem" style="list-style-type: disc">How to control the mobile user experience with <code class="literal">dojox/mobile</code> modules</li></ul></div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec87"/>Embracing mobile</h1></div></div></div><p>Mobile web development <a id="id732" class="indexterm"/>is a fast-growing market. In India in 2012, the percentage of Internet content served from mobile devices surpassed that of desktop computers. In the US, reports show that web traffic from mobile devices accounted for 10 percent in 2014, and the percentage is increasing.</p><p>What are people doing with the mobile Internet? Some are checking their e-mail. Others are searching for information, playing games, or keeping in contact with others. People want to be connected, entertained, and informed, and they want it available when they want them.</p></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec88"/>Mobile is different</h1></div></div></div><p>Making a <a id="id733" class="indexterm"/>website work on a mobile device is vastly different from making it work on a desktop machine. There are so many things that were<a id="id734" class="indexterm"/> features on a desktop browser that are now a hindrance to work with on a mobile device. Let's look at both the good and the bad of what makes mobile different.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec138"/>The good</h2></div></div></div><p>Even with all <a id="id735" class="indexterm"/>the negatives, mobile application development is an exciting field. There are a lot of good features available for mobile web applications. Modern smartphones offer sensors and tools that would be strange on a desktop, but are vital for mobile apps. They bring a world of information to the user, and let the user make notes and share things where they are, instead of later that day when they boot up their desktop. Let's look at these features in more detail.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec114"/>Access to phone sensors</h3></div></div></div><p>Mobile devices<a id="id736" class="indexterm"/> come with a number of sensors built in. These sensors can test the device's orientation, acceleration, and even location. Location can be collected through a built-in GPS device, cell phone signal triangulation, or based on the location of your Wi-Fi signal. Newer sensors within the phone can relay battery strength. Also, some third-party hybrid tools provide access to more phone features, such as the memory, contact lists, and the camera.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec115"/>Instant access to the app</h3></div></div></div><p>Users no <a id="id737" class="indexterm"/>longer have to write down a URL to pull up at home. Now, they can speak it into the browser, or take a picture of a QR Code to access a website. That instant access gets more people to use your application right away, cutting the risk of forgetting your app's location.</p><p>With instant access to the application, users can collect data where they are, instead of going home to input information. The user can take a picture of a broken fire hydrant, log in to a community issues app, and report the problem to the proper authorities. Field workers can collect feature data in the field and check it in. Volunteer geographical data collection can be used for citizen science, municipal issue tracking, and a host of other applications.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec116"/>Instant access to the user</h3></div></div></div><p>Unlike a <a id="id738" class="indexterm"/>desktop application that may be used by anybody sitting at a library computer kiosk, mobile phones are more likely to have a single user. Application usage can be tied in to user profiles to give you a more complete picture of how your app is used by different demographics. The possibilities are endless.</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec139"/>The bad</h2></div></div></div><p>You spend hours <a id="id739" class="indexterm"/>putting together a gorgeous website that looks perfect on your monitor. You test your site on three or four different browsers, and like what you see. It looks great; it works great. It's bound to be a success.</p><p>Then, you run into a <a id="id740" class="indexterm"/>friend and want to show them your amazing website, but all you have is your smartphone. No problem, you think, as you type in site's URL into your phone's browser. What comes up is a usability nightmare. Parts of the screen are cut off. Controls don't work like you planned. You can't navigate through the menus properly. Overall, it's a mess.</p><p>Now, let's look at some of the pain points of mobile web development.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec117"/>So many screen sizes</h3></div></div></div><p>Back in <a id="id741" class="indexterm"/>the old days of the Internet, you only had to worry about a few monitor sizes. As long as you made a site that looked good on a 1024x768 monitor, you were okay. Some people had the money to afford larger monitors, while some others had smaller, but there wasn't a big difference.</p><p>Now, smartphones, tablets, and other devices have screens that range from four inches corner-to-corner to flat-screen television sizes and, because screen technology has improved so much, the smaller screens have a pixel density 1.5, 2, or even 3 times that of a standard desktop monitor. Websites that were easy to read on a desktop become squished and smaller on a smartphone.</p><p>As the number of screen resolutions increases, so does the number of tests you need to perform on your website. Does the site look as good on a three inch wide phone as on an HD television? Does it scale well?</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec118"/>Fingertip accuracy</h3></div></div></div><p>Another<a id="id742" class="indexterm"/> feature lost when moving from desktop to mobile applications is the high accuracy input of a mouse. Whether you use a mouse, a laptop trackpad, or a stylus pen with your computer, you have a mouse pointer that provides fine manipulation of your content. On mobile devices, you have to account for rather large fingers that may click more than one of your cleverly sized buttons. Also, the little closeout buttons you created for your site may be too hard to close with some of the large fingerprints out there.</p><p>Along with<a id="id743" class="indexterm"/> losing the accuracy of a mouse pointer, you also lose mouse hover events. Everything from simple tooltips to CSS-powered collapsible menus no longer work as expected in a mobile browser, because there are no hover events to listen to and work with. Your old code from five to ten years ago won't work the same in the mobile web era.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec119"/>Battery life</h3></div></div></div><p>Dealing with battery life<a id="id744" class="indexterm"/> can be another hindrance to mobile development. Repeated access to location data and constantly monitoring advertising can drain the battery on mobile devices. While this information is handy to have, it comes at a price. Remember that not everybody has a full charge on their phone, and not every battery will run for hours.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec120"/>More devices</h3></div></div></div><p>We mentioned the multitude of screen sizes before, but that's just the beginning. There are a wide variety of devices out there, running Android, iOS, Windows Phone, and other operating systems. Each one has a choice of a number of web browsers, and even those web browsers may be at different version numbers. With all this, support for the latest and greatest web features can be spotty, depending on the feature. You'll have to decide what you're willing to support, and what devices you're willing to purchase for testing.</p><p>Now that we've looked at why we should be building mobile applications, let's look at the tools we have available through the ArcGIS JavaScript API.</p></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec89"/>The ArcGIS compact build</h1></div></div></div><p>The <a id="id745" class="indexterm"/>ArcGIS JavaScript API can be loaded as a more compact library for mobile browsers. The compact build, as it is called, packs the bare minimum of the libraries needed to view map applications in a mobile browser. Other modules can be downloaded through Dojo's <code class="literal">require()</code> statements, but many will not be preloaded with the initial library.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec140"/>Modules included in the compact build</h2></div></div></div><p>The ArcGIS compact build <a id="id746" class="indexterm"/>contains all the modules necessary to build a web map application. It loads the same as the regular ArcGIS API for JavaScript, using <code class="literal">require()</code> and <code class="literal">define()</code> statements. It also comes with the most frequently used modules, such as <code class="literal">esri/Map</code> and <code class="literal">esri/layers/ArcGISDynamicMapServiceLayer</code>, to quickly load your maps while using the least<a id="id747" class="indexterm"/> bandwidth.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec141"/>What's not included</h2></div></div></div><p>With all the functionality the ArcGIS JavaScript compact build offers, you'd think they must sacrifice something. The first thing that the compact build gives up is weight. At 179.54 KB in version 3.13, the library weighs in 107.26 KB under its bulkier cousin. The regular build comes with a number of libraries preloaded, while the compact build uses <code class="literal">require()</code> or <code class="literal">define()</code> statements to request those modules separately. With this, you have better control over what library parts you send to the user.</p><p>Another item sacrificed in the ArcGIS JavaScript API compact build is the reliance on the <code class="literal">dijit</code> namespace. The first thing you'll notice is that the popups are replaced with a more simplified versions. Also, if you like the graduated zoom slider to zoom your map in and out, you can forget it in the compact build. It only supports the <strong>+</strong> and <strong>–</strong> buttons to zoom the map in and out. If you have widgets that rely on the <code class="literal">dijit/_Widgetbase</code> library, those can be downloaded separately through <code class="literal">require()</code> and <code class="literal">define()</code> statements.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec142"/>What does this mean to you?</h2></div></div></div><p>The ArcGIS JavaScript compact build provides much of the same functionality as the regular build does. There are a few differences in some of the controls, but they both present the same maps and information. The smaller library size is perfect for dropping a map into an existing application, or for using other libraries, such as Angular, Knockout, or jQuery, to handle other component interactions. If you don't have a dependence on the few features lost by using the compact build, it's worth trying.</p><div><div><h3 class="title"><a id="note19"/>Note</h3><p>For more information on the ArcGIS JavaScript API compact build, look at the<a id="id748" class="indexterm"/> ArcGIS JavaScript API documentation at <a class="ulink" href="https://developers.arcgis.com/javascript/jshelp/inside_compactbuild.html">https://developers.arcgis.com/javascript/jshelp/inside_compactbuild.html</a>.</p></div></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec90"/>ESRI Leaflet</h1></div></div></div><p>The <a id="id749" class="indexterm"/><code class="literal">Leaflet.js</code> library<a id="id750" class="indexterm"/> provides another alternative to the ArcGIS JavaScript API. It's a lightweight library that can show maps on a<a id="id751" class="indexterm"/> large range of browsers. Leaflet works well with any tiled map services, and points, lines, and polygons can be added through <a id="id752" class="indexterm"/><strong>geojson</strong>, a popular open-source JSON format for geographical data. The library can support different tools and data sources with plugins. There is a rich plugin ecosystem for the Leaflet library, with more tools and data source plugins developed daily.</p><p>ESRI has<a id="id753" class="indexterm"/> released the ESRI Leaflet plugin so that Leaflet maps can use ArcGIS Server Map Services. According to <a id="id754" class="indexterm"/>the ESRI Leaflet GitHub page, it supports the following map service layers:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">ESRI basemap services</li><li class="listitem" style="list-style-type: disc">Feature services</li><li class="listitem" style="list-style-type: disc">Tiled map services</li><li class="listitem" style="list-style-type: disc">Dynamic map services</li><li class="listitem" style="list-style-type: disc">ImageServer map services</li></ul></div><div><div><h3 class="title"><a id="note20"/>Note</h3><p>For more information about<a id="id755" class="indexterm"/> the <code class="literal">Leaflet.js</code> library, you can visit <a class="ulink" href="http://leafletjs.com/">http://leafletjs.com/</a>. For books on the library, you can check out <em>Leaflet.js Essentials</em> by Paul Crickard III, or <em>Interactive Map Designs with Leaflet JavaScript Library How-to</em> by Jonathan Derrough.</p></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec91"/>Dojox mobile</h1></div></div></div><p>Don't <a id="id756" class="indexterm"/>you <a id="id757" class="indexterm"/>wish you could create an application that mimics the style of a mobile device, while looking like a native app? That's what some of the contributors to the Dojo framework thought, and that led to the modules in <code class="literal">dojox/mobile</code>. The modules provide controls that match many of the UI elements in native mobile apps, mimicking them in form and function. With the widgets in this library, buttons and sliders look like iPhone buttons and sliders on Safari, while appearing as native Android buttons and sliders on Android-based browsers.</p><p>The <code class="literal">dojox/mobile</code> modules provide a visual interactive framework that mimics native mobile apps. Unlike their <code class="literal">dijit</code> form counterparts, the <code class="literal">dojox/mobile</code> user controls do not use so many HTML elements, improving the download speed and memory usage. The UI elements work well with other <code class="literal">dojox/mobile</code> controls, from the <code class="literal">dojox/mobile/View</code> that takes up the whole screen, down to the last <code class="literal">dojox/mobile/Button</code>. Let's take a look at a few of them.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec143"/>Dojox mobile views</h2></div></div></div><p>The <code class="literal">dojox/mobile/View</code> module<a id="id758" class="indexterm"/> provides a visual separation between parts of the application. Views are full page containers that can be navigated to and from by swipes or button presses. These are somewhat analogous to the <code class="literal">dijit/layout/ContentPane</code> in how they organize content.</p><p>Related to<a id="id759" class="indexterm"/> the <code class="literal">dojox/mobile/View</code>, the <code class="literal">dojox/mobile/ScrollableView</code> provides extra scrolling functionality in a way mobile users expect. In many mobile devices, when the user swipes the screen to scroll down the page, that user expects the page will continue to scroll until it slows to a stop. <code class="literal">ScrollableView</code> implements that inertial scrolling down the page.</p><div><div><h3 class="title"><a id="note21"/>Note</h3><p>As <code class="literal">ScrollableView</code> scrolling events interfere with panning a map on a touchscreen interface, you should not add an interactive map to this view. <code class="literal">ScrollableView</code> is better suited for forms and content that may extend beyond the height of the screen.</p></div></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec92"/>Working with touch</h1></div></div></div><p>If you're used to<a id="id760" class="indexterm"/> working with mouse events in JavaScript, touch events can be a bit confusing. The <code class="literal">touchstart</code> and <code class="literal">touchend</code> events look equivalent to the <code class="literal">mousedown</code> and <code class="literal">mouseup</code> events.</p><p>In current versions of the ArcGIS JavaScript API, many of the touch events are already handled by the API modules. When working with the map, you don't need to assign a <code class="literal">map.on("touchstart")</code> event listener on top of a <code class="literal">map.on("click")</code> event listener. The <code class="literal">map.on("click")</code> event listener handles it for you. The same goes for any Dojo widgets and controls. That's one less thing you have to do to make your application mobile-ready.</p><p>Speaking of the map, there are touch events available that make some navigation tools obsolete. You can pinch or spread your fingers on the screen to zoom in and out respectively. Panning can be controlled by dragging your finger across the map. These actions remove the need for zoom in, zoom out, and pan buttons, which can free up valuable screen real estate.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec144"/>Gestures</h2></div></div></div><p>JavaScript <a id="id761" class="indexterm"/>handling of complicated mobile gestures hasn't been as smooth as it has been in native applications. Native applications are developed to distinguish between a tap and a tap-and-hold, for instance. By default, many JavaScript-based applications treat them both as a click.</p><p>The Dojo framework that comes with the ArcGIS JavaScript API has some experimental libraries to handle gestures, with the <code class="literal">dojox/gesture</code> modules. These modules allow you to assign events using <code class="literal">dojo/on</code>, as in the following snippet:</p><div><pre class="programlisting">require(["dojo/on", "dojox/gesture/tap"], function (dojoOn, tap) {
  dojoOn(node, tap, function (e) {…});
});</pre></div><p>For simple<a id="id762" class="indexterm"/> gesture definition, <code class="literal">dojox/gesture</code> modules allow you to define tap and swipe events using <code class="literal">dojox/gesture/tap</code> and <code class="literal">dojox/gesture/swipe</code> respectively. With tap events, you can define single tap, double tap, and tap-and-hold events. For swipe events, you can define events at the beginning and end of the swipe event. In the following, you can see a code snippet implementing it:</p><div><pre class="programlisting">require(["dojo/on", "dojox/gesture/swipe"], function(on, swipe){
  on(node, swipe, function(e){ … });
  on(node, swipe.end, function(e){ alert("That was easy.");});
});</pre></div><p>You can't find a gesture that does what you want? With the <code class="literal">dojox/gesture/Base</code> module, you can define your own custom gestures. As of now, you have to define your own methods to handle gestures such as rotating, pinching, and spreading your fingers. At some point, there will be more general support for those gestures, but not as of the time of writing.</p><div><div><h3 class="title"><a id="note22"/>Note</h3><p>If you would like to learn more about handling touch and gestures in Dojo applications, you<a id="id763" class="indexterm"/> can visit <a class="ulink" href="https://dojotoolkit.org/reference-guide/1.10/dojox/gesture.html">https://dojotoolkit.org/reference-guide/1.10/dojox/gesture.html</a>.</p></div></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec93"/>Our application</h1></div></div></div><p>As our story <a id="id764" class="indexterm"/>continues, we receive a call from the city of Hollister, California, regarding their incident reporting app. They like the application, and it works great for the receptionist who takes phone calls about those issues. Now, they want a version that's more mobile-friendly, and they've come to us for help. It's time for us to take our knowledge of mobile apps and create a tool they can use from a smartphone in the field.</p><p>The <a id="id765" class="indexterm"/>original incident reporting app was built using typical <code class="literal">dijit/layout</code> elements, where every panel had a place on the screen. Now, we have to consider that there's not enough room on a smaller screen for everything. Instead, we need to organize each panel into its own separate view. We'll need to control how we navigate between these views, and use the appropriate controls that work well with a mobile device.</p><p>We'll use the ArcGIS JavaScript API compact build, along with the <code class="literal">dojox/mobile</code> modules, to create a mobile-friendly web application. We'll put the map in one view, the incident picker in a second view, and a more detailed reporting form in the third view. For all of these, we'll use <code class="literal">dojox/mobile</code> user interface components, along with the ArcGIS JavaScript API <a id="id766" class="indexterm"/>editing widgets, to create not just a mobile-friendly, but a user-friendly reporting experience as well.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec145"/>Changing the layout</h2></div></div></div><p>We will begin <a id="id767" class="indexterm"/>creating the mobile application by loading the ArcGIS compact build into the <code class="literal">index.html</code> file. In the head of the HTML document, we'll change the link to the ArcGIS JavaScript API to load the compact build. We'll keep the <code class="literal">esri.css</code> file and our own style sheet reference, but we can remove the <code class="literal">claro.css</code> style sheet reference, since our application won't need it. Our <code class="literal">index.html</code> file should look like the following:</p><div><pre class="programlisting">&lt;head&gt;
  …
  <strong>&lt;!-- note that the claro.css stylesheet is removed --&gt;</strong>
  &lt;link rel="stylesheet" 
    href="https://js.arcgis.com/3.13/esri/css/esri.css" /&gt;
  &lt;link rel="stylesheet" href="./css/style.css" /&gt;
  &lt;script type="text/javascript"&gt;
    dojoConfig = { async: true, isDebug: true };
  &lt;/script&gt;
  &lt;script src="img/"&gt;&lt;/script&gt;
&lt;/head&gt;
…</pre></div><p>The body of our application has three actionable parts. There's a map where we place our incidences. There's also a panel where we select what incident is on the map. Finally, there is a form where we fill out more information about the incident. We'll lay those out into different views: <code class="literal">mapview</code>, <code class="literal">incidentview</code>, and <code class="literal">attributeview</code>. Inside each view, we'll add the headings and controls we need for our application. It should look like the following:</p><div><pre class="programlisting">&lt;body&gt;
  &lt;div id="mapview" <strong>data-dojo-type="dojox/mobile/View"</strong>&gt;
    &lt;h1 <strong>data-dojo-type="dojox/mobile/Heading"</strong>&gt;
      Incident Reporting App
    &lt;/h1&gt;
    &lt;div id="map" &gt;
      &lt;div id="locatebutton"&gt;&lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div id="incidentview" <strong>data-dojo-type="dojox/mobile/View"</strong>&gt;
    &lt;<strong>h2 data-dojo-type="dojox/mobile/Heading"</strong> 
    <strong>data-dojo-props="back:'Map',moveTo:'mapview'"</strong>&gt;
      Incident
    &lt;/h2&gt;
    &lt;div id="pickerdiv"&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;div id="attributeview" <strong>data-dojo-type="dojox/mobile/View"&gt;</strong>
    &lt;h2 <strong>data-dojo-type="dojox/mobile/Heading" </strong>
<strong>    data-dojo-props="back:'Incident',moveTo:'incidentview'"</strong>&gt;
      Description
    &lt;/h2&gt;
    &lt;div id="attributediv"&gt;&lt;/div&gt;
  &lt;/div&gt;
  …
&lt;/body&gt;</pre></div><p>In the preceding<a id="id768" class="indexterm"/> code, we've added the familiar <code class="literal">data-dojo-type</code> attributes to create the <code class="literal">dojox/mobile/View</code> modules on the page. Inside each view, we have a <code class="literal">dojox/mobile/Heading</code> module element, to show a heading at the top of the page. The heading also doubles up as a sort of a button bar, into which we can put back buttons inside. In the <code class="literal">data-dojo-props</code> attribute of the headings, we define a back button with the <code class="literal">back</code> attribute defining the button text, and the <code class="literal">moveTo</code> attribute defining the view it switches to.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec121"/>Modifying the JavaScript</h3></div></div></div><p>In<a id="id769" class="indexterm"/> our <code class="literal">app.js</code> file, we'll need to modify the <code class="literal">require</code> statement in order to load the appropriate modules for the mobile library. Instead of loading the <code class="literal">dijit/layout</code> modules for setting up the layout, we'll need to add the <code class="literal">dojox/mobile</code> equivalent. In the <code class="literal">require()</code> statement in the <code class="literal">app.js</code> file, modify the code to add the following:</p><div><pre class="programlisting">require([
  "dojox/mobile/parser",
  "dojo/dom",
  "dojo/on",
  "esri/config",
  "esri/map",
  "esri/graphic",
  "esri/layers/FeatureLayer",
  "esri/layers/ArcGISDynamicMapServiceLayer",
  "esri/symbols/SimpleMarkerSymbol",
  "esri/geometry/Extent",
  "esri/dijit/editing/Editor",
  "esri/dijit/editing/TemplatePicker",
  "esri/dijit/editing/AttributeInspector",
  "esri/dijit/LocateButton",
  "esri/tasks/query",
  "dijit/registry",
  "dojox/mobile/Button",
  "dojox/mobile",
  "dojox/mobile/deviceTheme",
  "dojox/mobile/compat",
  "dojox/mobile/View", 
  "dojox/mobile/Heading",
  "dojox/mobile/ToolBarButton",
  "dojo/domReady!"
], function (
  parser, dojoDom, dojoOn,
  esriConfig, Map, Graphic,
  FeatureLayer, ArcGISDynamicMapServiceLayer,
  MarkerSymbol, Extent,
  Editor, TemplatePicker, AttributeInspector,
  LocateButton, Query, registry, Button
) {</pre></div><p>As you can see, we <a id="id770" class="indexterm"/>replaced the normal <code class="literal">dojo/parser</code> with a <code class="literal">dojox/mobile/parser</code> equivalent. We've added the <code class="literal">dojox/mobile</code> base class, the <code class="literal">dojox/mobile/deviceTheme</code> that loads the appropriate theme based on your browser, and <code class="literal">dojox/mobile/compat</code> so that the site can also be seen on older desktop browsers such as Internet Explorer. For the elements we want to see out of the <code class="literal">dojox/mobile</code> library, we've loaded the <code class="literal">View</code>, the <code class="literal">Heading</code> to view title data, and the <code class="literal">ToolBarButton</code> to add buttons to the heading.</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec146"/>Working with the map on mobile</h2></div></div></div><p>Let's focus <a id="id771" class="indexterm"/>on making the map work. In our mobile application, we've added the map within the <code class="literal">mapview</code> div. We've set the width and height of the map to <code class="literal">100%</code> in our <code class="literal">style.css</code> file. The map should load as normal, right?</p><p>When we load the map as it is, especially from a larger browser, we find that the map doesn't stretch all the way to the bottom. Using our favorite tools for examining DOM elements, we find that height of the map div has been set inline to <code class="literal">400px</code>. Where have we seen this before?</p><p>After examining the DOM elements of features around the map, we see that the view's height hasn't been set. By default, the <code class="literal">mapview</code> div's height depends on the height of its content. As its height has not been defined, the map sets its height to <code class="literal">400px</code>. To fix this, we need to manually define the <code class="literal">mapview</code> div's height in our <code class="literal">style.css</code> file. We'll also stop the <code class="literal">mapview</code> div from scrolling by setting its <code class="literal">overflow-y</code> to <code class="literal">hidden</code>. This will remove any unsightly scrollbars on our map, which may interfere with map navigation:</p><div><pre class="programlisting">#mapview {
  height: 100%;
  overflow-y: hidden;
}

#map {
  width: 100%;
  height: 100%;
}</pre></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec122"/>Fixing the LocateButton</h3></div></div></div><p>The <code class="literal">LocateButton</code>, which <a id="id772" class="indexterm"/>uses the browser's GPS functionality to center the map on our location, has moved around. It appears that addition of the <code class="literal">dojox/mobile/Heading</code> and the mobile buttons to zoom in and out have caused our <code class="literal">LocateButton</code> to be displaced. We can use our favorite browser DOM explorer to reposition the Locate button to a good spot, and then include it in the <code class="literal">style.css</code> file to make it more permanent. The style for the <code class="literal">LocateButton</code> should look something like the following:</p><div><pre class="programlisting">.LocateButton {
  position: absolute;
  left: 21px;
  top: 130px;
  z-index: 500;
}</pre></div><p>When you're done, you should have a map that looks like the following:</p><div><img src="img/6459OT_09_01.jpg" alt="Fixing the LocateButton" width="322" height="482"/></div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec147"/>Working with the editor widgets</h2></div></div></div><p>Now that <a id="id773" class="indexterm"/>we're using the ArcGIS compact build, we <a id="id774" class="indexterm"/>don't have access to the popup dijit that we used with the attachment editor. We don't have many of the other dijit-based modules either. This application may require a bit more work to make it mobile-ready.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec123"/>Template picker</h3></div></div></div><p>To select<a id="id775" class="indexterm"/> from the list of incidents, we chose the <code class="literal">esri/dijit/editing/TemplatePicker</code> module to create buttons to select an incident. Now, we'll keep using it, but we're looking at it in a different view. The <a id="id776" class="indexterm"/>original one presented a vertical list of buttons down the side of the page for presenting incidents. Now, we're going to remove those settings and define the template picker more normally. The code for initializing the template picker should look like the following:</p><div><pre class="programlisting">function startEditing () {
  …
  picker = new TemplatePicker({
    featureLayers: [ layer ],
    style: "width:100%;height:auto;",
    grouping: false
  }, "pickerdiv");
  picker.startup();
…</pre></div><p>To access the <a id="id777" class="indexterm"/>picker for our incidents, or to edit a currently selected feature, we need to call the <code class="literal">showInspector()</code> function. If we look over the existing function, it attempts to select features in a feature service based on a point around where we click. It uses the map's <code class="literal">infoWindow</code> to show the attribute editor. Now that we're using another location to edit the feature attributes, we need to modify the <code class="literal">showInspector()</code> code to handle our new functionality.</p><p>Our first step in making our <code class="literal">showInspector()</code> function work on a mobile is to tweak the surface area that is selected compared to that if we click on the map. Currently, it creates a two pixel wide extent around our click point. We can expand it to 10 pixels, because our fingers are wider than a mouse pointer. Also, we need to modify the <code class="literal">callback</code> function after the query succeeds. If there are no features in the location clicked on the map, we'll show the template picker. If none is selected, we'll tell it to go to the attribute inspector instead:</p><div><pre class="programlisting">function showInspector(evt) {
  var selectQuery = new Query(),
  point = evt.mapPoint,
  mapScale = map.getScale();
  selectQuery.geometry = new Extent({
    xmin: point.x - mapScale <strong>* 5</strong> / 96,
    xmax: point.x + mapScale <strong>* 5</strong> / 96,
    ymin: point.y - mapScale <strong>* 5</strong> / 96,
    ymax: point.y + mapScale <strong>* 5</strong> / 96,
    spatialReference: map.spatialReference
  });

  incidentLayer.selectFeatures(selectQuery, FeatureLayer.SELECTION_NEW, function (features) {
    <strong>if (!features.length) {</strong>
<strong>      goToPicker(point);</strong>
<strong>    } else {</strong>
<strong>      goToAttributeInspector('mapview', features[0]);</strong>
<strong>    }</strong>
  });
   }</pre></div><p>In our <code class="literal">goToPicker()</code> function, we'll switch from <code class="literal">mapview</code> to <code class="literal">incidentview</code>. We'll do this by using the <code class="literal">performTransition()</code> method provided by <code class="literal">dojox/mobile/View.</code> It accepts up to five arguments: an <code class="literal">id</code> for another view to see, a number-based direction (either <code class="literal">1</code> or <code class="literal">-1</code>), a transition style, and an object that defines <code class="literal">this</code> for the <code class="literal">callback</code> function that rounds<a id="id778" class="indexterm"/> out the fifth argument. We'll tell <code class="literal">mapview</code> to make the transition to <code class="literal">incidentview</code>, moving from the right with a <code class="literal">slide</code> animation, and we'll add a <code class="literal">callback</code> function once the process finishes:</p><div><pre class="programlisting">  function goToPicker(point) {
    registry.byId('mapview').performTransition('incidentview', 1, 'slide', null, function() {
…
  });
}</pre></div><p>When we try to run the <code class="literal">goToPicker</code> function as it is, it goes to <code class="literal">incidentview</code>, but we don't see any incidents. This is due to an interesting feature of some dojo widgets. When not visible, the widgets set their widths and heights to <code class="literal">0</code>, effectively becoming invisible. We need to refresh the <code class="literal">TemplatePicker</code> internal grid and clear the template selection.</p><p>When the user selects a feature from the list, we need something to convey our selection to the attribute inspector. We'll also add a single fire event using the <code class="literal">once()</code> method in the <code class="literal">dojo/on</code> module, and attach it to the <code class="literal">selection-change</code> event of the <code class="literal">TemplatePicker</code> widget. From there, we'll collect the selected attributes, the current date, and a few other attributes, and pass them to a function that adds the incident to the map. The function should look like the following:</p><div><pre class="programlisting">  registry.byId('mapview').performTransition('incidentview', 1, 'slide', null, function() {

    //refresh the grid used by the templatePicker.
    picker.grid.render();
    picker.clearSelection();
    // on picker selection change…
    dojoOn.once(picker, 'selection-change', function () {

    var selected = picker.getSelected();
     if (selected) {
      // log the date and time
      var currentDate = new Date();
       var incidentAttributes = {
         req_type: selected.template.name,
        req_date:(currentDate.getMonth() + 1) + "/" + currentDate.getDate() + "/" + currentDate.getFullYear(),
        req_time: currentDate.toLocaleTimeString(),
        address: "",
        district: "",
         status: 1
       };
      addIncident(point, selected.symbol, incidentAttributes);
       }
      });
    });
  }</pre></div><p>For the <code class="literal">addIncident()</code> function, we'll <a id="id779" class="indexterm"/>add our point location, symbol, and attributes into a graphic. From there, we'll add the graphic feature to the editable <code class="literal">incidentLayer</code>. Once we have completed that, we'll attempt to select it again using the <code class="literal">incidentLayer</code> layer's <code class="literal">selectFeatures()</code> method, then send the result to the <code class="literal">goToAttributeInspector()</code> function. We'll pass along the name of the current view (<code class="literal">incidentview</code>), as well as the first feature that's selected. It should look like the following:</p><div><pre class="programlisting">function addIncident(point, symbol, attributes) {
  var incident = new Graphic(point, symbol, attributes);
// add incident to the map so it can be selected and passed to the
// attribute inspector. 
incidentLayer.applyEdits([incident],null,null).then(function () {
  var selectQuery = new Query(),
        mapScale = map.getScale();
  selectQuery.geometry = new Extent({
    xmin: point.x - mapScale / 96,
    xmax: point.x + mapScale / 96,
    ymin: point.y - mapScale / 96,
    ymax: point.y + mapScale / 96,
    spatialReference: map.spatialReference
  });

  // must select features before going to attributeInspector
  incidentLayer.selectFeatures(selectQuery, FeatureLayer.SELECTION_NEW, function (features) {
    if (features.length) {
      // fill in the items
      goToAttributeInspector(features[0], "incidentview");
    }
  });
  });
}</pre></div><p>If all works correctly, you should be able to access your incident picker with <code class="literal">incidentview</code>, and it should look like the following:</p><div><img src="img/6459OT_09_02.jpg" alt="Template picker" width="322" height="482"/></div></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec124"/>Attribute inspector</h3></div></div></div><p>Now that the<a id="id780" class="indexterm"/> map and <a id="id781" class="indexterm"/>the template picker have been properly updated for the mobile application, it's time to look at the third stage of our incident reporting application. Using our previous code, we'll select the incident through the <code class="literal">FeatureLayer</code> selection. We'll then load the attribute inspector and edit the data. Finally, we'll save the feature data, including any images, to the feature service.</p><p>In the previous desktop application, we loaded the attribute inspector in the map popup. However, we don't have the same popup widget we had before in the ArcGIS compact build. This one won't be so editable on the map screen. However, we have plenty of screen real estate on the attribute view, so we'll load the inspector there. Also, note that we'll remove any of the events where the map popup loads or changes the attribute inspector.</p><p>First, we need to create a location on the page for the attribute inspector within the attribute view. In the <code class="literal">index.html</code> page, within the <code class="literal">attributeview</code> div element, we'll add a div element with an <code class="literal">id</code> of <code class="literal">attinspector</code>. When our application loads, it will create an attribute inspector in this location. It should look like the following:</p><div><pre class="programlisting">&lt;div id="attributeview" data-dojo-type="dojox/mobile/View"&gt;
  &lt;div id="attinspector"&gt;&lt;/div&gt;
&lt;/div&gt;</pre></div><p>In our <code class="literal">app.js</code> file, we <a id="id782" class="indexterm"/>will still use the <code class="literal">generateAttributeInspector()</code> function that is called by the <code class="literal">startEditing()</code> function when the map is loaded. However, the <code class="literal">generateAttributeInspector()</code> function will need a few changes to work with its more permanent surroundings. We will need to do the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Initialize and start up the attribute inspector where the <code class="literal">attinspector</code> div element is located</li><li class="listitem" style="list-style-type: disc">Remove any references to the <code class="literal">infoWindow</code> property of the map</li><li class="listitem" style="list-style-type: disc">When the changes are applied to the <code class="literal">generateAttributeInspector()</code> function, it should look something like the following:<div><pre class="programlisting">function generateAttributeInspector(layer) {

    layerInfos = [{
      featureLayer: layer,
      showAttachments: true,
      isEditable: true,
      showDeleteButton: false,
      fieldInfos: [
        {'fieldName': 'req_type', 'isEditable':true, 'tooltip': 'What\'s wrong?', 'label':'Status:'},
        {'fieldName': 'req_date', 'isEditable':false, 'tooltip': 'Date incident was reported.', 'label':'Date:'},
        {'fieldName': 'req_time', 'isEditable':false,'label':'Time:'},
        {'fieldName': 'address', 'isEditable':true, 'label':'Address:'},
        {'fieldName': 'district', 'isEditable':true, 'label':'District:'},
        {'fieldName': 'status', 'isEditable':false, 'label':'Status:'}
      ]
    }]; //"","req_date","req_time","address","district","status"

    attInspector = new AttributeInspector({
      layerInfos: layerInfos
    }, <code class="literal">"attinspector"</code>);

    attInspector.startup();

    //add a save button next to the delete button
    var saveButton = new Button({ label: "Save", "class": "saveButton"});
    domConstruct.place(saveButton.domNode, attInspector.deleteBtn.domNode, "after");

    saveButton.on("click", function(){
      updateFeature.getLayer()
       .applyEdits(null, [updateFeature], null); 
    });

    attInspector.on("attribute-change", function(evt) {
      //store the updates to apply when the save button is clicked
      updateFeature.attributes[evt.fieldName] = evt.fieldValue;
    });

    attInspector.on("next", function(evt) {
      updateFeature = evt.feature;
      console.log("Next " + updateFeature.attributes.objectid);
    });

    attInspector.on("delete", function(evt){
      evt.feature.getLayer()
        .applyEdits(null,null,[updateFeature]);
      map.infoWindow.hide();
    });
<strong>    // content after this was deleted.</strong>
  }</pre></div></li></ul></div><p>Once we have <a id="id783" class="indexterm"/>made the changes, we can run the application in a browser and check out the attribute inspector. After clicking on a troublesome location on our map, and identifying the incident with <code class="literal">TemplatePicker</code>, we should be able to view and edit the incident attributes with the attribute inspector.</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec148"/>Trouble in the app</h2></div></div></div><p>Oops, we've <a id="id784" class="indexterm"/>run into a bit of a problem with the application. We tested the app by tapping on a spot on the map to report an incident. We selected the incident type from the template picker, and it made the selection. After a couple of seconds, it switched over to the attribute inspector, and we got the following:</p><div><img src="img/6459OT_09_03.jpg" alt="Trouble in the app" width="322" height="482"/></div><p>The attribute <a id="id785" class="indexterm"/>inspector form is very unsightly, and doesn't behave in the way it did as a desktop web application. The user controls to edit the feature attributes don't work very well. How could this happen?</p><p>The issues with the attribute inspector actually lead back to something we did at the beginning of this application. We removed the <code class="literal">claro.css</code> file at the head of the web page and, along with it, removed any other <code class="literal">dijit</code> references. This act saved significant bandwidth on our application, but we lost the styling and functionality of the user controls in the attribute inspector. Now, it's not going to do what we want it to.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec149"/>Rebuilding the attribute inspector</h2></div></div></div><p>There is <a id="id786" class="indexterm"/>another way, however. We can create our own form for updating the feature attributes. We can use form elements from the <code class="literal">dojox/mobile</code> modules to make our own form, instead of using the attribute inspector. Also, on closer inspection, the attachment editor portion of the attribute inspector worked well. We can load the attachment editor after our custom form, and use it to save images to the features.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec125"/>Creating the form</h3></div></div></div><p>To make the<a id="id787" class="indexterm"/> custom form, we're going to need to load a few <code class="literal">dojox/mobile</code> modules to parse. In the <code class="literal">require()</code> list in our <code class="literal">app.js</code> file, we'll add the <code class="literal">dojox/mobile/RoundRect</code> module to create a rounded body for the form. We'll also use <code class="literal">dojox/mobile/TextBox</code> for text entry, as well as the combination of <code class="literal">dijit/form/DataList</code> and <code class="literal">dojox/mobile/ComboBox</code> to create a mobile drop-down menu. We're also going to use <code class="literal">dojox/mobile/Button</code> to save our changes. Our <code class="literal">require</code> statement should look like the following:</p><div><pre class="programlisting">require([…, "dojox/mobile/RoundRect", "dojox/mobile/TextBox",
 "dijit/form/DataList", "dojox/mobile/ComboBox", 
  "dojox/mobile/Button", "dojo/domReady!"], function ( … ) { 
…
});</pre></div><p>Next, we'll modify the attribute view to make the form for editing the incident attributes. We'll use <code class="literal">DataList</code> and <code class="literal">ComboBox</code> in <code class="literal">index.html</code> as a selection tool for the incident type. In this way, if the wrong type is selected, the user will be able to correct it. Next, we'll use <code class="literal">Textbox</code> to record the <code class="literal">Address</code> and <code class="literal">District</code> attributes. The date, time, and status are read-only at this point, since we don't want the reporter to change the date and time of the incident and whether the incident has been opened or closed. Finally, we'll add a <code class="literal">Save</code> button to the form to save the results. Once we add these to <code class="literal">index.html</code>, the file should look like the following:</p><div><pre class="programlisting">&lt;div id="attributeview" data-dojo-type="dojox/mobile/View"&gt;
  &lt;h2 data-dojo-type="dojox/mobile/Heading" 
    data-dojo-props="back:'Incident',moveTo:'incidentview'"&gt;
      Description
  &lt;/h2&gt;
  &lt;div data-dojo-type="dojox/mobile/RoundRect"&gt;
    &lt;label&gt;Request Type:&lt;/label&gt;
    &lt;select data-dojo-type="dijit/form/DataList"
      data-dojo-props='id:"incidentDataList"'&gt;
        &lt;option&gt;Graffiti Complaint&lt;/option&gt;
        &lt;option&gt;Blocked Street or Sidewalk&lt;/option&gt;
        &lt;option&gt;Damaged Property&lt;/option&gt;
        &lt;option&gt;Sewer Issues&lt;/option&gt;
        &lt;option&gt;Tree Maintenance or Damage&lt;/option&gt;
        &lt;option&gt;Sidewalk and Curb Issues&lt;/option&gt;
    &lt;/select&gt;
    &lt;input type="text" data-dojo-type="dojox/mobile/ComboBox"
      data-dojo-props='list:"incidentDataList",
        id:"incidentSelector"' /&gt;
    &lt;br /&gt;
    &lt;label&gt;Date:&lt;/label&gt;
    &lt;span id="incidentDate"&gt;&lt;/span&gt;
    &lt;br /&gt;
    &lt;label&gt;Time:&lt;/label&gt;
    &lt;span id="incidentTime"&gt;&lt;/span&gt;
    &lt;br /&gt;
    &lt;label&gt;Address:&lt;/label&gt;
    &lt;input type="text" data-dojo-type="dojox/mobile/TextBox"
      data-dojo-props='id:"incidentAddress"' /&gt;
    &lt;br /&gt;
    &lt;label&gt;District:&lt;/label&gt;
    &lt;input type="text" data-dojo-type="dojox/mobile/TextBox"
      data-dojo-props='id:"incidentDistrict"' /&gt;
    &lt;br /&gt;
    &lt;label&gt;Status: &lt;/label&gt;
    &lt;span id="incidentStatus"&gt;&lt;/span&gt;
    &lt;br /&gt;
    &lt;button data-dojo-type="dojox/mobile/Button"
      data-dojo-props="id:'saveButton'"&gt;Save&lt;/button&gt;
…
  &lt;/div&gt;</pre></div><p>Finally, we <a id="id788" class="indexterm"/>need to modify our JavaScript to handle the form input and output. We'll create two functions, <code class="literal">setupIncident()</code> and <code class="literal">saveEdits()</code>, to load and save the data from the incident details form. The <code class="literal">setupIncident()</code> function will accept the feature to be modified as an argument. Also, since <code class="literal">setupIncident()</code> can be called when tapping on an existing incident on the map, or after selecting an incident type in <code class="literal">TemplatePicker</code>, we'll pass the view name along with the feature data so it can move to the incident details view:</p><div><pre class="programlisting">  function setupIncident(feature, view) {
    var attr = feature.attributes;
    updateFeature = feature;
    registry.byId("incidentSelector").set("value", attr.req_type);
    dojoDom.byId("incidentDate").innerHTML = attr.req_date;
    dojoDom.byId("incidentTime").innerHTML = attr.req_time;
    registry.byId("incidentAddress").set("value", attr.address);
    registry.byId("incidentDistrict").set("value", attr.district);
    dojoDom.byId("incidentStatus").innerHTML = attr.status;

    attInspector.showAttachments(feature, incidentLayer);
    registry.byId(view).performTransition('attributeview', 1, 'slide');
  }</pre></div><p>The <code class="literal">saveEdits()</code> function <a id="id789" class="indexterm"/>will collect the values from the form, add those values as feature attributes, and save the feature back to the geodatabase:</p><div><pre class="programlisting">  function setupIncident() { 
    …
  }
  function saveEdits(){
    // add updated values
    updateFeature.attributes.req_type = registry.byId("incidentSelector").get("value");
    updateFeature.attributes.address = registry.byId("incidentAddress").get("value");
    updateFeature.attributes.district = registry.byId("incidentDistrict").get("value");

    // update the feature layer
    updateFeature.getLayer().applyEdits(null, [updateFeature], null);
    // move back to the map view
    registry.byId("attributeview").performTransition("mapview",  -1, 'slide');
  }</pre></div></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec126"/>The attachment editor</h3></div></div></div><p>The last <a id="id790" class="indexterm"/>feature we will be implementing is the addition of photos to the incident reports. The previous version used the attachment editor that was part of the attribute inspector. Now that we're implementing our own entry form, we need to include the attachment editor separately.</p><p>The first step in adding the attachment editor in our application is to add the module reference in the <code class="literal">app.js</code> file <code class="literal">require</code> statement. According to the API documentation, the module to use is in <code class="literal">esri/dijit/editing/AttachmentEditor</code>. We'll add the reference in the following code:</p><div><pre class="programlisting">require([…
  "esri/dijit/editing/TemplatePicker",
  <strong>"esri/dijit/editing/AttachmentEditor",</strong>
  …
], function (… 
  TemplatePicker, <strong>AttachmentEditor</strong>,
  …
) {  });</pre></div><p>We'll initialize the attachment editor after the <code class="literal">TemplatePicker</code> in our <code class="literal">startEditing()</code> function and <a id="id791" class="indexterm"/>assign it to the variable <code class="literal">attachmentEditor</code>. We need the scope of the <code class="literal">attachmentEditor</code> to fit within the whole application since we'll be connecting it with feature data in other functions. You can see the additions highlighted in the following code:</p><div><pre class="programlisting">require([…
  "esri/dijit/editing/TemplatePicker",
<strong>  "esri/dijit/editing/AttachmentEditor",</strong>
  …
], function ( 
  TemplatePicker, AttachmentEditor,
  …
) {

<strong>  var attachmentEditor;</strong>
  …
  function startEditing () {
    // add the Locate button
    var locator = new LocateButton({map: map}, "locatebutton");
    var incidentLayer = map.getLayer("incidentLayer");

    picker = new TemplatePicker({
      featureLayers: [ layer ],
      style: "width:100%;height:auto;",
      grouping: false
    }, "pickerdiv");
    picker.startup();

<strong>    attachmentEditor = new AttachmentEditor({}, "attributediv");</strong>
<strong>    attachmentEditor.startup();</strong>
    …
  }
  …
});</pre></div><p>When we connect our editing form with our data in the <code class="literal">setupIncident()</code> function, we also need to connect the <code class="literal">attachmentEditor</code> to its data. After we've updated the editing form with the feature values, we'll call the <code class="literal">showAttachments()</code> method of the <code class="literal">attachmentEditor</code>. This method accepts the feature, as well as the layer to be edited. The attachment editor will handle how to display existing attachments, and how to add new ones. The code changes should look like the following:</p><div><pre class="programlisting">  function setupIncident(feature, view) {
    var attr = feature.attributes;
    updateFeature = feature;
    registry.byId("incidentSelector").set("value", attr.req_type);
    dojoDom.byId("incidentDate").innerHTML = attr.req_date;
    dojoDom.byId("incidentTime").innerHTML = attr.req_time;
    registry.byId("incidentAddress").set("value", attr.address);
    registry.byId("incidentDistrict").set("value", attr.district);
    dojoDom.byId("incidentStatus").innerHTML = attr.status;

<strong>    attachmentEditor.showAttachments(feature, incidentLayer);</strong>
    registry.byId(view).performTransition('attributeview', 1, 'slide');
  }</pre></div><p>Finally, we <a id="id792" class="indexterm"/>need to supply an element to <code class="literal">index.html</code>, in which we will attach the attachment editor widget. At the bottom of the <code class="literal">attributeview</code> element, underneath the editing form, we'll add a <code class="literal">div</code> element with the <code class="literal">id</code> of <code class="literal">attributediv</code>. That portion of our <code class="literal">index.html</code> page should look like the following:</p><div><pre class="programlisting">&lt;div id="attributeview" data-dojo-type="dojox/mobile/View"&gt;
  &lt;h2 data-dojo-type="dojox/mobile/Heading" 
    data-dojo-props="back:'Incident',moveTo:'incidentview'"&gt; 
  Description
  &lt;/h2&gt;
  &lt;div data-dojo-type="dojox/mobile/RoundRect"&gt;
    …
    &lt;button data-dojo-type="dojox/mobile/Button"
    data-dojo-props="id:'saveButton'"&gt;Save&lt;/button&gt;
  &lt;/div&gt;
<strong>  &lt;div id="attributediv"&gt;&lt;/div&gt;</strong>
&lt;/div&gt;</pre></div><p>When you run the application and begin reporting an incident, you should eventually see a form that looks like the following:</p><div><img src="img/6459OT_09_04.jpg" alt="The attachment editor" width="322" height="482"/></div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec150"/>The end result</h2></div></div></div><p>After <a id="id793" class="indexterm"/>modifying our application layout and behavior, we now have a useful mobile reporting tool. A citizen could load this page in their browser and report any problems they find. City workers could also use this to report incidents. Your application should look like this:</p><div><img src="img/6459OT_09_05.jpg" alt="The end result" width="322" height="445"/></div><p>More work<a id="id794" class="indexterm"/> could be done to improve the application. Currently, it requires a constant Internet connection to make edits. If your mobile device is in an area with bad network coverage, any edits will be lost.</p></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec94"/>Summary</h1></div></div></div><p>In this chapter, we have examined what makes a website mobile. We looked at the requirements for a mobile application, in screen real estate, functionality, and bandwidth. We looked at the ArcGIS compact build to use on mobile applications. We also modified an existing application previously formatted for desktop use, and made it mobile-ready.</p><p>In the next chapter, we'll investigate how to write testable code using test-driven development.</p></div></div></div></body></html>