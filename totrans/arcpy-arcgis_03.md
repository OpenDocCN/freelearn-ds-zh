# 第三章。创建第一个 Python 脚本

现在我们已经将 Python 配置得符合我们的需求，我们可以创建 Python 脚本。本章将探讨如何使用 ArcGIS **ModelBuilder**来建模一个简单的分析作为脚本的基础。ModelBuilder 本身非常有用，并且对于创建 Python 脚本也非常有用，因为它具有操作和可视化组件，并且所有模型都可以输出为 Python 脚本。这将使我们能够比较更熟悉的 ModelBuilder 如何利用 ArcToolbox 中的工具与 Python 如何处理相同的工具。我们还将讨论迭代以及在何时使用 Python 而不是 ModelBuilder 最佳。

在本章中，我们将涵盖以下主题：

+   使用 ModelBuilder 建模简单分析

+   将模型导出到 Python 脚本

# 前提条件

“除了 ArcGIS ModelBuilder 外，还需要数据集和脚本。”

对于本章，相关的数据和脚本应从 Packt Publishing 的网站下载。完成的脚本可用于比较目的，数据将用于本章的分析。

## ModelBuilder

ArcGIS 自 1970 年代以来一直在开发中。在这段时间里，它包含各种编程语言和工具，以帮助 GIS 分析师自动化分析和地图制作。这些包括 ArcGIS 3x 系列中的 Avenue 脚本语言以及 ARC/Info 工作站时代的**ARC 宏语言（AML**），以及直到 ArcGIS 10x 时的 VBScript，当时引入了 Python。ArcGIS 9x 中引入的另一项有用工具是 ModelBuilder，这是一个用于建模分析和创建可重复使用不同输入要素类的工具的可视化编程环境。

ModelBuilder 的另一个有用功能是导出功能，允许模型师直接从模型创建 Python 脚本。这将使比较 ModelBuilder 工具中的输入如何被接受与 Python 脚本如何调用同一工具并向其提供输入，或者创建的要素类如何命名和放置在文件结构中变得更加容易。ModelBuilder 是一个出色的工具，它将使 GIS 分析师轻松地从常规 GIS 工作流程过渡到基于 Python 的自动化工作流程。

# 创建模型并导出到 Python

本章将依赖于可从 Packt Publishing 网站下载的`SanFrancisco.gdb`文件地理数据库。旧金山 GDB 包含从[data.sfgov.org](http://data.sfgov.org)和位于[factfinder2.census.gov](http://factfinder2.census.gov)的美国人口普查局的美国事实查找网站下载的数据。地理数据库中包含的所有人口普查和地理数据均来自 2010 年人口普查。数据包含在名为**SanFrancisco**的要素数据集中。该要素数据集中的数据位于 NAD 83 加利福尼亚州平面坐标系 3 区，线性度量单位为美国英尺（这对应于欧洲石油调查组，或 EPSG，格式中的 SRID 2227）。

我们将使用模型创建的分析，并将其最终导出到 Python 中进行进一步优化，将使用旧金山的特定线路上的公交车站。这些公交车站将被缓冲以创建每个公交车站周围的代表性区域。然后，这些缓冲区域将与人口普查区相交，以找出每个代表性区域周围有多少人。

## 建模选择和缓冲工具

使用模型构建器，我们首先将构建公交车站分析的基础模型。一旦建模完成，它将被导出为自动生成的 Python 脚本。按照以下步骤开始分析：

1.  打开**ArcCatalog**并创建一个文件夹连接到包含`SanFrancisco.gdb`的文件夹。右键单击地理数据库，添加一个名为**Chapter3Tools**的新工具箱。

1.  接下来，打开**模型构建器**并创建一个模型，将其保存在**Chapter3Tools**工具箱中，命名为**Chapter3Model1**。

1.  从**ArcToolbox**中的**分析/提取**工具集拖动**Bus_Stops**要素类和**选择**工具。

1.  打开**选择**工具，并将输出要素类命名为`Inbound71`。确保要素类被写入到**Chapter3Results**要素数据集中。

1.  打开**表达式**SQL 查询构建器，创建以下 SQL 表达式：**NAME = '71 IB' AND BUS_SIGNAG = 'Ferry Plaza'**。![建模选择和缓冲工具](img/8662OS_03_01.jpg)

1.  下一步是添加来自**分析/邻近**工具集的**缓冲**工具。**缓冲**工具将用于创建每个公交车站周围的缓冲区。缓冲的公交车站允许我们与以人口普查区形式的人口普查数据进行交集，从而创建每个公交车站周围的代表性区域。

1.  将**选择**工具的输出（**Inbound71**）连接到**缓冲**工具。打开**缓冲**工具，并将 400 添加到**距离**字段，单位为**英尺**。其余选项留空。点击**确定**并返回模型。

![建模选择和缓冲工具](img/8662OS_03_02.jpg)

## 添加**交集**工具

现在我们已经选择了感兴趣的公交线路，并将车站缓冲以创建代表性区域，我们需要将这些区域与人口普查区相交，以找出每个代表性区域的居民人数：

1.  首先，将**CensusBlocks2010**要素类从**SanFrancisco**要素数据集添加到模型中。

1.  接下来，添加位于**ArcToolbox**中**分析/叠加**工具集的**交集**工具。虽然我们可以使用**空间连接**来实现类似的结果，但我使用**交集**工具来捕获交集区域，以便在模型和脚本中稍后使用。

到目前为止，我们的模型应该看起来像这样：

![添加交集工具](img/8662OS_03_03.jpg)

## 统计分析结果

在创建了这个简单的分析之后，下一步是确定每个公交车站的结果。找出受每个公交车站 400 英尺缓冲区影响的普查区中居住的人数，需要检查最终要素类中的每一行数据，并选择与公交车站对应的行。一旦这些行被选中，就可以使用 **字段计算器** 或 **汇总** 工具计算选中行的总和。所有这些方法都可行，但都不是完美的。它们花费的时间太长，更糟糕的是，如果模型中的假设被调整（例如，缓冲区从 400 英尺调整为 500 英尺），则这些方法无法自动重复。

这就是传统使用 ModelBuilder 的方式开始让分析师感到失败的地方。应该很容易指示模型选择与每个公交车站相关的所有行，并为每个公交车站的代表区域生成人口总和。如果模型能够创建一个包含分析最终结果的电子表格就更好了。现在是时候使用 Python 将这一分析提升到下一个层次了。

# 导出模型并调整脚本

虽然 ModelBuilder 中的建模分析有其缺点，但 ModelBuilder 中内置了一个非常棒的功能；即创建模型并将其导出到 Python 的能力。结合 ArcGIS 帮助文档，这是发现编写 ArcPy 脚本时应该使用正确 Python 语法的最有效方法。

在 **SanFrancisco** 地数据库旁边创建一个可以存放导出脚本的文件夹（例如，`C:\Projects\Scripts`）。这将包含 ArcGIS 自动生成的导出脚本，以及我们将从这些生成的脚本中构建的版本。

打开名为 **Chapter3Model1** 的模型，并在左上角的 **模型** 菜单中点击。从菜单中选择 **导出**，然后选择 **导出到 Python 脚本**。将脚本保存在脚本文件夹中，命名为 `Chapter3Model1.py`。

### 注意

注意，还有将模型导出为图形的选项。创建模型的图形是一个很好的方法，可以在不共享模型和数据的情况下与其他分析师分享模型正在做什么，当共享 Python 脚本时也很有用。

## 自动生成的脚本

在 IDE 中打开自动生成的脚本。它应该看起来像这样：

```py
# -*- coding: utf-8 -*-
# ---------------------------------------------------------------------------
# 8662_Chapter3Model1.py
# Created on: 2014-04-22 21:59:31.00000
#   (generated by ArcGIS/ModelBuilder)
# Description:
# ---------------------------------------------------------------------------
# Import arcpy module
import arcpy
# Local variables:
Bus_Stops = "C:\\Projects\\PacktDB.gdb\\SanFrancisco\\Bus_Stops"
CensusBlocks2010 = "C:\\Projects\\PacktDB.gdb\\SanFrancisco\\CensusBlocks2010"
Inbound71 = "C:\\Projects\\PacktDB.gdb\\Chapter3Results\\Inbound71"
Inbound71_400ft_buffer = "C:\\Projects\\PacktDB.gdb\\Chapter3Results\\Inbound71_400ft_buffer"
Intersect71Census = "C:\\Projects\\PacktDB.gdb\\Chapter3Results\\Intersect71Census"
# Process: Select
arcpy.Select_analysis(Bus_Stops,
 Inbound71,
 "NAME = '71 IB' AND BUS_SIGNAG = 'Ferry Plaza'")
# Process: Buffer
arcpy.Buffer_analysis(Inbound71,
 Inbound71_400ft_buffer,
 "400 Feet", "FULL", "ROUND", "NONE", "")
# Process: Intersect
arcpy.Intersect_analysis("C:\\Projects\\PacktDB.gdb\\Chapter3Results\\Inbound71_400ft_buffer #;C:\\Projects\\PacktDB.gdb\\SanFrancisco\\CensusBlocks2010 #", Intersect71Census, "ALL", "", "INPUT")

```

让我们逐行检查这个脚本。第一行前面有一个井号（#），这意味着这一行是一个注释；然而，当脚本按常规执行时，Python 解释器不会忽略这一行，而是用它来帮助 Python 解释脚本编码，如这里所述：[`legacy.python.org/dev/peps/pep-0263`](http://legacy.python.org/dev/peps/pep-0263)。

第二行注释和第三行注释是为了装饰目的。接下来的四行注释（全部注释）用于向读者提供有关脚本的信息，包括脚本的名称和创建时间，以及从模型属性中提取的描述。还包含了一行装饰性注释，用于在视觉上将信息性标题与脚本的主体分开。虽然将注释信息包含在脚本中供其他脚本用户使用是友好的，但并非必需。

脚本的主体或脚本的执行部分从`import arcpy`行开始。按照惯例，导入语句包含在脚本主体的顶部。在这种情况下，只导入了 ArcPy 模块。

ModelBuilder 的导出功能不仅创建了一个可执行脚本，还为每个部分添加了注释，以帮助标记脚本的各个部分。这些注释让用户知道变量所在的位置以及 ArcToolbox 工具正在执行的位置。随着读者对代码的理解加深，注释可能会变得多余，但 ESRI 包含这些注释是很友好的。

在导入语句下方是变量。在这种情况下，变量代表输入和输出要素类的文件路径。变量名称是从要素类的名称（文件路径的基本名称）派生出来的。文件路径通过赋值运算符（=）分配给变量，文件路径的部分通过两个反斜杠分隔。

# Python 中的文件路径

很好地回顾一下在 Python 中与在 Windows 中表示方式相比，文件路径的使用方式。在 Python 中，文件路径是字符串，Python 中的字符串有特殊字符用于表示制表符（\t）、换行符（\n）或回车符（\r），以及其他许多字符。这些特殊字符都包含单个反斜杠，这使得创建使用单个反斜杠的文件路径变得非常困难。这本来不是什么大问题，但是 Windows 资源管理器中的文件路径全部使用单个反斜杠。

有多种方法可以避免这个问题。Python 是在 Linux 环境中开发的，那里的文件路径使用正斜杠。这种更符合 Python 风格的表示方式在 Windows 环境中使用 Python 时也是可用的，如下所示：

```py
Windows Explorer: "C:\Projects\PacktDB.gdb\Chapter3Results\Intersect71Census"
Pythonic version:  "C:/Projects/PacktDB.gdb/Chapter3Results/Intersect71Census"
```

在 Python 脚本中，使用正斜杠的文件路径将正常工作，而 Windows 资源管理器版本可能会使脚本抛出异常。

避免特殊字符问题的另一种方法是 ModelBuilder 在从模型自动创建 Python 脚本时使用的方法。在这种情况下，反斜杠是通过使用第二个反斜杠来转义的。前面的脚本使用第二种方法产生了以下结果：

```py
Python escaped version:  "C:\\Projects\\PacktDB.gdb\\Chapter3Results\\Intersect71Census"
```

第三个方法，我比较喜欢，是创建一个所谓的原始字符串。这与常规字符串相同，但在脚本开始前包含一个**r**。这个**r**会通知 Python 解释器，接下来的脚本不包含任何特殊字符或转义字符。以下是一个使用示例：

```py
Python raw string:  r"C:\Projects\PacktDB.gdb\Chapter3Results\Intersect71Census"
```

使用原始字符串将使从 Windows 资源管理器获取文件路径并将其添加到脚本中的字符串内变得更加容易。它还将使避免在文件路径中意外忘记包含一组双反斜杠变得更加容易，这种情况经常发生，是许多脚本错误的原因。

# 继续分析脚本：ArcPy 工具

下一个，也是最重要的脚本部分是执行分析的地方。在这个部分中包含了我们在模型中创建的工具，即**Select**、**Buffer**和**Intersect**工具。模型中提供的相同参数也包含在这里：输入和输出，以及 Select 工具中的 SQL 语句和 Buffer 工具中的缓冲距离。

工具参数按照在模型工具界面中出现的顺序提供给脚本中的工具。以下是脚本中的**Select**工具：

```py
arcpy.Select_analysis(Bus_Stops, Inbound71, "NAME = '71 IB' AND BUS_SIGNAG = 'Ferry Plaza'")

```

它的工作原理是这样的。arcPy 模块有一个名为`Select_analysis`的方法或特殊属性。当调用此方法时，需要三个参数：输入要素类（或 shapefile）、输出要素类和 SQL 语句。在这个例子中，输入由变量`Bus_Stops`表示，输出要素类由变量`Inbound71`表示，这两个变量都在变量部分定义。SQL 语句作为第三个参数包含在内。请注意，如果变量在上文定义，它也可以表示为变量；作为字符串的 SQL 语句可以分配给变量，然后变量可以替换 SQL 语句作为第三个参数。以下是一个使用变量替换参数的示例：

```py
sqlStatement = "NAME = '71 IB' AND BUS_SIGNAG = 'Ferry Plaza'"
arcpy.Select_analysis(Bus_Stops, Inbound71, sqlStatement)

```

虽然 ModelBuilder 在将输入和输出要素类分配给变量方面做得很好，但它不会将变量分配给参数的每个部分。当我们调整和构建自己的脚本时，这将是一个重要的纠正点。

**Buffer** 工具接受与 **Select** 工具相似的参数集。它有一个由变量表示的输入要素类，一个输出要素类变量，以及我们提供的距离（在这个例子中是 400 英尺），以及一系列默认提供的参数。请注意，这些参数依赖于关键字，并且这些关键字可以在脚本的文本中调整，以调整最终的缓冲输出。例如，英尺可以调整为米，缓冲区会更大。请查看工具的帮助部分，以更好地了解其他参数将如何影响缓冲区，以及 ArcPy 中**Buffer**工具将接受的键词参数。此外，如前所述，所有参数都可以分配给变量，如果在脚本中重复使用相同的参数，这可以节省时间。

有时提供的参数只是一个空字符串，就像这里最后一个参数的情况：

```py
arcpy.Buffer_analysis(Inbound71,Inbound71_400ft_buffer,
 "400 Feet", "FULL", "ROUND", "NONE", "")

```

空字符串，在这种情况下表示这个缓冲区没有溶解字段，在 ArcPy 中非常常见。它也可以用两个单引号表示，但 ModelBuilder 已经被构建为使用双引号来包含字符串。

## **Intersect** 工具和字符串操作

最后一个工具，**Intersect** 工具，在工具执行时使用不同的方法来表示需要相交的文件。因为这个工具接受输入部分中的多个文件（这意味着在一个操作中可以相交的文件数量没有限制），它将所有文件路径存储在一个字符串中。这个字符串使用井号或磅号（#）来分隔输入字符串中的文件路径。如果我们想在脚本工具中使用**Intersect**工具，我们必须处理这种轻微的偏差。如果我们从这个脚本构建一个工具，我们将在它们运行之前不知道将要相交的文件，因此我们需要了解将变量插入字符串的方法。

有三种方法可以将变量插入到字符串中。每种方法都有其技术上的优缺点。了解这三种方法都很好，因为它们的应用范围超出了我们在这里的需求，所以让我们来回顾一下。

### 字符串操作方法 1-字符串相加

字符串相加最初可能是一个奇特的概念，因为它看起来不可能将字符串相加，这与整数或浮点数不同，它们是数字。然而，在 Python 和其他编程语言中，这却是一个正常的步骤。使用加号（+），字符串可以相加形成更长的字符串，或者允许变量被添加到现有字符串的中间。以下是一些这个过程的示例：

```py
>>> aString = "This is a string"
>>> bString = " and this is another string"
>>> aString + bString

```

输出如下：

```py
'This is a string and this is another string'

```

```py
>>> cString = aString + bString
>>> cString

```

输出如下：

```py
'This is a string and this is another string'

```

两个或多个字符串可以相加，甚至可以分配给第三个变量。这个过程在诸如 Intersect 工具的输入字符串等情况下可能很有用。字符串可以被拆分，代表文件路径的变量可以插入到字符串的中间：

```py
filePath1 = r"C:\Projects\Inbound71_400ft_buffer"
filePath2 =  r"C:\Projects\CensusBlocks2010"
arcpy.Intersect_analysis(filePath1 + " #;" + filePath2 + " #", Intersect71Census, "ALL", "", "INPUT")

```

这是一种强大且有用的方法，可以将文件路径插入到输入字符串中。只要分隔符仍然包含在字符串中，字符串仍然有效，Intersect 工具将按预期运行。以下是字符串相加完成后的字符串看起来像什么：

```py
>>> filePath1 = r"C:\Projects\Inbound71_400ft_buffer"
>>> filePath2 =  r"C:\Projects\CensusBlocks2010"
>>> inputString = filePath1 + " #;" + filePath2 + " #"
>>> print inputString

```

输出如下：

```py
C:\Projects\Inbound71_400ft_buffer #;C:\Projects\CensusBlocks2010 #

```

另一种与字符串相加类似的分支是字符串乘法，其中字符串通过一个整数相乘来产生字符串的重复版本：

```py
>>>"string" * 3

```

输出如下：

```py
'stringstringstring'

```

### 字符串操作方法 2–字符串格式化 #1

字符串操作的第二种方法，称为字符串格式化，涉及在字符串中添加将接受特定类型数据的占位符。这意味着这些特殊字符串可以接受其他字符串以及整数和浮点值。这些占位符使用取模 (%) 和一个键字母来指示预期的数据类型。字符串使用 **%s** 表示，浮点数使用 **%f** 表示，整数使用 **%d** 表示。浮点数还可以通过在取模后添加一个修改数字来调整，以限制包含的数字位数。如果字符串中有多个占位符，则值以元组的形式传递到字符串中。

自从 Python 2.6 中引入了下一节讨论的第三种方法以来，这种方法已经变得不那么流行了，但了解它仍然很有价值，因为许多较老的脚本仍在使用它。以下是这个方法的示例：

```py
>>> origString = "This string has as a placeholder %s"
>>> newString = origString % "and this text was added"
>>> print newString

```

输出如下：

```py
This string has as a placeholder and this text was added

```

这里是一个使用浮点占位符的示例：

```py
>>> floatString1 = "This string has a float here: %f"
>>> newString = floatString1 % 1.0
>>> print newString

```

输出如下：

```py
This string has a float here: 1.000000
>>> floatString2 = "This string has a float here: %.1f"
>>> newString2 = floatString2 % 1.0
>>> print newString2

```

输出如下：

```py
This string has a float here: 1.0

```

这里是一个使用整数占位符的示例：

```py
>>> intString = "Here is an integer: %d"
>>> newString = intString % 1
>>> print newString

```

输出如下：

```py
Here is an integer: 1

```

对于 **Intersect** 工具，可以使用 %s 符号来接受文件路径字符串变量：

```py
filePath1 = r"C:\Projects\Inbound71_400ft_buffer"
filePath2 =  r"C:\Projects\CensusBlocks2010"
arcpy.Intersect_analysis("%s #;%s #" % (filePath1,filePath2), Intersect71Census, "ALL", "", "INPUT")

```

### 字符串操作方法 3–字符串格式化 #2

最后一种方法，也是最近引入的，也称为字符串格式化。它与前面讨论的字符串格式化类似，但增加了不需要特定类型占位符的好处。占位符，或称为标记，只需按顺序排列即可被接受。格式化函数是字符串内建的；通过在字符串中添加 `.format` 并传递参数，字符串接受这些值：

```py
>>> formatString = "This string has 3 tokens: {0}, {1}, {2}"
>>> newString = formatString.format("String", 2.5, 4)
>>> print newString
The output is as follows:
This string has 3 tokens: String, 2.5, 4

```

标记不需要在字符串中按顺序排列，甚至可以重复。顺序是从传递给 `.format` 函数的参数中派生出来的，该函数将值传递到字符串中。

对于 **Intersect** 工具，字符串格式化看起来像这样：

```py
filePath1 = r"C:\Projects\Inbound71_400ft_buffer"
filePath2 =  r"C:\Projects\CensusBlocks2010"
arcpy.Intersect_analysis("{0} #;{1} #".format(filePath1,filePath2), Intersect71Census, "ALL", "", "INPUT")

```

第三种方法因为能够重复添加值并使其能够避免向特定占位符提供错误类型的数据，而不同于第二种方法，已经成为我字符串操作的首选方法。

# 调整脚本

现在是时候将自动生成的脚本进行调整，以适应我们的需求。我们希望脚本既能生成输出数据，又能分析数据并将结果汇总到电子表格中。这个电子表格将包含每个公交车站的平均人口值。平均值将从与公交车站周围的缓冲代表区域相交的每个普查区块中得出。将原始脚本保存为`Chapter3Model1Modified`.`py`。

# 将 CSV 模块添加到脚本中

对于这个脚本，我们将使用**CSV**模块，这是一个用于创建逗号分隔值电子表格的有用模块。其简单的语法将使其成为创建脚本输出的有用工具。需要注意的是，当 ArcGIS for Desktop 安装时，它也会安装**xlrd**和**xlwt**模块，分别用于读取或生成 Excel 电子表格。

在 import arcPy 行下方添加`import csv`。这将允许我们使用 csv 模块创建电子表格：

```py
# Import arcpy module
import arcpy
import csv

```

下一个调整是对**Intersect**工具进行的。注意，输入字符串中包含的两个路径也在变量部分定义为变量。从输入字符串中删除文件路径，并用编号占位符替换它们，然后添加格式函数并供应变量作为占位符：

```py
# Process: Intersect
arcpy.Intersect_analysis("{0} #;{1}#".format( ..............  Inbound71_400ft_buffer,CensusBlocks2010),
                         Intersect71Census, "ALL", "", "INPUT")
```

## 访问数据：使用游标

现在脚本已经到位，可以生成我们需要的原始数据，我们需要一种方法来访问**Intersect**工具输出特征类中存储的数据。这种访问将允许我们聚合代表每个公交车站的数据行。我们还需要某种东西来在内存中存储聚合数据，以便写入电子表格。

为了完成第二部分，我们将使用 Python 字典。为了完成第一部分，我们将使用 ArcPy 模块中内置的方法：数据访问搜索游标。

Python 字典将在**Intersect**工具下方添加。在 Python 中，使用花括号创建字典。将以下行添加到脚本中：

dataDictionary = {}

此脚本将使用公交车站 ID 作为字典的键。值将是列表，将包含与每个公交车站 ID 相关的所有人口值。添加以下行以生成数据游标：

```py
with arcpy.da.SearchCursor(Intersect71Census, ["STOPID","POP10"]) as cursor:
    for row in cursor:
        busStopID = row[0]
        pop10 = row[1]
        if busStopID not in dataDictionary.keys():
            dataDictionary[busStopID] = [pop10]
        else:
            dataDictionary[busStopID].append(pop10)
```

这个迭代结合了 Python 和 ArcPy 中的几个想法。使用 with … as 语句创建一个变量（游标），该变量代表`arcpy.da.SearchCursor`对象。它也可以写成这样：

```py
cursor = arcpy.da.SearchCursor(Intersect71Census, ["STOPID","POP10"])
```

### 注意

with … as 结构的优势在于，当迭代完成后，游标对象将从内存中删除，从而消除了对正在评估的特征类的锁定。

`arcpy.da.SearchCursor()` 函数需要一个输入要素类和一个要返回的字段列表。可选地，一个 SQL 语句可以限制返回的行数。

下一个行，`for row in cursor`，是遍历数据。它不是一个正常的 Python 遍历，这种区别在某些情况下会产生影响。例如，然而，它确实允许逐行访问包含在提供的要素类中的数据。请注意，当使用搜索游标时，每一行数据都作为元组返回，无法修改。可以使用索引访问数据，如前述代码所示，其中元组的两个成员被分配给变量。

if/else 条件语句允许对数据进行排序。如前所述，公交站 ID，即元组中包含的数据的第一个成员，将被用作键。条件语句评估公交站 ID 是否包含在字典的现有键中（这些键包含在一个列表中，并使用 `dictionary.keys()` 方法访问）。如果没有，它将被添加到键中，并分配一个包含（最初）一个数据片段的列表作为值，即该行中包含的人口值。如果它已经存在于键中，则将下一个与该公交站 ID 相关的人口值附加到列表中。使用此代码，我们现在已根据与之关联的公交站对每个普查区人口进行排序。

接下来，我们需要添加代码来创建电子表格。此代码将使用相同的 with ... as 结构，并使用两个内置 Python 函数 `sum` 和 `len` 来生成平均人口值，其中 `sum` 从数字列表创建总和，而 `len` 将获取列表、元组或字符串的长度：

```py
with open(r'C:\Projects\Output\Averages.csv', 'wb') as csvfile:
    csvwriter = csv.writer(csvfile, delimiter=',')
    for busStopID in dataDictionary.keys():
        popList = dataDictionary[busStopID]
        averagePop = sum(popList)/len(popList)
        data = [busStopID, averagePop]
        csvwriter.writerow(data)
```

使用公交站 ID 键从字典中检索平均人口值，并将其分配给变量 `averagePop`。然后将两个数据片段，`BusStopID` 和 `averatePop` 变量添加到一个列表中，该列表被提供给一个 `CSVwriter` 对象，该对象知道如何接受数据并将其写入文件，该文件位于提供给内置 Python `open()` 函数的文件路径中，用于创建简单文件。

脚本已完成，尽管在末尾添加一行以提供脚本已运行的视觉确认是件好事：

```py
print "Data Analysis Complete"
```

这将创建一个输出，表明脚本已运行。一旦完成，请转到输出 csv 文件的所在位置，并使用 Excel 或记事本打开它，查看分析结果。我们的第一个脚本已完成！

# 最终脚本

这是脚本最终应该看起来的样子：

```py
# -*- coding: utf-8 -*-
# ---------------------------------------------------------------------------
# 8662_Chapter3Model1.py
# Created on: 2014-04-22 21:59:31.00000
#   (generated by ArcGIS/ModelBuilder)
# Description:
# ---------------------------------------------------------------------------

# Import arcpy module
import arcpy
import csv

# Local variables:
Bus_Stops = r"C:\Projects\PacktDB.gdb\SanFrancisco\Bus_Stops"
CensusBlocks2010 = r"C:\Projects\PacktDB.gdb\SanFrancisco\CensusBlocks2010"
Inbound71 = r"C:\Projects\PacktDB.gdb\Chapter3Results\Inbound71"
Inbound71_400ft_buffer = r"C:\Projects\PacktDB.gdb\Chapter3Results\Inbound71_400ft_buffer"
Intersect71Census = r"C:\Projects\PacktDB.gdb\Chapter3Results\Intersect71Census"

# Process: Select
arcpy.Select_analysis(Bus_Stops,
 Inbound71,
 "NAME = '71 IB' AND BUS_SIGNAG = 'Ferry Plaza'")
# Process: Buffer
arcpy.Buffer_analysis(Inbound71,
 Inbound71_400ft_buffer,
 "400 Feet", "FULL", "ROUND", "NONE", "")
# Process: Intersect
arcpy.Intersect_analysis("{0} #;{1} #".format(Inbound71_400ft_buffer,CensusBlocks2010),
 Intersect71Census, "ALL", "", "INPUT")

dataDictionary = {}

with arcpy.da.SearchCursor(Intersect71Census, ["STOPID","POP10"]) as cursor:
 for row in cursor:
 busStopID = row[0]
 pop10 = row[1]
 if busStopID not in dataDictionary.keys():
 dataDictionary[busStopID] = [pop10]
 else:
 dataDictionary[busStopID].append(pop10)

with open(r'C:\Projects\Output\Averages2.csv', 'wb') as csvfile:
 spamwriter = csv.writer(csvfile, delimiter=',')
 for busStopID in dataDictionary.keys():
 popList = dataDictionary[busStopID]
 averagePop = sum(popList)/len(popList)
 data = [busStopID, averagePop]
 spamwriter.writerow(data)

print "Data Analysis Complete"

```

# 摘要

在本章中，我们介绍了如何构建分析模型并将其导出为脚本。在讨论脚本之后，我们对脚本进行了调整，以包含结果分析和总结，这些内容被输出到 CSV 文件中。特别是，我们讨论了如何使用 ModelBuilder 创建分析和将其导出为脚本，以及如何调整脚本使其更符合 Python 风格。我们还简要提到了搜索游标的使用，这将在第五章（Chapter 5）中更详细地介绍，即*ArcPy 游标 – 搜索、插入和更新*。此外，我们还看到了如何使用内置模块，如 CSV 模块，与 ArcPy 一起使用，以捕获格式化的电子表格中的分析输出。

在下一章中，我们将讨论如何创建更复杂的脚本并构建函数以避免代码重复。这些函数将使得代码一旦编写就可以永久使用。这种代码的重用将展示 Python 如何超越分析自动化，成为一套新的生产力工具集。
