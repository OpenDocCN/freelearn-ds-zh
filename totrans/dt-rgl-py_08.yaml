- en: '*Chapter 8*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*'
- en: RDBMS and SQL
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RDBMS和SQL
- en: Learning Objectives
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够：
- en: Apply the basics of RDBMS to query databases using Python
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python将RDBMS的基本知识应用于查询数据库
- en: Convert data from SQL into a pandas DataFrame
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将SQL中的数据转换为pandas DataFrame
- en: This chapter explains the concepts of databases, including their creation, manipulation
    and control, and transforming tables into pandas DataFrames.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了数据库的概念，包括它们的创建、操作和控制，以及将表转换为pandas DataFrame。
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter of our data journey is focused on **RDBMS** (Relational Database
    Management Systems) and **SQL** (Structured Query Language). In the previous chapter,
    we stored and read data from a file. In this chapter, we will read structured
    data, design access to the data, and create query interfaces for databases.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们数据之旅的本章专注于**RDBMS**（关系数据库管理系统）和**SQL**（结构化查询语言）。在前一章中，我们从文件中存储和读取数据。在本章中，我们将读取结构化数据，设计数据访问，并为数据库创建查询接口。
- en: 'Data has been stored in RDBMS format for years. The reasons behind it are as
    follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 数据已经以RDBMS格式存储多年。背后的原因如下：
- en: RDBMS is one of the safest ways to store, manage, and retrieve data.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RDBMS是存储、管理和检索数据的一种非常安全的方式。
- en: They are backed by a solid mathematical foundation (relational algebra and calculus)
    and they expose an efficient and intuitive declarative language – SQL – for easy
    interaction.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们有一个坚实的数学基础（关系代数和关系演算），并且提供了一个高效直观的声明性语言——SQL，以便轻松交互。
- en: Almost every language has a rich set of libraries to interact with different
    RDBMS and the tricks and methods of using them are well tested and well understood.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几乎每种语言都有丰富的库来与不同的RDBMS交互，并且使用它们的技巧和方法已经过良好的测试和理解。
- en: Scaling an RDBMS is a pretty well-understood task and there are a bunch of well
    trained, experienced professionals to do this job (DBA or database administrator).
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展关系型数据库管理系统（RDBMS）是一个相当熟悉的任务，并且有许多受过良好训练、经验丰富的专业人士（数据库管理员或数据库管理员）来做这项工作。
- en: 'As we can see in the following chart, the market of DBMS is big. This chart
    was produced based on market research that was done by **Gartner, Inc.** in **2016**:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下图表所示，DBMS市场很大。此图表是基于**Gartner, Inc.**在**2016**年进行的市调产生的：
- en: '![Figure 8.1 Commercial database market share in 2016](img/C11065_08_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 2016年商业数据库市场份额](img/C11065_08_01.jpg)'
- en: Figure 8.1 Commercial database market share in 2016
  id: totrans-16
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.1 2016年商业数据库市场份额
- en: We will learn and play around with some basic and fundamental concepts of database
    and database management systems in this chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习和探索数据库和数据库管理系统的一些基本和基本概念。
- en: Refresher of RDBMS and SQL
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RDBMS和SQL的复习
- en: An RDBMS is a piece of software that manages data (represented for the end user
    in a tabular form) on physical hard disks and is built using the Codd's relational
    model. Most of the databases that we encounter today are RDBMS. In recent years,
    there has been a huge industry shift toward a newer kind of database management
    system, called **NoSQL** (**MongoDB**, **CouchDB**, **Riak**, and so on). These
    systems, although in some aspects they follow some of the rules of RDBMS, in most
    cases reject or modify them.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: RDBMS是一种管理数据（对于最终用户以表格形式表示）的软件，它使用Codd的关系模型构建，并存储在物理硬盘上。我们今天遇到的数据库大多数都是RDBMS。近年来，整个行业向一种新型的数据库管理系统转变，称为**NoSQL**（**MongoDB**、**CouchDB**、**Riak**等）。这些系统虽然在某些方面遵循RDBMS的一些规则，但在大多数情况下拒绝或修改了它们。
- en: How is an RDBMS Structured?
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RDBMS是如何结构的？
- en: 'The RDBMS structure consists of three main elements, namely the storage engine,
    query engine, and log management. Here is a diagram that shows the structure of
    a RDBMS:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: RDBMS结构由三个主要元素组成，即存储引擎、查询引擎和日志管理。以下是显示RDBMS结构的图：
- en: '![Figure 8.2 RDBMS structure](img/C11065_08_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 RDBMS结构](img/C11065_08_02.jpg)'
- en: Figure 8.2 RDBMS structure
  id: totrans-23
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.2 RDBMS结构
- en: 'The following are the main concepts of any RDBMS structure:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些RDBMS结构的主要概念：
- en: '**Storage engine**: This is the part of the RDBMS that is responsible for storing
    the data in an efficient way and also to give it back when asked for, in an efficient
    way. As an end user of the RDBMS system (an application developer is considered
    an end user of an RDBMS), we will never need to interact with this layer directly.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储引擎**：这是RDBMS中负责以高效方式存储数据并在请求时以高效方式返回数据的部分。作为RDBMS系统的最终用户（应用程序开发人员被视为RDBMS的最终用户），我们永远不会需要直接与这一层交互。'
- en: '**Query engine**: This is the part of the RDBMS that allows us to create data
    objects (tables, views, and so on), manipulate them (create and delete columns,
    create/delete/update rows, and so on), and query them (read rows) using a simple
    yet powerful language.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询引擎**：这是 RDBMS 的部分，允许我们创建数据对象（表、视图等），操作它们（创建和删除列，创建/删除/更新行等），并使用简单而强大的语言查询它们（读取行）。'
- en: '**Log management**: This part of the RDBMS is responsible for creating and
    maintaining the logs. If you are wondering why the log is such an important thing,
    then you should look into how replication and partitions are handled in a modern
    RDBMS (such as PostgreSQL) using something called **Write Ahead Log** (or WAL
    for short).'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志管理**：RDBMS 的这部分负责创建和维护日志。如果你想知道为什么日志如此重要，那么你应该了解一下在现代 RDBMS（如 PostgreSQL）中如何使用所谓的
    **Write Ahead Log**（或简称为 WAL）来处理复制和分区。'
- en: We will focus on the query engine in this chapter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中关注查询引擎。
- en: SQL
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQL
- en: '**S**tructured **Q**uery **L**anguage or **SQL** (pronounced sequel), as it
    is commonly known, is a domain-specific language that was originally designed
    based on E.F. Codd''s relational model and is widely used in today''s databases
    to define, insert, manipulate, and retrieve data from them. It can be further
    sub-divided into four smaller sub-languages, namely **DDL** (Data Definition Language),
    **DML** (Data Manipulation Language), **DQL** (Data Query Language), and **DCL**
    (Data Control Language). There are several advantages of using SQL, with some
    of them being as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**结构化查询语言**（**S**tructured **Q**uery **L**anguage 或 **SQL**，通常发音为 sequel）是一种领域特定语言，最初是基于
    E.F. Codd 的关系模型设计的，并且在当今的数据库中广泛用于定义、插入、操作和从数据库中检索数据。它可以进一步细分为四个较小的子语言，即 **DDL**（数据定义语言）、**DML**（数据操作语言）、**DQL**（数据查询语言）和
    **DCL**（数据控制语言）。使用 SQL 有几个优点，其中一些如下：'
- en: It is based on a solid mathematical framework and thus it is easy to understand.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它基于一个坚实的数学框架，因此很容易理解。
- en: It is a declarative language, which means that we actually never tell it how
    to do its job. We almost always tell it what to do. This frees us from a big burden
    of writing custom code for data management. We can be more focused on the actual
    query problem we are trying to solve instead of bothering about how to create
    and maintain a data store.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一种声明性语言，这意味着我们实际上从未告诉它如何完成其工作。我们几乎总是告诉它要做什么。这使我们从编写数据管理自定义代码的大负担中解放出来。我们可以更专注于我们试图解决的查询问题，而不是烦恼于如何创建和维护数据存储。
- en: It gives you a fast and readable way to deal with data.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为你提供了一个快速且易于阅读的方式来处理数据。
- en: SQL gives you out-of-the-box ways to get multiple pieces of data with a single
    query.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL 提供了单次查询获取多个数据片段的现成方法。
- en: The main areas of focus for the following topic will be DDL, DML, and DQL. The
    DCL part is more for database administrators.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个主题的主要关注领域将是 DDL、DML 和 DQL。DCL 部分更多是针对数据库管理员的。
- en: '`CREATE` `TABLE` or `DROP` `TABLE` or `ALTER` `TABLE`.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CREATE` `TABLE` 或 `DROP` `TABLE` 或 `ALTER` `TABLE`。'
- en: Note
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Notice the use of uppercase letters. It is not a specification and you can use
    lowercase letters, but it is a widely followed convention and we will use that
    in this book.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意大写字母的使用。这并不是一个规范，你可以使用小写字母，但这是一个广泛遵循的约定，我们将在本书中使用它。
- en: '`INSERT` `INTO`, `DELETE` `FROM`, or `UPDATE`.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INSERT` `INTO`、`DELETE` `FROM` 或 `UPDATE`。'
- en: '`SELECT` command. We will also see and use the concepts of the primary key,
    foreign key, index, joins, and so on.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SELECT` 命令。我们还将看到并使用主键、外键、索引、连接等概念。'
- en: 'Once you define and insert data in a database, it can be represented as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在数据库中定义并插入数据，它可以表示如下：
- en: '![Figure 8.3 Table displaying sample data](img/C11065_08_03.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.3 显示示例数据的表](img/C11065_08_03.jpg)'
- en: Figure 8.3 Table displaying sample data
  id: totrans-43
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8.3 显示示例数据的表
- en: Another thing to remember about RDBMS is relations. Generally, in a table, we
    have one or more columns that will have unique values for each row in the table.
    We call them **primary keys** for the table. We should be aware that we will encounter
    unique values across the rows, which are not primary keys. The main difference
    between them and primary keys is the fact that a primary key cannot be null.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 RDBMS 另一件需要记住的事情是关系。通常，在一个表中，我们有一列或多列，每行在表中都有唯一值。我们称它们为该表的 **主键**。我们应该意识到，我们将在行之间遇到唯一值，这些值不是主键。它们与主键之间的主要区别是主键不能为空。
- en: 'By using the primary key of one table and mentioning it as a foreign key in
    another table, we can establish relations between two tables. A certain table
    can be related to any finite number of tables. The relations can be 1:1, which
    means that each row of the second table is uniquely related to one row of the
    first table, or 1 :N, N:1, or N: M. An example of relations is as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用一个表的主键，并在另一个表中将其作为外键提及，我们可以在两个表之间建立关系。某个表可以与任何有限数量的表相关联。关系可以是 1:1，这意味着第二个表的每一行都与第一个表的唯一一行相关联，或者
    1:N，N:1，或者 N:M。关系的一个例子如下：
- en: '![Figure 8.4 Diagram showing relations](img/C11065_08_04.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.4 显示关系的图](img/C11065_08_04.jpg)'
- en: Figure 8.4 Diagram showing relations
  id: totrans-47
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8.4 显示关系的图
- en: With this brief refresher, we are now ready to jump into hands-on exercises
    and write some SQL to store and retrieve data.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个简短的复习，我们现在可以开始动手练习，并编写一些 SQL 来存储和检索数据。
- en: Using an RDBMS (MySQL/PostgreSQL/SQLite)
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 RDBMS（MySQL/PostgreSQL/SQLite）
- en: In this topic, we will focus on how to write some basic SQL commands, as well
    as how to connect to a database from Python and use it effectively within Python.
    The database we will choose here is SQLite. There are other databases, such as
    `Oracle`, `MySQL`, `Postgresql`, and `DB2`. The main tricks that you are going
    to learn here will not change based on what database you are using. But for different
    databases, you will need to install different third-party Python libraries (such
    as `Psycopg2` for `Postgresql`, and so on). The reason they all behave the same
    way (apart for some small details) is the fact that they all adhere to `PEP249`
    (commonly known as Python DB API 2).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个主题中，我们将关注如何编写一些基本的 SQL 命令，以及如何从 Python 连接到数据库并在 Python 中有效地使用它。我们将选择 SQLite
    作为数据库。还有其他数据库，例如 `Oracle`、`MySQL`、`Postgresql` 和 `DB2`。你将要学习的主要技巧不会根据你使用的数据库而改变。但是，对于不同的数据库，你需要安装不同的第三方
    Python 库（例如，`Postgresql` 的 `Psycopg2` 等）。它们之所以都以相同的方式（除了某些小细节外）运行，是因为它们都遵循 `PEP249`（通常称为
    Python DB API 2）。
- en: This is a good standardization and saves us a lot of headaches while porting
    from one RDBMS to another.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的标准化，在从一种 RDBMS 转移到另一种时，它能节省我们很多麻烦。
- en: Note
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Most of the industry standard projects which are written in Python and use some
    kind of RDBMS as the data store, most often relay on an ORM or Object Relational
    Mapper. An ORM is a high-level library in Python which makes many tasks, while
    dealing with RDBMS, easier. It also exposes a more Pythonic API than writing raw
    SQL inside Python code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数用 Python 编写并使用某种 RDBMS 作为数据存储的行业标准项目，通常依赖于一个 ORM 或对象关系映射器。ORM 是一个高级库，在处理
    RDBMS 时使许多任务变得更容易。它还提供了一个比在 Python 代码中编写原始 SQL 更 Pythonic 的 API。
- en: 'Exercise 107: Connecting to Database in SQLite'
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 107：在 SQLite 中连接到数据库
- en: 'In this exercise, we will look into the first step toward using a RDBMS in
    Python code. All we are going to do is connect to a database and then close the
    connection. We will also learn about the best way to do this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将探讨使用 Python 代码中的 RDBMS 的第一步。我们即将要做的是连接到数据库，然后关闭连接。我们还将了解如何最好地完成这项任务：
- en: 'Import the `sqlite3` library of Python by using the following command:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令导入 Python 的 `sqlite3` 库：
- en: '[PRE0]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Use the `connect` function to connect to a database. If you already have some
    experience with databases, then you will notice that we are not using any `server
    address`, `user name`, `password`, or other credentials to connect to a database.
    This is because these fields are not mandatory in `sqlite3,` unlike in `Postgresql`
    or `MySQL`. The main database engine of SQLite is embedded:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `connect` 函数连接到数据库。如果你对数据库有一些经验，你会注意到我们没有使用任何 `服务器地址`、`用户名`、`密码` 或其他凭证来连接到数据库。这是因为这些字段在
    `sqlite3` 中不是强制性的，而在 `Postgresql` 或 `MySQL` 中则是。SQLite 的主要数据库引擎是嵌入式的：
- en: '[PRE1]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Close the connection, as follows:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭连接，如下所示：
- en: '[PRE2]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This `conn` object is the main connection object, and we will need that to get
    a second type of object in the future once we want to interact with the database.
    We need to be careful about closing any open connection to our database.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个 `conn` 对象是主要的连接对象，一旦我们想要与数据库交互，我们将来需要获取第二种类型的对象。我们需要小心关闭对数据库的任何打开连接。
- en: 'Use the same `with` statement from Python, just like we did for files, and
    connect to the database, as follows:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用与文件相同的 `with` 语句，连接到数据库，如下所示：
- en: '[PRE3]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this exercise, we have connected to a database using Python.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们已经使用 Python 连接到数据库。
- en: 'Exercise 108: DDL and DML Commands in SQLite'
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 108：SQLite 中的 DDL 和 DML 命令
- en: In this exercise, we will look at how we can create a table, and we will also
    insert data in it.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将查看如何创建一个表，并且我们还将向其中插入数据。
- en: As the name suggests, DDL (Data Definition Language) is the way to communicate
    to the database engine in advance to define what the data will look like. The
    database engine creates a table object based on the definition provided and prepares
    it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，DDL（数据定义语言）是提前与数据库引擎通信以定义数据外观的方式。数据库引擎根据提供的定义创建一个表对象，并对其进行准备。
- en: To create a table in SQL, use the `CREATE` `TABLE` SQL clause. This will need
    the table name and the table definition. Table name is a unique identifier for
    the database engine to find and use the table for all future transactions. It
    can be anything (any alphanumeric string), as long as it is unique. We add the
    table definition in the form of (column_name_1 data_type, column_name_2 data type,
    … ). For our purpose, we will use the `text` and `integer` datatypes, but usually
    a standard database engine supports many more datatypes, such as float, double,
    date time, Boolean, and so on. We will also need to specify a primary key. A primary
    key is a unique, non-null identifier that's used to uniquely identify a row in
    a table. In our case, we use email as a primary key. A primary key can be an integer
    or text.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 SQL 中创建一个表，使用 `CREATE TABLE` SQL 子句。这需要表名和表定义。表名是数据库引擎用于查找和在未来所有事务中使用表的唯一标识符。它可以是一切（任何字母数字字符串），只要它是唯一的。我们将以（column_name_1
    数据类型，column_name_2 数据类型，……）的形式添加表定义。出于我们的目的，我们将使用 `text` 和 `integer` 数据类型，但通常标准数据库引擎支持更多的数据类型，例如
    float、double、日期时间、布尔值等。我们还需要指定一个主键。主键是一个唯一、非空的标识符，用于在表中唯一标识一行。在我们的例子中，我们使用电子邮件作为主键。主键可以是整数或文本。
- en: 'The last thing you need to know is that unless you call a `commit` on the series
    of operations you just performed (together, we formally call them a `transaction`),
    nothing will be actually performed and reflected in the database. This property
    is called **atomicity**. In fact, for a database to be industry standard (to be
    useable in real life), it needs to follow the ACID (Atomicity, Consistency, Isolation,
    Durability) properties:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要知道的是，除非你对你刚刚执行的一系列操作（我们正式称之为“事务”）调用 `commit`，否则实际上不会执行任何操作并在数据库中反映出来。这个特性被称为**原子性**。实际上，为了使数据库成为行业标准（在实际生活中可用），它需要遵循
    ACID（原子性、一致性、隔离性、持久性）特性：
- en: 'Use SQLite''s `connect` function to connect to the `chapter.db` database, as
    follows:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 SQLite 的 `connect` 函数连接到 `chapter.db` 数据库，如下所示：
- en: '[PRE4]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: This code will work once you add the snippet from step 3.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦你添加了第 3 步中的代码片段，此代码就会生效。
- en: 'Create a cursor object by calling `conn.cursor()`. The cursor object acts as
    a medium to communicate with the database. Create a table in Python, as follows:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用 `conn.cursor()` 创建一个游标对象。游标对象作为与数据库通信的媒介。在 Python 中创建一个表，如下所示：
- en: '[PRE5]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Insert rows into the database that you created, as follows:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式将行插入你创建的数据库中：
- en: '[PRE6]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Commit to the database:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交到数据库：
- en: '[PRE7]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will create the table and write two rows to it with data.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个表并将两行数据写入其中。
- en: Reading Data from a Database in SQLite
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 SQLite 数据库中读取数据
- en: In the preceding exercise, we created a table and stored data in it. Now, we
    will learn how to read the data that's stored in this database.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的练习中，我们创建了一个表并在其中存储了数据。现在，我们将学习如何读取存储在此数据库中的数据。
- en: The `SELECT` clause is immensely powerful, and it is really important for a
    data practitioner to master `SELECT` and everything related to it (such as conditions,
    joins, group-by, and so on).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`SELECT` 子句非常强大，对于数据从业者来说，掌握 `SELECT` 以及与之相关的所有内容（例如条件、连接、分组等）非常重要。'
- en: The *** after `SELECT` tells the engine to select all of the columns from the
    table. It is a useful shorthand. We have not mentioned any condition for the selection
    (such as above a certain age, first name starting with a certain sequence of letters,
    and so on). We are practically telling the database engine to select all the rows
    and all the columns from the table. It is time-consuming and less effective if
    we have a huge table. Hence, we would want to use the `LIMIT` clause to limit
    the number of rows we want.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`SELECT` 后的 *** 告诉引擎从表中选择所有列。这是一个有用的缩写。我们还没有提到任何选择条件（例如年龄超过某个值、名字以某个字母序列开头等）。我们实际上是在告诉数据库引擎从表中选择所有行和所有列。如果我们有一个非常大的表，这将非常耗时且效率低下。因此，我们希望使用
    `LIMIT` 子句来限制我们想要的行数。'
- en: 'You can use the `SELECT` clause in SQL to retrieve data, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 SQL 中的 `SELECT` 子句来检索数据，如下所示：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output is as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/Image61892.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image61892.jpg)'
- en: 'Figure 8.5: Output of the SELECT clause'
  id: totrans-90
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.5：SELECT子句的输出
- en: 'The syntax to use the `SELECT` clause with a `LIMIT` as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `LIMIT` 与 `SELECT` 子句的语法如下：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: This syntax is a sample code and will not work on Jupyter notebook.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此语法是示例代码，在 Jupyter notebook 中无法工作。
- en: This will select all the columns, but only the first 50 rows from the table.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这将选择所有列，但只从表中选取前50行。
- en: 'Exercise 109: Sorting Values that are Present in the Database'
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习109：对数据库中存在的值进行排序
- en: 'In this exercise, we will use the `ORDER BY` clause to sort the rows of user
    table with respect to age:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用 `ORDER BY` 子句按年龄对用户表的行进行排序：
- en: 'Sort the `chapter.db` by `age` in descending order, as follows:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按降序对 `chapter.db` 中的 `age` 进行排序，如下所示：
- en: '[PRE10]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output is as follows:'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/Image61902.jpg)'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/Image61902.jpg)'
- en: 'Figure 8.6: Output of data displaying age in descending order'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.6：按降序显示年龄的数据输出
- en: 'Sort the `chapter.db` by `age` in ascending order, as follows:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按升序对 `chapter.db` 中的 `age` 进行排序，如下所示：
- en: '[PRE11]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output is as follows:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/Image61910.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image61910.jpg)'
- en: 'Figure 8.7: Output of data displaying age in ascending order'
  id: totrans-107
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.7：按升序显示年龄的数据输出
- en: Notice that we don't need to specify the order as `ASC` to sort it into ascending
    order.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要指定 `ASC` 来按升序排序。
- en: 'Exercise 110: Altering the Structure of a Table and Updating the New Fields'
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习110：修改表结构并更新新字段
- en: In this exercise, we are going to add a column using `ALTER` and `UPDATE` the
    values in the newly added column.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用 `ALTER` 添加一个列，并使用 `UPDATE` 更新新添加列中的值。
- en: 'The `UPDATE` command is used to edit/update any row after it has been inserted.
    Be careful when using it because using `UPDATE` without selective clauses (such
    as `WHERE`) affects the entire table:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`UPDATE` 命令用于在插入后编辑/更新任何行。使用时请小心，因为没有选择性子句（如 `WHERE`）的 `UPDATE` 会影响整个表：'
- en: 'Establish the connection with the database by using the following command:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令建立与数据库的连接：
- en: '[PRE12]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add another column in the `user` table and fill it with `null` values by using
    the following command:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `user` 表中添加另一列，并使用以下命令填充 `null` 值：
- en: '[PRE13]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Update all of the values of `gender` so that they are `M` by using the following
    command:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令更新所有 `gender` 的值，使它们为 `M`：
- en: '[PRE14]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To check the altered table, execute the following command:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检查修改后的表，请执行以下命令：
- en: '[PRE15]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![](img/Image61918.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image61918.jpg)'
- en: 'Figure 8.8: Output after altering the table'
  id: totrans-121
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.8：修改表后的输出
- en: We have updated the entire table by setting the gender of all the users as `M`,
    where `M` stands for male.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已通过将所有用户的性别设置为 `M`（代表男性）来更新整个表。
- en: 'Exercise 111: Grouping Values in Tables'
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习111：在表中分组值
- en: In this exercise, we will learn about a concept that we have already learned
    about in pandas. This is the `GROUP` `BY` clause. The `GROUP` `BY` clause is a
    technique that's used to retrieve distinct values from the database and place
    them in individual buckets.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将学习一个我们已经在 pandas 中学习过的概念。这就是 `GROUP BY` 子句。`GROUP BY` 子句是一种用于从数据库中检索不同值并将它们放入单独桶的技术。
- en: 'The following diagram explains how the GROUP BY clause works:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图解说明了GROUP BY子句的工作原理：
- en: '![](img/Image61926.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image61926.jpg)'
- en: 'Figure 8.9: Illustration of the GROUP BY clause on a table'
  id: totrans-127
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.9：GROUP BY子句在表上的说明
- en: In the preceding diagram, we can see that the `Col3` column has only two unique
    values across all rows, A and B.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到 `Col3` 列在所有行中只有两个唯一值，A和B。
- en: 'The command that''s used to check the total number of rows belonging to each
    group is as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 用于检查每个组所属行总数的命令如下：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add female users to the table and group them based on the gender:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 向表中添加女性用户并根据性别进行分组：
- en: 'Add a female user to the table:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向表中添加一个女性用户：
- en: '[PRE17]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Run the following code to see the count by each gender:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下代码以查看按性别划分的计数：
- en: '[PRE18]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output is as follows:'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/Image61935.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image61935.jpg)'
- en: 'Figure 8.10: Output of the GROUP BY clause'
  id: totrans-138
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.10：GROUP BY子句的输出
- en: Relation Mapping in Databases
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据库中的关系映射
- en: 'We have been working with a single table and altering it, as well as reading
    back the data. However, the real power of an RDBMS comes from the handling of
    relationships among different objects (tables). In this section, we are going
    to create a new table called `comments` and link it with the user table in a 1:
    N relationship. This means that one user can have multiple comments. The way we
    are going to do this is by adding the `user` table''s primary key as a foreign
    key in the `comments` table. This will create a 1: N relationship.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '我们一直在使用单个表，对其进行修改，以及读取数据。然而，关系型数据库管理系统（RDBMS）的真正力量来自于处理不同对象（表）之间的关系。在本节中，我们将创建一个名为`comments`的新表，并以1:
    N的关系将其与用户表关联起来。这意味着一个用户可以有多个评论。我们将通过在`comments`表中添加`user`表的主键作为外键来实现这一点。这将创建一个1:
    N的关系。'
- en: 'When we link two tables, we need to specify to the database engine what should
    be done if the parent row is deleted, which has many children in the other table.
    As we can see in the following diagram, we are asking what happens at the place
    of the question marks when we delete row1 of the user table:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将两个表进行关联时，我们需要指定数据库引擎在父表中的行被删除，且在另一表中存在许多子行时应该执行什么操作。正如我们可以在以下图中看到的那样，当我们删除用户表中的行1时，我们想知道问号所在位置会发生什么：
- en: '![](img/Image61944.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Image61944.jpg)'
- en: 'Figure 8.11: Illustration of relations'
  id: totrans-143
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.11：关系说明
- en: 'In a non-RDBMS situation, this situation can quickly become difficult and messy
    to manage and maintain. However, with an RDBMS, all we have to tell the database
    engine, in very precise ways, is what to do when a situation like this occurs.
    The database engine will do the rest for us. We use `ON` `DELETE` to tell the
    engine what we do with all the rows of a table when the parent row gets deleted.
    The following code illustrates these concepts:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在非RDBMS的情况下，这种情况可能会迅速变得难以管理和维护。然而，在使用RDBMS的情况下，我们只需要非常精确地告诉数据库引擎在这种情况下应该做什么。数据库引擎会为我们完成剩下的工作。我们使用`ON`
    `DELETE`来告诉引擎当父行被删除时，我们应该如何处理表中的所有行。以下代码说明了这些概念：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `ON` `DELETE` `CASCADE` line informs the database engine that we want to
    delete all the children rows when the parent gets deleted. We can also define
    actions for `UPDATE`. In this case, there is nothing to do on `UPDATE`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`ON` `DELETE` `CASCADE`行通知数据库引擎，当父行被删除时，我们希望删除所有子行。我们也可以为`UPDATE`定义操作。在这种情况下，对于`UPDATE`没有要执行的操作。'
- en: The `FOREIGN KEY` modifier modifies a column definition (`user_id`, in this
    case) and marks it as a foreign key, which is related to the primary key (`email`,
    in this case) of another table.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`FOREIGN KEY`修饰符修改一个列定义（在这种情况下为`user_id`），并将其标记为外键，它与另一个表的主键（在这种情况下为`email`）相关联。'
- en: You may notice the strange looking `cursor.execute("PRAGMA foreign_keys = 1")`
    line in the code. It is there just because SQLite does not use the normal foreign
    key features by default. It is this line that enables that feature. It is typical
    to SQLite and we won't need it for any other databases.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到代码中看起来奇怪的`cursor.execute("PRAGMA foreign_keys = 1")`行。它之所以存在，仅仅是因为SQLite默认不使用正常的键外键功能。正是这一行启用了该功能。这是SQLite的典型做法，我们不需要为任何其他数据库使用它。
- en: Adding Rows in the comments Table
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在`comments`表中添加行
- en: 'We have created a table called comments. In this section, we will dynamically
    generate an insert query, as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个名为`comments`的表。在本节中，我们将动态生成一个插入查询，如下所示：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Pay attention to how we dynamically generate the insert query so that we can
    insert 10 comments for each user.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何动态生成插入查询，以便我们可以为每个用户插入10条评论。
- en: Joins
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接
- en: In this exercise, we will learn how to exploit the relationship we just built.
    This means that if we have the primary key from one table, we can recover all
    the data needed from that table and also all the linked rows from the child table.
    To achieve this, we will use something called a **join**.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将学习如何利用我们刚刚建立的关系。这意味着如果我们有一个表的键，我们可以从该表恢复所需的所有数据，以及从子表中的所有关联行。为了实现这一点，我们将使用一个称为**连接**的东西。
- en: 'A join is basically a way to retrieve linked rows from two tables using any
    kind of primary key - foreign key relation that they have. There are many types
    of join, such as `INNER`, `LEFT OUTER`, `RIGHT OUTER`, `FULL OUTER`, and `CROSS`.
    They are used in different situations. However, most of the time, in simple 1:
    N relations, we end up using an `INNER` join. In *Chapter 1: Introduction to Data
    Wrangling with Python*, we learned about sets, then we can view an `INNER` `JOIN`
    as an intersection of two sets. The following diagram illustrate the concepts:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '连接基本上是一种使用任何类型的键-外键关系从两个表中检索相关行的方法。有许多类型的连接，如`INNER`、`LEFT OUTER`、`RIGHT OUTER`、`FULL
    OUTER`和`CROSS`。它们用于不同的场景。然而，在简单的1: N关系中，我们通常使用`INNER`连接。在*第1章：使用Python进行数据整理的介绍*中，我们学习了集合，然后我们可以将`INNER`连接视为两个集合的交集。以下图表说明了这些概念：'
- en: '![](img/Image61953.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image61953.jpg)'
- en: 'Figure 8.12: Intersection Join'
  id: totrans-157
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.12：交集连接
- en: Here, A represents one table and B represents another. The meaning of having
    common members is to have a relationship between them. It takes all of the rows
    of A and compares them with all of the rows of B to find the matching rows that
    satisfy the join predicate. This can quickly become a complex and time-consuming
    operation. Joins can be very expensive operations. Usually, we use some kind of
    `where` clause, after we specify the join, to shorten the scope of rows that are
    fetched from table A or B to perform the matching.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，A代表一个表，B代表另一个表。拥有共同成员的意义是它们之间存在关系。它将A的所有行与B的所有行进行比较，以找到满足连接谓词的匹配行。这可能会迅速变成一个复杂且耗时的操作。连接可以是昂贵的操作。通常，我们在指定连接后使用某种`WHERE`子句，以缩短从表A或B中检索的行的范围以执行匹配。
- en: 'In our case, our first table, `user`, has three entries, with the primary key
    being the `email`. We can make use of this in our query to get comments just from
    `Bob`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们的第一个表`user`有三个条目，主键是`email`。我们可以在查询中使用这一点来获取来自`Bob`的评论：
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output is as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Figure 8.13: Output of the Join query'
  id: totrans-163
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.13：连接查询的输出
- en: Retrieving Specific Columns from a JOIN query
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从JOIN查询中检索特定列
- en: In the previous exercise, we saw that we can use a JOIN to fetch the related
    rows from two tables. However, if we look at the results, we will see that it
    returned all the columns, thus combining both tables. This is not very concise.
    What about if we only want to see the emails and the related comments, and not
    all the data?
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们看到了我们可以使用连接来从两个表中检索相关行。然而，如果我们查看结果，我们会看到它返回了所有列，因此结合了两个表。这并不非常简洁。如果我们只想看到电子邮件和相关的评论，而不是所有数据呢？
- en: 'There is some nice shorthand code that lets us do this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些简洁的代码可以让我们做到这一点：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Just by changing the `SELECT` statement, we made our final result look as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 只需更改`SELECT`语句，我们就可以使最终结果看起来如下：
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Exercise 112: Deleting Rows'
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 112：删除行
- en: 'In this exercise, we are going to delete a row from the user table and observe
    the effects it will have on the `comments` table. Be very careful when running
    this command as it can have a destructive effect on the data. Please keep in mind
    that it has to almost always be run accompanied by a `WHERE` clause so that we
    delete just a part of the data and not everything:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将从用户表中删除一行，并观察它对`comments`表产生的影响。运行此命令时要非常小心，因为它可能会对数据产生破坏性影响。请记住，它几乎总是需要与`WHERE`子句一起运行，以便我们只删除部分数据而不是全部：
- en: 'To delete a row from a table, we use the `DELETE` clause in `SQL`. To run delete
    on the `user` table, we are going to use the following code:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从表中删除一行，我们使用`SQL`中的`DELETE`子句。要运行`user`表的删除操作，我们将使用以下代码：
- en: '[PRE25]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Perform the `SELECT` operation on the user table:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在用户表上执行`SELECT`操作：
- en: '[PRE26]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Observe that the user Bob has been deleted.
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 观察到用户Bob已被删除。
- en: Now, moving on to the `comments` table, we have to remember that we had mentioned
    `ON DELETE CASCADE` while creating the table. The database engine knows that if
    a row is deleted from the parent table (`user`), all the related rows from the
    child tables (`comments`) will have to be deleted.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，让我们转到`comments`表，我们必须记住我们在创建表时提到了`ON DELETE CASCADE`。数据库引擎知道，如果从父表（`user`）中删除一行，所有相关的子表（`comments`）中的行都必须被删除。
- en: 'Perform a select operation on the comments table by using the following command:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在评论表上执行选择操作：
- en: '[PRE27]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output is as follows:'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE28]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We can see that all of the rows related to Bob are deleted.
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以看到与Bob相关的所有行都被删除了。
- en: Updating Specific Values in a Table
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在表中更新特定值
- en: In this exercise, we will see how we can update rows in a table. We have already
    looked at this in the past but, as we mentioned, at a table level only. Without
    WHERE, updating is often a bad idea.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将看到如何更新表中的行。我们以前已经看过这个，但正如我们提到的，只是在表级别。没有WHERE子句，更新通常不是一个好主意。
- en: Combine UPDATE with WHERE to selectively update the first name of the user with
    the email address [`tom@web.com`](mailto:tom@web.com)`:`
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 将UPDATE与WHERE结合使用，以选择性地更新具有电子邮件地址`[tom@web.com](mailto:tom@web.com)`的用户的名字：`
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output is as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/Image61961.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image61961.jpg)'
- en: 'Figure 8.14: Output of the update query'
  id: totrans-189
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.14：更新查询的输出
- en: 'Exercise 113: RDBMS and DataFrames'
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习113：关系数据库管理系统和DataFrame
- en: 'We have looked into many fundamental aspects of storing and querying data from
    a database, but as a data wrangling expert, we need our data to be packed and
    presented as a DataFrame so that we can perform quick and convenient operations
    on them:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了从数据库存储和查询数据的许多基本方面，但作为一个数据整理专家，我们需要我们的数据打包并呈现为DataFrame，这样我们就可以快速方便地对它们进行操作：
- en: 'Import `pandas` using the following code:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码导入`pandas`：
- en: '[PRE30]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create a columns list with `email`, `first name`, `last name`, `age`, `gender`,
    and `comments` as column names. Also, create an empty data list:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含`email`、`first name`、`last name`、`age`、`gender`和`comments`作为列名的列列表。同时创建一个空的数据列表：
- en: '[PRE31]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Connect to `chapter.db` using `SQLite` and obtain a cursor, as follows:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`SQLite`连接到`chapter.db`并获取游标，如下所示：
- en: '[PRE32]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create a `sql` variable that will contain the `SELECT` command and use the
    `join` command to join the databases:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含`SELECT`命令的`sql`变量，并使用`join`命令连接数据库：
- en: '[PRE33]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Use the `execute` method of cursor to execute the `sql` command:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用游标的`execute`方法执行`sql`命令：
- en: '[PRE34]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Append the rows to the data list:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将行追加到数据列表中：
- en: '[PRE35]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Create a DataFrame using the data list:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用数据列表创建DataFrame：
- en: '[PRE36]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We have created the DataFrame using the data list. You can print the values
    into the DataFrame using `df.head`.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经使用数据列表创建了DataFrame。您可以使用`df.head`将值打印到DataFrame中。
- en: 'Activity 11: Retrieving Data Correctly From Databases'
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动11：正确从数据库检索数据
- en: 'In this activity, we have the persons table:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们有人员表：
- en: '![](img/Image61971.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image61971.jpg)'
- en: 'Figure 8.15: The persons table'
  id: totrans-210
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.15：人员表
- en: 'We have the pets table:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有宠物表：
- en: '![](img/Image61987.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image61987.jpg)'
- en: 'Figure 8.16: The pets table'
  id: totrans-213
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.16：宠物表
- en: As we can see, the `id` column in the persons table (which is an integer) serves
    as the primary key for that table and as a foreign key for the pet table, which
    is linked via the `owner_id` column.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，人员表中的`id`列（它是一个整数）是该表的主键，也是宠物表的外键，通过`owner_id`列进行链接。
- en: 'The persons table has the following columns:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 人员表有以下列：
- en: '`first_name`: The first name of the person'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`first_name`: 人员的名字'
- en: '`last_name`: The last name of the person (can be "null")'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`last_name`: 人员的姓氏（可以是“null”）'
- en: '`age`: The age of the person'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`age`: 人员的年龄'
- en: '`city`: The city from where he/she is from'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`city`: 他/她来自的城市'
- en: '`zip_code`: The zip code of the city'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zip_code`: 城市的邮政编码'
- en: 'The pets table has the following columns:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 宠物表有以下列：
- en: '`pet_name`: The name of the pet.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pet_name`: 宠物的名字。'
- en: '`pet_type`: What type of pet it is, for example, cat, dog, and so on. Due to
    a lack of further information, we do not know which number represents what, but
    it is an integer and can be null.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pet_type`: 宠物的类型，例如，猫、狗等。由于缺乏更多信息，我们不知道哪个数字代表什么，但它是一个整数，可以是空值。'
- en: '`treatment_done`: It is also an integer column, and 0 here represents "No",
    whereas 1 represents "Yes".'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`treatment_done`: 它也是一个整数列，这里的0代表“否”，而1代表“是”。'
- en: The name of the SQLite DB is `petsdb` and it is supplied along with the Activity
    notebook.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite数据库的名称是`petsdb`，它随活动笔记本一起提供。
- en: 'These steps will help you complete this activity:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将帮助您完成此活动：
- en: Connect to `petsDB` and check whether the connection has been successful.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到`petsDB`并检查连接是否成功。
- en: Find the different age groups in the persons database.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找人员数据库中的不同年龄段。
- en: Find the age group that has the maximum number of people.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找人数最多的年龄段。
- en: Find the people who do not have a last name.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出没有姓氏的人。
- en: Find out how many people have more than one pet.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询有多少人拥有不止一只宠物。
- en: Find out how many pets have received treatment.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询已接受治疗的宠物数量。
- en: Find out how many pets have received treatment and the type of pet is known.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询已接受治疗且已知宠物类型的宠物数量。
- en: Find out how many pets are from the city called `east port`.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询有多少宠物来自名为`east port`的城市。
- en: Find out how many pets are from the city called `east port` and who received
    a treatment.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询有多少宠物来自名为`east port`的城市，并且接受了治疗。
- en: Note
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 324.
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第324页找到。
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: We have come to the end of the database chapter. We have learned how to connect
    to SQLite using Python. We have brushed up on the basics of relational databases
    and learned how to open and close a database. We then learned how to export this
    relational database into Python DataFrames.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了数据库章节的结尾。我们学习了如何使用Python连接到SQLite数据库。我们复习了关系型数据库的基础知识，并学习了如何打开和关闭数据库。然后我们学习了如何将这个关系型数据库导出到Python的DataFrames中。
- en: In the next chapter, we will be performing data wrangling on real-world datasets.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将对现实世界的数据集进行数据整理。
