- en: '*Chapter 8*'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RDBMS and SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Apply the basics of RDBMS to query databases using Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convert data from SQL into a pandas DataFrame
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter explains the concepts of databases, including their creation, manipulation
    and control, and transforming tables into pandas DataFrames.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter of our data journey is focused on **RDBMS** (Relational Database
    Management Systems) and **SQL** (Structured Query Language). In the previous chapter,
    we stored and read data from a file. In this chapter, we will read structured
    data, design access to the data, and create query interfaces for databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data has been stored in RDBMS format for years. The reasons behind it are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: RDBMS is one of the safest ways to store, manage, and retrieve data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are backed by a solid mathematical foundation (relational algebra and calculus)
    and they expose an efficient and intuitive declarative language – SQL – for easy
    interaction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Almost every language has a rich set of libraries to interact with different
    RDBMS and the tricks and methods of using them are well tested and well understood.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling an RDBMS is a pretty well-understood task and there are a bunch of well
    trained, experienced professionals to do this job (DBA or database administrator).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we can see in the following chart, the market of DBMS is big. This chart
    was produced based on market research that was done by **Gartner, Inc.** in **2016**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 Commercial database market share in 2016](img/C11065_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 Commercial database market share in 2016
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We will learn and play around with some basic and fundamental concepts of database
    and database management systems in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Refresher of RDBMS and SQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An RDBMS is a piece of software that manages data (represented for the end user
    in a tabular form) on physical hard disks and is built using the Codd's relational
    model. Most of the databases that we encounter today are RDBMS. In recent years,
    there has been a huge industry shift toward a newer kind of database management
    system, called **NoSQL** (**MongoDB**, **CouchDB**, **Riak**, and so on). These
    systems, although in some aspects they follow some of the rules of RDBMS, in most
    cases reject or modify them.
  prefs: []
  type: TYPE_NORMAL
- en: How is an RDBMS Structured?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The RDBMS structure consists of three main elements, namely the storage engine,
    query engine, and log management. Here is a diagram that shows the structure of
    a RDBMS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 RDBMS structure](img/C11065_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 RDBMS structure
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The following are the main concepts of any RDBMS structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Storage engine**: This is the part of the RDBMS that is responsible for storing
    the data in an efficient way and also to give it back when asked for, in an efficient
    way. As an end user of the RDBMS system (an application developer is considered
    an end user of an RDBMS), we will never need to interact with this layer directly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Query engine**: This is the part of the RDBMS that allows us to create data
    objects (tables, views, and so on), manipulate them (create and delete columns,
    create/delete/update rows, and so on), and query them (read rows) using a simple
    yet powerful language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log management**: This part of the RDBMS is responsible for creating and
    maintaining the logs. If you are wondering why the log is such an important thing,
    then you should look into how replication and partitions are handled in a modern
    RDBMS (such as PostgreSQL) using something called **Write Ahead Log** (or WAL
    for short).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will focus on the query engine in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: SQL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**S**tructured **Q**uery **L**anguage or **SQL** (pronounced sequel), as it
    is commonly known, is a domain-specific language that was originally designed
    based on E.F. Codd''s relational model and is widely used in today''s databases
    to define, insert, manipulate, and retrieve data from them. It can be further
    sub-divided into four smaller sub-languages, namely **DDL** (Data Definition Language),
    **DML** (Data Manipulation Language), **DQL** (Data Query Language), and **DCL**
    (Data Control Language). There are several advantages of using SQL, with some
    of them being as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It is based on a solid mathematical framework and thus it is easy to understand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a declarative language, which means that we actually never tell it how
    to do its job. We almost always tell it what to do. This frees us from a big burden
    of writing custom code for data management. We can be more focused on the actual
    query problem we are trying to solve instead of bothering about how to create
    and maintain a data store.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It gives you a fast and readable way to deal with data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL gives you out-of-the-box ways to get multiple pieces of data with a single
    query.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main areas of focus for the following topic will be DDL, DML, and DQL. The
    DCL part is more for database administrators.
  prefs: []
  type: TYPE_NORMAL
- en: '`CREATE` `TABLE` or `DROP` `TABLE` or `ALTER` `TABLE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the use of uppercase letters. It is not a specification and you can use
    lowercase letters, but it is a widely followed convention and we will use that
    in this book.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`INSERT` `INTO`, `DELETE` `FROM`, or `UPDATE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SELECT` command. We will also see and use the concepts of the primary key,
    foreign key, index, joins, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you define and insert data in a database, it can be represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 Table displaying sample data](img/C11065_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 Table displaying sample data
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Another thing to remember about RDBMS is relations. Generally, in a table, we
    have one or more columns that will have unique values for each row in the table.
    We call them **primary keys** for the table. We should be aware that we will encounter
    unique values across the rows, which are not primary keys. The main difference
    between them and primary keys is the fact that a primary key cannot be null.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using the primary key of one table and mentioning it as a foreign key in
    another table, we can establish relations between two tables. A certain table
    can be related to any finite number of tables. The relations can be 1:1, which
    means that each row of the second table is uniquely related to one row of the
    first table, or 1 :N, N:1, or N: M. An example of relations is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 Diagram showing relations](img/C11065_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 Diagram showing relations
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: With this brief refresher, we are now ready to jump into hands-on exercises
    and write some SQL to store and retrieve data.
  prefs: []
  type: TYPE_NORMAL
- en: Using an RDBMS (MySQL/PostgreSQL/SQLite)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this topic, we will focus on how to write some basic SQL commands, as well
    as how to connect to a database from Python and use it effectively within Python.
    The database we will choose here is SQLite. There are other databases, such as
    `Oracle`, `MySQL`, `Postgresql`, and `DB2`. The main tricks that you are going
    to learn here will not change based on what database you are using. But for different
    databases, you will need to install different third-party Python libraries (such
    as `Psycopg2` for `Postgresql`, and so on). The reason they all behave the same
    way (apart for some small details) is the fact that they all adhere to `PEP249`
    (commonly known as Python DB API 2).
  prefs: []
  type: TYPE_NORMAL
- en: This is a good standardization and saves us a lot of headaches while porting
    from one RDBMS to another.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most of the industry standard projects which are written in Python and use some
    kind of RDBMS as the data store, most often relay on an ORM or Object Relational
    Mapper. An ORM is a high-level library in Python which makes many tasks, while
    dealing with RDBMS, easier. It also exposes a more Pythonic API than writing raw
    SQL inside Python code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 107: Connecting to Database in SQLite'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will look into the first step toward using a RDBMS in
    Python code. All we are going to do is connect to a database and then close the
    connection. We will also learn about the best way to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `sqlite3` library of Python by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `connect` function to connect to a database. If you already have some
    experience with databases, then you will notice that we are not using any `server
    address`, `user name`, `password`, or other credentials to connect to a database.
    This is because these fields are not mandatory in `sqlite3,` unlike in `Postgresql`
    or `MySQL`. The main database engine of SQLite is embedded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the connection, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This `conn` object is the main connection object, and we will need that to get
    a second type of object in the future once we want to interact with the database.
    We need to be careful about closing any open connection to our database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use the same `with` statement from Python, just like we did for files, and
    connect to the database, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this exercise, we have connected to a database using Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 108: DDL and DML Commands in SQLite'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this exercise, we will look at how we can create a table, and we will also
    insert data in it.
  prefs: []
  type: TYPE_NORMAL
- en: As the name suggests, DDL (Data Definition Language) is the way to communicate
    to the database engine in advance to define what the data will look like. The
    database engine creates a table object based on the definition provided and prepares
    it.
  prefs: []
  type: TYPE_NORMAL
- en: To create a table in SQL, use the `CREATE` `TABLE` SQL clause. This will need
    the table name and the table definition. Table name is a unique identifier for
    the database engine to find and use the table for all future transactions. It
    can be anything (any alphanumeric string), as long as it is unique. We add the
    table definition in the form of (column_name_1 data_type, column_name_2 data type,
    … ). For our purpose, we will use the `text` and `integer` datatypes, but usually
    a standard database engine supports many more datatypes, such as float, double,
    date time, Boolean, and so on. We will also need to specify a primary key. A primary
    key is a unique, non-null identifier that's used to uniquely identify a row in
    a table. In our case, we use email as a primary key. A primary key can be an integer
    or text.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing you need to know is that unless you call a `commit` on the series
    of operations you just performed (together, we formally call them a `transaction`),
    nothing will be actually performed and reflected in the database. This property
    is called **atomicity**. In fact, for a database to be industry standard (to be
    useable in real life), it needs to follow the ACID (Atomicity, Consistency, Isolation,
    Durability) properties:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use SQLite''s `connect` function to connect to the `chapter.db` database, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: This code will work once you add the snippet from step 3.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a cursor object by calling `conn.cursor()`. The cursor object acts as
    a medium to communicate with the database. Create a table in Python, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Insert rows into the database that you created, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Commit to the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will create the table and write two rows to it with data.
  prefs: []
  type: TYPE_NORMAL
- en: Reading Data from a Database in SQLite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the preceding exercise, we created a table and stored data in it. Now, we
    will learn how to read the data that's stored in this database.
  prefs: []
  type: TYPE_NORMAL
- en: The `SELECT` clause is immensely powerful, and it is really important for a
    data practitioner to master `SELECT` and everything related to it (such as conditions,
    joins, group-by, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: The *** after `SELECT` tells the engine to select all of the columns from the
    table. It is a useful shorthand. We have not mentioned any condition for the selection
    (such as above a certain age, first name starting with a certain sequence of letters,
    and so on). We are practically telling the database engine to select all the rows
    and all the columns from the table. It is time-consuming and less effective if
    we have a huge table. Hence, we would want to use the `LIMIT` clause to limit
    the number of rows we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `SELECT` clause in SQL to retrieve data, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image61892.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.5: Output of the SELECT clause'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The syntax to use the `SELECT` clause with a `LIMIT` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This syntax is a sample code and will not work on Jupyter notebook.
  prefs: []
  type: TYPE_NORMAL
- en: This will select all the columns, but only the first 50 rows from the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 109: Sorting Values that are Present in the Database'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will use the `ORDER BY` clause to sort the rows of user
    table with respect to age:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sort the `chapter.db` by `age` in descending order, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/Image61902.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 8.6: Output of data displaying age in descending order'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Sort the `chapter.db` by `age` in ascending order, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Image61910.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.7: Output of data displaying age in ascending order'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice that we don't need to specify the order as `ASC` to sort it into ascending
    order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 110: Altering the Structure of a Table and Updating the New Fields'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this exercise, we are going to add a column using `ALTER` and `UPDATE` the
    values in the newly added column.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `UPDATE` command is used to edit/update any row after it has been inserted.
    Be careful when using it because using `UPDATE` without selective clauses (such
    as `WHERE`) affects the entire table:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Establish the connection with the database by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add another column in the `user` table and fill it with `null` values by using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update all of the values of `gender` so that they are `M` by using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To check the altered table, execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![](img/Image61918.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.8: Output after altering the table'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We have updated the entire table by setting the gender of all the users as `M`,
    where `M` stands for male.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 111: Grouping Values in Tables'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this exercise, we will learn about a concept that we have already learned
    about in pandas. This is the `GROUP` `BY` clause. The `GROUP` `BY` clause is a
    technique that's used to retrieve distinct values from the database and place
    them in individual buckets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram explains how the GROUP BY clause works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image61926.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.9: Illustration of the GROUP BY clause on a table'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding diagram, we can see that the `Col3` column has only two unique
    values across all rows, A and B.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command that''s used to check the total number of rows belonging to each
    group is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Add female users to the table and group them based on the gender:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a female user to the table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following code to see the count by each gender:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/Image61935.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.10: Output of the GROUP BY clause'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Relation Mapping in Databases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have been working with a single table and altering it, as well as reading
    back the data. However, the real power of an RDBMS comes from the handling of
    relationships among different objects (tables). In this section, we are going
    to create a new table called `comments` and link it with the user table in a 1:
    N relationship. This means that one user can have multiple comments. The way we
    are going to do this is by adding the `user` table''s primary key as a foreign
    key in the `comments` table. This will create a 1: N relationship.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we link two tables, we need to specify to the database engine what should
    be done if the parent row is deleted, which has many children in the other table.
    As we can see in the following diagram, we are asking what happens at the place
    of the question marks when we delete row1 of the user table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image61944.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.11: Illustration of relations'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In a non-RDBMS situation, this situation can quickly become difficult and messy
    to manage and maintain. However, with an RDBMS, all we have to tell the database
    engine, in very precise ways, is what to do when a situation like this occurs.
    The database engine will do the rest for us. We use `ON` `DELETE` to tell the
    engine what we do with all the rows of a table when the parent row gets deleted.
    The following code illustrates these concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `ON` `DELETE` `CASCADE` line informs the database engine that we want to
    delete all the children rows when the parent gets deleted. We can also define
    actions for `UPDATE`. In this case, there is nothing to do on `UPDATE`.
  prefs: []
  type: TYPE_NORMAL
- en: The `FOREIGN KEY` modifier modifies a column definition (`user_id`, in this
    case) and marks it as a foreign key, which is related to the primary key (`email`,
    in this case) of another table.
  prefs: []
  type: TYPE_NORMAL
- en: You may notice the strange looking `cursor.execute("PRAGMA foreign_keys = 1")`
    line in the code. It is there just because SQLite does not use the normal foreign
    key features by default. It is this line that enables that feature. It is typical
    to SQLite and we won't need it for any other databases.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Rows in the comments Table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have created a table called comments. In this section, we will dynamically
    generate an insert query, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Pay attention to how we dynamically generate the insert query so that we can
    insert 10 comments for each user.
  prefs: []
  type: TYPE_NORMAL
- en: Joins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this exercise, we will learn how to exploit the relationship we just built.
    This means that if we have the primary key from one table, we can recover all
    the data needed from that table and also all the linked rows from the child table.
    To achieve this, we will use something called a **join**.
  prefs: []
  type: TYPE_NORMAL
- en: 'A join is basically a way to retrieve linked rows from two tables using any
    kind of primary key - foreign key relation that they have. There are many types
    of join, such as `INNER`, `LEFT OUTER`, `RIGHT OUTER`, `FULL OUTER`, and `CROSS`.
    They are used in different situations. However, most of the time, in simple 1:
    N relations, we end up using an `INNER` join. In *Chapter 1: Introduction to Data
    Wrangling with Python*, we learned about sets, then we can view an `INNER` `JOIN`
    as an intersection of two sets. The following diagram illustrate the concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image61953.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.12: Intersection Join'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Here, A represents one table and B represents another. The meaning of having
    common members is to have a relationship between them. It takes all of the rows
    of A and compares them with all of the rows of B to find the matching rows that
    satisfy the join predicate. This can quickly become a complex and time-consuming
    operation. Joins can be very expensive operations. Usually, we use some kind of
    `where` clause, after we specify the join, to shorten the scope of rows that are
    fetched from table A or B to perform the matching.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, our first table, `user`, has three entries, with the primary key
    being the `email`. We can make use of this in our query to get comments just from
    `Bob`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Figure 8.13: Output of the Join query'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Retrieving Specific Columns from a JOIN query
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous exercise, we saw that we can use a JOIN to fetch the related
    rows from two tables. However, if we look at the results, we will see that it
    returned all the columns, thus combining both tables. This is not very concise.
    What about if we only want to see the emails and the related comments, and not
    all the data?
  prefs: []
  type: TYPE_NORMAL
- en: 'There is some nice shorthand code that lets us do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Just by changing the `SELECT` statement, we made our final result look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 112: Deleting Rows'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we are going to delete a row from the user table and observe
    the effects it will have on the `comments` table. Be very careful when running
    this command as it can have a destructive effect on the data. Please keep in mind
    that it has to almost always be run accompanied by a `WHERE` clause so that we
    delete just a part of the data and not everything:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To delete a row from a table, we use the `DELETE` clause in `SQL`. To run delete
    on the `user` table, we are going to use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Perform the `SELECT` operation on the user table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Observe that the user Bob has been deleted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, moving on to the `comments` table, we have to remember that we had mentioned
    `ON DELETE CASCADE` while creating the table. The database engine knows that if
    a row is deleted from the parent table (`user`), all the related rows from the
    child tables (`comments`) will have to be deleted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Perform a select operation on the comments table by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can see that all of the rows related to Bob are deleted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Updating Specific Values in a Table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this exercise, we will see how we can update rows in a table. We have already
    looked at this in the past but, as we mentioned, at a table level only. Without
    WHERE, updating is often a bad idea.
  prefs: []
  type: TYPE_NORMAL
- en: Combine UPDATE with WHERE to selectively update the first name of the user with
    the email address [`tom@web.com`](mailto:tom@web.com)`:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image61961.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.14: Output of the update query'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Exercise 113: RDBMS and DataFrames'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have looked into many fundamental aspects of storing and querying data from
    a database, but as a data wrangling expert, we need our data to be packed and
    presented as a DataFrame so that we can perform quick and convenient operations
    on them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import `pandas` using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a columns list with `email`, `first name`, `last name`, `age`, `gender`,
    and `comments` as column names. Also, create an empty data list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Connect to `chapter.db` using `SQLite` and obtain a cursor, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `sql` variable that will contain the `SELECT` command and use the
    `join` command to join the databases:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `execute` method of cursor to execute the `sql` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Append the rows to the data list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a DataFrame using the data list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have created the DataFrame using the data list. You can print the values
    into the DataFrame using `df.head`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Activity 11: Retrieving Data Correctly From Databases'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this activity, we have the persons table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image61971.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.15: The persons table'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We have the pets table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image61987.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.16: The pets table'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As we can see, the `id` column in the persons table (which is an integer) serves
    as the primary key for that table and as a foreign key for the pet table, which
    is linked via the `owner_id` column.
  prefs: []
  type: TYPE_NORMAL
- en: 'The persons table has the following columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '`first_name`: The first name of the person'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`last_name`: The last name of the person (can be "null")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`age`: The age of the person'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`city`: The city from where he/she is from'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zip_code`: The zip code of the city'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The pets table has the following columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pet_name`: The name of the pet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pet_type`: What type of pet it is, for example, cat, dog, and so on. Due to
    a lack of further information, we do not know which number represents what, but
    it is an integer and can be null.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`treatment_done`: It is also an integer column, and 0 here represents "No",
    whereas 1 represents "Yes".'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the SQLite DB is `petsdb` and it is supplied along with the Activity
    notebook.
  prefs: []
  type: TYPE_NORMAL
- en: 'These steps will help you complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect to `petsDB` and check whether the connection has been successful.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the different age groups in the persons database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the age group that has the maximum number of people.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the people who do not have a last name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find out how many people have more than one pet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find out how many pets have received treatment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find out how many pets have received treatment and the type of pet is known.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find out how many pets are from the city called `east port`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find out how many pets are from the city called `east port` and who received
    a treatment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 324.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have come to the end of the database chapter. We have learned how to connect
    to SQLite using Python. We have brushed up on the basics of relational databases
    and learned how to open and close a database. We then learned how to export this
    relational database into Python DataFrames.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be performing data wrangling on real-world datasets.
  prefs: []
  type: TYPE_NORMAL
