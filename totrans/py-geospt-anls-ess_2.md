# 第二章 地理空间数据

在本章中，我们将重点关注用于地理空间分析的数据。你将了解更多关于地理空间数据性质的知识，并发现一些你可以免费获取地理空间数据集的主要网站。然后我们将探讨使用 Python 读取和写入地理空间数据的方法。

尤其是本章将涵盖以下主题：

+   为什么高质量的地理空间数据很重要

+   你可能会遇到的地理空间数据的各种类型

+   可免费获取的地理空间数据集的主要来源

+   如何使用 GDAL/OGR 库读取和写入地理空间数据

+   如何处理空间参考系统

+   地理空间数据错误及其修复方法

让我们先看看为什么拥有高质量的地理空间数据很重要。

# 地理空间数据质量

想象一下，你正在编写一个程序，需要将每个城市和镇的位置显示在栅格底图上。你尽职尽责地获取了一个用于底图的优秀栅格数据源，然后在网上搜索城市和镇数据的来源。你选择了**国家地理空间情报服务**（**NGIS**）网站下载地名数据库，然后将其绘制到你的地图上。该数据库包括许多其他信息，例如每个地名的纬度和经度：

| 位置 | 纬度 | 经度 |
| --- | --- | --- |
| Abache | 7.3551 | 7.6407 |
| Abacheke | 5.50372 | 6.729519 |
| Abacher | 13.816667 | 20.816667 |
| Abacheri | 14.183333 | 41.5 |
| Abachi | 7.3551 | 7.6407 |
| ...等等 |   |   |

到目前为止一切顺利，但当你完成程序后，当用户放大你的地图时，位置看起来可疑地规则：

![地理空间数据质量](img/B04102_02_01.jpg)

如果你在地图上绘制一个网格，你可以清楚地看到问题所在：

![地理空间数据质量](img/B04102_02_02.jpg)

如你所见，位置是均匀分布的——尽管纬度和经度值有很多精度，但实际上它们只精确到大约两位小数。在显示荷兰部分地区的前一个图像中，这可能会导致位置偏差近一公里。

这只是如果你不使用高质量的地理空间数据可能会出错的一种类型的事例。另一个例子通常出现在执行**点在多边形内**计算时——即，在尝试确定一个给定点是在给定多边形内部还是外部时：

![地理空间数据质量](img/B04102_02_03.jpg)

如果多边形代表的是，例如，一个国家的轮廓，那么你可以使用点在多边形内计算来确定给定位置是否在国家的边界内。这通常用于**地理定位**一个给定的点（即，将一个点与一个或多个已知位置匹配）。

现在，当你尝试定位接近多边形边缘的点时，如果你的多边形不够详细，你很容易出现地理定位错误：

![地理空间数据质量](img/B04102_02_04.jpg)

在前面的图像中，点代表一个需要地理定位的点。这个点在旧金山是一个有效的位置，但由于 polygon 不够详细，这个点位于旧金山市 polygon 之外，因此地理定位失败。

当使用覆盖较大区域的 polygon，如州或国家轮廓时，这个问题尤为严重。由于这些情况中 polygon 的大小，精度通常会被牺牲。

你可能会认为这个问题的答案是拥有更详细的 polygon——也就是说，使用更多的点来构成 polygon 的轮廓，以便更准确地表示所需的轮廓（在这种情况下，旧金山海岸线）。然而，更多的细节并不总是更好的。一个 polygon 越详细，处理它所需的时间就越长——如果点太多，你的程序可能会因为处理过多的数据而崩溃。

解决这个问题有方法；例如，可以通过将大型多边形分割成更小的部分，或者通过**缓冲区**多边形以包括靠近边缘的点。但重要的是要认识到，高质量的数据并不总是意味着高精度数据；它意味着数据对于你想要使用的目的来说是*合适的*。

我们现在将继续通过查看你可能会遇到的多种地理空间数据类型来继续我们对地理空间概念的探索。

# 地理空间数据类型

在前一章中，我们简要地查看了一些用于存储和传输栅格和矢量地理空间数据的常见格式。现在，让我们看看你可能会遇到的一些重要的地理空间数据类型。

## Shapefiles

如前一章所述，shapefile 是磁盘上的一组文件集合，这些文件一起存储了一组地理空间特征及其属性和几何形状。例如，以下插图显示了典型 shapefile 中存储的数据：

![Shapefiles](img/B04102_02_05.jpg)

由于 shapefile 格式已经存在多年，并且可以追溯到 dBase 时代，一个 shapefile 由几个单独的文件组成。通常，这些文件被组合成一个 ZIP 存档以进行分发。

Shapefiles 之所以非常受欢迎，是因为它们使得存储和分发地理空间数据变得非常容易。实际上，几乎所有处理地理空间数据的 GIS 系统和库都能够理解 shapefile 格式。

然而，shapefiles 确实有一些缺点：

+   与几乎所有的其他地理空间数据格式不同，shapefile 中属性的名称是区分大小写的。当你的代码在另一种格式（例如，在数据库中）中处理数据时，这可能会引起问题，但当你尝试访问 shapefile 中的属性时，代码突然停止。

+   单个 shapefile 中存储的所有几何形状必须是同一类型。这意味着，例如，您不能有些特征由线表示，而其他特征由点表示。更严重的是，当处理复合几何形状（如 MultiLines 或 MultiPolygons）或尝试在 shapefile 中存储几何集合时，这会导致问题。

+   虽然 shapefiles 允许您按顺序读取特征，但通常没有空间索引支持。这意味着您不能根据地球表面上特征的位置进行搜索。例如，回答“哪些国家在伦敦 1,000 公里范围内？”这样的问题，您需要逐个检查每个特征，这并不特别高效。

## 已知文本

**知名文本**（**WKT**）格式通常不用于存储地理空间数据。相反，它用于将几何形状从一个格式传输到另一个格式。我们在上一章中看到了一个例子，我们使用 OGR 库提取了一个几何形状，然后将其转换为 WKT，以便我们可以将其重新创建为一个 Shapely 几何对象。

WKT 是一种非常紧凑且易于使用的格式。例如，以下 WKT 字符串定义了纽约市中央公园中间的一个点几何形状：

```py
POINT(-73.967344 40.782148)
```

如您所见，点被表示为一个*x*（经度）值，一个空格，然后是*y*（纬度）值。相同的通用格式用于表示多边形的坐标。例如，以下是一个 WKT 格式的多边形，这次定义了中央公园的大致轮廓：

```py
POLYGON((-73.973057 40.764356, -73.981898 40.768094, -73.958209 40.800621, -73.949282 40.796853, -73.973057 40.764356))
```

除了使用 WKT 在不同系统和库之间传输数据外，当您需要快速将几何形状硬编码到 Python 代码中时，您也会发现 WKT 字符串很有用。例如，以下代码展示了如何快速创建一个 Shapely 多边形进行测试：

```py
p = shapely.wkt.loads("POLYGON((23.4 38.9, 23.5 38.9, 23.5 38.8, 23.4 38.9))")
```

如果您想将几何数据存储在文本文件中，例如将分析输出临时保存到磁盘上以便将其加载到另一个程序进行进一步处理，WKT 格式也非常有用。

## 已知二进制

**知名的二进制**（**WKB**）格式是 WKT 的二进制等价物。WKB 通常仅用于在数据库内部传输和存储地理空间数据。在 WKB 格式中，坐标以双精度浮点数存储，并使用数字代码来表示几何类型。与 WKT 相比，这种格式对计算机的读写速度更快，尽管当然这种格式对人类来说不容易理解。

## 空间数据库

正如普通数据库用于存储大量数据并允许用户对数据进行高效查询一样，**空间数据库**是一种设计用于存储几何形状并根据每个几何形状在空间中的位置执行高效查询的数据库。例如，您可以快速找到在给定点 20 英里范围内的所有道路交通事故，或者找到您当前位置最近的岛屿。

![空间数据库](img/B04102_02_06.jpg)

设置和使用空间数据库是一项相当复杂的任务。有几种不同类型的空间数据库可供选择。在免费选项中，轻量级的 **SpatiaLite** 数据库和功能强大但复杂的 **PostGIS** 数据库是最受欢迎的选择。

创建数据库后，您必须配置数据库以处理空间数据。您还需要使用数据库自己的语法来存储和查询您的空间数据——您如何做这取决于您使用哪种数据库。

无论您使用哪种类型的数据库，尝试检索空间几何体通常将返回 WKT 格式的字符串或 WKB 格式的原始二进制数据。然后您可以将这些转换为不同的格式（例如，Shapely 几何对象）进行处理。

当然，在空间数据库中可用的强大功能，尤其是 PostGIS 中内置的空间操作和查询功能，您可能不需要在数据库本身之外进行任何空间分析。例如，一旦您要求数据库识别给定半径内的所有道路交通事故，您通常会检索这些事故的非空间信息。所有的空间处理都是在数据库内部完成的，一旦您找到了所需的记录集，您就可以像在非空间数据库中一样检索和处理结果。

我们将在 第三章 *空间数据库* 中回到空间数据库的主题。

## 地理空间微格式

所说的 **地理空间微格式**通常由 API 用于发送和接收地理空间数据。各种公司和组织已经定义了自己的标准来传输地理空间数据，因此随着时间的推移，已经开发出多种常见格式。如果您使用使用这些微格式之一的 API，您需要熟悉这些数据格式。

我们在这里将探讨两种地理空间微格式：**GeoJSON** 和 **GML**。

### GeoJSON

GeoJSON ([`geojson.org`](http://geojson.org)) 是一种开放标准，用于将地理空间数据结构表示为 **JavaScript 对象表示法**（**JSON**）对象。例如，以下 GeoJSON 格式的字符串用于表示一个点几何体：

```py
{"type": "Point", "coordinates": [-73.967344, 40.782148]}
```

由于 GeoJSON 建立在 JSON 标准之上，因此你可以使用`json`标准 Python 库在 GeoJSON 格式字符串和 Python 字典之间进行转换。这使得在 Python 程序中使用 GeoJSON 变得特别容易。

GeoJSON 标准包括对以下内容的支持：

+   将任何标准几何对象（点、LineString、Polygon、MultiPoint、MultiLineString、MultiPolygon 和 GeometryCollection）表示为 GeoJSON 字符串。

+   将一个特征作为 GeoJSON 字符串存储，包括特征的几何形状、任意数量的属性（在 GeoJSON 中称为**属性**）以及可选的空间参考系统。

+   使用现有的 XML 模式和处理工具。因为 GML 格式基于 XML，所以可以使用现有的 XML 解析器和验证器处理 GML 数据。你还可以创建一个特定于应用程序的 XML 模式，定义你对 GML 标准的扩展，然后使用现有的 XML 库与该模式一起工作。

GeoJSON 格式被处理地理空间数据的软件广泛支持。实际上，GDAL/OGR 库包括对读取和写入 GeoJSON 格式数据的支持，同样，我们稍后将要使用的 Mapnik 库也支持。

### GML

**地理标记语言**（**GML**）是一种基于 XML 的格式，用于以文本形式存储几何和特征。GML 是一个复杂且精细的标准。因为它基于 XML，所以 GML 格式的数据往往相当冗长。例如，以下 GML 字符串表示一个最小的点几何：

```py
<gml:Point>
    <gml:pos>40.782148 -73.967344</gml:pos>
</gml:Point>
```

GML 包括以下支持：

+   表示点、LineString 和多边形几何。

    ### 注意

    GML 标准的 3.0 版本增加了对栅格格式数据的支持。

+   定义特征，并为每个特征存储属性。

+   将多个几何与每个特征关联；例如，一个特征可能有一个轮廓、一个边界框和一个质心，所有这些都定义为与特征关联的几何。

+   定义几何所使用的空间参考系统。

+   允许你为特定数据集使用 GML 标准子集的配置文件；例如，GML 简单特征配置文件将数据限制在表示几何及其相关属性。

+   由于 GML 格式基于 XML，因此可以使用现有的 XML 模式和处理工具；例如，你可以定义一个特定于应用程序的 XML 模式，定义你对 GML 标准的扩展，然后使用 XML 解析器和验证器处理你的 GML 数据。

GML 标准是由**开放地理空间联盟**（**OGC**）开发的，现在已被接受为 ISO 标准。GML 被 OGC 定义的各个网络标准广泛使用，并且当你想要访问遵循这些标准之一的 API 时，你将使用 GML，例如 Web 特征服务。

## 数字高程模型

**数字高程模型**（**DEM**）是一种以栅格格式数据表示地球表面曲线和等高线的迷人方式。正如我们在上一章中提到的，栅格格式的地理空间数据将世界划分为**单元格**，并将信息与每个单元格关联。在 DEM 中，每个单元格包含关于该点地球表面高度的信息。例如，考虑以下来自典型 DEM 文件的高程数据：

```py
2874  2871  2874  2933  2995  3022  3028  3031  3035  3031
2874  2871  2874  2933  2992  3012  3025  3028  3031  3028
2871  2871  2877  2932  2989  3007  3018  3025  3023  3020
2872  2871  2886  2935  2975  2997  3010  3020  3022  3023
2871  2879  2903  2942  2965  2991  3005  3015  3022  3026
2871  2887  2930  2972  2992  2998  3013  3023  3029  3031
2880  2899  2941  2992  3005  3005  3021  3028  3033  3039
2896  2920  2956  3000  3013  3019  3019  3028  3037  3042
2915  2939  2981  3008  3017  3026  3028  3028  3036  3044
2928  2952  2986  3024  3029  3034  3038  3034  3031  3044
2936  2960  3009  3040  3044  3046  3049  3044  3037  3044
2943  2977  3041  3051  3051  3051  3051  3051  3037  3046
2960  3029  3051  3051  3051  3051  3051  3050  3044  3049
```

这份数据是从俄勒冈州 Forked Horn Butte 的 DEM 文件中提取的。每个数字表示海平面以上的高度，单位为英尺。如果将这些高程值绘制成三维图，就可以揭示地球表面的形状，如下所示：

![数字高程模型](img/B04102_02_07.jpg)

这只是整体 DEM 文件的一小部分，但它确实展示了 DEM 文件是如何编码地球表面形状的。

### 注意

DEM 文件还有一个称为**无数据值**的概念。这是一个特殊的高度值，表示该点没有高程值。无数据值用于你不想记录或显示 DEM 中某些部分的高程值的地方。例如，特定国家的 DEM 文件会使用无数据值来表示该国边界以外的所有地区。

数字高程模型通常用作构建地球表面有用图像的基石。例如：

+   可以使用称为**颜色映射**的技术将不同的颜色与不同的高度带相关联。如果选择了正确的颜色组合，结果几乎可以看起来像一张显示不同植被、裸地、岩石和雪的带的照片。

+   可以从高程数据生成**阴影渲染**图像。这模仿了光源（例如太阳）照射到地球表面的效果，揭示了深度并产生阴影和亮部，使得生成的图像几乎像是从太空中拍摄的地球照片。

+   **等高线**可以通过平滑 DEM 数据并通过 GDAL 库提供的程序`gdal_contour`生成。

通常，将几个生成的图像合并以产生更逼真的效果。然后，这些派生图像被用作背景地图，在背景地图上叠加地理空间数据。

## 栅格底图

而不是从 DEM 文件构建你的图像，你可以使用为底图预先生成的图像。这些底图通常非常复杂。例如，水下区域可能使用不同深度的蓝色色图来绘制，以表示水的深度，而海平面以上的区域则使用阴影渲染图像，结合植被和基于高度的颜色来产生逼真的效果。

下图展示了这种类型的典型底图：

![栅格底图](img/B04102_02_08.jpg)

这些基础地图仅仅是带有相关地理参照信息的图像文件。地理参照信息标识了基础地图覆盖的地球区域。这通常是通过指定图像的左上角和右下角的纬度和经度来完成的。使用这些点，可以在地球表面上准确放置图像，允许在基础地图上正确绘制地理空间数据，并且根据你希望显示的地球表面区域，允许正确绘制基础地图的相应部分。

## 多波段栅格文件

如前一章所述，栅格格式的地理空间数据不仅能存储图像。栅格信息可能包括诸如高程（如我们在数字高程模型部分之前所见）、土壤类型、平均降雨量、人口密度等值。

栅格格式的数据文件不仅限于存储单一信息。单个文件可以包含多个**波段**的栅格数据，如下面的插图所示：

![多波段栅格文件](img/B04102_02_09.jpg)

每个波段都有一个单元格的值，因此对于给定的（x，y）位置，波段 1 将包含一个值，波段 2 将包含一个值，依此类推。存储在每个波段中的值的含义完全取决于你使用的栅格文件；你需要参考该栅格文件的文档以了解每个波段中存储了什么。

有时，多个波段可以组合起来产生一种颜色。例如，你可以下载由陆地卫星捕获的栅格数据（有关详细信息，请参阅[`landsatlook.usgs.gov`](http://landsatlook.usgs.gov)），这些数据包括三个单独波段中的红色、绿色和蓝色颜色成分。额外的波段包含红外和*全色*值，在某些情况下也可能很有用。

# 可免费获取的地理空间数据来源

现在你已经了解了拥有适当地理空间数据的重要性，并且已经了解了你将想要使用的主要数据类型，让我们看看你可以获取所需数据的几个地方。

有一些情况下你可能需要购买地理空间数据集。一个例子是在寻找美国邮政编码边界时；此类信息属于美国邮政服务（USPS）的专有信息，并且只能通过从获得 USPS 许可以销售此类数据的供应商处购买合适的数据集来获取准确版本。然而，这只是一个例外：在几乎所有其他情况下，你可以免费获取、修改和使用地理空间数据。

现在我们来看看在寻找地理空间数据时你将想要使用的几个主要网站。

## 自然地球数据

自然地球数据网站 ([`naturalearthdata.com`](http://naturalearthdata.com)) 是高质量和免费地理空间数据的综合来源。在矢量格式数据方面，文件以高、中、低分辨率提供。提供了两种不同类型的矢量数据：

+   **文化数据**：这包括国家、州或省、城市区域和公园轮廓的多边形，以及人口密集地区、道路和铁路的点数据和 LineString 数据。![自然地球数据](img/4102_02_10.jpg)

+   **物理数据**：这包括陆地、海岸线、海洋、小岛屿、珊瑚礁、河流和湖泊的多边形和 LineStrings。![自然地球数据](img/B04102_02_11.jpg)

在栅格格式数据方面，自然地球数据在 1:100 万和 1:500 万比例尺下提供了五种不同类型的栅格基础地图。

![自然地球数据](img/B04102_02_12.jpg)

这些图像文件以地理参考的 TIFF 图像提供，这使得它们很容易在您的 Python 程序中用作栅格基础地图。

## OpenStreetMap

OpenStreetMap ([`openstreetmap.org`](http://openstreetmap.org)) 是一个巨大的协作努力，旨在创建和提供地理空间地图数据。该网站将其描述为“由像您这样的人制作的整个世界的免费可编辑地图”。它将自己定位为 Google Maps 的直接竞争对手。以下图像显示了基于 OpenStreetMap 数据的新西兰罗托鲁阿市的部分街道地图：

![OpenStreetMap](img/B04102_02_13.jpg)

不幸的是，OpenStreetMap 使用其自有的基于 XML 的格式来存储地理空间数据。如果您愿意，您可以下载整个 OpenStreetMap 数据库，称为 `Planet.osm`，然后使用空间数据库来访问这些信息。然而，在大多数情况下，您可能希望使用已经转换为更标准格式（如 shapefile）的 OpenStreetMap 数据库的提取。

您可以在 [`wiki.openstreetmap.org/wiki/Planet.osm#Country_and_area_extracts`](http://wiki.openstreetmap.org/wiki/Planet.osm#Country_and_area_extracts) 找到提供 OpenStreetMap 数据提取的网站列表。

如果您想要操作街道地图或使用街道地图作为背景来显示其他地理空间数据，OpenStreetMap 非常有用。

## 美国人口普查局

美国人口普查局已将大量地理空间数据以 **TIGER**（**拓扑集成地理编码和参考系统**）的名义提供。TIGER 数据集包括街道、铁路、河流、湖泊、地理边界以及州、学区、城市边界等法律和统计区域。

TIGER 数据以 shapefile 格式提供，可以从 [`www.census.gov/geo/maps-data/data/tiger.html`](http://www.census.gov/geo/maps-data/data/tiger.html) 下载。

由于它是由美国政府生产的，TIGER 数据仅覆盖美国及其保护领地（即波多黎各、美属萨摩亚、北马里亚纳群岛、关岛和美国维尔京群岛）。然而，对于这些地区，TIGER 是准确地理空间数据的绝佳来源。

## 世界边界数据集

我们在上一章中使用了这个数据集。虽然它非常简单，但世界边界数据集([`thematicmapping.org/downloads/world_borders.php`](http://thematicmapping.org/downloads/world_borders.php))以 shapefile 的形式提供了有用的国家轮廓。shapefile 包括国家的名称、相关的 ISO、FIPS 和联合国识别代码、基于联合国的地区和子地区分类，以及国家的人口和面积。

世界边界数据集的简单性使其成为许多需要整个世界基本地图的地理空间应用的理想选择。

## GLOBE

**全球陆地一公里基础高程**（**GLOBE**）数据集是一个国际努力，旨在生产高质量、中等分辨率的 DEM 数据，覆盖整个世界。在栅格 DEM 文件中的每个单元格代表地球表面上一个正方形的地面高程，该正方形的经度为 30 弧秒，纬度为 30 弧秒。这相当于每边大约一公里的正方形。

GLOBE 项目的官方网站可在[`www.ngdc.noaa.gov/mgg/topo/globe.html`](http://www.ngdc.noaa.gov/mgg/topo/globe.html)找到。请注意，如果您下载了覆盖地球表面区域的预制的“瓦片”，您还需要下载相关的头文件（`.hdr`），该头文件为 DEM 数据提供地理参考。这些头文件可以从[`www.ngdc.noaa.gov/mgg/topo/elev/esri/hdr`](http://www.ngdc.noaa.gov/mgg/topo/elev/esri/hdr)下载。

### 注意

由于在本章后面我们需要一些示例 DEM 数据，现在就下载`E`瓦片。然后访问提供的链接下载相关的头文件。您应该最终得到两个文件，分别命名为`e10g`和`e10g.hdr`。

## 国家高程数据集

国家高程数据集([`ned.usgs.gov`](http://ned.usgs.gov))为美国大陆、阿拉斯加、夏威夷和其他美国领土提供了高分辨率 DEM 数据。根据您查看的区域，DEM 数据集中的每个单元格对应于 3 到 60 平方米的面积。这比 GLOBE 项目使用的 1 平方公里分辨率要高得多。

如果您想为美国制作自己的阴影高程基础地图，国家高程数据集是一个极佳的选择。所有文件都可用多种格式，包括 GeoTIFF 和 ArcGRID，这些都可以使用 GDAL 进行处理。

# 使用 Python 读取和写入地理空间数据

由于我们将使用 GDAL/OGR 库来访问地理空间数据，让我们更详细地看看如何使用这个库读取和写入矢量格式和栅格格式数据。

## 读取矢量数据

在上一章中，我们编写了一个简单的程序，用于从 shapefile 中读取要素。以下是该程序的副本：

```py
import osgeo.ogr
shapefile = osgeo.ogr.Open("TM_WORLD_BORDERS-0.3.shp")
layer = shapefile.GetLayer(0)
for i in range(layer.GetFeatureCount()):
    feature = layer.GetFeature(i)
    feature_name = feature.GetField("NAME")
    geometry = feature.GetGeometryRef()
    geometry_type = geometry.GetGeometryName()
    print i, feature_name, geometry_type
```

让我们更详细地看看这个程序是如何工作的，以及更一般地，如何使用 OGR 库读取矢量格式数据。

当读取地理空间数据时，`osgeo.ogr.Open()` 函数只接受一个参数：要打开的数据集的名称。OGR 库遍历它支持的所有不同的驱动程序，直到找到一个能够读取此数据集的驱动程序。然后，驱动程序创建一个新的 `OGRDataSource` 对象，该对象提供对数据集内容的访问，`Open()` 函数将此对象返回给调用者。

所有这些操作的效果是将 `shapefile` 变量设置为 OGR 数据源。OGR 数据源由一个或多个 **图层** 组成，每个图层代表一组不同的数据。例如，**Countries** 数据源可能有一个表示国家地形的图层，一个包含道路的图层，另一个表示国家城市边界的图层，另一个表示区域边界的图层，等等。

### 注意

请记住，shapefile 只能有一个图层。为了使用 shapefile 表示这些不同的信息，您必须为这些不同的数据分别创建一个单独的 shapefile。

如前述代码示例所示，您使用 `GetLayer()` 方法从数据源中检索一个图层；返回的对象是 `OGRLayer` 类的实例。还有一个方便的 `GetLayerCount()` 方法，它返回数据源中的图层数量。

每个图层都有一个 **空间参考系统**，它告诉您如何解释图层中的各个坐标，以及包含实际数据的 **要素** 列表。如果您不知道空间参考系统是什么，请不要担心；您将在本章后面的 *处理空间参考系统* 部分中了解到所有关于它的信息。

我们可以使用 `GetFeatureCount()` 和 `GetFeature()` 方法遍历图层中的各个要素。正如您所期望的，每个要素都由 `ogr.Feature` 类的实例表示。

每个要素都有一个唯一的 **ID**，可以使用 `GetFID()` 方法检索，以及一个 **几何形状** 和一个 **属性** 列表。我们使用 `GetGeometryRef()` 方法检索几何形状（`OGRGeometry` 的实例），并且可以使用 `GetField()` 方法访问要素的属性。

使用这些各种类和方法，您可以遍历矢量数据源中的各种功能，依次检索每个功能的几何形状和属性（以及 ID）。然而，所有这些的奇妙之处在于，这并不重要您的数据格式是什么：您使用完全相同的过程从 shapefile 中读取数据，就像您使用 OGR 库的 PostGIS 数据库驱动程序从空间数据库中读取数据一样。OGR 库隐藏了如何读取不同数据格式的所有细节，并为您提供了一个简单的、高级的接口来从任何数据源读取矢量格式数据。

## 写入矢量数据

将地理空间数据写入矢量格式文件几乎与读取它一样简单。然而，您必须采取一些额外的步骤。让我们编写一个简单的 Python 程序，该程序创建一个 shapefile 并将一些示例数据保存到其中。这个程序将教会您所有关于使用 OGR 编写矢量格式数据所需知道的事情。

使用 OGR 创建矢量格式数据集涉及以下步骤：

1.  首先，我们通过选择一个 OGR 驱动程序并告诉该驱动程序创建新的数据源来创建目标文件：

    ```py
    from osgeo import ogr
    driver = ogr.GetDriverByName("ESRI Shapefile")
    dstFile = driver.CreateDataSource("test-shapefile")
    ```

1.  然后，我们创建一个 **空间参考** 对象，该对象定义了数据集中坐标应该如何解释：

    ```py
    from osgeo import osr
    spatialReference = osr.SpatialReference()
    spatialReference.SetWellKnownGeogCS("WGS84")
    ```

    正如您所看到的，我们使用 `osr` 模块来定义空间参考，然后使用代码 `WGS84` 将其设置为“已知”空间参考。

    ### 注意

    WGS84 是用于经纬度值的标准。我们将在本章后面的 *处理空间参考系统* 部分详细讨论这一点。

1.  然后，我们将图层添加到目标文件中，以存储图层的数据：

    ```py
    layer = dstFile.CreateLayer("layer", spatialReference)
    ```

    正如您所看到的，每个图层都有自己的空间参考，因此我们必须在创建图层时传递我们之前定义的空间参考。

1.  下一步是定义目标文件将为每个功能存储的各种属性。让我们定义一个名为 `NAME` 的字段：

    ```py
    field = ogr.FieldDefn("NAME", ogr.OFTString)
    field.setWidth(100)
    layer.CreateField(field)
    ```

    ### 注意

    注意，我们使用大写字母定义字段名称。这是因为我们正在写入 shapefile，它对属性名称的大小写敏感，通常使用大写字母定义属性。在 shapefile 中使用大写属性名称将有助于避免以后的问题。

这完成了文件的创建。现在让我们创建一些示例数据并将其保存到文件中。这涉及以下步骤：

1.  让我们定义一个简单的多边形来表示功能的几何形状。我们将使用 WKT 格式来简化这个过程：

    ```py
    wkt = "POLYGON((23.4 38.9, 23.5 38.9, 23.5 38.8, 23.4 38.9))"
    polygon = ogr.CreateGeometryFromWkt(wkt)
    ```

1.  我们接下来创建表示功能的 OGR `Feature` 对象，并按需设置几何形状和属性：

    ```py
    feature = ogr.Feature(layer.GetLayerDefn())
    feature.SetGeometry(polygon)
    feature.SetField("NAME", "My Polygon")
    ```

1.  然后，我们可以将功能添加到图层中：

    ```py
    layer.CreateFeature(feature)
    feature.Destroy()
    ```

    注意到对 `feature.Destroy()` 的调用。这看起来可能有些奇怪，但这样做是释放由该功能使用的内存，并且巧合的是，它还会将功能的详细信息写入 shapefile。

1.  最后，我们通过调用 `Destroy()` 方法来关闭目标文件：

    ```py
    dstFile.Destroy()
    ```

    这将关闭目标文件并确保所有内容都已保存到磁盘。

与读取矢量格式数据一样，此代码不仅限于创建 shapefile。OGR 允许您以许多不同的格式创建地理空间数据，并且无论使用什么格式，您都使用相同的类和方法名称。

## 读取栅格数据

要读取栅格格式的地理空间数据，您使用 GDAL 库。让我们看看如何使用我们之前下载的 `E` 栅格数据来执行此操作。

确保将 `e10g` 和 `e10g.hdr` 文件都放在一个方便的目录中，然后在同一目录中创建一个 Python 脚本。我们将首先在这个脚本中输入以下内容：

```py
from osgeo import gdal
dem_file = gdal.Open("e10g")
```

如您所见，我们使用 `gdal.Open()` 函数打开栅格数据文件。正如我们之前提到的，栅格数据源可以由多个数据带组成。要查看文件中有多少个数据带，您可以使用 `RasterCount`：

```py
num_bands = dem_file.RasterCount
```

对于这个 DEM 文件，只有一个数据带；我们将使用 `GetRasterBand()` 方法获取对这个数据带的引用：

```py
band = dem_file.GetRasterBand(1)
```

注意，数据带编号从 1 开始，而不是通常的 0。结果是 `gdal.Band` 对象。虽然您可以使用 Band 类的各种方法以原始字节序列的形式读取栅格数据带的内容，但从栅格数据带中提取数据的最简单方法是将其转换为 NumPy 数组：

```py
data = band.ReadAsArray()
```

### 注意

如果您使用 GDAL 的 Mac OS X 安装程序，NumPy 将自动安装。在其他平台上，您可能需要自己安装它。NumPy 可以在 [`numpy.org`](http://numpy.org) 找到。

然后，您可以使用 NumPy 数组处理方法从该数组中提取数据。为了了解如何进行，让我们遍历数组并计算 DEM 数据中的高程值直方图：

```py
num_rows,num_cols = data.shape

histogram = {} # Maps elevation to number of occurrences of that elevation.

for row in range(num_rows):
    for col in range(num_cols):
        elevation = int(data[row, col])
        try:
            histogram[elevation] += 1
        except KeyError:
            histogram[elevation] = 1

for elevation in sorted(histogram.keys()):
    print elevation, histogram[elevation]
```

如您所见，从 NumPy 数组中读取数据相当简单。

### 注意

我们程序中有一小部分可能让人困惑。请注意，我们使用：

```py
elevation = int(data[row, col])
```

除了从 NumPy 数组中提取高程之外，我们还将它强制转换为整数。我们这样做是因为 `data` 是一个 NumPy 数组，它为数组中的每个条目返回一个 `numpy.uint16` 值。NumPy 会自动将其转换为整数，但这样做会减慢我们的程序速度。由于这些值已经是整数，我们直接将高程转换为常规整数。这提高了我们程序的速度大约一个数量级——当我们处理大量数据时这一点非常重要。

如果您运行此程序，您将看到一个唯一高程值列表以及该高程值在 DEM 文件中出现的频率：

```py
% python readRaster.py
-500 53081919
-84 1
-83 8
-82 9
-81 17
...
5241 1
5295 1
5300 1
5443 1

```

注意负高程值。其中大部分是因为美国（例如死亡谷）的一些地区低于海平面。然而，有一个 `-500` 的高程值，这不是真实的高程值。这是我们之前提到的**无数据值**。

您可以通过在程序中添加以下突出显示的行来避免将其添加到直方图中：

```py
...
histogram = {} # maps elevation to number of occurrences of that elevation.
no_data = int(band.GetNoDataValue())

for row in range(num_rows):
    for col in range(num_cols):
        elevation = int(data[row, col])
        if elevation == no_data: continue
        try:
            ...
```

以这种方式使用 NumPy，读取栅格格式数据源的内容相对简单。现在让我们看看写入栅格格式数据涉及哪些内容。

## 写入栅格数据

要写入栅格格式数据，我们需要生成一些样本数据，告诉 GDAL 如何将数据中的每个单元格地理配准到地球表面上的一个点，然后将数据保存到磁盘。让我们一步一步来完成这个任务。

1.  我们首先创建栅格格式数据文件。我们将使用`EHdr`格式，它是 ESRI 头标签文件的简称——这是我们之前读取 DEM 数据时使用的相同文件格式。

    ### 注意

    如同往常，GDAL 使得处理不同的数据格式变得容易；无论您选择什么格式，相同的代码都将工作。

    下面是创建 EHdr 格式栅格数据文件的代码：

    ```py
    from osgeo import gdal
    driver = gdal.GetDriverByName("EHdr")
    dstFile = driver.Create("Example Raster", 180, 360, 1, gdal.GDT_Int16)
    ```

    `Create()`方法的参数是文件名、单元格的宽度和高度、栅格波段数以及每个单元格中要存储的数据类型。

1.  接下来，我们需要告诉 GDAL 为文件使用哪个空间参考系统。在这种情况下，我们将使用之前遇到的相同`WGS84`参考系统；如果您还记得，这意味着我们的坐标由纬度和经度值组成。以下是相关代码：

    ```py
    from osgeo import osr

    spatialReference = osr.SpatialReference()
    spatialReference.SetWellKnownGeogCS("WGS84")

    dstFile.SetProjection(spatialReference.ExportToWkt())
    ```

1.  接下来，我们需要将栅格数据地理配准到地球表面。这是通过使用**地理配准变换**来完成的。在定义地理配准变换时，您可以使用许多选项，允许您执行诸如翻转栅格数据或旋转数据等复杂操作。然而，在这种情况下，我们只需要告诉 GDAL 左上角单元格应该放置的位置以及每个单元格的大小：

    ```py
    originX    = -180
    originY    = 90
    cellWidth  = 0.25
    cellHeight = 0.25

    geoTransform = [originX, cellWidth, 0, originY, 0, -cellHeight]
    dstFile.SetGeoTransform(geoTransform)
    ```

    在这个示例代码中，我们已将左上角单元格设置为`latitude=90`、`longitude=-180`，并定义每个单元格覆盖 1/4 度的纬度和经度。

1.  我们现在准备好创建我们的栅格格式数据并将其保存到文件中。让我们生成一个 360 行和 180 列的数组，其中每个值是介于 1 和 100 之间的随机数：

    ```py
    import random

    data = []
    for row in range(360):
        row_data = []
        for col in range(180):
            row_data.append(random.randint(1, 100))
        data.append(row_data)
    ```

    我们可以将这个数组转换为 NumPy 数组，其中数组中的每个条目都是一个 16 位有符号整数：

    ```py
    import numpy
    array = numpy.array(data, dtype=numpy.int16)
    ```

    然后，这些数据可以保存到文件中：

    ```py
    band.WriteArray(array)
    ```

1.  最后，让我们定义一个无数据值，并关闭文件以将所有内容保存到磁盘：

    ```py
    band.SetNoDataValue(-500)
    del dstFile
    ```

运行此程序将在磁盘上创建一个新的栅格格式文件，包括头部（`.hdr`）文件以及如何将我们的（随机）数据地理配准到地球表面的信息。除了添加空间参考系统和地理配准变换外，写入地理空间数据的过程几乎与读取一样简单。

### 注意

实际上，在从文件读取栅格数据时，您也可以使用空间参考系统和地理变换——我们只是跳过了这一步以保持简单。稍后，当我们想要将单元格精确地放置在地球表面的一个点上时，我们将在读取栅格格式数据时同时使用这两个概念。

# 处理空间参考系统

当你开始处理地理空间数据时，可能会相当令人困惑的一个概念是**空间参考系统**。想象一下，你正在执行一次搜救行动，并且被提供了一个飞机坠毁的坐标位置，例如：

```py
(-114.93, 12.478)
```

这些数字代表什么？这些值是纬度和经度，还是可能是从给定参考点起数公里的距离？如果不了解这些坐标如何转换到地球表面上的一个点，你就无法知道该将救援人员送往何处。

### 注意

空间参考系统有时被称为坐标参考系统。不用担心：这两个术语指的是同一件事。

要理解空间参考系统的概念，你首先需要了解一些关于制图理论的知识。地图是尝试在二维笛卡尔平面上绘制地球的三维表面：

![处理空间参考系统](img/B04102_02_14.jpg)

为了将地球表面转换成二维平面，你需要使用一种称为**投影**的数学过程。问题是，在数学上不可能有一个完美的投影：形状将会变形，面积将会被错误表示，或者点之间的距离将会不正确。

由于这种不完美，多年来已经开发了大量不同的地图投影。某些地图投影对于世界的某些地区来说非常准确，但在其他地方则不准确。其他地图投影在保持大陆形状的同时，错误地表示距离和面积，等等。

无论何时你处理地理空间数据，你都需要回答以下三个问题：

+   哪种数学模型被用来定义地球的形状？

+   坐标是否已经投影到地图上？

+   如果是这样，使用了哪种投影？

知道这些问题的答案将使你知道给定一组坐标所指的是确切位置。正如你可以想象的那样，知道这些问题的答案是任何地理空间分析成功的关键。

空间参考系统封装了这三个问题的答案。让我们看看几个常见的空间参考系统，看看它们是如何工作的。

## WGS84

**WGS84**代表 1984 年世界大地测量系统，是一个全球标准，用于表示地球表面的点。它使用了一个精确的地球形状数学模型，以及定义纬度和经度的标准。综合来看，WGS84 空间参考系统提供了一个完整的系统来描述地球表面的点。

让我们更详细地看看 WGS84 是如何定义纬度和经度值的。给定地球表面上的一个点，纬度和经度是通过从地球中心到所需点的想象线来计算的：

![WGS84](img/B04102_02_15.jpg)

然后，您可以测量纬度作为这条线与延伸到赤道的线之间的北南方向的角：

![WGS84](img/B04102_02_16.jpg)

同样，经度可以通过这条线在东西方向上的角与延伸到零度的线（基于英国格林尼治的位置）来计算：

![WGS84](img/B04102_02_17.jpg)

如您所见，经纬度值是基于地球表面上所需点的位置。WGS84 是一个典型的**未投影**坐标系统的例子。它是一种非常常见的地理空间数据格式，在许多情况下，你将只处理这种格式的数据。

## 普通横轴墨卡托

**普通横轴墨卡托**（**UTM**）是一个非常常用的标准，用于在平面直角坐标系上表示坐标。UTM 不是一个单一的地图投影，而是一系列称为 **区域** 的六十个不同的投影，每个区域覆盖地球表面的一小部分：

![普通横轴墨卡托](img/B04102_02_18.jpg)

对于任何给定的 UTM 区域，坐标被测量为“北向”和“东向”值，这些值对应于给定参考点北或东方向上的米数。参考点被计算得使得北向和东向值始终为正。

由于 UTM 投影基于二维地图，这些是**投影**坐标系统的例子。

## 描述空间参考系统

无论何时您处理地理空间数据，您都需要知道您正在使用哪个空间参考系统。通常，在生成地图或读取和写入地理空间数据时，您需要构建一个 `osr.SpatialReference` 对象或其等效对象来描述您正在使用的空间参考系统。

描述空间参考系统的一种最简单的方法是使用名称。我们之前在创建空间参考对象时使用已知名称时看到了这一点，如下所示：

```py
spatialReference = osr.SpatialReference()
spatialReference.SetWellKnownGeogCS("WGS84")
```

描述空间参考系统的另一种常见方法是使用 **EPSG** 代码。EPSG 是一个维护所有已知空间参考系统数据库的标准机构，并为每个系统分配一个唯一的数字代码。您可以在 [`www.epsg-registry.org`](http://www.epsg-registry.org) 找到 EPSG 网站。例如，WGS84 的 EPSG 代码是 4326，因此您也可以使用以下 Python 代码创建一个 WGS84 空间参考对象：

```py
spatialReference = osr.SpatialReference()
spatialReference.ImportFromEPSG(4326)
```

最后，您可以使用 WKT 格式字符串来定义一个空间参考系统。GDAL/OGR 库使得使用 WKT 导入和导出空间参考系统变得容易。例如：

```py
>>> spatialReference = osr.SpatialReference()
>>> spatialReference.ImportFromEPSG(4326)
>>> print spatialReference.ExportToWkt()
GEOGCS["WGS 84",DATUM["WGS_1984",SPHEROID["WGS 84",6378137,298.257223563,AUTHORITY["EPSG","7030"]],AUTHORITY["EPSG","6326"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4326"]]

```

还有一个 `ImportFromWkt()` 方法，它允许你使用 WKT 定义字符串来定义一个空间参考对象。

## 坐标转换

除了知道你正在使用哪个空间参考系统之外，有时能够将空间数据从一个空间参考系统转换到另一个也很重要。例如，如果你想使用 Shapely 来计算两个多边形之间的交集，而这两个多边形使用不同的空间参考系统，你需要在交集工作之前将它们转换到同一个空间参考系统。

### 注意

记住，Shapely 是一个*几何*操作库。它不了解空间参考系统，所以你需要自己处理这个问题。

要将几何形状从一个空间参考系统转换到另一个，你可以使用`osr.CoordinateTransformation`类。让我们看看这是如何完成的：

```py
src_spatialReference = osr.SpatialReference()
src_spatialReference.SetWellKnownGeogCS("WGS84")

dst_spatialReference = osr.SpatialReference()
dst_spatialReference.SetUTM(10)

transform = osr.CoordinateTransformation(src_spatialReference, dst_spatialReference)

geometry.Transform(transform)
```

你首先定义两个空间参考系统，然后创建坐标变换以将一个系统转换到另一个。然后你可以简单地调用`Transform()`方法将几何形状从源空间参考系统转换到目标空间参考系统。

## 计算长度和面积

现在我们已经了解了空间参考系统的基础知识以及如何将数据从一个空间参考系统转换到另一个，我们终于可以解决我们在第一章中遇到的问题，即*地理空间分析和技术*。如果你还记得，当我们查看使用 Shapely 库可以进行的计算时，我们发现我们无法准确计算使用经纬度值的空间数据的长度和面积。

让我们再次审视这个问题，以及我们如何可以使用坐标变换来解决这些问题。

让我们定义一个简单的多边形，它定义了纽约中央公园的大致轮廓：

```py
import shapely.wkt
wkt = "POLYGON((-73.973057 40.764356, -73.981898 40.768094, -73.958209 40.800621, -73.949282 40.796853, -73.973057 40.764356))"
outline = shapely.wkt.loads(wkt)
```

我们在本章前面关于已知文本的部分使用了这个多边形作为例子。

如果我们要求 Shapely 计算这个几何形状的面积，它将计算这个多边形覆盖的数学面积：

```py
>>> print outline.area
0.000377902804

```

不幸的是，得到的结果是“平方度”，这是一个没有意义的数字。这是因为 Shapely 不了解地图投影——它只是将每个坐标值视为一个数字。为了计算这个多边形在真实单位中的面积，我们必须将未投影的经纬度坐标转换为所谓的“等面积”地图投影，该投影以米为单位测量坐标。然后我们可以要求 Shapely 计算面积，结果将以平方米为单位。让我们看看我们如何使用 OGR 和 Shapely 的组合来完成这项工作：

1.  首先，我们使用我们的轮廓的 WKT 定义创建一个 OGR 几何对象：

    ```py
    from osgeo import ogr
    polygon = ogr.CreateGeometryFromWkt(wkt)
    ```

1.  接下来，我们需要定义一个从 WGS84 到使用米的投影坐标系统的坐标变换。我们将使用**世界莫勒维德**投影（EPSG 代码 54009），这是一个在全球范围内相当准确的等面积投影：

    ```py
    from osgeo import osr

    src_spatialReference = osr.SpatialReference()
    src_spatialReference.ImportFromEPSG(4326)

    dst_spatialReference = osr.SpatialReference()
    dst_spatialReference.ImportFromEPSG(54009)

    transform = osr.CoordinateTransformation(src_spatialReference, dst_spatialReference)
    ```

1.  然后，我们可以将 OGR 几何体从 WGS84 转换为世界莫勒韦德投影，将其转换回 Shapely 几何体，并最终让 Shapely 计算多边形的面积：

    ```py
    polygon.Transform(transform)

    outline = shapely.wkt.loads(polygon.ExportToWkt())
    print outline.area
    ```

结果是中央公园面积的准确数值（与原始多边形轮廓允许的精度一样），以平方米为单位。然后你可以将这个面积转换为平方英里或其他任何你想要的单位。

在这个例子中，我们使用了等面积投影。为了准确计算长度，你必须使用一个等距地图投影来覆盖你感兴趣的地球区域。或者，你可以使用`PyProj`库来计算未投影坐标的距离；我们将在第五章*分析地理空间数据*中详细探讨`PyProj`。

# 地理空间数据错误及其修复方法

当你开始处理地理空间数据时，你很快会发现事情并不总是像你预期的那样运作。当尝试将几何体保存到形状文件中时，OGR 可能会崩溃，或者当计算两个多边形的交集时，Shapely 可能会引起系统错误。虽然这可能会令人沮丧，但一旦你了解了导致这些问题的原因，就有办法解决这些问题。

地理空间数据，以及像 GDAL/OGR 和 Shapely 这样的库，都是基于一个几何结构应该如何构建的数学模型。当你的地理空间数据不符合这个数学理想时，就会出现问题。让我们看看一个数学上正确的几何体是什么样的。

## 点

虽然坐标只是一对数字，但可接受值的范围是有限的。例如，想象以下使用 WGS84（即纬度和经度坐标）的点几何体：

```py
POINT(-0.076 51.506)
POINT(2.295 48.858)
POINT(37.784 -122.402)
```

这些点本应代表伦敦塔、埃菲尔铁塔和旧金山莫斯 cone 中心的位置。然而，第三个点几何体被错误地定义了，通过交换纬度和经度。这个位置被设置为经度=37.784 和纬度=-122.402。但是纬度值只能在-90 到+90 的范围内，因此这个点几何体是无效的。

当然，所有几何体都是由坐标组成的，所以例如一个多边形可能只有一个超出范围的坐标，这可能导致你的程序崩溃。在构建或操作几何体时，你有时需要添加代码来检查坐标是否都有效，并在必要时调整几何体。

## 线段

线段几何体由一系列坐标组成，从一点到下一点绘制一条直线段：

![线段](img/B04102_02_19.jpg)

然而，如果你尝试定义只有一个坐标的线段，或者两个坐标恰好相同的线段，那么你的线段几何体在数学上就是无效的，并可能导致你的程序崩溃。

## 线性环

线性环是起点和终点相同的 LineString：

![线性环](img/B04102_02_20.jpg)

线性环用于包围空间区域，是多边形几何体的构建块。为了使线性环有效，它必须至少有三个坐标，并且线段不能接触或交叉。

下图显示了两个数学上无效的线性环示例：

![线性环](img/B04102_02_21.jpg)

## 多边形

多边形几何体由一个或多个线性环组成：第一个线性环定义了多边形的轮廓，而额外的线性环定义了多边形内部的空间。例如：

![多边形](img/B04102_02_22.jpg)

然而，这种多边形的数学理想表示如果内部环重叠、相互接触或接触多边形的外部，就会崩溃。如果发生任何这些情况，您的多边形将变得无效，并且程序可能会崩溃。

## 多边形

如其名称所示，MultiPolygon 几何体是由两个或多个多边形组成的集合。如果其中两个多边形沿着边相接触，则 MultiPolygon 在数学上无效——在这种情况下，这两个多边形应该被合并成一个更大的多边形，因此 MultiPolygon 被认为是无效的。

## 修复无效几何体

即使您的几何数据一开始是有效的，在操作它们时几何体也可能变得无效。例如，如果您尝试将多边形分成两部分，或者合并 LineString 几何体，结果有时可能是无效的。

现在您已经了解了几何体可能无效的方式，让我们来看看一些修复它们的小技巧。首先，您可以通过检查 `is_valid` 属性来询问 Shapely 是否认为几何体是有效的：

```py
if not geometry.is_valid:
    ....
```

同样，您可以使用 `IsValid()` 方法来检查 OGR 几何对象是否有效：

```py
if not geometry.IsValid():
    ...
```

不幸的是，这两个有效性检查并不完美：有时您会发现一个几何体被标识为有效，尽管它实际上不是。当这种情况发生时，您必须在程序中添加 `try...except` 子句来捕获崩溃，然后尝试在再次尝试之前自己修复几何体。

当一个几何体无效时，您首先应该尝试的将是 `buffer(0)` 技术。`buffer()` 操作是一种将几何体扩展以包括原始几何体一定距离内的所有点的操作，例如：

![修复无效几何体](img/B04102_02_23.jpg)

通过调用 `buffer(0)`，您正在告诉 Shapely（或 OGR）构建一个新副本的几何体，该副本包括与几何体零距离内的所有点。这实际上是从头开始重建几何体，并且通常会将无效的几何体转换回有效的几何体。

很不幸，这并不总是有效的。有时`buffer()`函数无法在不崩溃的情况下重建复杂几何形状。在这种情况下，你可能需要将几何形状拆分成单个部分，然后逐一检查每个部分，看它是否是崩溃的原因。当你重新构建时，你可以排除表现不佳的部分。以下是一个示例 Python 代码，它尝试使用此技术修复无效的 Shapely 几何形状：

```py
def fix_geometry(geometry):
    buffer_worked = True
    try:
        geometry = geometry.buffer(0)
    except:
        buffer_worked = False

    if buffer_worked:
        return geometry

    polygons = []
    if geometry.geom_type == "Polygon":
        polygons.append(geometry)
    elif geometry.geom_type == "MultiPolygon":
        polygons.extend(geometry.geoms)

    fixed_polygons = []
    for n,polygon in enumerate(polygons):
        if not linear_ring_is_valid(polygon.exterior):
            continue # Unable to fix.

        interiors = []
        for ring in polygon.interiors:
            if linear_ring_is_valid(ring):
                interiors.append(ring)

        fixed_polygon = shapely.geometry.Polygon(polygon.exterior,
                                                 interiors)

        try:
            fixed_polygon = fixed_polygon.buffer(0)
        except:
            continue

        if fixed_polygon.geom_type == "Polygon":
            fixed_polygons.append(fixed_polygon)
        elif fixed_polygon.geom_type == "MultiPolygon":
            fixed_polygons.extend(fixed_polygon.geoms)

    if len(fixed_polygons) > 0:
        return shapely.geometry.MultiPolygon(fixed_polygons)
    else:
        return None # Unable to fix.

def linear_ring_is_valid(ring):
    points = set() # Set of (x,y) tuples.

    for x,y in ring.coords:
        points.add((x,y))

    if len(points) < 3:
        return False
    else:
        return True
```

### 注意

记住，此代码与 Shapely 几何形状一起工作。如果你有一个 OGR 几何形状，你可以使用`shapely.wkt.loads(ogrGeometry.ExportToWkt())`将其转换为 Shapely 几何形状。

# 摘要

在本章中，我们更详细地研究了用于地理空间分析的数据。我们看到了为什么拥有高质量的地理空间数据很重要，你可能会遇到的地理空间数据的各种类型，以及提供免费高质量地理空间数据的主要网站。然后我们探讨了如何使用 GDAL 和 OGR 读取和写入矢量格式和栅格格式的地理空间数据，并了解了空间参考系统。最后，我们研究了地理空间数据可能变得无效的方式以及如何修复它。

在下一章中，我们将探讨空间数据库以及它们如何作为地理空间分析的有力工具。
