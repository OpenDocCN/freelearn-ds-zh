<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Complex ArcPy Scripts and Generalizing Functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Complex ArcPy Scripts and Generalizing Functions</h1></div></div></div><p>In this chapter, we will move from creating simple scripts based on autogenerated scripts from ModelBuilder to complex scripts that incorporate advanced Python and ArcPy concepts, such as functions. Functions can improve code and save time when writing scripts. They are also useful when creating modules or other reusable code, allowing for standard programming operations to be scripted and ready for future use.</p><p>In this chapter, will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating functions to avoid repeating code</li><li class="listitem" style="list-style-type: disc">Creating helper functions to work with ArcPy limitations</li><li class="listitem" style="list-style-type: disc">Generalizing functions to make them reusable</li></ul></div><div class="section" title="Python functions–Avoid repeating code"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Python functions–Avoid repeating code</h1></div></div></div><p>Programming <a id="id166" class="indexterm"/>languages share a concept that has aided programmers for decades: functions. The idea of a function, loosely speaking, is to create blocks of code that will perform an action on a piece of data, transforming it as required by the programmer and returning the transformed data back to the main body of code. We've already been introduced to some of Python's built-in functions in the last few chapters, the <code class="literal">int</code> function, for instance, will convert a string or a floating number into an integer; now it's time to write our own.</p><p>Functions are used because they solve many different needs within programming. Functions reduce the need to write repetitive code, which in turn reduces the time needed to create a script. They can be used to create ranges of numbers (the <code class="literal">range()</code> function), or to determine the maximum value of a list (the <code class="literal">max</code> function), or to create a SQL statement to select a set of rows from a feature class. They can even be copied and used in another script or included as part of a module that can be imported into scripts. Function reuse has the added bonus of making programming more useful and less of a chore. When a scripter starts writing functions, it is a major step towards making programming part of a GIS workflow.</p><div class="section" title="Technical definition of functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec38"/>Technical definition of functions</h2></div></div></div><p>Functions, also<a id="id167" class="indexterm"/> called subroutines or procedures in other <a id="id168" class="indexterm"/>programming languages, are blocks of code that have been designed to either accept input data and transform it, or provide data to the main program when called without any input required. In theory, functions will only transform data that has been provided to the function as a parameter; it should not change any other part of the script that has not been included in the function. To make this possible, the concept of namespaces is invoked. As discussed in <a class="link" href="ch01.html" title="Chapter 1. Introduction to Python for ArcGIS">Chapter 1</a>, <span class="emphasis"><em>Introduction to Python for ArcGIS</em></span>, namespaces are used to isolate variables within a script; variables are either global, and available to be used in the main body of a script as well as in a function, or are local and only available within a function.</p><p>Namespaces make it possible to use a variable name within a function, and allow it to represent a value, while also using the same variable name in another part of the script. This becomes especially important when importing modules from other programmers; within that module and its functions, the variables that it contains might have a variable name that is the same as a variable name within the main script.</p><p>In a high-level programming language such as Python, there is built-in support for functions, including the ability to define function names and the data inputs (also known as parameters). Functions are created using the keyword <code class="literal">def</code> plus a function name, along with parentheses that may or may not contain parameters. Parameters can also be defined with default values, so parameters only need to be passed to the function when they differ from the default. The values that are returned from the function are also easily defined.</p></div><div class="section" title="A first function"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec39"/>A first function</h2></div></div></div><p>Let's create<a id="id169" class="indexterm"/> a function to get a feel for what is possible when writing functions. First, we need to invoke the function by providing the <code class="literal">def</code> keyword and providing a name along with the parentheses. The <code class="literal">firstFunction()</code> will return a string when called:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>def firstFunction():</strong></span>
<span class="strong"><strong>    'a simple function returning a string'</strong></span>
<span class="strong"><strong>    return "My First Function"</strong></span>
<span class="strong"><strong>&gt;&gt;&gt;firstFunction()</strong></span>
</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>'My First Function'</strong></span>
</pre></div><p>Notice that this function has a documentation string or doc string (a simple function returning a string) that describes what the function does; this string can be called later to find out what the function does, using the <code class="literal">__doc__</code> internal function:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt;print firstFunction.__doc__</strong></span>
</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>'a simple function returning a string' </strong></span>
</pre></div><p>The function is <a id="id170" class="indexterm"/>defined and given a name, and then the parentheses are added followed by a colon. The following lines must then be indented (a good IDE will add the indention automatically). The function does not have any parameters, so the parentheses are empty. The function then uses the keyword <code class="literal">return</code> to return a value, in this case a string, from the function.</p><p>Next, the function is called by adding parentheses to the function name. When it is called, it will do what it has been instructed to do: return the string.</p></div><div class="section" title="Functions with parameters"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec40"/>Functions with parameters</h2></div></div></div><p>Now let's <a id="id171" class="indexterm"/>create a function that accepts parameters and transforms them as needed. This function will accept a number and multiply it by 3:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>def secondFunction(number):</strong></span>
<span class="strong"><strong>    'this function multiples numbers by 3'</strong></span>
<span class="strong"><strong>    return number *3</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; secondFunction(4)</strong></span>
</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>12</strong></span>
</pre></div><p>The function has one flaw, however; there is no assurance that the value passed to the function is a number. We need to add a conditional to the function to make sure it does not throw an exception:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>def secondFunction(number):</strong></span>
<span class="strong"><strong>    'this function multiples numbers by 3'</strong></span>
<span class="strong"><strong>    if type(number) == type(1) or type(number) == type(1.0):</strong></span>
<span class="strong"><strong>        return number *3</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; secondFunction(4.0)</strong></span>
</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>12.0</strong></span>
<span class="strong"><strong>&gt;&gt;&gt;secondFunction(4)</strong></span>
</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>12</strong></span>
<span class="strong"><strong>&gt;&gt;&gt;secondFunction("String")</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; </strong></span>
</pre></div><p>The function<a id="id172" class="indexterm"/> now accepts a parameter, checks what type of data it is, and returns a multiple of the parameter whether it is an integer or a function. If it is a string or some other data type, as shown in the last example, no value is returned.</p><p>There is one more adjustment to the simple function that we should discuss: parameter defaults. By including default values in the definition of the function, we avoid having to provide parameters that rarely change. If, for instance, we wanted a different multiplier than 3 in the simple function, we would define it like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>def thirdFunction(number, multiplier=3):</strong></span>
<span class="strong"><strong>    'this function multiples numbers by 3'</strong></span>
<span class="strong"><strong>    if type(number) == type(1) or type(number) == type(1.0):</strong></span>
<span class="strong"><strong>        return number *multiplier</strong></span>
<span class="strong"><strong>&gt;&gt;&gt;thirdFunction(4)</strong></span>
</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>12</strong></span>
<span class="strong"><strong>&gt;&gt;&gt;thirdFunction(4,5)</strong></span>
</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>20</strong></span>
</pre></div><p>The function will work when only the number to be multiplied is supplied, as the multiplier has a default value of 3. However, if we need another multiplier, the value can be adjusted by adding another value when calling the function. Note that the second value doesn't have to be a number as there is no type checking on it. Also, the default value(s) in a function must follow the parameters with no defaults (or all parameters can have a default value and the parameters can be supplied to the function in order or by name).</p><p>These simple functions combine many of the concepts that we discussed in earlier chapters, including built-in functions such as <code class="literal">type</code>, <code class="literal">conditionals</code>, <code class="literal">parameters</code>, <code class="literal">parameter defaults</code>, and <code class="literal">function returns</code>. We can now move on to creating functions with ArcPy.</p></div><div class="section" title="Using functions to replace repetitive code"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec41"/>Using functions to replace repetitive code</h2></div></div></div><p>One <a id="id173" class="indexterm"/>of the main uses of functions is to ensure that the same code does not have to be written over and over. Let's return to our example from the last chapter and make a function from the script to make it possible to perform the same analysis for any bus line in San Francisco.</p><p>The first portion of the script that we could convert into a function is the three ArcPy functions. Doing so will allow the script to be applicable to any of the stops in the Bus Stop<a id="id174" class="indexterm"/> feature class and have an adjustable buffer distance:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>bufferDist = 400</strong></span>
<span class="strong"><strong>buffDistUnit  = "Feet"</strong></span>
<span class="strong"><strong>lineName = '71 IB'</strong></span>
<span class="strong"><strong>busSignage = 'Ferry Plaza'</strong></span>
<span class="strong"><strong>sqlStatement = "NAME = '{0}' AND BUS_SIGNAG = '{1}'"</strong></span>
<span class="strong"><strong>def selectBufferIntersect(selectIn,selectOut,bufferOut,intersectIn, intersectOut, sqlStatement, bufferDist, buffDistUnit, lineName, busSignage):  </strong></span>
<span class="strong"><strong>    'a function to perform a bus stop analysis'</strong></span>
<span class="strong"><strong>    arcpy.Select_analysis(selectIn, selectOut, sqlStatement.format(lineName, busSignage))</strong></span>
<span class="strong"><strong>    arcpy.Buffer_analysis(selectOut, bufferOut, "{0} {1}".format(bufferDist), "FULL", "ROUND", "NONE", "")</strong></span>
<span class="strong"><strong>    arcpy.Intersect_analysis("{0} #;{1} #".format(bufferOut, intersectIn), intersectOut, "ALL", "", "INPUT")</strong></span>
<span class="strong"><strong>    return intersectOut</strong></span>
</pre></div><p>This function demonstrates how the analysis can be adjusted to accept the input and output feature class variables as parameters, along with some new variables.</p><p>The function adds a variable to replace the SQL statement and variables to adjust the bus stop, and also tweaks the buffer distance statement so that both the distance and the unit can be adjusted. The feature class name variables, defined earlier in the script, have all been replaced with local variable names; while the global variable names could have been retained, it reduces the portability of the function.</p><p>The next function will accept the result of the <code class="literal">selectBufferIntersect()</code> function and search it using the Search Cursor, passing the results into a dictionary. The dictionary will then be returned from the function for later use:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>def createResultDic(resultFC):</strong></span>
<span class="strong"><strong>   'search results of analysis and create results dictionary' </strong></span>
<span class="strong"><strong>  dataDictionary = {}   </strong></span>
<span class="strong"><strong>    with arcpy.da.SearchCursor(resultFC, ["STOPID","POP10"]) as cursor:</strong></span>
<span class="strong"><strong>        for row in cursor:</strong></span>
<span class="strong"><strong>            busStopID = row[0]</strong></span>
<span class="strong"><strong>            pop10 = row[1]</strong></span>
<span class="strong"><strong>            if busStopID not in dataDictionary.keys():</strong></span>
<span class="strong"><strong>                dataDictionary[busStopID] = [pop10]</strong></span>
<span class="strong"><strong>            else:</strong></span>
<span class="strong"><strong>                dataDictionary[busStopID].append(pop10)</strong></span>
<span class="strong"><strong>    return dataDictionary</strong></span>
</pre></div><p>This <a id="id175" class="indexterm"/>function only requires one parameter: the feature class returned from the <code class="literal">searchBufferIntersect()</code> function. The results holding dictionary is first created, then populated by the search cursor, with the <code class="literal">busStopid</code> attribute used as a key, and the census block population attribute added to a list assigned to the key.</p><p>The dictionary, having been populated with sorted data, is returned from the function for use in the final function, <code class="literal">createCSV()</code>. This function accepts the dictionary and the name of the output CSV file as a string:</p><div class="informalexample"><pre class="programlisting">def createCSV(dictionary, csvname):
  'a function takes a dictionary and creates a CSV file'
    with open(csvname, 'wb') as csvfile:
        csvwriter = csv.writer(csvfile, delimiter=',')
        for busStopID in dictionary.keys():
            popList = dictionary[busStopID]
            averagePop = sum(popList)/len(popList)
            data = [busStopID, averagePop]
            csvwriter.writerow(data)</pre></div><p>The final function creates the CSV using the <code class="literal">csv</code> module. The name of the file, a string, is now a customizable parameter (meaning the script name can be any valid file path and text file with the extension <code class="literal">.csv</code>). The <code class="literal">csvfile</code> parameter is passed to the CSV module's writer method and assigned to the variable <code class="literal">csvwriter</code>, and the dictionary is accessed and processed, and passed as a list to <code class="literal">csvwriter</code> to be written to the <code class="literal">CSV</code> file. The <code class="literal">csv.writer()</code> method processes each item in the list into the CSV format and saves the final result. Open the <code class="literal">CSV</code> file with Excel or a text editor such as Notepad.</p><p>To run the functions, we will call them in the script following the function definitions:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>analysisResult = selectBufferIntersect(Bus_Stops,Inbound71, Inbound71_400ft_buffer,CensusBlocks2010, Intersect71Census, bufferDist, lineName, busSignage )</strong></span>
<span class="strong"><strong>dictionary = createResultDic(analysisResult)</strong></span>
<span class="strong"><strong>createCSV(dictionary,r'C:\Projects\Output\Averages.csv')</strong></span>
</pre></div><p>Now, the script has been divided into three functions, which replace the code of the first modified<a id="id176" class="indexterm"/> script. The modified script looks like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># -*- coding: utf-8 -*-</strong></span>
<span class="strong"><strong># ---------------------------------------------------------------------------</strong></span>
<span class="strong"><strong># 8662_Chapter4Modified1.py</strong></span>
<span class="strong"><strong># Created on: 2014-04-22 21:59:31.00000</strong></span>
<span class="strong"><strong>#   (generated by ArcGIS/ModelBuilder)</strong></span>
<span class="strong"><strong># Description: </strong></span>
<span class="strong"><strong># Adjusted by Silas Toms</strong></span>
<span class="strong"><strong># 2014 05 05</strong></span>
<span class="strong"><strong># ---------------------------------------------------------------------------</strong></span>

<span class="strong"><strong># Import arcpy module</strong></span>
<span class="strong"><strong>import arcpy</strong></span>
<span class="strong"><strong>import csv</strong></span>

<span class="strong"><strong># Local variables:</strong></span>
<span class="strong"><strong>Bus_Stops = r"C:\Projects\PacktDB.gdb\SanFrancisco\Bus_Stops"</strong></span>
<span class="strong"><strong>CensusBlocks2010 = r"C:\Projects\PacktDB.gdb\SanFrancisco\CensusBlocks2010"</strong></span>
<span class="strong"><strong>Inbound71 = r"C:\Projects\PacktDB.gdb\Chapter3Results\Inbound71"</strong></span>
<span class="strong"><strong>Inbound71_400ft_buffer = r"C:\Projects\PacktDB.gdb\Chapter3Results\Inbound71_400ft_buffer"</strong></span>
<span class="strong"><strong>Intersect71Census = r"C:\Projects\PacktDB.gdb\Chapter3Results\Intersect71Census"</strong></span>
<span class="strong"><strong>bufferDist = 400</strong></span>
<span class="strong"><strong>lineName = '71 IB'</strong></span>
<span class="strong"><strong>busSignage = 'Ferry Plaza'</strong></span>
<span class="strong"><strong>def selectBufferIntersect(selectIn,selectOut,bufferOut,intersectIn,</strong></span>
<span class="strong"><strong>                          intersectOut, bufferDist,lineName, busSignage ):</strong></span>
<span class="strong"><strong>    arcpy.Select_analysis(selectIn, </strong></span>
<span class="strong"><strong>                          selectOut, </strong></span>
<span class="strong"><strong>                          "NAME = '{0}' AND BUS_SIGNAG = '{1}'".format(lineName, busSignage))</strong></span>
<span class="strong"><strong>    arcpy.Buffer_analysis(selectOut, </strong></span>
<span class="strong"><strong>                          bufferOut, </strong></span>
<span class="strong"><strong>                          "{0} Feet".format(bufferDist), </strong></span>
<span class="strong"><strong>                          "FULL", "ROUND", "NONE", "")</strong></span>
<span class="strong"><strong>    arcpy.Intersect_analysis("{0} #;{1} #".format(bufferOut,intersectIn), </strong></span>
<span class="strong"><strong>                             intersectOut, "ALL", "", "INPUT")</strong></span>
<span class="strong"><strong>    return intersectOut</strong></span>

<span class="strong"><strong>def createResultDic(resultFC):</strong></span>
<span class="strong"><strong>    dataDictionary = {}</strong></span>
<span class="strong"><strong>    </strong></span>
<span class="strong"><strong>    with arcpy.da.SearchCursor(resultFC, </strong></span>
<span class="strong"><strong>                               ["STOPID","POP10"]) as cursor:</strong></span>
<span class="strong"><strong>        for row in cursor:</strong></span>
<span class="strong"><strong>            busStopID = row[0]</strong></span>
<span class="strong"><strong>            pop10 = row[1]</strong></span>
<span class="strong"><strong>            if busStopID not in dataDictionary.keys():</strong></span>
<span class="strong"><strong>                dataDictionary[busStopID] = [pop10]</strong></span>
<span class="strong"><strong>            else:</strong></span>
<span class="strong"><strong>                dataDictionary[busStopID].append(pop10)</strong></span>
<span class="strong"><strong>    return dataDictionary</strong></span>

<span class="strong"><strong>def createCSV(dictionary, csvname):</strong></span>
<span class="strong"><strong>    with open(csvname, 'wb') as csvfile:</strong></span>
<span class="strong"><strong>        csvwriter = csv.writer(csvfile, delimiter=',')</strong></span>
<span class="strong"><strong>        for busStopID in dictionary.keys():</strong></span>
<span class="strong"><strong>            popList = dictionary[busStopID]</strong></span>
<span class="strong"><strong>            averagePop = sum(popList)/len(popList)</strong></span>
<span class="strong"><strong>            data = [busStopID, averagePop]</strong></span>
<span class="strong"><strong>            csvwriter.writerow(data)</strong></span>
<span class="strong"><strong>analysisResult = selectBufferIntersect(Bus_Stops,Inbound71, Inbound71_400ft_buffer,CensusBlocks2010,Intersect71Census, bufferDist,lineName, busSignage )</strong></span>
<span class="strong"><strong>dictionary = createResultDic(analysisResult)</strong></span>
<span class="strong"><strong>createCSV(dictionary,r'C:\Projects\Output\Averages.csv')</strong></span>
<span class="strong"><strong>print "Data Analysis Complete"</strong></span>
</pre></div><p>Further <a id="id177" class="indexterm"/>generalization of the functions, while we have created functions from the original script that can be used to extract more data about bus stops in San Francisco, our new functions are still very specific to the dataset and analysis for which they were created. This can be very useful for long and laborious analysis for which creating reusable functions is not necessary. The first use of functions is to get rid of the need to repeat code. The next goal is to then make that code reusable. Let's discuss some ways in which we can convert the functions from one-offs into reusable functions or even modules.</p><p>First, let's examine the first function:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>def selectBufferIntersect(selectIn,selectOut,bufferOut,intersectIn,</strong></span>
<span class="strong"><strong>                          intersectOut, bufferDist,lineName, busSignage ):</strong></span>
<span class="strong"><strong>    arcpy.Select_analysis(selectIn, </strong></span>
<span class="strong"><strong>                          selectOut, </strong></span>
<span class="strong"><strong>                          "NAME = '{0}' AND BUS_SIGNAG = '{1}'".format(lineName, busSignage))</strong></span>
<span class="strong"><strong>    arcpy.Buffer_analysis(selectOut, </strong></span>
<span class="strong"><strong>                          bufferOut, </strong></span>
<span class="strong"><strong>                          "{0} Feet".format(bufferDist), </strong></span>
<span class="strong"><strong>                          "FULL", "ROUND", "NONE", "")</strong></span>
<span class="strong"><strong>    arcpy.Intersect_analysis("{0} #;{1} #".format(bufferOut,intersectIn), </strong></span>
<span class="strong"><strong>                             intersectOut, "ALL", "", "INPUT")</strong></span>
<span class="strong"><strong>    return intersectOut</strong></span>
</pre></div><p>This function appears to be pretty specific to the bus stop analysis. It's so specific, in fact, that while <a id="id178" class="indexterm"/>there are a few ways in which we can tweak it to make it more general (that is, useful in other scripts that might not have the same steps involved), we should not convert it into a separate function. When we create a separate function, we introduce too many variables into the script in an effort to simplify it, which is a counterproductive effort. Instead, let's focus on ways to generalize the ArcPy tools themselves.</p><p>The first step will be to split the three ArcPy tools and examine what can be adjusted with each of them. The Select tool should be adjusted to accept a string as the SQL select statement. The SQL statement can then be generated by another function or by parameters accepted at runtime (for example, passed to the script by a Script tool, which will be discussed in a later chapter).</p><p>For instance, if we wanted to make the script accept multiple bus stops for each run of the script (for example, the inbound and outbound stops for each line), we could create a function that would accept a list of the desired stops and a SQL template, and would return a SQL statement to plug into the Select tool. Here is an example of how it would look:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>def formatSQLIN(dataList, sqlTemplate):</strong></span>
<span class="strong"><strong>    'a function to generate a SQL statement'</strong></span>
<span class="strong"><strong>    sql = sqlTemplate #"OBJECTID IN "</strong></span>
<span class="strong"><strong>    step = "("</strong></span>
<span class="strong"><strong>    for data in dataList:</strong></span>
<span class="strong"><strong>        step += str(data)</strong></span>
<span class="strong"><strong>    sql += step + ")"</strong></span>
<span class="strong"><strong>    return sql</strong></span>

<span class="strong"><strong>def formatSQL(dataList, sqlTemplate):</strong></span>
<span class="strong"><strong>    'a function to generate a SQL statement'</strong></span>
<span class="strong"><strong>    sql = ''</strong></span>
<span class="strong"><strong>    for count, data in enumerate(dataList):</strong></span>
<span class="strong"><strong>        if count != len(dataList)-1:</strong></span>
<span class="strong"><strong>            sql += sqlTemplate.format(data) + ' OR '</strong></span>
<span class="strong"><strong>        else:</strong></span>
<span class="strong"><strong>            sql += sqlTemplate.format(data)</strong></span>
<span class="strong"><strong>    return sql</strong></span>
</pre></div><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; dataVals = [1,2,3,4]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; sqlOID = "OBJECTID = {0}"</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; sql = formatSQL(dataVals, sqlOID)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print sql</strong></span>
</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">OBJECTID = 1 OR OBJECTID = 2 OR OBJECTID = 3 OR OBJECTID = 4</pre></div><p>This new<a id="id179" class="indexterm"/> function, <code class="literal">formatSQL()</code>, is a very useful function. Let's review what it does by comparing the function to the results following it. The function is defined to accept two parameters: a list of values and a SQL template. The first local variable is the empty string <code class="literal">sql,</code> which will be added to using string addition. The function is designed to insert the values into the variable <code class="literal">sql</code>, creating a SQL statement by taking the SQL template and using string formatting to add them to the template, which in turn is added to the SQL statement string (note that <code class="literal">sql +=</code> is equivelent to <code class="literal">sql = sql +</code>). Also, an operator (<code class="literal">OR</code>) is used to make the SQL statement inclusive of all data rows that match the pattern. This function uses the built-in enumerate function to count the iterations of the list; once it has reached the last value in the list, the operator is not added to the SQL statement.</p><p>Note that we could also add one more parameter to the function to make it possible to use an <code class="literal">AND</code> operator instead of <code class="literal">OR</code>, while still keeping <code class="literal">OR</code> as the default:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>def formatSQL2(dataList, sqlTemplate, operator=" OR "):</strong></span>
<span class="strong"><strong>    'a function to generate a SQL statement'</strong></span>
<span class="strong"><strong>    sql = ''</strong></span>
<span class="strong"><strong>    for count, data in enumerate(dataList):</strong></span>
<span class="strong"><strong>        if count != len(dataList)-1:</strong></span>
<span class="strong"><strong>            sql += sqlTemplate.format(data) + operator</strong></span>
<span class="strong"><strong>        else:</strong></span>
<span class="strong"><strong>            sql += sqlTemplate.format(data)</strong></span>
<span class="strong"><strong>    return sql</strong></span>

<span class="strong"><strong>&gt;&gt;&gt; sql = formatSQL2(dataVals, sqlOID," AND ")</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print sql</strong></span>
</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>OBJECTID = 1 AND OBJECTID = 2 AND OBJECTID = 3 AND OBJECTID = 4</strong></span>
</pre></div><p>While it would make no sense to use an <code class="literal">AND</code> operator on ObjectIDs, there are other cases where it would make sense, hence leaving <code class="literal">OR</code> as the default while allowing for <code class="literal">AND</code>. Either<a id="id180" class="indexterm"/> way, this function can now be used to generate our bus stop SQL statement for multiple stops (ignoring, for now, the bus signage field):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; sqlTemplate = "NAME = '{0}'"</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; lineNames = ['71 IB','71 OB']</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; sql = formatSQL2(lineNames, sqlTemplate)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print sql</strong></span>
</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>NAME = '71 IB' OR NAME = '71 OB'</strong></span>
</pre></div><p>However, we can't ignore the Bus Signage field for the inbound line, as there are two starting points for the line, so we will need to adjust the function to accept multiple values:</p><div class="informalexample"><pre class="programlisting">def formatSQLMultiple(dataList, sqlTemplate, operator=" OR "):
    'a function to generate a SQL statement'
    sql = ''
    for count, data in enumerate(dataList):
        if count != len(dataList)-1:
            sql += sqlTemplate.format(*data) + operator
        else:
            sql += sqlTemplate.format(*data)
    return sql</pre></div><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; sqlTemplate = "(NAME = '{0}' AND BUS_SIGNAG = '{1}')"</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; lineNames = [('71 IB', 'Ferry Plaza'),('71 OB','48th Avenue')]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; sql = formatSQLMultiple(lineNames, sqlTemplate)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print sql</strong></span>
</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>(NAME = '71 IB' AND BUS_SIGNAG = 'Ferry Plaza') OR (NAME = '71 OB' AND BUS_SIGNAG = '48th Avenue')</strong></span>
</pre></div><p>The slight difference in this function, the asterisk before the data variable, allows the values inside the data variable to be correctly formatted into the SQL template by exploding the values within the tuple. Notice that the SQL template has been created to segregate each conditional by using parentheses. The function(s) are now ready for reuse, and the SQL statement is now ready for insertion into the Select tool:</p><div class="informalexample"><pre class="programlisting">sql = formatSQLMultiple(lineNames, sqlTemplate)
arcpy.Select_analysis(Bus_Stops, Inbound71, sql)</pre></div><p>Next up is the Buffer tool. We have already taken steps towards making it generalized by adding a variable for the distance. In this case, we will only add one more variable to it, a unit variable that will make it possible to adjust the buffer unit from feet to meter or any other <a id="id181" class="indexterm"/>allowed unit. We will leave the other defaults alone.</p><p>Here is an adjusted version of the Buffer tool:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>bufferDist = 400</strong></span>
<span class="strong"><strong>bufferUnit = "Feet"</strong></span>
<span class="strong"><strong>arcpy.Buffer_analysis(Inbound71, </strong></span>
<span class="strong"><strong>                      Inbound71_400ft_buffer, </strong></span>
<span class="strong"><strong>                      "{0} {1}".format(bufferDist, bufferUnit), </strong></span>
<span class="strong"><strong>                      "FULL", "ROUND", "NONE", "")</strong></span>
</pre></div><p>Now, both the buffer distance and buffer unit are controlled by a variable defined in the previous script, and this will make it easily adjustable if it is decided that the distance was not sufficient and the variables might need to be adjusted.</p><p>The next step towards adjusting the ArcPy tools is to write a function, which will allow for any number of feature classes to be intersected together using the Intersect tool. This new function will be similar to the <code class="literal">formatSQL</code> functions as previous, as they will use string formatting and addition to allow for a list of feature classes to be processed into the correct string format for the Intersect tool to accept them. However, as this function will be built to be as general as possible, it must be designed to accept any number of feature classes to be intersected:</p><div class="informalexample"><pre class="programlisting">def formatIntersect(features):
    'a function to generate an intersect string'
    formatString = ''
    for count, feature in enumerate(features):
        if count != len(features)-1:
            formatString += feature + " #;"
        else:
            formatString += feature + " #"
        return formatString</pre></div><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; shpNames = ["example.shp","example2.shp"]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; iString = formatIntersect(shpNames)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print iString</strong></span>
</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>example.shp #;example2.shp #</strong></span>
</pre></div><p>Now that we have written the <code class="literal">formatIntersect()</code> function, all that needs to be created is a list of the feature classes to be passed to the function. The string returned by the function <a id="id182" class="indexterm"/>can then be passed to the Intersect tool:</p><div class="informalexample"><pre class="programlisting">intersected = [Inbound71_400ft_buffer, CensusBlocks2010]
iString = formatIntersect(intersected)
# Process: Intersect
arcpy.Intersect_analysis(iString, 
                         Intersect71Census, "ALL", "", "INPUT")</pre></div><p>Because we avoided creating a function that only fits this script or analysis, we now have two (or more) useful functions that can be applied in later analyses, and we know how to manipulate the ArcPy tools to accept the data that we want to supply to them.</p></div><div class="section" title="More generalization of the functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec42"/>More generalization of the functions</h2></div></div></div><p>The other<a id="id183" class="indexterm"/> functions that we initially created to search the results, and generate the spreadsheet of results, can also be manipulated into being more generalized with a few tweaks.</p><p>If we want to generate more information about each census block within a distance to a bus stop (for example, if we had a census block dataset with income data as well as population data), we would pass to the function a list of attributes to be extracted from the final feature class. To make this possible, it would be necessary to adjust the <code class="literal">createResultDic()</code> function to accept this list of attributes:</p><div class="informalexample"><pre class="programlisting">def createResultDic(resultFC, key, values):
    dataDictionary = {}
    fields = [key]
    fields.extend(values)
    with arcpy.da.SearchCursor(resultFC, fields) as cursor:
        for row in cursor:
            busStopID = row[0]
            data = row[1:]
            if busStopID not in dataDictionary.keys():
                dataDictionary[busStopID] = [data]
            else:
                dataDictionary[busStopID].append(data)
    return dataDictionary</pre></div><p>This new version of the <code class="literal">createResultDic()</code> function will generate a list of lists (that is, the values from each row are contained within a list and are added to a master list) for each bus stop, which can then be parsed later by knowing the position of each value in the list. This solution is useful when needing to sort data into a dictionary.</p><p>However, this is an unsatisfactory way to sort the results. What if the list of fields is not passed on to the dictionary and there is no way of knowing the order of the data in the lists? Instead, we want to be able to use the functionality of Python dictionaries to sort the data by <a id="id184" class="indexterm"/>field name. In this case, we will use nested dictionaries to create lists of results accessible by the type of data they contain (that is, population, income, or another field):</p><div class="informalexample"><pre class="programlisting">def createResultDic(resultFC, key, values):
    dataDic = {}
    fields = []
   if type(key) == type((1,2)) or type(key) == type([1,2]):
            fields.extend(key)
            length = len(key)
    else:
        fields = [key]
        length = 1
    fields.extend(values)
    with arcpy.da.SearchCursor(resultFC, fields) as cursor:
        for row in cursor:
            busStopID = row[:length]
            data = row[length:]
            if busStopID not in dataDictionary.keys():

                dataDictionary[busStopID] = {}

            for counter,field in enumerate(values):
                if field not in dataDictionary[busStopID].keys():
                    dataDictionary[busStopID][field] = [data[counter]]
                else:
                    dataDictionary[busStopID][field].append(data[counter])
    return dataDictionary</pre></div><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; rFC = r'C:\Projects\PacktDB.gdb\Chapter3Results\Intersect71Census'</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; key = 'STOPID'</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; values = 'HOUSING10','POP10'</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; dic = createResultDic(rFC, key, values)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; dic[1122023]</strong></span>
</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>{'HOUSING10': [104, 62, 113, 81, 177, 0, 52, 113, 0, 104, 81, 177, 52], 'POP10': [140, 134, 241, 138, 329, 0, 118, 241, 0, 140, 138, 329, 118]}</strong></span>
</pre></div><p>In this example, the function is passed as parameters to a feature class, the <code class="literal">STOPID</code>, and the fields to be conglomerated. The <code class="literal">fields</code> variable is created to pass the required fields on to the Search Cursor. The cursor returns each row as a tuple; the first member of the tuple is <code class="literal">busStopID</code>, and the rest of the tuple is the data associated with that bus stop. The function then uses a condition to assess whether the bus stop has been previously analyzed; if not, it is added to the dictionary and assigned a second internal dictionary, which will be used to <a id="id185" class="indexterm"/>store the results associated with that stop. By using a dictionary, we can then sort through the results and assign them to the correct field to which they belong.</p><p>The previous example shows the results of requesting data for one particular bus stop (<code class="literal">1122023</code>). As there are two fields passed here, the data has been organized into two sets, and the field names are now keys for the internal dictionary. Because of this organization, we can now create averages for each field instead of just one.</p><p>Speaking of averages, we left the job of averaging the results of the search cursor analysis to the <code class="literal">createCSV()</code> function. This should also be avoided, as it reduces the usefulness of the <code class="literal">createCSV()</code> function by adding additional data manipulation duties that should be the responsibility of another function. Let's address this issue by adjusting the <code class="literal">createCSV()</code> function first:</p><div class="informalexample"><pre class="programlisting">def createCSV(data, csvname, mode ='ab'):
    with open(csvname, mode) as csvfile:
        csvwriter = csv.writer(csvfile, delimiter=',')
        csvwriter.writerow(data)</pre></div><p>This is a stripped down version of the function, but it is infinitely more useful. By adjusting the function like this, we are limiting it to only doing two things: opening the CSV file and adding a row of data to it. Because we used the <code class="literal">ab</code> mode, if the CSV file exists, we will only be adding data to it instead of writing over it (if it doesn't exist, it will be created). This adding mode can be overridden by passing <code class="literal">wb</code> as the mode, which will generate a new script each time.</p><p>Now we can sort through the results of the analysis, average them, and pass them to our new <code class="literal">createCSV</code> script. To do this, we will iterate through the dictionary created by the <code class="literal">createResultDic()</code> function:</p><div class="informalexample"><pre class="programlisting">csvname = r'C:\Projects\Output\Averages.csv'
dataKey = 'STOPID'
fields = 'HOUSING10','POP10'
dictionary = createResultDic(Intersect71Census, dataKey, fields)

header = [dataKey]
for field in fields:
    header.append(field)

createCSV(header,csvname, 'wb' )

for counter, busStop in enumerate(dictionary.keys()):
    datakeys  = dictionary[busStop]
    averages = [busStop]
    for key in datakeys:
        data = datakeys[key]
        average = sum(data)/len(data)
        averages.append(average)
    createCSV(averages,csvname)</pre></div><p>This last <a id="id186" class="indexterm"/>step shows how the CSV file is created: by iterating through the data contained in the dictionary and then averaging the values for each bus stop. Then, these averages are added to a list that contains the name of each bus stop (and the line it belongs to in this instance) and passed to the <code class="literal">createCSV()</code> function to be written into the <code class="literal">CSV</code> file.</p><p>Here is the final code. Note that I have converted many of the autogenerated comments into print statements to give some feedback on the state of the script:</p><div class="informalexample"><pre class="programlisting"># -*- coding: utf-8 -*-
# ---------------------------------------------------------------------------
# 8662_Chapter4Modified2.py
# Created on: 2014-04-22 21:59:31.00000
#   (generated by ArcGIS/ModelBuilder)
# Description: 
# Adjusted by Silas Toms
# 2014 04 23
# ---------------------------------------------------------------------------

# Import arcpy module
import arcpy
import csv

Bus_Stops = r"C:\Projects\PacktDB.gdb\SanFrancisco\Bus_Stops"
CensusBlocks2010 = r"C:\Projects\PacktDB.gdb\SanFrancisco\CensusBlocks2010"
Inbound71 = r"C:\Projects\PacktDB.gdb\Chapter4Results\Inbound71"
Inbound71_400ft_buffer = r"C:\Projects\PacktDB.gdb\Chapter4Results\Inbound71_400ft_buffer"
Intersect71Census = r"C:\Projects\PacktDB.gdb\Chapter4Results\Intersect71Census"
bufferDist = 400
bufferUnit = "Feet"
lineNames = [('71 IB', 'Ferry Plaza'),('71 OB','48th Avenue')]
sqlTemplate = "NAME = '{0}' AND BUS_SIGNAG = '{1}'"
intersected = [Inbound71_400ft_buffer, CensusBlocks2010]
dataKey = 'NAME','STOPID'
fields = 'HOUSING10','POP10'
csvname = r'C:\Projects\Output\Averages.csv'


def formatSQLMultiple(dataList, sqlTemplate, operator=" OR "):
    'a function to generate a SQL statement'
    sql = ''
    for count, data in enumerate(dataList):
        if count != len(dataList)-1:
            sql += sqlTemplate.format(*data) + operator
        else:
            sql += sqlTemplate.format(*data)
    return sql


def formatIntersect(features):
    'a function to generate an intersect string'
    formatString = ''
    for count, feature in enumerate(features):
        if count != len(features)-1:
            formatString += feature + " #;"
        else:
            formatString += feature + " #"
    return formatString



def createResultDic(resultFC, key, values):
    dataDictionary = {}
    fields = []
    if type(key) == type((1,2)) or type(key) == type([1,2]):
        fields.extend(key)
        length = len(key)
    else:
        fields = [key]
        length = 1
    fields.extend(values)
    with arcpy.da.SearchCursor(resultFC, fields) as cursor:
        for row in cursor:
            busStopID = row[:length]
            data = row[length:]
            if busStopID not in dataDictionary.keys():

                dataDictionary[busStopID] = {}

            for counter,field in enumerate(values):
                if field not in dataDictionary[busStopID].keys():
                    dataDictionary[busStopID][field] = [data[counter]]
                else:
                    dataDictionary[busStopID][field].append(data[counter])
    
    return dataDictionary

def createCSV(data, csvname, mode ='ab'):
    with open(csvname, mode) as csvfile:
        csvwriter = csv.writer(csvfile, delimiter=',')
        csvwriter.writerow(data)

 
sql = formatSQLMultiple(lineNames, sqlTemplate)
 
print 'Process: Select'
arcpy.Select_analysis(Bus_Stops, 
                      Inbound71, 
                      sql)
     
print 'Process: Buffer'
arcpy.Buffer_analysis(Inbound71, 
                      Inbound71_400ft_buffer, 
                      "{0} {1}".format(bufferDist, bufferUnit), 
                      "FULL", "ROUND", "NONE", "")
 
iString = formatIntersect(intersected)
print iString
  
print 'Process: Intersect'
arcpy.Intersect_analysis(iString, 
                          Intersect71Census, "ALL", "", "INPUT")


print 'Process Results'
dictionary = createResultDic(Intersect71Census, dataKey, fields)


print 'Create CSV'
header = [dataKey]
for field in fields:
    header.append(field)
createCSV(header,csvname, 'wb' )


for counter, busStop in enumerate(dictionary.keys()):
    datakeys  = dictionary[busStop]
    averages = [busStop]

    for key in datakeys:
        data = datakeys[key]
        average = sum(data)/len(data)
        averages.append(average)
    createCSV(averages,csvname)

print "Data Analysis Complete"</pre></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Summary</h1></div></div></div><p>In this chapter, we discussed how to take autogenerated code and make it generalized, while adding functions that can be reused in other scripts and will make the generation of the necessary code components, such as SQL statements, much easier. We also addressed when it is best not to go too far with the creation of functions to avoid making them too specific.</p><p>In the next chapter, we will investigate the powerful Data Access module and its Search Cursors, Update Cursors, and Insert Cursors.</p></div></body></html>