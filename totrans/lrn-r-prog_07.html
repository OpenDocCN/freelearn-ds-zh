<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Working with Data"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Working with Data</h1></div></div></div><p>In the previous chapters, you learned the most commonly used object types and functions to work in R. We know how to create and modify vectors, lists, and data frames, how to define our own functions and how to use proper expressions to translate our logic in mind to R code in the editor. With these objects, functions, and expressions, we can start working with data.</p><p>In this chapter, we will set out on a journey of working with data and cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Reading and writing data in a file</li><li class="listitem" style="list-style-type: disc">Visualizing data with plot functions</li><li class="listitem" style="list-style-type: disc">Analyzing data with simple statistical models and data mining tools</li></ul></div><div class="section" title="Reading and writing data"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec40"/>Reading and writing data</h1></div></div></div><p>The first step in any kind of data analysis in R is to load data, that is, to import a dataset into the environment. Before that, we have to figure out the type of data file and choose appropriate tools to read the data.</p><div class="section" title="Reading and writing text-format data in a file"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec98"/>Reading and writing text-format data in a file</h2></div></div></div><p>Among all the file types used to store data, perhaps the most widely used one is CSV. In a typical CSV file, the first line is the header of columns, and each subsequent line represents a data record with columns separated by commas. Here is an example of student records written in this format:</p><pre class="programlisting">Name,Gender,Age,Major
Ken,Male,24,Finance
Ashley,Female,25,Statistics
Jennifer,Female,23,Computer Science</pre><div class="section" title="Importing data via RStudio IDE"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec31"/>Importing data via RStudio IDE</h3></div></div></div><p>RStudio provides an interactive way to import data. You can navigate to <span class="strong"><strong>Tools</strong></span> | <span class="strong"><strong>Import Dataset</strong></span> | <span class="strong"><strong>From Local File</strong></span> and choose a local file in a text format, such as <code class="literal">.csv</code> and <code class="literal">.txt</code>. Then, you can adjust the parameters and preview the resulting data frame:</p><div class="mediaobject"><img src="graphics/image_07_001.jpg" alt="Importing data via RStudio IDE"/></div><p>Note that you should check <span class="strong"><strong>Strings as factors</strong></span> only if you intend to convert string columns to factors.</p><p>The file importer is not magic, but translates the file path and options to R code. Once you set up the data importing parameters and click on <span class="strong"><strong>Import</strong></span>, it will execute a call to <code class="literal">read.csv()</code>. Using this interactive tool to import data is very handy and will help you avoid many mistakes when you import a data file for the first time.</p></div><div class="section" title="Importing data using built-in functions"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec32"/>Importing data using built-in functions</h3></div></div></div><p>When you write a script, you can't expect the user to interact with the file importer every time. You can copy the generated code to your script so that it will automatically work each time you run the script. Therefore, it is useful to know how to use built-in functions to import data.</p><p>The simplest built-in function to import data is <code class="literal">readLines()</code>, as we mentioned in previous chapters. This function reads a text file and returns a number of lines as a character vector:</p><pre class="programlisting">readLines("data/persons.csv")&#13;
## [1] "Name,Gender,Age,Major" 
## [2] "Ken,Male,24,Finance" 
## [3] "Ashley,Female,25,Statistics" 
## [4] "Jennifer,Female,23,Computer Science"</pre><p>By default, it will read all the lines of the file. To preview the first two lines, run the following code:</p><pre class="programlisting">readLines("data/persons.csv", n = 2)&#13;
## [1] "Name,Gender,Age,Major" "Ken,Male,24,Finance"</pre><p>For practical data importing, <code class="literal">readLines()</code> is too simple in most cases. It works by reading lines as strings rather than parsing them into a data frame. If you want to import data from a CSV file like the preceding code, directly call <code class="literal">read.csv()</code>:</p><pre class="programlisting">persons1 &lt;- read.csv("data/persons.csv", stringsAsFactors = FALSE)str(persons1)&#13;
## 'data.frame': 3 obs. of 4 variables:
## $ Name : chr "Ken" "Ashley" "Jennifer"
## $ Gender: chr "Male" "Female" "Female"
## $ Age : int 24 25 23
## $ Major : chr "Finance" "Statistics" "Computer Science"</pre><p>Note that we want to keep the string value as it is, so we set <code class="literal">stringsAsFactors = FALSE</code> in the function call to avoid converting the strings to factors.</p><p>The function provides many useful arguments to customize importing. For example, we can use <code class="literal">colClasses</code> to explicitly specify the types of columns and use <code class="literal">col.names</code> to replace the original column names in the data file:</p><pre class="programlisting">persons2 &lt;- read.csv("data/persons.csv", colClasses = c("character", "factor", "integer", "character"),  col.names = c("name", "sex", "age", "major"))  str(persons2)&#13;
## 'data.frame': 3 obs. of 4 variables:
## $ name : chr "Ken" "Ashley" "Jennifer"
## $ sex : Factor w/ 2 levels "Female","Male": 2 1 1
## $ age : int 24 25 23
## $ major: chr "Finance" "Statistics" "Computer Science"</pre><p>Note that CSV is a special case of the delimited data format. Technically, the CSV format is a delimited data format that uses a comma (,) to separate columns and a new line to separate rows. More generally speaking, any character can be the column separator and row separator. Many datasets are stored in the tab-delimited format, that is, they use tab character to separate columns. In this case, you may try using <code class="literal">read.table()</code>, a more general version, based on which <code class="literal">read.csv()</code> is implemented.</p></div><div class="section" title="Importing data using the readr package"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec33"/>Importing data using the readr package</h3></div></div></div><p>For historical reasons, <code class="literal">read.*</code> functions have some inconsistencies and are not very friendly in some situations. The <code class="literal">readr</code> package is a good choice to import tabular data in a fast and consistent manner.</p><p>To install the package, run <code class="literal">install.packages("readr")</code>. You can then use a family of <code class="literal">read_*</code> functions to import tabular data:</p><pre class="programlisting">persons3 &lt;- readr::read_csv("data/persons.csv")str(persons3)&#13;
## Classes 'tbl_df', 'tbl' and 'data.frame': 3 obs. of 4 variables:
## $ Name : chr "Ken" "Ashley" "Jennifer"
## $ Gender: chr "Male" "Female" "Female"
## $ Age : int 24 25 23
## $ Major : chr "Finance" "Statistics" "Computer Science"</pre><p>Here, we use <code class="literal">readr::read_csv</code> instead of <code class="literal">library(readr)</code> first and then directly call <code class="literal">read_csv</code> because it is easy to confuse <code class="literal">read_csv</code> with the built-in <code class="literal">read.csv</code> file since they have slightly different behaviors.</p><p>Also, note that the default behavior of <code class="literal">read_csv</code> is smart enough to handle most situations. To make a contrast with built-in functions, let's import a data file (<code class="literal">data/persons.txt</code>) in an irregular format:</p><pre class="programlisting">Name     Gender Age Major
Ken      Male   24  Finance
Ashley   Female 25  Statistics
Jennifer Female 23  Computer Science</pre><p>The file content looks quite standard and tabular, but the number of spaces between each column is unequal across rows, which fails to let <code class="literal">read.table()</code> work with <code class="literal">sep = " "</code>:</p><pre class="programlisting">read.table("data/persons.txt", sep = " ")&#13;
## Error in scan(file, what, nmax, sep, dec, quote, skip, nlines, na.strings, : line 1 did not have 20 elements</pre><p>If you insist on using <code class="literal">read.table()</code> to import data, you may waste a lot of time trying to figure out the right argument to control the behavior. However, with the same input, the default behavior of <code class="literal">read_table</code> in <code class="literal">readr</code> is smart enough and thus helps you save time:</p><pre class="programlisting">readr::read_table("data/persons.txt")&#13;
##   Name     Gender Age Major
## 1 Ken      Male   24  Finance
## 2 Ashley   Female 25  Statistics
## 3 Jennifer Female 23  Computer Science</pre><p>That's why I strongly recommend that you use the functions in <code class="literal">readr</code> to import tabular data into R. The functions in <code class="literal">readr</code> are fast, smart, and consistent and support the features of the built-in functions which are much easier to use. To learn more about the <code class="literal">readr</code> package, visit <a class="ulink" href="https://github.com/hadley/readr">https://github.com/hadley/readr</a>.</p></div><div class="section" title="Writing a data frame to a file"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec34"/>Writing a data frame to a file</h3></div></div></div><p>A typical procedure in data analysis is importing data from a data source, transforming the data, applying appropriate tools and models, and finally creating some new data to be stored for decision making. The interface for writing data to file is very similar to that for reading data—we use <code class="literal">write.*</code> functions to export a data frame to a file.</p><p>For example, we can create an arbitrary data frame and store it in a CSV file:</p><pre class="programlisting">some_data &lt;- data.frame(&#13;
id = 1:4,&#13;
grade = c("A", "A", "B", NA), width = c(1.51, 1.52, 1.46, NA),check_date = as.Date(c("2016-03-05", "2016-03-06", "2016-03-10", "2016-03-11")))some_data&#13;
##   id grade width check_date
## 1 1   A    1.51  2016-03-05
## 2 2   A    1.52  2016-03-06
## 3 3   B    1.46  2016-03-10
## 4 4  &lt;NA&gt;   NA   2016-03-11&#13;
write.csv(some_data, "data/some_data.csv")</pre><p>To check whether the CSV file correctly preserves the missing values and dates, we can read the output file in raw text:</p><pre class="programlisting">cat(readLines("data/some_data.csv"), sep = "\n")&#13;
## "","id","grade","width","check_date"
## "1",1,"A",1.51,2016-03-05
## "2",2,"A",1.52,2016-03-06
## "3",3,"B",1.46,2016-03-10
## "4",4,NA,NA,2016-03-11</pre><p>Although the data is correct, sometimes we may have different standards for storing such data. The <code class="literal">write.csv()</code> function allows us to modify the writing behavior. From the preceding output, we might think there are some unnecessary components in it. For example, we don't usually want the row names to be exported because they seem a bit redundant, since id already does its job. We don't need the quotation marks around string values. We want the missing values to be represented by <code class="literal">-</code> instead of <code class="literal">NA</code>. To proceed, we can run the following code to export the same data frame with the behavior and standard we want:</p><pre class="programlisting">write.csv(some_data, "data/some_data.csv", quote =FALSE, na = "-", row.names = FALSE)</pre><p>Now, the output data is a simplified CSV file:</p><pre class="programlisting">cat(readLines("data/some_data.csv"), sep = "\n")&#13;
## id,grade,width,check_date
## 1,A,1.51,2016-03-05
## 2,A,1.52,2016-03-06
## 3,B,1.46,2016-03-10
## 4,-,-,2016-03-11</pre><p>We can use <code class="literal">readr::read_csv()</code> to import such a CSV file with customized missing values and a date column:</p><pre class="programlisting">readr::read_csv("data/some_data.csv", na = "-")&#13;
##   id grade width check_date
## 1 1   A    1.51  2016-03-05
## 2 2   A    1.52  2016-03-06
## 3 3   B    1.46  2016-03-10
## 4 4  &lt;NA&gt;   NA   2016-03-11</pre><p>Note that <code class="literal">-</code> are correctly translated to missing values and the date column is correctly imported as date objects too:</p><pre class="programlisting">## [1] TRUE</pre></div></div><div class="section" title="Reading and writing Excel worksheets"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec99"/>Reading and writing Excel worksheets</h2></div></div></div><p>An import advantage of text-format data such as CSV is software neutrality, that is, you don't have to rely on certain software to read the data and the file is directly readable by a human. However, its disadvantage is obvious too—we can't directly perform calculations on the data represented in a text editor because the contents are pure text.</p><p>Another popular format for storing tabular data is the Excel workbook. An Excel workbook contains one or more worksheets. Each worksheet is a grid where you can fill in texts and values to make tables. With the tables, you can easily perform calculations within a table, between tables, or even across worksheets. Microsoft Excel is a powerful software, but its data format (<code class="literal">.xls</code> for Excel 97-2003 and <code class="literal">.xlsx</code> since Excel 2007) is not directly readable.</p><p>For example, <code class="literal">data/prices.xlsx</code> is a simple Excel workbook as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/image_07_002.jpg" alt="Reading and writing Excel worksheets"/></div><p>Although no built-in function is provided to read an Excel workbook, several R packages are designed to work with it. The simplest one is readxl (<a class="ulink" href="https://github.com/hadley/readxl">https://github.com/hadley/readxl</a>), which makes it much easier to extract the table stored in a single sheet of an Excel workbook. To install the package from CRAN, use <code class="literal">install.package("readxl")</code>:</p><pre class="programlisting">readxl::read_excel("data/prices.xlsx")&#13;
##   Date        Price Growth&#13;
## 1 2016-03-01  85    NA&#13;
## 2 2016-03-02  88    0.03529412&#13;
## 3 2016-03-03  84   -0.04545455&#13;
## 4 2016-03-04  81   -0.03571429&#13;
## 5 2016-03-05  83    0.02469136&#13;
## 6 2016-03-06  87    0.04819277</pre><p>From the preceding data frame, it is obvious that <code class="literal">read_excel()</code> automatically translates the dates in Excel to dates in R and correctly preserves the missing value in the <code class="literal">Growth</code> column.</p><p>Another package for working with an Excel workbook is <code class="literal">openxlsx</code>. This package can read, write, and edit XLSX files, which is more comprehensive than what <code class="literal">readr</code> is designed for. To install the package, run <code class="literal">install.package("openxlsx")</code>.</p><p>With <code class="literal">openxlsx</code>, we can call <code class="literal">read.xlsx</code> to read data from a specified workbook into a data frame, just like <code class="literal">readr::read_excel()</code>:</p><pre class="programlisting">openxlsx::read.xlsx("data/prices.xlsx", detectDates = TRUE)&#13;
##   Date       Price Growth
## 1 2016-03-01  85    NA
## 2 2016-03-02  88    0.03529412
## 3 2016-03-03  84   -0.04545455
## 4 2016-03-04  81   -0.03571429
## 5 2016-03-05  83    0.02469136
## 6 2016-03-06  87    0.04819277</pre><p>To ensure that the date values are correctly imported, we need to specify <code class="literal">detectDates = TRUE</code>; otherwise, the dates will be left as numbers as you may try. In addition to reading data, <code class="literal">openxlsx</code> is also able to create a workbook with an existing data frame:</p><pre class="programlisting">openxlsx::write.xlsx(mtcars, "data/mtcars.xlsx")</pre><p>The package supports more advanced features such as editing an existing workbook by creating styles and inserting plots, but these features are beyond the scope of this book. For more details, please read the documentation of the package.</p><p>There are other packages designed for working with Excel workbooks. XLConnect (<a class="ulink" href="http://cran.r-project.org/web/packages/XLConnect">http://cran.r-project.org/web/packages/XLConnect</a>) is another Excel connector which is cross-platform and does not depend on an existing installation of Microsoft Excel, but it does rely on an existing installation of Java Runtime Environment (JRE). RODBC (<a class="ulink" href="http://cran.r-project.org/web/packages/RODBC">http://cran.r-project.org/web/packages/RODBC</a>) is a more general database connector that is able to connect to Access databases and Excel workbooks with properly installed ODBC drivers on Windows. Since these two packages have heavier dependencies, we won't introduce them in this session.</p></div><div class="section" title="Reading and writing native data files"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec100"/>Reading and writing native data files</h2></div></div></div><p>In the previous sections, we introduced the reader and writer functions of CSV files and Excel workbooks. These are non-native data formats to R, that is, there is a gap between the original data object and the output file.</p><p>For example, if we export a data frame with many columns of different types to a CSV file, the information on the column types is discarded. Whether the column is numeric, string, or date, it is always represented in text format This certainly makes it easier for a human to read the data directly from the output file, but we will have to rely on how a computer would guess the type of each column. In other words, it is sometimes hard for the reader functions to recover the data in CSV format to exactly the same data frame as the original one, since the writing process throws the column types away in exchange for portability (for example, other software can read the data too).</p><p>If you do not care for portability and only use R to work with the data, you can use the native formats to read and write data. You can no longer uses an arbitrary text editor to read the data, nor can you read the data from other software, but it is easy to write and read a single object or even the whole environment with high efficiency and no data losses. In other words, the native format allows you to save objects in file and recover exactly the same data without worrying about issues like the symbols of missing values and the types, classes and attributes of columns.</p><div class="section" title="Reading and writing a single object in native format"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec35"/>Reading and writing a single object in native format</h3></div></div></div><p>There are two groups of functions related to working with the native data format. One group is designed to write a single object to an RDS file or read a single object from an RDS file, a file format to store a single R object in serialized form. The other group works with multiple R objects, which we will cover in the next section. In the following example, we write <code class="literal">some_data</code> to an RDS file and read it from the same file and see whether two data frames are exactly identical.</p><p>First, we use <code class="literal">saveRDS</code> to save <code class="literal">some_data</code> to <code class="literal">data/some_data.rds</code>:</p><pre class="programlisting">saveRDS(some_data, "data/some_data.rds")</pre><p>Then we read the data from the same file and store the data frame in <code class="literal">some_data2</code>:</p><pre class="programlisting">some_data2 &lt;- readRDS("data/some_data.rds")</pre><p>Finally, we use <code class="literal">identical()</code> to test whether two data frames are exactly the same:</p><pre class="programlisting">identical(some_data, some_data2)&#13;
## [1] TRUE</pre><p>The two data frames are exactly the same, as supposed.</p><p>The native format has two notable advantages: space efficiency and time efficiency. In the following example, we will create a large data frame with 200,000 rows of random data. Then, we time the process for saving the data frame to a CSV file and an RDS file, respectively:</p><pre class="programlisting">rows &lt;- 200000
large_data &lt;- data.frame(id = 1:rows, x = rnorm(rows), y = rnorm(rows))system.time(write.csv(large_data, "data/large_data.csv"))&#13;
## user system elapsed 
## 1.33 0.06 1.41&#13;
system.time(saveRDS(large_data, "data/large_data.rds"))&#13;
## user system elapsed 
## 0.23 0.03 0.26</pre><p>It is obvious that <code class="literal">saveRDS</code> has much higher writing efficiency than <code class="literal">write.csv</code>.</p><p>Then we use <code class="literal">file.info()</code> to see the size of the two output files:</p><pre class="programlisting">fileinfo &lt;- file.info("data/large_data.csv", "data/large_data.rds")fileinfo[, "size", drop = FALSE]&#13;
## size
## data/large_data.csv 10442030
## data/large_data.rds 3498284</pre><p>The gap between the two file sizes is large—the size of the CSV file is almost three times that of the RDS file, indicating that the native format has higher storage or space efficiency.</p><p>Finally, we read the CSV and RDS files and see how much time both formats consume. To read the CSV file, we use both the built-in function <code class="literal">read.csv</code> and the faster implementation, <code class="literal">read_csv()</code>, provided by the <code class="literal">readr</code> package:</p><pre class="programlisting">system.time(read.csv("data/large_data.csv"))&#13;
## user system elapsed 
## 1.46 0.07 1.53&#13;
system.time(readr::read_csv("data/large_data.csv"))&#13;
## user system elapsed 
## 0.17 0.01 0.19</pre><p>It may be surprising to see that <code class="literal">read_csv()</code> is almost four times faster than the built-in <code class="literal">read.csv()</code> in this case. But with the native format, the performance of both CSV reader functions is not comparable:</p><pre class="programlisting">system.time(readRDS("data/large_data.rds"))&#13;
## user system elapsed 
## 0.03 0.00 0.03</pre><p>The native format clearly has much higher writing efficiency.</p><p>In addition, <code class="literal">saveRDS</code> and <code class="literal">readRDS</code> work not only with data frames but also with any R object. For example, we create a numeric vector with a missing value and a list with a nested structure. Then, we save them in separate RDS files:</p><pre class="programlisting">nums &lt;- c(1.5, 2.5, NA, 3)
list1 &lt;- list(x = c(1, 2, 3),  &#13;
    y = list(a =c("a", "b"), &#13;
    b = c(NA, 1, 2.5)))
saveRDS(nums, "data/nums.rds")
saveRDS(list1, "data/list1.rds")</pre><p>Now we read the RDS files, and these two objects are exactly recovered, respectively:</p><pre class="programlisting">readRDS("data/nums.rds")&#13;
## [1] 1.5 2.5 NA 3.0&#13;
readRDS("data/list1.rds")&#13;
## $x
## [1] 1 2 3
## 
## $y
## $y$a
## [1] "a" "b"
## 
## $y$b
## [1] NA 1.0 2.5</pre></div><div class="section" title="Saving and restoring the working environment"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec36"/>Saving and restoring the working environment</h3></div></div></div><p>While the RDS format is used to store a single R object, the RData format is used to store multiple R objects. We can call <code class="literal">save()</code> to store <code class="literal">some_data</code>, <code class="literal">nums</code>, and <code class="literal">list1</code> together in a single RData file:</p><pre class="programlisting">save(some_data, nums, list1, file = "data/bundle1.RData")</pre><p>To verify that the three objects are stored and can be recovered, we remove them first and call <code class="literal">load()</code> to recover the objects from the file:</p><pre class="programlisting">rm(some_data, nums, list1)&#13;
load("data/bundle1.RData")</pre><p>Now, the three objects are fully recovered:</p><pre class="programlisting">some_data&#13;
##   id grade width check_date
## 1 1   A    1.51  2016-03-05
## 2 2   A    1.52  2016-03-06
## 3 3   B    1.46  2016-03-10
## 4 4 &lt;NA&gt;    NA   2016-03-11&#13;
nums&#13;
## [1] 1.5 2.5 NA 3.0&#13;
list1&#13;
## $x
## [1] 1 2 3
## 
## $y
## $y$a
## [1] "a" "b"
## 
## $y$b
## [1] NA 1.0 2.5&#13;
## [1] TRUE TRUE TRUE TRUE TRUE TRUE</pre></div></div><div class="section" title="Loading built-in datasets"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec101"/>Loading built-in datasets</h2></div></div></div><p>In R, there are already a great number of built-in datasets. They can be easily loaded and put into use, mostly for demonstration and test purposes. The built-in datasets are mostly data frames and come with detailed specifications.</p><p>For example, iris and mtcars are probably among the most famous datasets in R. You can read the description of the datasets with <code class="literal">? iris</code> and <code class="literal">? mtcars</code>, respectively. Typically, the description is quite specific—it not only tells you what is in the data, how was it collected and formatted, and what each column means, but it also provides related sources and references. Reading the description helps you know more about the dataset.</p><p>It is extremely handy to conduct experiments on data analysis tools with built-in datasets because these datasets are immediately available once R is ready. For example, you can directly use iris and mtcars without explicitly loading them from somewhere.</p><p>The following is the view of the first six rows of iris:</p><pre class="programlisting">head(iris)&#13;
##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
## 1     5.1          3.5         1.4          0.2      setosa
## 2     4.9          3.0         1.4          0.2      setosa
## 3     4.7          3.2         1.3          0.2      setosa
## 4     4.6          3.1         1.5          0.2      setosa
## 5     5.0          3.6         1.4          0.2      setosa
## 6     5.4          3.9         1.7          0.4      setosa</pre><p>The following code shows its structure:</p><pre class="programlisting">str(iris)&#13;
## 'data.frame': 150 obs. of 5 variables:
## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...
## $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...
## $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...
## $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...
## $ Species : Factor w/ 3 levels "setosa","versicolor",..: 1 1 1 1 1 1 1 1 1 1 ...</pre><p>The structure of iris is straightforward. You can either print <code class="literal">iris</code> to see the whole data frame in the console or use <code class="literal">View(iris)</code> in a grid pane or window.</p><p>To view the first six rows of mtcars and see its structure:</p><pre class="programlisting">head(mtcars)&#13;
##                    mpg cyl disp  hp drat    wt  qsec vs am&#13;
## Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1&#13;
## Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1&#13;
## Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1&#13;
## Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0&#13;
## Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0&#13;
## Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0&#13;
##                   gear carb&#13;
## Mazda RX4            4    4&#13;
## Mazda RX4 Wag        4    4&#13;
## Datsun 710           4    1&#13;
## Hornet 4 Drive       3    1&#13;
## Hornet Sportabout    3    2&#13;
## Valiant              3    1&#13;
str(mtcars)&#13;
## 'data.frame':    32 obs. of  11 variables:&#13;
##  $ mpg : num  21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...&#13;
##  $ cyl : num  6 6 4 6 8 6 8 4 4 6 ...&#13;
##  $ disp: num  160 160 108 258 360 ...&#13;
##  $ hp  : num  110 110 93 110 175 105 245 62 95 123 ...&#13;
##  $ drat: num  3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...&#13;
##  $ wt  : num  2.62 2.88 2.32 3.21 3.44 ...&#13;
##  $ qsec: num  16.5 17 18.6 19.4 17 ...&#13;
##  $ vs  : num  0 0 1 1 0 1 0 1 1 1 ...&#13;
##  $ am  : num  1 1 1 0 0 0 0 0 0 0 ...&#13;
##  $ gear: num  4 4 4 3 3 3 3 4 4 4 ...&#13;
##  $ carb: num  4 4 1 1 2 1 4 2 2 4 ...</pre><p>As you can see, iris and mtcars are small and simple. In fact, most built-in datasets only have tens or hundreds of rows and a few columns. They are often used to demonstrate the usage of particular data analysis tools.</p><p>If you want to experiment with larger data, you may turn to some R packages that come along with datasets. For example, the most famous data visualization package, <code class="literal">ggplot2</code>, provides a dataset called diamonds, which contains the prices and other attributes of a large number of diamonds. Use?ggplot2::diamonds to know more about the data specification. If you don't have the package installed, run <code class="literal">install.package("ggplot2")</code>.</p><p>To load the data in the package, we can use <code class="literal">data()</code>:</p><pre class="programlisting">data("diamonds", package = "ggplot2")dim(diamonds)&#13;
## [1] 53940 10</pre><p>The output shows that diamonds has <code class="literal">53940</code> rows and <code class="literal">10</code> columns. Here is a preview:</p><pre class="programlisting">head(diamonds)&#13;
##   carat       cut color clarity depth table price    x    y&#13;
## 1  0.23     Ideal     E     SI2  61.5    55   326 3.95 3.98&#13;
## 2  0.21   Premium     E     SI1  59.8    61   326 3.89 3.84&#13;
## 3  0.23      Good     E     VS1  56.9    65   327 4.05 4.07&#13;
## 4  0.29   Premium     I     VS2  62.4    58   334 4.20 4.23&#13;
## 5  0.31      Good     J     SI2  63.3    58   335 4.34 4.35&#13;
## 6  0.24 Very Good     J    VVS2  62.8    57   336 3.94 3.96&#13;
##      z&#13;
## 1 2.43&#13;
## 2 2.31&#13;
## 3 2.31&#13;
## 4 2.63&#13;
## 5 2.75&#13;
## 6 2.48</pre><p>Besides packages that provide useful functions, there are also packages that only provide datasets. For example, nycflights13 and babynames each only contains several datasets. The method to load the data in them is exactly the same as the previous example. To install the two packages, run <code class="literal">install.package(c("nycflights13", "babynames"))</code>.</p><p>In the next few sections, we will use these datasets to demonstrate basic graphic tools and data analysis tools.</p></div></div></div>
<div class="section" title="Visualizing data"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec41"/>Visualizing data</h1></div></div></div><p>In the previous section, we introduced a number of functions to import data, the first step in most data analysis. It is usually a good practice to look at the data before pouring it into a model, so that is what we will do in the next step. The reason is simple—different models have different strengths, and no model is universally the best choice for all cases since they have a different set of assumptions. Arbitrarily applying a model without checking the data against its assumptions usually results in misleading conclusions.</p><p>An initial way to choose a model and perform such checks is to just visually examine the data by looking at its boundaries and patterns. In other words, we need to visualize the data first. In this section, you will learn the basic graphic functions to produce simple charts to visualize a given dataset.</p><p>We will use the datasets in the <code class="literal">nycflights13</code> and <code class="literal">babynames</code> packages. If you don't have them installed, run the following code:</p><pre class="programlisting">install.package(c("nycflights13", "babynames"))</pre><div class="section" title="Creating scatter plots"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec102"/>Creating scatter plots</h2></div></div></div><p>In R, the basic function to visualize data is <code class="literal">plot()</code>. If we simply provide a numeric or integer vector to <code class="literal">plot()</code>, it will produce a scatter plot of value by index. For example, the following code creates a scatter plot of 10 points in the increasing order:</p><pre class="programlisting">plot(1:10)</pre><p>The plot generated is as follows:</p><div class="mediaobject"><img src="graphics/image_07_003.jpg" alt="Creating scatter plots"/></div><p>We can create a more realistic scatter plot by generating two linearly correlated random numeric vectors:</p><pre class="programlisting">x &lt;- rnorm(100)
y &lt;- 2 * x + rnorm(100)&#13;
plot(x, y)&#13;</pre><p>The plot generated is as follows:</p><div class="mediaobject"><img src="graphics/image_07_004.jpg" alt="Creating scatter plots"/></div><div class="section" title="Customizing chart elements"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec37"/>Customizing chart elements</h3></div></div></div><p>In a plot, there are numerous chart elements that can be customized. The most common elements to be specified are the title (main or <code class="literal">title()</code>), the label of the <span class="emphasis"><em>x</em></span> axis (<code class="literal">xlab</code>), the label of the <span class="emphasis"><em>y</em></span> axis (<code class="literal">ylab</code>), the range of the <span class="emphasis"><em>x</em></span> axis (<code class="literal">xlim</code>), and the range of the <span class="emphasis"><em>y</em></span> axis (<code class="literal">ylim</code>):</p><pre class="programlisting">plot(x, y,&#13;
  main = "Linearly correlated random numbers",
  xlab = "x", ylab = "2x + noise",
  xlim = c(-4, 4), ylim = c(-4, 4))</pre><p>The plot generated is as follows:</p><div class="mediaobject"><img src="graphics/image_07_005.jpg" alt="Customizing chart elements"/></div><p>The chart title can be specified by either the main argument or a separate <code class="literal">title()</code> function call. Therefore, the preceding code is equivalent to the following code:</p><pre class="programlisting">plot(x, y,
   xlim = c(-4, 4), ylim = c(-4, 4),
   xlab = "x", ylab = "2x + noise")
 title("Linearly correlated random numbers")</pre></div><div class="section" title="Customizing point styles"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec38"/>Customizing point styles</h3></div></div></div><p>The default point style of a scatter plot is a circle. By specifying the <code class="literal">pch</code> argument (plotting character), we can change the point style. There are 26 point styles available:</p><pre class="programlisting">plot(0:25, 0:25, pch = 0:25,
   xlim = c(-1, 26), ylim = c(-1, 26),
   main = "Point styles (pch)")&#13;
text(0:25+1, 0:25, 0:25)</pre><div class="mediaobject"><img src="graphics/image_07_006.jpg" alt="Customizing point styles"/></div><p>The preceding code produces a scatter plot of all point styles available with the corresponding <code class="literal">pch</code> numbers printed beside. First, <code class="literal">plot()</code> creates a simple scatter plot, and then <code class="literal">text()</code> prints the <code class="literal">pch</code> numbers on the right side of each point.</p><p>Like many other built-in functions, <code class="literal">plot()</code> is vectorized with respect to <code class="literal">pch</code> and several other arguments. It makes it possible to customize the style of each point in the scatter plot. For example, the simplest case is that we use only one non-default point style for all points by setting <code class="literal">pch = 16</code>:</p><pre class="programlisting">x &lt;- rnorm(100)
y &lt;- 2 * x + rnorm(100)
plot(x, y, pch = 16,&#13;
  main = "Scatter plot with customized point style")</pre><p>The plot generated is as follows:</p><div class="mediaobject"><img src="graphics/image_07_007.jpg" alt="Customizing point styles"/></div><p>Sometimes, we need to distinguish two groups of points by a logical condition. Knowing that <code class="literal">pch</code> is vectorized, we can use <code class="literal">ifelse()</code> to specify the point style of each observation by examining whether a point satisfies the condition. In the following example, we want to apply <code class="literal">pch = 16</code> to the points satisfying <code class="literal">x * y &gt; 1</code> otherwise, <code class="literal">pch = 1</code>:</p><pre class="programlisting">plot(x, y,
   pch = ifelse(x * y &gt; 1, 16, 1),
   main = "Scatter plot with conditional point styles")</pre><p>The plot generated is as follows:</p><div class="mediaobject"><img src="graphics/image_07_009.jpg" alt="Customizing point styles"/></div><p>We can also draw the points in two separate datasets that share the same x axis using <code class="literal">plot()</code> and <code class="literal">points()</code>. In the previous example, we generated a normally distributed random vector <code class="literal">x</code> and a linearly correlated random vector <code class="literal">y</code>. Now, we generate another random vector <code class="literal">z</code> that has a non-linear relationship with <code class="literal">x</code> and plot both <code class="literal">y</code> and <code class="literal">z</code> against <code class="literal">x</code> but with different point styles:</p><pre class="programlisting">z &lt;- sqrt(1 + x ^ 2) + rnorm(100)
plot(x, y, pch = 1,
   xlim = range(x), ylim = range(y, z),
   xlab = "x", ylab = "value")
points(x, z, pch = 17)
title("Scatter plot with two series")</pre><p>The plot generated is as follows:</p><div class="mediaobject"><img src="graphics/image_07_010.jpg" alt="Customizing point styles"/></div><p>After we generate <code class="literal">z</code>, we create a plot of <code class="literal">x</code> and <code class="literal">y</code> first, and then add another group of points <code class="literal">z</code> with a different <code class="literal">pch</code>. Note that if we don't specify <code class="literal">ylim = range(y, z)</code>, the plot builder will only consider the range of <code class="literal">y</code>, and the <span class="emphasis"><em>y</em></span> axis may have a range narrower than the range of <code class="literal">z</code>. Unfortunately, <code class="literal">points()</code> does not automatically lengthen the axes created by <code class="literal">plot()</code>, therefore any point beyond the axes' range will disappear. The preceding code sets an appropriate range of <span class="emphasis"><em>y</em></span> axis so that all points in <code class="literal">y</code> and <code class="literal">z</code> can be shown in the plot area.</p></div><div class="section" title="Customizing point colors"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec39"/>Customizing point colors</h3></div></div></div><p>If the graphics are not limited to gray-scale printing, we may also use different point colors by setting the column of <code class="literal">plot()</code>:</p><pre class="programlisting">plot(x, y, pch = 16, col = "blue",
   main = "Scatter plot with blue points")</pre><p>The plot generated is as follows:</p><div class="mediaobject"><img src="graphics/image_07_011.jpg" alt="Customizing point colors"/></div><p>Like <code class="literal">pch</code>, <code class="literal">col</code> is also a vectorized argument. With the same method, we can apply different colors to separate points into two different categories depending on whether they satisfy a certain condition:</p><pre class="programlisting">plot(x, y, pch = 16, &#13;
  col = ifelse(y &gt;= mean(y), "red", "green"),&#13;
  main = "Scatter plot with conditional colors")</pre><p>The plot generated is as follows:</p><div class="mediaobject"><img src="graphics/image_07_012.jpg" alt="Customizing point colors"/></div><p>Note that if the scatter plot is printed grayscale, the colors can only be viewed as different intensities of grayness.</p><p>Also, we can use <code class="literal">plot()</code> and <code class="literal">points()</code> again, but with different <code class="literal">col</code> to distinguish different groups of points:</p><pre class="programlisting">plot(x, y, col = "blue", pch = 0,
  xlim = range(x), ylim = range(y, z),
  xlab = "x", ylab = "value")
points(x, z, col = "red", pch = 1)
title("Scatter plot with two series")</pre><p>The plot generated is as follows:</p><div class="mediaobject"><img src="graphics/image_07_013.jpg" alt="Customizing point colors"/></div><p>R supports commonly used color names and many others (657 in total). Call <code class="literal">colors()</code> to get a full list of colors supported by R.</p></div></div><div class="section" title="Creating line plots"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec103"/>Creating line plots</h2></div></div></div><p>For time series data, line plots are more useful to demonstrate the trend and variation across time. To create line plots, we only need to set <code class="literal">type = "l"</code> when calling <code class="literal">plot()</code>:</p><pre class="programlisting">t &lt;- 1:50
y &lt;- 3 * sin(t * pi / 60) + rnorm(t)
plot(t, y, type = "l",
   main = "Simple line plot")</pre><p>The plot generated is as follows:</p><div class="mediaobject"><img src="graphics/image_07_014.jpg" alt="Creating line plots"/></div><div class="section" title="Customizing line type and width"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec40"/>Customizing line type and width</h3></div></div></div><p>Just like <code class="literal">pch</code> for scatter plot, <code class="literal">lty</code> is used to specify the line type of a line plot. The following shows a preview of six line types supported by R:</p><pre class="programlisting">lty_values &lt;- 1:6
plot(lty_values, type = "n", axes = FALSE, ann = FALSE)
abline(h =lty_values, lty = lty_values, lwd = 2
mtext(lty_values, side = 2, at = lty_values)
title("Line types (lty)")</pre><p>The plot generated is as follows:</p><div class="mediaobject"><img src="graphics/image_07_015.jpg" alt="Customizing line type and width"/></div><p>The preceding code creates an empty canvas with <code class="literal">type = "n"</code> with proper axes ranges and turns off axes, and another label <code class="literal">elements.abline()</code> is used to draw the horizontal lines with different line types but of equal line width (<code class="literal">lwd = 2</code>). The <code class="literal">mtext()</code> function is used to draw the text on the margin. Note that <code class="literal">abline()</code> and <code class="literal">mtext()</code> are vectorized with respect to their arguments so that we don't need a <code class="literal">for</code> loop  to draw each line and margin text in turn.</p><p>The following example demonstrates how <code class="literal">abline()</code> can be useful to draw auxiliary lines in a plot. First, we create a line plot of <code class="literal">y</code> with time, <code class="literal">t</code>, which we defined before we created the first line plot a moment ago. Suppose we also want the plot to show the mean value and the range of <code class="literal">y</code> along with the time at which the maximal and minimal values appear. With <code class="literal">abline()</code>, we can easily draw these auxiliary lines with different line types and colors to avoid ambiguity:</p><pre class="programlisting">plot(t, y, type = "l", lwd = 2)
abline(h = mean(y), lty = 2, col = "blue")
abline(h = range(y), lty = 3, col = "red")
abline(v = t[c(which.min(y), which.max(y))], lty = 3, col = "darkgray")
title("Line plot with auxiliary lines")</pre><p>The plot generated is as follows:</p><div class="mediaobject"><img src="graphics/image_07_016.jpg" alt="Customizing line type and width"/></div></div><div class="section" title="Plotting lines in multiple periods"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec41"/>Plotting lines in multiple periods</h3></div></div></div><p>Another kind of line plot in which different line types are mixed is a multi-period line plot. A typical form is that the first period is historic data and the second period is predictions. Suppose the first period of <code class="literal">y</code> includes the first 40 observations and the remaining points are predictions based on the historic data. We want to use solid lines to represent the historic data and dashed lines for the predictions. Here, we plot the data in the first period and add dashed <code class="literal">lines()</code> for the data in the second period of the plot. Note that <code class="literal">lines()</code> is to a line plot as <code class="literal">points()</code> is to a scatter plot:</p><pre class="programlisting">p &lt;- 40
plot(t[t &lt;= p], y[t &lt;= p], type = "l",
   xlim = range(t), xlab = "t")
lines(t[t &gt;= p], y[t &gt;= p], lty = 2)
title("Simple line plot with two periods")</pre><p>The plot generated is as follows:</p><div class="mediaobject"><img src="graphics/image_07_017.jpg" alt="Plotting lines in multiple periods"/></div></div><div class="section" title="Plotting lines with points"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec42"/>Plotting lines with points</h3></div></div></div><p>Sometimes, it is useful to plot both lines and points in the same chart to emphasize that the observations are discrete or simply make the chart clearer. The method is simple, just plot a line chart and add <code class="literal">points()</code> of the same data to the plot again:</p><pre class="programlisting">plot(y, type = "l")
points(y, pch = 16)
title("Lines with points")</pre><p>The plot generated is shown as follows:</p><div class="mediaobject"><img src="graphics/image_07_018.jpg" alt="Plotting lines with points"/></div><p>An equivalent way to do this is to plot a scatter chart first using the <code class="literal">plot()</code> function and then add lines using the <code class="literal">lines()</code> function of the same data to the plot again. Therefore, the following code should produce exactly the same graphics as the previous example:</p><pre class="programlisting">plot(y, pch = 16)
lines(y)
title("Lines with points")</pre></div><div class="section" title="Plotting a multi-series chart with a legend"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec43"/>Plotting a multi-series chart with a legend</h3></div></div></div><p>The full version of a multi-series chart should include multiple series represented by lines and points, and a legend to illustrate the series in the chart.</p><p>The following code randomly generates two series, <code class="literal">y</code> and <code class="literal">z</code>, with time, <code class="literal">x</code>, and creates a chart with these put together:</p><pre class="programlisting">x &lt;- 1:30
y &lt;- 2 * x + 6 * rnorm(30)
z &lt;- 3 * sqrt(x) + 8 * rnorm(30)&#13;
plot(x, y, type = "l",
   ylim = range(y, z), col = "black")
points(y, pch = 15)
lines(z, lty = 2, col = "blue")
points(z, pch = 16, col = "blue")
title ("Plot of two series")&#13;
legend("topleft",&#13;
  legend = c("y", "z"),
  col = c("black", "blue"),&#13;
  lty = c(1, 2), pch = c(15, 16),
  cex = 0.8, x.intersp = 0.5, y.intersp = 0.8)</pre><p>The plot generated is as follows:</p><div class="mediaobject"><img src="graphics/image_07_019.jpg" alt="Plotting a multi-series chart with a legend"/></div><p>The preceding code uses <code class="literal">plot()</code> to create the line-point chart of <code class="literal">y</code> and adds the <code class="literal">lines()</code> and <code class="literal">points()</code> of <code class="literal">z</code>. In the end, we add a <code class="literal">legend()</code> on the top left to demonstrate the line and point styles of <code class="literal">y</code> and <code class="literal">z</code>, respectively. Note that <code class="literal">cex</code> is used to scale the font sizes of the legend and <code class="literal">x.intersp</code> and <code class="literal">y.intersp</code> are used for minor adjustments to the legend.</p><p>Another useful type of line plot is step-lines. We use <code class="literal">type = "s"</code> in <code class="literal">plot()</code> and <code class="literal">lines()</code> to create a step-line plot:</p><pre class="programlisting">plot(x, y, type = "s",&#13;
  main = "A simple step plot")</pre><p>The plot generated is as follows:</p><div class="mediaobject"><img src="graphics/image_07_020.jpg" alt="Plotting a multi-series chart with a legend"/></div></div></div><div class="section" title="Creating bar charts"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec104"/>Creating bar charts</h2></div></div></div><p>In the previous sections, you learned how to create scatter plots and line plots. There are several other types of charts that are useful and worth mentioning. Bar charts are among the most commonly used ones. The height of bars in a bar chart can make a constrast quantitatively between different categories.</p><p>The simplest bar chart we can create is the following one. Here, we use <code class="literal">barplot()</code> instead of <code class="literal">plot()</code>:</p><pre class="programlisting">barplot(1:10, names.arg = LETTERS[1:10])</pre><p>The plot generated is as follows:</p><div class="mediaobject"><img src="graphics/image_07_021.jpg" alt="Creating bar charts"/></div><p>If the numeric vector has names, the names will automatically be the names on the <span class="emphasis"><em>x</em></span> axis. Therefore, the following code will produce exactly the same bar chart as the previous one:</p><pre class="programlisting">ints &lt;- 1:10&#13;
names(ints) &lt;- LETTERS[1:10]
barplot(ints)</pre><p>The making of a bar chart looks so easy. Now that we have the flights dataset in <code class="literal">nycflights13</code>, we can create a bar plot of the top eight carriers with the most flights in the record:</p><pre class="programlisting">data("flights", package = "nycflights13")&#13;
carriers &lt;- table(flights$carrier)&#13;
carriers&#13;
## &#13;
##    9E    AA    AS    B6    DL    EV    F9    FL    HA    MQ &#13;
## 18460 32729   714 54635 48110 54173   685  3260   342 26397 &#13;
##    OO    UA    US    VX    WN    YV &#13;
##    32 58665 20536  5162 12275   601</pre><p>In the preceding code, <code class="literal">table()</code> is used to count the number of flights in the record for each carrier:</p><pre class="programlisting">sorted_carriers &lt;- sort(carriers, decreasing = TRUE)&#13;
sorted_carriers&#13;
## &#13;
##    UA    B6    EV    DL    AA    MQ    US    9E    WN    VX &#13;
## 58665 54635 54173 48110 32729 26397 20536 18460 12275  5162 &#13;
##    FL    AS    F9    YV    HA    OO &#13;
##  3260   714   685   601   342    32</pre><p>As shown in the preceding code, the carriers are sorted in descending order. We can take the first <code class="literal">8</code> elements out of the table and make a bar plot:</p><pre class="programlisting">barplot(head(sorted_carriers, 8),
   ylim = c(0, max(sorted_carriers) * 1.1),
   xlab = "Carrier", ylab = "Flights",
   main ="Top 8 carriers with the most flights in record")</pre><p>The plot generated is as follows:</p><div class="mediaobject"><img src="graphics/image_07_022.jpg" alt="Creating bar charts"/></div></div><div class="section" title="Creating pie charts"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec105"/>Creating pie charts</h2></div></div></div><p>Another useful chart is the pie chart. The function to create a pie chart, <code class="literal">pie()</code>, works in a way similar to <code class="literal">barplot()</code>. It works with a numeric vector with labels specified; it also works directly with a named numeric vector. The following code is a simple example:</p><pre class="programlisting">grades &lt;- c(A = 2, B = 10, C = 12, D = 8)
pie(grades, main = "Grades", radius = 1)</pre><p>The plot generated is as follows:</p><div class="mediaobject"><img src="graphics/image_07_023.jpg" alt="Creating pie charts"/></div></div><div class="section" title="Creating histogram and density plots"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec106"/>Creating histogram and density plots</h2></div></div></div><p>Previously, you learned how to create several different types of charts. Scatter plots and line plots are direct illustrations of the observations in a dataset. Bar charts and pie charts are usually used to show a rough summary of data points in different categories.</p><p>They are two limitations to plots: scatter plots and line plots convey too much information and are difficult to draw insights from, while bar charts and pie charts drop too much information, so with these too it can be difficult to make a conclusive judgement with confidence.</p><p>A histogram shows the distribution of a numeric vector, and it summarizes the information in the data without dropping too much and thus can be easier to make use of. The following example demonstrates how to use <code class="literal">hist()</code> to produce a histogram of a normally distributed random numeric vector and the density function of normal distribution:</p><pre class="programlisting">random_normal &lt;- norm(10000)
hist(random_normal)</pre><p>The plot generated is as follows:</p><div class="mediaobject"><img src="graphics/image_07_024.jpg" alt="Creating histogram and density plots"/></div><p>By default, the <span class="emphasis"><em>y</em></span> axis of a histogram is the frequency of the value in the data. We can verify that the histogram is quite close to the standard normal distribution from which <code class="literal">random_normal</code> was generated. To overlay the curve of a probability density function of the standard normal distribution, <code class="literal">dnorm()</code>, we need to ensure that the <span class="emphasis"><em>y</em></span> axis of the histogram is a probability and the curve is to be added to the histogram:</p><pre class="programlisting">hist(random_normal, probability = TRUE, col = "lightgray")&#13;
curve(dnorm, add = TRUE, lwd = 2, col ="blue")</pre><p>The plot generated is as follows:</p><div class="mediaobject"><img src="graphics/image_07_025.jpg" alt="Creating histogram and density plots"/></div><p>Now, let's make a histogram of the speed of an aircraft in flight. Basically, the average speed of an aircraft in a trip is the distance of the trip (<code class="literal">distance</code>) divided by the air time (<code class="literal">air_time</code>):</p><pre class="programlisting">flight_speed &lt;- flights$distance / flights$air_time
hist(flight_speed, main = "Histogram of flight speed")</pre><p>The plot generated is as follows:</p><div class="mediaobject"><img src="graphics/image_07_026.jpg" alt="Creating histogram and density plots"/></div><p>The histogram seems a bit different from a normal distribution. In this case, we use <code class="literal">density()</code> to estimate an empirical distribution of the speed, plot a pretty smooth probability distribution curve out of it, and add a vertical line to indicate the global average of all observations:</p><pre class="programlisting">plot(density(flight_speed, from = 2, na.rm = TRUE),
   main ="Empirical distribution of flight speed")
abline(v = mean(flight_speed, na.rm = TRUE),
   col = "blue", lty = 2)</pre><p>The plot generated is as follows:</p><div class="mediaobject"><img src="graphics/image_07_027.jpg" alt="Creating histogram and density plots"/></div><p>Just like the first histogram and curve example, we can combine the two graphics together to get a better view of the data:</p><pre class="programlisting">hist(flight_speed, &#13;
  probability = TRUE, ylim = c(0, 0.5), &#13;
  main ="Histogram and empirical distribution of flight speed",
  border ="gray", col = "lightgray")
lines(density(flight_speed, from = 2, na.rm = TRUE),
  col ="darkgray", lwd = 2)&#13;
abline(v = mean(flight_speed, na.rm = TRUE),
   col ="blue", lty =2)</pre><p>The plot generated is as follows:</p><div class="mediaobject"><img src="graphics/image_07_028.jpg" alt="Creating histogram and density plots"/></div></div><div class="section" title="Creating box plots"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec107"/>Creating box plots</h2></div></div></div><p>Histograms and density plots are two ways to demonstrate the distribution of data. Usually, we only need several critical quantiles to get an impression of the whole distribution. The box plot (or box-and-whisker plot) is a simple way to do this. For a randomly generated numeric vector, we can call <code class="literal">boxplot()</code> to draw a box plot:</p><pre class="programlisting">x &lt;- rnorm(1000)
boxplot(x)</pre><p>The plot generated is as follows:</p><div class="mediaobject"><img src="graphics/image_07_029.jpg" alt="Creating box plots"/></div><p>A box plot contains several components to show critical quartile levels of data as well as outliers. The following image clearly explains what a box plot means:</p><div class="mediaobject"><img src="graphics/image_07_030.jpg" alt="Creating box plots"/></div><p>The following code draws a box plot of the flight speed for each carrier. There will be 16 boxes in one chart, making it easier to roughly compare the distribution of different carriers. To proceed, we use the formula <span class="emphasis"><em>distance /air_time ~carrier</em></span> to indicate that the <span class="emphasis"><em>y </em></span>axis denotes the flight speed computed from <span class="emphasis"><em>distance / air_time</em></span>, and the <span class="emphasis"><em>x </em></span>axis denotes the carrier. With this representation, we have the following box plot:</p><pre class="programlisting">boxplot(distance / air_time ~ carrier, data =flights,&#13;
  main = "Box plot of flight speed by carrier")</pre><p>The plot generated is as follows:</p><div class="mediaobject"><img src="graphics/image_07_031.jpg" alt="Creating box plots"/></div><p>Note that we use the formula interface of creating graphics in <code class="literal">boxplot()</code>. Here, <span class="emphasis"><em>distance / air_time ~ carrier</em></span> basically means the <span class="emphasis"><em>y</em></span> axis should represent the values of <span class="emphasis"><em>distance / air_time</em></span>, that is, flight speed, and the <span class="emphasis"><em>x </em></span>axis should represent different carriers. <span class="emphasis"><em>data = flights</em></span> tells <span class="emphasis"><em>boxplot()</em></span> where to find the symbols in the formula we specify. As a result, the box plot of flight speed is created and grouped by carrier.</p><p>The formula interface of visualizing and analyzing data is very expressive and powerful. In the next section, we will introduce some basic tools and models to analyze data. Behind the functions that implement these tools and models are not only algorithms but also a user-friendly interface (formula) to make it easier to specify relationships for the model to fit.</p><p>There are also other packages that are specially tailored for data visualization. One great example is <code class="literal">ggplot2</code>, which implements a very powerful grammar of graphics to create, compose, and customize different types of charts. However, it is beyond the scope of this book. To know more, I recommend that you read <span class="emphasis"><em>ggplot2: Elegant Graphics for Data Analysis</em></span> by Hadley Wickham.</p></div></div>
<div class="section" title="Analyzing data"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec42"/>Analyzing data</h1></div></div></div><p>In practical data analysis, most time is spent on data cleansing, that is, to filter and transform the original data (or raw data) to a form that is easier to analyze. The filtering and transforming process is also called data manipulation. We will dedicate an entire chapter to this topic.</p><p>In this section, we directly assume that the data is ready for analysis. We won't go deep into the models, but will apply some simple models to leave you an impression of how to fit a model with data, how to interact with fitted models, and how to apply a fitted model to make predictions.</p><div class="section" title="Fitting a linear model"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec108"/>Fitting a linear model</h2></div></div></div><p>The simplest model in R is the linear model, that is, we use a linear function to describe the relationship between two random variables under a certain set of assumptions. In the following example, we will create a linear function that maps <span class="emphasis"><em>x</em></span>to <span class="emphasis"><em>3 + 2 * x</em></span>. Then we generate a normally-distributed random numeric vector <code class="literal">x</code>, and generate <code class="literal">y</code> by <code class="literal">f(x)</code> plus some independent noise:</p><pre class="programlisting">f &lt;- function(x) 3 + 2 * x
x &lt;- rnorm(100)
y &lt;- f(x) + 0.5 * rnorm(100)</pre><p>If we pretend not to know how <code class="literal">y</code> is generated by <code class="literal">x</code>, can we use a linear model to recover their relationship, that is, to recover the coefficient of the linear function? The following code uses <code class="literal">slm()</code> to fit <code class="literal">x</code> and <code class="literal">y</code> with a linear model. Note that a formula <span class="emphasis"><em>y ~ x</em></span> is an accessible representation to tell <code class="literal">m()</code> that the linear regression is between the dependent variable <code class="literal">y</code> and a single regressor <code class="literal">x</code>:</p><pre class="programlisting">model1 &lt;- lm(y ~ x)model1&#13;
## 
## Call:
## lm(formula = y ~ x)
## 
## Coefficients:
## (Intercept) x 
##   2.969    1.972</pre><p>The true coefficients are 3 (intercept) and 2 (slope), and with the sample data <code class="literal">x</code> and <code class="literal">y</code>, the fitted model has coefficients <code class="literal">2.9692146</code> (intercept) and <code class="literal">1.9716588</code> (slope), which are quite close to the true coefficients.</p><p>We store the model in <code class="literal">model1</code>. To access the coefficients of the model, we can use the following code:</p><pre class="programlisting">coef(model1)&#13;
## (Intercept)   x 
##  2.969215   1.971659</pre><p>Alternatively, we can use the <code class="literal">model1$</code> coefficients, since <code class="literal">model1</code> is essentially a list.</p><p>Then, we can call <code class="literal">summary()</code> to know more about the statistical properties of the linear model:</p><pre class="programlisting">summary(model1)&#13;
## &#13;
## Call:&#13;
## lm(formula = y ~ x)&#13;
## &#13;
## Residuals:&#13;
##      Min       1Q   Median       3Q      Max &#13;
## -0.96258 -0.31646 -0.04893  0.34962  1.08491 &#13;
## &#13;
## Coefficients:&#13;
##             Estimate Std. Error t value Pr(&gt;|t|)    &#13;
## (Intercept)  2.96921    0.04782    62.1   &lt;2e-16 ***&#13;
## x            1.97166    0.05216    37.8   &lt;2e-16 ***&#13;
## ---&#13;
## Signif. codes:  &#13;
## 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1&#13;
## &#13;
## Residual standard error: 0.476 on 98 degrees of freedom&#13;
## Multiple R-squared:  0.9358, Adjusted R-squared:  0.9352 &#13;
## F-statistic:  1429 on 1 and 98 DF,  p-value: &lt; 2.2e-16</pre><p>To interpret the summary, you had better review the chapter on linear regression in one or two textbooks of statistics. The following plot puts the data and the fitted model together:</p><pre class="programlisting">plot(x, y, main = "A simple linear regression")
abline(coef(model1), col = "blue")</pre><p>The plot generated is shown as follows:</p><div class="mediaobject"><img src="graphics/image_07_032.jpg" alt="Fitting a linear model"/></div><p>In the preceding code, we directly supply a two-element numeric vector of estimated regression coefficients to <code class="literal">abline()</code>, so it smartly draws the regression line as supposed.</p><p>Then, we can call <code class="literal">predict()</code> to use the fitted model to make predictions. To predict <code class="literal">y</code> with standard errors when <code class="literal">x = -1</code> and <code class="literal">x = 0.5</code>, run the following code:</p><pre class="programlisting">predict(model1, list(x = c(-1, 0.5)), se.fit = TRUE)&#13;
## $fit
## 1         2 
## 0.9975559 3.9550440 
## 
## $se.fit
## 1          2 
## 0.06730363 0.05661319 
## 
## $df
## [1] 98
## 
## $residual.scale
## [1] 0.4759621</pre><p>The prediction result is a list of predicted values of <code class="literal">y</code> (<code class="literal">$fit</code>), the standard errors of the fitted values (<code class="literal">$se.fit</code>), the degree of freedom (<code class="literal">$df</code>), and <code class="literal">$residual.scale</code>.</p><p>Now that you know the basics of how to fit a linear model given some data, it is time to look at some real-world data. In the following examples, we try to predict the air time of a flight using linear models of different complexity. The most obvious variable that should be helpful to predict air time is distance.</p><p>First, we load the dataset and make a scatter plot of distance and <code class="literal">air_time</code>. We use <code class="literal">pch = "."</code> to make each point very small, since the number of records in the dataset is large:</p><pre class="programlisting">data("flights", package = "nycflights13")
plot(air_time ~ distance, data = flights,
  pch = ".", &#13;
  main = "flight speed plot")</pre><p>The plot generated is as follows:</p><div class="mediaobject"><img src="graphics/image_07_033.jpg" alt="Fitting a linear model"/></div><p>The plot clearly suggests that distance and <code class="literal">air_time</code> has a positive correlation. So, it is reasonable to fit a linear model between the two variables.</p><p>Before pouring the whole dataset into a linear model, we divide the dataset into two parts: a training set and a testing set. The purpose of dividing the dataset is that we want to perform not only sample evaluation but also out-of-sample evaluation of the model. More specifically, we put 75% of the data to the training set, and the remaining 25% of data to the testing set. In the following code, we use <code class="literal">sample()</code> to draw a random sample of 75% records from the original data and use <code class="literal">setdiff()</code> to get the rest of the records:</p><pre class="programlisting">rows &lt;- nrow(flights)
rows_id &lt;- 1:rows
sample_id &lt;- sample(rows_id, rows * 0.75, replace = FALSE)
flights_train &lt;- flights[sample_id,]
flights_test &lt;- flights[setdiff (rows_id, sample_id), ]</pre><p>Note that <code class="literal">setdiff(rows_id, sample_id)</code> returns the indices in <code class="literal">rows_id</code> but not in <code class="literal">sample_id</code>.</p><p>Now <code class="literal">flights_train</code> is the training set and <code class="literal">flights_test</code> is the testing set. With the divided datasets, the procedure of model fitting and model evaluation is straightforward. First, use the training set to fit the model, then make an in-sample prediction to see the magnitude of the in-sample errors:</p><pre class="programlisting">model2 &lt;- lm(air_time ~ distance, data = flights_train)
predict2_train &lt;- predict(model2, flights_train)
error2_train &lt;- flights_train$air_time - predict2_train</pre><p>To evaluate the magnitude of the errors, we define a function named <code class="literal">evaluate_error()</code> to calculate the mean absolute errors and the standard deviation of errors:</p><pre class="programlisting">evaluate_error &lt;- function(x) {&#13;
  c(abs_err = mean(abs(x), na.rm = TRUE),
  std_dev = sd(x, na.rm = TRUE))
  }</pre><p>Using this function, we can evaluate the errors of the in-sample predictions of <code class="literal">model2</code>:</p><pre class="programlisting">evaluate_error(error2_train)&#13;
## abs_err  std_dev 
## 9.413836 12.763126</pre><p>The absolute mean errors indicate that on average the prediction deviates from the correct value by around 9.45 minutes in absolute value and has a standard deviation of 12.8 minutes.</p><p>Then, we perform a simple out-of-sample evaluation by using the model to predict on the testing set:</p><pre class="programlisting">predict2_test &lt;- predict (model2, flights_test)
error2_test &lt;- flights_test$air_time - predict2_test
evaluate_error(error2_test)&#13;
## abs_err std_dev 
## 9.482135 12.838225</pre><p>The prediction results in a numeric vector of predicted values. Both the absolute mean errors and the standard deviation of errors go up slightly, which suggests that the quality of the out-of-sample prediction does not get significantly worse, indicating that <code class="literal">model2</code> does not seem to be a result of overfitting.</p><p>Since <code class="literal">model2</code> has only one regressor, <code class="literal">distance</code>, it is natural to consider whether more regressors would improve the prediction. The following code fits a new linear model with not only distance but also <code class="literal">carrier</code>, <code class="literal">month</code> and departure time (<code class="literal">dep_time</code>) as regressors:</p><pre class="programlisting">model3 &lt;- lm(air_time ~ carrier + distance + month + dep_time,&#13;
  data = flights_train)predict3_train
&lt;- predict(model3, flights_train)
error3_train &lt;- flights_train$air_time - predict3_train
evaluate_error(error3_train)&#13;
## abs_err  std_dev 
## 9.312961 12.626790</pre><p>The in-sample errors are slightly lower in both magnitude and variation:</p><pre class="programlisting">predict3_test &lt;- predict(model3, flights_test)
error3_test &lt;- flights_test$air_time - predict3_test
evaluate_error(error3_test)&#13;
## abs_err std_dev 
## 9.38309 12.70168</pre><p>Also, the out-of-sample errors looks slightly better than <code class="literal">model2</code>. To compare the distribution of out-of-sample errors before and after adding new regressors to the linear model, we overlay the two density curves:</p><pre class="programlisting">plot(density(error2_test, na.rm = TRUE),
  main = "Empirical distributions of out-of-sample errors")&#13;
lines(density(error3_test, na.rm = TRUE), lty = 2)
legend("topright", legend = c("model2", "model3"), &#13;
  lty = c(1, 2), cex = 0.8,
  x.intersp = 0.6, y.intersp = 0.6)</pre><p>The plot generated is as follows:</p><div class="mediaobject"><img src="graphics/image_07_034.jpg" alt="Fitting a linear model"/></div><p>From the preceding density plot, the improvement from <code class="literal">model2</code> to <code class="literal">model3</code> is too small to notice, that is, there's no significant improvement at all.</p></div><div class="section" title="Fitting a regression tree"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec109"/>Fitting a regression tree</h2></div></div></div><p>In this section, we try another model to fit the data. The model is called a <span class="strong"><strong>regression tree</strong></span> (<a class="ulink" href="https://en.wikipedia.org/wiki/Decision_tree_learning">https://en.wikipedia.org/wiki/Decision_tree_learning</a>) and is one of the machine learning models. It is not a simple linear regression, but uses a decision tree to fit the data.</p><p>Suppose we want to predict the daily air quality (<code class="literal">Ozone</code>) according to solar radiation (<code class="literal">Solar.R</code>), average wind speed (<code class="literal">Wind</code>), and maximum daily temperature (<code class="literal">Temp</code>), the built-in dataset <code class="literal">airquality</code> being the training set. The following graph illustrates how a fitted regression tree works:</p><div class="mediaobject"><img src="graphics/image_07_035.jpg" alt="Fitting a regression tree"/></div><p>In the tree, each circle represents a question which has two possible answers. To predict <code class="literal">Ozone</code>, we need to ask questions along the tree from top to bottom where each observation lies in one of the bottom cases. Each node at the bottom has a distribution different from the others, which is illustrated by a box plot. The median or mean in each box should be reasonable predictions for each case.</p><p>There are a number of packages that implement decision tree learning algorithms. In this section, we use a simple package called party (<a class="ulink" href="https://cran.r-project.org/web/packages/party">https://cran.r-project.org/web/packages/party</a>). If you don't have it installed yet, run <code class="literal">install.package("party")</code>.</p><p>Now we use the same formula and data to train a regression tree model. Note that we took a subset of the data where there is no missing value of <code class="literal">air_time</code> because <code class="literal">ctree</code> does not accept missing values in a response variable:</p><pre class="programlisting">model4 &lt;- party::ctree(air_time ~ distance + month + dep_time,&#13;
  data = subset(flights_train, !is.na(air_time)))
predict4_train &lt;- predict(model4, flights_train)
error4_train &lt;- flights_train$air_time - predict4_train[, 1]
evaluate_error(error4_train)&#13;
## abs_err  std_dev 
## 7.418982 10.296528</pre><p>It looks like <code class="literal">model4</code> performs better than <code class="literal">model3</code>. Then, we take a look at its out-of-sample performance:</p><pre class="programlisting">predict4_test &lt;- predict(model4, flights_test)
error4_test &lt;- flights_test$air_time - predict4_test[, 1]
evaluate_error(error4_test)&#13;
## abs_err  std_dev 
## 7.499769 10.391071</pre><p>The preceding output suggests that the regression tree, on average, can make better predictions for this problem. The following density plots make a contrast between the distributions of the out-of-sample prediction errors of <code class="literal">model3</code> and <code class="literal">model4</code>:</p><pre class="programlisting">plot(density(error3_test, na.rm = TRUE),
   ylim = range(0, 0.06),
   main = "Empirical distributions of out-of-sample errors")
lines(density(error4_test, na.rm = TRUE), lty = 2)
legend("topright", legend = c("model3", "model4"),
  lty = c(1, 2), cex = 0.8,&#13;
  x.intersp = 0.6, y.intersp = 0.6)</pre><p>The plot generated is as follows:</p><div class="mediaobject"><img src="graphics/image_07_036.jpg" alt="Fitting a regression tree"/></div><p>For the preceding plot, we can see that the variance of the prediction errors of <code class="literal">model4</code> is lower than that of <code class="literal">model3</code>.</p><p>The preceding examples may suffer from many problems because we apply the linear models and machine learning models without any serious checking of the data. The point of these sections is not about the models but to demonstrate a common procedure and interface of fitting models in R. For a real-world problem, you need more careful analysis of the data rather than directly pouring them into an arbitrary model and making conclusions.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec43"/>Summary</h1></div></div></div><p>In this chapter, you learned how to read and write data in various formats, how to visualize data with plot functions, and how to apply basic models on the data. Now, you know the basic tools and interface of working with data. However, you may learn more data analysis tools from other sources.</p><p>For statistical and econometric models, I recommend that you read not only text books of statistics and econometrics but also R books that focus on statistical analysis. For machine learning models such as artificial neural networks, support vector machines, and random forests, I recommend that you read machine learning books and go to <span class="emphasis"><em>CRAN Task View: Machine Learning &amp; Statistical Learning</em></span> (<a class="ulink" href="https://cran.r-project.org/web/views/MachineLearning.html">https://cran.r-project.org/web/views/MachineLearning.html</a>).</p><p>Since this book is focused on the R programming language rather than any specific model, we will continue our journey in the next chapter by going deeper into R. If you are not familiar with how R code works, you can hardly predict what will happen, which slows down your coding, and a small issue can waste a lot of your time.</p><p>The next few chapters will help you build a concrete understanding of R's evaluation model, metaprogramming facilities, object-oriented systems, and several other mechanisms R chose to facilitate data analysis, which enables you to use more advanced packages of data manipulation and to work on more complicated tasks.</p></div></body></html>