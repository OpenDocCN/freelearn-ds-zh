["```py\n%run helper_file_1.0.ipynb\n#Adding two binary numbers\ntwo = 0b010\nthree = 0b011\nanswer = two + three\nprint(bin(answer)) \n0b101. The code reads the binary values of 2 and 3 and returns the result as a binary called answer, which is printed as a binary using the bin() function. In order to obtain the results of adding two numbers together, classical systems use Modulo 2 arithmetic, which is the result of using logic gates, in this case, an XOR gate. When XORing two input bits, that is, , the input values can also be written as two binary numbers, *x*1 and *x*2; that is, . Note that the result will work for the following input values of x1 and *x*2: 0+0, 0+1, and 1+0. However, when the input values of *x*1 and *x*2 are 1+1, we will need a second qubit to carry the value, hence the result for 1+1 will be 10.\n```", "```py\n    # Load the helper file\n    %run helper_file_1.0.ipynb \n    ```", "```py\n finished, whereas the qasm simulator returns count information. Finally, we will execute our circuit and get the state vector results:\n```", "```py\n#Create a simple circuit with just one qubit\nqc = QuantumCircuit(1) \n```", "```py\n    # Get the state vector result from the circuit\n    stateVectorResult = Statevector(qc)\n    print('state vector results', stateVectorResult) \n    ```", "```py\nstate vector results:  Statevector([1.+0.j, 0.+0.j],\n            dims=(2,)) \n```", "```py\n# Display the Bloch sphere\nstateVectorResult.draw('bloch') \n```", "```py\n    stateVectorResult.draw('qsphere') \n    ```", "```py\n    qc = QuantumCircuit(1)\n    qc.x(0)\n    #Run circuit using state vector and display results\n    stateVectorResult = Statevector(qc)\n    stateVectorResult.draw('qsphere') \n    ```", "```py\n    qc = QuantumCircuit(1)\n    qc.h(0)\n    #Run the circuit using the state vector and display results\n    stateVectorResult = Statevector(qc)\n    stateVectorResult.draw('bloch') \n    ```", "```py\n    stateVectorResult.draw('qsphere') \n    ```"]