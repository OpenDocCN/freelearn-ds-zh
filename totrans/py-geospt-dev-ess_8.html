<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Looking Forward</h1></div></div></div><p>Congratulations! You are now a proud owner of your very own GIS application; but not really. In reality, you have only started the journey. The application we created is still very basic, and while it has some of the core essential features, it lacks many others. You probably also have a few ideas and customizations that you want to implement on your own. Before we send you off to fend for yourself, in this final chapter we will look at some of the ways that you can move forward with your application:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Areas where the existing user interface should be improved</li><li class="listitem" style="list-style-type: disc">Some tips on building alternative GUI layouts using our toolkit</li><li class="listitem" style="list-style-type: disc">Suggestions for additional GIS functionality to add to the application</li><li class="listitem" style="list-style-type: disc">How to go about supporting your application on additional platforms such as Mac and mobile devices</li></ul></div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec40"/>Improvements to the user interface</h1></div></div></div><p>In the application, we made<a id="id299" class="indexterm"/> in this book, we tried to give it a modern and intuitive design. However, since we had to balance this with also building GIS content, there are several user interface aspects we were not able to address.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec48"/>Saving and loading user sessions</h2></div></div></div><p>One obvious thing that is missing<a id="id300" class="indexterm"/> from our general user interface is that we have no way to save or load a user session. That is, saving the current state of<a id="id301" class="indexterm"/> loaded layers and their properties, the sequence of layers, general map options, projection, zoom level, and so on, so that we can return to the same application session we previously used. The <strong>Home</strong> tab will be a good place for a load and save session button, which can also be called on with the keyboard shortcuts <em>Ctrl</em> + <em>O</em> and <em>Ctrl</em> + <em>S</em>.</p><p>In order to save these settings, we will have to come up with a file format specification as well as an identifiable filename extension. This can be, for instance, a simple JSON text file ending with <code class="literal">.pgs</code> (short for Python GIS if that is the name of your application) containing a dictionary or dictionaries<a id="id302" class="indexterm"/> of options. Layers can be reloaded based on their origin file path, and <a id="id303" class="indexterm"/>perhaps the user can be forced to save to file any virtual layers.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec49"/>File drag and drop</h2></div></div></div><p>Adding data layers with the <strong>Add Layer</strong> button is fine, but sometimes it can be a hassle to have to repeatedly<a id="id304" class="indexterm"/> locate the files each time, especially if they are located in deeply nested folders in multiple locations. Dragging and dropping series of files from already opened Windows folders to the application window is often a preferred<a id="id305" class="indexterm"/> way to add layers. Currently, we have not added any support for this in our application because Tkinter has no built-in support for detecting drag and drop between applications.</p><div><div><h3 class="title"><a id="note23"/>Note</h3><p>Luckily, there exists a <code class="literal">Tk</code> extension for this called TkDND at SourceForge which you will have to <a id="id306" class="indexterm"/>setup: <a class="ulink" href="http://sourceforge.net/projects/tkdnd/">http://sourceforge.net/projects/tkdnd/</a>. The following Python wrapper posted on StackOverflow<a id="id307" class="indexterm"/> should let you access this <code class="literal">Tk</code> extension in your Tkinter application: <a class="ulink" href="http://stackoverflow.com/questions/14267900/python-drag-and-drop-explorer-files-to-tkinter-entry-widget">http://stackoverflow.com/questions/14267900/python-drag-and-drop-explorer-files-to-tkinter-entry-widget</a>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec50"/>GUI widgets</h2></div></div></div><p>A great deal of our application framework has been spent tweaking and creating our own custom widget templates, for the purposes of widget styling and code reusability. As you move forward, I suggest<a id="id308" class="indexterm"/> following this logic even further so it becomes easier for you to build and extend the user interface. For instance, in our <code class="literal">RunToolFrame</code>, we created a method that will add commonly needed combinations of widgets<a id="id309" class="indexterm"/> inside that particular frame. However, to make it even more flexible you can make these into widget classes of their own so you can place them anywhere inside your application. In particular, I would suggest adding scrollbars to your widgets, which is something our current application is lacking.</p><p>On a more superficial note, although Tkinter generally has a nice look, especially with custom styling, some of our application widgets still look a bit out of place, such as the drop-down choice menu. With some style experimentation though, you should be able to improve its look. Alternatively, Python 2.7 and newer versions come packaged with a Tkinter extension module<a id="id310" class="indexterm"/> called <strong>ttk</strong>, which provides a newer looking ComboBox drop-down widget, among many others. The only difference that you should note, if you choose to switch to ttk widgets is that, they are styled using a different approach that requires you to make changes to the old Tkinter based code.</p></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec41"/>Other variations of the user interface</h1></div></div></div><p>The beauty of our approach <a id="id311" class="indexterm"/>to building a flexible toolkit of GIS-related widgets, is that they can be used, positioned, and combined in any number of ways, rather than locking ourselves to the traditional "LayersPane-MapView" layout of a GIS. For instance, here are some interesting examples of useful ways to create different types of GIS applications and layouts.</p><p>Instead of just a single-map GIS application, you can split the window into multiple windows, say 2 or 4 maps with a LayersPane in the middle. By connecting each map to the same LayerGroup and LayersPane, the layer sequence and symbolizations you define there will affect all of the maps, but with the added benefit that you can have multiple eyes on the same data, at different locations and zoom levels. Refer to the following screenshot:</p><div><img src="img/5407OS_08_01.jpg" alt="Other variations of the user interface"/></div><p>Alternatively, you don't have to have all of the widgets there at all. You can create a minimalistic map-only application, where layers can be preloaded and/or managed in a different or a more discrete way. Alternatively, you can have a more management-oriented application with only the LayersPane and the functionality to manage and organize your files.</p><p>Finally, remember that all of our widgets are styled and easily changed based on color and font instructions in our <code class="literal">app/toolkit/theme.py</code> module. We built it like that for a reason, so make use of it!</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec42"/>Adding more GIS functionality</h1></div></div></div><p>There are loads of GIS functionalities that you may wish to add to your application. Of the many pre-existing modules<a id="id312" class="indexterm"/> and libraries available, here are just a few suggestions as to what is mostly needed and possible to do. A more comprehensive list can be found at <a class="ulink" href="http://www.pythongisresources.wordpress.com">www.pythongisresources.wordpress.com</a> or on the Python Package Index website.</p><div><div><h3 class="title"><a id="note24"/>Note</h3><p>For more in-depth implementations of some of these tools, and further reading and ideas on how to implement a GIS application in Python, refer to <em>Python Geospatial Development - Second Edition</em> by Erik Westra.</p></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec51"/>Basic GIS selections</h2></div></div></div><p>There are a few core data<a id="id313" class="indexterm"/> selection functions that we have still not implemented. Importantly, these include the ability to subset a layer based on a data query, or spatially cropping it based on a region bounding box or overlap with another layer. Both of these should be as simple as looping through the features and only keeping the matches from the attribute query or spatial query. The ability to view the actual information stored in vector data is also something we are currently lacking, such as in a table or with a feature identification tool where the user can click on any vector feature or raster cell and view their attributes or values.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec52"/>More advanced visualization</h2></div></div></div><p>Currently, our application is not very flexible when it comes to visualizing data. Vector data is rendered with a single random color for all features, and rasters as greyscale or RGB, with no ability to change it. However, using our RunToolFrame widget, it should be easy<a id="id314" class="indexterm"/> to pack it inside a <strong>Symbology</strong> ribbon tab in the layer's properties window and assign input widgets and a function that updates that layer's <code class="literal">styleoptions</code> dictionary and redraws it.</p><p>Even with this though, a hallmark of GIS visualization is that we should also be able to have these colors and sizes vary based on each vector feature's attributes in order to visualize patterns. Similarly, we need to be able to label layers by rendering text over each feature based on its attributes. Finally, we should be able to add cartographic elements to the map such as adding a custom title, placing a legend, a scale, and a north arrow. These are some very exciting areas that you can work on improving.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec53"/>Online data services</h2></div></div></div><p>For our application, we built the capability to load data by pointing it to a file path on your computer, which is<a id="id315" class="indexterm"/> the traditional way of working in a GIS. But it is increasingly common to load generic background data or regularly updated data feeds such as satellite imagery directly from the web, via the <strong>Open Geospatial Consortium</strong> (<strong>OGC</strong>) web <a id="id316" class="indexterm"/>service interface standard.</p><p>In Python, I would recommend using OWSLib which lets you access a wide variety of online services and data sources, and has great documentation for learning more about it.</p><div><div><h3 class="title"><a id="note25"/>Note</h3><p>For a more concrete example, see how<a id="id317" class="indexterm"/> PyEarthquake uses web services for retrieving real-time earthquake data:</p><p><a class="ulink" href="http://blog.christianperone.com/?p=1013">http://blog.christianperone.com/?p=1013</a></p></div></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec54"/>Converting between raster and vector data</h2></div></div></div><p>The ability to convert from a raster grid to vector data of square polygons or center points for more custom processing, or to convert from vector data to a raster grid of a given resolution, is frequently needed. Both of these are currently missing from our application, but should <a id="id318" class="indexterm"/>be fairly easy and useful to implement within our existing framework. Rasterizing vector data is essentially the same as drawing it on an image, so you can just draw it to the desired raster resolution using PIL or PyAgg. To vectorize raster data, you can loop through the cells of your raster and create a point geometry at each cell's <em>x</em> and <em>y</em> coordinates (or polygon geometry based on the cell bounding box). Alternatively, you can use GDAL that already has functions for both rasterizing and vectorizing.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec55"/>Projections</h2></div></div></div><p>As it currently stands, our application can process and visualize data defined in any projection, but it cannot convert between these projections. So if multiple data have different projections, then there is no way to position or analyze them correctly in relation to each other. Luckily, PyProj is an excellent and widely used Python package based on PROJ4 for converting<a id="id319" class="indexterm"/> coordinates from one projection to another and is fairly lightweight. With this, you can add tools to define and convert layer projections and to set on-the-fly reprojection of all layers into a common map projection.</p><p>The most difficult part is that there are numerous formats in which projections are stored, such as EPSG codes, OGC URN codes, ESRI WKT, OGC WKT, +proj strings, and GeoTIFF definitions, to name but a few. PyProj requires that projections be defined as +proj strings, so the challenge will be to correctly detect, parse, and convert whichever projection format a file is stored in, <a id="id320" class="indexterm"/>over to +proj format. GDAL is the best way to handle these translations, or using <a class="ulink" href="http://www.spatialreference.org">http://www.spatialreference.org</a> if you only expect to receive codes such as EPSG.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec56"/>Geocoding</h2></div></div></div><p>Today, geocoding of addresses <a id="id321" class="indexterm"/>and other textual information into coordinates is relatively easy using free online search websites and their programming-friendly APIs. GeoPy is a Python package that provides access to numerous online geocoding services, such as OpenStreetMap, Google, Bing, and many others. This can be added to your application either as a tool for geocoding a table based on a field containing textual locations, or by providing an interactive geocoding search widget that shows the resulting matches on the map.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec57"/>Going the GDAL/NumPy/SciPy route</h2></div></div></div><p>If you, at some point, decide<a id="id322" class="indexterm"/> to add GDAL, NumPy, and SciPy as dependencies to your application, it will add about 100 MB of additional size to your application, but will also open up a lot of new doors. For instance, the problem of translating between different projection formats will be solved by functions available in GDAL. Adding GDAL and NumPy will also let you add a host of new data loading and saving capabilities, and especially open up for raster management, analysis, and resampling methods using packages like PyResample, RasterStats, and even raster interpolation via SMEAR. For vector data, it will also open the door for more advanced spatial statistic and hotspot analysis as available in PySAL or various clustering algorithms using PyCluster. Matplotlib combined with Basemap or Cartopy may provide all the visual projection support you need without much extra work on your end.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec43"/>Expanding to other platforms</h1></div></div></div><p>For now, I can attest that the application works on Windows 7 and even Windows 8 (single-touch navigation of the MapView is especially fun). However, at some point you may find yourself <a id="id323" class="indexterm"/>needing to share your GIS application on platforms other than Windows. Python and most of our application's dependencies are in principle cross-platform, and I have personally tested that the application framework that I created over the course of this book also worked on a Mac OS X, though with slightly different installation instructions.</p><p>When you are finished creating your application and are ready to distribute it, just get a hold of the operating system that you want to support, install the necessary third-party libraries, and copy and paste your application folder. If the application works from within Python, then just wrap it all up with one of the packaging libraries for your operating system that were suggested in <a class="link" href="ch07.html" title="Chapter 7. Packaging and Distributing Your Application">Chapter 7</a>, <em>Packaging and Distributing Your Application</em>.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec58"/>Touch devices</h2></div></div></div><p>A more trendy and exciting<a id="id324" class="indexterm"/> possibility is to be able to port your application to the newer wave of recreational tablets and other mobile touch devices. Our current Tkinter user interface approach is unfortunately not able to be packaged for use on, or contain multitouch gesture support for, phones like Android or iPhone or tablets like iPad. If these are your main audiences, you can possibly keep the GIS processing engine, but may wish to switch the user interface to one based on Kivy, a newer GUI package which is gaining in popularity, which supports multitouch inputs, and is said to support packaging for Android, iPhone, and iPad. If you only want to support iOS, then the Pythonista app provides<a id="id325" class="indexterm"/> a GUI builder, several core Python packages like PIL, NumPy, and Matplotlib, access to the iOS rendering engine, and even a way to package your application into an app (though you will still have to apply to get it onto the Apple store).</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec44"/>Summary</h1></div></div></div><p>We started out in this book seeking to create a basic and lightweight GIS application from scratch. As we reach the end of the book, this is exactly what we have done. Based on an underlying codebase of interlinked Python libraries, we have a distributable visual user interface application that can perform basic loading and saving, visualizing, managing, and analysis of spatial data.</p><p>At the very least, you picked up a few ideas of how to go about creating one. The best part about it is that you are fully in control of tweaking, modifying, and further developing it. If you have a particular need or a great idea for a custom workflow application, just look to the many tools available and build it yourself. I am very excited to keep using this application framework myself and especially curious to see what kind of GIS applications you will come up with.</p></div></div>
</body></html>