<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 8. Network Routing Analysis"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Network Routing Analysis</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Finding the Dijkstra shortest path with pgRouting</li><li class="listitem" style="list-style-type: disc">Finding the Dijkstra shortest path with NetworkX in pure Python</li><li class="listitem" style="list-style-type: disc">Generating evacuation polygons based on an indoor shortest path</li><li class="listitem" style="list-style-type: disc">Creating centerlines from polygons</li><li class="listitem" style="list-style-type: disc">Building an indoor routing system in 3D</li><li class="listitem" style="list-style-type: disc">Calculating indoor route walk time</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec56"/>Introduction</h1></div></div></div><p>Routing has<a id="id352" class="indexterm"/> become commonplace on navigation devices for road networks across the world. If you want to know how to drive from point A to point B, simply enter the start address and end address into your navigation software and it will calculate the shortest route for you in seconds.</p><p>Here's a scenario you may come across: Route me to Prof. Dr. Smith's office in the Geography Department for my meeting at any university anywhere. Hmm, sorry, there's no routing network available on my navigation software. This is a reminder for you to not to forget to ask for directions on campus for your meeting location.</p><p>This chapter is all about routing and, specifically, routing inside large building complexes from office <span class="emphasis"><em>A33</em></span>, first floor in building <span class="emphasis"><em>E01</em></span> to office <span class="emphasis"><em>B55</em></span>, sixth floor in building <span class="emphasis"><em>P7</em></span>.</p><div class="mediaobject"><img src="images/50790OS_08_01.jpg" alt="Introduction"/></div><p>We will <a id="id353" class="indexterm"/>explore the powerful routing capabilities of <span class="strong"><strong>pgRouting</strong></span>, an extension of PostgreSQL. With pgRouting, we can calculate the shortest path using either the Dijkstra, A*, and/or K shortest path algorithms. Alongside pgRouting, we will use a pure Python solution with the NetworkX library to generate a route from the same source data.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note36"/>Note</h3><p>BIG IMPORTANT NOTE. Pay attention to the input network dataset used and make sure that it is in the EPSG: 3857 coordinate system, a geometric Cartesian meter system. Routing calculations using world coordinates in EPSG: 4326 must be converted if used by such a system. Also, note that the GeoJSON coordinate system is interpreted by QGIS as EPSG:4326 even though the coordinates are stored in EPSG:3857!</p></div></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Finding the Dijkstra shortest path with pgRouting"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec57"/>Finding the Dijkstra shortest path with pgRouting</h1></div></div></div><p>There <a id="id354" class="indexterm"/>are a few Python libraries out <a id="id355" class="indexterm"/>there, such<a id="id356" class="indexterm"/> as <span class="strong"><strong>networkX</strong></span> and<a id="id357" class="indexterm"/> <span class="strong"><strong>scikit-image</strong></span>, that can find the shortest path over a raster or NumPy array. We want to focus on routing over a vector source and returning a vector dataset; therefore, pgRouting is a natural choice for us. Custom Python <span class="emphasis"><em>Dijkstra</em></span> or the <span class="emphasis"><em>A Star (A*)</em></span> shortest path algorithms exist but one that performs well on large networks is hard to find. The <code class="literal">pgRouting</code> extension of PostgreSQL is used by OSM and many other projects and is well tested.</p><p>Our<a id="id358" class="indexterm"/> example will have us load a Shapefile of <a id="id359" class="indexterm"/>an indoor network from one floor for simplicity's sake. An indoor network is comprised of network lines that go along the hallways and open walkable spaces within a building, leading to a door in most cases.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec137"/>Getting ready</h2></div></div></div><p>For this recipe, we are going to need to set up our PostGIS database with the pgRouting extension. On a Windows machine, you can install pgRouting by downloading a ZIP file for<a id="id360" class="indexterm"/> Postgresql 9.3 at <a class="ulink" href="http://winnie.postgis.net/download/windows/pg93/buildbot/">http://winnie.postgis.net/download/windows/pg93/buildbot/</a>. Then, extract the zip file into <code class="literal">C:\Program Files\PostgreSQL\9.3\</code>.</p><p>For<a id="id361" class="indexterm"/> Ubuntu Linux users, the pgRouting website explains the details at <a class="ulink" href="http://docs.pgrouting.org/2.0/en/doc/src/installation/index.html#ubuntu-debian">http://docs.pgrouting.org/2.0/en/doc/src/installation/index.html#ubuntu-debian</a>.</p><p>To enable this extension, you have a couple of options. First off, you can run the command-line <code class="literal">psql</code> tool to activate the extension as follows if you have your PostgreSQL running as explained in <a class="link" href="ch01.html" title="Chapter 1. Setting Up Your Geospatial Python Environment">Chapter 1</a>, <span class="emphasis"><em>Setting Up Your Geospatial Python Environment</em></span>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; psql py_geoan_cb -c "create extension pgrouting"</strong></span>
</pre></div><p>You can<a id="id362" class="indexterm"/> use the <span class="strong"><strong>pgAdmin</strong></span> user tool by simply opening up the <code class="literal">py_geoan_cb</code> database, right-clicking on <span class="strong"><strong>Extensions</strong></span>, selecting <span class="strong"><strong>New Extension...,</strong></span> and in the <span class="strong"><strong>Name</strong></span> field, scrolling down to find the <code class="literal">pgRouting</code> entry and selecting it.</p><p>Now we need some data to do our routing calculations. The data used is a Shapefile located in your <code class="literal">/ch08/geodata/shp/e01_network_lines_3857.shp</code> folder. Take a look at <a class="link" href="ch03.html" title="Chapter 3. Moving Spatial Data from One Format to Another">Chapter 3</a>, <span class="emphasis"><em>Moving Spatial Data from One Format to Another</em></span>, on how to import the Shapefile or use <code class="literal">shp2pgsql</code>. Here is the command-line one-liner using <code class="literal">ogr2ogr</code> to import the Shapefile:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;ogr2ogr -a_srs EPSG:3857 -lco "SCHEMA=geodata" -lco "COLUMN_TYPES=type=varchar,type_id=integer" -nlt MULTILINESTRING -nln ch08_e01_networklines -f PostgreSQL "PG:host=localhost port=5432 user=pluto dbname=py_geoan_cb password=secret" geodata/shp/e01_network_lines_3857.shp</strong></span>
</pre></div><p>Note that you either use the same username and password from <a class="link" href="ch01.html" title="Chapter 1. Setting Up Your Geospatial Python Environment">Chapter 1</a>, <span class="emphasis"><em>Setting Up Your Geospatial Python Environment</em></span>, or your own defined username and password.</p><p>For Windows users, you might need to insert the full path of your Shapefile, something that could look like <code class="literal">c:\somepath\geodata\shp\e01_network_lines.shp</code>. We explicitly set the input of the EPSG:3857 Web Mercator because, sometimes, ogr2ogr guesses the wrong projection and in this way, it ensures that it is correct on upload. Another thing to note is that we also explicitly define the output table column types because <code class="literal">ogr2ogr</code> uses numeric fields for our integers and this does not go well with <code class="literal">pgRouting</code>, so we explicitly pass the comma-separated list of field names and field types.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip20"/>Tip</h3><p>For a<a id="id363" class="indexterm"/> detailed description of how ogr2ogr works, visit <a class="ulink" href="http://gdal.org/ogr2ogr.html">http://gdal.org/ogr2ogr.html</a>.</p></div></div><p>Our <a id="id364" class="indexterm"/>new table includes two fields, one called <code class="literal">type</code> and <a id="id365" class="indexterm"/>the other, <code class="literal">type_id</code>. The <code class="literal">type_id</code> variable will store an integer used to identify what kind of network segment we are on, such as stairs, an indoor way, or elevator. The remaining fields are necessary for <code class="literal">pgRouting</code>, which is installed as shown in the following code, and include columns called <code class="literal">source</code>, <code class="literal">target</code>, and <code class="literal">cost</code>. The <code class="literal">source</code> and <code class="literal">target</code> columns both need to be integers, while the <code class="literal">cost</code> field is of a double precision type. These types are the requirements of the pgRouting functions.</p><p>Let's go ahead and add these fields now to our <code class="literal">ch08_e01_networklines</code> table with the help of some SQL queries:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ALTER TABLE geodata.ch08_e01_networklines ADD COLUMN source INTEGER;</strong></span>
<span class="strong"><strong>ALTER TABLE geodata.ch08_e01_networklines ADD COLUMN target INTEGER;</strong></span>
<span class="strong"><strong>ALTER TABLE geodata.ch08_e01_networklines ADD COLUMN cost DOUBLE PRECISION;</strong></span>
<span class="strong"><strong>ALTER TABLE geodata.ch08_e01_networklines ADD COLUMN length DOUBLE PRECISION;</strong></span>
<span class="strong"><strong>UPDATE geodata.ch08_e01_networklines set length = ST_Length(wkb_geometry);</strong></span>
</pre></div><p>Once the network dataset has its new columns, we need to run the create topology <code class="literal">pgr_createTopology()</code>function. This function takes the name of our network dataset, a tolerance value, geometry field name, and a primary key field name. The function will create a new table of points on the LineString intersections, that is, nodes on a network that are in the same schema:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>SELECT public.pgr_createTopology('geodata.ch08_e01_networklines',</strong></span>
<span class="strong"><strong>        0.0001, 'wkb_geometry', 'ogc_fid');</strong></span>
</pre></div><p>The <code class="literal">pgr_createTopology</code> function parameters include the name of the networklines LineStrings containing our cost and type fields. The second parameter is the distance tolerance in meters followed by the name of the geometry column and our primary key unique id called <code class="literal">ogc_fid</code>.</p><p>Now <a id="id366" class="indexterm"/>that our tables and environment<a id="id367" class="indexterm"/> are set up, this allows us to actually create the shortest path called the Dijkstra route.</p><p>To run the Python code, make sure you have the <code class="literal">psycopg2</code> and <code class="literal">geojson</code> modules installed as described in <a class="link" href="ch01.html" title="Chapter 1. Setting Up Your Geospatial Python Environment">Chapter 1</a>, <span class="emphasis"><em>Setting Up Your Geospatial Python Environment</em></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec138"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Check out this code and follow along:<div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# -*- coding: utf-8 -*-

import psycopg2
import json
from geojson import loads, Feature, FeatureCollection

db_host = "localhost"
db_user = "pluto"
db_passwd = "secret"
db_database = "py_geoan_cb"
db_port = "5432"

# connect to DB
conn = psycopg2.connect(host=db_host, user=db_user, port=db_port,
                        password=db_passwd, database=db_database)

# create a cursor
cur = conn.cursor()

start_x = 1587927.204
start_y = 5879726.142
end_x = 1587947.304
end_y = 5879611.257

# find the start node id within 1 meter of the given coordinate
# used as input in routing query start point
start_node_query = """
    SELECT id FROM geodata.ch08_e01_networklines_vertices_pgr AS p
    WHERE ST_DWithin(the_geom, ST_GeomFromText('POINT(%s %s)',3857), 1);"""

# locate the end node id within 1 meter of the given coordinate
end_node_query = """
    SELECT id FROM geodata.ch08_e01_networklines_vertices_pgr AS p
    WHERE ST_DWithin(the_geom, ST_GeomFromText('POINT(%s %s)',3857), 1);
    """

# get the start node id as an integer
cur.execute(start_node_query, (start_x, start_y))
sn = int(cur.fetchone()[0])

# get the end node id as an integer
cur.execute(end_node_query, (end_x, end_y))
en = int(cur.fetchone()[0])


# pgRouting query to return our list of segments representing
# our shortest path Dijkstra results as GeoJSON
# query returns the shortest path between our start and end nodes above
# using the python .format string syntax to insert a variable in the query
routing_query = '''
    SELECT seq, id1 AS node, id2 AS edge, ST_Length(wkb_geometry) AS cost,
           ST_AsGeoJSON(wkb_geometry) AS geoj
      FROM pgr_dijkstra(
        'SELECT ogc_fid as id, source, target, st_length(wkb_geometry) as cost
         FROM geodata.ch08_e01_networklines',
        {start_node},{end_node}, FALSE, FALSE
      ) AS dij_route
      JOIN  geodata.ch08_e01_networklines AS input_network
      ON dij_route.id2 = input_network.ogc_fid ;
  '''.format(start_node=sn, end_node=en)


# run our shortest path query
cur.execute(routing_query)

# get entire query results to work with
route_segments = cur.fetchall()

# empty list to hold each segment for our GeoJSON output
route_result = []

# loop over each segment in the result route segments
# create the list for our new GeoJSON
for segment in route_segments:
    geojs = segment[4]
    geojs_geom = loads(geojs)
    geojs_feat = Feature(geometry=geojs_geom, properties={'nice': 'route'})
    route_result.append(geojs_feat)

# using the geojson module to create our GeoJSON Feature Collection
geojs_fc = FeatureCollection(route_result)

# define the output folder and GeoJSON file name
output_geojson_route = "../geodata/ch08_shortest_path_pgrouting.geojson"


# save geojson to a file in our geodata folder
def write_geojson():
    with open(output_geojson_route, "w") as geojs_out:
        geojs_out.write(json.dumps(geojs_fc))


# run the write function to actually create the GeoJSON file
write_geojson()

# clean up and close database curson and connection
cur.close()
conn.close()</pre></div></li><li class="listitem">The<a id="id368" class="indexterm"/> resulting query, if you<a id="id369" class="indexterm"/> ran it inside <code class="literal">pgAdmin</code>, for example, would return the following:<div class="mediaobject"><img src="images/50790OS_08_02.jpg" alt="How to do it..."/></div><p>A <a id="id370" class="indexterm"/>route needs to be <a id="id371" class="indexterm"/>visualized on a map and not as a table. Go ahead and drag and drop your newly created <code class="literal">/ch08/geodata/ch08_shortest_path_pgrouting.geojson</code> file into QGIS. If all goes well, you should see this pretty little line, excluding the red arrows and text:</p></li></ol></div><div class="mediaobject"><img src="images/50790OS_08_03.jpg" alt="How to do it..."/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec139"/>How it works...</h2></div></div></div><p>Our<a id="id372" class="indexterm"/> code journey starts with setting up <a id="id373" class="indexterm"/>our database connection so that we can execute some queries against our uploaded data.</p><p>Now we are ready to run some routing, but wait, How do we set the start and end points that we want to route to and from? The natural way to do this is to input and the x, y coordinate pair for the start and end points. Unfortunately, the <code class="literal">pgr_dijkstra()</code> function takes only the start and end node IDs. This means that we need to get these node IDs from the new table called <code class="literal">ch08_e01_networklines_vertices_pgr</code>. To locate the nodes, we use a simple PostGIS function, <code class="literal">ST_Within()</code>, to find the nearest node within one meter from the input coordinate. Inside this query, our input geometry uses the <code class="literal">ST_GeomFromText()</code> function so that you can clearly see where things go in our SQL. Now, we'll execute our query and convert the response to an integer value as our node ID. This node ID is then ready for input in the next and final query.</p><p>The routing query will return a sequence number, node, edge, cost, and geometry for each segment along our final route. The geometry created is GeoJSON using the <code class="literal">ST_AsGeoJSON()</code> PostGIS function that feeds the creation of our final GeoJSON output route.</p><p>The pgRouting <code class="literal">pgr_dijkstra()</code>function's input arguments include an SQL query, start node ID, end node ID, directed value, and a <code class="literal">has_rcost</code> Boolean value. We set the <code class="literal">directed</code> and <code class="literal">has_rcost</code> values to <code class="literal">False</code>, while passing in the <code class="literal">start_node</code> and <code class="literal">end_node</code> IDs. This query performs a <code class="literal">JOIN</code> between the generated route IDs and input network IDs so that we have some geometry output to visualize.</p><p>Our <a id="id374" class="indexterm"/>journey then ends with processing<a id="id375" class="indexterm"/> the results and creating our output GeoJSON file. The routing query has returned a list of individual segments from start to end that aren't in the form of a single LineString, but a set of many LineStrings. This is why we need to create a list and append each route segment to a list by creating our GeoJSON <code class="literal">FeatureCollection</code> file.</p><p>Here, we use the <code class="literal">write_geojson()</code> function to output our final GeoJSON file called <code class="literal">ch08_shortest_path_pgrouting.geojson</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note37"/>Note</h3><p>Note that this GeoJSON file is in the EPSG:3857 coordinate system and is interpreted by QGIS as EPSG:4326, which is incorrect. Geodata for routing, such as OSM data and custom datasets, has lots of possible mistakes, errors, and inconsistencies. Beware that the devil is hiding in the detail of the data this time and not so much in the code.</p></div></div><p>Go ahead and drag and drop your GeoJSON file into QGIS to see how your final route looks.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Finding the Dijkstra shortest path with NetworkX in pure Python"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec58"/>Finding the Dijkstra shortest path with NetworkX in pure Python</h1></div></div></div><p>This <a id="id376" class="indexterm"/>recipe is a pure<a id="id377" class="indexterm"/> Python solution to calculate the shortest path<a id="id378" class="indexterm"/> on a network. <span class="strong"><strong>NetworkX</strong></span> is the library we will use with many algorithms<a id="id379" class="indexterm"/> to solve the shortest path problem, including Dijkstra (<a class="ulink" href="http://networkx.github.io/">http://networkx.github.io/</a>). <span class="strong"><strong>NetworkX</strong></span> relies on <code class="literal">numpy</code> and <code class="literal">scipy</code> to perform some graph calculations and help with performance. In this recipe, we will only use Python libraries to create our shortest path based on the same input Shapefile used in our previous recipe.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec140"/>Getting ready</h2></div></div></div><p>Start with installing <span class="emphasis"><em>NetworkX</em></span> on your machine with the <code class="literal">pip</code> installer as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt; pip install networkx</strong></span>
</pre></div><p>For the network graph algorithms, NetworkX requires <code class="literal">numpy</code> and <code class="literal">scipy</code>, so take a look at <a class="link" href="ch01.html" title="Chapter 1. Setting Up Your Geospatial Python Environment">Chapter 1</a>, <span class="emphasis"><em>Setting Up Your Geospatial Python Environment</em></span>, for instructions on these. We also use<a id="id380" class="indexterm"/> Shapely to generate <a id="id381" class="indexterm"/>our geometry outputs to create GeoJSON files, so check whether you have installed Shapely. One hidden requirement is that GDAL/OGR is used in the back end of NetworkX's <code class="literal">import Shapefile</code> function. As mentioned earlier, in <a class="link" href="ch01.html" title="Chapter 1. Setting Up Your Geospatial Python Environment">Chapter 1</a>, you will find instructions on this subject.</p><p>The input <a id="id382" class="indexterm"/>data that represents our network is a Shapefile at <code class="literal">/ch08/geodata/shp/e01_network_lines_3857.shp</code>, containing our network dataset that is already prepared for routing, so make sure you download this chapter. Now you are ready to run the example.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec141"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">You need to run this code from the command line to generate the resulting output GeoJSON files that you can open in QGIS, so follow along:<div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# -*- coding: utf-8 -*-
import networkx as nx
import numpy as np
import json
from shapely.geometry import asLineString, asMultiPoint


def get_path(n0, n1):
    """If n0 and n1 are connected nodes in the graph,
    this function will return an array of point
    coordinates along the line linking
    these two nodes."""

    return np.array(json.loads(nx_list_subgraph[n0][n1]['Json'])['coordinates'])


def get_full_path(path):
    """
    Create numpy array line result
    :param path: results of nx.shortest_path function
    :return: coordinate pairs along a path
    """
    p_list = []
    curp = None
    for i in range(len(path)-1):
        p = get_path(path[i], path[i+1])
        if curp is None:
            curp = p
        if np.sum((p[0]-curp)**2) &gt; np.sum((p[-1]-curp)**2):
            p = p[::-1, :]
        p_list.append(p)
        curp = p[-1]
    return np.vstack(p_list)


def write_geojson(outfilename, indata):
    """
    create GeoGJSOn file
    :param outfilename: name of output file
    :param indata: GeoJSON
    :return: a new GeoJSON file
    """

    with open(outfilename, "w") as file_out:
        file_out.write(json.dumps(indata))


if __name__ == '__main__':

    # use Networkx to load a Noded shapefile
    # returns a graph where each node is a coordinate pair
    # and the edge is the line connecting the two nodes

    nx_load_shp = nx.read_shp("../geodata/shp/e01_network_lines_3857.shp")

    # A graph is not always connected, so we take the largest connected subgraph
    # by using the connected_component_subgraphs function.
    nx_list_subgraph = list(nx.connected_component_subgraphs(nx_load_shp.to_undirected()))[0]

    # get all the nodes in the network
    nx_nodes = np.array(nx_list_subgraph.nodes())

    # output the nodes to a GeoJSON file to view in QGIS
    network_nodes = asMultiPoint(nx_nodes)
    write_geojson("../geodata/ch08_final_netx_nodes.geojson",
                  network_nodes.__geo_interface__)

    # this number represents the nodes position
    # in the array to identify the node
    start_node_pos = 30
    end_node_pos = 21

    # Compute the shortest path. Dijkstra's algorithm.
    nx_short_path = nx.shortest_path(nx_list_subgraph,
                                     source=tuple(nx_nodes[start_node_pos]),
                                     target=tuple(nx_nodes[end_node_pos]),
                                     weight='distance')

    # create numpy array of coordinates representing result path
    nx_array_path = get_full_path(nx_short_path)

    # convert numpy array to Shapely Linestring
    out_shortest_path = asLineString(nx_array_path)

    write_geojson("../geodata/ch08_final_netx_sh_path.geojson",
                  out_shortest_path.__geo_interface__)</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec142"/>How it works...</h2></div></div></div><p>NetworkX has <a id="id383" class="indexterm"/>a nice<a id="id384" class="indexterm"/> function called <code class="literal">read_shp</code> that inputs a Shapefile directly. However, to start doing this, we need to define the <code class="literal">write_geojson</code> function to output our results as GeoJSON files. The input Shapefile is a completely connected network dataset. Sometimes, you may find that your input is not connected and this function call to <code class="literal">connected_component_subgraphs</code> finds nodes that are connected, only using these connected nodes. The inner function sets our network to <code class="literal">undirected</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note38"/>Note</h3><p>This function does not create a connected network dataset; this job is left for you to perform in QGIS or some other desktop GIS software. One solution is to execute this in PostgreSQL with the tools provided with the pgRouting extension.</p></div></div><p>Now, we'll generate the nodes on our network and export them to GeoJSON. This is, of course, not necessary, but it is nice to see where the nodes are on the map to debug your data. If any problems do occur in generating routes, you can visually identify them quite quickly.</p><p>Next up, we set the array position of the start and end node to calculate our route. The NetworkX <code class="literal">shortest_path</code> algorithm requires you to define the source and target nodes.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip21"/>Tip</h3><p>One thing to pay attention to is the fact that the source and target are coordinate pairs within an array of points.</p></div></div><p>As<a id="id385" class="indexterm"/> nice as this array<a id="id386" class="indexterm"/> of points are, we need a path and, hence, the <code class="literal">get_path</code> and <code class="literal">get_full_path</code> functions are discussed next. Our <code class="literal">get_path</code> function takes two input nodes, that is, two pairs of coordinates, and returns a NumPy array of edge coordinates along the line. This is followed closely by the <code class="literal">get_full_path</code> function that internally uses the <code class="literal">get_path</code> function to output the complete list of all paths and coordinates along all paths.</p><p>All the edges and corresponding coordinates are then appended to a new list that needs to be combined—hence, the NumPy <code class="literal">vstack</code> function. Inside our <code class="literal">for</code> loop, we go through each path, getting the edges and coordinates to build our list that then gets concatenated together as our final NumPy array output.</p><p>Shapely was built with NumPy compatibility and, therefore, has an <code class="literal">asLineString()</code>function that can directly input a NumPy array of coordinates. Now we have the geometry of our final LineString route and can export it to GeoJSON with our function.</p><div class="mediaobject"><img src="images/50790OS_08_04.jpg" alt="How it works..."/></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Generating evacuation polygons based on an indoor shortest path"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec59"/>Generating evacuation polygons based on an indoor shortest path</h1></div></div></div><p>Architects<a id="id387" class="indexterm"/> and transportation<a id="id388" class="indexterm"/> planners, for example, need to plan where and how many exits a building will require based on various standards and safety policies. After a building is built, a facility manager and security team usually do not have access to this information. Imagine that there is an event to be planned and you want to see what areas can be evacuated within a certain time, which are constrained by your list of exits in the building.</p><p>During this exercise, we want to create some polygons for a specific start point inside a major building, showing which areas can be evacuated in 10, 20, 30, and 60 second intervals. We assume that people will walk at 5 km/hr or 1.39 m/s, which is their normal walking speed. If we panic and run, our normal run speed increases to 6.7 m/s or 24.12 km/hr.</p><p>Our results are going to generate a set of polygons representing our evacuation zones based on the building hallways. We need to define the start position of where the evacuation begins. This starting point of our calculation is equal to the starting point in our route that was discussed in the previous recipe, <span class="emphasis"><em>Finding the Dijkstra shortest path with NetworkX in pure Python</em></span>.</p><div class="mediaobject"><img src="images/50790OS_08_05.jpg" alt="Generating evacuation polygons based on an indoor shortest path"/></div><p>This image shows the resulting polygons and points that are generated using our script. The results are styled and visualized using QGIS.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec143"/>Getting ready</h2></div></div></div><p>This<a id="id389" class="indexterm"/> example uses <a id="id390" class="indexterm"/>the network data loaded by our previous recipe, so make sure that you have loaded this data into your local PostgreSQL database. After you have loaded the data, you will have two tables, <code class="literal">geodata.ch08_e01_networklines_vertices_pgr</code> and <code class="literal">geodata.ch08_e01_networklines</code>. In combination with these tables, you need a single new Shapefile for our input polygons located at <code class="literal">/ch08/geodata/shp/e01_hallways_union_3857.shp</code>, representing the building hallways that are used to clip our resulting distance polygons.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec144"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">There are lots of comments in the code for clarity purposes, so read along:<div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# -*- coding: utf-8 -*-

import psycopg2
import shapefile
import json
import shapely.geometry as geometry
from geojson import loads, Feature, FeatureCollection
from shapely.geometry import asShape

# database connection
db_host = "localhost"
db_user = "pluto"
db_passwd = "secret"
db_database = "py_geoan_cb"
db_port = "5432"

# connect to DB
conn = psycopg2.connect(host=db_host, user=db_user, port=db_port,
                        password=db_passwd, database=db_database)
cur = conn.cursor()

def write_geojson(outfilename, indata):
    with open(outfilename, "w") as geojs_out:
        geojs_out.write(json.dumps(indata))

# center point for creating our distance polygons
x_start_coord = 1587926.769
y_start_coord = 5879726.492


# query including two variables for the x, y POINT coordinate
start_node_query = """
    SELECT id
    FROM geodata.ch08_e01_networklines_vertices_pgr AS p
    WHERE ST_DWithin(the_geom,
      ST_GeomFromText('POINT({0} {1})',3857),1);
      """.format(x_start_coord, y_start_coord)

# get the start node id as an integer
# pass the variables
cur.execute(start_node_query)
start_node_id = int(cur.fetchone()[0])

combined_result = []

hallways = shapefile.Reader("../geodata/shp/e01_hallways_union_3857.shp")
e01_hallway_features = hallways.shape()
e01_hallway_shply = asShape(e01_hallway_features)

# time in seconds
evac_times = [10, 20, 30, 60]


def generate_evac_polys(start_node_id, evac_times ):
    """
    
    :param start_node_id: network node id to start from
    :param evac_times: list of times in seconds
    :return: none, generates GeoJSON files
    """

    for evac_time in evac_times:

        distance_poly_query = """
            SELECT seq, id1 AS node, cost, ST_AsGeoJSON(the_geom)
                FROM pgr_drivingDistance(
                        'SELECT ogc_fid AS id, source, target,
                            ST_Length(wkb_geometry)/5000*60*60 AS cost
                         FROM geodata.ch08_e01_networklines',
                        {0}, {1}, false, false
                ) as ev_dist
                JOIN geodata.ch08_e01_networklines_vertices_pgr
                AS networklines
                ON ev_dist.id1 = networklines.id;
            """.format(start_node_id, evac_time)

        cur.execute(distance_poly_query)
        # get entire query results to work with
        distance_nodes = cur.fetchall()

        # empty list to hold each segment for our GeoJSON output
        route_results = []

        # loop over each segment in the result route segments
        # create the list of our new GeoJSON
        for dist_node in distance_nodes:
            sequence = dist_node[0]     # sequence number
            node = dist_node[1]         # node id
            cost = dist_node[2]         # cost value
            geojs = dist_node[3]        # geometry
            geojs_geom = loads(geojs) # create geojson geom
            geojs_feat = Feature(geometry=geojs_geom,
                    properties={'sequence_num': sequence,
                    'node':node, 'evac_time_sec':cost,
                    'evac_code': evac_time})
            # add each point to total including all points
            combined_result.append(geojs_feat)
            # add each point for individual evacuation time
            route_results.append(geojs_geom)

        # geojson module creates GeoJSON Feature Collection
        geojs_fc = FeatureCollection(route_results)

        # create list of points for each evac time
        evac_time_pts = [asShape(route_segment) for route_segment in route_results]

        # create MultiPoint from our list of points for evac time
        point_collection = geometry.MultiPoint(list(evac_time_pts))

        # create our convex hull polyon around evac time points
        convex_hull_polygon = point_collection.convex_hull

        # intersect convex hull with hallways polygon (ch = convex hull)
        cvex_hull_intersect = e01_hallway_shply.intersection(convex_hull_polygon)

        # export convex hull intersection to geojson
        cvex_hull = cvex_hull_intersect.__geo_interface__

        # for each evac time we create a unique GeoJSON polygon
        output_ply = "../geodata/ch08-03_dist_poly_" + str(evac_time) + ".geojson"

        write_geojson(output_ply, cvex_hull)

        output_geojson_route = "../geodata/ch08-03_dist_pts_" + str(evac_time) + ".geojson"

        # save GeoJSON to a file in our geodata folder
        write_geojson(output_geojson_route, geojs_fc )

# create or set of evac GeoJSON polygons based
# on location and list of times in seconds
generate_evac_polys(start_node_id, evac_times)

# final result GeoJSON
final_res = FeatureCollection(combined_result)

# write to disk
write_geojson("../geodata/ch08-03_final_dist_poly.geojson", final_res)

# clean up and close database cursor and connection
cur.close()
conn.close()</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec145"/>How it works...</h2></div></div></div><p>The code starts with database boiler plate code plus a function to export the GeoJSON result files. To create an evacuation polygon, we require one input, which is the starting point <a id="id391" class="indexterm"/>for the distance <a id="id392" class="indexterm"/>calculation polygon on our network. As seen in the previous section, we need to find the node on the network closest to our starting coordinate. Therefore, we run a SQL <code class="literal">select</code> to find this node that's within one meter of our coordinate.</p><p>Next up, we define the <code class="literal">combined_result</code> variable that will hold all the points reachable for all specified evacuation times in our list. Hence, it stores the results of each evacuation time in one single output.</p><p>The hallways Shapefile is then prepared as Shapely geometry because we will need it to clip our output polygons to be inside the hallways. We are only interested in seeing which areas can be evacuated within the specified time scales of 10, 20, 30, and 60 seconds. If the area is outside the hallways, you are located outside the building and, well, better said, you are safe.</p><p>Now, we will loop through each of our time intervals to create individual evacuation polygons for each time defined in our list. The <code class="literal">pgRouting</code> extension includes a function called <code class="literal">pgr_drivingDistance(),</code> which returns a list of nodes that are reachable within a specified cost. Parameters for this function include the <span class="emphasis"><em>SQL query</em></span> that returns <code class="literal">id</code>, <code class="literal">source</code>, <code class="literal">target</code>, and <code class="literal">cost</code> columns. Our final four parameters include the start node ID that's represented by the <code class="literal">%s</code> variable and equals <code class="literal">start_node_id</code>. Then, the evacuation time in seconds stored within the <code class="literal">evac_time</code> variable followed by two false values. These last two false values are for the directed route or reverse cost calculation, which we are not using.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note39"/>Note</h3><p>In our case, the cost is calculated as a time value in seconds based on distance. We assume that you are walking at 5 km/hr. The cost is then calculated as the segment length in meters divided by 5000 m x 60 min x 60 sec to derive a cost value. Then, we pass in the start node ID along with our specified evacuation time in seconds. If you want to calculate in minutes, simply remove one of the x 60 in the equation.</p></div></div><p>The geometry of each node is then derived through a SQL JOIN between the vertices table and the result list of nodes with node IDs. Now that we have our set of geometry of points for each node reachable within our evacuation time, it's time to parse this result. Parsing is required to create our GeoJSON output, and it also feeds the points into our combined output, the <code class="literal">combined_result</code> variable, and the individual evacuation time polygons that are created with a convex hull algorithm from Shapely.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip22"/>Tip</h3><p>A better or more realistic polygon could be created using alpha shapes. Alpha shapes form a polygon from a set of points, hugging each point to retain a more realistic polygon that follow the shape of the points. The convex hull simply ensures that all the points are inside the resulting polygon. For a good read on alpha shapes, check<a id="id393" class="indexterm"/> out this post by Sean Gillies at <a class="ulink" href="http://sgillies.net/blog/1155/the-fading-shape-of-alpha/">http://sgillies.net/blog/1155/the-fading-shape-of-alpha/</a> and this post at <a class="ulink" href="http://blog.thehumangeo.com/2014/05/12/drawing-boundaries-in-python/">http://blog.thehumangeo.com/2014/05/12/drawing-boundaries-in-python/</a>.</p><p>What is included in the code is the alpha shapes module called <code class="literal">//ch08/code/alpha_shape.py</code> that you can try out with the input data points created, if you've followed along so far, to create a more accurate polygon.</p></div></div><p>Our <code class="literal">route_results</code> variable stores the GeoJSON geometry used to create individual convex<a id="id394" class="indexterm"/> hull polygons. This <a id="id395" class="indexterm"/>variable is then used to populate the list of points for each evacuation set of points. It also provides the source of our GeoJSON export, creating <code class="literal">FeatureCollection</code>.</p><p>The final calculations include using Shapely to create the convex hull polygon, immediately followed by intersecting this new convex hull polygon with our input Shapefile that represents the building hallways. We are only interested in showing areas to evacuate, which boils down to only areas inside the building, hence the intersection.</p><p>The remaining code exports our results to the GeoJSON files in your <code class="literal">/ch08/geodata</code> folder. Go ahead and open this folder and drag and drop the GeoJSON files into QGIS to visualize your new results. You will want to grab the following files:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ch08-03_dist_poly_10.geojson</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ch08-03_dist_poly_20.geojson</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ch08-03_dist_poly_30.geojson</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ch08-03_dist_poly_60.geojson</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ch08-03_final_dis_poly.geojson</code></li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Creating centerlines from polygons"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec60"/>Creating centerlines from polygons</h1></div></div></div><p>For <a id="id396" class="indexterm"/>any routing algorithm to work, we need a set <a id="id397" class="indexterm"/>of network LineStrings to perform our shortest path query on. Here, you, of course, have some options, ones that you can download to the OSM data to clean up the roads. Secondly, you could digitize your own set of network lines or, thirdly, you can try to autogenerate these lines.</p><p>The generation of this network LineString is of utmost importance and determines the quality and types of routes that we can generate. In an indoor environment, we have no roads and street names; instead, we have hallways, rooms, lounges, elevators, ramps, and stairs. These<a id="id398" class="indexterm"/> features are our roads, bridges, and highway <a id="id399" class="indexterm"/>metaphors where we want to create routes for people to walk.</p><p>How we can create basic network LineStrings from polygons that represent hallways is what we are going to show you in this recipe.</p><div class="mediaobject"><img src="images/50790OS_08_06.jpg" alt="Creating centerlines from polygons"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec146"/>Getting ready</h2></div></div></div><p>This exercise requires us to have a plan of some sort in digital form with polygons representing hallways and other open spaces where people could walk. Our hallway polygon is courtesy of the Alpen-Adria-Universität Klagenfurt in Austria. The polygons were simplified to keep the rendering time low. The more complex your input geometry, the longer it will take to process.</p><p>We are using the <code class="literal">scipy</code>, <code class="literal">shapely</code>, and <code class="literal">numpy</code> libraries, so read <a class="link" href="ch01.html" title="Chapter 1. Setting Up Your Geospatial Python Environment">Chapter 1</a>, <span class="emphasis"><em>Setting Up Your Geospatial Python Environment</em></span>, if you have not done so already. Inside the <code class="literal">/ch08/code/</code> folder, you'll find the <code class="literal">centerline.py</code> module containing the <code class="literal">Centerline</code> class. This contains the<a id="id400" class="indexterm"/> actual code that generates centerlines <a id="id401" class="indexterm"/>and is imported by the <code class="literal">ch08/code/ch08-04_centerline.py</code> module.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec147"/>How to do it...</h2></div></div></div><p>Let's dive into some code:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note40"/>Note</h3><p>If you decide to run the following code straightaway, beware that the creation of centerlines is a slow process and is not optimized for performance. This code could run for 5 min on a slow machine, so be patient and keep an eye on the console until it displays <span class="strong"><strong>FINISHED</strong></span>.</p></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first task is to create a function to create our centerlines. This is the modified version of the Filip Todic orginal <code class="literal">centerlines.py</code> class:<div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# -*- coding: utf-8 -*-
from shapely.geometry import LineString
from shapely.geometry import MultiLineString
from scipy.spatial import Voronoi
import numpy as np


class Centerline(object):
    def __init__(self, inputGEOM, dist=0.5):
        self.inputGEOM = inputGEOM
        self.dist = abs(dist)

    def create_centerline(self):
        """
        Calculates the centerline of a polygon.

        Densifies the border of a polygon which is then represented
        by a Numpy array of points necessary for creating the
        Voronoi diagram. Once the diagram is created, the ridges
        located within the polygon are joined and returned.

        Returns:
            a MultiLinestring located within the polygon.
        """

        minx = int(min(self.inputGEOM.envelope.exterior.xy[0]))
        miny = int(min(self.inputGEOM.envelope.exterior.xy[1]))

        border = np.array(self.densify_border(self.inputGEOM, minx, miny))

        vor = Voronoi(border)
        vertex = vor.vertices

        lst_lines = []
        for j, ridge in enumerate(vor.ridge_vertices):
            if -1 not in ridge:
                line = LineString([
                    (vertex[ridge[0]][0] + minx, vertex[ridge[0]][1] + miny),
                    (vertex[ridge[1]][0] + minx, vertex[ridge[1]][1] + miny)])

                if line.within(self.inputGEOM) and len(line.coords[0]) &gt; 1:
                    lst_lines.append(line)

        return MultiLineString(lst_lines)

    def densify_border(self, polygon, minx, miny):
        """
        Densifies the border of a polygon by a given factor
        (by default: 0.5).

        The function tests the complexity of the polygons
        geometry, i.e. does the polygon have holes or not.
        If the polygon doesn't have any holes, its exterior
        is extracted and densified by a given factor.
        If the polygon has holes, the boundary of each hole 
        as well as its exterior is extracted and densified
        by a given factor.

        Returns:
            a list of points where each point is 
            represented
            by a list of its
            reduced coordinates.

        Example:
            [[X1, Y1], [X2, Y2], ..., [Xn, Yn]
        """

        if len(polygon.interiors) == 0:
            exterior_line = LineString(polygon.exterior)
            points = self.fixed_interpolation(exterior_line, minx, miny)

        else:
            exterior_line = LineString(polygon.exterior)
            points = self.fixed_interpolation(exterior_line, minx, miny)

            for j in range(len(polygon.interiors)):
                interior_line = LineString(polygon.interiors[j])
                points += self.fixed_interpolation(interior_line, minx, miny)

        return points

    def fixed_interpolation(self, line, minx, miny):
        """
        A helping function which is used in densifying
        the border of a polygon.

        It places points on the border at the specified 
        distance. By default the distance is 0.5 (meters)
        which means that the first point will be placed
        0.5 m from the starting point, the second point
        will be placed at the distance of 1.0 m from the
        first point, etc. Naturally, the loop breaks when
        the summarized distance exceeds
        the length of the line.

        Returns:
            a list of points where each point is
            represented by
            a list of its reduced coordinates.

        Example:
            [[X1, Y1], [X2, Y2], ..., [Xn, Yn]
        """

        count = self.dist
        newline = []

        startpoint = [line.xy[0][0] - minx, line.xy[1][0] - miny]
        endpoint = [line.xy[0][-1] - minx, line.xy[1][-1] - miny]
        newline.append(startpoint)

        while count &lt; line.length:
            point = line.interpolate(count)
            newline.append([point.x - minx, point.y - miny])
            count += self.dist

        newline.append(endpoint)

        return newline</pre></div></li><li class="listitem">Now<a id="id402" class="indexterm"/> that we have a function that <a id="id403" class="indexterm"/>creates centerlines, we need some code to import a Shapefile polygon, run the centerlines script, and export our results to GeoJSON so we that can see it in QGIS:<div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# -*- coding: utf-8 -*-
import json
import shapefile
from shapely.geometry import asShape, mapping
from centerline import Centerline


def write_geojson(outfilename, indata):
    with open(outfilename, "w") as file_out:
        file_out.write(json.dumps(indata))


def create_shapes(shapefile_path):
    '''
    Create our Polygon
    :param shapefile_path: full path to shapefile
    :return: list of Shapely geometries
    '''
    in_ply = shapefile.Reader(shapefile_path)
    ply_shp = in_ply.shapes()

    out_multi_ply = [asShape(feature) for feature in ply_shp]

    print "converting to MultiPolygon: "

    return out_multi_ply


def generate_centerlines(polygon_shps):
    '''
    Create centerlines
    :param polygon_shps: input polygons
    :return: dictionary of linestrings
    '''
    dct_centerlines = {}

    for i, geom in enumerate(polygon_shps):
        print " now running Centerline creation"
        center_obj = Centerline(geom, 0.5)
        center_line_shply_line = center_obj.create_centerline()
        dct_centerlines[i] = center_line_shply_line

    return dct_centerlines


def export_center(geojs_file, centerlines):
    '''
    Write output to GeoJSON file
    :param centerlines: input dictionary of linestrings
    :return: write to GeoJSON file
    '''
    with open(geojs_file, 'w') as out:

        for i, key in enumerate(centerlines):
            geom = centerlines[key]
            newline = {'id': key, 'geometry': mapping(geom), 'properties': {'id': key}}

            out.write(json.dumps(newline))


if __name__ == '__main__':

    input_hallways = "../geodata/shp/e01_hallways_small_3857.shp"
    # run our function to create Shapely geometries
    shply_ply_halls = create_shapes(input_hallways)

    # create our centerlines
    res_centerlines = generate_centerlines(shply_ply_halls)
    print "now creating centerlines geojson"

    # define output file name and location
    outgeojs_file = '../geodata/04_centerline_results_final.geojson'

    # write the output GeoJSON file to disk
    export_center(outgeojs_file, res_centerlines)</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec148"/>How it works...</h2></div></div></div><p>Starting<a id="id404" class="indexterm"/> with <code class="literal">centerlines.py</code> that contains the <code class="literal">Centerline</code> class, there is a lot going on inside the class. We use the <span class="strong"><strong>Voronoi</strong></span> polygons<a id="id405" class="indexterm"/> and extract <span class="strong"><strong>ridges</strong></span> as centerlines. To<a id="id406" class="indexterm"/> create<a id="id407" class="indexterm"/> these Voronoi polygons, we need to convert our polygon into LineStrings representing inner and outer polygon edges. These edges then need to be converted to points to feed the Voronoi algorithm. The points are generated based on a <span class="emphasis"><em>densify</em></span> algorithm that creates points every 0.5 m along the edge of a polygon and all the way around it. This helps the <code class="literal">Voronoi</code> function create a more accurate representation of the polygon, and hence provides a better centerline. On the negative side, the higher this distance is set, the more computing power needed.</p><p>The <code class="literal">ch08-04_centerline.py</code> code then imports this new Centerline class and actually runs it using our hallways polygon. The input polygons are read from a Shapefile using <code class="literal">pyshp</code>. Our generated shapes are then pumped into the <code class="literal">generate_centerlines</code> function to output a dictionary of LineStrings representing our centerlines.</p><p>That output dictionary is then exported to GeoJSON as we loop over the centerlines and use the standard <code class="literal">json.dumps</code> function to export it to our file.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Building an indoor routing system in 3D"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec61"/>Building an indoor routing system in 3D</h1></div></div></div><p>How<a id="id408" class="indexterm"/> to route through one or multiple buildings or floors is what this recipe is all about. This is, of course, the most complex situation involving complex data collection, preparation, and implementation processes. We cannot go into all the complex data details of collection and transformation from ACAD to PostGIS, for example; instead, the finished data is provided.</p><p>To create an indoor routing application, you need an already digitized routing network set of lines representing the areas where people can walk. Our data represents the first and second floor of a university building. The resulting indoor route, shown in the following screenshot, starts from the second floor and travels down the stairs to the first floor, all the way through the building, heading up the stairs again to the second floor, and finally reaching our destination.</p><div class="mediaobject"><img src="images/50790OS_08_07.jpg" alt="Building an indoor routing system in 3D"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec149"/>Getting ready</h2></div></div></div><p>For this recipe, we will need to complete quite a few tasks to prepare for the indoor 3D routing. Here's<a id="id409" class="indexterm"/> a quick list of requirements:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A Shapefile for the first floor (<code class="literal">/ch08/geodata/shp/e01_network_lines_3857.shp</code>).</li><li class="listitem" style="list-style-type: disc">A Shapefile for the second floor (<code class="literal">/ch08/geodata/shp/e02_network_lines_3857.shp</code>).</li><li class="listitem" style="list-style-type: disc">PostgreSQL DB 9.1 + PostGIS 2.1 and pgRouting 2.0. These were all installed in the <span class="emphasis"><em>Finding the Dijkstra shortest path with pgRouting</em></span> recipe at the beginning of this chapter.</li><li class="listitem" style="list-style-type: disc">Python modules, <code class="literal">psycopg2</code> and <code class="literal">geojson</code>.</li></ul></div><p>Here is the list of tasks that we need to carry out:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Import the Shapefile of the first floor networklines (skip this if you've completed the earlier recipe that imported this Shapefile) as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ogr2ogr -a_srs EPSG:3857 -lco "SCHEMA=geodata" -lco "COLUMN_TYPES=type=varchar,type_id=integer" -nlt MULTILINESTRING -nln ch08_e01_networklines -f PostgreSQL "PG:host=localhost port=5432 user=postgres dbname=py_geoan_cb password=air" geodata/shp/e01_network_lines_3857.shp</strong></span>
</pre></div></li><li class="listitem">Import the Shapefile of the second floor networklines as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ogr2ogr -a_srs EPSG:3857 -lco "SCHEMA=geodata" -lco "COLUMN_TYPES=type=varchar,type_id=integer" -nlt MULTILINESTRING -nln ch08_e02_networklines -f PostgreSQL "PG:host=localhost port=5432 user=postgres dbname=py_geoan_cb password=air" geodata/shp/e02_network_lines_3857.shp</strong></span>
</pre></div></li><li class="listitem">Assign routing columns to the first floor networklines (skip this step if you've completed it in the previous recipe):<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ALTER TABLE geodata.ch08_e01_networklines ADD COLUMN source INTEGER;</strong></span>
<span class="strong"><strong>ALTER TABLE geodata.ch08_e01_networklines ADD COLUMN target INTEGER;</strong></span>
<span class="strong"><strong>ALTER TABLE geodata.ch08_e01_networklines ADD COLUMN cost DOUBLE PRECISION;</strong></span>
<span class="strong"><strong>ALTER TABLE geodata.ch08_e01_networklines ADD COLUMN length DOUBLE PRECISION;</strong></span>
<span class="strong"><strong>UPDATE geodata.ch08_e01_networklines set length = ST_Length(wkb_geometry);</strong></span>
</pre></div></li><li class="listitem">Assign routing columns to the second floor networklines as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ALTER TABLE geodata.ch08_e02_networklines ADD COLUMN source INTEGER;</strong></span>
<span class="strong"><strong>ALTER TABLE geodata.ch08_e02_networklines ADD COLUMN target INTEGER;</strong></span>
<span class="strong"><strong>ALTER TABLE geodata.ch08_e02_networklines ADD COLUMN cost DOUBLE PRECISION;</strong></span>
<span class="strong"><strong>ALTER TABLE geodata.ch08_e02_networklines ADD COLUMN length DOUBLE PRECISION;</strong></span>
<span class="strong"><strong>UPDATE geodata.ch08_e02_networklines set length = ST_Length(wkb_geometry);</strong></span>
</pre></div></li><li class="listitem">Create <a id="id410" class="indexterm"/>pgRouting 3D functions that allow you to route over your 3D networklines. These two PostgreSQL functions are critically important as they reflect the original pgRouting 2D functions that have now been converted to allow 3D routing. The order of installation is also very important, so make sure you install <code class="literal">pgr_pointtoid3d.sql</code> first! Both SQL files are located in your <code class="literal">/ch08/code/</code> folder:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>psql -U username -d py_geoan_cb -a -f pgr_pointtoid3d.sql</strong></span>
</pre></div></li><li class="listitem"> Next, install <code class="literal">pgr_createTopology3d.sql</code>. This is a modified version of the original that now uses our new <code class="literal">pgr_pointtoid3d</code> functions as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>psql -U username -d py_geoan_cb -a -f pgr_createTopology3d.sql</strong></span>
</pre></div></li><li class="listitem">Now we need to merge our two floor network lines into a single 3D LineString table that we will perform our 3D routing on. This set of SQL commands is stored for you at:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>psql -U username -d py_geoan_cb -a -f indrz_create_3d_networklines.sql</strong></span>
</pre></div></li></ol></div><p>The exact creation of the 3D routing table is very important to understand as it allows 3D routing queries. Our code is, therefore, listed as follows with SQL comments describing what we are doing at each step:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>-- if not, go ahead and update</strong></span>
<span class="strong"><strong>-- make sure tables dont exist</strong></span>

<span class="strong"><strong>drop table if exists geodata.ch08_e01_networklines_routing;</strong></span>
<span class="strong"><strong>drop table if exists geodata.ch08_e02_networklines_routing;</strong></span>

<span class="strong"><strong>-- convert to 3d coordinates with EPSG:3857</strong></span>
<span class="strong"><strong>SELECT ogc_fid, ST_Force_3d(ST_Transform(ST_Force_2D(st_geometryN(wkb_geometry, 1)),3857)) AS wkb_geometry,</strong></span>
<span class="strong"><strong>  type_id, cost, length, 0 AS source, 0 AS target</strong></span>
<span class="strong"><strong>  INTO geodata.ch08_e01_networklines_routing</strong></span>
<span class="strong"><strong>  FROM geodata.ch08_e01_networklines;</strong></span>

<span class="strong"><strong>SELECT ogc_fid, ST_Force_3d(ST_Transform(ST_Force_2D(st_geometryN(wkb_geometry, 1)),3857)) AS wkb_geometry,</strong></span>
<span class="strong"><strong>  type_id, cost, length, 0 AS source, 0 AS target</strong></span>
<span class="strong"><strong>  INTO geodata.ch08_e02_networklines_routing</strong></span>
<span class="strong"><strong>  FROM geodata.ch08_e02_networklines;</strong></span>

<span class="strong"><strong>-- fill the 3rd coordinate according to their floor number</strong></span>
<span class="strong"><strong>UPDATE geodata.ch08_e01_networklines_routing SET wkb_geometry=ST_Translate(ST_Force_3Dz(wkb_geometry),0,0,1);</strong></span>
<span class="strong"><strong>UPDATE geodata.ch08_e02_networklines_routing SET wkb_geometry=ST_Translate(ST_Force_3Dz(wkb_geometry),0,0,2);</strong></span>


<span class="strong"><strong>UPDATE geodata.ch08_e01_networklines_routing SET length =ST_Length(wkb_geometry);</strong></span>
<span class="strong"><strong>UPDATE geodata.ch08_e02_networklines_routing SET length =ST_Length(wkb_geometry);</strong></span>

<span class="strong"><strong>-- no cost should be 0 or NULL/empty</strong></span>
<span class="strong"><strong>UPDATE geodata.ch08_e01_networklines_routing SET cost=1 WHERE cost=0 or cost IS NULL;</strong></span>
<span class="strong"><strong>UPDATE geodata.ch08_e02_networklines_routing SET cost=1 WHERE cost=0 or cost IS NULL;</strong></span>


<span class="strong"><strong>-- update unique ids ogc_fid accordingly</strong></span>
<span class="strong"><strong>UPDATE geodata.ch08_e01_networklines_routing SET ogc_fid=ogc_fid+100000;</strong></span>
<span class="strong"><strong>UPDATE geodata.ch08_e02_networklines_routing SET ogc_fid=ogc_fid+200000;</strong></span>


<span class="strong"><strong>-- merge all networkline floors into a single table for routing</strong></span>
<span class="strong"><strong>DROP TABLE IF EXISTS geodata.networklines_3857;</strong></span>
<span class="strong"><strong>SELECT * INTO geodata.networklines_3857 FROM</strong></span>
<span class="strong"><strong>(</strong></span>
<span class="strong"><strong>(SELECT ogc_fid, wkb_geometry, length, type_id, length*o1.cost as total_cost,</strong></span>
<span class="strong"><strong>   1 as layer FROM geodata.ch08_e01_networklines_routing o1) UNION</strong></span>
<span class="strong"><strong>(SELECT ogc_fid, wkb_geometry, length, type_id, length*o2.cost as total_cost,</strong></span>
<span class="strong"><strong>   2 as layer FROM geodata.ch08_e02_networklines_routing o2))</strong></span>
<span class="strong"><strong>as foo ORDER BY ogc_fid;</strong></span>

<span class="strong"><strong>CREATE INDEX wkb_geometry_gist_index</strong></span>
<span class="strong"><strong>   ON geodata.networklines_3857 USING gist (wkb_geometry);</strong></span>

<span class="strong"><strong>CREATE INDEX ogc_fid_idx</strong></span>
<span class="strong"><strong>   ON geodata.networklines_3857 USING btree (ogc_fid ASC NULLS LAST);</strong></span>

<span class="strong"><strong>CREATE INDEX network_layer_idx</strong></span>
<span class="strong"><strong>  ON geodata.networklines_3857</strong></span>
<span class="strong"><strong>  USING hash</strong></span>
<span class="strong"><strong>  (layer);</strong></span>

<span class="strong"><strong>-- create populate geometry view with info</strong></span>
<span class="strong"><strong>SELECT Populate_Geometry_Columns('geodata.networklines_3857'::regclass);</strong></span>

<span class="strong"><strong>-- update stairs, ramps and elevators to match with the next layer</strong></span>
<span class="strong"><strong>UPDATE geodata.networklines_3857 SET wkb_geometry=ST_AddPoint(wkb_geometry,</strong></span>
<span class="strong"><strong>  ST_EndPoint(ST_Translate(wkb_geometry,0,0,1)))</strong></span>
<span class="strong"><strong>  WHERE type_id=3 OR type_id=5 OR type_id=7;</strong></span>
<span class="strong"><strong>-- remove the second last point</strong></span>
<span class="strong"><strong>UPDATE geodata.networklines_3857 SET wkb_geometry=ST_RemovePoint(wkb_geometry,ST_NPoints(wkb_geometry) - 2)</strong></span>
<span class="strong"><strong>  WHERE type_id=3 OR type_id=5 OR type_id=7;</strong></span>


<span class="strong"><strong>-- add columns source and target</strong></span>
<span class="strong"><strong>ALTER TABLE geodata.networklines_3857 add column source integer;</strong></span>
<span class="strong"><strong>ALTER TABLE geodata.networklines_3857 add column target integer;</strong></span>
<span class="strong"><strong>ALTER TABLE geodata.networklines_3857 OWNER TO postgres;</strong></span>

<span class="strong"><strong>-- we dont need the temporary tables any more, delete them</strong></span>
<span class="strong"><strong>DROP TABLE IF EXISTS geodata.ch08_e01_networklines_routing;</strong></span>
<span class="strong"><strong>DROP TABLE IF EXISTS geodata.ch08_e02_networklines_routing;</strong></span>

<span class="strong"><strong>-- remove route nodes vertices table if exists</strong></span>
<span class="strong"><strong>DROP TABLE IF EXISTS geodata.networklines_3857_vertices_pgr;</strong></span>
<span class="strong"><strong>-- building routing network vertices (fills source and target columns in those new tables)</strong></span>
<span class="strong"><strong>SELECT public.pgr_createTopology3d('geodata.networklines_3857', 0.0001, 'wkb_geometry', 'ogc_fid');</strong></span>
</pre></div><p>Wow, that was a lot of stuff to get through, and now we are actually ready to run and create some 3D routes. Hurray!</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec150"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's<a id="id411" class="indexterm"/> dive into some code full of comments for your reading pleasure:<div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# -*- coding: utf-8 -*-

import psycopg2
import json
from geojson import loads, Feature, FeatureCollection

db_host = "localhost"
db_user = "pluto"
db_passwd = "secret"
db_database = "py_geoan_cb"
db_port = "5432"

# connect to DB
conn = psycopg2.connect(host=db_host, user=db_user, port=db_port,
                        password=db_passwd, database=db_database)

# create a cursor
cur = conn.cursor()

# define our start and end coordinates in EPSG:3857
# set start and end floor level as integer 0,1,2 for example
x_start_coord = 1587848.414
y_start_coord = 5879564.080
start_floor = 2

x_end_coord = 1588005.547
y_end_coord = 5879736.039
end_floor = 2


# find the start node id within 1 meter of the given coordinate
# select from correct floor level using 3D Z value
# our Z Value is the same as the floor number as an integer
# used as input in routing query start point
start_node_query = """
    SELECT id FROM geodata.networklines_3857_vertices_pgr AS p
    WHERE ST_DWithin(the_geom, ST_GeomFromText('POINT(%s %s)',3857), 1)
    AND ST_Z(the_geom) = %s;"""

# locate the end node id within 1 meter of the given coordinate
end_node_query = """
    SELECT id FROM geodata.networklines_3857_vertices_pgr AS p
    WHERE ST_DWithin(the_geom, ST_GeomFromText('POINT(%s %s)',3857), 1)
    AND ST_Z(the_geom) = %s;"""

# run our query and pass in the 3 variables to the query
# make sure the order of variables is the same as the 
# order in your query
cur.execute(start_node_query, (x_start_coord, y_start_coord, start_floor))
start_node_id = int(cur.fetchone()[0])

# get the end node id as an integer
cur.execute(end_node_query, (x_end_coord, y_end_coord, end_floor))
end_node_id = int(cur.fetchone()[0])


# pgRouting query to return our list of segments representing
# our shortest path Dijkstra results as GeoJSON
# query returns the shortest path between our start and end nodes above
# in 3D traversing floor levels and passing in the layer value = floor

routing_query = '''
    SELECT seq, id1 AS node, id2 AS edge, ST_Length(wkb_geometry) AS cost, layer,
           ST_AsGeoJSON(wkb_geometry) AS geoj
      FROM pgr_dijkstra(
        'SELECT ogc_fid as id, source, target, st_length(wkb_geometry) AS cost, layer
         FROM geodata.networklines_3857',
        %s, %s, FALSE, FALSE
      ) AS dij_route
      JOIN  geodata.networklines_3857 AS input_network
      ON dij_route.id2 = input_network.ogc_fid ;
  '''


# run our shortest path query
cur.execute(routing_query, (start_node_id, end_node_id))

# get entire query results to work with
route_segments = cur.fetchall()

# empty list to hold each segment for our GeoJSON output
route_result = []

# loop over each segment in the result route segments
# create the list of our new GeoJSON
for segment in route_segments:
    print segment
    seg_cost = segment[3]     # cost value
    layer_level = segment[4]  # floor number
    geojs = segment[5]        # geojson coordinates
    geojs_geom = loads(geojs) # load string to geom
    geojs_feat = Feature(geometry=geojs_geom, properties={'floor': layer_level, 'cost': seg_cost})
    route_result.append(geojs_feat)

# using the geojson module to create our GeoJSON Feature Collection
geojs_fc = FeatureCollection(route_result)

# define the output folder and GeoJSON file name
output_geojson_route = "../geodata/ch08_indoor_3d_route.geojson"


# save geojson to a file in our geodata folder
def write_geojson():
    with open(output_geojson_route, "w") as geojs_out:
        geojs_out.write(json.dumps(geojs_fc))

# run the write function to actually create the GeoJSON file
write_geojson()

# clean up and close database curson and connection
cur.close()
conn.close()</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec151"/>How it works...</h2></div></div></div><p>Using<a id="id412" class="indexterm"/> the <code class="literal">psycopg2</code> module, we can connect to our fancy new tables in the database and run some queries. The first query set finds the start and end nodes based on the <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>, and <span class="emphasis"><em>Z</em></span> elevation values. The <span class="emphasis"><em>Z</em></span> value is VERY important; otherwise, the wrong node will be selected. The <span class="emphasis"><em>Z</em></span> value corresponds one to one with a layer/floor value. The 3D elevation data assigned to our <code class="literal">networklines_3857</code> dataset is simply one meter for floor one and two meters for floor two. This keeps things simple and easy to remember without actually using the real height of the floors, which, of course, you could do if you want to.</p><p>Our 3D routing is then able to run like any other normal 2D routing query because the data is now in 3D, thanks to our two new pgRouting functions. The query goes through, selects our data, and returns a nice GeoJSON string.</p><p>You have seen the remaining code before. It exports the results to a GeoJSON file on disk so that you can open it in QGIS for viewing. We've managed to add a couple of properties to the new GeoJSON file, including the floor number, cost in terms of distance, and the route segment type that identifies whether a segment is an indoor way or is in the form of stairs.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Calculating indoor route walk time"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec62"/>Calculating indoor route walk time</h1></div></div></div><p>Our<a id="id413" class="indexterm"/> indoor routing application would not be complete without letting us know how long it would take to walk to our indoor walk now, would it? We will create a couple of small functions that you can insert into your code in the previous recipe to print out the route walk times.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec152"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Without further ado, let's take a look at some code:<div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# -*- coding: utf-8 -*-

def format_walk_time(walk_time):
    """
    takes argument: float walkTime in seconds
    returns argument: string time  "xx minutes xx seconds"
    """
    if walk_time &gt; 0.0:
        return str(int(walk_time / 60.0)) + " minutes " + str(int(round(walk_time % 60))) + " seconds"
    else:
        return "Walk time is less than zero! Something is wrong"


def calc_distance_walktime(rows):
    """
    calculates distance and walk_time.
    rows must be an array of linestrings --&gt; a route, retrieved from the DB.
    rows[5]: type of line (stairs, elevator, etc)
    rows[3]: cost as length of segment
    returns a dict with key/value pairs route_length, walk_time
    """

    route_length = 0
    walk_time = 0

    for row in rows:

        route_length += row[3]
        #calculate walk time
        if row[5] == 3 or row[5] == 4:  # stairs
            walk_speed = 1.2 # meters per second m/s
        elif row[5] == 5 or row[5] == 6:  # elevator
            walk_speed = 1.1  # m/s
        else:
            walk_speed = 1.39 # m/s

        walk_time += (row[3] / walk_speed)

    length_format = "%.2f" % route_length
    real_time = format_walk_time(walk_time)
    print {"route_length": length_format, "walk_time": real_time}</pre></div></li><li class="listitem">Your <a id="id414" class="indexterm"/>results should show you a dictionary as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>{'walk_time': '4 minutes 49 seconds', 'route_length': '397.19'}</strong></span>
</pre></div><p>Here, it is assumed that you have placed these functions into our previous recipe and have called the function to print the results to the console.</p></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec153"/>How it works...</h2></div></div></div><p>We have two simple functions to create walk times for our indoor routes. The first function, called <code class="literal">format_walk_time()</code>, simply takes the resulting time and converts it to a human-friendly<a id="id415" class="indexterm"/> form, showing the minutes and seconds, respectively, that are required for output.</p><p>The second function, <code class="literal">calc_distance_walktime()</code>, does the work, expecting a list object including the distance. This distance then gets summed for each route segment into a total distance value that's stored in the <code class="literal">route_length</code> variable. Our <code class="literal">real_time</code> variable is then created by calling upon the <code class="literal">format_walk_time</code> function that passes in the <code class="literal">walk_time</code> value in seconds.</p><p>Now you have a sophisticated indoor route with specified walk times for your application.</p></div></div></div>
</body></html>