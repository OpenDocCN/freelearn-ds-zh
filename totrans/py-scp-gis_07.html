<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Geoprocessing with Geodatabases</h1>
                </header>
            
            <article>
                
<p class="mce-root">In <a href="42c1ea5a-7372-4688-bb7f-fc3822248562.xhtml" target="_blank">Chapter 3</a>, <em>Introduction to Geospatial Databases</em>, you learned how to install PostGIS, create a table, add data, and perform basic spatial queries. In this chapter, you will learn how to work with geospatial databases to answer questions and make maps. This chapter will have you load crime data into tables. Once you have populated your geodatabase with real-world data, you will learn how to perform common crime analysis tasks. You will learn how to map queries, query by date ranges, and perform basic geoprocessing tasks such as buffers, point in polygon, and nearest neighbor. You will learn how to add widgets to your Jupyter Notebooks to allow queries to be interactive. Lastly, you will learn how to use Python to create charts from your geospatial queries. As a crime analyst, you will make maps, but not all GIS-related tasks are map-based. Analysts use GIS data to answer questions and create reports. Executives are often more familiar with charts and graphs.</p>
<p><span>In this chapter, you will learn:</span></p>
<ul>
<li><span>How to use spatial queries to perform geoprocessing tasks</span></li>
<li>How to add triggers to your tables</li>
<li>How to map your geospatial query results</li>
<li><span>How to graph geospatial queries</span></li>
<li>How to use Jupyter to interact with and connect widgets to your queries</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A crime dashboard</h1>
                </header>
            
            <article>
                
<p>To build an interactive <strong>crime dashboard</strong>, you will need to collect data to build a database. Then, you will query the data and add widgets to allow users to modify the queries without needing to code. Lastly, you will graph and map the query results.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building a crime database</h1>
                </header>
            
            <article>
                
<p>To build the components for a crime dashboard, we will use the City of Albuquerque's open data. Albuquerque has datasets for crime incidents, as well as area commands and <kbd>beats</kbd>. By combining the areas with <kbd>incidents</kbd>, you will be able to report on two geographic areas. You could then extend the analysis using neighborhood associations or any other boundary—Census blocks, groups, or tracts, and get demographic information as well. </p>
<div class="packt_infobox">You can find links to the data on the main open data site located at: <a href="http://www.cabq.gov/abq-data/">http://www.cabq.gov/abq-data/</a>. Scroll to the bottom of the page and look for the <span class="packt_screen">Safety Data Sets</span> heading. </div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the tables</h1>
                </header>
            
            <article>
                
<p>We will need to create three tables to hold the crime data. We need a table for:</p>
<ol>
<li>Area commands</li>
<li>Beats</li>
<li>Incidents</li>
</ol>
<p>To create the tables, we need to import the required libraries:</p>
<pre>import psycopg2<br/>import requests<br/>from shapely.geometry import Point,Polygon,MultiPolygon, mapping<br/>import datetime</pre>
<p>The precious code imports <kbd>psycopg2</kbd> for connecting to PostGIS, <kbd>requests</kbd> to make the call to the service so you can grab the data, <kbd>Point</kbd>, <kbd>Polygon</kbd>, and <kbd>MultiPolygon</kbd> from <kbd>shapely.geometry</kbd> to make converting the <kbd>GeoJSON</kbd> to objects easier, and <kbd>datetime</kbd> because the <kbd>incidents</kbd> have a <kbd>date</kbd> field.</p>
<p>In <a href="42c1ea5a-7372-4688-bb7f-fc3822248562.xhtml" target="_blank">Chapter 3</a>, <em>Introduction to Geospatial Databases</em>, you created a database named <kbd>pythonspatial</kbd> with a user called <kbd>postgres</kbd>. We will create the tables in that database. To populate the tables, we will copy some of the fields from the service. The layer page of the service has a list of fields at the bottom.</p>
<div class="packt_tip">The URL to the layer is linked to the root page of the service or the layer number. For incidents, the URL to the layer is: <a href="http://coagisweb.cabq.gov/arcgis/rest/services/public/APD_Incidents/MapServer/0">http://coagisweb.cabq.gov/arcgis/rest/services/public/APD_Incidents/MapServer/0</a>.</div>
<p>Each of the fields has a type and length<span> for the <kbd>incidents</kbd> layer</span> as follows:</p>
<ul>
<li><kbd>OBJECTID</kbd> (type: esriFieldTypeOID, alias: Object_ID)</li>
<li><kbd>Shape</kbd> (type: esriFieldTypeGeometry, alias: Geometry)</li>
<li><kbd>CV_BLOCK_ADD</kbd> (type: esriFieldTypeString, alias: Location, length: 72)</li>
<li><kbd>CVINC_TYPE</kbd> (type: esriFieldTypeString, alias: Description, length: 255)</li>
<li><kbd>date</kbd> (type: esriFieldTypeDate, alias: Date, length: 8)</li>
</ul>
<div class="packt_infobox"><strong><br/>
Supported operations</strong>: Query, Generate Renderer, Return updates.</div>
<p>Create the tables using the following code:</p>
<pre>connection = psycopg2.connect(database="pythonspatial",user="postgres", password="postgres")<br/>cursor = connection.cursor()<br/><br/>cursor.execute("CREATE TABLE areacommand (id SERIAL PRIMARY KEY, name VARCHAR(20), geom GEOMETRY)")<br/><br/>cursor.execute("CREATE TABLE beats (id SERIAL PRIMARY KEY, beat VARCHAR(6), agency VARCHAR(3), areacomm VARCHAR(15),geom GEOMETRY)")<br/><br/>cursor.execute("CREATE TABLE incidents (id SERIAL PRIMARY KEY, address VARCHAR(72), crimetype VARCHAR(255), date DATE,geom GEOMETRY)")<br/><br/>connection.commit()</pre>
<p>The previous code starts by creating the connection and getting the <kbd>cursor</kbd>. It then creates the <kbd>areacommand</kbd> table, with a field for the <kbd>name</kbd> and a <kbd>GEOMETRY</kbd> field. In the <strong>ArcServer</strong> service, the area command field has a length of <kbd>20</kbd>, so the code created a field called <kbd>name</kbd> as a <kbd>VARCHAR(20)</kbd>. The next two lines create the tables for <kbd>beats</kbd> and <kbd>incidents</kbd>, and lastly, the code commits, making the changes permanent.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Populating the data</h1>
                </header>
            
            <article>
                
<p>With the tables in place, we need to grab the data and populate them. The following code will grab the area commands and insert them into our table:</p>
<pre>url='http://coagisweb.cabq.gov/arcgis/rest/services/public/adminboundaries/MapServer/8/query'<br/>params={"where":"1=1","outFields":"*","outSR":"4326","f":"json"}<br/>r=requests.get(url,params=params)<br/>data=r.json()<br/><br/>for acmd in data['features']:<br/>    polys=[]<br/> <br/>    for ring in acmd['geometry']['rings']:<br/>        polys.append(Polygon(ring))<br/>    p=MultiPolygon(polys)<br/>    name=acmd['attributes']['Area_Command']<br/>    <br/>    cursor.execute("INSERT INTO areacommand (name, geom) VALUES ('{}',<br/>    ST_GeomFromText('{}'))".format(name, p.wkt))<br/> <br/> connection.commit()</pre>
<p>The previous code uses <kbd>requests</kbd> to query the URL passing parameters. The parameters just grab all the data (<kbd>1=1</kbd>), and grab all the fields (<kbd>*</kbd>) in reference <kbd>4326</kbd> and as <kbd>json</kbd>. The results are loaded in the variable <kbd>data</kbd> using the <kbd>json()</kbd> method. </p>
<div class="packt_infobox">To learn about the<strong> Environmental Systems Research Institute</strong> (<strong>ESRI</strong>) ArcServer query parameters, see the API reference here: <a href="http://coagisweb.cabq.gov/arcgis/sdk/rest/index.html#/Query_Map_Service_Layer/02ss0000000r000000/">http://coagisweb.cabq.gov/arcgis/sdk/rest/index.html#/Query_Map_Service_Layer/02ss0000000r000000/</a></div>
<p>The next block of code is the <kbd>for</kbd> loop that will insert the data. The service returns <kbd>json</kbd>, and the data we need is stored in the features array. For each area command (<kbd>acmd</kbd>) in the <kbd>features</kbd> array (<kbd>data['features']</kbd>), we will grab the <kbd>name</kbd> and <kbd>geometry</kbd>.</p>
<p>The <kbd>geometry</kbd> is comprised of multiple <kbd>rings</kbd>—in this case, because our data is comprised of polygons. We need to loop through the <kbd>rings</kbd>. To do so, the code has another <kbd>for</kbd> loop that iterates through each <kbd>ring</kbd>, creates a polygon, and adds it to <kbd>polys[]</kbd>. When all the <kbd>rings</kbd> are collected as polygons, the code creates a single <kbd>MultiPolygon</kbd> with the name of the area command and inserts it into the table using <kbd>cursor.execute()</kbd>.</p>
<p>The SQL is the basic insert command but uses a parameterized query and <kbd>ST_GeometryFromText()</kbd>. Do not get distracted by those additions. Build the query by using the base query as follows:</p>
<pre>INSERT INTO table (field, field) VALUES (value,value)</pre>
<p>To pass the values, the code uses <kbd>.format()</kbd>. It passes the string name and uses Shapely to convert the coordinates to WKT (<kbd>p.wkt</kbd>).</p>
<p>You will need to do the same thing for the <kbd>beats</kbd> table:</p>
<pre>url='http://coagisweb.cabq.gov/arcgis/rest/services/public/adminboundaries/MapServer/9/query'<br/>params={"where":"1=1","outFields":"*","outSR":"4326","f":"json"}<br/>r=requests.get(url,params=params)<br/>data=r.json()<br/><br/>for acmd in data['features']:<br/>    polys=[]<br/>    for ring in acmd['geometry']['rings']:<br/>        polys.append(Polygon(ring))<br/>    p=MultiPolygon(polys)<br/> <br/>    beat = acmd['attributes']['BEAT']<br/>    agency = acmd['attributes']['AGENCY']<br/>    areacomm = acmd['attributes']['AREA_COMMA']<br/><br/>    cursor.execute("INSERT INTO beats (beat, agency,areacomm,geom) VALUES ('{}','{}','{}',<br/>    ST_GeomFromText('{}'))".format(beat,agency,areacomm,p.wkt))<br/> <br/>connection.commit()</pre>
<p>The previous code is the same as the code for area commands, only passing additional fields using multiple placeholders (<kbd>'{}'</kbd>).</p>
<p>Lastly, we need to add the <kbd>incidents</kbd>:</p>
<pre>url='http://coagisweb.cabq.gov/arcgis/rest/services/public/APD_Incidents/MapServer/0/query'<br/>params={"where":"1=1","outFields":"*","outSR":"4326","f":"json"}<br/>r=requests.get(url,params=params)<br/>data=r.json()<br/><br/>for a in data["features"]:<br/>    address=a["attributes"]["CV_BLOCK_ADD"]<br/>    crimetype=a["attributes"]["CVINC_TYPE"]<br/>    if a['attributes']['date'] is None:<br/>        pass<br/>    else:<br/>        date = datetime.datetime.fromtimestamp(a['attributes']['date'] / 1e3).date()<br/>    try:<br/>        p=Point(float(a["geometry"]["x"]),float(a["geometry"]["y"]))<br/>        cursor.execute("INSERT INTO incidents (address,crimetype,date, geom) VALUES<br/>        ('{}','{}','{}', ST_GeomFromText('{}'))".format(address,crimetype,str(date), p.wkt))<br/> <br/>   except KeyError:<br/>        pass<br/>connection.commit()</pre>
<p>The previous code grabs the data using <kbd>requests</kbd>. It then iterates through the <kbd>features</kbd>. This code block has some error checking because there are <kbd>features</kbd> with blank dates and some with no coordinates. The code passes if there is no <kbd>date</kbd> and uses a <kbd>try</kbd>, with the <kbd>catch</kbd> block accepting a <kbd>KeyError</kbd>, which will catch the missing coordinates.</p>
<p>Now that the data is loaded into the tables, we can start to query the data and present it in maps and charts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mapping queries</h1>
                </header>
            
            <article>
                
<p>In <a href="42c1ea5a-7372-4688-bb7f-fc3822248562.xhtml" target="_blank">Chapter 3</a>, <em>Introduction to Geospatial Databases</em>, you queried the database and got text back. The <kbd>geometry</kbd> came back as <strong>well-known text</strong> (<strong>WKT</strong>). These are the results we asked for, but I cannot visualize geographic data by reading a list of coordinates. I need to see it on a map. In this section, you will use <kbd>ipyleaflet</kbd> and Jupyter to map the results of your queries.</p>
<p>To map the queries in Jupyter, you need to install <kbd>ipyleaflet</kbd>. You can do this using <kbd>pip</kbd> at your OS's command prompt:</p>
<pre><strong>pip install ipyleaflet</strong></pre>
<p>Then you may need to enable the extension, depending on your environment. At the command prompt, type:</p>
<pre><strong>jupyter nbextension enable --py --sys-prefix ipyleaflet</strong></pre>
<div class="packt_infobox">For the code, and examples of using <kbd>ipyleaflet</kbd>, you can view the GitHub repository at: <a href="https://github.com/ellisonbg/ipyleaflet">https://github.com/ellisonbg/ipyleaflet</a></div>
<p>If you receive an error in your mapping, you may need to enable the <kbd>widgetsnbextension</kbd>:</p>
<pre><strong>jupyter nbextension enable --py --sys-prefix widgetsnbextension</strong></pre>
<p>If you have Jupyter running, you will need to restart it.</p>
<p>With <kbd>ipyleaflet</kbd> installed and enabled, you can map your queries:</p>
<pre>import psycopg2<br/>from shapely.geometry import Point,Polygon,MultiPolygon<br/>from shapely.wkb import loads<br/>from shapely.wkt import dumps, loads<br/>import datetime<br/>import json<br/>from ipyleaflet import (<br/>    Map, Marker,<br/>    TileLayer, ImageOverlay,<br/>    Polyline, Polygon, Rectangle, Circle, CircleMarker,<br/>    GeoJSON<br/>)</pre>
<p>The previous code imports the libraries we need to query and map the data. Let's make the <kbd>connection</kbd> and get the <kbd>cursor</kbd>, as shown in the following code:</p>
<pre>connection = psycopg2.connect(database="pythonspatial",user="postgres", password="postgres")<br/>cursor = connection.cursor()</pre>
<p>In <a href="42c1ea5a-7372-4688-bb7f-fc3822248562.xhtml" target="_blank">Chapter 3</a>, <em>Introduction to Geospatial Databases</em>, the queries all used <kbd>ST_AsText()</kbd> to return <kbd>geometry</kbd>. Now that we will map the results, it will be easier if we have them returned as <kbd>GeoJSON</kbd>. In the following code, you will use <kbd>ST_AsGeoJSON()</kbd> to get the <kbd>geometry</kbd>:</p>
<pre>cursor.execute("SELECT name, ST_AsGeoJSON(geom) from areacommand")<br/>c=cursor.fetchall()<br/>c[0]</pre>
<p>The previous query grabs all the records in the <kbd>areacommand</kbd> table, with their <kbd>name</kbd> and <kbd>geometry</kbd> as <kbd>GeoJSON</kbd>, then prints the first record (<kbd>c[0]</kbd>). The result is as follows:</p>
<pre><strong>('FOOTHILLS',</strong><br/><strong> '{"type":"MultiPolygon","coordinates":[[[[-106.519742762931,35.0505292241227],[-106.519741401085,35.0505292211811],[-106.51973952181,35.0505292175042],[-106.518248463965,35.0505262104449],[-106.518299012166,35.0517336649125],[-106.516932057477,35.0537380198153],....]]]}</strong></pre>
<div class="packt_infobox"><kbd>ST_AsText</kbd> and <kbd>ST_AsGeoJSON</kbd> are two of the 17 ways to get <kbd>geometry</kbd> out of PostGIS. For a full list of available return types, see the PostGIS reference at: <a href="https://postgis.net/docs/reference.html#Geometry_Accessors">https://postgis.net/docs/reference.html#Geometry_Accessors</a></div>
<p>Now that you have some <kbd>GeoJSON</kbd>, it is time to create a map to display it. To make the leaflet map, use the following code:</p>
<pre>center = [35.106196,-106.629515]<br/>zoom = 10<br/>map = Map(center=center, zoom=zoom)<br/>map</pre>
<p>The previous code defines the <kbd>center</kbd> of the map which, for Albuquerque, I always use the intersections of I-25 and I-40. This intersection splits the city into quadrants. The code then defines the <kbd>zoom</kbd> level—the higher the number, the closer the <kbd>zoom</kbd>. Lastly, it prints the map. </p>
<p>You will have a blank basemap with <kbd>OpenStreetMap</kbd> tiles. In Jupyter, when you add data to the map, you can scroll back to the original print of the map to see the data; you do not need to reprint the map every time.</p>
<p>The <kbd>GeoJSON</kbd> of the area commands is stored in variable <kbd>c</kbd>. For every item <kbd>c[x]</kbd>, the <kbd>GeoJSON</kbd> is in position <kbd>1</kbd> <kbd>(c[x][1]</kbd>). The following code will iterate through <kbd>c</kbd> and add the <kbd>GeoJSON</kbd> to the map:</p>
<pre>for x in c:<br/>   layer=json.loads(x[1])<br/>   layergeojson=GeoJSON(data=layer)<br/>   map.add_layer(layergeojson)</pre>
<p>The previous code assigns the <kbd>GeoJSON</kbd> to a layer using <kbd>json.loads()</kbd>. This will make the returned <kbd>GeoJSON</kbd> string a dictionary in Python. Next, the code calls the <kbd>ipyleaflet GeoJSON()</kbd> method on the layer, and passes it to the variable <kbd>layergeojson</kbd>. Finally, <kbd>add_layer()</kbd> is called on the map and passes <kbd>layergeojson</kbd>. There are other ways to draw maps in Jupyter; for example, you could plot them using Matplotlib, Plotly, or Bokeh. If you come from web mapping, you are probably already familiar with the Leaflet JavaScript library, which will make using <kbd>ipyleaflet</kbd> familiar. Also, <kbd>ipyleaflet</kbd> loads a basemap and provides interactivity.</p>
<p>If you scroll up to the map, you should see the screenshot as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/fb3cfccb-7d9a-438e-a919-5461df1c5137.jpg"/></div>
<p>Changing the SQL query in <kbd>cursor.execute()</kbd>, you can map the <kbd>beats</kbd>:</p>
<pre>cursor.execute("SELECT beat, ST_AsGeoJSON(geom) from beats")<br/>c=cursor.fetchall()<br/>for x in c:<br/>   layer=json.loads(x[1])<br/>   layergeojson=GeoJSON(data=layer)<br/>   map.add_layer(layergeojson)</pre>
<p>You should see the <kbd>beats</kbd> drawn as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e89910fa-5868-48ea-8593-74ee198937a5.png"/></div>
<p>You can do the same for <kbd>incidents</kbd>, but we will hold on to that for now, because there are almost 30,000 <kbd>incidents</kbd> in the data set and it would overwhelm our map. To map <kbd>incidents</kbd>, we will use spatial queries to limit our selection.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Incidents by date</h1>
                </header>
            
            <article>
                
<p>One of the ways you can limit the results of an incident query is by <kbd>date</kbd>. Using the Python <kbd>datetime</kbd> library, you can specify a <kbd>date</kbd>, then query <kbd>incidents</kbd> on that <kbd>date</kbd>, and get the <kbd>geometry</kbd> of the results as <kbd>GeoJSON</kbd> and add it to your map:</p>
<pre>d=datetime.datetime.strptime('201781','%Y%m%d').date() <br/>cursor.execute("SELECT address,crimetype,date,ST_AsGeoJSON(geom) from incidents where date =<br/>'{}' ".format(str(d)))<br/>incidents_date=cursor.fetchall()<br/>for x in incidents_date:<br/>    layer=json.loads(x[3])<br/>    layergeojson=GeoJSON(data=layer)<br/>    map.add_layer(layergeojson)</pre>
<p>The previous code specifies a <kbd>date</kbd> (YYYYMD) of August 1, 2017. It queries the <kbd>incidents</kbd> table we're using, where <kbd>date = d</kbd> and returns the <kbd>geometry</kbd> as <kbd>GeoJSON</kbd>. It then uses the <kbd>for</kbd> loop you used for area commands, and <kbd>beats</kbd> to map the <kbd>incidents</kbd>.</p>
<div class="packt_infobox">When you create a map in a Jupyter Notebook, further blocks of code will modify that map. You may need to scroll back up to your map to see the changes. </div>
<p>The map you created earlier will now look like the screenshot as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e3a40684-3088-4091-8c8d-f01267967508.png"/></div>
<p>Besides specifying a specific <kbd>date</kbd>, you could get all the <kbd>incidents</kbd> where the <kbd>date</kbd> was greater than a specific day:</p>
<pre>d=datetime.datetime.strptime('201781','%Y%m%d').date() <br/>cursor.execute("SELECT address,crimetype,date,ST_AsGeoJSON(geom) from incidents where date &gt;<br/>'{}' ".format(str(d)))</pre>
<p>Or, you could query dates at an <kbd>interval</kbd> earlier than today and now:</p>
<pre>cursor.execute("select * from incidents where date &gt;= NOW() - interval '10 day'")</pre>
<p>The previous code uses the <kbd>NOW()</kbd> method and a <kbd>10 day</kbd> interval. By specifying <kbd>&gt;=</kbd>, you will get all the crimes that are 10 days old, and newer from the current day. I wrote this on November 24, 2017, so the results will be all <kbd>incidents</kbd> from November 14<sup>th</sup> until today. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Incidents in a polygon</h1>
                </header>
            
            <article>
                
<p>Our crime database has a polygon area—area commands and <kbd>beats</kbd>—as well as incident points. To build a crime dashboard, we want to be able to map <kbd>incidents</kbd> within a specific area command or <kbd>beat</kbd>. We can do that by using <kbd>JOIN</kbd> and <kbd>ST_Intersects</kbd>. The following code shows you how:</p>
<pre>cursor.execute("SELECT ST_AsGeoJSON(i.geom) FROM incidents i JOIN areacommand acmd ON ST_Intersects(acmd.geom, i.geom) WHERE acmd.name like'FOOTHILLS' and date &gt;= NOW() - interval '10 day';")<br/><br/>crime=cursor.fetchall()<br/>for x in crime:<br/>    layer=json.loads(x[0])<br/>    layergeojson=GeoJSON(data=layer)<br/>    map.add_layer(layergeojson)</pre>
<p>The previous code selects the <kbd>geometry</kbd> from <kbd>incidents</kbd> as <kbd>GeoJSON</kbd> (<kbd>ST_AsGeoJSON(i.geom)</kbd> from <kbd>incidents</kbd>), where the incident <kbd>ST_Intersects</kbd> the polygon area command, specifically where the name of the area command is <kbd>FOOTHILLS</kbd>. The code is joining the incident and area command tables where the intersection is true. The code limits the results by selecting only the last 10 days of crimes. </p>
<p>The code then iterates through the results and maps them as in the previous examples. You should see the screenshot as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7d335f59-7618-4ed3-804c-5a466a398938.png"/></div>
<p>The preceding screenshot overlays the <kbd>incidents</kbd> on the <kbd>Foothills</kbd> area command. Notice all the <kbd>incidents</kbd> are within the polygon. </p>
<p>You can do the same thing for specific <kbd>beats</kbd> by changing the SQL query. The following code will map specific <kbd>beats</kbd>:</p>
<pre>cursor.execute("SELECT ST_AsGeoJSON(geom)from beats where beats.beat in ('336','523','117','226','638','636')")<br/><br/>c=cursor.fetchall()<br/>for x in c:<br/>    layer=json.loads(x[0])<br/>    layergeojson=GeoJSON(data=layer)<br/>    map.add_layer(layergeojson)</pre>
<p>The previous code uses an array of the <kbd>beats.beat</kbd> field. In Python, the array is <kbd>[]</kbd>, but in the SQL statement, use parentheses. The results are the specified <kbd>beats</kbd>. Then, the code maps them.</p>
<p>Using the same specified <kbd>beats</kbd>, we can select the <kbd>incidents</kbd> using a join on <kbd>ST_Intersects()</kbd> with the <kbd>beats</kbd>, and mapping the <kbd>incidents</kbd> as shown in the code: </p>
<pre>cursor.execute("SELECT ST_AsGeoJSON(i.geom) FROM incidents i JOIN beats b ON ST_Intersects(b.geom, i.geom) WHERE b.beat in ('336','523','117','226','638','636') and date &gt;= NOW() - interval '10 day';")<br/><br/>crime=cursor.fetchall()<br/>for x in crime:<br/>    layer=json.loads(x[0])<br/>    layergeojson=GeoJSON(data=layer)<br/>    map.add_layer(layergeojson)</pre>
<p>The previous code passes the <kbd>beats</kbd> array and filters again by the last 10 days. It then maps the <kbd>incidents</kbd>, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2ec522a6-b36a-4490-b562-50d31cca930d.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Buffers</h1>
                </header>
            
            <article>
                
<p>You have mapped data from tables, but now you will map the results of a geoprocessing task—buffer.</p>
<p>To code a buffer example, we must first create a point. The following code will do that for us:</p>
<pre>from shapely.geometry import mapping<br/>p = Point([-106.578677,35.062485])<br/>pgeojson=mapping(p)<br/>player=GeoJSON(data=pgeojson)<br/>map.add_layer(player)</pre>
<p>The previous code creates a point using Shapely. It then converts it to <kbd>GeoJSON</kbd> using <kbd>shapely.geometry.mapping()</kbd>. The next two lines allow us to display it on the map.</p>
<p>PostGIS <span>allows you to send data to the database and get data back, none of which has to be in a table. For example, examine the following code:</span></p>
<pre>cursor.execute("SELECT ST_AsGeoJSON(ST_Buffer(ST_GeomFromText('{}')::geography,1500));".format(p.wkt))<br/>buff=cursor.fetchall()<br/>buffer=json.loads(buff[0][0])<br/>bufferlayer=GeoJSON(data=buffer)<br/>map.add_layer(bufferlayer)</pre>
<p>The previous code uses <kbd>ST_Buffer()</kbd> to get a polygon back from PostGIS. <kbd>ST_Buffer()</kbd> can take a point geography and a radius in meters to return the polygon. The code wraps the result in <kbd>ST_AsGeoJSON</kbd> so we can map it. In this example, the result set is a single item, so we don't need the <kbd>for</kbd> loop. The code loads the result <kbd>buff[0][0]</kbd><em> </em>and maps it.</p>
<p>The result of the previous code is shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9905bae8-76cc-4352-8b76-f5585ab4033f.png"/></div>
<p>We now have a polygon that we can use to select <kbd>incidents</kbd> from. The following code will execute the same query as earlier, but instead of <kbd>ST_AsGeoJSON</kbd>, we will use <kbd>ST_AsText</kbd>. We are not mapping the polygon, but using it as a parameter for a point in the polygon operation:</p>
<pre>cursor.execute("SELECT ST_AsText(ST_Buffer(ST_GeomFromText('{}')::geography,1500));".format(p.wkt))<br/>bufferwkt=cursor.fetchall()<br/>b=loads(bufferwkt[0][0])</pre>
<p>In the previous code, the query result is passed to a <kbd>shapely</kbd> polygon named <kbd>b</kbd> using <kbd>loads()</kbd>. Now, you can pass that polygon to another query using <kbd>ST_Intersects()</kbd>, as in the following code:</p>
<pre>cursor.execute("SELECT ST_AsGeoJSON(incidents.geom) FROM incidents where ST_Intersects(ST_GeomFromText('{}'), incidents.geom) and date &gt;= NOW() - interval '10 day';".format(b.wkt))<br/>crime=cursor.fetchall()<br/>for x in crime:<br/>    layer=json.loads(x[0])<br/>    layergeojson=GeoJSON(data=layer)<br/>    map.add_layer(layergeojson)</pre>
<p>The previous code selects the <kbd>incidents</kbd> as <kbd>GeoJSON</kbd>, where they intersect the <kbd>buffer</kbd> (<kbd>b.wkt</kbd>), and where they are within the last 10 days. The results are mapped. The following map shows the output of the previous code:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/72a6e62b-94ac-4701-9580-fe7e703099f9.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Nearest neighbor</h1>
                </header>
            
            <article>
                
<p>Using a <kbd>buffer</kbd>, you can get all the <kbd>incidents</kbd> within a specified radius of the point of interest. But what if you only want the 5, 10, or 15 closest incidents? To do that, you can use the <kbd>&lt;-&gt;</kbd> operator or k-nearest neighbor.</p>
<p>You can use the following code to select the <kbd>15</kbd> closest points to a specified point, <kbd>p</kbd>:</p>
<pre>p = Point([-106.578677,35.062485])<br/>cursor.execute("SELECT ST_AsGeoJSON(incidents.geom), ST_Distance(incidents.geom::geography,ST_GeometryFromText('{}')::geography) from incidents ORDER BY incidents.geom&lt;-&gt;ST_GeometryFromText('{}') LIMIT 15".format(p.wkt,p.wkt))<br/>c=cursor.fetchall()<br/>for x in c:<br/>    layer=json.loads(x[0])<br/>    layergeojson=GeoJSON(data=layer)<br/>    map.add_layer(layergeojson)</pre>
<p>The previous code creates a point using Shapely, and uses it in the SQL query. The query selects the incident <kbd>geometry</kbd> as <kbd>GeoJSON</kbd>, and then calculates the distance of each incident from the specified point. The <kbd>ORDER BY</kbd> clause, <kbd>&lt;-&gt;</kbd> operator, and limit clause make sure that we get the <kbd>15</kbd> nearest points in order of closeness.</p>
<p>The last block of code is our code for adding the results to the map. The results are shown in the following screenshot. The point in the center of the screenshot is the specified point:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/bbf19a2f-97a6-4d7a-a3b2-304570e2c7d2.png"/></div>
<p>Now that you know how to map the results of your spatial queries, let's add interactive widgets to modify the queries and change the map without writing new code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interactive widgets</h1>
                </header>
            
            <article>
                
<p>At the beginning of the chapter, you learned how to query and map <kbd>incidents</kbd> based on a <kbd>date</kbd>. In Jupyter, you can use interactive widgets to change values. The code will help us in how you can use <kbd>ipywidgets</kbd> to import <kbd>interact</kbd>, which will allow you to insert a <kbd>DatePicker</kbd> so that you can select a <kbd>date</kbd> to interact with the Notebook:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/21e217ae-4e75-4102-a6f2-947fe5623420.png"/></div>
<p><span>The previous code imports <kbd>interact</kbd> and the <kbd>DatePicker</kbd> widget. At its simplest, the previous screenshot shows a decorator and function to allow interactively selecting a <kbd>date</kbd> and displaying it as a string.</span></p>
<p>When the <kbd>DatePicker</kbd> changes, <kbd>x</kbd> (the <kbd>DatePicker</kbd>) is sent to the function <kbd>theDate(x)</kbd>, and <kbd>x</kbd> is printed as a string. The actual return value is <kbd>datetime.date</kbd>.</p>
<p>Using the <kbd>DatePicker</kbd> widget, you can pass a <kbd>date</kbd> value to an SQL query, and then map the results. When the <kbd>DatePicker</kbd> changes, you can erase the map and then display the new results. The following code will show you how:</p>
<pre>from ipywidgets import interact, interactive, fixed, interact_manual,DatePicker<br/>import ipywidgets as widgets<br/><br/>@widgets.interact(x=DatePicker())<br/>def theDate(x):<br/> <br/>    if x:<br/>        for l in map.layers[1:]:<br/>        map.remove_layer(l)<br/>    nohyphen=str(x).replace("-","")<br/>    d=datetime.datetime.strptime(nohyphen,'%Y%m%d').date() <br/>    cursor.execute("SELECT ST_AsGeoJSON(geom) from incidents where date <br/>    = '{}' ".format(str(d))) <br/>    c=cursor.fetchall()<br/> <br/>    for x in c:<br/>        layer=json.loads(x[0])<br/>        layergeojson=GeoJSON(data=layer)<br/>        map.add_layer(layergeojson)<br/>    return len(c)<br/> <br/>    else:<br/>        pass</pre>
<p>The previous code creates an interactive <kbd>DatePicker</kbd> widget. The code has an <kbd>if...else</kbd> statement because, on the first pass, <kbd>x</kbd> will be none. The <kbd>DatePicker</kbd> is not selected, so we <kbd>pass</kbd> on the first go around.</p>
<p>Next, the code grabs all the layers on the map, and removes them using <kbd>map.remove_layer()</kbd>, starting at the second (<kbd>[1:]</kbd>) layer. Why the second layer? Because the first layer on the map is the <kbd>TileLayer</kbd>—the basemap. We want that to stay, and only remove the markers that were added from the SQL query.</p>
<p>The code then strips the hyphens from the <kbd>date</kbd> string and converts it into a <kbd>datetime</kbd>. Once it is a <kbd>datetime</kbd>, you can pass it to the SQL query.</p>
<p>The next code block is the same block you have used throughout this chapter to add the query results to the map. </p>
<p>Selecting a <kbd>date</kbd> of November 2, 2017, is shown in the following screenshot: </p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ed83f731-e64d-49ca-ab8a-ca09926047fc.png"/></div>
<p>And when selecting November 8, 2017, the map is redrawn and shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/573d8ec3-9954-4981-82bc-c25e4e341f90.png"/></div>
<p>These screenshots were generated immediately following the reselection of a <kbd>date</kbd>. A user can use a <kbd>DatePicker</kbd> drop-down to requery the data in your PostGIS database.</p>
<p>In Jupyter, if you set the value of a variable to a string or an integer, you will get a number slider or a text box. In the following screenshot, the decorator has <kbd>x="None"</kbd>, with <kbd>None</kbd> being a string. The text <kbd>None</kbd> is a placeholder to create the text box. This creates a text box with the word <kbd>None</kbd> in it:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/bd28f970-d507-45b6-9ae6-e943bad6d1cc.png"/></div>
<p>The code in the previous screenshot is presented as follows. The code will allow you to type the name of an area command, and then display the <kbd>incidents</kbd> within that area command:</p>
<pre>@widgets.interact(x="None")<br/>def areaCommand(x):<br/>    if x:<br/>        for l in map.layers[1:]:<br/>            map.remove_layer(l)<br/>        cursor.execute("SELECT ST_AsGeoJSON(i.geom) FROM incidents i <br/>        JOIN areacommand acmd ON   <br/>        ST_Intersects(acmd.geom, i.geom) WHERE acmd.name like'{}' and <br/>        date &gt;= NOW() - interval '10 <br/>        day';".format(x))<br/>        c=cursor.fetchall()<br/> <br/>        for x in c:<br/>            layer=json.loads(x[0])<br/>            layergeojson=GeoJSON(data=layer)<br/>            map.add_layer(layergeojson)<br/>        return c<br/>    else:<br/>        pass</pre>
<p>The previous code starts with the decorator and a string. This will draw the text box. The <kbd>areaCommand()</kbd> function acts exactly as the <kbd>date</kbd> example mentioned earlier, but passes a string to the SQL query. It returns the results of the query, and draws the <kbd>incidents</kbd> on the map. </p>
<p>The following screenshot shows the return values for <kbd>NORTHWEST</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/47fdc251-03f1-4ff6-a9f6-a9ae6abb3548.png" style="width:35.75em;height:24.50em;"/> </div>
<p>The following screenshot shows the map when the user types <kbd>NORTHWEST</kbd> in the text box:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e398e0e1-7be4-48eb-ab99-caa76341fcf9.png" style="width:58.67em;height:23.92em;"/></div>
<p>In this section, you have learned how to perform queries on your spatial data, and how to map the results. In the next section, you will learn how to chart the results of your queries.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Charts</h1>
                </header>
            
            <article>
                
<p>Maps are a great data visualization tool, but sometimes a bar chart will do the trick. In this section, you will learn how to chart your data using <kbd>pandas.DataFrame</kbd>. </p>
<p>A <kbd>DataFrame</kbd> stores two-dimensional tabular data (think of a spreadsheet). Data frames can be loaded with data from many different sources and data structures, but what interests us is that it can load data from SQL queries. </p>
<p>The following code loads an SQL query into a <kbd>DataFrame</kbd>:</p>
<pre>import pandas as pd<br/>d=datetime.datetime.strptime('2017101','%Y%m%d').date()<br/>cursor.execute("SELECT date, count(date) from incidents where date &gt; '{}' group by date".format(str(d)))<br/>df=pd.DataFrame(cursor.fetchall(),columns=["date","count"])<br/>df.head()</pre>
<p>The previous code selects the <kbd>date</kbd>, and then counts the occurrence of each <kbd>date</kbd> in <kbd>incidents</kbd> where the <kbd>date</kbd> is greater than October 1, 2017. The <kbd>DataFrame</kbd> is then populated using <kbd>DataFrame</kbd> (SQL, columns). In this case, the code passes <kbd>cursor.fetchall()</kbd><em>,</em> and <kbd>columns=["date","count"]</kbd>. The resulting five records are displayed using <kbd>df.head()</kbd>. You could use <kbd>df.tial()</kbd> to see the last five records, or <kbd>df</kbd> to see it all. </p>
<p>The following screenshot shows <kbd>df.head()</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1c74eb97-d105-424a-9e1d-6ebbef910774.png"/></div>
<p>The preceding screenshot shows that on <span class="packt_screen">2017-10-17</span>, there were <span class="packt_screen">175</span> <kbd>incidents</kbd>. </p>
<p>You can plot a <kbd>DataFrame</kbd> by calling the <kbd>plot()</kbd> method from the <kbd>pandas</kbd> library. The following code will plot a bar chart of the <kbd>DataFrame</kbd> <kbd>df</kbd>:</p>
<pre>df.sort_values(by='date').plot(x="date",y="count",kind='bar',figsize=(15,10))</pre>
<p>The previous code sorts the data frame by <kbd>date</kbd>. This is so that the dates are in chronological order in our bar chart. It then plots the data using a bar chart, with the <em>x</em>-axis being the <kbd>date</kbd>, and the <em>y</em>-axis is the <kbd>count</kbd>. I specified the figure size to make it fit on the screen. For smaller data sets, the default figure size tends to work well.</p>
<p>The following screenshot is the result of the <kbd>plot</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9da3f2f5-50e5-4513-a167-494f2b73bb9d.png"/></div>
<p>This chart shows us what a map cannot—that crimes seem to decrease on Friday and Saturday. </p>
<p>Let's walk through another example using <kbd>beats</kbd>. The following code will load crimes by <kbd>beat</kbd>:</p>
<pre>cursor.execute("SELECT beats.beat, beats.agency, count(incidents.geom) as crimes from beats left join incidents on ST_Contains(beats.geom,incidents.geom) group by beats.beat, beats.agency")<br/>area=pd.DataFrame(cursor.fetchall(),columns=["Area","Agency","Crimes"])<br/>area.head()</pre>
<p>The previous code selects the <kbd>beat</kbd>, <kbd>agency</kbd>, and count of <kbd>incidents</kbd> from the <kbd>beats</kbd> table. Notice the <kbd>left join</kbd>. The <kbd>left join</kbd> will give us <kbd>beats</kbd> that may have zero <kbd>incidents</kbd>. The join is based on an incident being in a <kbd>beat</kbd> polygon. We group by each field we selected.</p>
<p>The query is loaded into a <kbd>DataFrame</kbd>, and the <kbd>head()</kbd> is displayed. The result is in the screenshot as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a10108e4-06b6-4ea6-a6f7-d41e7a9fd2d6.jpg"/></div>
<p>Notice that we have <kbd>beats</kbd> with no crimes instead of missing beats. There are too many <kbd>beats</kbd> to scroll through, so let's chart the <kbd>DataFrame</kbd>. We will use the plot function again, passing an <kbd>x</kbd>, <kbd>y</kbd>, <kbd>kind</kbd>, and <kbd>figsize</kbd> as follows:</p>
<pre><span>area.plot(x="Area",y="Crimes",kind='bar',figsize=(25,10))</span></pre>
<p>The result of the plot is shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e31d97c2-6256-4473-9748-7d23f9830bc0.png"/></div>
<p>That is a lot of data to look through, but certain <kbd>beats</kbd> stand out as high crime. This is where data frames can help. You can query the <kbd>DataFrame</kbd> instead of requerying the database. The following code will plot the selection of <kbd>beats</kbd>:</p>
<pre>area[(area['Crimes']&gt;800)].plot(x='Area',y='Crimes',kind='bar')</pre>
<p>The previous code passes an expression to the area. The expression selects records in the <kbd>DataFrame</kbd> column <kbd>Crimes</kbd>, where the value is over <kbd>800</kbd>; <kbd>Crimes</kbd> is the <kbd>count</kbd> column. The result is shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/82ad4c02-e28a-45a5-9c19-eef2d798574a.png"/></div>
<p>Loading your queries into a <kbd>DataFrame</kbd> will allow you to plot the data, but also to slice and query the data again without having to requery the database. You can also use the interactive widgets to allow users to modify the charts as you learned with the maps. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Triggers</h1>
                </header>
            
            <article>
                
<p>In any database, when data is inserted, updated, or deleted, you can have the table launch a <strong>trigger</strong>. For example, if a user inserts a record, you could launch a trigger to make sure that the record meets some specified criteria—no null values. Spatial databases allow you to use the same triggers. You can create these in several languages, including Python and SQL. The following example will use <kbd>PL/pgsql</kbd>.</p>
<p>You create triggers using SQL expressions. The following code will create a trigger to prevent entering an incomplete incident:</p>
<pre>query=('CREATE FUNCTION newcrime()'+'\n'<br/> 'RETURNS trigger' +'\n'<br/> 'AS $newcrime$' +'\n'<br/> 'BEGIN' +'\n'<br/> 'IF NEW.crimetype IS NULL THEN'+'\n'<br/> 'RAISE EXCEPTION' +" '% Must Include Crime Type', NEW.address;"+'\n'<br/> 'END IF;'+'\n'<br/> 'RETURN NEW;'+'\n'<br/> 'END;'+'\n'<br/> '$newcrime$'+'\n'<br/> 'LANGUAGE \'plpgsql\';'<br/> )<br/> cursor.execute(query)</pre>
<p>The previous code creates a new function named <kbd>newcrime()</kbd>. The function is an <kbd>if</kbd> statement that checks if the <kbd>NEW.crimetype</kbd> is null. If it is, the record is not added, and an exception is raised. The exception will state that <kbd>NEW.address</kbd> must include a crime type. The assumption is being made that the address is not null.</p>
<p>Now that you have a function, you can create a trigger that calls that function. The following code shows you how:</p>
<pre class="mce-root">query=('CREATE TRIGGER newcrime BEFORE INSERT OR UPDATE ON incidents FOR EACH ROW EXECUTE PROCEDURE newcrime()')<br/>cursor.execute(query)<br/>connection.commit()</pre>
<p>The previous code executes the SQL statement that creates the trigger. It is created <kbd>BEFORE INSERT OR UPDATE</kbd>. To test the trigger, let's insert a point with no crime type. The following code will attempt to enter the incident:</p>
<pre>p=Point([-106,35])<br/>address="123 Sesame St"<br/>cursor.execute("INSERT INTO incidents (address, geom) VALUES ('{}', ST_GeomFromText('{}'))".format(address, p.wkt))</pre>
<p>The previous code creates an incident with only an <kbd>address</kbd> and a <kbd>geom</kbd>. The result of executing the previous code is shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4cae4022-c224-4c5b-8834-d4352df0b5ad.png"/></div>
<p>In the previous screenshot, the <span class="packt_screen">InternalError</span> states that <span class="packt_screen">123 Sesame St Must Include Crime Type</span>. Our trigger successfully blocked bad data from being entered. To double-check, we can query for <kbd>"123 Sesame St."</kbd> The results are shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f85d2d8f-fb99-4010-b4ac-5fdc0988b275.png"/></div>
<p>A trigger can be used to prevent bad data from being loaded for emailing or texting when changes have occurred. For example, you could allow users to enter polygons they are interested in, and their phone number. On a new incident being added to the database, you could see if it is within a polygon, and if so, text the phone number associated with the polygon. </p>
<p>To install other languages for triggers, open <strong>Stack Builder</strong> and add the add-on shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6623adda-2f3b-49fc-8396-4342f7a6fba5.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you learned how to <span>use spatial queries to perform geoprocessing tasks. You also learned how to map and chart the results of your queries using <kbd>ipyleaflet</kbd> and d</span>ata frames<span>. You learned how to modify the maps and queries using interactive widgets in Jupyter. Lastly, you learned about how triggers work, and were shown a quick example of data checking using trigger. </span></p>
<p>In the next chapter, you will learn how to perform geoprocessing tasks using QGIS. You will learn how to use toolboxes that are already included in QGIS. You will learn how to write your own toolboxes that you can use and share with other QGIS users, and you will learn how to use QGIS to map the results. The results can be saved as a QGIS project, or as one of many spatial data formats from QGIS.</p>
<p> </p>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>