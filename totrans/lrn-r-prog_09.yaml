- en: Chapter 9.  Metaprogramming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned about the structure and features of an
    environment and also learned how to create and access an environment. Environment
    plays an important role in lazy evaluation, copy-on-modify, and lexical scoping,
    which are enabled by the environments associated with a function when it is created
    and called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a solid understanding of how functions work, we will go further
    in this chapter by learning to work with functions in more advanced forms. You
    will learn the metaprogramming facilities that make R flexible in interactive
    analysis. More specifically, we will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Functional programming: closures and higher-order functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computing on language with language objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding non-standard evaluation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding functional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, you learned the behavior of a function in detail,
    including when an argument is evaluated (lazy evaluation), what happens when we
    try to modify an argument (copy-on-modify), and where to look for variables not
    defined within the function (lexical scoping). These technical terms that describe
    the behaviors may look more difficult than they actually are. In the following
    sections, you will learn about two types of functions: functions that are defined
    in functions and functions that work with other functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating and using closures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A function defined in a function is called a **closure_**. It is special because
    in the function body of the closure, not only the local arguments but also the
    variables created in the parent function are also available.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose we have the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This function has two arguments. Each time we call `add()`, we should supply
    two arguments. If we use closure, we can generate special versions of this function
    with a pre-specified argument. In the following section, we will create a simple
    closure to accomplish this.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple closure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here, we will create a function called `addn`, which has one argument `y`.
    This function does not do the actual plus calculation but creates a child function
    that adds `y` to whatever number `x` supplied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It may take extra efforts to realize that `addn` does not return a number like
    a typical function, but returns a closure: that is, a function defined in a function.
    The closure calculates `x + y`, where `x` refers to a local argument and `y` refers
    to an argument in its enclosing environment. In other words, `addn()` is no longer
    a calculator, but a calculator factory that manufactures calculators.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The factory function enables us to create specialized versions of calculators.
    For example, we can create two functions that add `1` and `2` to a numeric vector,
    respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The two functions work as if the second argument of `add(x, y)` was fixed.
    The following code validates the calculators made by `addn()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Take `add1` as an example. The `add1 <- addn(1)` code evaluates `addn(1)`,
    which results in a function assigned to `add1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When we print `add1`, it is a bit different because the environment of `add1`
    is also attached. The environment of a function will be printed if it is not the
    current environment-in this case, the global environment. In the environment of
    `add1`, `y` is specified in `addn(1)`, which can be verified by running the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can call `environment()` with `add1` to access its enclosing environment,
    which captures `y`. That''s exactly how closure works. We can do the same thing
    to `add2` and see the value of `y` we specified with `addn(2)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Making specialized functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Closures are useful to make specialized functions. For example, due to the flexibility
    of the production of graphics, plot functions often provide a large number of
    arguments. If we frequently use only a particular subset of all arguments, we
    can make specialized versions that make the code easier to write and read.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `color_line` function is a version of `plot` specialized in color
    picking, but with plot type and line type being fixed. It is comparable to a factory
    that makes pens of all colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want a red pen, we call `color_line` and get a specialized function that
    draws red lines. The resulted function is also open to other arguments such as
    title and font:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This function produces the following line plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making specialized functions](img/image_09_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding code looks more readable than the original version that does
    not employ such a specialized function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Fitting normal distribution with maximal likelihood estimation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Closures are useful when we work with an algorithm with some given data. Optimization,
    for example, is a problem to find a set of parameters that maximizes or minimizes
    a pre-defined objective function subject to certain constraints and data. In statistics,
    many parameter estimation problems are, in essence, optimization problems. One
    good example that demonstrates the use of closures is **MLE** (**maximum likelihood
    estimation**). When we estimate the parameters of a statistical model with data,
    we often use the method of maximal likelihood estimation (MLE, see [https://en.wikipedia.org/wiki/Maximum_likelihood](https://en.wikipedia.org/wiki/Maximum_likelihood)).
    The idea behind MLE is simple: the estimated values of parameters should make
    the observed data the most probable, given the model.'
  prefs: []
  type: TYPE_NORMAL
- en: To perform MLE, we need a function that measures how probable it is to observe
    a given set of data under a specific model. Then, we apply optimization techniques
    to find out the values of parameters that maximizes the probability.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we know that a set of observed data is generated by normal distribution,
    but the problem is, we don''t know the parameters: mean and standard deviation.
    Then, we can use MLE to estimate them, given the observed data.'
  prefs: []
  type: TYPE_NORMAL
- en: "First, we know that the probability density function of a normal distribution\
    \ with mean *Âµ[0]* and standard deviation *Ï\x83[0]* is:"
  prefs: []
  type: TYPE_NORMAL
- en: '![Fitting normal distribution with maximal likelihood estimation](img/image_09_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Therefore, the likelihood function given the observed data *x* is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fitting normal distribution with maximal likelihood estimation](img/image_09_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To make the optimization easier, we will take a natural log and negate on both
    sides and get the negative log-likelihood function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fitting normal distribution with maximal likelihood estimation](img/image_09_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The negative log-likelihood function has the same monotonicity as the original
    function. The optimization solution of this function is the same as the original
    function but can be much easier to solve. That's why we use this function in the
    estimation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `nloglik` R function returns a closure of the two parameters
    of normal distribution given the observed data `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this way, for any given set of observations, we call `nloglike` to get a
    negative log-likelihood function with respect to mean and standard deviation.
    It tells us how unlikely it is for us to observe the given data `x` assuming that
    the true model takes the values of `mean` and `sd` we specify.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we use `rnorm()` to generate 10,000 random numbers that are normally
    distributed with mean `1` and standard deviation `2`. Therefore, `mean = 1` and
    `sd = 2` are the true values of the distribution parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we turn to the `mle()` function in the `stats4` package. This function
    implements a number of numeric methods to find the minimum value of a given negative
    log-likelihood function with certain parameters. It takes a starting point of
    the numeric search, and a lower bound and a upper bound of the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After some iterations, it finds an MLE solution and returns an S4 object, which
    includes the related data of the solution. To see how close the estimates are
    to the true value, we will extract the `coef` slot from the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'It is obvious that the estimates are very close to the true values. Relatively
    speaking, both estimates have an error lower than 1 percent, as can be verified
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function is a composition of the histogram of `data` and the
    density functions of the normal distribution with both true parameters (red curve)
    and estimated parameters (blue curve):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following histogram, plus a fitted normal density curve:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fitting normal distribution with maximal likelihood estimation](img/image_09_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can see that the density function produced by the estimated parameters is
    very close to the true model.
  prefs: []
  type: TYPE_NORMAL
- en: Using higher-order functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we discussed closures, functions defined in parent
    functions. In this section, we will discuss higher-order functions, that is, functions
    that accept another function as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Before walking into this topic, we need more knowledge of how functions behave
    when they are passed around either as variables or as function arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Creating aliases for functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first question is: if we assign an existing function to another variable,
    will it affect the enclosing environment of the function? If this is so, then
    the search paths of symbols that are not locally defined will be different.'
  prefs: []
  type: TYPE_NORMAL
- en: The following code demonstrates why the enclosing environment of a function
    is not changed when it is assigned to another symbol. We define a simple function
    `f1` that prints the executing environment, the enclosing environment, and the
    calling environment when it is called. Then, we define `f2` that also prints the
    three environments, but in addition, it assigns the function of `f1` to a local
    variable `p` and call `p` inside `f2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `p <- f1` defines the function locally, the enclosing environment of `p`
    will be the executing environment of `f2`. Otherwise, the enclosing environment
    will remain the global environment in which `f1` is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We called the two functions in turn and found that `p` is called from the executing
    environment of `f2`, but the enclosing environment is unchanged. In other words,
    the search path of `p` and `f1` are exactly the same. In fact, `p <- f1` assigns
    exactly the same function `f1` represents to `p`, and then, they both point to
    the same function.
  prefs: []
  type: TYPE_NORMAL
- en: Using functions as variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functions in R are not as special as they are in other programming languages.
    Everything is an object. Functions are objects too and can be referred to by variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have a function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding function, two conditional branches lead to different expressions
    that may result in different values. To achieve the same goal, we can also let
    the conditional branches result in different functions, store the result in a
    variable, and, finally, call the function the variable represents to get the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note that in R, everything we do is done by a function. The most basic operators
    `+` and `-` are functions too. They can be assigned to the variable `op`, and
    we can call `op` if it is indeed a function.
  prefs: []
  type: TYPE_NORMAL
- en: Passing functions as arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous examples demonstrate that we can easily pass functions around just
    like everything else, including passing functions in arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we will define two functions called `add` and `product`,
    respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will define another function, `combine`, that tries to combine `x`,
    `y`, and `z` in some way specified by the argument `f`. Here,`f` is assumed to
    be a function that takes three arguments as we call it. In this way, `combine`
    is more flexible. It is not limited to a particular way of combining the inputs,
    but allows the user to specify:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can pass `add` and `product`, we just defined in turn, to see if it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: It is natural that when we call `combine(add, 3, 4, 5)`, the function body has
    `f = add` and `f(x, y, z)`, which result in `add(x, y, z)`. The same logic also
    applies to calling `combine` with `product`. Since `combine` accepts a function
    in its first argument, it is indeed a higher-order function.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason we need higher-order functions is that the code is easier to
    read and write at a higher level of abstraction. In many cases, using higher-order
    functions make the code shorter yet more expressive. For example, for-loop is
    an ordinary flow-control device that iterates along a vector or list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we need to apply a function named `f` to each element of vector `x`.
    If the function itself is vectorized, it is better to call `f(x)` directly. However,
    not every function supports vectorized operations, nor does every function need
    to be vectorized. If we want to do so, a for-loop,like the following one, solves
    the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the previous loop, `seq_along(x)` produces a sequence from `1` to the length
    of `x`, which is equivalent to `1:length(x)`. The code looks simple and easy to
    implement, but if we use it all the time, the drawback becomes significant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose the operation in each iteration gets more complicated: it would be
    hard to read. If you think about it, you will find that the code tells R *how*
    to finish the task instead of *what* the task is about. When you take a look at
    very long, sometimes nested loops, you would have a hard time to figure out what
    it is actually doing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we can apply a function (`f`) to each element of a vector or list
    (`x`) by calling `lapply`, which we introduced in the previous chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, `lapply` is essentially the same as the following code, although it
    is implemented in C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This function is a higher-order function, because it works at a higher level
    of abstraction. Although it still uses a for-loop inside, it separates the work
    into two levels of abstraction so that each level looks simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, `lapply` also supports extending `f` with additional arguments. For
    example, `+` has two arguments, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding lines of code are equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding line of code is also equivalent to the case where we use a closure
    to produce the `x+3` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As we mentioned in the previous chapters, `lapply` only returns a list. If
    we want a vector instead, we should use `sapply` in the interactive mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we should use `vapply` in the programming code with type checking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In addition to these functions, R also offers several other apply-family functions,
    as we mentioned in the previous chapters, as well as `Filter`, `Map`, `Reduce`,
    `Find`, `Position`, and `Negate`. For more details, refer to `?Filter` in the
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the use of higher-order functions not only makes the code easier to
    read and more expressive, but these functions also separate the implementation
    of each level of abstraction so that they are independent from each other. It
    is much easier to improve simpler components than a whole bundle of logic coupled
    together.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we can use apply-family functions to perform vector mapping, given
    a function. If each iteration is independent from the others, we can parallelize
    the mapping using multiple CPU cores so that more tasks can be done simultaneously.
    However, if we didn't use higher-order functions at the first place but a for-loop
    instead, it would take a while to convert it to parallel code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s assume we use a for-loop to get the results. In each iteration,
    we perform a heavy computing task. Even if we find each iteration independently
    from the others, it is not always straightforward to convert it to parallel code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we use the higher-order function `lapply()`, things will be much
    easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'It would just take one small change to transform the code into a parallel version.
    Using `parallel::mclapply()`, we can apply `f` to each element of `x` with multiple
    cores:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, `mclapply()` does not support Windows. More code is needed to
    perform parallel apply functions in Windows. We will cover this topic in the chapter
    on high-performance computing.
  prefs: []
  type: TYPE_NORMAL
- en: Computing on language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we introduced the functional programming facilities
    in R. You learned that functions are just another type of object we can pass around.
    When we create a new function, say `fun`, the environment we create will be associated
    with the function. This environment is called the enclosing environment of the
    function, which can be accessed via `environment(fun)`. Each time we call the
    function, a new executing environment that contains the unevaluated arguments
    (promises) will be created to host the execution of the function, which enables
    lazy evaluation. The parent of the executing environment is the enclosing environment
    of the function, which enables lexical scoping.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming allows us to write code in higher level of abstraction.
    Metaprogramming goes even further. It allows us to tweak the language itself and
    make certain language constructs easier to use in a certain scenario. Some popular
    R packages use metaprogramming in their functions to make things easier. In this
    section, I will show you the power of metaprogramming as well as its pros and
    cons, so that you can understand how related packages and functions work.
  prefs: []
  type: TYPE_NORMAL
- en: Before digging into the knowledge of how things work, we may look at a few built-in
    functions that use metaprogramming to make things easier.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we want to filter the built-in dataset `iris` for records with each
    numeric column being greater than 80 percent of all records.
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard method is to subset the rows of the data frame by composing a
    logical vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, each call of `quantile()` yields an 80 percent threshold
    for a column. Although the code works, it is quite redundant, because each time
    we use a column, we have to begin with `iris$`. In total, `iris$` appears nine
    times.
  prefs: []
  type: TYPE_NORMAL
- en: 'The built-in function `subset` is useful to make things easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code returns exactly the same results, but with cleaner code.
    But why does it work while omitting `iris$` in the previous example does not work?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code does not work, because `Sepal.Length` and other columns are
    not defined in the scope (or environment) where we evaluate the subsetting expression.
    The magic function, `subset`, uses metaprogramming techniques to tweak the evaluation
    environment of its arguments so that `Sepal.Length>quantile(Sepal.Length, 0.8)`
    is evaluated in the environment with the columns of `iris`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, `subset` not only works with rows, but is also useful in selecting
    columns. For example, we can also specify the `select` argument by directly using
    the column names as variables instead of using a character vector to select columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: See, `subset` tweaks how its second argument (`subset`) and third argument (`select`)
    are evaluated. The result is we can write simpler code with less redundancy.
  prefs: []
  type: TYPE_NORMAL
- en: In the next few sections, you will learn what happens behind the scene and how
    it is designed to work.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing and modifying expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we type an expression and hit the *Enter* (or return) key, R will evaluate
    the expression and show the output. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'It shows the five random numbers generated. The magic of `subset` is that it
    tweaks the environment where the argument is evaluated. This happens in two steps:
    first, capture the expression and then, interfere the evaluation of the expression.'
  prefs: []
  type: TYPE_NORMAL
- en: Capturing expressions as language objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Capturing an expression means preventing the expression from being evaluated,
    but storing the expression itself as a variable. The function that does this is
    `quote()`; we can call `quote()` to capture the expression between the parenthesis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code does not result in five random numbers, but the function
    call itself. We can use `typeof()` and `class()` to see the type and class of
    the resulted object, `call1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that `call1` is essentially a language object and it is a call.
    We can also write a function name in `quote()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we don't get a call but a symbol (or name) instead.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, `quote()` will return a call if a function call is captured and return
    a symbol if a variable name is captured. The only requirement is the validity
    of the code to capture; that is, as long as the code is syntactically correct,
    `quote()` will return the language object that represents the captured expression
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even if the function does not exist or the variable as yet is undefined, the
    expression can be captured on its own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Of the preceding language objects, maybe `pvar`, `xfun`, and `n` are all as
    yet undefined, but we can `quote()` them anyway.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand the difference between a variable and a symbol
    object, and between a function and a call object. A variable is a name of an object,
    and a symbol object is the name itself. A function is an object that is callable,
    and a call object is a language object that represents such a function call, which
    is as yet unevaluated. In this case, `rnorm` is a function and it is callable
    (for example, `rnorm(5)` returns five random numbers), but `quote(rnorm)` returns
    a symbol object and `quote(rnorm(5))` returns a call object, both of which are
    only the representations of the language itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can convert the call object to a list so that we can see its internal structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows that the call consists of two components: the symbol of the function
    and one argument. We can extract objects from a call object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The first element of `call1` is a symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The second element of `call1` is a numeric value. From the previous examples,
    we know that `quote()` captures a variable name as a symbol object and a function
    call as a call object. Both of them are language objects. Like typical data structures,
    we can use `is.symbol()`/`is.name()` and `is.call()` to detect whether an object
    is a symbol or a call, respectively. More generally, we can also use `is.language()`
    to detect both the symbol and the call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another question is, "What if we call `quote()` on a literal value? What about
    a number or a string?" The following code creates a numeric value `num1` and a
    quoted numeric value `num2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'They have exactly the same representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, they have exactly the same value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, `quote()` does not transform a literal value (such as a number,
    logical value, string, and so on) to a language object, but it leaves it as it
    is. However, an expression that combines several literal values into a vector
    will still be transformed into a call object. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'It is consistent because `c()` is indeed a function that combines values and
    vectors. Moreover, if you look at the list representation of the call using `as.list()`,
    we can see the structure of the call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The types of elements in the call can be revealed by `str()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Another noteworthy fact here is that simple arithmetic calculations are captured
    as calls too because they are surely function calls to arithmetic operators such
    as `+` and `*`, which are essentially built-in functions. For example, we can
    use the `quote()` function to the simplest arithmetic calculation, perform `1
    + 1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The arithmetic representation is preserved, but it is a call and has exactly
    the same structure as of a call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Given all the preceding knowledge about capturing an expression, we can now
    capture a nested call; that is, a call that contains more calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use a function in the `pryr` package to view the recursive structure
    of the call. To install the package, run `install.package("pryr")`. Once the package
    is ready, we can call `pryr::call_tree` to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: For `call4`, the recursive structure is printed in a tree structure. The `\-
    ()` operator means a call, then `` `var `` represents a symbol object `var`, and
    others are literal values. In the preceding output, we can see that symbols and
    calls are captured and literal values are preserved.
  prefs: []
  type: TYPE_NORMAL
- en: If you are curious about the call tree of an expression, you can always use
    this function because it precisely reflects the way R processes the expression.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we capture an expression as a call object, the call can be modified as
    if it were a list. For example, we can change the function to call by replacing
    the first element of the call with another symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: So, `rnorm(5)` is changed to `runif(5)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also add new argument to the call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Then, the call now has another parameter: `min = -1`.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing expressions of function arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous examples, you learned how to use `quote()` to capture a known
    expression, but `subset` works with arbitrary user-input expressions. Suppose
    we want to capture the expression of argument `x`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first implementation uses `quote()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see if `fun1` can capture the input expression when we call the function
    with `rnorm(5)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, `quote(x)` only captures `x` and has nothing to do with the input
    expression `rnorm(5)`. To correctly capture it, we need to use `substitute()`.
    The function captures an expression and substitutes existing symbols with their
    expressions. The simplest usage of this function is to capture the expression
    of a function argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: With this implementation, `fun2` returns the input expression rather than `x`
    because `x` is replaced with the input expression, in this case, `rnorm(5)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following examples demonstrate the behavior of `substitute` when we supply
    a list of language objects or literal values. In the first example, we substitute
    each symbol `x` in the given expression with `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In the second example, we substitute each symbol `f` that is supposed to be
    a function name with another quoted function name `sin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are able to capture a certain expression with `quote()` and user-input
    expression with `substitute()`.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing function calls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In addition to capturing expressions, we can directly build language objects
    with built-in functions. For example, `call1` is a captured call using `quote()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use `call()` to create a call of the same function with the same arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can convert a list of call components to a call using `as.call()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The three methods create identical calls; that is, they call a function of
    the same name and with the same arguments, which can be confirmed by calling `identical()`
    with the three resulted call objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Evaluating expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After capturing an expression, the next step is evaluating it. This can be done
    with `eval()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we type `sin(1)` and enter, the value will appear immediately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'To control the evaluation of `sin(1)`, We can use `quote()` to capture the
    expression and then `eval()` to evaluate the function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We can capture any expression that is syntactically correct, which allows us
    to `quote()` an expression that uses undefined variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'In `call2`, `sin(x)` uses an undefined variable `x`. If we directly evaluate
    it, an error occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'This error is similar to what happens when we directly run `sin(x)` without
    `x` being defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The difference between directly running in console and using `eval()` is that
    `eval()` allows us to provide a list to evaluate the given expression. In this
    case, we don''t have to create a variable `x` but supply a temporary list that
    contains `x` so that the expression will look up symbols in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, `eval()` also accepts an environment for symbol lookup. Here,
    we will create a new environment `e1` in which we create a variable `x` with value
    `1`, and then we use `eval()` in the call in `e1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The same logic also applies when the captured expression has more undefined
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Directly evaluating the expression without a complete specification of the
    undefined symbols will result in an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'So does a partial specification, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Only when we fully specify the values of the symbols in the expression can
    the evaluation result in a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The evaluation model of `eval(expr, envir, enclos)` is the same as calling a
    function. The function body is `expr`, and the executing environment is `envir`.
    If `envir` is given as a list, then the enclosing environment is `enclos`, or
    otherwise the enclosing environment is the parent environment of `envir`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This model implies the exact behavior of symbol lookup. Suppose we use an environment
    instead to evaluate `call3`. Since `e1` only contains variable `x`, the evaluation
    does not proceed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create a new environment whose parent is `e1` and contains variable
    `y`. If we now evaluate `call3` in `e2`, both `x` and `y` are found and the evaluation
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, `eval(call3, e2)` tries to evaluate `call3`, with `e2`
    being the executing environment. Now, we can go through the evaluating process
    to get a better understanding of how it works. The evaluation process is reflected
    by travelling recursively along the call tree produced by `pryr::call_tree()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: First, it tries to find a function called `+`. It goes through `e2` and `e1`,
    and does not find `+` until it reaches the base environment (`baseenv()`), where
    all the basic arithmetic operators are defined. Then, `+` needs to evaluate its
    arguments, so it looks for another function called `^` and finds it by going through
    the same flow. Then, again `^` needs to evaluate its arguments, so it looks for
    symbol `x` in `e2`. Environment `e2` does not contain variable `x`, so it continues
    searching in `e2` class's parent environment, `e1`, and finds `x` there. Finally,
    it looks for symbol `y` in `e2` and finds it immediately. When the arguments a
    call needs are ready, the call can be evaluated to a result.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative approach is to supply a list to `envir` and an enclosing environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The evaluating process begins with an executing environment generated from the
    list whose parent environment is `e3`, as specified. Then, the process is exactly
    the same as the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: Since everything we do is essentially calling functions, `quote()` and `substitute()`
    can capture everything, including assignment and other operations that do not
    look like calling functions. In fact, for example, `x <- 1` is essentially calling
    `<-` with `(x, 1)`, and `length(x) <- 10` is essentially calling `length<-` with
    `(x, 10)`.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate the point, we may construct another example in which we create
    a new variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we supply a list to generate the executing environment
    and `e3` as the enclosing environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, `z` is not created in `e3` but in a temporary executing environment
    created from the list. If we, instead, specify `e3` as the executing environment,
    the variable will be created in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'In conclusion, `eval()` works in a way extremely close to the behavior of function
    calling, but `eval()` allows us to customize the evaluation of an expression by
    tweaking its executing and enclosing environment, which allows us to do good things
    such as `subset` as well as bad things such as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Understanding non-standard evaluation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous sections, you learned how to use `quote()` and `substitute()`
    to capture an expression as a language object, and you learned how to use `eval()`
    to evaluate it within a given list or environment. These functions constitute
    the facility of metaprogramming in R and allow us to tweak standard evaluation.
    The main application of metaprogramming is to perform non-standard evaluation
    to make certain usage easier. In the following sections, we will discuss a few
    examples to gain a better understanding of how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing quick subsetting using non-standard evaluation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Often, we need to take out a certain subset from a vector. The range of the
    subset may be the first few elements, last few elements, or some elements in the
    middle.
  prefs: []
  type: TYPE_NORMAL
- en: The first two cases can be easily handled by `head(x, n)` and `tail(x, n)`.
    The third case requires an input of the length of the vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose we have an integer vector and want to take out elements
    from the third to the fifth last:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding subsetting expression uses `x` twice and looks a bit redundant.
    We can define a quick subsetting function that uses metaprogramming facilities
    to provide a special symbol to refer to the length of the input vector The following
    function, `qs`, is a simple implementation of this idea that allows us to use
    dot (`.`) to represent the length of the input vector `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this function, we can use `3:(. - 5)` to represent the same range as
    the motivating example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also easily pick out a number by counting from the last element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on `qs()`, the following function is designed to trim both margins of
    `n` elements from the input vector `x`; that is, it returns a vector without the
    first `n` and last `n` elements of `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The function looks alright, but when we call it with an ordinary input, an
    error occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: How come it couldn't find `n`? To understand why this happens, we need to analyze
    the path of symbol lookup when `trim_margin` is called. In the next section, we
    will go into this in detail and introduce the concept of dynamic scoping to resolve
    the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding dynamic scoping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before trying to tackle the problem, let's use what you have learned to analyze
    what went wrong. When we call `trim_margin(x, 3)`, we call `qs(x, (n + 1):(. -
    n - 1))` in a fresh executing environment with `x`, and `n`. `qs()` is special
    because it uses non-standard evaluation. More specifically, it first captures
    `range` as a language object and then evaluates it with a list of additional symbols
    to provide, which, at the moment, only contains `. = length(x)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The error just happens at `eval(range, list(. = length(x)))`. The number of
    margin elements to trim, `n`, cannot be found here. There must be something wrong
    with the enclosing environment of evaluation. Now, we will take a closer look
    at the default value of the `enclos` argument of `eval()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The definition of `eval()` says that if we supply a list to `envir`, which is
    exactly what we have done, `enclos` will take `parent.frame()` by default, which
    is the calling environment of `eval()`; that is, the executing environment when
    we call `qs()`. Certainly, there is no `n` in any executing environment of `qs`.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we exposed a shortcoming of using `substitute()` in `trim_margin()` because
    the expression is only fully meaningful in the correct context, that is, the executing
    environment of `trim_margin()`, which is also the calling environment of `qs()`.
    Unfortunately, `substitute()` only captures the expression; it does not capture
    the environment in which the expression is meaningful. Therefore, we have to do
    it ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we know where the problem comes from. The solution is simple: always use
    the correct enclosing environment in which the captured expression is defined.
    In this case, we specify `enclos = parent.frame()` so that `eval()` looks for
    all symbols other than `.` in the calling environment of `qs()`, that is, the
    executing environment of `trim_margin()` where `n` is supplied.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines of code are the fixed version of `qs()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test the function with the same code that went wrong previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Now, the function works in the correct manner. In fact, this mechanism is the
    so-called **dynamic scoping**. Recall what you learned in the previous chapter.
    Each time a function is called, an executing environment is created. If a symbol
    cannot be found in the executing environment, it will search the enclosing environment.
  prefs: []
  type: TYPE_NORMAL
- en: With lexical scoping used in standard evaluation, the enclosing environment
    of a function is determined when the function is defined and so is the environment
    where it is defined.
  prefs: []
  type: TYPE_NORMAL
- en: However, with dynamic scoping used in non-standard evaluation, by contrast,
    the enclosing environment should be the calling environment in which the captured
    expression is defined so that symbols can be found either in the customized executing
    environment or in the enclosing environment, along with its parents.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, when a function uses non-standard evaluation, it is important
    to ensure that dynamic scoping is correctly implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Using formulas to capture expression and environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To correctly implement dynamic scoping, we use `parent.frame()` to track the
    expression captured by `substitute()`. An easier way is to use a formula to capture
    the expression and environment at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: In the chapter of working the data, we saw that a formula is often used to represent
    the relationship between variables. Most model functions (such as `lm()`) accept
    a formula to specify the relationship between a response variable and explanatory
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, a formula object is much simpler than that. It automatically captures
    the expressions beside `~` and the environment where it is created. For example,
    we can directly create a formula and store it in a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the formula is essentially a language object with the `formula`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'If we convert the formula to a list, we can have a closer look at its structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that `formula1` captured not only the expressions as language objects
    on both sides of `~`, but also the environment where it was created. In fact,
    a formula is merely a call of function `~` with the arguments and calling environment
    captured. If both sides of `~` are specified, the length of the call is `3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'To access the language objects it captured, we can extract the second and the
    third elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'To access the environment where it was created, we can call `environment()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'A formula can also be right-sided, that is, only the right side of `~` is specified.
    Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, only one argument of `~` is supplied and captured so that we
    have a call of two language objects and we can access the expression it captured
    by extracting its second element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: With the knowledge of how the formula works, we can implement another version
    of `qs()` and `trim_margin()` using the formula.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following function, `qs2`, behaves consistently with `qs` when `range`
    is a formula, or otherwise, it directly uses `range` to subset `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we use `inherits(range, "formula")` to check whether `range` is a
    formula and use `environment(range)` to implement dynamic scoping. Then, we can
    use a right-sided formula to activate non-standard evaluation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, we can use standard evaluation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can re-implement `trim_margin` with `qs2` using a formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'As can be verified, dynamic scoping works correctly because the formula used
    in `trim_margin2` automatically captures the executing environment, which is also
    the environment where the formula and `n` are defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Implementing subset with metaprogramming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the knowledge of language objects, evaluation functions, and dynamic scoping,
    now we have the capability to implement a version of `subset`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The underlying idea of the implementation is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: Capture the row subsetting expression and evaluate it within the data frame
    which is, in essence, a list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capture the column-selecting expression and evaluate it in a named list of integer
    indices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the resulting row selector (logical vector) and column selector (integer
    vector) to subset the data frame
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an implementation of the preceding logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: The feature of row subsetting is easier to implement than the column selecting
    part. To perform row subsetting, we only need to capture `subset` and evaluate
    it within the data frame.
  prefs: []
  type: TYPE_NORMAL
- en: The column subsetting is trickier here. We will create a list of integer indices
    for the columns and give them the corresponding names. For example, a data frame
    with three columns (say, `x`, `y`, and `z`) needs a list of indices such as `list(a
    = 1, b = 2, c = 3)`, which allows us to select rows in the form of `select = c(x,
    y)` because `c(x, y)` is evaluated within the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the behavior of `subset2` is very close to the built-in function `subset`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Both implementations allow us to use `a:b` to select all columns between `a`
    and `b`, including both sides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the idea and usage of functional programming,
    including closures and higher order functions. We went further by digging into
    the metaprogramming facilities, including language objects, evaluation functions,
    formula, and the implementation of dynamic scoping to ensure user-input expressions
    are correctly handled when we customize the evaluation behavior. Since a number
    of popular packages use metaprogramming and non-standard evaluation to make interactive
    analysis easier, it is important to understand how it works so that we can be
    more confident to predict and debug the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will walk into another infrastructure of R: the object-oriented
    programming systems. You will learn the basic idea of object-oriented programming,
    how this idea is implemented in R, and how it can be useful. More specifically,
    we will begin with the looser S3 system, cover the stricter system S4 which offers a
    richer set of features, and introduce the reference class and newly implemented
    R5 system.'
  prefs: []
  type: TYPE_NORMAL
