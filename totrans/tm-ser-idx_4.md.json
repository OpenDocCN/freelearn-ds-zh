["```py\n$ tree isax/\nisax/\n├── SAXalphabet\n├── __init__.py\n├── isax.py\n├── sax.py\n├── tools.py\n└── variables.py\n1 directory, 6 files\n```", "```py\n$ grep -w def isax/isax.py | grep -v __init__\n    def insert(self, ts, ISAX):\n    def nTimeSeries(self):\n    def insert(self, ts_node):\n```", "```py\n$ grep -w def -n1 isax/isax.py\n5-class TS:\n6:    def __init__(self, ts, segments):\n7-        self.index = 0\n--\n11-class Node:\n12:    def __init__(self, sax_word):\n13-        self.left = None\n--\n19-    # Follow algorithm from iSAX paper\n20:    def insert(self, ts, ISAX):\n21-        # Accessing a subsequence\n--\n127-\n128:    def nTimeSeries(self):\n129-        if self.terminalNode == False:\n--\n141-class iSAX:\n142:    def __init__(self):\n143-        # This is now a hash table\n--\n148-\n149:    def insert(self, ts_node):\n150-        # Array with number of segments\n```", "```py\nclass TS:\n    def __init__(self, ts, segments):\n        self.index = 0\n        self.ts = ts\n        self.maxCard = sax.createPAA(ts,\n            variables.maximumCardinality, segments)\n```", "```py\nclass Node:\n    def __init__(self, sax_word):\n        self.left = None\n        self.right = None\n        self.terminalNode = False\n        self.word = sax_word\n        self.children = [TS] * variables.threshold\n```", "```py\nclass iSAX:\n    def __init__(self):\n        # This is now a hash table\n        self.children = {}\n        # HashTable for storing Nodes\n        self.ht = {}\n        self.length = 0\n```", "```py\n    # Follow algorithm from iSAX paper\n    def insert(self, ts, ISAX):\n        # Accessing a subsequence\n        variables.nSubsequences += 1\n        if self.terminalNode:\n            if self.nTimeSeries() == variables.threshold:\n                variables.nSplits += 1\n                # Going to duplicate self Node\n                temp = Node(self.word)\n                temp.children = self.children\n                temp.terminalNode = True\n                # The current Terminal node becomes\n                # an inner node\n                self.terminalNode = False\n                self.children = None\n```", "```py\n                # Create TWO new Terminal nodes\n                new1 = Node(temp.word)\n                new1.terminalNode = True\n                new2 = Node(temp.word)\n                new2.terminalNode = True\n                n1Segs = new1.word.split('_')\n                n2Segs = new2.word.split('_')\n```", "```py\n                # This is where the promotion\n                # strategy is selected\n                if variables.defaultPromotion:\n                    tools.round_robin_promotion(n1Segs)\n                else:\n                    tools.shorter_first_promotion(n1Segs)\n                # New SAX_WORD 1\n                n1Segs[variables.promote] =\n                    n1Segs[variables.promote] + \"0\"\n                # CONVERT it to string\n                new1.word = \"_\".join(n1Segs)\n                # New SAX_WORD 2\n                n2Segs[variables.promote] =\n                    n2Segs[variables.promote] + \"1\"\n                # CONVERT it to string\n                new2.word = \"_\".join(n2Segs)\n                # The inner node has the same\n                # SAX word as before but this is\n                # not true for the two\n                # NEW Terminal nodes, which should\n                # be added to the Hash Table\n                ISAX.ht[new1.word] = new1\n                ISAX.ht[new2.word] = new2\n                # Associate the 2 new Nodes with the\n                # Node that is being splitted\n                self.left = new1\n                self.right = new2\n```", "```py\n                # Check all TS in original node\n                # and put them\n                # in one of the two children\n                #\n                # This is where the actual\n                # SPLITTING takes place\n                #\n                for i in range(variables.threshold):\n                    # Accessing a subsequence\n                    variables.nSubsequences += 1\n                    # Decrease TS.maxCard to\n                    # current Cardinality\n                    tempCard =\n                        tools.promote(temp.children[i],\n                        n1Segs)\n                    if tempCard == new1.word:\n                        new1.insert(temp.children[i], ISAX)\n                    elif tempCard == new2.word:\n                        new2.insert(temp.children[i], ISAX)\n                    else:\n                        if variables.overflow == 0:\n                            print(\"OVERFLOW:\", tempCard)\n                        variables.overflow =\n                            variables.overflow + 1\n                # Now insert the INITIAL TS node!\n                # self is now an INNER node\n                self.insert(ts, ISAX)\n                if variables.defaultPromotion:\n                    # Next time, promote the next segment\n                    Variables.promote = (variables.promote\n                        + 1) % variables.segments\n```", "```py\n            else:\n                # TS is added if we have a Terminal node\n                self.children[self.nTimeSeries()] = ts\n```", "```py\n        else:\n            # Otherwise, we are dealing with an INNER node\n            # and we should add it to the\n            # INNER node by trying\n            # to find an existing terminal node\n            # or create a new one\n            # See whether it is going to be\n            # included in the left\n            # or the right child\n            left = self.left\n            right = self.right\n```", "```py\n            leftSegs = left.word.split('_')\n            # Promote\n            tempCard = tools.promote(ts, leftSegs)\n```", "```py\n            if tempCard == left.word:\n                left.insert(ts, ISAX)\n            elif tempCard == right.word:\n                right.insert(ts, ISAX)\n            else:\n                if variables.overflow == 0:\n                    print(\"OVERFLOW:\", tempCard, left.word,\n                        right.word)\n                variables.overflow = variables.overflow + 1\n        return\n```", "```py\n    def nTimeSeries(self):\n        if self.terminalNode == False:\n            print(\"Not a terminal node!\")\n            return\n        n = 0\n        for i in range(0, variables.threshold):\n            if type(self.children[n]) == TS:\n                n = n + 1\n        return n\n```", "```py\n    def insert(self, ts_node):\n        # Array with number of segments\n        # For cardinality 1\n        segs = [1] * variables.segments\n        # Get cardinality 1 from ts_node\n        # in order to find its main subtree\n        lower_cardinality = tools.lowerCardinality(segs,\n            ts_node)\n        lower_cardinality_str = \"\"\n        for i in lower_cardinality:\n            lower_cardinality_str = lower_cardinality_str +\n                \"_\" + i\n        # Remove _ at the beginning\n        lower_cardinality_str = lower_cardinality_str[\n            1:len(lower_cardinality_str)]\n```", "```py\n        # Check whether the SAX word with CARDINALITY 1\n        # exists in the Hash Table.\n        # If not, create it and update Hash Table\n        if self.ht.get(lower_cardinality_str) == None:\n            n = Node(lower_cardinality_str)\n            n.terminalNode = True\n            # Add it to the hash table\n            self.children[lower_cardinality_str] = n\n            self.ht[lower_cardinality_str] = n\n            n.insert(ts_node, self)\n```", "```py\n        else:\n            n = self.ht.get(lower_cardinality_str)\n            n.insert(ts_node, self)\n        return\n```", "```py\ndef round_robin_promotion(nSegs):\n    # Check if there is a promotion overflow\n    n = power_of_two(variables.maximumCardinality)\n    t = 0\n    while len(nSegs[variables.promote]) == n:\n        # Go to the next SAX word and promote it\n        Variables.promote = (variables.promote + 1) %\n            variables.segments\n        t += 1\n        if t == variables.segments:\n            if variables.overflow == 0:\n                print(\"Non recoverable Promotion overflow!\")\n            return\n```", "```py\ndef shorter_first_promotion(nSegs):\n    length = len(nSegs)\n    pos = 0\n    min = len(nSegs[pos])\n    for i in range(1,length):\n        if min > len(nSegs[i]):\n            min = len(nSegs[i])\n            pos = i\n    variables.promote = pos\n```", "```py\ndef promote(node, segments):\n    new_sax_word = \"\"\n    max_array = node.maxCard.split(\"_\")[\n        0:variables.segments]\n    # segments is an array\n    #\n    for i in range(variables.segments):\n        t = len(segments[i])\n        new_sax_word = new_sax_word + \"_\" +\n            max_array[i][0:t]\n    # Remove _ from the beginning of the new_sax_word\n    new_sax_word = new_sax_word[1:len(new_sax_word)]\n    return new_sax_word\n```", "```py\ndef lowerCardinality(segs, ts_node):\n    # Get Maximum Cardinality\n    max = ts_node.maxCard\n    lowerCardinality = [\"\"] * variables.segments\n    # Because max is a string, we need to split.\n    # The max string has an\n    # underscore character at the end.\n    max_array = max.split(\"_\")[0:variables.segments]\n    for i in range(variables.segments):\n        t = segs[i]\n        lowerCardinality[i] = max_array[i][0:t]\n    return lowerCardinality\n```", "```py\n#!/usr/bin/env python3\nfrom isax import variables\nfrom isax import isax\nimport numpy as np\nvariablesPromote = 0\nmaximumCardinality = 8\nsegments = 4\ndef promote(node, s):\n    global segments\n    new_sax_word = \"\"\n    max_array = node.maxCard.split(\"_\")[0:segments]\n    for i in range(segments):\n        t = len(s[i])\n        new_sax_word = new_sax_word + \"_\" +\n            max_array[i][0:t]\n    new_sax_word = new_sax_word[1:len(new_sax_word)]\n    return new_sax_word\n```", "```py\ndef main():\n    global variablesPromote\n    global maximumCardinality\n    global segments\n    variables.maximumCardinality = maximumCardinality\n    ts = np.array([1, 2, 3, 4])\n    t = isax.TS(ts, segments)\n    SAX_WORD = \"0_0_1_1_\"\n    Segs = SAX_WORD.split('_')\n    print(\"Max cardinality:\", t.maxCard)\n    SAX_WORD = \"00_0_1_1_\"\n    Segs = SAX_WORD.split('_')\n    print(\"P1:\", promote(t, Segs))\n    SAX_WORD = \"000_0_1_1_\"\n    Segs = SAX_WORD.split('_')\n    print(\"P2:\", promote(t, Segs))\n    SAX_WORD = \"000_01_1_1_\"\n    Segs = SAX_WORD.split('_')\n    print(\"P3:\", promote(t, Segs))\n    SAX_WORD = \"000_011_1_100_\"\n    Segs = SAX_WORD.split('_')\n    print(\"P4:\", promote(t, Segs))\nif __name__ == '__main__':\n    main()\n```", "```py\n$ ./usePromote.py\nMax cardinality: 000_010_101_111_\nP1: 00_0_1_1\nP2: 000_0_1_1\nP3: 000_01_1_1\nP4: 000_010_1_111\n```", "```py\n#!/usr/bin/env python3\nfrom isax import variables\nfrom isax import tools\nfrom isax import isax\nimport numpy as np\ndef main():\n    global maximumCardinality\n    global segments\n    # Used by isax.TS()\n    variables.maximumCardinality = 8\n    variables.segments = 4\n    ts = np.array([1, 2, 3, 4])\n    t = isax.TS(ts, variables.segments)\n    Segs = [1] * variables.segments\n    print(tools.lowerCardinality(Segs ,t))\n    Segs = [2] * variables.segments\n    print(tools.lowerCardinality(Segs ,t))\n    Segs = [3] * variables.segments\n    print(tools.lowerCardinality(Segs ,t))\nif __name__ == '__main__':\n    main()\n```", "```py\n$ ./useLCard.py\n['0', '0', '1', '1']\n['00', '01', '10', '11']\n['000', '010', '101', '111']\n```", "```py\n# This file includes all variables for the isax package\n#\nmaximumCardinality = 32\nbreakpointsFile = \"SAXalphabet\"\n# Breakpoints in breakpointsFile\nelements = \"\"\nslidingWindowSize = 16\nsegments = 0\n# Maximum number of time series in a terminal node\nthreshold = 100\n# Keeps number of splits\nnSplits = 0\n# Keep number of accesses of subsequences\nnSubsequences = 0\n# Currently supporting TWO promotion strategies\ndefaultPromotion = True\n# Number of overflows\noverflow = 0\n# Floating point precision\nprecision = 5\n# Segment to promote\npromote = 0\n```", "```py\n2c2\n< # This file includes all variables for the sax package\n---\n> # This file includes all variables for the isax package\n13a14,16\n> # Breakpoints in breakpointsFile\n> elements = \"\"\n>\n20,21c23,24\n< # Breakpoints in breakpointsFile\n< elements = \"\"\n---\n> # Maximum number of time series in a terminal node\n> threshold = 100\n22a26,37\n> # Keeps number of splits\n> nSplits = 0\n>\n> # Keeps number of accesses of subsequences\n> nSubsequences = 0\n>\n> # Currently supporting TWO promotion strategies\n> defaultPromotion = True\n>\n> # Number of overflows\n> overflow = 0\n>\n24a40,42\n>\n> # Segment to promote\n> promote = 0\n```", "```py\nfrom sax import sax\nfrom sax import variables\n```", "```py\nfrom isax import sax\nfrom isax import variables\n```", "```py\n#!/usr/bin/env python3\nimport argparse\nfrom isax import variables\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-s\", \"--segments\",\n        dest = \"segments\", default = \"4\",\n        help=\"Number of Segments\", type=int)\n    parser.add_argument(\"-c\", \"--cardinality\",\n        dest = \"cardinality\", default = \"32\",\n        help=\"Cardinality\", type=int)\n    parser.add_argument(\"-w\", \"--window\", dest = \"window\",\n        default = \"16\", help=\"Sliding Window Size\",\n        type=int)\n    parser.add_argument(\"TS1\")\n    args = parser.parse_args()\n    variables.segments = args.segments\n    variables.maximumCardinality = args.cardinality\n    variables.slidingWindowSize = args.window\n    windowSize = variables.slidingWindowSize\n    maxCardinality = variables.maximumCardinality\n    f1 = args.TS1\n    print(\"Time Series:\", f1, \"Window Size:\", windowSize)\n    print(\"Maximum Cardinality:\", maxCardinality,\n        \"Segments:\", variables.segments)\nif __name__ == '__main__':\n    main()\n```", "```py\n$ ./parameters.py -s 2 -c 32 -w 16 ts1.gz\nTime Series: ts1.gz Window Size: 16\nMaximum Cardinality: 32 Segments: 2\n```", "```py\n$ ./parameters.py -s 1 -c cardinality ts1.gz\nusage: parameters.py [-h] [-s SEGMENTS] [-c CARDINALITY] [-w WINDOW] TS1\nparameters.py: error: argument -c/--cardinality: invalid int value: 'cardinality'\n```", "```py\n$ ./parameters.py\nusage: parameters.py [-h] [-s SEGMENTS] [-c CARDINALITY] [-w WINDOW] TS1\nparameters.py: error: the following arguments are required: TS1\n```", "```py\n#!/usr/bin/env python3\nimport argparse\nimport numpy as np\nimport pandas as pd\nfrom isax import sax\nfrom isax import variables\nclass TS:\n    def __init__(self, ts, index):\n        self.ts = ts\n        self.sax = sax.createPAA(ts,\n            variables.maximumCardinality,\n            variables.segments)\n        self.index = index\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-w\", \"--window\", dest = \"window\",\n        default = \"16\", help=\"Sliding Window Size\",\n        type=int)\n    parser.add_argument(\"-s\", \"--segments\",\n        dest = \"segments\", default = \"4\",\n        help=\"Number of Segments\", type=int)\n    parser.add_argument(\"-c\", \"--cardinality\",\n        dest = \"cardinality\", default = \"32\",\n        help=\"Cardinality\", type=int)\n    parser.add_argument(\"TS\")\n    args = parser.parse_args()\n    windowSize = args.window\n    variables.segments = args.segments\n    variables.maximumCardinality = args.cardinality\n    file = args.TS\n```", "```py\n    ts = pd.read_csv(file, names=['values'],\n        compression='gzip', header = None)\n    ts_numpy = ts.to_numpy()\n    length = len(ts_numpy)\n```", "```py\n    # Split sequence into subsequences\n    n = 0\n    for i in range(length - windowSize + 1):\n        # Get the actual subsequence\n        ts = ts_numpy[i:i+windowSize]\n        # Create new TS node based on ts\n        ts_node = TS(sax.normalize(ts), i)\n        n = n + n\n```", "```py\n    print(\"Created\", n, \"TS() nodes\")\nif __name__ == '__main__':\n    main()\n```", "```py\n$ ./subsequences.py ts1.gz\nCreated 35 TS() nodes\n```", "```py\n#!/usr/bin/env python3\nfrom isax import variables\nfrom isax import isax\nfrom isax import tools\nfrom isax import sax\nimport sys\nimport pandas as pd\nimport numpy as np\nimport time\nimport argparse\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-s\", \"--segments\",\n        dest = \"segments\", default = \"16\",\n        help=\"Number of Segments\", type=int)\n    parser.add_argument(\"-c\", \"--cardinality\",\n        dest = \"cardinality\", default = \"16\",\n        help=\"Cardinality\", type=int)\n    parser.add_argument(\"-w\", \"--windows\", dest = \"window\",\n        default = \"16\", help=\"Sliding Window Size\",\n        type=int)\n    parser.add_argument(\"-t\", \"--threshold\",\n        dest = \"threshold\", default = \"1000\",\n        help=\"Threshold for split\", type=int)\n    parser.add_argument(\"-p\", \"--promotion\",\n        action='store_true',\n        help=\"Define Promotion Strategy\")\n    parser.add_argument(\"TSfile\")\n    args = parser.parse_args()\n```", "```py\n    variables.segments = args.segments\n    variables.maximumCardinality = args.cardinality\n    variables.slidingWindowSize = args.window\n    variables.threshold = args.threshold\n    variables.defaultPromotion = args.promotion\n    file = args.TSfile\n    maxCardinality = variables.maximumCardinality\n    segments = variables.segments\n    windowSize = variables.slidingWindowSize\n    if tools.power_of_two(maxCardinality) == -1:\n        print(\"Not a power of 2:\", maxCardinality)\n        sys.exit()\n    if variables.segments > variables.slidingWindowSize:\n        print(\"Segments:\", variables.segments,\n            \"Sliding window:\", variables.slidingWindowSize)\n        print(\"Sliding window size should be bigger than #\n            of segments.\")\n        sys.exit()\n    print(\"Max Cardinality:\", maxCardinality, \"Segments:\",\n        variables.segments,\n        \"Sliding Window:\", variables.slidingWindowSize,\n        \"Threshold:\", variables.threshold,\n        \"Default Promotion:\", variables.defaultPromotion)\n```", "```py\n    ts = pd.read_csv(file, names=['values'],\n        compression='gzip')\n    ts_numpy = ts.to_numpy()\n    length = len(ts_numpy)\n    #\n    # Initialize iSAX index\n    #\n    ISAX = isax.iSAX()\n```", "```py\n    # Split sequence into subsequences\n    for i in range(length - windowSize + 1):\n        # Get the subsequence\n        ts = ts_numpy[i:i+windowSize]\n        # Create new TS node based on ts\n        ts_node = isax.TS(ts, segments)\n        ISAX.insert(ts_node)\nif __name__ == '__main__':\n    main()\n```", "```py\n$ ./createiSAX.py ts1.gz\nMax Cardinality: 16 Segments: 16 Sliding Window: 16 Threshold: 1000 Default Promotion: False\n$ ./createiSAX.py\nusage: createiSAX.py [-h] [-s SEGMENTS] [-c CARDINALITY] [-w WINDOW] [-t THRESHOLD] [-p] TSfile\ncreateiSAX.py: error: the following arguments are required: TSfile\n```", "```py\n    # Visit all entries in Dictionary\n    # Count TS in Terminal Nodes\n    sum = 0\n    for k in ISAX.ht:\n        t = ISAX.ht[k]\n        if t.terminalNode:\n            sum += t.nTimeSeries()\n    print(length - windowSize + 1, sum)\n```", "```py\n$ ./countSub.py ts1.gz\nMax Cardinality: 16 Segments: 16 Sliding Window: 16 Threshold: 1000 Default Promotion: False\n35 35\n```", "```py\n    start_time = time.time()\n    print(\"--- %.5f seconds ---\" % (time.time() –\n        start_time))\n```", "```py\n$ ./howMuchTime.py -w 2 -s 2 ts1.gz\nMax Cardinality: 16 Segments: 2 Sliding Window: 2 Threshold: 1000 Default Promotion: False\n--- 0.00833 seconds ---\n```", "```py\n$ ./howMuchTime.py 500k.gz\nMax Cardinality: 16 Segments: 16 Sliding Window: 16 Threshold: 1000 Default Promotion: False\n--- 114.80277 seconds ---\n```", "```py\n$ ./ch01/synthetic_data.py 500000 -1 1 > 500k\n$ gzip 500k\n```", "```py\n$ ./howMuchTime.py 2M.gz\nMax Cardinality: 16 Segments: 16 Sliding Window: 16 Threshold: 1000 Default Promotion: False\n--- 450.37358 seconds ---\n```", "```py\n$ ./ch01/synthetic_data.py 2000000 -10 10 > 2M\n$ gzip 2M\n```", "```py\n$ ./accessSplit.py 500k.gz\nMax Cardinality: 16 Segments: 16 Sliding Window: 16 Threshold: 1000 Default Promotion: False\nNumber of splits: 0\nNumber of subsequence accesses: 499985\n```", "```py\n$ ./accessSplit.py -w 1024 -s 8 -c 32 500k.gz\nMax Cardinality: 32 Segments: 8 Sliding Window: 1024 Threshold: 1000 Default Promotion: False\nNumber of splits: 4733\nNumber of subsequence accesses: 16370018\n```", "```py\n$ ./accessSplit.py 2M.gz\nMax Cardinality: 16 Segments: 16 Sliding Window: 16 Threshold: 1000 Default Promotion: False\nNumber of splits: 0\nNumber of subsequence accesses: 1999985\n```", "```py\n$ ./accessSplit.py -s 8 -c 32 2M.gz\nMax Cardinality: 32 Segments: 8 Sliding Window: 16 Threshold: 1000 Default Promotion: False\nNumber of splits: 3039\nNumber of subsequence accesses: 13694075\n```", "```py\nprint(\"Number of overflows:\", variables.overflow)\n```", "```py\n$ ./overflow.py -w 1024 -s 8 500k.gz\nMax Cardinality: 16 Segments: 8 Sliding Window: 1024 Threshold: 1000 Default Promotion: False\nOVERFLOW: 1000_0111_0111_1000_1000_0111_0111_1000\nNumber of overflows: 303084\n```", "```py\n$ ./overflow.py -w 1024 -s 8 500k.gz -p\nMax Cardinality: 16 Segments: 8 Sliding Window: 1024 Threshold: 1000 Default Promotion: True\nNon recoverable Promotion overflow!\nOVERFLOW: 1000_0111_0111_1000_1000_0111_0111_1000\nNumber of overflows: 303084\n```", "```py\n$ ./overflow.py -w 1024 -s 8 -c 16 -t 1500 500k.gz\nMax Cardinality: 16 Segments: 8 Sliding Window: 1024 Threshold: 1500 Default Promotion: False\nOVERFLOW: 0111_1000_1000_1000_1000_0111_0111_0111\nNumber of overflows: 176454\n```", "```py\n$ ./overflow.py -w 1024 -s 8 -c 32 -t 500 500k.gz\nMax Cardinality: 32 Segments: 8 Sliding Window: 1024 Threshold: 500 Default Promotion: False\nNumber of overflows: 0\n```"]