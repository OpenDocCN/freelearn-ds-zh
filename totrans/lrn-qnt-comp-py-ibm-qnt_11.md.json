["```py\n    %run helper_file_1.0.ipynb \n    ```", "```py\n    # Implement Deutsch's algorithm for a balanced function\n    qc = QuantumCircuit(2,1)\n    # Prepare the input qubits, where q0=0, q1=1\n    print('Step 1: Prepare the input qubits, where q0=0, q1=1')\n    qc.id(0)\n    qc.x(1)\n    qc.barrier()\n    qc.draw(output='mpl') \n    ```", "```py\n    # Place each qubit in superposition by applying a\n    # Hadamard\n    print('Step 2: Place each qubit in superposition by     applying a Hadamard')\n    qc.h(0)\n    qc.h(1)\n    qc.barrier()\n    qc.draw(output='mpl') \n    ```", "```py\n# Add a CNOT gate with the Control on q0 and Target on q1\nqc.cx(0,1)\n# Draw the circuit\nqc.draw(output='mpl') \n```", "```py\n    # Add the Hadamard gates to all qubits\n    qc.h(0)\n    qc.h(1)\n    qc.barrier() \n    ```", "```py\n    # Add measurement operator to the first qubit\n    qc.measure(0,0) \n    ```", "```py\n    # Run on a Sampler\n    def run_on_sampler(circuit):\n        from qiskit.primitives import StatevectorSampler\n        # Construct a Statevector Sampler\n        sampler = StatevectorSampler()\n        # Run using the Sampler\n        result = sampler.run([circuit]).result()\n        return result \n    ```", "```py\n    # Execute the quantum circuit on the simulator first to\n    # confirm our results.\n    print('Step 6: Execute the circuit to view results.')\n    result = run_on_sampler(qc)\n    counts = result[0].data.c.get_counts()\n    # Print and plot our results\n    print(counts)\n    plot_distribution(counts, title='Balanced function') \n    ```", "```py\n    # Create the quantum circuit with both input registers X,\n    # and y\n    input_qubits = 4  # Refers to our X input register,\n    #4-qubits\n    ancilla_qubit = 1 # Refers to our y input register,\n    #1--qubit\n    # Total qubits in our quantum circuit\n    total_qubits = input_qubits + ancilla_qubit\n    # Generate the circuit\n    qc = QuantumCircuit(total_qubits, input_qubits)\n    # Set the X qubits in superposition\n    for idx in range(input_qubits):\n        qc.h(idx)\n\n    # Set the y qubit to 1, then apply a Hadamard\n    qc.x(input_qubits)\n    qc.h(input_qubits)\n    qc.barrier()\n    qc.draw(output='mpl') \n    ```", "```py\n    # Set the bit string which we wish to evaluate,\n    # in this case set '1010', where I indicates value 0,\n    # and x indicates value 1.\n    qc.id(0)\n    qc.x(1)\n    qc.id(2)\n    qc.x(3)\n    qc.barrier()\n    qc.draw(output='mpl') \n    ```", "```py\n    # Set oracle to either constant (output = 0s)\n    # or balanced (output = 1s)\n    # In this example we will choose a balanced function\n    for idx in range(input_qubits):\n        qc.cx(idx, input_qubits)\n    qc.barrier()\n    qc.draw(output='mpl') \n    ```", "```py\n    # Set the closing bit string we selected earlier to\n    # evaluate\n    qc.id(0)\n    qc.x(1)\n    qc.id(2)\n    qc.x(3)\n    qc.barrier()\n    qc.draw(output='mpl') \n    ```", "```py\n    # Add the Hadamard gates to complete wrapping the oracle\n    for idx in range(4):\n        qc.h(idx)\n    qc.barrier()\n    qc.draw(output='mpl') \n    ```", "```py\n    # Add measurements only to our inputs\n    qc.measure(range(4),range(4))\n    # Draw the circuit\n    qc.draw(output='mpl') \n    ```", "```py\n    # Run the circuit\n    result = run_on_sampler(qc)\n    counts = result[0].data.c.get_counts()\n    # Print and plot results\n    print(counts)\n    plot_distribution(counts) \n    ```", "```py\n# Create your secret number\nshh = '1010'\n# Set the number of qubits to represent secret number and\n# an ancilla qubit\ninput_qubits = len(shh)\nancilla_qubit = 1\ntotal_qubits = input_qubits + ancilla_qubit\n# Create the quantum circuit\nqc = QuantumCircuit(total_qubits, input_qubits) \n```", "```py\n    # Add Hadamard gates to the input qubits\n    for idx in range(input_qubits):\n        qc.h(idx)\n    # Draw the input circuit\n    qc.draw(output='mpl') \n    ```", "```py\n    # Prepare the ancilla qubit of the circuit\n    qc.x(total_qubits-1)\n    qc.h(total_qubits-1)\n    qc.barrier()\n\n    # Draw the prepared circuit\n    qc.draw(output='mpl') \n    ```", "```py\n    # Before creating the oracle, we need to adjust the\n    # qubits. Since they are ordered from left to right,\n    # we will reverse the secret number's current value\n    print('Secret before reverse: ', shh)\n    # Reverse order\n    shh = shh[::-1]\n    print('Secret after reverse: ', shh) \n    ```", "```py\nSecret before reverse:  1010\nSecret after reverse:  0101 \n```", "```py\n    # Now that we have the right order,\n    # let's create the oracle by applying a CNOT,\n    # where the qubits set to '1' are the source\n    # and the target would be the ancilla qubit\n    for idx in range(input_qubits):\n        if shh[idx] == '1':\n            qc.cx(idx, input_qubits)\n    qc.barrier()\n    qc.draw(output='mpl') \n    ```", "```py\n# Now let's close up our circuit with Hadamard gates\n# applied to the input qubits\nfor idx in range(input_qubits):\n    qc.h(idx)\nqc.barrier()\n# Finally, let's add measurements to our input qubits\nqc.measure(range(input_qubits), range(input_qubits))\nqc.draw(output='mpl') \n```", "```py\n    # Execute the circuit and plot the results\n    result = run_on_sampler(qc)\n    counts = result[0].data.c.get_counts()\n    plot_distribution(counts) \n    ```"]