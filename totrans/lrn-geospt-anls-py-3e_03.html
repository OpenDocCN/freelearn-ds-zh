<html><head></head><body><div><h1 class="header-title">Learning Geospatial Data</h1>
                
            
            
                
<p>One of the most challenging aspects of geospatial analysis is the data. Geospatial data already includes dozens of file formats and database structures and continues to evolve and grow to include new types of data and standards. Additionally, almost any file format can technically contain geospatial information and is done by simply adding a location.</p>
<p>In this chapter, we will look at the following topics:</p>
<ul>
<li class="h1">Getting an overview of common data formats</li>
<li>Examining some common traits of geospatial data</li>
<li class="h1">Understanding spatial indexing</li>
<li>Knowing the most widely used vector data types</li>
<li>Understanding raster data types</li>
</ul>
<p>We'll also gain some insight into newer, more complex types, including point cloud data, web services, and geospatial databases.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting an overview of common data formats</h1>
                
            
            
                
<p>As a geospatial analyst, you may frequently encounter the following general data types:</p>
<ul>
<li>Spreadsheets and <strong>comma-separated values</strong> (<strong>CSV files</strong>) or <strong>tab-separated values</strong> (<strong>TSV files</strong>)</li>
<li>Geotagged photos</li>
<li>Lightweight binary points, lines, and polygons</li>
<li>Multi-gigabyte satellite or aerial images</li>
<li>Elevation data such as grids, point clouds, or integer-based images</li>
<li>XML files</li>
<li>JSON files</li>
<li>Databases (both servers and file databases)</li>
<li>Web services</li>
<li>Geodatabases</li>
</ul>
<p>Each format contains its own challenges for access and processing. When you perform analysis on data, you usually have to do some form of preprocessing first. You might clip or subset a satellite image of a large area down to just your area of interest, or you might reduce the number of points in a collection to just the ones meeting certain criteria in your data model. A good example of this type of preprocessing is the <kbd>SimpleGIS</kbd> example that we looked at the end of <a href="6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml">Chapter 1</a>, <em>Learning about Geospatial Analysis with Python</em>. The state dataset included just the state of Colorado rather than all 50 states. The city dataset included only three sample cities demonstrating three levels of population, along with different relative locations.</p>
<p>The common geospatial operations in <a href="6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml" target="_blank">Chapter 1</a>, <em>Learning about Geospatial Analysis with Python</em>, are the building blocks for this type of preprocessing. However, it is important to note that there has been a gradual shift in the field of geospatial analysis toward readily available basemaps. Until around 2004, geospatial data was difficult to acquire and desktop computing power was much less than it is today. Preprocessing data was an absolute first step for any geospatial project. However, in 2004, Google released Google Maps, which wasn't long after Google Earth. Microsoft had also been developing a technology acquisition called <strong>TerraServer</strong>, which they relaunched around this time. In 2004, the <strong>Open Geospatial Consortium</strong> (<strong>OGC</strong>) updated the version of its <strong>Web Map Service</strong> (<strong>WMS</strong>), which was growing in use and popularity. This same year, Esri also released version 9 of its ArcGIS server system. These innovations were driven by Google's web map tiling model, which allowed for smooth, global, scrolling maps at many different resolutions, and were often called <strong>slippy maps</strong>.</p>
<p>People used map servers on the internet before Google Maps, most famously with the MapQuest driving directions website. However, these map servers offered only small amounts of data at a time and usually over limited areas. The Google tiling system converted global maps into tiered image tiles for both images and mapping data. These were served dynamically using JavaScript and the browser-based <kbd>XMLHttpRequest</kbd> API, more commonly known as <strong>Asynchronous JavaScript and XML</strong> (<strong>AJAX</strong>). Google's system scaled to millions of users using ordinary web browsers. More importantly, it allowed programmers to leverage JavaScript programming to create mashups so that they could use the Google Maps JavaScript API to add additional data to the maps. The mashup concept is actually a shared geospatial layers system. Users can combine and recombine data from different web services into a single map, as long as the data is web-accessible. Other commercial and open source systems quickly mimicked this concept.</p>
<p>Notable examples of distributed geospatial layers are <strong>OpenLayers</strong>, which provide an open source, Google-like API that has now gone beyond Google's API, offering additional features. Complimentary to OpenLayers is <strong>OpenStreetMap</strong>, which is the open source answer to the tiled map services consumed by systems such as OpenLayers. OpenStreetMap has global, street-level vector data and other spatial features that have been collected from available government data sources and the contributions of thousands of editors worldwide. OpenStreetMap's data maintenance model is similar to the way Wikipedia, the online encyclopedia, crowd sources information creation and updates for articles. Recently, even more mapping APIs have appeared, including Leaflet and Mapbox, which continue to increase in flexibility, simplicity, and capability.</p>
<p>The mashup revolution had interesting and beneficial side effects on data. Geospatial data is traditionally difficult to obtain. The cost of collecting, processing, and distributing data kept geospatial analysis constrained to those who could afford this steep overhead cost by producing data or purchasing it. For decades, geospatial analysis was the tool of governments, very large organizations, and universities. Once the web mapping trend shifted to large-scale, globally tiled maps, organizations began essentially providing basemap layers for free in order to draw developers to their platform. The massively scalable global map system required massively scalable, high-resolution data to be useful. Geospatial software producers and data providers wanted to maintain their market share and kept up with the technology trend.</p>
<p>Geospatial analysts benefited greatly from this market shift in several ways. First of all, data providers began distributing data in a common projection called <strong>Mercator</strong>. The Mercator projection is a nautical navigation projection that was introduced over 400 years ago. As we mentioned in <a href="6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml">Chapter 1</a>, <em>Learning about Geospatial Analysis with Python</em>, all projections have practical benefits, as well as distortions. The distortion in the Mercator projection is its size. In a global view, Greenland appears bigger than the continent of South America. However, like every projection, it also has some benefits. Mercator preserves angles. Predictable angles allowed medieval navigators to draw straight bearing lines when plotting a course across oceans. Google Maps didn't launch with Mercator. However, it quickly became clear that roads in high and low latitudes met at odd angles on the map instead of the 90 degrees in reality.</p>
<p>Since the primary purpose of Google Maps was street-level driving directions, Google sacrificed the global view accuracy for far better relative accuracy among streets when viewing a single city. Competing mapping systems followed suit. Google also standardized on the WGS 84 datum. This datum defines a specific spherical model of the Earth, called a <strong>geoid</strong>. This model defines the normal sea level. What's significant about this choice by Google is that the <strong>Global Positioning System</strong> (<strong>GPS</strong>) also uses this datum. Therefore, most GPS units default to this datum as well, making Google Maps easily compatible with raw GIS data.</p>
<p>The Google variation of the Mercator projection is often called <strong>Google Mercator</strong>. The <strong>European Petroleum Survey Group</strong> (<strong>EPSG</strong>) assigns short numeric codes to projections as an easy way to reference them. Rather than waiting for the EPSG to approve or assign a code that was first only relevant to Google, they began calling the projection EPSG:900913, which is <em>Google</em> spelled with numbers. Later, EPSG assigned the code EPSG:3857, deprecating the older code. Most GIS systems recognize the two codes as synonymous. It should be noted that Google tweaked the standard Mercator projection slightly for its use; however, this variation is almost imperceptible. Google uses spherical formulas at all map scales, while the standard Mercator assumes an ellipsoidal form at large scales.</p>
<p>The following image of the Mercator projection (<a href="https://en.wikipedia.org/wiki/File:Tissot_mercator.png">https://en.wikipedia.org/wiki/File:Tissot_mercator.png</a>) was taken from Wikipedia:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/aa3f6516-3f64-4141-bf6c-3a82af6b95a6.png" style="width:41.00em;height:38.08em;" width="797" height="740"/></p>
<p>It shows the distortion caused by the Mercator projection using Tissot's indicatrix, which projects small ellipses of equal size on a map. The distortion of the ellipse clearly shows how the projection affects the size and distance: web mapping services have reduced the chore of hunting for data and much of the preprocessing for analysts to create basemaps. However, to create anything of value, you must understand geospatial data and how to work with it. This chapter provides an overview of the common data types and issues that you will encounter in geospatial analysis.</p>
<p>Throughout this chapter, two terms will be commonly used:</p>
<ul>
<li><strong>Vector data:</strong> Vector data includes any format that minimally represents geolocation data using points, lines, or polygons.</li>
<li><strong>Raster data:</strong> Raster data includes any format that stores data in a grid of rows and columns. Raster data includes all image formats.<strong><br/></strong></li>
</ul>
<p>These are the two primary categories under which most geospatial datasets can be grouped. </p>
<p>If you want to see a projection that shows the relative size of continents more accurately, refer to the Goode homolosine projection: <a href="https://en.wikipedia.org/wiki/Goode_homolosine_projection">https://en.wikipedia.org/wiki/Goode_homolosine_projection</a>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Understanding data structures</h1>
                
            
            
                
<p>Despite having dozens of formats, geospatial data has some common traits. Understanding these traits can help you approach and understand unfamiliar data formats by identifying the ingredients common to nearly all spatial data. The structure of a given data format is usually driven by its intended use.</p>
<p>Some data is optimized for efficient storage or compression, some is optimized for efficient access, some is designed to be lightweight and readable (web formats), while other data formats seek to contain as many different data types as possible.</p>
<p>Interestingly, some of the most popular formats today are also some of the simplest and even lack features found in more capable and sophisticated formats. Ease of use is extremely important to geospatial analysts because so much time is spent integrating data into geographic information systems, as well as exchanging data among analysts. Simple data formats facilitate these activities the best.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Common traits</h1>
                
            
            
                
<p>Geospatial analysis is an approach in which you apply information processing techniques to data with a geographic context. This definition contains the most important elements of geospatial data:</p>
<ul>
<li><strong>Geolocation data</strong>: Geolocation information can be as simple as a single point on the Earth referencing where a photo was taken. It can also be as complex as a satellite camera engineering model and orbital mechanics information being used to reconstruct the exact conditions and location under which the satellite captured the image.</li>
<li><strong>Subject information</strong>: Subject information can also cover a wide range of possibilities. Sometimes, the pixels in an image are the data in terms of a visual representation of the ground. Other times, an image may be processed using multispectral bands, such as infrared light, to provide information that's not visible in the image. Processed images are often classified using a structured color palette that is linked to a key, describing the information each color represents. Other possibilities include some form of database with rows and columns of information for each geolocated feature, such as the population associated with each city in our <kbd>SimpleGIS</kbd> from <a href="6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml">Chapter 1</a>, <em>Learning about Geospatial Analysis with Python</em>.</li>
</ul>
<p>These two factors are present in every format that can be considered geospatial data. Another common feature of geospatial data is spatial indexing. Overview datasets are also related to indexing.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Understanding spatial indexing</h1>
                
            
            
                
<p>Geospatial datasets are often very large files, easily reaching hundreds of megabytes or even several gigabytes in size. Geospatial software can be quite slow in trying to repeatedly access large files when performing analysis.</p>
<p>As discussed briefly in <a href="6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml">Chapter 1</a>, <em>Learning about Geospatial Analysis with Python</em>, spatial indexing creates a guide, which allows the software to quickly locate query results without examining every single feature in the dataset. Spatial indexes allow the software to eliminate possibilities and perform more detailed searches or comparisons on a much smaller subset of the data.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Spatial indexing algorithms</h1>
                
            
            
                
<p>Many spatial indexing algorithms are derivatives of well-established algorithms that have been used on non-spatial information for decades. The two most common spatial indexing algorithms are <strong>Quadtree index</strong> and <strong>R-tree index</strong>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Quadtree index</h1>
                
            
            
                
<p>The Quadtree algorithm actually represents a series of different algorithms based on a common theme. Each node in a Quadtree index contains four children. These child nodes are typically square or rectangular in shape. When a node contains a specified number of features and more features are added, the node splits.</p>
<p>The concept of dividing a space into nested squares speeds up spatial searches. The software must only handle five points at a time and use simple greater-than/less-than comparisons to check whether a point is inside a node. Quadtree indexes are most commonly found in file-based index formats.</p>
<p>The following diagram shows a point dataset sorted by a Quadtree algorithm. The black points are the actual dataset, while the boxes are the bounding boxes of the index. Note that none of the bounding boxes overlap. The diagram on the left shows the spatial representation of the index, while the diagram on the right shows the hierarchical relationship of a typical index, which is how spatial software sees the index and data.</p>
<p>This structure allows a spatial search algorithm to quickly eliminate possibilities when trying to locate one or more points in relation to some other set of features, as shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/398e27ef-ba22-41b8-b31f-070bf520ed09.png" style="width:35.17em;height:15.00em;" width="1165" height="497"/></p>
<p>Now that we understand quadtree indexes, let's look at another common type of spatial indexes called R-trees.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">R-tree index</h1>
                
            
            
                
<p><strong>R-tree</strong> indexes are more sophisticated than Quadtrees. R-trees are designed to handle 3D data and are optimized to store the index in a way that is compatible with the way databases use disk space and memory. Nearby objects are grouped together using an algorithm from a variety of spatial algorithms. All objects in a group are bounded by a minimum rectangle. These rectangles are aggregated into hierarchical nodes that are balanced at each level.</p>
<p>Unlike a Quadtree, the bounding boxes of an R-tree may overlap across nodes. Due to their relative complexity and database-oriented structure, R-trees are most commonly found in spatial databases, as opposed to file-based formats.</p>
<p>The following diagram from <a href="https://en.wikipedia.org/wiki/File:R-tree.svg">https://en.wikipedia.org/wiki/File:R-tree.svg</a> shows a balanced R-tree for a 2D point dataset:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/0dbb8666-cc09-4f9f-99d4-7dd14fa27ae2.png" style="width:44.25em;height:35.67em;" width="1034" height="833"/></p>
<p>Indexes break up large datasets, but to speed up searching, they may employ a technique called <strong>grids</strong>. We'll look at that next.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Grids</h1>
                
            
            
                
<p>Spatial indexes also often employ the concept of an integer grid. Geospatial coordinates are usually floating-point decimal numbers with anywhere from 2 to 16 decimal places. Performing comparisons on floating-point numbers is far more computationally expensive than working with integers. Indexed searching is about eliminating possibilities that don't require precision first.</p>
<p>Most spatial indexing algorithms, therefore, map floating-point coordinates to a fixed-sized integer grid. On searching for a particular feature, the software can use more efficient integer comparisons rather than working with floating-point numbers. Once the results are narrowed down, the software can access the full resolution data.</p>
<p>Grid sizes can be as small as 256 x 256 for simple file formats, or can be as large as 3 million x 3 million in large geospatial databases designed to incorporate every known coordinate system and possible resolution.</p>
<p>The integer mapping technique is very similar to the rendering technique that is used to plot data on a graphics canvas in mapping programs. The <kbd>SimpleGIS</kbd> script in <a href="6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml">Chapter 1</a>, <em>Learning about Geospatial Analysis with Python</em>, also uses this technique to render points and polygons using the built-in Python turtle graphics engine.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">What are overviews?</h1>
                
            
            
                
<p>Overview data is most commonly found in raster formats. Overviews are resampled and lower-resolution versions of raster datasets that provide thumbnail views or simply faster-loading image views at different map scales. They are also known as <strong>pyramids</strong>, and the process of creating them is known as <strong>pyramiding an image</strong>. These overviews are usually preprocessed and stored with the full resolution data either embedded with the file or in a separate file.</p>
<p>The compromise of this convenience is that the additional images add to the overall file size of the dataset; however, they speed up image viewers. Vector data also has a concept of overviews, usually to give a dataset geographic context in an overview map. However, because vector data is scalable, reduced size overviews are usually created on the fly by software using a generalization operation, as mentioned in <a href="6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml">Chapter 1</a>, <em>Learning about Geospatial Analysis with Python</em>.</p>
<p>Occasionally, vector data is rasterized by converting it into a thumbnail image, which is stored with, or embedded in, the image header. The following diagram demonstrates the concept of image overviews that shows visually why they are often called pyramids:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/2c449dc3-a96e-499f-b133-afafb9a0737c.png" style="width:24.67em;height:18.75em;" width="1206" height="916"/></p>
<p>Spatial indexing and overviews help speed up access to data by software for analysts. Next, we'll look at metadata, which provides both a human-and machine-readable way to understand, search, and even catalog data.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">What is metadata?</h1>
                
            
            
                
<p>As discussed in <a href="6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml">Chapter 1</a>, <em>Learning about Geospatial Analysis with Python</em>, metadata is any data that describes the associated dataset. Common examples of metadata include basic elements such as the footprint of the dataset on the Earth, as well as more detailed information such as spatial projection and information describing how the dataset was created.</p>
<p>Most data formats contain the footprint or bounding box of the data on the Earth. Detailed metadata is typically stored in a separate location in a standard format, such as the US <strong>Federal Geographic Data Committee</strong> (<strong>FGDC</strong>), <strong>Content Standard for Digital Geospatial Metadata</strong> (<strong>CSDGM</strong>), ISO, or the newer European Union initiative, which includes metadata requirements, and is called the <strong>Infrastructure for Spatial Information in the European Community</strong> (<strong>INSPIRE</strong>).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Understanding the file structure</h1>
                
            
            
                
<p>The preceding elements can be stored in a variety of ways in a single file, multiple files, or databases, depending on the format. Additionally, this geospatial information can be stored in a variety of formats, including embedded binary headers, XML, database tables, spreadsheets/CSV, separate text, or binary files.</p>
<p>Human-readable formats such as XML files, spreadsheets, and structured text files require only a text editor to be investigated. These files are also easily parsed and processed using Python's built-in modules, data types, and string manipulation functions. Binary-based formats are more complicated. Therefore, it is typically easier to use a third-party library to deal with binary formats.</p>
<p>However, you don't have to use a third-party library, especially if you just want to investigate the data at a high level. Python's built-in <kbd>struct</kbd> module has everything that you need. The <kbd>struct</kbd> module lets you read and write binary data as strings. When using the <kbd>struct</kbd> module, you need to be aware of the concept of byte order. Byte order refers to how the bytes of information that make up a file are stored in memory. This order is usually platform-specific, but in some rare cases, including shapefiles, the byte order is mixed into the file.</p>
<p>The Python <kbd>struct</kbd> module uses the greater than (<kbd>&gt;</kbd>) and less than (<kbd>&lt;</kbd>) symbols to specify byte order (big-endian and little-endian, respectively).</p>
<p>The following brief example demonstrates the usage of the Python <kbd>struct</kbd> module to parse the bounding box coordinates from an Esri shapefile vector dataset. You can download this shapefile as a zipped file from the following URL: <a href="https://github.com/GeospatialPython/Learn/blob/master/hancock.zip?raw=true">https://github.com/GeospatialPython/Learn/blob/master/hancock.zip?raw=true</a>.<a href="https://geospatialpython.googlecode.com/files/hancock.zip"><br/></a></p>
<p>When you unzip this, you will see three files. For this example, we'll be using <kbd>hancock.shp</kbd>. The Esri shapefile format has a fixed location and data type in the file header from byte 36 to byte 37 for the minimum <em>x</em>, minimum <em>y</em>, maximum <em>x</em>, and maximum <em>y</em> bounding box values. In this example, we will execute the following steps:</p>
<ol>
<li>Import the <kbd>struct</kbd> module.</li>
<li>Open the <kbd>hancock.zip</kbd> shapefile in the binary read mode.</li>
<li>Navigate to byte <kbd>36</kbd>.</li>
<li>Read each 8-byte double variables specified as <kbd>d</kbd>, and unpack it using the <kbd>struct</kbd> module in little-endian order, as designated by the <kbd>&lt;</kbd> sign.</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The best way to execute this script is in the interactive Python interpreter. We will then read the minimum longitude, minimum latitude, maximum longitude, and maximum latitude:</p>
<pre><strong>&gt;&gt;&gt; import struct</strong> 
<strong>&gt;&gt;&gt; f = open("hancock.shp","rb")</strong> 
<strong>&gt;&gt;&gt; f.seek(36)</strong> 
<strong>&gt;&gt;&gt; struct.unpack("&lt;d", f.read(8))</strong> 
(-89.6904544701547,) <strong>
&gt;&gt;&gt; struct.unpack("&lt;d", f.read(8)) </strong>
(30.173943486533133,) 
<strong>&gt;&gt;&gt; struct.unpack("&lt;d", f.read(8))</strong> 
(-89.32227546981174,) 
<strong>&gt;&gt;&gt; struct.unpack("&lt;d", f.read(8))</strong> 
(30.6483914869749,) </pre>
<p>You'll notice that, when the <kbd>struct</kbd> module unpacks a value, it returns a Python tuple with one value. You can shorten the preceding unpacking code to one line by specifying all four doubles at once and increasing the byte length to 32 bytes, as shown in the following code:</p>
<pre><strong>&gt;&gt;&gt; f.seek(36)</strong> 
<strong>&gt;&gt;&gt; struct.unpack("&lt;dddd", f.read(32))</strong> 
(-89.6904544701547, 30.173943486533133, -89.32227546981174, <br/>   30.6483914869749) </pre>
<p>Now that we understand how to describe data, let's learn about one of the most common types of geospatial data—vector data.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Knowing the most widely used vector data types</h1>
                
            
            
                
<p>Vector data is, by far, the most common geospatial format because it is the most efficient way to store spatial information. In general, it requires fewer computer resources to store and process than raster data. The OGC has over 16 formats directly related to vector data. Vector data stores only geometric primitives, including points, lines, and polygons. However, only the points are stored for each type of shape. For example, in the case of a simple straight vector line shape, only the endpoints would be necessarily stored and defined as a line. Software displaying this data would read the shape type and then connect the endpoints with a line dynamically.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Geospatial vector data is similar to the concept of vector computer graphics, with some notable exceptions. Geospatial vector data contains positive and negative Earth-based coordinates, while vector graphics typically store computer screen coordinates. Geospatial vector data is also usually linked to other information about the object that's represented by the geometry. This information may be as simple as a timestamp in the case of GPS data or an entire database table for larger geographic information systems.</p>
<p>Vector graphics often store styling information describing colors, shadows, and other display-related instructions, while geospatial vector data typically does not. Another important difference is the shapes. Geospatial vectors typically only include very primitive geometries based on points, straight lines, and straight-line polygons, while many computer graphic vector formats have concepts of curves and circles. However, geospatial vectors can model these shapes using more points.</p>
<p>Other human-readable formats, such as CSV, simple text strings, GeoJSON, and XML-based formats, are technically vector data because they store geometry as opposed to rasters, which represent all the data within the bounding box of the dataset. Until the explosion of XML in the late 1990s, vector data formats were nearly all binary. XML provided a hybrid approach that was both computer and human-readable. The compromise is that text formats such as GeoJSON and XML data greatly increase the file size compared to binary formats. These formats will be discussed later in this section.</p>
<p>The number of vector formats to choose from is staggering. The open source vector library, OGR (<a href="http://www.gdal.org/ogr_formats.html">http://www.gdal.org/ogr_formats.html</a>), lists over 86 supported vector formats. Its commercial counterpart, Safe Software's <strong>Feature Manipulation Engine</strong> (<strong>FME</strong>), lists over 188 supported vector formats (<a href="http://www.safe.com/fme/format-search/#filters%5B%5D=VECTOR">http://www.safe.com/fme/format-search/#filters%5B%5D=VECTOR</a>). These lists include a few vector graphics formats, as well as human-readable geospatial formats. There are still dozens of formats out there to at least be aware of, in case you come across them.</p>
<p>Now, let's look at a specific, and widely used type of vector data called shapefiles.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Shapefiles</h1>
                
            
            
                
<p>The most ubiquitous geospatial format is the Esri shapefile. The geospatial software company known as Esri released the shapefile format specification as an open format in 1998 (<a href="http://www.esri.com/library/whitepapers/pdfs/shapefile.pdf">http://www.esri.com/library/whitepapers/pdfs/shapefile.pdf</a>). Esri developed it as a format for their ArcView software, designed as a lower-end GIS option to complement their high-end professional package, <strong>ArcInfo</strong>, formerly called <strong>ARC/INFO</strong>. However, the open specification, efficiency, and simplicity of the format turned it into an unofficial GIS standard that is still extremely popular over 15 years later.</p>
<p>Virtually, every piece of the software labeled as geospatial software supports shapefiles because the shapefile format is so common. For this reason, you can almost get by as an analyst by being intimately familiar with shapefiles and mostly ignoring other formats. You can convert almost any other format into a shapefile through the source format's native software or a third-party converter, such as the OGR library, for which there is a Python module. Other Python modules that handle shapefiles are Shapely and Fiona, which are based on OGR.</p>
<p>One of the most striking features of a shapefile is that the format consists of multiple files (from minimum to maximum, there can be 3-15 different files). The following table describes the file formats. The <kbd>.shp</kbd>, <kbd>.shx</kbd>, and <kbd>.dbf</kbd> files are required for a valid shapefile:</p>
<table style="border-collapse: collapse;width: 90%" border="1">
<thead>
<tr>
<td>
<p><strong>Shapefile supporting file extension</strong></p>
</td>
<td>
<p><strong>Supporting file purpose</strong></p>
</td>
<td>
<p><strong>Notes</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
<p><kbd>.shp</kbd></p>
</td>
<td>
<p>This is the shapefile. It contains the geometry.</p>
</td>
<td>
<p>It is a required file. Some software that needs only geometry will accept the <kbd>.shp</kbd> files without the <kbd>.shx</kbd> or <kbd>.dbf</kbd> file.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>.shx</kbd></p>
</td>
<td>
<p>This is the shape index file. It is a fixed-sized record index referencing geometry for faster access.</p>
</td>
<td>
<p>It is a required file. This file is meaningless without the <kbd>.shp</kbd> file.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>.dbf</kbd></p>
</td>
<td>
<p>This is the database file. It contains the geometry attributes.</p>
</td>
<td>
<p>It is a required file. Some software will access this format without the <kbd>.shp</kbd> file present as the specification predates shapefiles. It's based on the very old FoxPro and dBase formats. An open specification exists for it called Xbase. The <kbd>.dbf</kbd> files can be opened by most types of spreadsheet software.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>.sbn</kbd></p>
</td>
<td>
<p>This is the spatial bin file, that is, the shapefile spatial index.</p>
</td>
<td>
<p>It contains bounding boxes of features mapped to a 256 x 256 integer grid. It is very common for this file to accompany large shapefile datasets.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>.sbx</kbd></p>
</td>
<td>
<p>A fixed-sized record index for the <kbd>.sbn</kbd> file.</p>
</td>
<td>
<p>A traditional ordered record index of a spatial index. Frequently seen.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>.prj</kbd></p>
</td>
<td>
<p>This contains map projection information that's stored in a well-known text format.</p>
</td>
<td>
<p>A very common and required file for on-the-fly projection by the GIS software. This same format can also accompany raster data.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>.fbn</kbd></p>
</td>
<td>
<p>A spatial index of read-only features.</p>
</td>
<td>
<p>Very rarely seen.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>.fbx</kbd></p>
</td>
<td>
<p>A fixed-sized record index of the <kbd>.fbn</kbd> spatial index.</p>
</td>
<td>
<p>Very rarely seen.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>.ixs</kbd></p>
</td>
<td>
<p>A geocoding index.</p>
</td>
<td>
<p>Common in geocoding applications, including driving-direction type applications.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>.mxs</kbd></p>
</td>
<td>
<p>Another type of geocoding index.</p>
</td>
<td>
<p>Less common than the <kbd>.ixs</kbd> format.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>.ain</kbd></p>
</td>
<td>
<p>Attribute index.</p>
</td>
<td>
<p>Mostly legacy format, and rarely used in modern software.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>.aih</kbd></p>
</td>
<td>
<p>Attribute index.</p>
</td>
<td>
<p>Accompanies the <kbd>.ain</kbd> files.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>.qix</kbd></p>
</td>
<td>
<p>Quadtree index.</p>
</td>
<td>
<p>A spatial index format created by the open source community because the Esri <kbd>.sbn</kbd> and <kbd>.sbx</kbd> files were undocumented until recently.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>.atx</kbd></p>
</td>
<td>
<p>Attribute index.</p>
</td>
<td>
<p>A more recent Esri software-specific attribute index to speed up attribute queries.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>.shp.xml</kbd></p>
</td>
<td>
<p>Metadata.</p>
</td>
<td>
<p>A geospatial metadata <kbd>.xml</kbd> container. It can be any of the multiple XML standards, including FGDC and ISO.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>.cpg</kbd></p>
</td>
<td>
<p>Code page file for <kbd>.dbf</kbd>.</p>
</td>
<td>
<p>It is used for the internationalization of <kbd>.dbf</kbd> files.</p>
</td>
</tr>
</tbody>
</table>
<div><p class="mce-root"/>
<p class="mce-root"/>
<p>You will probably never encounter all of these formats at once. However, any shapefile that you use will have multiple files. You will commonly see <kbd>.shp</kbd>, <kbd>.shx</kbd>, <kbd>.dbf</kbd>, <kbd>.prj</kbd>, <kbd>.sbn</kbd>, <kbd>.sbx</kbd>, and occasionally, <kbd>.shp.xml</kbd> files. If you want to rename a shapefile, you must rename all of the associated files with the same name; however, in Esri software and other GIS packages, these datasets will appear as a single file.</p>
<p>Another important feature of shapefiles is that the records are not numbered. Records include the geometry, the <kbd>.shx</kbd> index record, and the <kbd>.dbf</kbd> record. These records are stored in a fixed order. When you examine shapefile records using the software, they appear to be numbered.</p>
<p>People are often confused when they delete a shapefile record, save the file, and reopen it; the number of the record that was deleted still appears. The reason for this is that the shapefile records are numbered dynamically on loading, but not saved. So, for example, if you delete record number 23 and save the shapefile, record number 24 will become 23 the next time you read the shapefile. Many people expect to open the shapefile and see the records jump from 22 to 24. The only way to track shapefile records in this way is to create a new attribute called ID or similar in the <kbd>.dbf</kbd> file and assign each record a permanent and unique identifier.</p>
<p>Just like renaming shapefiles, care must be taken while editing shapefiles. It's best to use software that treats the shapefiles as a single dataset. If you edit any of the files individually and add/delete a record without editing the accompanying files, the shapefile will be seen as corrupt by most geospatial software.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">CAD files</h1>
                
            
            
                
<p><strong>CAD</strong> stands for <strong>computer-aided design</strong>. The primary formats for CAD data were created by Autodesk for their leading AutoCAD package. The two formats that are commonly seen are <strong>Drawing Exchange Format</strong> (<strong>DXF</strong>) and AutoCAD's native <strong>Drawing</strong> (<strong>DWG</strong>) format.</p>
<p>DWG was traditionally a closed format, but it has become more open.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The CAD software is used for everything that is engineering-related, from designing bicycles to cars, parks, and city sewer systems. As a geospatial analyst, you don't have to worry about mechanical engineering designs; however, civil engineering designs become quite an issue. Most engineering firms use geospatial analysis to a very limited degree, but store nearly all of their data in the CAD format. The DWG and DXF formats can represent objects using features not found in geospatial software or that are weakly supported by geospatial systems. Some examples of these features include the following:</p>
<ul>
<li>Curves</li>
<li>Surfaces (for objects that are different from geospatial elevation surfaces)</li>
<li>3D solids</li>
<li>Text (rendered as an object)</li>
<li>Text styling</li>
<li>Viewport configuration</li>
</ul>
<p>These CAD and engineering-specific features make it difficult to cleanly convert CAD data into geospatial formats. If you encounter CAD data, the easiest option is to ask the data provider if they have shapefiles or some other geospatial-centric format.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Tag-based and markup-based formats</h1>
                
            
            
                
<p>Tag-based markup formats are typically XML formats. They also include other structured text formats such as the <strong>Well-Known Text</strong> (<strong>WKT</strong>) format, which is used for projection information files as well as different types of data exchange.</p>
<p>XML formats include the <strong>Keyhole Markup Language</strong> (<strong>KML</strong>), the <strong>OpenStreetMap</strong> (<strong>OSM</strong>) format, and the Garmin GPX format for GPS data, which has become a popular exchange format. The Open Geospatial Consortium's <strong>Geographic Markup Language</strong> (<strong>GML</strong>) standard is one of the oldest and most widely used XML-based geographic formats. It is also the basis for the OGC <strong>Web Feature Service</strong> (<strong>WFS</strong>) standard for web applications. However, GML has been largely superseded by KML and the GeoJSON format.</p>
<p>XML formats often contain more than just geometry. They also contain attributes and rendering instructions such as color, styling, and symbology. Google's KML format has become a fully supported OGC standard. The following is a sample of KML showing a simple placemark:</p>
<pre>&lt;?xml version="1.0" encoding="utf-8"?&gt; 
&lt;kml &gt; 
  &lt;Placemark&gt; 
    &lt;name&gt;Mockingbird Cafe&lt;/name&gt; 
    &lt;description&gt;Coffee Shop&lt;/description&gt; 
    &lt;Point&gt; 
      &lt;coordinates&gt;-89.329160,30.310964&lt;/coordinates&gt; 
    &lt;/Point&gt; 
  &lt;/Placemark&gt; 
&lt;/kml&gt; </pre>
<p>The XML format is attractive to geospatial analysts for the following reasons:</p>
<ul>
<li>It is a human-readable format.</li>
<li>It can be edited in a text editor.</li>
<li>It is well supported by programming languages (especially Python).</li>
<li>It is, by definition, easily extensible.</li>
</ul>
<p>XML is not perfect, though. It is an inefficient storage mechanism for very large data formats and can quickly become cumbersome to edit. Errors in datasets are common, and most parsers do not handle errors robustly. Despite the downsides, XML is widely used in geospatial analysis.</p>
<p><strong>Scalable Vector Graphics</strong> (<strong>SVG</strong>) is a widely supported XML format for computer graphics. It is supported well by browsers and is often used for geospatial rendering. However, SVG was not designed as a geographic format.</p>
<p>The WKT format is also an older OGC standard. The most common use for it is to define projection information usually stored in <kbd>.prj</kbd> projection files, along with a shapefile or raster. The WKT string for the WGS 84 coordinate system is as follows:</p>
<pre>GEOGCS["WGS 84", 
    DATUM["WGS_1984", 
        SPHEROID["WGS 84",6378137,298.257223563, 
            AUTHORITY["EPSG","7030"]], 
        AUTHORITY["EPSG","6326"]], 
    PRIMEM["Greenwich",0, 
        AUTHORITY["EPSG","8901"]], 
    UNIT["degree",0.01745329251994328, 
        AUTHORITY["EPSG","9122"]], 
    AUTHORITY["EPSG","4326"]] </pre>
<p>The parameters that define a projection can be quite long. A standards committee, which was created by the EPSG, introduced a numerical coding system to reference projections. These codes, such as EPSG:4326, are used as shorthand for strings such as the preceding code. There are also short names for commonly used projections such as Mercator, which can be used in different software packages to reference a projection.</p>
<p>More information on these reference systems can be found on the spatial reference website at <a href="http://spatialreference.org/ref/">http://spatialreference.org/ref/</a>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">GeoJSON</h1>
                
            
            
                
<p>GeoJSON is a relatively new and brilliant text format based on the <strong>JavaScript Object Notation</strong> (<strong>JSON</strong>) format, which has been a commonly used data exchange format for years. Despite its short history, GeoJSON can be found embedded in all major geospatial software systems and most websites that distribute data. This is because JavaScript is the language of the dynamic web, and GeoJSON can be directly fed into JavaScript.</p>
<p>GeoJSON is a completely backward-compatible extension for the popular JSON format. The structure of JSON is very similar and, in some cases, identical to existing data structures of common programming languages. JSON is almost identical to Python's dictionary and list data types. Due to this similarity, parsing JSON in a script is simple to do from scratch, but there are many libraries to make it even easier. Python contains a built-in library aptly named <kbd>json</kbd>.</p>
<p>GeoJSON provides you with a standard way to define geometry, attributes, bounding boxes, and projection information. GeoJSON has all of the advantages of XML, including human-readable syntax, excellent software support, and wide use in the industry. It also surpasses XML.</p>
<p>GeoJSON is far more compact than XML, largely because it uses simple symbols to define objects rather than opening and closing text-laden tags. This compactness also helps with the readability and manageability of larger datasets. However, it is still inferior to binary formats from a data volume standpoint. The following is a sample of the GeoJSON syntax, defining a geometry collection with both a point and line:</p>
<pre>{ "type": "GeometryCollection", 
  "geometries": [ 
    { "type": "Point", 
      "coordinates": [-89.33, 30.0] 
    }, 
    { "type": "LineString", 
      "coordinates": [ [-89.33, 30.30], [-89.36, 30.28] ] 
    } 
  {"type": "Polygon", 
    "coordinates": [[ 
      [-104.05, 48.99], 
      [-97.22,  48.98] 
    } 
  ] 
} </pre>
<p>The preceding code is a valid GeoJSON, but it is also a valid Python data structure. You can copy the preceding code sample directly into the Python interpreter as a variable definition and it will evaluate without error, as follows:</p>
<pre>gc = { "type": "GeometryCollection", 
  "geometries": [ 
    { "type": "Point", 
      "coordinates": [-89.33, 30.0] 
    }, 
    { "type": "LineString", 
      "coordinates": [ [-89.33, 30.30], [-89.36, 30.28] ] 
    } 
  ] 
} 
gc 
{'type': 'GeometryCollection', 'geometries': [{'type': 'Point', <br/>   'coordinates': [ 
  -89.33, 30.0]}, {'type': 'LineString', 'coordinates': [[-89.33, <br/>     30.3], [-89.36,30.28]]}]} </pre>
<p>Due to its compact size, internet-friendly syntax by virtue of being written in JavaScript, and support from major programming languages, GeoJSON is a key component of leading REST geospatial web APIs, which will be covered later in this chapter. It currently offers the best compromise among the computer resource efficiency of binary formats, the human-readability of text formats, and programmatic utility.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">GeoPackage</h1>
                
            
            
                
<p>We'll briefly mention the GeoPackage format here as it's covered in <a href="a5e439d1-e7fd-46b4-8fd3-8f811bfe73e4.xhtml">Chapter 3</a>, <em>The Geospatial Technology Landscape</em>, as well as because it's a type of geodatabase. The <kbd>geopackage</kbd> format is an OGC open standard on a SQLite file-based database container that is a platform, vendor, and software independent. It's an attempt to get away from all of the issues that are generated from either proprietary data formats or limited data formats.</p>
<p>Next, we'll look at the other major data type: raster data.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Understanding raster data types</h1>
                
            
            
                
<p>Raster data consists of rows and columns of cells or pixels, with each cell representing a single value. The easiest way to think of raster data is as images, which is how they are typically represented by software. However, raster datasets are not necessarily stored as images. They can also be ASCII text files or <strong>Binary Large Objects</strong> (<strong>BLOBs</strong>) in databases.</p>
<p>Another difference between geospatial raster data and regular digital images is their resolution. Digital images express resolution as dots-per-inch if printed in full size. Resolution can also be expressed as the total number of pixels in the image, and are defined as megapixels. However, geospatial raster data uses the ground distance that each cell represents. For example, a raster dataset with a two-foot resolution means that a single cell represents two feet on the ground, which also means that only objects larger than two feet can be identified visually in the dataset.</p>
<p>Raster datasets may contain multiple bands, meaning that different wavelengths of light can be collected at the same time over the same area. Often, this range is from 3-7 bands, but can be several hundred in hyperspectral systems. These bands are viewed individually or swapped in and out as the RGB bands of an image. They can also be recombined into a derivative single-band image using mathematics and then recolored using a set number of classes representing values within the dataset.</p>
<p>Another common application of raster data is in the field of scientific computing, which shares many elements of geospatial remote sensing but adds some interesting twists. Scientific computing often uses complex raster formats, including <strong>Network Common Data Form</strong> (<strong>NetCDF</strong>), <strong>GRIB</strong>, and <strong>HDF5</strong>, which store entire data models. These formats are more like directories in a filesystem and can contain multiple datasets or multiple versions of the same dataset. Oceanography and meteorology are the most common applications of this kind of analysis. An example of a scientific computing dataset is the output of a weather model, where the cells of the raster dataset in different bands may represent a different variables' output from the model in a time series.</p>
<p>Like vector data, raster data can come in a variety of formats. The open source <kbd>raster</kbd> library, known as <strong>Geospatial Data Abstraction Library</strong> (<strong>GDAL</strong>), which actually includes the vector OGR library we mentioned earlier, lists over 130 supported raster formats (<a href="http://www.gdal.org/formats_list.html">http://www.gdal.org/formats_list.html</a>). The FME software package supports this many as well. However, just like shapefiles and CAD data, there are a few standout raster formats.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">TIFF files</h1>
                
            
            
                
<p>The <strong>Tagged Image File Format</strong> (<strong>TIFF</strong>) is the most common geospatial raster format. The TIFF format's flexible tagging system allows it to store any type of data whatsoever in a single file. TIFFs can contain overview images, multiple bands, integer elevation data, basic metadata, internal compression, and a variety of other data that's typically stored in additional supporting files by other formats. Anyone can extend the TIFF format unofficially by adding tagged data to the file structure. This extensibility has benefits and drawbacks. However, a TIFF file may work fine in one piece of software but fail when it's accessed in another because the two software packages implement the massive TIFF specification to different degrees. An old joke about TIFFs has a frustrating amount of truth to it: <strong>TIFF</strong> stands for <strong>Thousands of Incompatible File Formats</strong>. The GeoTIFF extension defines how geospatial data is stored. Geospatial rasters stored as TIFF files may have any of the following file extensions: <kbd>.tiff</kbd>, <kbd>.tif</kbd>, or <kbd>.gtif</kbd>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">JPEG, GIF, BMP, and PNG</h1>
                
            
            
                
<p>JPEG, GIF, BMP, and PNG formats are common image formats in general, but can be used for basic geospatial data storage as well. Typically, these formats rely on accompanying the supporting text files for the georeferencing of the information in order to make them compatible with the GIS software, such as WKT, <kbd>.prj</kbd>, or world files.</p>
<p>The JPEG format is also fairly common for geospatial data. JPEGs have a built-in metadata tagging system, similar to TIFFs, called EXIF. JPEGs are commonly used for geotagged photographs in addition to raster GIS layers. <strong>Bitmap</strong> (<strong>BMP</strong>) images are used for desktop applications and document graphics. However, JPEG, GIF, and PNG are the formats that are used in web mapping applications, especially for pregenerated server map tiles for quick access via slippy maps.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Compressed formats</h1>
                
            
            
                
<p>Since geospatial rasters tend to be very large, they are often stored using advanced compression techniques. The latest open standard is the JPEG 2000 format, which is an upgrade of the JPEG format and includes wavelet compression and a few other features, such as georeferencing data. The <strong>Multi-resolution Seamless Image Database</strong> (<strong>MrSID</strong>) (<kbd>.sid</kbd>) and <strong>Enhanced Compression Wavelet</strong> (<strong>ECW</strong>) (<kbd>.ecw</kbd>) are two proprietary wavelet compression formats often seen in geospatial contexts.</p>
<p>The TIFF format supports compression, including the <strong>Lempel-Ziv-Welch</strong> (<strong>LZW</strong>) algorithm. It must be noted that compressed data is suitable as part of a basemap, but should not be used for remote sensing processing. Compressed images are designed to look visually correct but often alter the original cell value. Lossless compression algorithms try to avoid degrading the source data, but it's generally considered a bad idea to attempt to perform spectral analysis on data that has been through compression. The JPEG format is designed to be a lossy format that sacrifices data for a smaller file size. It is also commonly encountered, so it is important to remember this fact to avoid invalid results.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">ASCII Grids</h1>
                
            
            
                
<p>Another means of storing raster data, often elevation data, is in ASCII Grid files. This file format was created by Esri, but has become an unofficial standard supported by most software packages. An ASCII Grid is a simple text file containing (<em>x</em>, <em>y</em>) values as rows and columns. The spatial information for the raster is contained in a simple header. The format of the file is as follows:</p>
<pre>&lt;NCOLS xxx&gt; 
&lt;NROWS xxx&gt; 
&lt;XLLCENTER xxx | XLLCORNER xxx&gt; 
&lt;YLLCENTER xxx | YLLCORNER xxx&gt; 
&lt;CELLSIZE xxx&gt; 
{NODATA_VALUE xxx} 
row 1 
row 2 
. 
. 
. 
row n </pre>
<p>While not the most efficient way to store data, ASCII Grid files are very popular because they don't require any special data libraries to create or access geospatial raster data. These files are often distributed as <kbd>.zip</kbd> files. The header values in the preceding format contain the following information:</p>
<ul>
<li>The number of columns</li>
<li>The number of rows</li>
<li>The <em>x</em>-axis cell center coordinate | <em>x</em>-axis lower-left corner coordinate</li>
<li>The <em>y</em>-axis cell center coordinate | <em>y</em>-axis lower-left corner coordinate</li>
<li>The cell size in mapping units</li>
<li>The no-data value (typically, 9,999)</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">World files</h1>
                
            
            
                
<p>World files are simple text files that can provide geospatial referencing information to any image externally for file formats that typically have no native support for spatial information, including JPEG, GIF, PNG, and BMP. The world file is recognized by geospatial software due to its naming convention. The most common way to name a world file is by using the raster file name and then altering the extension to remove the middle letter and adding <kbd>w</kbd> at the end.</p>
<p>The following table shows some examples of raster images in different formats and the associated world file name based on the convention:</p>
<table style="border-collapse: collapse;width: 90%" border="1">
<tbody>
<tr>
<td>
<p>Raster file name</p>
</td>
<td>
<p>World file name</p>
</td>
</tr>
<tr>
<td>
<p><kbd>World.jpg</kbd></p>
</td>
<td>
<p><kbd>World.jgw</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>World.tif</kbd></p>
</td>
<td>
<p><kbd>World.tfw</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>World.bmp</kbd></p>
</td>
<td>
<p><kbd>World.bpw</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>World.png</kbd></p>
</td>
<td>
<p><kbd>World.pgw</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>World.gif</kbd></p>
</td>
<td>
<p><kbd>World.gfw</kbd></p>
</td>
</tr>
</tbody>
</table>
<div><p> </p>
<p>The structure of a world file is very simple. It is a six-line text file, as follows:</p>
<ul>
<li>Line 1: The cell size along the <em>x</em>-axis in ground units</li>
<li>Line 2: The rotation on the <em>y</em>-axis</li>
<li>Line 3: The rotation on the <em>x</em>-axis</li>
<li>Line 4: The cell size along the <em>y</em>-axis in ground units</li>
<li>Line 5: The center <em>x</em>-coordinate of the upper-left cell</li>
<li>Line 6: The center <em>y</em>-coordinate of the upper-left cell</li>
</ul>
<p>The following is an example of world file values:</p>
<pre>15.0 
0.0 
0.0 
-15.0 
-89,38 
45.0 </pre>
<p>The (<em>x</em>, <em>y</em>) coordinates and the (<em>x</em>, <em>y</em>) cell size contained in lines 1, 4, 5, and 6 allow you to calculate the coordinate of any cell or the distance across a set of cells. The rotation values are important for geospatial software because remotely sensed images are often rotated due to the data collection platform.</p>
<p>Rotating the images runs the risk of resampling the data and, therefore, data loss, so the rotation values allow the software to account for the distortion. The surrounding pixels outside the image are typically assigned a <kbd>no data</kbd> value and represented as the color black.</p>
<p>The following image, courtesy of the <strong>U.S. Geological Survey</strong> (<strong>USGS</strong>) from <a href="https://viewer.nationalmap.gov/advanced-viewer/">https://viewer.nationalmap.gov/advanced-viewer/</a>, demonstrates image rotation, where the satellite collection path is oriented from southeast to northeast, but the underlying basemap is north:</p>
<div><img src="img/5827a80b-d807-473f-b890-10df982a5080.png" style="width:36.75em;height:42.67em;" width="515" height="598"/></div>
<p>World files are a great tool when working with raster data in Python. Most geospatial software and data libraries support world files, so they are usually a good choice when it comes to georeferencing.</p>
<p>You'll find that world files are very useful, but as you use them infrequently, you will forget what the unlabeled contents represent. A quick reference for world files is available at <a href="http://kralidis.ca/gis/worldfile.htm">https://kralidis.ca/gis/worldfile.htm</a>.</p>
<p>Vector data and raster data are the two most common data types. However, there is another type that is gaining popularity due to the cost of collecting it gradually becoming cheaper. That type is point cloud data, and we'll examine it next.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">What is point cloud data?</h1>
                
            
            
                
<p>Point cloud data is any data collected as the (<em>x</em>, <em>y</em>, <em>z</em>) location of a surface point based on some sort of focused energy return. This can be created using lasers, radar waves, acoustic soundings, or other waveform generation devices. The spacing between points is arbitrary and dependent on the type and position of the sensor collecting the data.</p>
<p>In this book, we will primarily be concerned with LIDAR data and radar data. Radar point cloud data is typically collected on space missions, while LIDAR is typically collected by terrestrial or airborne vehicles. Conceptually, both types of data are similar.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">LIDAR</h1>
                
            
            
                
<p>LIDAR uses powerful laser range-finding systems to model the world with very high precision. The term <strong>LIDAR</strong>, or LiDAR, is a combination of the words <em>light</em> and <em>radar</em>. Some people claim it also stands for <strong>Light Detection and Ranging</strong>. LIDAR sensors can be mounted on aerial platforms, including satellites, airplanes, or helicopters. They can also be mounted on vehicles for ground-based collection.</p>
<p>Due to the high-speed, continuous data collection provided by LIDAR, and a wide field of view – often 360 degrees of the sensor – LIDAR data doesn't typically have a rectangular footprint the way other forms of raster data do. LIDAR datasets are usually called point clouds because the data is a stream of <em>(x,y,z</em>) locations, where <em>z</em> is the distance from the laser to a detected object and the (<em>x</em>,<em>y</em>) values are the projected location of the object calculated from the location of the sensor.</p>
<p>The following image, courtesy of USGS, shows a point cloud LIDAR dataset in an urban area using a terrestrial sensor, as opposed to an aerial one. The colors are based on the strength of the laser's energy return, with red areas being closer to the LIDAR sensor and green areas farther away, which can give a precise height to within a few centimeters:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/cfdac61c-49f8-41cb-bf3d-a9733d879a9a.png" style="width:33.92em;height:20.17em;" width="619" height="368"/></p>
<p>The most common data format for LIDAR data is the <strong>LIDAR Exchange Format</strong> (<strong>LAS</strong>), which is a community standard. LIDAR data can be represented in many ways, including a simple text file with one (<em>x</em>, <em>y</em>, <em>z</em>) tuple per line. Sometimes, LIDAR data can be colorized using image pixel colors that have been collected at the same time. LIDAR data can also be used to create 2D elevation rasters.</p>
<p>This technique is the most common use for LIDAR in geospatial analysis. Any other use requires specialized software that allows the user to work in 3D. In that case, other geospatial data cannot be combined with the point cloud.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">What are web services?</h1>
                
            
            
                
<p>Geospatial web services allow users to perform data discovery, data visualization, and data access across the web. Web services are usually accessed by applications based on user input, such as zooming in to an online map or searching a data catalog. The most common protocols are the <strong>Web Map Service</strong> (<strong>WMS</strong>), which returns a rendered map image, and <strong>Web Feature Service</strong> (<strong>WFS</strong>), which typically returns GML, which was mentioned in this chapter's introduction.</p>
<p class="mce-root"/>
<p>Many WFS services can also return KML, JSON, zipped shapefiles, and other formats. These services are called through HTTP <kbd>GET</kbd> requests. The following URL is an example of a WMS <kbd>GET</kbd> request, which returns a map image of the world that is 640 pixels wide and 400 pixels tall and has an EPSG code of 900913: <a href="http://ows.mundialis.de/services/service?SERVICE=wms&amp;VERSION=1.1.1&amp;REQUEST=GetMap&amp;FORMAT=image/png&amp;STYLES=&amp;WIDTH=600&amp;HEIGHT=400&amp;LAYERS=TOPO-OSM-WMS&amp;SRS=EPSG:900913&amp;BBOX=-20037508,-20037508,20037508,20037508">http://ows.mundialis.de/services/service?SERVICE=wms&amp;VERSION=1.1.1&amp;REQUEST=GetMap&amp;FORMAT=image/png&amp;STYLES=&amp;WIDTH=600&amp;HEIGHT=400&amp;LAYERS=TOPO-OSM-WMS&amp;SRS=EPSG:900913&amp;BBOX=-20037508,-20037508,20037508,20037508</a>.<a href="http://osm.woc.noaa.gov/mapcache?SERVICE=wms&amp;VERSION=1.1.1&amp;REQUEST=GetMap&amp;FORMAT=image/png&amp;WIDTH=600&amp;HEIGHT=400&amp;LAYERS=osm&amp;SRS=EPSG:900913&amp;BBOX=-20037508,-20037508,20037508,20037508"><br/></a></p>
<p>Web services are rapidly evolving. The Open GIS Consortium is adding new standards for sensor networks and other geospatial contexts. <strong>REpresentational State Transfer</strong> (<strong>REST</strong>) services are also commonly used. REST services use simple URLs to make requesting data very easy to implement in nearly any programming language by tailoring URL parameters and their values accordingly. Nearly every programming language has robust HTTP client libraries that are capable of using REST services.</p>
<p>These REST services can return many types of data, including images, XML, or JSON. There is no overarching geospatial REST standard yet, but the OGC has been working on one for quite some time. Esri has created a working implementation that is currently widely used.</p>
<p>The following URL is an example of an Esri geospatial REST service that would return KML based on a weather radar image layer. You can add this URL to Google Earth as a network link, or you can download it as compressed KML (KMZ) in a browser to import it into another program: <a href="https://idpgis.ncep.noaa.gov/arcgis/rest/services/NWS_Observations/radar_base_reflectivity/MapServer/generateKml?docName=NWSRadar&amp;layers=0&amp;layerOptions=separateImage">https://idpgis.ncep.noaa.gov/arcgis/rest/services/NWS_Observations/radar_base_reflectivity/MapServer/generateKml?docName=NWSRadar&amp;layers=0&amp;layerOptions=separateImage</a>.<br/>
<br/>
You can find tutorials on the myriad of OGC services here: <a href="http://cite.opengeospatial.org/pub/cite/files/edu/fundamental-concepts/text/basic.html">http://cite.opengeospatial.org/pub/cite/files/edu/fundamental-concepts/text/basic.html</a>.</p>
<p>At the time of writing this book, the OGC is going through an API evolution that will significantly lower the barrier of using geospatial APIs through technologies such as REST, OpenAPI, JSON/HTML, and Swagger. You can track these trends through OGC's technology roadmap here: <a href="https://github.com/opengeospatial/OGC-Technology-Trends">https://github.com/opengeospatial/OGC-Technology-Trends</a>.</p>
<p>Now, we'll move from individual file formats to powerful geodatabases that can consolidate data through a single API.</p>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Understanding geospatial databases</h1>
                
            
            
                
<p>A geospatial database, or geodatabase, refers to an entire category of file formats, data schemas, and even software. In <a href="a5e439d1-e7fd-46b4-8fd3-8f811bfe73e4.xhtml" target="_blank">Chapter 3</a>, <em>The Geospatial Technology Landscape</em>, we'll cover geodatabases as software packages, formally known as database management systems. But in this section, we'll describe their attributes as file formats. Geodatabases historically stored only vector data, though modern geodatabases are well-suited for raster data management as well.</p>
<p>Geodatabases can exhibit all of the common traits we noted previously. This information is stored in the database in what we call the database model. A very popular model is the traditional relational model, which uses tables of rows and columns. Each row and column combination is called a cell. Rows can be related to another table to link information using a designated column where each cell becomes a key referencing a cell in another table that then links the rows together.</p>
<p>The actual names of the columns and the relationships among data constitute the data definition. At a minimum, geodatabases associate a geometry description with attributes about the object the geometry represents. Single points are often represented by <kbd>x</kbd> and <kbd>y</kbd> columns. However, polygons and polylines have arbitrary numbers of points. This means that geodatabases often store geometry information as a <strong>BLOB</strong> using a format standard known as <strong>Well-Known Binary</strong>, or <strong>WKB</strong>.</p>
<p>The attribute information is usually defined as data types such as integers, floating-point decimal numbers, strings, or dates. The table may also include projection information for map display, as well as a spatial indexing column to speed up searching and geospatial comparisons. A geodatabase may also have another related table in order to link detailed metadata about the geospatial data.</p>
<p>Large geospatial raster datasets are rarely stored directly in the database. Typically, the raster data is stored on disk with a name, and a filesystem reference is stored in the database that points to the raster data. A geodatabase may also store a geometry column representing the ground footprint of the raster data, which can then be used as a proxy for geospatial operations.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>You now have the background needed to work with common types of geospatial data. You also know about the common traits of geospatial datasets that will allow you to evaluate unfamiliar types of data and identify key elements that will drive you toward which tools to use when interacting with this data.</p>
<p>In the next chapter, we'll examine the modules and libraries that you can use to work with geospatial datasets. We will learn about the geospatial technology ecosystem, which consists of thousands of software libraries and packages. We will also understand the hierarchy of geospatial software and how it allows you to quickly comprehend and evaluate any geospatial tool.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Further reading</h1>
                
            
            
                
<p>You can find tutorials on the myriad of OGC services here: <a href="http://cite.opengeospatial.org/pub/cite/files/edu/fundamental-concepts/text/basic.html">http://cite.opengeospatial.org/pub/cite/files/edu/fundamental-concepts/text/basic.html</a><a href="http://www.ogcnetwork.net/tutorials">.</a></p>


            

            
        
    </div>



  </body></html>