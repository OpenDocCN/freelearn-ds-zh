- en: Chapter 8. Inside R
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。R内部
- en: In the previous chapters, you learned the basics of R programming language,
    and understood the usage of vectors, matrices, lists, and data frames to represent
    data in different shapes. You also saw how we can use the built-in functions to
    solve simple problems. However, simply knowing these features does not help you
    solve every problem. Real-world data analysis usually involves careful and detailed
    transformation and aggregation of data, which can be done with a good variety
    of functions, whether they are built-in or provided by extension packages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了R编程语言的基础知识，了解了如何使用向量、矩阵、列表和数据框以不同的形状表示数据。你也看到了我们如何使用内置函数来解决简单问题。然而，仅仅了解这些特性并不能帮助你解决每一个问题。现实世界的数据分析通常涉及对数据进行仔细和详细地转换和聚合，这可以通过各种函数来完成，无论是内置的还是由扩展包提供的。
- en: 'To best use these functions rather than let them confuse you with unexpected
    results, you need a basic but concrete understanding of how R functions work.
    In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最好地使用这些函数而不是让它们因意外结果而让你困惑，你需要对R函数的工作方式有一个基本但具体的理解。在本章中，我们将涵盖以下主题：
- en: Lazy evaluation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 惰性求值
- en: Copy-on-modify mechanism
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制修改机制
- en: Lexical scoping
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 词法作用域
- en: Environments
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境
- en: If you understand these concepts and their roles in the code, most R code should
    appear highly predictable to you, which means higher productivity in both finding
    bugs and writing properly functional code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你理解了这些概念及其在代码中的作用，大多数R代码应该对你来说非常可预测，这意味着在查找错误和编写正确功能的代码方面有更高的生产力。
- en: Understanding lazy evaluation
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解惰性求值
- en: 'A big part of understanding how R works can be done by figuring out how R functions
    work. After going through the previous chapters, you should know the most commonly
    used basic functions. However, you may still be confused about their exact behavior.
    Suppose we create the following function:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 理解R语言的工作原理很大一部分可以通过弄清楚R函数的工作方式来实现。在阅读了前面的章节之后，你应该已经了解了最常用的基本函数。然而，你可能仍然对它们的精确行为感到困惑。假设我们创建以下函数：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The function is somewhat special because `y` seems to be needed only when `x`
    is greater than zero. What if we only supply a positive number to `x` and ignore `y`?
    Will the function fail because we don''t supply every argument in its definition?
    Let''s find out by calling the following function:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 函数有些特殊，因为`y`似乎只在`x`大于零时才需要。如果我们只为`x`提供一个正数而忽略`y`，函数会因为我们没有提供定义中的所有参数而失败吗？让我们通过调用以下函数来找出答案：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The function works without `y` being supplied. It looks like we are not required
    to supply the values to all arguments when we call a function but only to those
    that are needed. If we call `test0` with a negative number, `y` is needed:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 函数在没有提供`y`的情况下也能正常工作。看起来当我们调用一个函数时，我们不需要为所有参数提供值，而只需要为那些需要的参数提供值。如果我们用负数调用`test0`，则需要`y`：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Since we did not specify the value of `y`, the function stopped, reporting that `y`
    is missing.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有指定`y`的值，函数停止了，报告说`y`缺失。
- en: 'From the preceding examples, you learn that a function does not require all
    arguments to be specified if they are not needed to return a value. What if we
    insist on specifying those arguments that are not used in the function? Will they
    be evaluated before we call the function or not evaluated at all? Let''s find
    out by putting a `stop()` function in the position of argument `y`. If the expression
    is evaluated by any means somewhere, it should stop immediately before `x` is
    returned:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的例子中，你了解到如果一个函数不需要所有参数来返回值，那么它不需要指定所有参数。如果我们坚持指定那些在函数中未使用的参数，它们会在我们调用函数之前被评估，或者根本不会被评估？让我们通过在参数`y`的位置放置一个`stop()`函数来找出答案。如果表达式以任何方式在任何地方被评估，它应该在`x`返回之前立即停止：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output indicates that `stop()` does not happen, which indicates that it
    is not evaluated at all. If we change the value of `x` to a negative number, the
    function should stop instead:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 输出表明`stop()`没有发生，这表明它根本就没有被评估。如果我们将`x`的值改为负数，函数应该停止执行：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, it is very clear that `stop()` is evaluated in this case. The mechanism
    becomes quite transparent. In a function call, the expression of an argument is
    evaluated only when the value of the argument is needed. This mechanism is called **lazy
    evaluation**, and therefore, we can also say that the arguments of a function
    call are lazily evaluated, that is, evaluated only when needed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，很明显，在这种情况下`stop()`被评估了。机制变得相当透明。在函数调用中，只有当需要参数的值时，才会评估参数的表达式。这种机制被称为**惰性求值**，因此，我们也可以说函数调用的参数是惰性求值的，即只在需要时评估。
- en: 'If you are not aware of the lazy evaluation mechanism, you may think that the
    following function call must be extremely time consuming and may exhaust all your
    computer memory. However, lazy evaluation prevents it from happening because `rnorm(1000000)`
    is never evaluated. This is because it is never needed when evaluating `if (x
    > 0) x else y`, which can be verified by timing the function calls in turn using `system.time()`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道惰性求值机制，你可能会认为以下函数调用将非常耗时，并且可能会耗尽你的所有计算机内存。然而，惰性求值阻止了这种情况的发生，因为`rnorm(1000000)`永远不会被评估。这是因为当评估`if
    (x > 0) x else y`时，它永远不会被需要，这可以通过使用`system.time()`依次计时函数调用来验证：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Generating 10 million random numbers is not an easy job. It takes more than
    a second. By contrast, evaluating a number should be the easiest thing R can do,
    and it is so fast that the timer itself can''t tell:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 生成一千万个随机数不是一件容易的事情。它需要超过一秒钟。相比之下，评估一个数字应该是R能做的最容易的事情，而且它非常快，以至于计时器本身都无法感知：
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we time the following expression, given the logic of `test0` and the knowledge
    of lazy evaluation, at an educated guess it should be zero:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们根据`test0`的逻辑和惰性求值的了解来计时以下表达式，那么根据合理的猜测，它应该是零：
- en: '[PRE7]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Another lazy evaluation scenario that could happen is the default values of
    arguments. More precisely, the default values of function arguments should really
    be default expressions because the value is not available until the expression
    is actually evaluated. Consider the following function:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能发生的惰性求值场景是参数的默认值。更准确地说，函数参数的默认值应该真正是默认表达式，因为值只有在表达式实际评估时才可用。考虑以下函数：
- en: '[PRE8]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We give `y` a default value that calls `stop()`. If lazy evaluation does not
    apply here, that is, if `y` is evaluated irrespective of whether it is needed,
    we should receive an error as long as we call `test1()` without supplying `y`.
    However, if lazy evaluation applies, calling `test1()` with a positive `x` argument
    should not cause an error since the `stop()` expression of `y` is never evaluated.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给`y`一个默认值，该值调用`stop()`。如果惰性求值不适用，即无论是否需要，`y`都会被评估，那么只要我们不提供`y`就调用`test1()`，我们应该收到一个错误。然而，如果惰性求值适用，使用正数`x`参数调用`test1()`不应该导致错误，因为`y`的`stop()`表达式永远不会被评估。
- en: 'Let''s do an experiment to find out which is true. First, we will call `test1()`
    with a positive `x argument`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一个实验来找出哪个是正确的。首先，我们将使用正数`x`参数调用`test1()`：
- en: '[PRE9]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output implies that lazy evaluation also works here. The function only
    uses `x`, and the default expression of `y` is not evaluated at all. If we supply
    a negative `x` argument instead, the function should stop as supposed:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 输出表明惰性求值在这里也起作用。函数只使用`x`，而`y`的默认表达式根本不会被评估。如果我们提供一个负数的`x`参数，函数应该像预期的那样停止：
- en: '[PRE10]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding examples demonstrate an advantage of lazy evaluation: it makes
    it possible to save time and avoid unnecessary evaluation of expressions. Besides,
    it also allows more flexible specification of default values of function arguments.
    For example, you can use other arguments in the expression of a function argument:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例展示了惰性求值的一个优点：它使得节省时间和避免不必要的表达式评估成为可能。此外，它还允许更灵活地指定函数参数的默认值。例如，你可以在函数参数的表达式中使用其他参数：
- en: '[PRE11]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This allows you to set up the default behavior of a function in a more reasonable
    or desirable way, while the function arguments are still as customizable as they
    were without those default values.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你以更合理或更期望的方式设置函数的默认行为，同时函数参数仍然可以像没有这些默认值一样进行自定义。
- en: 'If we call `test2` without specifying `n`, the default behavior takes out the
    first half elements of `x`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不指定`n`就调用`test2`，默认行为会取出`x`的前半部分元素：
- en: '[PRE12]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The function remains flexible because you can always override its default behavior
    by specifying another value of `n`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 函数保持灵活，因为你总是可以通过指定另一个`n`的值来覆盖其默认行为：
- en: '[PRE13]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Like all other features, lazy evaluation also has its pros and cons. Since the
    arguments of a function are only parsed but not evaluated when the function is
    called, we can only make sure that the expressions supplied to the arguments are
    syntactically correct. It is hard to ensure that the arguments are going to work.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 就像所有其他特性一样，惰性求值也有其优缺点。由于函数的参数在函数调用时只进行解析而不进行求值，我们只能确保提供给参数的表达式在语法上是正确的。很难确保参数将按预期工作。
- en: For example, if an undefined variable appears in the default value of an argument,
    there will be no warning or error the moment we create the function. In the following
    example, we create a `test3` function, which is exactly the same as `test2`, except
    that `x` in `n` is mistakenly written as an undefined variable `m`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果默认值中出现未定义的变量，则在创建函数时不会出现警告或错误。在以下示例中，我们创建了一个`test3`函数，它与`test2`完全相同，除了`n`中的`x`被错误地写成了未定义的变量`m`。
- en: '[PRE14]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When we create `test3`, there''s no warning or error because `floor(length(m)
    / 2)` is never evaluated before `test3` is called, and the value of `n` is demanded
    by `1:n`. The function will stop only when we actually call it:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建`test3`时，没有警告或错误，因为`floor(length(m) / 2)`在调用`test3`之前从未被求值，而`n`的值是由`1:n`要求的。函数只有在实际调用时才会停止：
- en: '[PRE15]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we have `m` defined before `test3` is called, the function works, but in
    an unexpected way:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在调用`test3`之前定义了`m`，函数将正常工作，但方式出乎意料：
- en: '[PRE16]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Another example that makes how lazy evaluation works more explicit is as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个使惰性求值的工作方式更加明确的例子如下：
- en: '[PRE17]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that the default value of `y` is `p`, which is not defined before the function
    is called, just like the previous example. A notable difference between these
    two examples is when the missing symbol in the default value of the second argument
    is supplied. In the previous example, `p` is defined before the function is called.
    However, in this example, `p` is defined inside the function before `y` is used.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`y`的默认值是`p`，这与之前的例子一样，在函数调用之前没有定义。这两个例子之间的一个显著区别是，第二个参数默认值中缺失的符号何时被提供。在之前的例子中，`p`在函数调用之前被定义。然而，在这个例子中，`p`是在函数内部定义的，在`y`被使用之前。
- en: 'Let''s see what happens when we call the function:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看调用函数时会发生什么：
- en: '[PRE18]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It looks like the function works rather than ending up in an error. It will
    become easier to understand if we go through the detailed process of how `test4(1)`
    is executed:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来函数是正常工作的，而不是导致错误。如果我们通过`test4(1)`的执行详细过程来分析，这将更容易理解：
- en: Find a function named `test4`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到一个名为`test4`的函数。
- en: Match the given arguments, but both `x` and `y` are unevaluated.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 匹配给定的参数，但`x`和`y`都没有被求值。
- en: '`p <- x + 1` evaluates `x + 1` and assigns the value to a new variable `p`.'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`p <- x + 1`求值`x + 1`并将值赋给新变量`p`。'
- en: '`c(x, y)` evaluates both `x` and `y`, where `x` takes `1` and `y` takes `p`,
    which just happens to get the value of `x + 1`, which is `2`.'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`c(x, y)`求值`x`和`y`，其中`x`取值为`1`，`y`取值为`p`，恰好得到`x + 1`的值，即`2`。'
- en: The function returns a numeric vector `c(1, 2)`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数返回一个数值向量`c(1, 2)`。
- en: Therefore, in the whole evaluation process of `test4(1)`, no warning or error
    occurs because no rules are violated. The most important trick here is that `p`
    is just defined before `y` is used.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在整个`test4(1)`的评估过程中，没有出现警告或错误，因为没有违反任何规则。这里最重要的技巧是`p`的定义是在使用`y`之前。
- en: The preceding example helps exaplain how lazy evaluation works, but it is indeed
    a bad practice. I won't recommend writing a function in this way because such
    a trick only makes the behavior of the function less transparent. A good practice
    is to simplify the arguments and avoid using undefined symbols outside the function.
    Otherwise, it can be hard to predict its behavior or debug the function due to
    its dependency on the outer environment.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 上述例子有助于解释惰性求值的工作方式，但这确实是一种不良实践。我不会推荐以这种方式编写函数，因为这种技巧只会使函数的行为更不透明。一种好的做法是简化参数，并避免在函数外部使用未定义的符号。否则，由于其对外部环境的依赖，可能会很难预测其行为或调试函数。
- en: 'Despite this, there is some wise use of lazy evaluation too. For example, `stop()`
    can be used along with `switch()` in the last argument to make the function stop
    when no cases are matched. The following function `check_input()` uses `switch()`
    to regulate the input of `x` so that it only accepts `y` or `n` and stops when
    other strings are supplied:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，也有一些明智地使用懒加载的情况。例如，`stop()`可以与`switch()`一起在最后一个参数中使用，以便在没有匹配到任何情况时停止函数。以下函数`check_input()`使用`switch()`来规范`x`的输入，使其只接受`y`或`n`，并在提供其他字符串时停止：
- en: '[PRE19]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When `x` takes `y`, a message saying `yes` shows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当`x`取`y`时，显示一条消息说`yes`：
- en: '[PRE20]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When `x` takes `n`, a message saying `no` shows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当`x`取`n`时，显示一条消息说`no`：
- en: '[PRE21]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Otherwise, the function stops:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，函数停止：
- en: '[PRE22]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The example works because `stop()` is lazily evaluated as an argument of `switch()`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子之所以有效，是因为`stop()`作为`switch()`的一个参数被懒加载评估。
- en: As a summary of the examples, the reminder here is that you cannot rely too
    much on the parser to check the code. It only checks the code in its syntax, and
    it does not tell you whether the code is written with good practice. To avoid
    the potential pitfalls caused by lazy evaluation, do necessary checking in the
    function to make sure that the input can be handled correctly.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这些例子的总结，这里提醒的是，你不能过分依赖解析器来检查代码。它只检查代码的语法，并且不会告诉你代码是否编写得很好。为了避免懒加载可能引起的潜在陷阱，在函数中进行必要的检查，以确保可以正确处理输入。
- en: Understanding the copy-on-modify mechanism
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解复制修改机制
- en: 'In the previous section, we showed how lazy evaluation works and how it may
    help save computing time and working memory by avoiding unnecessary evaluation
    of function arguments. In this section, I will show you an important feature of
    R that makes it safer to work with data. Suppose we create a simple numeric vector
    `x1`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们展示了懒加载评估的工作原理以及它如何通过避免不必要的函数参数评估来节省计算时间和工作内存。在本节中，我将向您展示R的一个重要特性，这使得处理数据更加安全。假设我们创建一个简单的数值向量`x1`：
- en: '[PRE23]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, we assign the value of `x1` to `x2`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将`x1`的值赋给`x2`：
- en: '[PRE24]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, `x1` and `x2` have exactly the same value. What if we modify an element
    in one of the two vectors? Will both vectors change?
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`x1`和`x2`具有完全相同的值。如果我们修改两个向量中的一个元素会发生什么？两个向量都会改变吗？
- en: '[PRE25]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The output shows that when `x1` is changed, `x2` will remain unchanged. You
    may guess that the assignment automatically copies the value and makes the new
    variable point to the copy of the data instead of the original data. Let's use `tracemem()` to
    track the footprint of the data in memory.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示，当`x1`被修改时，`x2`将保持不变。你可能猜测赋值会自动复制值并使新变量指向数据的副本而不是原始数据。让我们使用`tracemem()`来跟踪数据在内存中的足迹。
- en: 'Let''s reset the vectors and conduct an experiment by tracing the memory addresses
    of `x1` and `x2`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重置向量并通过跟踪`x1`和`x2`的内存地址来进行实验：
- en: '[PRE26]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As we call `tracemem()` on the two vectors, it shows the current memory address
    of the data. If the memory address being traced changes, a text will show up with
    the original address and the new address, indicating that the data is copied:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对两个向量调用`tracemem()`时，它显示了数据的当前内存地址。如果被跟踪的内存地址发生变化，将显示一个文本，其中包含原始地址和新地址，表明数据已被复制：
- en: '[PRE27]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, both vectors have the same value, and `x1` and `x2` share the same address,
    which implies that they point to exactly the same piece of data in memory and
    that the assignment operation does not copy the data automatically. But when is
    the data copied?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，两个向量具有相同的值，`x1`和`x2`共享相同的地址，这意味着它们指向内存中完全相同的同一块数据，并且赋值操作不会自动复制数据。但是数据何时被复制？
- en: 'Now, we will modify the first element of `x1` to `0`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将`x1`的第一个元素修改为`0`：
- en: '[PRE28]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The memory tracing says that the address of `x1` has changed to a new one. More
    specifically, the piece of memory, that is, the original vector both `x1` and
    `x2` point to is copied to a new location. Now we have two copies of the same
    data in two different locations. Then, the first element of the copy is modified,
    and finally, `x1` is made to point to the modified copy.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 内存跟踪显示`x1`的地址已更改为一个新的地址。更具体地说，原始向量`x1`和`x2`所指向的那块内存被复制到了一个新的位置。现在我们在两个不同的位置有了相同数据的两个副本。然后，修改副本的第一个元素，最后，使`x1`指向修改后的副本。
- en: Now, `x1` and `x2` have different values: `x1` points to the modified vector
    and `x2` remains pointing to the original vector.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`x1`和`x2`有不同的值：`x1`指向修改后的向量，而`x2`仍然指向原始向量。
- en: In other words, if multiple variables refer to the same object, modifying one
    variable will make a copy of the object. This mechanism is called **copy-on-modify**.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果多个变量引用同一个对象，修改一个变量将导致对象的复制。这种机制被称为 **复制修改**。
- en: 'Another scenario where copy-on-modify happens is when we modify a function
    argument. Suppose we create the following function:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 复制修改机制发生的另一个场景是在修改函数参数时。假设我们创建以下函数：
- en: '[PRE29]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When the function is executed, it attempts to modify the first element of argument
    `x`. Let's do some experiments with vectors and lists and see whether `modify_first()`
    can modify them.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数执行时，它试图修改参数 `x` 的第一个元素。让我们通过向量和列表做一些实验，看看 `modify_first()` 是否可以修改它们。
- en: 'For a number vector `v1`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个数字向量 `v1`：
- en: '[PRE30]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For a list `v2`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个列表 `v2`：
- en: '[PRE31]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In both experiments, the function only returned a modified version of the original
    object, but it did not modify the original object. However, directly modifying
    the vectors outside the function works:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个实验中，函数只返回了原始对象的修改版本，但没有修改原始对象。然而，在函数外部直接修改向量是有效的：
- en: '[PRE32]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To use the modified version, we need to assign it to the original variable:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用修改后的版本，我们需要将其分配给原始变量：
- en: '[PRE33]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The preceding examples demonstrate that modifying a function argument also causes
    a copy to make sure that the modification does not affect things outside the function.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子表明，修改函数参数也会导致复制，以确保修改不会影响函数外部的事物。
- en: 'The copy-on-modify mechanism also happens when the attributes are modified.
    The following function removes the row names of a data frame and replaces its
    column names with capital letters:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当修改属性时，复制修改机制也会发生。以下函数删除数据框的行名，并将其列名替换为大写字母：
- en: '[PRE34]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To test the function, we will create a simple data frame with randomly generated
    data:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试该函数，我们将创建一个具有随机生成数据的简单数据框：
- en: '[PRE35]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, we will call the function with the data frame and see the modified version:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用数据框调用该函数并查看修改后的版本：
- en: '[PRE36]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'According to the copy-on-modify mechanism, `small_df` is copied the first time
    when its row names are removed, and then, all subsequent changes are made to the
    copied version instead of the original version. We can verify this by viewing `small_df`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 根据复制修改机制，`small_df` 在其行名被移除时第一次被复制，然后，所有后续的更改都是对复制的版本而不是原始版本进行的。我们可以通过查看 `small_df`
    来验证这一点：
- en: '[PRE37]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The original version has not changed at all.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 原始版本没有任何变化。
- en: Modifying objects outside a function
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数外部的对象修改
- en: 'Despite the copy-on-modify mechanism, it is still possible to modify a vector
    outside a function. The `<<-` operator is designed to do the job. Suppose we have
    a variable `x` and create a function `modify_x()` that simply assigns a new value
    to `x`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有复制修改机制，仍然可以在函数外部修改一个向量。`<<-` 运算符被设计来执行这项任务。假设我们有一个变量 `x` 并创建一个函数 `modify_x()`，该函数简单地分配一个新的值给
    `x`：
- en: '[PRE38]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'When we call the function, the value of `x` will be replaced:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用函数时，`x` 的值将被替换：
- en: '[PRE39]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This can be useful when you try to map a vector to a new list and do some counting
    at the same time. The following code creates a list of vectors with an increasing
    number of elements. In each iteration of `lapply()`, `count` is used to sum up
    the total number of elements in the vector generated:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试将一个向量映射到一个新的列表并同时进行计数时，这可能会很有用。以下代码创建了一个具有递增元素数量的向量列表。在 `lapply()` 的每次迭代中，`count`
    用于计算生成的向量中元素的总数：
- en: '[PRE40]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Another example in which `<<-` is useful is to flatten a nested list. Suppose
    we have a nested list like the one shown here:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`<<-` 运算符有用的另一个例子是将嵌套列表展平。假设我们有一个像下面这样的嵌套列表：'
- en: '[PRE41]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We want to flatten the list so that the nested levels are all brought to the
    first level. The following code solves the problem using `rapply()` and `<<-`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将列表展平，使得嵌套的级别都提升到第一级。以下代码使用 `rapply()` 和 `<<-` 解决了这个问题：
- en: 'First, we need to know that `rapply()` is a recursive version of `lapply()`.
    In each iteration, the supplied function is called with an atomic vector at a
    particular level in the list until all atomic vectors at all levels are exhausted.
    Calling `rapply(nested_list, f)` basically runs in the following manner:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要知道 `rapply()` 是 `lapply()` 的递归版本。在每次迭代中，提供的函数都会在列表的特定级别上调用一个原子向量，直到所有级别的原子向量都耗尽。调用
    `rapply(nested_list, f)` 基本上按以下方式运行：
- en: '[PRE42]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Keep in mind, that we should work out a solution to flatten `nested_list`.
    The solution that we will discuss is inspired by a Stackoverflow answer ([http://stackoverflow.com/a/8139959/2906900](http://stackoverflow.com/a/8139959/2906900)),
    which smartly uses `rapply()`. First, we will create an empty list to receive
    individual vectors in the nested list and a counter:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们应该找出一个解决方案来扁平化`nested_list`。我们将讨论的解决方案受到了Stackoverflow答案（[http://stackoverflow.com/a/8139959/2906900](http://stackoverflow.com/a/8139959/2906900)）的启发，该答案巧妙地使用了`rapply()`。首先，我们将创建一个空列表来接收嵌套列表中的单个向量和一个计数器：
- en: '[PRE43]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, we will use `rapply()` to recursively apply a function to `nested_list`.
    In each iteration, the function receives an atomic vector in `nested_list` through `x`.
    The function sets the`i` ^(th) element of `flat_list` to `x` and increments the
    counter `i`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用`rapply()`递归地将函数应用于`nested_list`。在每次迭代中，函数通过`x`接收`nested_list`中的原子向量。函数将`flat_list`的第`i`个元素设置为`x`并增加计数器`i`：
- en: '[PRE44]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'With the iterations done, all atomic vectors are stored in `flat_list` at the
    first level. The value returned by `rapply()` is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代完成后，所有原子向量都存储在`flat_list`的第一级。`rapply()`返回的值如下：
- en: '[PRE45]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'As a result of `i <<- i + 1`, the values in `res` are of no much importance.
    However, the names of `res` are useful to indicate the original levels and names
    of each element in `flat_list`. So we let `flat_list` also have the names of `res`
    to indicate the origin of each element:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`i <<- i + 1`，`res`中的值并不重要。然而，`res`的名称对于指示`flat_list`中每个元素的原始级别和名称是有用的。因此，我们让`flat_list`也具有`res`的名称，以指示每个元素的来源：
- en: '[PRE46]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Finally, all elements in `nested_list` are stored in a flat way in `flat_list`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`nested_list`中的所有元素都以扁平的方式存储在`flat_list`中。
- en: Understanding lexical scoping
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解词法作用域
- en: In the previous section, we introduced the copy-on-modify mechanism. The examples
    demonstrated two cases in which this mechanism happens. When an object has multiple
    names or is passed as an argument to a function, modifying it will cause the object
    to be copied, and it is the copied version that is actually modified.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们介绍了复制修改机制。示例演示了这种机制发生的两种情况。当一个对象有多个名称或作为函数的参数传递时，修改它会导致对象被复制，并且实际上被修改的是复制的版本。
- en: To modify an object outside a function, we introduced the use of `<<-`, which
    finds the variable outside the function first and modifies that object instead
    of copying one locally. This leads to an important idea that a function has inside
    and outside. Inside a function, we can somehow refer to variables and functions
    outside.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改函数外部的对象，我们引入了`<<-`的使用，它会首先找到函数外部的变量并修改该对象，而不是复制一个局部对象。这引出了一个重要观点，即函数内部和外部。在函数内部，我们可以以某种方式引用外部变量和函数。
- en: 'For example, the following function uses two outside variables:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下函数使用了两个外部变量：
- en: '[PRE47]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We first create two variables and define a function called `fun1`. The function
    simply puts together `start_num`, argument `x`, and `end_num` into a new vector.
    It is clear that `start_num` and `end_num` are not defined in the function but
    outside it while `x` is the argument of the function. Let''s see if it works:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建两个变量并定义一个名为`fun1`的函数。该函数简单地将`start_num`、参数`x`和`end_num`组合成一个新的向量。很明显，`start_num`和`end_num`在函数外部定义，而`x`是函数的参数。让我们看看它是否工作：
- en: '[PRE48]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The function works by successfully getting the value of the two variables outside
    the function. You may guess that when we define the function, the values are captured
    so that `start_num` and `end_num` in `fun1` just take the values from outside.
    In fact, two experiments can be performed to prove it wrong.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数通过成功获取函数外部的两个变量的值来工作。你可能猜到，当我们定义函数时，值被捕获，所以`fun1`中的`start_num`和`end_num`只是从外部获取值。实际上，可以进行两个实验来证明它是错误的。
- en: 'The first experiment is simple. Let''s remove the two variables:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个实验很简单。让我们移除这两个变量：
- en: '[PRE49]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Then, the function does not work anymore. If the values of the two variables
    are captured when the function is defined, the removal of them should not paralyze
    the function.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，该函数不再工作。如果函数定义时捕获了两个变量的值，那么移除它们不应该使函数瘫痪。
- en: 'The second experiment is the other way around. Let''s remove the function as
    well as the two variables. We will first define the function:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个实验是相反的。让我们同时移除函数和两个变量。我们首先定义函数：
- en: '[PRE50]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If the creation of the function has to capture the two variables that are not
    present in it, the preceding code should result in an error saying `start_num`
    and `end_num` are missing. Clearly, there''s no error, and the function is successfully
    created. Let''s call it now:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数的创建必须捕获它内部不存在的两个变量，前面的代码应该会产生一个错误，指出`start_num`和`end_num`缺失。显然，没有错误，函数已经成功创建。现在让我们调用它：
- en: '[PRE51]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The function does not work because the two variables are not found. We will
    then define the two variables and again call the function with the same argument:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 函数无法工作是因为没有找到两个变量。然后我们将定义这两个变量，并再次使用相同的参数调用函数：
- en: '[PRE52]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The function works again. This leads to the conclusion that the function actually
    tries to look for the variables when it is called. Actually, during the execution
    of the function, when a symbol is encountered, it will first look for it inside
    the function. More specifically, if the symbol is passed in as an argument or
    created inside the function, the symbol will be resolved and its value is used.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 函数再次工作。这导致结论，函数实际上是在被调用时尝试寻找变量的。实际上，在函数执行过程中，当遇到一个符号时，它首先会在函数内部寻找。更具体地说，如果符号作为参数传入或在函数内部创建，符号将被解析并使用其值。
- en: 'Suppose we create a variable `p` first and then define a function `fun2` in
    which another `p` variable is created and used in the value to return:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们首先创建一个变量`p`，然后定义一个函数`fun2`，在这个函数中创建另一个`p`变量并用于返回值：
- en: '[PRE53]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: When we call the function, which `p` will `fun2` use in `x + p`? Let's find
    out;
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用函数时，`fun2`在`x + p`中将使用哪个`p`？让我们找出答案；
- en: '[PRE54]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The output makes it clear that `x + p` uses `p` defined inside the function.
    The flow is simple. First, `p <- 1` creates a new variable `p` with value `1`
    instead of changing `p` outside the function. Then, `x + p` is evaluated, with `x`
    being resolved as the passed-in argument and `p` as the local variable just defined.
    The rule is that only if a variable is not present inside the function will it
    be searched for outside.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 输出清楚地表明`x + p`使用了函数内部定义的`p`。流程很简单。首先，`p <- 1`创建了一个新的变量`p`，其值为`1`，而不是改变函数外部的`p`。然后，计算`x
    + p`，其中`x`被解析为传入的参数，`p`为刚刚定义的局部变量。规则是，只有当变量在函数内部不存在时，才会在外部搜索。
- en: 'However, what exactly does "outside" mean? The question is subtler than it
    appears to be. Suppose we create the following two functions:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，“外部”究竟是什么意思？这个问题比它看起来要微妙。假设我们创建了以下两个函数：
- en: '[PRE55]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The first function `f1` simply adds two variables: `x` is an argument and `p`
    is a variable yet to be found outside. The second function `g1` defines a `p`
    variable inside and calls `f1`. The question is, "Will `f1` find `p` inside `g1`
    when `g1` is called?"
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数`f1`简单地添加两个变量：`x`是一个参数，`p`是一个尚未在外部找到的变量。第二个函数`g1`在内部定义了一个`p`变量并调用了`f1`。问题是，“当`g1`被调用时，`f1`是否会在`g1`内部找到`p`？”
- en: '[PRE56]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Unfortunately, `f1` cannot find `p` inside `g1` even though `f1` is called
    in `g1`. If we define `p` and then call `g1` again, the function works:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，即使在`g1`中调用了`f1`，`f1`也无法在`g1`内部找到`p`。如果我们定义`p`然后再次调用`g1`，函数就能正常工作：
- en: '[PRE57]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: What made `g1` work is that when `f1` is called and `p` cannot be found inside `f1`,
    it will search where `f1` is defined instead of where it is called. This mechanism
    is called **lexical scoping**. In the preceding code, we defined `p` in the same
    scope where `f1` is defined. Then, `f1` can find `p` when it is called inside `g1`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使`g1`工作的是，当调用`f1`且在`f1`内部找不到`p`时，它会搜索`f1`的定义位置而不是调用位置。这种机制被称为**词法作用域**。在前面的代码中，我们在与`f1`定义相同的范围内定义了`p`。然后，当在`g1`内部调用`f1`时，`f1`可以找到`p`。
- en: 'The same scoping rule also applies to how `<<-` finds variables. For example,
    the following code defines a variable `m` and two functions, `f2` and `g2`, in
    the same scope. In `f2`, `m` is set to `2`. However, in `g2`, a local `m` variable
    is defined and then `f2` is called:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的作用域规则也适用于`<<-`如何查找变量。例如，以下代码在相同的作用域中定义了一个变量`m`和两个函数`f2`和`g2`。在`f2`中，`m`被设置为`2`。然而，在`g2`中，定义了一个局部变量`m`，然后调用了`f2`：
- en: '[PRE58]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'As soon as `f2` is called, the value of `m` in `g2` is printed. Let''s call `g2`
    and see what happens:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦调用`f2`，`g2`中的`m`的值就会被打印出来。让我们调用`g2`看看会发生什么：
- en: '[PRE59]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The printed text shows that the value of `m` in `g2` remains unchanged, but
    the value of `m` outside `f2` and `g2` is changed as can be verified:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 打印的文本显示，`g2`中的`m`的值保持不变，但`f2`和`g2`外部的`m`的值发生了变化，这可以通过验证得到：
- en: '[PRE60]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The preceding experiment confirms that `m <<- 2` follows the rule of lexical
    scoping.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的实验证实了`m <<- 2`遵循词法作用域的规则。
- en: 'The following two examples look even more complex. The functions are nested.
    In `f`, we not only create local variables such as `p` and `q` but also a local
    function `f2`, in which another local `p` variable is defined:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个例子看起来更加复杂。函数是嵌套的。在`f`中，我们不仅创建了局部变量如`p`和`q`，还创建了一个局部函数`f2`，在其中定义了另一个局部`p`变量：
- en: '[PRE61]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'If you understand lexical scoping, you should be able to predict the result
    given an arbitrary input `x`. We add some `cat()` functions to make it easier
    to track the values of variables in each scope level. The `cat()` message includes
    an order, the function scope, and the values of `p` and `q`. Now, we will run `f(0)`
    and you may predict the result:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你理解了词法作用域，你应该能够根据任意输入`x`预测结果。我们添加了一些`cat()`函数来更容易地跟踪每个作用域级别的变量值。`cat()`消息包括顺序、函数作用域和`p`和`q`的值。现在，我们将运行`f(0)`，你可以预测结果：
- en: '[PRE62]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The executing order of the three `cat()` functions are `1`, `3`, and `2`, and
    the values of `p` and `q` in each scope are consistent with lexical scoping rules.
    In the following example, we will also use `<<-`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 三个`cat()`函数的执行顺序是`1`、`3`和`2`，每个作用域中`p`和`q`的值都符合词法作用域规则。在以下示例中，我们也将使用`<<-`：
- en: '[PRE63]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You may analyze the flow of the function by predicting the order of execution
    and the values of the printed variables:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过预测执行顺序和打印变量的值来分析函数的流程：
- en: '[PRE64]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: If you do not succeed in predicting the behavior of the preceding function,
    go through the examples in this section more carefully.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有成功预测前面函数的行为，请更仔细地阅读本节中的例子。
- en: Understanding how an environment works
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解环境的工作原理
- en: In the previous sections, you learned about lazy evaluation, copy-on-modify,
    and lexical scoping. These mechanisms are highly related to a type of object called
    **environment**. In fact, lexical scoping is enabled exactly by the environment.
    Although environments look quite similar to lists, they are indeed fundamentally
    different in several aspects. In the following sections, we will get to know the
    behavior of environment objects by creating and manipulating them, and see the
    way its structure determines how R functions work.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了懒加载、修改时复制和词法作用域。这些机制与一种称为**环境**的对象高度相关。实际上，词法作用域正是由环境实现的。尽管环境看起来与列表非常相似，但它们在几个方面确实有根本的不同。在接下来的章节中，我们将通过创建和操作环境来了解环境对象的行为，并看到其结构如何决定R函数的工作方式。
- en: Knowing the environment object
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解环境对象
- en: 'An environment is an object consisting of a set of names and has a parent environment.
    Each name (also known as a symbol or variable) points to an object. When we look
    up a symbol in an environment, it will search the set of symbols and return the
    object the symbol points to if it exists in the environment. Otherwise, it will
    continue to look up its parent environment. The following diagram illustrates
    the structure of an environment and the relationship between environments:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 环境是一个包含一组名称的对象，并有一个父环境。每个名称（也称为符号或变量）指向一个对象。当我们在一个环境中查找符号时，它将搜索符号集，并在环境中存在该符号时返回符号指向的对象。否则，它将继续在其父环境中查找。以下图示说明了环境的结构和环境之间的关系：
- en: '![Knowing the environment object](img/image_08_001.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![了解环境对象](img/image_08_001.jpg)'
- en: In the preceding diagram, **Environment 1** consists of two names (**id** and **grades**),
    and its parent environment is **Environment 0**, which consists of one name (**scores**).
    Each name in these environments points to an object stored somewhere in the memory.
    If we look up **id** in **Environment 1**, we'll get the numeric vector it points
    to directly. If we look up **scores** instead, **Environment 1** does not consist
    of **scores**, so it will look it up in its parent environment, **Environment
    1**, and get its value successfully. For other names, it will look along the chain
    of parent environments until it is found or it will end up with an error of symbol
    not found.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，**环境1**包含两个名称（**id**和**grades**），其父环境是**环境0**，包含一个名称（**scores**）。这些环境中的每个名称都指向内存中某个位置存储的对象。如果我们查找**环境1**中的**id**，我们将直接得到它指向的数值向量。如果我们查找**scores**，**环境1**不包含**scores**，因此它将在其父环境**环境0**中查找，并成功获取其值。对于其他名称，它将沿着父环境链查找，直到找到或最终出现符号未找到的错误。
- en: In the following sections, we will go through these concepts in detail.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将详细讲解这些概念。
- en: Creating and chaining environments
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和链接环境
- en: 'We can create a new environment using the `new.env()` function:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `new.env()` 函数创建一个新的环境：
- en: '[PRE65]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The environment is usually represented by hexadecimal digits, which is a memory
    address:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 环境通常用十六进制数字表示，这是一个内存地址：
- en: '[PRE66]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Extraction operators (`$` and`[[`) can be used to create variables in the environment,
    just like modifying a list:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 提取运算符 (`$` 和 `[[`) 可以用来在环境中创建变量，就像修改列表一样：
- en: '[PRE67]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'However, there are three major differences between an environment and a list:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，环境与列表之间有三个主要区别：
- en: An environment has no index
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境没有索引
- en: An environment has a parent environment
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境有一个父环境
- en: Environments have reference semantics
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境具有引用语义
- en: In the following sections, we will explain them in detail.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将详细解释它们。
- en: Accessing an environment
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问环境
- en: 'An environment has no index. This means that we cannot subset an environment
    nor can we extract an element from it by index. If we try to subset the environment
    using a range of positions, we will get an error:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 环境没有索引。这意味着我们既不能对环境进行子集操作，也不能通过索引从它中提取元素。如果我们尝试使用位置范围来子集环境，我们会得到一个错误：
- en: '[PRE68]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We will get a different error when we try to extract a variable from an environment
    using index:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试使用索引从环境中提取变量时，我们会得到不同的错误：
- en: '[PRE69]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The correct way to work with an environment is using names and environment-access
    functions. For example, we can detect whether a variable exists in an environment
    using `exists()`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 正确处理环境的方式是使用名称和环境访问函数。例如，我们可以使用 `exists()` 来检测一个变量是否存在于环境中：
- en: '[PRE70]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'For an existing variable, we can call `get()` to retrieve its value:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个已存在的变量，我们可以调用 `get()` 来检索其值：
- en: '[PRE71]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We can call `ls()` to see all variable names in a given environment, as we
    mentioned in [Chapter 3](ch03.html "Chapter 3. Managing Your Workspace"), *Managing
    Your Workspace*:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以调用 `ls()` 来查看给定环境中的所有变量名，就像我们在[第 3 章](ch03.html "第 3 章。管理你的工作空间")中提到的，*管理你的工作空间*：
- en: '[PRE72]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'If we use `$` or `[[` to access variables that don''t exist in the environment,
    we will get `NULL`, just like what we get when we extract an element from a list
    using a non-existing name:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `$` 或 `[[` 来访问环境中不存在的变量，我们会得到 `NULL`，就像我们使用非存在的名称从列表中提取元素时得到的结果一样：
- en: '[PRE73]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'However, if we use the `get()` function in a non-existing variable out of an
    environment, we will certainly receive an error, just like what happens when we
    refer to a non-existing variable without caution:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们在一个不存在的变量上使用 `get()` 函数，我们肯定会收到一个错误，就像我们在不小心引用一个不存在的变量时发生的情况一样：
- en: '[PRE74]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'To better handle the situation before an error occurs, we may use `exists()`
    to perform a detection before we use the `get()` function to the variable:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地处理错误发生之前的情况，我们可以在使用 `get()` 函数访问变量之前使用 `exists()` 来进行检测：
- en: '[PRE75]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Chaining environments
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环境链
- en: An environment has a parent environment, which is the next place to look up
    a symbol if the symbol does not exist in the original environment. Suppose we
    are trying to use the `get()` function to a variable in an environment. If the
    variable is directly found in it, we get the value. Otherwise, `get()` will look
    for the variable in its parent environment.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 环境有一个父环境，这是在原始环境中不存在符号时查找符号的下一个地方。假设我们正在尝试使用 `get()` 函数访问环境中的变量。如果变量直接在其中找到，我们就得到值。否则，`get()`
    将在其父环境中查找变量。
- en: 'In the following example, we will create a new environment `e2`, whose parent
    (or enclosing) environment is `e1`, just like we created in the previous section:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将创建一个新的环境 `e2`，其父环境（或封装环境）是 `e1`，就像我们在上一节中创建的那样：
- en: '[PRE76]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Different environments have different memory addresses:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的环境有不同的内存地址：
- en: '[PRE77]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'However, the parent environment of `e2` is, by definition, exactly the same
    environment `e1` refers to, which can be verified by `parent.env()`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`e2` 的父环境，按照定义，与 `e1` 指向的环境完全相同，这可以通过 `parent.env()` 来验证：
- en: '[PRE78]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now, we create a variable `y` in `e2`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在 `e2` 中创建一个变量 `y`：
- en: '[PRE79]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We can use `ls()` to inspect all variable names in `e2`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `ls()` 来检查 `e2` 中的所有变量名：
- en: '[PRE80]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We can also access the value of the variable using `$`, `[[, exists()` or `get()`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用 `$`、`[[`、`exists()` 或 `get()` 来访问变量的值：
- en: '[PRE81]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: However, the extraction operators (`$` and `[[`) and the environment-access
    functions have a notable difference. The operators only work in the scope of a
    single environment, but the functions work along a chain of environments.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，提取运算符 (`$` 和 `[[`) 和环境访问函数有一个显著的区别。运算符仅在单个环境的作用域内工作，但函数在环境链中工作。
- en: 'Note that we don''t define any variable called `x` in `e2`. With no surprise,
    both operators extracting `x` result in `NULL`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在 `e2` 中没有定义任何名为 `x` 的变量。不出所料，提取 `x` 的两个运算符都导致 `NULL`：
- en: '[PRE82]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'However, the parent environment plays a role when we use `exists()` and `get()`.
    Since `x` is not found in `e2`, the functions will continue the search in its
    parent environment `e1`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们使用 `exists()` 和 `get()` 时，父环境会发挥作用。由于 `x` 在 `e2` 中未找到，函数将在其父环境 `e1` 中继续搜索：
- en: '[PRE83]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'That''s why we get positive results from both the preceding function calls.
    If we don''t want the functions to search the parent environment, we can set `inherits
    = FALSE`. In this case, if the variable is not immediately available in the given
    environment, the search will not continue. Instead, `exists()` will return `FALSE`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们从前面的函数调用中得到了积极的结果。如果我们不希望函数搜索父环境，我们可以设置 `inherits = FALSE`。在这种情况下，如果变量在给定环境中不可用，则搜索不会继续。相反，`exists()`
    将返回 `FALSE`：
- en: '[PRE84]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Also, the `get()` function will result in an error:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`get()` 函数将导致错误：
- en: '[PRE85]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The chaining of environments work at many levels. For example, you may create
    an environment, `e3`, whose parent is `e2`. When you use the `get()` function
    to a variable from `e3`, the search will go along the chain of environments.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 环境的链式工作在许多层面上。例如，你可能会创建一个名为 `e3` 的环境，其父环境为 `e2`。当你使用 `get()` 函数从 `e3` 中获取变量时，搜索将沿着环境链进行。
- en: Using environments for reference semantics
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用环境进行引用语义
- en: Environments have reference semantics. This means that unlike data types such
    as atomic vectors and lists, an environment will not be copied when it is modified,
    whether it has multiple names or is passed as an argument to a function.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 环境具有引用语义。这意味着与原子向量、列表等数据类型不同，当修改环境时，环境不会被复制，无论它具有多个名称还是作为函数的参数传递。
- en: 'For example, we assign the value of `e1` to another variable `e3`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将 `e1` 的值赋给另一个变量 `e3`：
- en: '[PRE86]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: If we have two variables pointing to the same list, modifying one would make
    a copy first and then modify the copied version, which does not influence the
    other list. Reference semantics behave otherwise. No copy is made when we modify
    the environment through either variable. So, we can see the changes through both
    `e1` and `e3` since they point to exactly the same environment.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有两个变量指向同一个列表，修改其中一个变量会首先创建一个副本，然后修改副本，这不会影响另一个列表。引用语义的行为则不同。当我们通过任一变量修改环境时，不会创建副本。因此，我们可以通过
    `e1` 和 `e3` 都看到变化，因为它们指向完全相同的环境。
- en: 'The following code demonstrates how reference semantics work:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了引用语义是如何工作的：
- en: '[PRE87]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: First, there is no `y` defined in `e3`. Then, we created a new variable `y`
    in `e1`. Since `e1` and `e3` point to exactly the same environment, we can also
    access `y` through `e3`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 `e3` 中没有定义 `y`。然后，我们在 `e1` 中创建了一个新的变量 `y`。由于 `e1` 和 `e3` 指向完全相同的环境，我们也可以通过
    `e3` 访问 `y`。
- en: 'The same thing happens when we pass an environment as an argument to a function.
    Suppose we define the following function that tries to set `z` of `e` to `10`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将环境作为函数的参数传递时，也会发生相同的情况。假设我们定义以下函数，尝试将 `e` 的 `z` 设置为 `10`：
- en: '[PRE88]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'If we pass a list to this function, the modification will not work. Instead
    a local version is created and modified, but it is dropped after the function
    call ends:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将列表传递给此函数，则修改将不起作用。相反，将创建并修改一个局部版本，但在函数调用结束后将被丢弃：
- en: '[PRE89]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'However, if we pass an environment to the function, modifying the environment
    does not produce a local copy but directly creates a new variable `z` in the environment:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们将环境传递给函数，修改环境不会产生局部副本，而是直接在环境中创建一个新的变量 `z`：
- en: '[PRE90]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Knowing the built-in environments
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 了解内置环境
- en: 'Environment is quite a special type of object in R, but it is used everywhere
    from the implementation of a function call to the mechanism of lexical scoping.
    In fact, when you run a chunk of R code, you run it in a certain environment.
    To know which environment we are running the code in, we can call `environment()`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 环境是 R 中一种相当特殊类型的对象，但它从函数调用的实现到词法作用域的机制无处不在。实际上，当你运行一段 R 代码时，你是在某个环境中运行的。为了知道我们在哪个环境中运行代码，我们可以调用
    `environment()`：
- en: '[PRE91]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The output says that the current environment is the global environment. In fact,
    when a fresh R session gets ready for user input, the working environment is always
    the global environment. It is in this environment that we usually create variables
    and functions in data analysis.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 输出表明当前环境是全局环境。实际上，当一个新的R会话准备好用户输入时，工作环境总是全局环境。正是在这个环境中，我们通常在数据分析中创建变量和函数。
- en: 'As the previous examples demonstrated, an environment is also an object we
    can create and work with. For example, we can assign the current environment to
    a variable and create new symbols in this environment:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，环境也是一个我们可以创建并与之交互的对象。例如，我们可以将当前环境赋值给一个变量，并在该环境中创建新的符号：
- en: '[PRE92]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The preceding assignment is equivalent to directly calling `some_obj <- 1`,
    because this is already in the global environment. As long as you run the preceding
    code, the global environment is modified and `some_obj` gets a value:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的赋值等同于直接调用`some_obj <- 1`，因为这在全局环境中已经存在。只要运行前面的代码，全局环境就会被修改，并且`some_obj`将获得一个值：
- en: '[PRE93]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'There are other ways to access the global environment. For example, both `globalenv()`
    and `.GlobalEnv` refer to the global environment:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他方法可以访问全局环境。例如，`globalenv()`和`.GlobalEnv`都指向全局环境：
- en: '[PRE94]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The global environment (`globalenv()`) is the user workspace, while the base
    environment (`baseenv()`) provides basic functions and operators:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 全局环境(`globalenv()`)是用户工作空间，而基础环境(`baseenv()`)提供基本函数和操作符：
- en: '[PRE95]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: If you type `base::` in the RStudio editor, a long list of functions should
    appear. Most of the functions we introduced in the previous chapters are defined
    in the base environment, including, for example, functions to create basic data
    structures (for example, `list()` and `data.frame()`) and operators to work with
    them (for example, `[`, `:` and even `+`).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在RStudio编辑器中输入`base::`，应该会显示一个长列表的函数。我们之前章节中介绍的大多数函数都是在基础环境中定义的，包括例如创建基本数据结构（例如，`list()`和`data.frame()`）的函数以及操作这些数据结构的操作符（例如，`[`,
    `:`甚至`+`）。
- en: The global environment and the base environment are the most important built-in
    environments. Now, you may ask "What is the parent environment of the global environment?
    And what about the base environment? What about their grandparents?"
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 全局环境和基础环境是最重要的内置环境。现在，你可能想知道“全局环境的父环境是什么？基础环境的呢？他们的祖父母又是谁？”
- en: 'The following function can be used to find out the chain of a given environment:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数可以用来找出给定环境的链：
- en: '[PRE96]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The preceding function recursively prints the names of the environment, the
    parent environment of each being the next one. Now, we can find out all levels
    of parent environments of the global environment:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的功能递归地打印环境的名称，每个环境的父环境是下一个。现在，我们可以找出全局环境的所有父环境级别：
- en: '[PRE97]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Note that the chain terminates at an environment called the **empty environment**,
    which is the only environment that has nothing in it and has no parent environment.
    There is also a `emptyenv()`function that refers to the empty environment, but `parent.env(emptyenv())`
    will cause an error. This explains why `parents()` will always end up with an
    error.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，链在被称为**空环境**的环境中终止，这是唯一一个没有任何内容且没有父环境的环境。还有一个`emptyenv()`函数指向空环境，但`parent.env(emptyenv())`将导致错误。这也解释了为什么`parents()`最终会出错。
- en: 'The chain of environments is a combination of built-in environments and package
    environments. We can call `search()` to get the search path of symbol lookup in
    the perspective of the global environment:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 环境链是内置环境和包环境的组合。我们可以调用`search()`来获取从全局环境角度的符号查找搜索路径：
- en: '[PRE98]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Given the knowledge of symbol lookup along a chain of environments, we can
    figure out the process in detail of how the following code is evaluated in the
    global environment:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 基于对环境链中符号查找的了解，我们可以详细地了解以下代码在全局环境中是如何评估的：
- en: '[PRE99]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The expression looks simple, but its evaluation process is more complex than
    it appears. First, look for `median` along the chain. It is found in the `stats`
    package environment. Then, look for `c`. It is found in the base environment.
    Finally, you may be surprised when you look for `+` (this is also a function!),
    as it is found in the base environment.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式看起来很简单，但它的评估过程比看起来要复杂。首先，沿着链查找`median`。它在`stats`包环境中找到。然后，查找`c`。它在基础环境中找到。最后，当你查找`+`（这同样也是一个函数！）时，你可能会感到惊讶，因为它也在基础环境中找到。
- en: In fact, each time you attach a package, the package environment will be inserted
    before the global environment in the search path. If two packages export functions
    with conflict names, the functions defined in the package attached later will
    mask formerly defined ones since it becomes a closer parent to the global environment.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，每次你附加一个包时，包环境都会在搜索路径中插入到全局环境之前。如果有两个包导出具有冲突名称的函数，那么后来附加的包中定义的函数将覆盖先前定义的函数，因为它们成为全局环境更近的父环境。
- en: Understanding environments associated with a function
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解与函数相关的环境
- en: 'Environments govern the symbol lookup at not only the global level but also
    the function level. There are three important environments associated with function
    and its execution process: the executing environment, the enclosing environment,
    and the calling environment.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 环境不仅控制全局级别的符号查找，也控制函数级别的符号查找。与函数及其执行过程相关的有三个重要的环境：执行环境、封闭环境和调用环境。
- en: Each time a function is called, a new environment called is created to host
    the execution process. This is the executing environment of the function call.
    The arguments of the function and the variables we create in the function are
    actually the variables in the executing environment.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 每次函数被调用时，都会创建一个新的环境来承载执行过程。这就是函数调用的执行环境。函数的参数以及我们在函数中创建的变量实际上都是执行环境中的变量。
- en: Like all other environments, the executing environment of a function is created
    with a parent environment. That parent environment, also called the enclosing
    environment of the function, is the environment where the function is defined.
    This means that during the execution of the function, any variable that is not
    defined in the executing environment will be looked for in the enclosing environment.
    This is exactly what makes lexical scoping possible.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有其他环境一样，函数的执行环境是用父环境创建的。这个父环境也称为函数的封闭环境，是函数被定义的环境。这意味着在函数执行期间，任何未在执行环境中定义的变量都会在封闭环境中查找。这正是词法作用域成为可能的原因。
- en: Sometimes it is also useful to know the calling environment, that is, the environment
    in which the function is called. We can use `parent.frame()` to get the calling
    environment of the currently executing function.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 有时了解调用环境也很有用，即函数被调用的环境。我们可以使用`parent.frame()`来获取当前正在执行函数的调用环境。
- en: 'To demonstrate these concepts, suppose we define the following function:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这些概念，假设我们定义以下函数：
- en: '[PRE100]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The function does nothing but prints the executing and enclosing environments
    when it is called:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 函数在被调用时什么也不做，只是打印执行环境和封闭环境：
- en: '[PRE101]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Note that each time the function is called, the executing environment is different,
    but the enclosing environment remains the same. In fact, when the function is
    defined, its enclosing environment is determined. We can call `environment()`
    over a function to get its enclosing environment:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每次函数被调用时，执行环境是不同的，但封闭环境保持不变。实际上，当函数被定义时，其封闭环境就已经确定。我们可以通过在函数上调用`environment()`来获取其封闭环境：
- en: '[PRE102]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The following example involves the three environments of three nested functions.
    In each function, the executing environment, enclosing environment, and calling
    environment are printed. If you firmly understand these concepts, I suggest that
    you make a prediction of which are the same and which are different:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例涉及三个嵌套函数的三个环境。在每个函数中，执行环境、封闭环境和调用环境都会被打印出来。如果你对这些概念有深刻的理解，我建议你预测哪些是相同的，哪些是不同的：
- en: '[PRE103]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Let's call `f1` and find out when each message is printed. The output requires
    some effort to read in its original form. We split the output into chunks for
    easier reading while preserving the order of output for consistency.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用`f1`并找出每次消息打印的时间。原始形式的输出需要一些努力才能阅读。我们将其分成几块以便更容易阅读，同时保持输出的顺序以保持一致性。
- en: 'Note that temporarily created environments only have memory addresses (for
    example, `0x0000000016a39fe8`) instead of a common name like the global environment
    (`R_GlobalEnv`). To make it easier to identify identical environments, we give
    the same memory addresses the same tags (for example, `*A`) at the end of each
    line of text output for the environments:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，临时创建的环境只有内存地址（例如，`0x0000000016a39fe8`），而不是像全局环境（`R_GlobalEnv`）那样的通用名称。为了更容易地识别相同的环境，我们在环境文本输出的每一行末尾给出相同的内存地址相同的标签（例如，`*A`）：
- en: '[PRE104]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'When we call `f1`, its associated environments are printed as supposed, and
    then `f2` and `f3` are defined, and finally `f3` is called, which continues producing
    the following text output:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `f1` 时，其关联的环境按预期打印，然后定义 `f2` 和 `f3`，最后调用 `f3`，继续产生以下文本输出：
- en: '[PRE105]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Then, `f2` is called in `f3`, which further produces the following text output:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `f3` 中调用 `f2`，进一步产生以下文本输出：
- en: '[PRE106]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The printed messages show the following facts:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 打印的消息显示了以下事实：
- en: Both the enclosing environment and calling environment of `f1` are the global
    environment
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f1` 的封装环境和调用环境都是全局环境'
- en: The enclosing environment and the calling environment of `f3`, as well as the
    enclosing environment of `f2`, are the executing environments of `f1`
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f3` 的封装环境和调用环境，以及 `f2` 的封装环境，是 `f1` 的执行环境'
- en: The calling environment of `f2` is the executing environment of `f3`
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f2` 的调用环境是 `f3` 的执行环境'
- en: 'The preceding facts are consistent with the following facts:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 上述事实与以下事实一致：
- en: '`f1` is both defined and called in the global environment'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f1` 在全局环境中既被定义又被调用'
- en: '`f3` is both defined and called in `f1`'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f3` 在 `f1` 中既被定义又被调用'
- en: '`f2` is defined in `f1` but called in `f3`'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f2` 在 `f1` 中定义但在 `f3` 中调用'
- en: If you managed to make the right predictions, you have a good understanding
    of how an environment and a function basically work. To go even deeper, I strongly
    recommend Hadley Wickham's Advanced R ([http://amzn.com/1466586966?tag=devtools-20](http://amzn.com/1466586966?tag=devtools-20)).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你成功地做出了正确的预测，说明你对环境和函数的基本工作原理有很好的理解。要进一步深入，我强烈推荐Hadley Wickham的《Advanced R》([http://amzn.com/1466586966?tag=devtools-20](http://amzn.com/1466586966?tag=devtools-20))。
- en: Summary
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went inside R and learned how R functions basically work.
    More specifically, you learned lazy evaluation, copy-on-modify, lexical scoping,
    and how environments work to allow these mechanisms. Having a concrete understanding
    of how R code is run not only helps you write the correct code but also makes
    it easier to find bugs from unexpected results.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入R中学习了R函数的基本工作原理。更具体地说，你学习了惰性求值、修改时复制、词法作用域以及环境是如何工作以允许这些机制。对R代码运行方式的直观理解不仅有助于你编写正确的代码，而且使你更容易从意外结果中找到错误。
- en: In the next chapter, we will build on top of the foundation laid in this chapter.
    You will learn the basics of metaprogramming, which enables powerful features
    of interactive analysis.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将在此基础上构建。你将学习元编程的基础，这为交互式分析提供了强大的功能。
