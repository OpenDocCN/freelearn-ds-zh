- en: Chapter 8. Inside R
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, you learned the basics of R programming language,
    and understood the usage of vectors, matrices, lists, and data frames to represent
    data in different shapes. You also saw how we can use the built-in functions to
    solve simple problems. However, simply knowing these features does not help you
    solve every problem. Real-world data analysis usually involves careful and detailed
    transformation and aggregation of data, which can be done with a good variety
    of functions, whether they are built-in or provided by extension packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'To best use these functions rather than let them confuse you with unexpected
    results, you need a basic but concrete understanding of how R functions work.
    In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Lazy evaluation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy-on-modify mechanism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lexical scoping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you understand these concepts and their roles in the code, most R code should
    appear highly predictable to you, which means higher productivity in both finding
    bugs and writing properly functional code.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding lazy evaluation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A big part of understanding how R works can be done by figuring out how R functions
    work. After going through the previous chapters, you should know the most commonly
    used basic functions. However, you may still be confused about their exact behavior.
    Suppose we create the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The function is somewhat special because `y` seems to be needed only when `x`
    is greater than zero. What if we only supply a positive number to `x` and ignore `y`?
    Will the function fail because we don''t supply every argument in its definition?
    Let''s find out by calling the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The function works without `y` being supplied. It looks like we are not required
    to supply the values to all arguments when we call a function but only to those
    that are needed. If we call `test0` with a negative number, `y` is needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Since we did not specify the value of `y`, the function stopped, reporting that `y`
    is missing.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the preceding examples, you learn that a function does not require all
    arguments to be specified if they are not needed to return a value. What if we
    insist on specifying those arguments that are not used in the function? Will they
    be evaluated before we call the function or not evaluated at all? Let''s find
    out by putting a `stop()` function in the position of argument `y`. If the expression
    is evaluated by any means somewhere, it should stop immediately before `x` is
    returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output indicates that `stop()` does not happen, which indicates that it
    is not evaluated at all. If we change the value of `x` to a negative number, the
    function should stop instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, it is very clear that `stop()` is evaluated in this case. The mechanism
    becomes quite transparent. In a function call, the expression of an argument is
    evaluated only when the value of the argument is needed. This mechanism is called **lazy
    evaluation**, and therefore, we can also say that the arguments of a function
    call are lazily evaluated, that is, evaluated only when needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are not aware of the lazy evaluation mechanism, you may think that the
    following function call must be extremely time consuming and may exhaust all your
    computer memory. However, lazy evaluation prevents it from happening because `rnorm(1000000)`
    is never evaluated. This is because it is never needed when evaluating `if (x
    > 0) x else y`, which can be verified by timing the function calls in turn using `system.time()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Generating 10 million random numbers is not an easy job. It takes more than
    a second. By contrast, evaluating a number should be the easiest thing R can do,
    and it is so fast that the timer itself can''t tell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If we time the following expression, given the logic of `test0` and the knowledge
    of lazy evaluation, at an educated guess it should be zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Another lazy evaluation scenario that could happen is the default values of
    arguments. More precisely, the default values of function arguments should really
    be default expressions because the value is not available until the expression
    is actually evaluated. Consider the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We give `y` a default value that calls `stop()`. If lazy evaluation does not
    apply here, that is, if `y` is evaluated irrespective of whether it is needed,
    we should receive an error as long as we call `test1()` without supplying `y`.
    However, if lazy evaluation applies, calling `test1()` with a positive `x` argument
    should not cause an error since the `stop()` expression of `y` is never evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do an experiment to find out which is true. First, we will call `test1()`
    with a positive `x argument`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output implies that lazy evaluation also works here. The function only
    uses `x`, and the default expression of `y` is not evaluated at all. If we supply
    a negative `x` argument instead, the function should stop as supposed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding examples demonstrate an advantage of lazy evaluation: it makes
    it possible to save time and avoid unnecessary evaluation of expressions. Besides,
    it also allows more flexible specification of default values of function arguments.
    For example, you can use other arguments in the expression of a function argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This allows you to set up the default behavior of a function in a more reasonable
    or desirable way, while the function arguments are still as customizable as they
    were without those default values.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we call `test2` without specifying `n`, the default behavior takes out the
    first half elements of `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The function remains flexible because you can always override its default behavior
    by specifying another value of `n`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Like all other features, lazy evaluation also has its pros and cons. Since the
    arguments of a function are only parsed but not evaluated when the function is
    called, we can only make sure that the expressions supplied to the arguments are
    syntactically correct. It is hard to ensure that the arguments are going to work.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if an undefined variable appears in the default value of an argument,
    there will be no warning or error the moment we create the function. In the following
    example, we create a `test3` function, which is exactly the same as `test2`, except
    that `x` in `n` is mistakenly written as an undefined variable `m`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When we create `test3`, there''s no warning or error because `floor(length(m)
    / 2)` is never evaluated before `test3` is called, and the value of `n` is demanded
    by `1:n`. The function will stop only when we actually call it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have `m` defined before `test3` is called, the function works, but in
    an unexpected way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example that makes how lazy evaluation works more explicit is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note that the default value of `y` is `p`, which is not defined before the function
    is called, just like the previous example. A notable difference between these
    two examples is when the missing symbol in the default value of the second argument
    is supplied. In the previous example, `p` is defined before the function is called.
    However, in this example, `p` is defined inside the function before `y` is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happens when we call the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'It looks like the function works rather than ending up in an error. It will
    become easier to understand if we go through the detailed process of how `test4(1)`
    is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: Find a function named `test4`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Match the given arguments, but both `x` and `y` are unevaluated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`p <- x + 1` evaluates `x + 1` and assigns the value to a new variable `p`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`c(x, y)` evaluates both `x` and `y`, where `x` takes `1` and `y` takes `p`,
    which just happens to get the value of `x + 1`, which is `2`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The function returns a numeric vector `c(1, 2)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Therefore, in the whole evaluation process of `test4(1)`, no warning or error
    occurs because no rules are violated. The most important trick here is that `p`
    is just defined before `y` is used.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example helps exaplain how lazy evaluation works, but it is indeed
    a bad practice. I won't recommend writing a function in this way because such
    a trick only makes the behavior of the function less transparent. A good practice
    is to simplify the arguments and avoid using undefined symbols outside the function.
    Otherwise, it can be hard to predict its behavior or debug the function due to
    its dependency on the outer environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite this, there is some wise use of lazy evaluation too. For example, `stop()`
    can be used along with `switch()` in the last argument to make the function stop
    when no cases are matched. The following function `check_input()` uses `switch()`
    to regulate the input of `x` so that it only accepts `y` or `n` and stops when
    other strings are supplied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When `x` takes `y`, a message saying `yes` shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When `x` takes `n`, a message saying `no` shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, the function stops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The example works because `stop()` is lazily evaluated as an argument of `switch()`.
  prefs: []
  type: TYPE_NORMAL
- en: As a summary of the examples, the reminder here is that you cannot rely too
    much on the parser to check the code. It only checks the code in its syntax, and
    it does not tell you whether the code is written with good practice. To avoid
    the potential pitfalls caused by lazy evaluation, do necessary checking in the
    function to make sure that the input can be handled correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the copy-on-modify mechanism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we showed how lazy evaluation works and how it may
    help save computing time and working memory by avoiding unnecessary evaluation
    of function arguments. In this section, I will show you an important feature of
    R that makes it safer to work with data. Suppose we create a simple numeric vector
    `x1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we assign the value of `x1` to `x2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now, `x1` and `x2` have exactly the same value. What if we modify an element
    in one of the two vectors? Will both vectors change?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The output shows that when `x1` is changed, `x2` will remain unchanged. You
    may guess that the assignment automatically copies the value and makes the new
    variable point to the copy of the data instead of the original data. Let's use `tracemem()` to
    track the footprint of the data in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s reset the vectors and conduct an experiment by tracing the memory addresses
    of `x1` and `x2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As we call `tracemem()` on the two vectors, it shows the current memory address
    of the data. If the memory address being traced changes, a text will show up with
    the original address and the new address, indicating that the data is copied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now, both vectors have the same value, and `x1` and `x2` share the same address,
    which implies that they point to exactly the same piece of data in memory and
    that the assignment operation does not copy the data automatically. But when is
    the data copied?
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will modify the first element of `x1` to `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The memory tracing says that the address of `x1` has changed to a new one. More
    specifically, the piece of memory, that is, the original vector both `x1` and
    `x2` point to is copied to a new location. Now we have two copies of the same
    data in two different locations. Then, the first element of the copy is modified,
    and finally, `x1` is made to point to the modified copy.
  prefs: []
  type: TYPE_NORMAL
- en: Now, `x1` and `x2` have different values: `x1` points to the modified vector
    and `x2` remains pointing to the original vector.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, if multiple variables refer to the same object, modifying one
    variable will make a copy of the object. This mechanism is called **copy-on-modify**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another scenario where copy-on-modify happens is when we modify a function
    argument. Suppose we create the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: When the function is executed, it attempts to modify the first element of argument
    `x`. Let's do some experiments with vectors and lists and see whether `modify_first()`
    can modify them.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a number vector `v1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'For a list `v2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In both experiments, the function only returned a modified version of the original
    object, but it did not modify the original object. However, directly modifying
    the vectors outside the function works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the modified version, we need to assign it to the original variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The preceding examples demonstrate that modifying a function argument also causes
    a copy to make sure that the modification does not affect things outside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The copy-on-modify mechanism also happens when the attributes are modified.
    The following function removes the row names of a data frame and replaces its
    column names with capital letters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To test the function, we will create a simple data frame with randomly generated
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will call the function with the data frame and see the modified version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'According to the copy-on-modify mechanism, `small_df` is copied the first time
    when its row names are removed, and then, all subsequent changes are made to the
    copied version instead of the original version. We can verify this by viewing `small_df`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The original version has not changed at all.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying objects outside a function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Despite the copy-on-modify mechanism, it is still possible to modify a vector
    outside a function. The `<<-` operator is designed to do the job. Suppose we have
    a variable `x` and create a function `modify_x()` that simply assigns a new value
    to `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'When we call the function, the value of `x` will be replaced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be useful when you try to map a vector to a new list and do some counting
    at the same time. The following code creates a list of vectors with an increasing
    number of elements. In each iteration of `lapply()`, `count` is used to sum up
    the total number of elements in the vector generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example in which `<<-` is useful is to flatten a nested list. Suppose
    we have a nested list like the one shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We want to flatten the list so that the nested levels are all brought to the
    first level. The following code solves the problem using `rapply()` and `<<-`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to know that `rapply()` is a recursive version of `lapply()`.
    In each iteration, the supplied function is called with an atomic vector at a
    particular level in the list until all atomic vectors at all levels are exhausted.
    Calling `rapply(nested_list, f)` basically runs in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Keep in mind, that we should work out a solution to flatten `nested_list`.
    The solution that we will discuss is inspired by a Stackoverflow answer ([http://stackoverflow.com/a/8139959/2906900](http://stackoverflow.com/a/8139959/2906900)),
    which smartly uses `rapply()`. First, we will create an empty list to receive
    individual vectors in the nested list and a counter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will use `rapply()` to recursively apply a function to `nested_list`.
    In each iteration, the function receives an atomic vector in `nested_list` through `x`.
    The function sets the`i` ^(th) element of `flat_list` to `x` and increments the
    counter `i`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'With the iterations done, all atomic vectors are stored in `flat_list` at the
    first level. The value returned by `rapply()` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result of `i <<- i + 1`, the values in `res` are of no much importance.
    However, the names of `res` are useful to indicate the original levels and names
    of each element in `flat_list`. So we let `flat_list` also have the names of `res`
    to indicate the origin of each element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Finally, all elements in `nested_list` are stored in a flat way in `flat_list`.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding lexical scoping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we introduced the copy-on-modify mechanism. The examples
    demonstrated two cases in which this mechanism happens. When an object has multiple
    names or is passed as an argument to a function, modifying it will cause the object
    to be copied, and it is the copied version that is actually modified.
  prefs: []
  type: TYPE_NORMAL
- en: To modify an object outside a function, we introduced the use of `<<-`, which
    finds the variable outside the function first and modifies that object instead
    of copying one locally. This leads to an important idea that a function has inside
    and outside. Inside a function, we can somehow refer to variables and functions
    outside.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following function uses two outside variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We first create two variables and define a function called `fun1`. The function
    simply puts together `start_num`, argument `x`, and `end_num` into a new vector.
    It is clear that `start_num` and `end_num` are not defined in the function but
    outside it while `x` is the argument of the function. Let''s see if it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The function works by successfully getting the value of the two variables outside
    the function. You may guess that when we define the function, the values are captured
    so that `start_num` and `end_num` in `fun1` just take the values from outside.
    In fact, two experiments can be performed to prove it wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first experiment is simple. Let''s remove the two variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Then, the function does not work anymore. If the values of the two variables
    are captured when the function is defined, the removal of them should not paralyze
    the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second experiment is the other way around. Let''s remove the function as
    well as the two variables. We will first define the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'If the creation of the function has to capture the two variables that are not
    present in it, the preceding code should result in an error saying `start_num`
    and `end_num` are missing. Clearly, there''s no error, and the function is successfully
    created. Let''s call it now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The function does not work because the two variables are not found. We will
    then define the two variables and again call the function with the same argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The function works again. This leads to the conclusion that the function actually
    tries to look for the variables when it is called. Actually, during the execution
    of the function, when a symbol is encountered, it will first look for it inside
    the function. More specifically, if the symbol is passed in as an argument or
    created inside the function, the symbol will be resolved and its value is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we create a variable `p` first and then define a function `fun2` in
    which another `p` variable is created and used in the value to return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: When we call the function, which `p` will `fun2` use in `x + p`? Let's find
    out;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The output makes it clear that `x + p` uses `p` defined inside the function.
    The flow is simple. First, `p <- 1` creates a new variable `p` with value `1`
    instead of changing `p` outside the function. Then, `x + p` is evaluated, with `x`
    being resolved as the passed-in argument and `p` as the local variable just defined.
    The rule is that only if a variable is not present inside the function will it
    be searched for outside.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, what exactly does "outside" mean? The question is subtler than it
    appears to be. Suppose we create the following two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The first function `f1` simply adds two variables: `x` is an argument and `p`
    is a variable yet to be found outside. The second function `g1` defines a `p`
    variable inside and calls `f1`. The question is, "Will `f1` find `p` inside `g1`
    when `g1` is called?"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, `f1` cannot find `p` inside `g1` even though `f1` is called
    in `g1`. If we define `p` and then call `g1` again, the function works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: What made `g1` work is that when `f1` is called and `p` cannot be found inside `f1`,
    it will search where `f1` is defined instead of where it is called. This mechanism
    is called **lexical scoping**. In the preceding code, we defined `p` in the same
    scope where `f1` is defined. Then, `f1` can find `p` when it is called inside `g1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same scoping rule also applies to how `<<-` finds variables. For example,
    the following code defines a variable `m` and two functions, `f2` and `g2`, in
    the same scope. In `f2`, `m` is set to `2`. However, in `g2`, a local `m` variable
    is defined and then `f2` is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as `f2` is called, the value of `m` in `g2` is printed. Let''s call `g2`
    and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The printed text shows that the value of `m` in `g2` remains unchanged, but
    the value of `m` outside `f2` and `g2` is changed as can be verified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The preceding experiment confirms that `m <<- 2` follows the rule of lexical
    scoping.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following two examples look even more complex. The functions are nested.
    In `f`, we not only create local variables such as `p` and `q` but also a local
    function `f2`, in which another local `p` variable is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'If you understand lexical scoping, you should be able to predict the result
    given an arbitrary input `x`. We add some `cat()` functions to make it easier
    to track the values of variables in each scope level. The `cat()` message includes
    an order, the function scope, and the values of `p` and `q`. Now, we will run `f(0)`
    and you may predict the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The executing order of the three `cat()` functions are `1`, `3`, and `2`, and
    the values of `p` and `q` in each scope are consistent with lexical scoping rules.
    In the following example, we will also use `<<-`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'You may analyze the flow of the function by predicting the order of execution
    and the values of the printed variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: If you do not succeed in predicting the behavior of the preceding function,
    go through the examples in this section more carefully.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how an environment works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, you learned about lazy evaluation, copy-on-modify,
    and lexical scoping. These mechanisms are highly related to a type of object called
    **environment**. In fact, lexical scoping is enabled exactly by the environment.
    Although environments look quite similar to lists, they are indeed fundamentally
    different in several aspects. In the following sections, we will get to know the
    behavior of environment objects by creating and manipulating them, and see the
    way its structure determines how R functions work.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the environment object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An environment is an object consisting of a set of names and has a parent environment.
    Each name (also known as a symbol or variable) points to an object. When we look
    up a symbol in an environment, it will search the set of symbols and return the
    object the symbol points to if it exists in the environment. Otherwise, it will
    continue to look up its parent environment. The following diagram illustrates
    the structure of an environment and the relationship between environments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Knowing the environment object](img/image_08_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, **Environment 1** consists of two names (**id** and **grades**),
    and its parent environment is **Environment 0**, which consists of one name (**scores**).
    Each name in these environments points to an object stored somewhere in the memory.
    If we look up **id** in **Environment 1**, we'll get the numeric vector it points
    to directly. If we look up **scores** instead, **Environment 1** does not consist
    of **scores**, so it will look it up in its parent environment, **Environment
    1**, and get its value successfully. For other names, it will look along the chain
    of parent environments until it is found or it will end up with an error of symbol
    not found.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will go through these concepts in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and chaining environments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can create a new environment using the `new.env()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The environment is usually represented by hexadecimal digits, which is a memory
    address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Extraction operators (`$` and`[[`) can be used to create variables in the environment,
    just like modifying a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'However, there are three major differences between an environment and a list:'
  prefs: []
  type: TYPE_NORMAL
- en: An environment has no index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An environment has a parent environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environments have reference semantics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we will explain them in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing an environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An environment has no index. This means that we cannot subset an environment
    nor can we extract an element from it by index. If we try to subset the environment
    using a range of positions, we will get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get a different error when we try to extract a variable from an environment
    using index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The correct way to work with an environment is using names and environment-access
    functions. For example, we can detect whether a variable exists in an environment
    using `exists()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'For an existing variable, we can call `get()` to retrieve its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We can call `ls()` to see all variable names in a given environment, as we
    mentioned in [Chapter 3](ch03.html "Chapter 3. Managing Your Workspace"), *Managing
    Your Workspace*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use `$` or `[[` to access variables that don''t exist in the environment,
    we will get `NULL`, just like what we get when we extract an element from a list
    using a non-existing name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we use the `get()` function in a non-existing variable out of an
    environment, we will certainly receive an error, just like what happens when we
    refer to a non-existing variable without caution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'To better handle the situation before an error occurs, we may use `exists()`
    to perform a detection before we use the `get()` function to the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Chaining environments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An environment has a parent environment, which is the next place to look up
    a symbol if the symbol does not exist in the original environment. Suppose we
    are trying to use the `get()` function to a variable in an environment. If the
    variable is directly found in it, we get the value. Otherwise, `get()` will look
    for the variable in its parent environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we will create a new environment `e2`, whose parent
    (or enclosing) environment is `e1`, just like we created in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Different environments have different memory addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the parent environment of `e2` is, by definition, exactly the same
    environment `e1` refers to, which can be verified by `parent.env()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we create a variable `y` in `e2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use `ls()` to inspect all variable names in `e2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also access the value of the variable using `$`, `[[, exists()` or `get()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: However, the extraction operators (`$` and `[[`) and the environment-access
    functions have a notable difference. The operators only work in the scope of a
    single environment, but the functions work along a chain of environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we don''t define any variable called `x` in `e2`. With no surprise,
    both operators extracting `x` result in `NULL`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the parent environment plays a role when we use `exists()` and `get()`.
    Since `x` is not found in `e2`, the functions will continue the search in its
    parent environment `e1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s why we get positive results from both the preceding function calls.
    If we don''t want the functions to search the parent environment, we can set `inherits
    = FALSE`. In this case, if the variable is not immediately available in the given
    environment, the search will not continue. Instead, `exists()` will return `FALSE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, the `get()` function will result in an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: The chaining of environments work at many levels. For example, you may create
    an environment, `e3`, whose parent is `e2`. When you use the `get()` function
    to a variable from `e3`, the search will go along the chain of environments.
  prefs: []
  type: TYPE_NORMAL
- en: Using environments for reference semantics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Environments have reference semantics. This means that unlike data types such
    as atomic vectors and lists, an environment will not be copied when it is modified,
    whether it has multiple names or is passed as an argument to a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we assign the value of `e1` to another variable `e3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: If we have two variables pointing to the same list, modifying one would make
    a copy first and then modify the copied version, which does not influence the
    other list. Reference semantics behave otherwise. No copy is made when we modify
    the environment through either variable. So, we can see the changes through both
    `e1` and `e3` since they point to exactly the same environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code demonstrates how reference semantics work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: First, there is no `y` defined in `e3`. Then, we created a new variable `y`
    in `e1`. Since `e1` and `e3` point to exactly the same environment, we can also
    access `y` through `e3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same thing happens when we pass an environment as an argument to a function.
    Suppose we define the following function that tries to set `z` of `e` to `10`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'If we pass a list to this function, the modification will not work. Instead
    a local version is created and modified, but it is dropped after the function
    call ends:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we pass an environment to the function, modifying the environment
    does not produce a local copy but directly creates a new variable `z` in the environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Knowing the built-in environments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Environment is quite a special type of object in R, but it is used everywhere
    from the implementation of a function call to the mechanism of lexical scoping.
    In fact, when you run a chunk of R code, you run it in a certain environment.
    To know which environment we are running the code in, we can call `environment()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The output says that the current environment is the global environment. In fact,
    when a fresh R session gets ready for user input, the working environment is always
    the global environment. It is in this environment that we usually create variables
    and functions in data analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the previous examples demonstrated, an environment is also an object we
    can create and work with. For example, we can assign the current environment to
    a variable and create new symbols in this environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding assignment is equivalent to directly calling `some_obj <- 1`,
    because this is already in the global environment. As long as you run the preceding
    code, the global environment is modified and `some_obj` gets a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'There are other ways to access the global environment. For example, both `globalenv()`
    and `.GlobalEnv` refer to the global environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The global environment (`globalenv()`) is the user workspace, while the base
    environment (`baseenv()`) provides basic functions and operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: If you type `base::` in the RStudio editor, a long list of functions should
    appear. Most of the functions we introduced in the previous chapters are defined
    in the base environment, including, for example, functions to create basic data
    structures (for example, `list()` and `data.frame()`) and operators to work with
    them (for example, `[`, `:` and even `+`).
  prefs: []
  type: TYPE_NORMAL
- en: The global environment and the base environment are the most important built-in
    environments. Now, you may ask "What is the parent environment of the global environment?
    And what about the base environment? What about their grandparents?"
  prefs: []
  type: TYPE_NORMAL
- en: 'The following function can be used to find out the chain of a given environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function recursively prints the names of the environment, the
    parent environment of each being the next one. Now, we can find out all levels
    of parent environments of the global environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Note that the chain terminates at an environment called the **empty environment**,
    which is the only environment that has nothing in it and has no parent environment.
    There is also a `emptyenv()`function that refers to the empty environment, but `parent.env(emptyenv())`
    will cause an error. This explains why `parents()` will always end up with an
    error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chain of environments is a combination of built-in environments and package
    environments. We can call `search()` to get the search path of symbol lookup in
    the perspective of the global environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Given the knowledge of symbol lookup along a chain of environments, we can
    figure out the process in detail of how the following code is evaluated in the
    global environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: The expression looks simple, but its evaluation process is more complex than
    it appears. First, look for `median` along the chain. It is found in the `stats`
    package environment. Then, look for `c`. It is found in the base environment.
    Finally, you may be surprised when you look for `+` (this is also a function!),
    as it is found in the base environment.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, each time you attach a package, the package environment will be inserted
    before the global environment in the search path. If two packages export functions
    with conflict names, the functions defined in the package attached later will
    mask formerly defined ones since it becomes a closer parent to the global environment.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding environments associated with a function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Environments govern the symbol lookup at not only the global level but also
    the function level. There are three important environments associated with function
    and its execution process: the executing environment, the enclosing environment,
    and the calling environment.'
  prefs: []
  type: TYPE_NORMAL
- en: Each time a function is called, a new environment called is created to host
    the execution process. This is the executing environment of the function call.
    The arguments of the function and the variables we create in the function are
    actually the variables in the executing environment.
  prefs: []
  type: TYPE_NORMAL
- en: Like all other environments, the executing environment of a function is created
    with a parent environment. That parent environment, also called the enclosing
    environment of the function, is the environment where the function is defined.
    This means that during the execution of the function, any variable that is not
    defined in the executing environment will be looked for in the enclosing environment.
    This is exactly what makes lexical scoping possible.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it is also useful to know the calling environment, that is, the environment
    in which the function is called. We can use `parent.frame()` to get the calling
    environment of the currently executing function.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate these concepts, suppose we define the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'The function does nothing but prints the executing and enclosing environments
    when it is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that each time the function is called, the executing environment is different,
    but the enclosing environment remains the same. In fact, when the function is
    defined, its enclosing environment is determined. We can call `environment()`
    over a function to get its enclosing environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example involves the three environments of three nested functions.
    In each function, the executing environment, enclosing environment, and calling
    environment are printed. If you firmly understand these concepts, I suggest that
    you make a prediction of which are the same and which are different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Let's call `f1` and find out when each message is printed. The output requires
    some effort to read in its original form. We split the output into chunks for
    easier reading while preserving the order of output for consistency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that temporarily created environments only have memory addresses (for
    example, `0x0000000016a39fe8`) instead of a common name like the global environment
    (`R_GlobalEnv`). To make it easier to identify identical environments, we give
    the same memory addresses the same tags (for example, `*A`) at the end of each
    line of text output for the environments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'When we call `f1`, its associated environments are printed as supposed, and
    then `f2` and `f3` are defined, and finally `f3` is called, which continues producing
    the following text output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, `f2` is called in `f3`, which further produces the following text output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'The printed messages show the following facts:'
  prefs: []
  type: TYPE_NORMAL
- en: Both the enclosing environment and calling environment of `f1` are the global
    environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The enclosing environment and the calling environment of `f3`, as well as the
    enclosing environment of `f2`, are the executing environments of `f1`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The calling environment of `f2` is the executing environment of `f3`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding facts are consistent with the following facts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`f1` is both defined and called in the global environment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`f3` is both defined and called in `f1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`f2` is defined in `f1` but called in `f3`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you managed to make the right predictions, you have a good understanding
    of how an environment and a function basically work. To go even deeper, I strongly
    recommend Hadley Wickham's Advanced R ([http://amzn.com/1466586966?tag=devtools-20](http://amzn.com/1466586966?tag=devtools-20)).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went inside R and learned how R functions basically work.
    More specifically, you learned lazy evaluation, copy-on-modify, lexical scoping,
    and how environments work to allow these mechanisms. Having a concrete understanding
    of how R code is run not only helps you write the correct code but also makes
    it easier to find bugs from unexpected results.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will build on top of the foundation laid in this chapter.
    You will learn the basics of metaprogramming, which enables powerful features
    of interactive analysis.
  prefs: []
  type: TYPE_NORMAL
