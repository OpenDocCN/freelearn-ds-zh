- en: Chapter 3. Simple Tweaks to Make R Run Faster
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 简单调整以使R运行更快
- en: Improving the speed of an R code does not necessarily involve advanced optimization
    techniques like parallelizing the code or making it run in the database. Indeed,
    there are a number of simple tweaks that, while not always obvious, can make R
    run significantly faster. In this chapter, some of these tweaks are described.
    By no means do they capture all possible simple means to optimize the R code.
    However, they constitute some of the most fundamental, and hence often-encountered,
    opportunities to gain some speedups.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 提高R代码的速度并不一定涉及高级优化技术，如并行化代码或使其在数据库中运行。实际上，有一些简单的调整，虽然并不总是显而易见，但可以使R运行得更快。在本章中，描述了其中的一些调整。这些调整绝对不能涵盖所有可能的简单优化方法。然而，它们构成了获得一些速度提升的最基本、也最常遇到的机会。
- en: This chapter presents these tweaks in the order of decreasing generality—the
    more general ones are those found in almost all R codes, regardless of their application.
    Each tweak is accompanied by an example code that is intentionally kept simple
    so as not to obscure the explanation of the intended concept with unnecessary
    application-specific knowledge. In all these examples, artificial datasets are
    generated using random functions in R.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章按照递减的普遍性顺序介绍了这些调整——更普遍的调整几乎可以在所有R代码中找到，无论其应用如何。每个调整都伴随着一个示例代码，这些代码故意保持简单，以免不必要的应用特定知识掩盖了对预期概念的说明。在这些所有示例中，都是使用R中的随机函数生成人工数据集。
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Vectorization
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量化
- en: Use of built-in functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内置函数
- en: Preallocating memory
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预分配内存
- en: Use of simpler data structures
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用更简单的数据结构
- en: Use of hash tables for frequent lookups on large data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大型数据上使用哈希表进行频繁查找
- en: Seeking fast alternative packages in CRAN
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在CRAN中寻找快速替代包
- en: Vectorization
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量化
- en: Most R users should have encountered this first tweak. In essence, vectorization
    allows R operators to take vectors as arguments for quick processing of multiple
    values. This is unlike some other programming languages such as C, C++, and Java,
    in which the processing of multiple values is usually done by iterating through
    and applying operators on each element of a vector (or array). R, being a flexible
    language, allows users to program using either iteration or vectorization. However,
    most of the time, iteration incurs significant and unnecessary computational cost
    because R is an interpreted, not compiled, language.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数R用户都应该遇到过这个第一个调整。本质上，向量化允许R运算符将向量作为参数进行快速处理多个值。这与C、C++和Java等一些其他编程语言不同，在这些语言中，多个值的处理通常是通过遍历并应用运算符到向量（或数组）的每个元素来完成的。R是一种灵活的语言，允许用户使用迭代或向量化进行编程。然而，大多数时候，迭代会带来显著且不必要的计算成本，因为R是一种解释型语言，而不是编译型语言。
- en: 'Take for example, the following simple code. Its goal is simply to calculate
    the square of every element in the random vector `data`. The first approach is
    to set up a `for` loop through every element of `data` and square it individually.
    Many would be tempted to take this approach because this is how it is done typically
    in other programming languages. Yet, a far more optimized approach in R is to
    apply the square operator on the `data` vector directly. This gives exactly the
    same output as the `for` loop, but much faster:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下简单的代码为例。其目的是简单地计算随机向量`data`中每个元素的平方。第一种方法是设置一个`for`循环遍历`data`中的每个元素并单独平方。许多人可能会倾向于采取这种方法，因为这是在其他编程语言中通常的做法。然而，在R中，一个更优化的方法是直接在`data`向量上应用平方运算符。这会得到与`for`循环完全相同的结果，但速度要快得多：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The following table shows the performance gains as the vector size increases
    (in logarithmic scale) from 100,000 to 100,000,000\. Notice that the compute time
    of the non-vectorized approach is about 200 times that of the vectorized approach,
    regardless of the vector size.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了随着向量大小（以对数尺度）从100,000增加到100,000,000时的性能提升。请注意，非向量化方法的计算时间大约是向量化方法的200倍，无论向量大小如何。
- en: '| **Vector size** | 100,000 | 1,000,000 | 10,000,000 | 100,000,000 |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| **向量大小** | 100,000 | 1,000,000 | 10,000,000 | 100,000,000 |'
- en: '| **Non-vectorized** | 120 ms | 1.19 s | 11.9 s | 117 s |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| **非向量化** | 120 ms | 1.19 s | 11.9 s | 117 s |'
- en: '| **Vectorized** | 508 μs | 5.67 ms | 52.5 ms | 583 ms |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| **向量化** | 508 μs | 5.67 ms | 52.5 ms | 583 ms |'
- en: When R executes a code, it has to take many steps behind the scenes. One example
    is type checking. R objects such as vectors do not need to be strictly defined
    to be of a particular type, such as an integer or a character. One can append
    a character to an integer vector without triggering any error—R converts the vector
    into a character vector automatically. Every time an operator is applied on a
    vector, R needs to check the type of the vector only once, but with the use of
    the iteration approach, this type checking happens as many times as the number
    of iterations, which incurs some computational costs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当 R 执行代码时，它需要在幕后执行许多步骤。一个例子是类型检查。R 对象，如向量，不需要严格定义为特定类型，如整数或字符。可以在整数向量中添加一个字符而不会触发任何错误——R
    会自动将向量转换为字符向量。每次在向量上应用运算符时，R 只需要检查一次向量的类型，但使用迭代方法，这种类型检查会像迭代次数一样多次发生，这会产生一些计算成本。
- en: Use of built-in functions
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置函数的使用
- en: As a programming language, R comes with low-level operators, such as basic arithmetic
    operators that can be used to construct more complex operators or functions. While
    R provides the flexibility to define functions, a performance comparison between
    an R function versus an equivalent function in a compiled language would almost
    always favor the latter. However, R and some CRAN packages provide a rich set
    of functions that are implemented in compiled languages such as C/C++. It is usually
    preferable to use these functions rather than to write custom R functions to perform
    the same task.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种编程语言，R 包含底层运算符，例如基本算术运算符，可以用来构建更复杂的运算符或函数。虽然 R 提供了定义函数的灵活性，但与编译语言中的等效函数相比，性能比较几乎总是偏向后者。然而，R
    和一些 CRAN 软件包提供了一组丰富的函数，这些函数是用 C/C++ 等编译语言实现的。通常，使用这些函数而不是编写自定义 R 函数来完成相同任务更为可取。
- en: 'Consider a simple example of how to calculate the sums of the rows of the following
    random matrix `data`. A code to perform these functions can be constructed by
    calling the `apply()` function, and setting the margin to 1 (representing a row
    operation) and by setting the `FUN` (or function) argument to `sum`. Alternatively,
    R provides a built-in function for this purpose called `rowSums`. The computational
    time of the former approach, as measured by `system.time`, is 11 times longer
    than that of the latter approach, which is an optimized and precompiled C function:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下随机矩阵 `data` 行求和的简单示例。可以通过调用 `apply()` 函数并设置边距为 1（表示行操作）以及将 `FUN`（或函数）参数设置为
    `sum` 来构建执行这些功能的代码。或者，R 提供了一个用于此目的的内置函数，称为 `rowSums`。通过 `system.time` 测量的前者方法的计算时间比后者方法长
    11 倍，后者是一个优化并预编译的 C 函数：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Speaking of optimized functions, our effort to improve the speed of an R code
    should not stop at precompiled functions that come with R. Over the years, the
    open source community has developed optimized libraries of specific functions
    that R can leverage. Take Basic Linear Algebra Subprograms (BLAS) for example
    (for more information refer to [http://www.netlib.org/blas/](http://www.netlib.org/blas/)).
    It was developed in the 1970s for Fortran and has since gained wider use by other
    languages (including R) because matrix operations make up the building blocks
    of many algorithms in various fields. There are now many implementations of BLAS,
    some of which include the capability to execute matrix operations in a multithreaded
    manner.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 说到优化函数，我们提高 R 代码速度的努力不应仅限于 R 伴随的预编译函数。多年来，开源社区已经开发了一系列优化库，R 可以利用这些库。以基本线性代数子程序（BLAS）为例（更多信息请参阅
    [http://www.netlib.org/blas/](http://www.netlib.org/blas/)）。它在 20 世纪 70 年代为 Fortran
    开发，此后由于矩阵运算构成了许多领域算法的构建块，因此被其他语言（包括 R）广泛使用。现在有许多 BLAS 的实现，其中一些包括以多线程方式执行矩阵运算的能力。
- en: 'For example, the Mac OS X version of R comes enabled with BLAS. The implementation
    of BLAS that is used is the reference BLAS from R called `libRblas.0.dylib`. Mac
    OS X however comes with its own version of BLAS, `libBLAS.dylib`, which is optimized
    for its hardware. R can be configured to use the optimized BLAS by executing the
    following commands in Terminal:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Mac OS X 版本的 R 默认启用了 BLAS。使用的 BLAS 实现是 R 中称为 `libRblas.0.dylib` 的参考 BLAS。然而，Mac
    OS X 自带其自己的 BLAS 版本，`libBLAS.dylib`，该版本针对其硬件进行了优化。R 可以配置为使用优化的 BLAS，通过在终端执行以下命令：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To test the effect of using different BLAS libraries, the following R code
    performs a simple matrix multiplication on a large random matrix. Using R''s default
    BLAS library, it took about 7 seconds for us to complete the task. After pointing
    R to the optimized BLAS, the same task was completed in about a tenth of the time:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试使用不同BLAS库的效果，下面的R代码在一个大随机矩阵上执行简单的矩阵乘法。使用R的默认BLAS库，我们完成这项任务大约需要7秒钟。在将R指向优化的BLAS之后，同样的任务在约十分之一的时间内完成：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There are BLAS versions of Windows and Linux available for you to download.
    If R is compiled with an enabled BLAS, that is, by setting the configuration option
    to `--enable-BLAS-shlib` while compiling R from its source, swapping between BLAS
    versions is done in a similar manner as in Mac OS X: by replacing the default
    BLAS library file with the new one. In Windows, the default library is located
    in `R_HOME\bin\x64\Rblas.dll`; while in Linux, it is in `R_HOME/lib/libRblas.so`.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 可供您下载的BLAS版本有Windows和Linux。如果R是用启用了BLAS编译的，即通过在从R的源代码编译R时设置配置选项为`--enable-BLAS-shlib`，那么在BLAS版本之间切换的方式与Mac
    OS X类似：通过用新的库文件替换默认的BLAS库文件。在Windows中，默认库位于`R_HOME\bin\x64\Rblas.dll`；而在Linux中，它位于`R_HOME/lib/libRblas.so`。
- en: Preallocating memory
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预分配内存
- en: Most strongly typed programming languages like C, C++, and Java generally require
    a vector (or array) to be declared prior to any operation applied on it. This
    declaration in effect preallocates the memory space that the vector requires.
    There are special occasions where dynamic memory allocation is used, but this
    is seldom the first choice mainly because dynamic memory allocation slows down
    a program. Every time a vector is resized, the program needs to perform extra
    steps that include copying the vector to a larger or smaller memory block and
    deleting the old vector. These steps are not needed if the memory is preallocated.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数强类型编程语言，如C、C++和Java，通常要求在向其应用任何操作之前声明一个向量（或数组）。这种声明实际上预分配了向量所需的内存空间。在某些特殊情况下会使用动态内存分配，但这很少是首选，主要是因为动态内存分配会减慢程序的速度。每次调整向量大小时，程序都需要执行额外的步骤，包括将向量复制到更大的或更小的内存块中，并删除旧向量。如果预分配了内存，这些步骤就不需要了。
- en: When it comes to preallocating memory, R is no different from the other programming
    languages. However, being an interpreted language, it imposes less control, thus
    it is easy for users to overlook this—R will not throw any compilation error if
    a vector's memory is not preallocated. Nevertheless, not preallocating memory
    in R can result in significantly longer execution times, especially when the vector
    is large.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到预分配内存时，R与其他编程语言没有区别。然而，作为一个解释型语言，它施加的控制较少，因此用户很容易忽略这一点——如果向量的内存没有预分配，R不会抛出任何编译错误。尽管如此，在R中没有预分配内存可能会导致执行时间显著变长，尤其是在向量很大时。
- en: 'To demonstrate this, let''s have a look at the following R code. It shows you
    two approaches to generate a series of random numbers, where each vector element
    is defined as the value of the previous element +/- a random integer between -5
    to 5\. The first approach (stores the results in `data_series1`) bypasses the
    preallocation of the vector''s memory, that is, it starts with a vector of a single
    element and appends a new element at each iteration. The second approach (with
    results in `data_series2`) preallocates the memory by declaring a numeric vector
    of size `N`. The preallocated space, as represented by the vector''s index, is
    filled in at every iteration. By preallocating the memory, the computation time
    on a vector of 10,000 elements is 10 times faster than the dynamic allocation.
    A benchmark exercise by varying the vector size, captured in the upcoming table,
    shows that while the computation time increases linearly when memory is preallocated,
    it increases super linearly when memory is dynamically allocated. It is critical
    for performance therefore to avoid unnecessary dynamic memory allocation in R:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，让我们看一下下面的R代码。它展示了两种生成一系列随机数的方法，其中每个向量元素定义为前一个元素的值加减一个介于-5到5之间的随机整数。第一种方法（将结果存储在`data_series1`中）绕过了向量内存的预分配，即它从一个只有一个元素的向量开始，并在每次迭代中添加一个新元素。第二种方法（结果在`data_series2`中）通过声明一个大小为`N`的数值向量来预分配内存。预分配的空间，由向量的索引表示，在每次迭代中填充。通过预分配内存，一个包含10,000个元素的向量的计算时间比动态分配快10倍。通过改变向量大小进行的基准测试，如即将到来的表格所示，显示当预分配内存时，计算时间呈线性增长，而当动态分配内存时，增长呈超线性。因此，避免在R中不必要的动态内存分配对于性能至关重要：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '| **Vector size** | 10 | 100 | 1000 | 10,000 |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| **向量大小** | 10 | 100 | 1000 | 10,000 |'
- en: '| **Dynamic allocation** | 0 | 0.006 | 0.288 | 25.373 |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| **动态分配** | 0 | 0.006 | 0.288 | 25.373 |'
- en: '| **Preallocated** | 0.001 | 0.006 | 0.062 | 0.577 |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| **预分配** | 0.001 | 0.006 | 0.062 | 0.577 |'
- en: At this point, it is interesting to compare the `apply` family of functions
    versus loops in R. Most R users would be familiar with the `apply()` function
    and its variants, including `lapply()`, `sapply()`, and `tapply()`. They provide
    the means to perform the same operation repeatedly on individual elements of a
    collection (for example, `data.frame`, `list`, or `vector`/`matrix`). Effectively,
    the `apply` family serves as a possible substitute of looping in R, provided there
    are no dependencies between one iteration and another. Besides simplifying the
    expression (it is often possible to express a multiline `for` loop as a single
    line `apply()` call), the `apply` family offers the benefit of automatically taking
    care of the memory preallocation and other housekeeping activities like deleting
    loop indices.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，比较 R 中的 `apply` 函数族与循环很有趣。大多数 R 用户都熟悉 `apply()` 函数及其变体，包括 `lapply()`、`sapply()`
    和 `tapply()`。它们提供了对集合（例如 `data.frame`、`list` 或 `vector`/`matrix`）中的单个元素重复执行相同操作的手段。实际上，`apply`
    函数族可以作为 R 中循环的可能替代品，前提是迭代之间没有依赖关系。除了简化表达式（通常可以将多行 `for` 循环表达为单行的 `apply()` 调用）之外，`apply`
    函数族还提供了自动处理内存预分配和其他家务活动（如删除循环索引）的好处。
- en: 'But does `apply` offer performance advantages over looping? The following code
    offers an answer to this. Two different approaches are used to generate a list
    of normally distributed random vectors whose sizes are also randomly set to values
    between 1 and 30\. The first approach uses a `for` loop while the second uses
    `lapply()`. Applying `system.time()` on both approaches shows that `lapply()`
    is significantly faster than the `for` loop:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 但 `apply` 是否比循环有性能优势？以下代码提供了一个答案。使用了两种不同的方法来生成一个大小在 1 到 30 之间随机设定的正态分布随机向量的列表。第一种方法使用
    `for` 循环，而第二种使用 `lapply()`。对这两种方法应用 `system.time()` 显示，`lapply()` 比循环快得多：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'But note that the `for` loop is implemented naively without preallocating the
    memory. The following code modifies it now with the preallocated memory. Its computation
    time has significantly been reduced to be just a tenth of a second slower than
    `lapply()`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 但请注意，`for` 循环是天真地实现的，没有预先分配内存。以下代码现在使用预分配的内存对其进行修改。其计算时间显著减少，比 `lapply()` 慢不到十分之一秒：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To establish this more convincingly, the comparison was repeated using `microbenchmark()`
    to run each expression 100 times. The results indicate that `lapply()` offers
    a slight performance advantage over a `for` loop:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更有说服力地建立这一点，使用 `microbenchmark()` 重复进行了比较，每次表达式运行 100 次。结果表明，`lapply()` 比循环有轻微的性能优势：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Based on this, the general view of replacing `for` loops with `apply` in R whenever
    possible is valid, but perhaps the performance gain would not be dramatic. In
    [Chapter 6](ch06.html "Chapter 6. Simple Tweaks to Use Less RAM"), *Simple Tweaks
    to Use Less RAM*, another benefit of `apply` will be discussed—that it reveals
    parts of R code that can be parallelized.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，在 R 中尽可能用 `apply` 替换 `for` 循环的一般观点是有效的，但性能提升可能不会非常显著。在[第 6 章](ch06.html
    "第 6 章。减少 RAM 使用量的简单技巧")“减少 RAM 使用量的简单技巧”中，将讨论 `apply` 的另一个好处——它揭示了 R 代码中可以并行化的部分。
- en: Use of simpler data structures
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单数据结构的使用
- en: Many R users would agree that `data.frame` as a data structure is the workhorse
    of data analysis in R. It provides an intuitive way to represent a typical structured
    dataset with rows and columns representing observations and variables respectively.
    A `data.frame` object also allows more flexibility than a matrix by allowing variables
    of different types (such as character and numeric variables in a single `data.frame`).
    Furthermore, in cases where a `data.frame` stores only variables of the same type,
    basic matrix operations conveniently become applicable to it without any explicit
    coercing required. This convenience, however, can come with performance degradation.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 R 用户会同意，`data.frame` 作为一种数据结构是 R 中数据分析的得力工具。它提供了一种直观的方式来表示典型的结构化数据集，其中行和列分别代表观测值和变量。`data.frame`
    对象也比矩阵提供了更多的灵活性，因为它允许不同类型的变量（例如，单个 `data.frame` 中的字符和数值变量）。此外，在 `data.frame` 仅存储相同类型变量的情况下，基本的矩阵运算可以方便地应用于它，而无需任何显式的强制转换。然而，这种便利性可能会带来性能下降。
- en: 'Applying a matrix operation on a `data.frame` is slower than on a `matrix`.
    One of the reasons is that most matrix operations first coerce the `data.frame`
    into a `matrix` before performing the computation. For this reason, where possible,
    one should use a `matrix` in place of a `data.frame`. The next code demonstrates
    this point. The goal is simply to perform row summation on a matrix and its equivalent
    `data.frame` representation. Using a `matrix` representation results in about
    3x speedup compared to using a `data.frame` representation:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在`data.frame`上执行矩阵运算比在矩阵上慢。其中一个原因是大多数矩阵运算首先将`data.frame`强制转换为`matrix`，然后再进行计算。因此，在可能的情况下，应该使用`matrix`代替`data.frame`。下面的代码演示了这一点。目标是简单地在一个矩阵及其等效的`data.frame`表示上执行行求和。使用`matrix`表示比使用`data.frame`表示快约3倍：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In many cases of R however, the use of `data.frame` is unavoidable, for example,
    when a dataset has mixed variable types. In this case, there is also a simple
    tweak that can improve the speed of one of the most frequently used operations
    on a `data.frame`, subsetting. Subsetting a `data.frame` is commonly done by conditioning
    its rows (or columns) through a logical test as in the following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在许多R的案例中，使用`data.frame`是不可避免的，例如，当数据集包含混合变量类型时。在这种情况下，也有一个简单的调整可以改善`data.frame`上最常用的操作之一，即子集操作的速度。通常通过以下代码通过逻辑测试对`data.frame`的行（或列）进行条件化来实现子集操作：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'An alternative to this is to wrap the condition by the `which` function. The
    speed is improved significantly as shown follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一种替代方法是使用`which`函数包装条件。如以下所示，速度显著提高：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Use of hash tables for frequent lookups on large data
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在大数据上频繁查找时使用哈希表
- en: 'One common task in data analysis is data lookup, which is often implemented
    via a list in R. For example, to look up customers'' ages, we can define a list,
    say, `cust_age`, with values set to customer ages and names set to the corresponding
    customer names (or IDs), that is `names(cust_age) <- cust_name`. In this case,
    to look up John Doe''s age, the following can be called: `cust_age[["John_Doe"]]`.
    However, the implementation of lists in R is not optimized for lookup; it incurs
    *O(N)* time complexity to perform a lookup on a list of *N* elements. This means
    that the values indexed later in the list require more time to look up. As *N*
    grows, this effect gets stronger. When a program requires frequent lookups, the
    cumulative effect can be significant. An alternative to lists that offers a more
    optimized data lookup is a hash table. In R, this is available from the CRAN package
    *hash*. A hash table''s lookup incurs *O(1)* time complexity.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 数据分析中的一个常见任务是数据查找，这通常通过R中的列表实现。例如，为了查找客户的年龄，我们可以定义一个列表，比如`cust_age`，将值设置为客户的年龄，将名称设置为相应的客户名称（或ID），即`names(cust_age)
    <- cust_name`。在这种情况下，要查找John Doe的年龄，可以调用以下内容：`cust_age[["John_Doe"]]`。然而，R中列表的实现并没有针对查找进行优化；在包含*N*个元素的列表上进行查找需要*O(N)*的时间复杂度。这意味着列表中索引较晚的值需要更多的时间来查找。随着*N*的增长，这种影响会变得更强。当程序需要频繁查找时，累积效应可能会非常显著。提供更优化数据查找的列表的替代方案是哈希表。在R中，这可以通过CRAN包*hash*获得。哈希表的查找需要*O(1)*的时间复杂度。
- en: 'The next code demonstrates the benefit of lookups in hash tables over lists.
    It simulates 1,000 lookups from a random list and its equivalent hash table representation.
    The total computation time required for the list is 6.14 seconds, while for the
    hash table is 0.31 seconds. One trade-off is that it takes more time to generate
    a hash table than a list. But for a program that requires frequent lookups on
    large data, this overhead can be insignificant:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码演示了在哈希表中进行查找比在列表中查找的优势。它模拟了从随机列表及其等效哈希表表示中进行的1,000次查找。列表所需的总计算时间为6.14秒，而哈希表为0.31秒。一个权衡是生成哈希表比列表需要更多的时间。但对于需要在大数据上频繁查找的程序来说，这种开销可以忽略不计：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Seeking fast alternative packages in CRAN
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在CRAN中寻找快速替代包
- en: One key advantage of R is its rich and active open source community, CRAN. As
    of the time of writing, there are over 6,000 R packages in CRAN. Given this, it
    is common that multiple packages offer the same functionalities. Some of these
    alternatives are designed specifically to improve the performance of a base or
    an existing CRAN package's performance. Others do not target performance improvement
    explicitly, but nevertheless achieve it as a by-product.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: R 的一个关键优势是其丰富且活跃的开源社区，CRAN。截至编写本文时，CRAN 上有超过 6,000 个 R 包。鉴于这一点，多个包提供相同的功能是很常见的。其中一些替代方案专门设计用来提高基础包或现有
    CRAN 包的性能。其他替代方案虽然没有明确针对性能提升，但作为副产品实现了这一点。
- en: 'An example of an alternative fast package developed to achieve performance
    gains is the `fastcluster` package. It was developed to improve the speed of hierarchical
    clustering provided by the base package through the `hclust` function. Depending
    on how the distance matrix gets updated after every branch merging in the hierarchical
    clustering procedure, its time complexity can vary significantly. The `fastcluster`
    package is developed using an optimized C++ code that improves the speed significantly
    compared to the routines implemented in `hclust`. The following R code compares
    the performance of the two functions on a random matrix with 10,000 rows and 100
    columns:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现性能提升而开发的替代快速包的例子是 `fastcluster` 包。它是为了通过 `hclust` 函数提高基础包提供的层次聚类速度而开发的。根据层次聚类过程中每次分支合并后距离矩阵的更新方式，其时间复杂度可能会有显著变化。`fastcluster`
    包是使用优化的 C++ 代码开发的，与 `hclust` 中实现的例程相比，速度显著提高。以下 R 代码比较了两个函数在具有 10,000 行和 100 列的随机矩阵上的性能：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'An example of a function that has more than one implementation, where one happens
    to be faster than the others as a by-product is **Principal Component Analysis**
    (**PCA**). PCA is a dimensionality reduction technique that achieves its goal
    by projecting a dataset onto orthogonal axes (called principal components) that
    maximize the dataset''s variance. The most common approach to PCA is via the Eigenvalue
    decomposition of the dataset''s covariance matrix. But there are alternative methods.
    In R, two of these alternatives materialize in two PCA functions called `prcomp`
    and `princomp` (both are parts of the `stats` package). A quick comparison on
    a random matrix with 100,000 rows and 100 columns as in the following code demonstrates
    that `princomp` is close to 2x faster than `prcomp`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有多个实现且其中一个实现比其他实现更快的函数的例子是**主成分分析**（**PCA**）。PCA 是一种降维技术，通过将数据集投影到正交轴（称为主成分）上以最大化数据集的方差来实现其目标。PCA
    最常见的方法是通过数据集协方差矩阵的特征值分解。但还有其他方法。在 R 中，这些替代方法体现在两个 PCA 函数 `prcomp` 和 `princomp`
    中（都是 `stats` 包的一部分）。以下代码在具有 100,000 行和 100 列的随机矩阵上的快速比较表明，`princomp` 比 `prcomp`
    快近 2 倍：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'There are other examples of fast packages both explicitly and implicitly. They
    include:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他快速包的例子，既有明确的也有隐含的。它们包括：
- en: '`fastmatch`: This provides a faster version of base R''s `match` function'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fastmatch`: 这提供了 R 的基础 `match` 函数的更快版本'
- en: '`RcppEigen`: This includes a faster version of linear modeling `lm`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RcppEigen`: 这包括线性建模 `lm` 的更快版本'
- en: '`data.table`: This offers faster data manipulation operations compared to the
    standard `data.frame` operations'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data.table`: 这提供了比标准 `data.frame` 操作更快的数据处理操作'
- en: '`dplyr` : This offers a set of tools to manipulate data frame-like objects
    efficiently'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dplyr` : 这提供了一套高效操作数据框对象（data frame-like objects）的工具'
- en: Summary
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter described a few simple tweaks to improve the speed of an R code.
    Some of the tweaks are well known, but often overlooked in practice; others are
    less obvious. Regardless of their nature, and despite their simplicity, these
    low hanging fruits can offer significant performance gains and sometimes even
    more than the advanced optimization discussed in subsequent chapters. As such,
    these tweaks should be taken as the first steps in order to optimize an R code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了一些简单的调整来提高 R 代码的速度。其中一些调整是众所周知的，但在实践中经常被忽视；其他一些则不那么明显。无论它们的性质如何，尽管它们很简单，这些低垂的果实可以提供显著的性能提升，有时甚至比后续章节中讨论的高级优化还要多。因此，这些调整应被视为优化
    R 代码的第一步。
- en: In the next chapter, we will see how to take R's performance even further by
    using compiled code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何通过使用编译代码来进一步提升 R 的性能。
