<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer1567">
			<h1 id="_idParaDest-119"><a id="_idTextAnchor208"/>Chapter 5: Variational Quantum Eigensolver (VQE) Algorithm</h1>
			<p class="author-quote"><a id="_idTextAnchor209"/>“Not only is the Universe stranger than we think, it is stranger than we can think.” </p>
			<p class="author-quote">– Werner Heisenberg</p>
			<div>
				<div id="_idContainer1405" class="IMG---Figure">
					<img src="Images/B18268_Figure_5.1.jpg" alt="" width="1349" height="510"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – Steepest descent line on a potential energy surface (PES) [authors]</p>
			<p>We introduced the history behind the use of the variational method in <em class="italic">Section 1.1, Understanding the history of quantum chemistry and mechanics</em>. It is a mathematical construct that can be used computationally. Within the context of quantum chemistry, the variational method is used to determine the lowest energy associated with an eigenvalue, either the ground state or excited states. </p>
			<p>The <strong class="bold">Variational Quantum Eigensolver</strong> (<strong class="bold">VQE</strong>) algorithm was introduced in 2014 [VQE_1] and is <a id="_idIndexMarker450"/>defined using quantum-based <a id="_idIndexMarker451"/>hardware. It is the first of several <strong class="bold">Variational Quantum Algorithms</strong> (<strong class="bold">VQAs</strong>) that are currently being explored by the scientific industry.</p>
			<p>We use <strong class="bold">Unitary Coupled Cluster Singles and Doubles</strong> (<strong class="bold">UCCSD</strong>) as a starting point to determine <a id="_idIndexMarker452"/>a trial wave function for the variational method as it is essential that the VQE ansatz is close to the true ground state to make the VQE computations successful. To get an accurate energy estimate of 1 milli-Hartree (mHA), the ansatz for the VQE must be close to the true ground state by less than one in a million [Troyer]. In this chapter, we will focus on calculating only the ground state and Born-Oppenheimer potential energy surface (BOPES) for the hydrogen (H<span class="subscript">2</span>) and lithium hydride (LiH) molecules, and a macro molecule. We introduced the BOPES in <em class="italic">Section 4.1, Born-Oppenheimer approximation</em>. We will cover the following topics:</p>
			<ul>
				<li><em class="italic">Section 5.1, Variational method</em></li>
				<li><em class="italic">Section 5.2, Example chemical calculations</em></li>
			</ul>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor210"/>Technical requirements</h1>
			<p>A companion Jupyter notebook for this chapter can be downloaded from GitHub at <a href="https://github.com/PacktPublishing/Quantum-Chemistry-and-Computing-for-the-Curious">https://github.com/PacktPublishing/Quantum-Chemistry-and-Computing-for-the-Curious</a>, which has been tested in the Google Colab environment, which is free and runs entirely in the cloud, and in the IBM Quantum Lab environment. Please refer to <a href="B18268_Appendix_B_ePub.xhtml#_idTextAnchor313"><em class="italic">Appendix B</em></a><em class="italic"> – Leveraging Jupyter Notebooks in the Cloud</em>, for more information. The companion Jupyter notebook automatically installs the following list of libraries:</p>
			<ul>
				<li><strong class="bold">Numerical Python</strong> (<strong class="bold">NumPy</strong>) [NumPy], an open-source Python library that is used in almost every field of science and engineering.</li>
				<li>Qiskit [Qiskit], an open-source SDK for working with quantum computers at the level of pulses, circuits, and application modules.</li>
				<li>Qiskit visualization support to enable the use of visualizations and Jupyter notebooks.</li>
				<li>Qiskit Nature [Qiskit_Nature] [Qiskit_Nat_0], a unique platform to bridge the gap between natural sciences and quantum simulations.</li>
				<li><strong class="bold">Python-based Simulations of Chemistry Framework</strong> (<strong class="bold">PySCF</strong>) [PySCF], an open-source collection of electronic structure modules powered by Python.</li>
				<li><strong class="bold">Quantum Toolbox in Python</strong> (<strong class="bold">QuTiP</strong>) [QuTiP], a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators.</li>
				<li><strong class="bold">Atomic Simulation Environment</strong> (<strong class="bold">ASE</strong>) [ASE_0], a set of tools and Python modules for setting up, manipulating, running, visualizing, and analyzing atomistic simulations. The code is freely available under the GNU LGPL license.</li>
				<li>PyQMC [PyQMC], a Python module that implements real-space quantum Monte Carlo techniques. It is primarily meant to interoperate with PySCF.</li>
				<li>h5py [h5py] package, a Pythonic interface to the HDF5 binary data format.</li>
				<li>SciPy [SciPy], a Python module that contains a large number of probability distributions, summary and frequency statistics, correlation functions and statistical tests, masked statistics, kernel density estimation, quasi-Monte Carlo functionality, and more.</li>
			</ul>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor211"/>Installing NumPy, Qiskit, QuTiP, and importing various modules</h2>
			<p>Install NumPy with <a id="_idIndexMarker453"/>the following command:</p>
			<p class="source-code">pip install numpy</p>
			<p>Install Qiskit with <a id="_idIndexMarker454"/>the following command:</p>
			<p class="source-code">pip install qiskit</p>
			<p>Install Qiskit visualization <a id="_idIndexMarker455"/>support with the following command:</p>
			<p class="source-code">pip install 'qiskit[visualization]'</p>
			<p>Install Qiskit Nature <a id="_idIndexMarker456"/>with the following command:</p>
			<p class="source-code">pip install qiskit-nature</p>
			<p>Install PySCF with the following command:</p>
			<p class="source-code">pip install pyscf</p>
			<p>Install QuTiP with the following command:</p>
			<p class="source-code">pip install qutip</p>
			<p>Install ASE with the following command:</p>
			<p class="source-code">pip install ase</p>
			<p>Install PyQMC with the following command:</p>
			<p class="source-code">pip install pyqmc --upgrade</p>
			<p>Install h5py with the following command:</p>
			<p class="source-code">pip install h5py</p>
			<p>Install SciPy with the following command:</p>
			<p class="source-code">pip install scipy</p>
			<p>Import NumPy with the following command:</p>
			<p class="source-code">import numpy as np</p>
			<p>Import Matplotlib, a comprehensive library for creating static, animated, and interactive visualizations in Python, with the following command:</p>
			<p class="source-code">import matplotlib.pyplot as plt</p>
			<p>Import the required <a id="_idIndexMarker457"/>functions and class methods. The <strong class="source-inline">array_to_latex function()</strong> returns <a id="_idIndexMarker458"/>a LaTeX representation <a id="_idIndexMarker459"/>of a complex <a id="_idIndexMarker460"/>array with dimension 1 or 2:</p>
			<p class="source-code">from qiskit.visualization import array_to_latex, plot_bloch_vector, plot_bloch_multivector, plot_state_qsphere, plot_state_city</p>
			<p class="source-code">from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit, transpile</p>
			<p class="source-code">from qiskit import execute, Aer</p>
			<p class="source-code">import qiskit.quantum_info as qi</p>
			<p class="source-code">from qiskit.extensions import Initialize</p>
			<p class="source-code">from qiskit.providers.aer import extensions  # import aer snapshot instructions</p>
			<p>Import the Qiskit Nature libraries with the following commands:</p>
			<p class="source-code">from qiskit import Aer</p>
			<p class="source-code">from qiskit_nature.drivers import UnitsType, Molecule</p>
			<p class="source-code">from qiskit_nature.drivers.second_quantization import ElectronicStructureDriverType, ElectronicStructureMoleculeDriver</p>
			<p class="source-code">from qiskit_nature.problems.second_quantization import ElectronicStructureProblem</p>
			<p class="source-code">from qiskit_nature.mappers.second_quantization import ParityMapper, JordanWignerMapper, BravyiKitaevMapper</p>
			<p class="source-code">from qiskit_nature.converters.second_quantization import QubitConverter</p>
			<p class="source-code">from qiskit_nature.transformers.second_quantization.electronic import ActiveSpaceTransformer, FreezeCoreTransformer</p>
			<p class="source-code">from qiskit_nature.operators.second_quantization import FermionicOp</p>
			<p class="source-code">from qiskit_nature.circuit.library.initial_states import HartreeFock</p>
			<p class="source-code">from qiskit_nature.circuit.library.ansatzes import UCCSD</p>
			<p>Import <a id="_idIndexMarker461"/>the Qiskit <a id="_idIndexMarker462"/>Nature property framework <a id="_idIndexMarker463"/>with the <a id="_idIndexMarker464"/>following command:</p>
			<p class="source-code">from qiskit_nature.properties import Property, GroupedProperty</p>
			<p>Import the <strong class="source-inline">ElectronicEnergy</strong> property with the following command:</p>
			<p class="source-code"># https://qiskit.org/documentation/nature/tutorials/08_property_framework.html</p>
			<p class="source-code">from qiskit_nature.properties.second_quantization.electronic import (</p>
			<p class="source-code">    ElectronicEnergy,</p>
			<p class="source-code">    ElectronicDipoleMoment,</p>
			<p class="source-code">    ParticleNumber,</p>
			<p class="source-code">    AngularMomentum,</p>
			<p class="source-code">    Magnetization,</p>
			<p class="source-code">)</p>
			<p>Import the <strong class="source-inline">ElectronicIntegrals</strong> property with the following command:</p>
			<p class="source-code">from qiskit_nature.properties.second_quantization.electronic.integrals import (</p>
			<p class="source-code">    ElectronicIntegrals,</p>
			<p class="source-code">    OneBodyElectronicIntegrals,</p>
			<p class="source-code">    TwoBodyElectronicIntegrals,</p>
			<p class="source-code">    IntegralProperty,</p>
			<p class="source-code">)</p>
			<p class="source-code">from qiskit_nature.properties.second_quantization.electronic.bases import ElectronicBasis</p>
			<p>Import the Qiskit Aer state vector simulator and various algorithms with the following commands:</p>
			<p class="source-code">from qiskit.providers.aer import StatevectorSimulator</p>
			<p class="source-code">from qiskit import Aer</p>
			<p class="source-code">from qiskit.utils import QuantumInstance</p>
			<p class="source-code">from qiskit_nature.algorithms import VQEUCCFactory, GroundStateEigensolver, NumPyMinimumEigensolverFactory, BOPESSampler</p>
			<p class="source-code">from qiskit.algorithms import NumPyMinimumEigensolver, VQE, HamiltonianPhaseEstimation</p>
			<p class="source-code">from qiskit.circuit.library import TwoLocal</p>
			<p class="source-code">from qiskit.algorithms.optimizers import QNSPSA</p>
			<p class="source-code">from qiskit.opflow import StateFn, PauliExpectation,  CircuitSampler, PauliTrotterEvolution</p>
			<p class="source-code">from functools import partial as apply_variation</p>
			<p>Import the PySCF gto <a id="_idIndexMarker465"/>and scf libraries <a id="_idIndexMarker466"/>with the <a id="_idIndexMarker467"/>following <a id="_idIndexMarker468"/>command:</p>
			<p class="source-code">from pyscf import gto, scf</p>
			<p>Import the PyQMC API library with the following command:</p>
			<p class="source-code">import pyqmc.api as pyq</p>
			<p>Import h5py with the following command:</p>
			<p class="source-code">import h5py</p>
			<p>Import the ASE libraries, the <strong class="source-inline">Atoms</strong> object, molecular data, and visualizations with the following commands:</p>
			<p class="source-code">from ase import Atoms</p>
			<p class="source-code">from ase.build import molecule</p>
			<p class="source-code">from ase.visualize import view</p>
			<p>Import the math libraries with the following commands:</p>
			<p class="source-code">import cmath</p>
			<p class="source-code">import math</p>
			<p>Import Python's statistical function<a id="_idTextAnchor212"/>s provided by the SciPy package with the following command:</p>
			<p class="source-code">import scipy.stats as stats</p>
			<p>Import <a id="_idIndexMarker469"/>QuTiP with <a id="_idIndexMarker470"/>the following command:</p>
			<p class="source-code">import qutip</p>
			<p>Import <a id="_idIndexMarker471"/>time and datetime <a id="_idIndexMarker472"/>with the following command:</p>
			<p class="source-code">import time, datetime</p>
			<p>Import pandas and os.path with the following commands:</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">import os.path</p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor213"/>5.1. Variational method</h1>
			<p>We illustrate the variational method through <a id="_idIndexMarker473"/>both classical <a id="_idIndexMarker474"/>and hybrid-quantum methods.  We compare VQE to the variational Monte Carlo method. Further, we also compare the results for VQE to the <strong class="bold">Quantum Phase Estimation</strong> (<strong class="bold">QPE</strong>) algorithm, which is not a variational method.</p>
			<p>In this section, we cover the following topics:</p>
			<ul>
				<li><em class="italic">Section 5.1.1, The Rayleigh-Ritz variational theorem</em></li>
				<li><em class="italic">Section 5.1.2, Variational Monte Carlo methods</em></li>
				<li><em class="italic">Section 5.1.3, Quantum Phase Estimation (QPE)</em></li>
				<li><em class="italic">Section 5.1.4, Description of the VQE algorithm</em></li>
			</ul>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor214"/>5.1.1. The Rayleigh-Ritz variational theorem</h2>
			<p>The Rayleigh-Ritz variational <a id="_idIndexMarker475"/>theorem states that the expectation value of the Hamiltonian <img src="Images/Formula_05_001.png" alt="" width="34" height="41"/> of a system with respect to the state <a id="_idIndexMarker476"/>of an arbitrary wave function (<img src="Images/Formula_05_002.png" alt="" width="38" height="35"/>) is always an upper bound to the exact ground state energy <img src="Images/Formula_05_003.png" alt="" width="47" height="45"/> of the system it describes:</p>
			<div>
				<div id="_idContainer1409" class="IMG---Figure">
					<img src="Images/Formula_05_004.jpg" alt="" width="528" height="150"/>
				</div>
			</div>
			<p>where <img src="Images/Formula_05_005.png" alt="" width="22" height="23"/> generally represents time, spatial, and spin variables. This formula is not assuming any particular chemical setup nor reference frame. </p>
			<p>We now <a id="_idIndexMarker477"/>give a proof of this theorem for the <a id="_idIndexMarker478"/>general Hamiltonian, which is represented by the discretized Hermitian operator <img src="Images/Formula_05_006.png" alt="" width="34" height="42"/> [Toulouse]. Recall that, according to the spectral theorem introduced in <em class="italic">Section 2.3.1, Hermitian operator</em>, <img src="Images/Formula_05_007.png" alt="" width="34" height="42"/> must have a set of orthonormal eigenvectors <img src="Images/Formula_05_008.png" alt="" width="476" height="56"/> with real eigenvalues <img src="Images/Formula_05_009.png" alt="" width="41" height="46"/>, <img src="Images/Formula_05_010.png" alt="" width="275" height="55"/> which form an orthonormal basis of the Hilbert space, and that <img src="Images/Formula_05_006.png" alt="" width="34" height="42"/> has a unique spectral representation in this basis:</p>
			<div>
				<div id="_idContainer1417" class="IMG---Figure">
					<img src="Images/Formula_05_012.jpg" alt="" width="407" height="171"/>
				</div>
			</div>
			<p>We can index the orthonormal eigenvectors of <img src="Images/Formula_05_006.png" alt="" width="34" height="42"/> in increasing order of energy, <img src="Images/Formula_05_014.png" alt="" width="366" height="45"/> and decompose any state <img src="Images/Formula_05_015.png" alt="" width="69" height="50"/> in this basis:</p>
			<div>
				<div id="_idContainer1421" class="IMG---Figure">
					<img src="Images/Formula_05_016.jpg" alt="" width="408" height="168"/>
				</div>
			</div>
			<p>with coefficients <img src="Images/Formula_05_017.png" alt="" width="231" height="48"/> and the normalization constraint:</p>
			<div>
				<div id="_idContainer1423" class="IMG---Figure">
					<img src="Images/Formula_05_018.jpg" alt="" width="597" height="171"/>
				</div>
			</div>
			<p>Noting that the complex conjugate transpose is:</p>
			<div>
				<div id="_idContainer1424" class="IMG---Figure">
					<img src="Images/Formula_05_019.jpg" alt="" width="954" height="166"/>
				</div>
			</div>
			<p>We compute the expectation value:</p>
			<div>
				<div id="_idContainer1425" class="IMG---Figure">
					<img src="Images/Formula_05_020.jpg" alt="" width="1472" height="161"/>
				</div>
			</div>
			<p>The minimum <a id="_idIndexMarker479"/>of this expression <img src="Images/Formula_05_021.png" alt="" width="47" height="46"/> is <a id="_idIndexMarker480"/>reached for <img src="Images/Formula_05_022.png" alt="" width="125" height="44"/> and <img src="Images/Formula_05_023.png" alt="" width="128" height="44"/> for all <img src="Images/Formula_05_024.png" alt="" width="113" height="38"/> that is for <img src="Images/Formula_05_025.png" alt="" width="213" height="49"/>. Hence:</p>
			<div>
				<div id="_idContainer1431" class="IMG---Figure">
					<img src="Images/Formula_05_026.jpg" alt="" width="654" height="123"/>
				</div>
			</div>
			<p>To find the minimum, one can find the first and second derivative of the expression with respect to the parameters of the wave function. This setup for the variational theorem holds true for the electronic molecular Hamiltonian (<img src="Images/Formula_05_027.png" alt="" width="97" height="53"/>).</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor215"/>5.1.2. Variational Monte Carlo methods</h2>
			<p>The <strong class="bold">variational Monte Carlo</strong> (<strong class="bold">VMC</strong>) method is based on the Rayleigh-Ritz variational theorem [Chen] [Gorelov] [Toulouse_1] [Cao] [Dagrada] and Monte Carlo integration methods [Pease], noting <a id="_idIndexMarker481"/>that the expectation <a id="_idIndexMarker482"/>value can be rewritten in the form:</p>
			<div>
				<div id="_idContainer1433" class="IMG---Figure">
					<img src="Images/Formula_05_028.jpg" alt="" width="720" height="125"/>
				</div>
			</div>
			<p>We separate the integral into a probability distribution:</p>
			<div>
				<div id="_idContainer1434" class="IMG---Figure">
					<img src="Images/Formula_05_029.jpg" alt="" width="318" height="118"/>
				</div>
			</div>
			<p>and an observable:</p>
			<div>
				<div id="_idContainer1435" class="IMG---Figure">
					<img src="Images/Formula_05_030.jpg" alt="" width="308" height="51"/>
				</div>
			</div>
			<p>which enables us to write the energy in the form of an average:</p>
			<div>
				<div id="_idContainer1436" class="IMG---Figure">
					<img src="Images/Formula_05_031.jpg" alt="" width="390" height="101"/>
				</div>
			</div>
			<p>Now we apply an approximation <a id="_idIndexMarker483"/>to the <img src="Images/Formula_05_032.png" alt="" width="56" height="45"/> formula, which is called the <strong class="bold">Metropolis-Hastings</strong> (<strong class="bold">MH</strong>) algorithm [Chen] [Toulouse1]. To perform the approximation mathematically, we sample a set of <img src="Images/Formula_05_033.png" alt="" width="41" height="34"/> points <img src="Images/Formula_05_034.png" alt="" width="334" height="49"/> from <a id="_idIndexMarker484"/>the probability distribution <img src="Images/Formula_05_035.png" alt="" width="97" height="46"/> and <a id="_idIndexMarker485"/>we evaluate the local energy at each point <img src="Images/Formula_05_036.png" alt="" width="116" height="48"/> , hence:</p>
			<div>
				<div id="_idContainer1442" class="IMG---Figure">
					<img src="Images/Formula_05_037.jpg" alt="" width="373" height="163"/>
				</div>
			</div>
			<p>In practice, we can use a flexible explicitly correlated wave function <img src="Images/Formula_05_038.png" alt="" width="47" height="38"/></p>
			<p>We now give an illustration of <a id="_idIndexMarker486"/>the MH algorithm with Python code from Ref. [Stephens]. The MH algorithm is a <strong class="bold">Markov chain Monte Carlo</strong> (<strong class="bold">MCMC</strong>) method for producing samples from a probability distribution that we will call the target probability distribution. It works by simulating a Markov chain, whose stationary distribution is the target probability distribution. <strong class="bold">Markov chain theory</strong> is used to describe <a id="_idIndexMarker487"/>polymerization type reactions that are <a id="_idIndexMarker488"/>prominent in chemistry, chemical engineering, and in biology and medicine, such as the <strong class="bold">polymerase chain reaction</strong> (<strong class="bold">PCR</strong>) [Tamir].</p>
			<p>We want to sample from the following probability distribution:</p>
			<div>
				<div id="_idContainer1444" class="IMG---Figure">
					<img src="Images/Formula_05_039.jpg" alt="" width="466" height="99"/>
				</div>
			</div>
			<p>We implement the MH algorithm with a “random walk” kernel, <img src="Images/Formula_05_040.png" alt="" width="300" height="47"/>, where <img src="Images/Formula_02_005.png" alt="" width="34" height="34"/> is the normal distribution, and the following acceptance probability:</p>
			<div>
				<div id="_idContainer1447" class="IMG---Figure">
					<img src="Images/Formula_05_042.jpg" alt="" width="390" height="117"/>
				</div>
			</div>
			<p>Here is the code:</p>
			<p class="source-code">n = 10000 # Size of the Markov chain stationary distribution</p>
			<p class="source-code"># Use np.linspace to create an array of n numbers between 0 and n</p>
			<p class="source-code">index = np.linspace(0, n, num=n)</p>
			<p class="source-code">x = np.linspace(0, n, num=n)</p>
			<p class="source-code">x[0] = 3     # Initialize to 3</p>
			<p class="source-code">for i in range(1, n):</p>
			<p class="source-code">  current_x = x[i-1]</p>
			<p class="source-code">  # We add a N(0,1) random number to x</p>
			<p class="source-code">  proposed_x = current_x + stats.norm.rvs(loc=0, scale=1, size=1, random_state=None)</p>
			<p class="source-code">  A = min(1, p(proposed_x)/p(current_x))</p>
			<p class="source-code">  r = np.random.uniform(0,1) # Generate a uniform random number in [0, 1]</p>
			<p class="source-code">  if r &lt; A:</p>
			<p class="source-code">    x[i] = proposed_x       # Accept move with probabilty min(1,A)</p>
			<p class="source-code">  else:</p>
			<p class="source-code">    x[i] = current_x        # Otherwise “reject” move, and stay where we are</p>
			<p>We plot <a id="_idIndexMarker489"/>the locations visited by the Markov <a id="_idIndexMarker490"/>chain <img src="Images/Formula_05_043.png" alt="" width="25" height="24"/>:</p>
			<p class="source-code">plt.plot(index, x, label=”Trace plot”)</p>
			<p class="source-code">plt.xlabel('Index')</p>
			<p class="source-code">plt.ylabel('MH value')</p>
			<p class="source-code">plt.legend()</p>
			<p class="source-code">plt.show()</p>
			<p><em class="italic">Figure 5.2</em> shows the result:</p>
			<div>
				<div id="_idContainer1449" class="IMG---Figure">
					<img src="Images/B18268_Figure_5.2.jpg" alt="" width="498" height="262"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2 – Plot of the locations visited by the Markov chain <img src="Images/Formula_05_044.png" alt="" width="25" height="24"/></p>
			<p>We use the Freedman–Diaconis rule to select the “right” bin width to be used in a histogram [Bushmanov] [Freeman]:</p>
			<p class="source-code">q25, q75 = np.percentile(x, [25, 75])</p>
			<p class="source-code">bin_width = 2 * (q75 - q25) * len(x) ** (-1/3)</p>
			<p class="source-code">bins = round((x.max() - x.min()) / bin_width)</p>
			<p class="source-code">print(“Freedman–Diaconis number of bins:”, bins)</p>
			<p>Here <a id="_idIndexMarker491"/>is the result:</p>
			<p class="source-code">Freedman–Diaconis number of bins: 109</p>
			<p>We plot <a id="_idIndexMarker492"/>the histogram of the Markov chain <img src="Images/Formula_05_045.png" alt="" width="25" height="24"/>:</p>
			<p class="source-code">plt.hist(x, density=True, bins=bins)</p>
			<p class="source-code">plt.ylabel('Density')</p>
			<p class="source-code">plt.xlabel('x');</p>
			<p><em class="italic">Figure 5.3</em> shows the result:</p>
			<div>
				<div id="_idContainer1452" class="IMG---Figure">
					<img src="Images/B18268_Figure_5.3.jpg" alt="" width="519" height="262"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3 – Histogram of the Markov chain <img src="Images/Formula_05_046.png" alt="" width="25" height="24"/></p>
			<p>We see that the histogram of values of the Markov chain <img src="Images/Formula_05_047.png" alt="" width="25" height="24"/> is a good approximation to the distribution <img src="Images/Formula_05_048.png" alt="" width="91" height="46"/> defined previously.</p>
			<p>We now define the <strong class="source-inline">run_PySCF()</strong> function, which computes the energy of the ground state with <a id="_idIndexMarker493"/>the PySCF RHF method and with <a id="_idIndexMarker494"/>the <strong class="source-inline">OPTIMIZE</strong> function in the PyQMC Python module that implements real-space variational Monte Carlo techniques [PyQMC]. It has the following parameters:</p>
			<ul>
				<li><strong class="source-inline">molecule</strong>, the geometry of the molecule, defined with the Qiskit <strong class="source-inline">Molecule</strong> class</li>
				<li><strong class="source-inline">pyqmc</strong>, set to <strong class="source-inline">True</strong> by default to run the PyQMC Python module</li>
				<li><strong class="source-inline">show</strong>, set to <strong class="source-inline">True</strong> by default to display intermediate results</li>
				<li>Here is the definition of the <strong class="source-inline">run_PySCF()</strong> function:</li>
			</ul>
			<p class="source-code">def run_PySCF(molecule, pyqmc=True, show=True):</p>
			<p>We now present the code that is contained in this <strong class="source-inline">run_PySCF()</strong> function. First, we reset the files:</p>
			<p class="source-code">  # Reset the files</p>
			<p class="source-code">  for fname in ['mf.hdf5','optimized_wf.hdf5']:</p>
			<p class="source-code">    if os.path.isfile(fname):</p>
			<p class="source-code">        os.remove(fname)</p>
			<ul>
				<li>Then we construct a PySCF molecular geometry from the molecule passed as an input parameter:</li>
			</ul>
			<p class="source-code">  mol_PySCF = gto.M(atom = [“ “.join(map(str, (name, *coord))) for (name, coord) in molecule.geometry])</p>
			<ul>
				<li>We run <a id="_idIndexMarker495"/>the PySCF RHF method:</li>
			</ul>
			<p class="source-code">  mf = scf.RHF(mol_PySCF)</p>
			<p class="source-code">  mf.chkfile = “mf.hdf5”</p>
			<p class="source-code">  </p>
			<p class="source-code">  conv, e, mo_e, mo, mo_occ = scf.hf.kernel(mf)</p>
			<p class="source-code">  if show:</p>
			<p class="source-code">    if conv:</p>
			<p class="source-code">      print(“PySCF restricted HF (RHF) converged ground-state energy: {:.12f}”.format(e))</p>
			<p class="source-code">    else:</p>
			<p class="source-code">      print(“PySCF restricted HF (RHF) ground-state computation failed to converge”)</p>
			<ul>
				<li>Next, we <a id="_idIndexMarker496"/>run the <strong class="source-inline">OPTIMIZE</strong> function in the PyQMC Python module:</li>
			</ul>
			<p class="source-code">  if pyqmc:</p>
			<p class="source-code">    pyq.OPTIMIZE(“mf.hdf5”,# Construct a Slater-Jastrow wave function from the pyscf output</p>
			<p class="source-code">      “optimized_wf.hdf5”, # Store optimized parameters in this file.</p>
			<p class="source-code">      nconfig=100,         # Optimize using this many Monte Carlo samples/configurations</p>
			<p class="source-code">      max_iterations=4,    # 4 optimization steps</p>
			<p class="source-code">      verbose=False)</p>
			<ul>
				<li>We read the content of the HDF5 file, which contains the optimized parameters, and if the PyQMC variational Monte Carlo computation converged, then we print the energy for each iteration:</li>
			</ul>
			<p class="source-code">    with h5py.File(“optimized_wf.hdf5”) as f:</p>
			<p class="source-code">      iter = f['iteration']</p>
			<p class="source-code">      energy = f['energy']</p>
			<p class="source-code">      error = f['energy_error']</p>
			<p class="source-code">      l = energy.shape[0]</p>
			<p class="source-code">      e = energy[l-1]</p>
			<p class="source-code">      err = error[l-1]</p>
			<p class="source-code">      if show:</p>
			<p class="source-code">        if err &lt; 0.1:</p>
			<p class="source-code">          print(“Iteration, Energy, Error”)</p>
			<p class="source-code">          for k in iter:</p>
			<p class="source-code">            print(“{}:         {:.4f} {:.4f}”.format(k, energy[k], error[k]))</p>
			<p class="source-code">          print(“PyQMC Monte Carlo converged ground-state energy: {:.12f}, error: {:.4f}”.format(e, err))</p>
			<p class="source-code">        else:</p>
			<p class="source-code">          print(“PyQMC Monte Carlo failed to converge”)</p>
			<p>Finally, we let <a id="_idIndexMarker497"/>the <strong class="source-inline">run_PySCF()</strong> function <a id="_idIndexMarker498"/>return the following parameters to the caller:</p>
			<ul>
				<li><strong class="source-inline">conv</strong>, <strong class="source-inline">Boolean</strong>, set to <strong class="source-inline">True</strong> if the PySCF RHF method converged</li>
				<li><strong class="source-inline">e</strong>, the energy of the ground state</li>
				<li>Here is the <strong class="source-inline">return</strong> statement:</li>
			</ul>
			<p class="source-code">return conv, e</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor216"/>5.1.3. Quantum Phase Estimation (QPE)</h2>
			<p>In quantum chemistry, we need very accurate calculations of the total electronic energy of each molecule <a id="_idIndexMarker499"/>species involved in a chemical reaction [Burg]. The <strong class="bold">Quantum Phase Estimation</strong> (<strong class="bold">QPE</strong>) algorithm has a unique feature <a id="_idIndexMarker500"/>that it allows a bounded-error simulation of quantum systems, which makes it one of the most promising applications of future fault-tolerant quantum computing. Given a unitary operator <img src="Images/Formula_05_049.png" alt="" width="31" height="32"/>, its eigenstate and eigenvalues, <img src="Images/Formula_05_050.png" alt="" width="322" height="54"/>, the ability to prepare a state <img src="Images/Formula_05_051.png" alt="" width="66" height="51"/>, and the ability to apply <img src="Images/Formula_05_052.png" alt="" width="31" height="33"/> itself, the QPE algorithm calculates <img src="Images/Formula_05_053.png" alt="" width="78" height="38"/>, where <img src="Images/Formula_02_247.png" alt="" width="28" height="26"/> is the number of qubits used to estimate <img src="Images/Formula_05_055.png" alt="" width="24" height="35"/> thereby allowing measurement of <img src="Images/Formula_05_055.png" alt="" width="24" height="35"/> as precisely as we want.</p>
			<p>Recall that in <em class="italic">Section 2.5, Postulate 5 – Time evolution dynamics</em>, we saw that time evolution dynamics of a quantum system is described by Schrödinger's equation:</p>
			<div>
				<div id="_idContainer1464" class="IMG---Figure">
					<img src="Images/Formula_05_057.jpg" alt="" width="321" height="104"/>
				</div>
			</div>
			<p>For a time-independent Hamiltonian <img src="Images/Formula_05_058.png" alt="" width="34" height="41"/> with initial condition <img src="Images/Formula_05_059.png" alt="" width="147" height="52"/>, the solution is:</p>
			<div>
				<div id="_idContainer1467" class="IMG---Figure">
					<img src="Images/Formula_05_060.jpg" alt="" width="411" height="51"/>
				</div>
			</div>
			<p>where <img src="Images/Formula_05_061.png" alt="" width="349" height="84"/> is the unitary time-evolution operator. Further recall that any unitary matrix has eigenvalues of the form <img src="Images/Formula_05_062.png" alt="" width="59" height="48"/>. An eigenvalue of <img src="Images/Formula_05_063.png" alt="" width="91" height="48"/> is also an eigenvalue of <img src="Images/Formula_05_064.png" alt="" width="34" height="43"/>.</p>
			<p><a id="_idTextAnchor217"/>We now <a id="_idIndexMarker501"/>illustrate the use of the <a id="_idIndexMarker502"/>Qiskit <strong class="source-inline">PhaseEstimation</strong> class. First, we define a function <img src="Images/Formula_05_065.png" alt="" width="97" height="47"/>, which creates a quantum circuit with a single qubit <img src="Images/Formula_05_066.png" alt="" width="78" height="52"/> and applies the following unitary:</p>
			<div>
				<div id="_idContainer1474" class="IMG---Figure">
					<img src="Images/Formula_05_067.jpg" alt="" width="691" height="58"/>
				</div>
			</div>
			<p>where <img src="Images/Formula_05_068.png" alt="" width="88" height="48"/> is the gate we introduced in <em class="italic">Section 3.2.1, Single qubit quantum gates</em>, which has the matrix form:</p>
			<div>
				<div id="_idContainer1476" class="IMG---Figure">
					<img src="Images/Formula_05_069.jpg" alt="" width="318" height="91"/>
				</div>
			</div>
			<p>Here is the code:</p>
			<p class="source-code">def U(theta):</p>
			<p class="source-code">  unitary = QuantumCircuit(1)</p>
			<p class="source-code">  unitary.p(np.pi*2*theta, 0)</p>
			<p class="source-code">  return unitary</p>
			<p>We define the <strong class="source-inline">do_qpe()</strong> function, which illustrates the use of the Qiskit Nature <strong class="source-inline">PhaseEstimation</strong> class, and which has three parameters:</p>
			<ul>
				<li><strong class="source-inline">unitary</strong>, a function that implements a unitary</li>
				<li><strong class="source-inline">nqubits</strong>, the number of qubits, by default <strong class="source-inline">3</strong></li>
				<li><strong class="source-inline">show</strong>, set to <strong class="source-inline">True</strong> by default to display the phase returned by <strong class="source-inline">PhaseEstimation</strong> class</li>
			</ul>
			<p>Here is the code:</p>
			<p class="source-code">def do_qpe(unitary, nqubits=3, show=True):</p>
			<p class="source-code">  state_in = QuantumCircuit(1)</p>
			<p class="source-code">  state_in.x(0)</p>
			<p class="source-code">  pe = PhaseEstimation(num_evaluation_qubits=nqubits, quantum_instance=quantum_instance)</p>
			<p class="source-code">  result = pe.estimate(unitary, state_in)</p>
			<p class="source-code">  phase_out = result.phase</p>
			<p class="source-code">  if show:</p>
			<p class="source-code">    print(“Number of qubits: {}, QPE phase estimate: {}”.format(nqubits, phase_out))</p>
			<p class="source-code">  return(phase_out)</p>
			<p>First, we <a id="_idIndexMarker503"/>run a test of accuracy <a id="_idIndexMarker504"/>with three qubits:</p>
			<p class="source-code">quantum_instance = QuantumInstance(backend = Aer.get_backend('aer_simulator_statevector'))</p>
			<p class="source-code">theta = 1/2 + 1/4 + 1/8</p>
			<p class="source-code">print(“theta: {}”.format(theta))</p>
			<p class="source-code">unitary = U(theta)</p>
			<p class="source-code">result = do_qpe(unitary, nqubits=3)</p>
			<p>Here is the result:</p>
			<p class="source-code">theta: 0.875</p>
			<p class="source-code">Number of qubits: 3, QPE phase estimate: 0.875 </p>
			<p>Next, we run a test of accuracy with eight qubits:</p>
			<p class="source-code">theta = 1/2 + 1/4 + 1/8 + 1/16 + 1/32 + 1/64 + 1/128 + 1/256</p>
			<p class="source-code">print(“theta: {}”.format(theta))</p>
			<p class="source-code">unitary = U(theta)</p>
			<p class="source-code">result = do_qpe(unitary, nqubits=8)</p>
			<p>Here is the result:</p>
			<p class="source-code">theta: 0.99609375</p>
			<p class="source-code">Number of qubits: 8, QPE phase estimate: 0.99609375 </p>
			<p>We see that we can get an estimate of the phase with a bounded error from the true phase by increasing the number of qubits that the <strong class="source-inline">PhaseEstimation</strong> class is allowed to use.</p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor218"/>5.1.4. Description of the VQE algorithm</h2>
			<p>In a loop, a classical computer optimizes the parameters of a quantum circuit with respect to an objective function, such as finding the ground state of a molecule, which is the state with the <a id="_idIndexMarker505"/>lowest energy. The parameterized quantum circuit prepares a trial quantum state as a trial solution (an ansatz). By repeatedly measuring qubits at the output of the quantum circuit, we get the expectation value of the energy observable with respect to the trial state.</p>
			<p>The VQE algorithm provides an estimate of the ground state of a given quantum system encoded as a Hamiltonian <img src="Images/Formula_05_070.png" alt="" width="34" height="41"/>, the state of the system with the lowest energy <img src="Images/Formula_05_071.png" alt="" width="47" height="47"/>, for instance, the ground state energy of a molecule. It involves an iterative minimization of the expectation value <img src="Images/Formula_05_072.png" alt="" width="106" height="53"/> of the energy observable with respect to the parametrized (<img src="Images/Formula_05_073.png" alt="" width="25" height="38"/>) trial state <img src="Images/Formula_05_074.png" alt="" width="131" height="49"/>:</p>
			<div>
				<div id="_idContainer1482" class="IMG---Figure">
					<img src="Images/Formula_05_075.jpg" alt="" width="563" height="59"/>
				</div>
			</div>
			<p>As shown in <em class="italic">Section 3.1.6, Pauli matrices</em>, we can decompose the Hamiltonian <img src="Images/Formula_05_006.png" alt="" width="34" height="42"/> into the weighted sum of <img src="Images/Formula_05_077.png" alt="" width="41" height="33"/> tensor products <img src="Images/Formula_05_078.png" alt="" width="250" height="60"/>, where <img src="Images/Formula_05_079.png" alt="" width="363" height="61"/> with weights <img src="Images/Formula_05_080.png" alt="" width="44" height="38"/> and <img src="Images/Formula_05_081.png" alt="" width="34" height="33"/> qubits:</p>
			<div>
				<div id="_idContainer1489" class="IMG---Figure">
					<img src="Images/Formula_05_082.jpg" alt="" width="612" height="154"/>
				</div>
			</div>
			<p>Hence the expectation value of the energy observable <img src="Images/Formula_05_083.png" alt="" width="106" height="54"/> can be rewritten as follows:</p>
			<div>
				<div id="_idContainer1491" class="IMG---Figure">
					<img src="Images/Formula_05_084.jpg" alt="" width="1575" height="156"/>
				</div>
			</div>
			<p>We prepare a trial state <img src="Images/Formula_05_085.png" alt="" width="131" height="48"/> with the set of parameters <img src="Images/Formula_05_086.png" alt="" width="366" height="49"/> with a quantum circuit initialized in the state <img src="Images/Formula_05_087.png" alt="" width="119" height="53"/>, and represented by <img src="Images/Formula_05_088.png" alt="" width="97" height="46"/>, which outputs the state <img src="Images/Formula_05_089.png" alt="" width="406" height="53"/>.</p>
			<p>By transposing the complex conjugate, <img src="Images/Formula_05_090.png" alt="" width="363" height="60"/>, we can rewrite the expectation value of the energy observable <img src="Images/Formula_05_091.png" alt="" width="109" height="54"/> as follows:</p>
			<div>
				<div id="_idContainer1499" class="IMG---Figure">
					<img src="Images/Formula_05_092.jpg" alt="" width="942" height="62"/>
				</div>
			</div>
			<p>and then by taking the sum out to the front:</p>
			<div>
				<div id="_idContainer1500" class="IMG---Figure">
					<img src="Images/Formula_05_093.jpg" alt="" width="1377" height="157"/>
				</div>
			</div>
			<p>For each <img src="Images/Formula_05_094.png" alt="" width="56" height="45"/> we run the quantum circuit <img src="Images/Formula_05_095.png" alt="" width="97" height="47"/> followed by rotations <img src="Images/Formula_05_096.png" alt="" width="563" height="49"/> depending on <img src="Images/Formula_05_097.png" alt="" width="47" height="46"/> before measuring the qubits in the Z basis <a id="_idIndexMarker506"/>so that we effectively measure the output state in the basis of the eigenvectors of <img src="Images/Formula_05_098.png" alt="" width="47" height="45"/> to get the expectation value <img src="Images/Formula_05_099.png" alt="" width="313" height="47"/> with respect to the output state <img src="Images/Formula_05_100.png" alt="" width="406" height="52"/>.</p>
			<p>On a classical computer, we compute the weighted sum of the expectation values <img src="Images/Formula_05_101.png" alt="" width="313" height="47"/> with weights <img src="Images/Formula_02_417.png" alt="" width="44" height="38"/> to get the expectation value <img src="Images/Formula_05_103.png" alt="" width="109" height="53"/> with respect to the output state <img src="Images/Formula_05_104.png" alt="" width="131" height="48"/>. We update the set of parameters <img src="Images/Formula_05_105.png" alt="" width="25" height="36"/> using a classical optimization routine, minimizing the expectation value <img src="Images/Formula_05_106.png" alt="" width="109" height="53"/> until convergence in the value of the energy or the maximum allowable number of iterations is reached. The parameters <img src="Images/Formula_05_107.png" alt="" width="91" height="45"/> at convergence define approximately the ground state <img src="Images/Formula_05_108.png" alt="" width="197" height="50"/> of the quantum system encoded into a Hamiltonian <img src="Images/Formula_05_109.png" alt="" width="31" height="44"/> with the lowest energy <img src="Images/Formula_05_110.png" alt="" width="653" height="62"/>. The algorithm is summarized in <em class="italic">Figure 5.4</em>.</p>
			<div>
				<div id="_idContainer1518" class="IMG---Figure">
					<img src="Images/B18268_Figure_5.4.jpg" alt="" width="972" height="257"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.4 – VQE algorithm</p>
			<h3>Trial wave functions</h3>
			<p>The <strong class="bold">Coupled-Cluster</strong> (<strong class="bold">CC</strong>) theory constructs a multi-electron wave function (<img src="Images/Formula_05_111.png" alt="" width="38" height="35"/>) using the exponential <a id="_idIndexMarker507"/>cluster operator <img src="Images/Formula_05_112.png" alt="" width="384" height="54"/>, where <img src="Images/Formula_05_113.png" alt="" width="44" height="58"/> is the <a id="_idIndexMarker508"/>operator for all single excitations, <img src="Images/Formula_05_114.png" alt="" width="44" height="55"/> is the operator for all double <a id="_idIndexMarker509"/>excitations, and so on. We start the VQE with the following <strong class="bold">unitary Coupled-Cluster</strong> (<strong class="bold">UCC</strong>) ansatz of the quantum state <img src="Images/Formula_05_115.png" alt="" width="131" height="48"/> with variational parameter <img src="Images/Formula_05_116.png" alt="" width="24" height="37"/> [Panagiotis] [Lolur]:</p>
			<div>
				<div id="_idContainer1525" class="IMG---Figure">
					<img src="Images/Formula_05_117.jpg" alt="" width="528" height="71"/>
				</div>
			</div>
			<p>where <img src="Images/Formula_05_118.png" alt="" width="122" height="62"/> is the Hartree-Fock ground state. In the UCC method restricted to the extension to single and double excitations (UCCSD), the operators <img src="Images/Formula_05_119.png" alt="" width="44" height="58"/> and <img src="Images/Formula_05_120.png" alt="" width="44" height="57"/> can be expanded as follows:</p>
			<div>
				<div id="_idContainer1529" class="IMG---Figure">
					<img src="Images/Formula_05_121.jpg" alt="" width="439" height="147"/>
				</div>
			</div>
			<div>
				<div id="_idContainer1530" class="IMG---Figure">
					<img src="Images/Formula_05_122.jpg" alt="" width="603" height="143"/>
				</div>
			</div>
			<p>where:</p>
			<ul>
				<li><img src="Images/Formula_05_123.png" alt="" width="59" height="63"/> is the fermionic creation operator introduced in <em class="italic">Section 4.3.1, Fermion creation operator</em></li>
				<li><img src="Images/Formula_05_124.png" alt="" width="41" height="50"/> is the fermionic annihilation operator introduced in Section <em class="italic">4.3.2, Fermion annihilation operator</em></li>
				<li><img src="Images/Formula_05_125.png" alt="" width="28" height="42"/> is the set of parameters for all expansion coefficients.</li>
			</ul>
			<p>The UCCSD ansatz of the <a id="_idIndexMarker510"/>quantum state <img src="Images/Formula_05_126.png" alt="" width="131" height="45"/> is then mapped to qubit operators with the Jordan-Wigner (JW), the Parity, or the Bravyi-Kitaev (BK) transformation introduced in <em class="italic">Section 4.7, Fermion to qubit mappings,</em> resulting in an initial qubit state vector for the VQE calculation.</p>
			<h3>Setting up the VQE solver</h3>
			<p>We set up a <a id="_idIndexMarker511"/>noise-free simulation with the Qiskit Aer state vector simulator backend:</p>
			<p class="source-code">quantum_instance = QuantumInstance(backend = Aer.get_backend('aer_simulator_statevector'))</p>
			<p>Now we set up solving methods. To learn how to train circuit-based variational models, check Ref. [Qiskit_2021_Lab4]. First, we set up the NumPy minimum eigensolver as follows:</p>
			<p class="source-code">numpy_solver = NumPyMinimumEigensolver()</p>
			<p>We set up the Two-Local circuit [Panagiotis] as follows:</p>
			<p class="source-code">tl_circuit = TwoLocal(rotation_blocks = ['h', 'rx'], entanglement_blocks = 'cz',</p>
			<p class="source-code">                      entanglement='full', reps=2, parameter_prefix = 'y')</p>
			<p>We set up <a id="_idIndexMarker512"/>the VQE using a heuristic ansatz, the Two-Local circuit with the default <strong class="bold">Sequential Least Squares Programming (SLSQP)</strong> optimizer:</p>
			<p class="source-code">vqe_tl_solver = VQE(ansatz = tl_circuit,</p>
			<p class="source-code">                     quantum_instance = QuantumInstance(Aer.get_backend('aer_simulator_statevector')))</p>
			<p>Then we set up a solver with the <strong class="bold">Unitary Coupled Cluster</strong> (<strong class="bold">UCC</strong>) factory. It allows a fast initialization <a id="_idIndexMarker513"/>of a VQE initializing the qubits in the Hartree-Fock state and using the quantum UCC with singles and doubles (q-UCCSD), a popular wave function ansatz [VQE_2] [VQE_3]. Here is the code:</p>
			<p class="source-code">vqe_ucc_solver = VQEUCCFactory(quantum_instance, ansatz=tl_ circuit)</p>
			<p>We set up a <a id="_idIndexMarker514"/>callback function, <strong class="source-inline">qnspsa_callback()</strong>, for the <strong class="bold">Quantum Natural SPSA</strong> (<strong class="bold">QN-SPSA</strong>) optimizer, which appends results to the loss <a id="_idIndexMarker515"/>array <strong class="source-inline">qnspsa_loss</strong>:</p>
			<p class="source-code">qnspsa_loss = []</p>
			<p class="source-code">def qnspsa_callback(nfev, x, fx, stepsize, accepted):</p>
			<p class="source-code">    qnspsa_loss.append(fx)</p>
			<p>Now we are ready to show some examples.</p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor219"/>5.2. Example chemical calculations</h1>
			<p>As discussed in <a href="B18268_04_ePub.xhtml#_idTextAnchor153"><em class="italic">Chapter 4</em></a><em class="italic">, Molecular Hamiltonians</em>, approximating the PES of nuclear motion occurs <a id="_idIndexMarker516"/>due to the use of the BO approximation. We can use a semi-empirical method of approximating the PES through experimental data and/or computer simulations.</p>
			<p>The PES can be compared to a landscape with mountains and valleys. In practice, as chemists, we want to find the global minimum (ocean floor) not local minima (mountain meadows) of the PES, as seen in <em class="italic">Figure 5.1</em>. We use the variational method, both classical and quantum, to find the global minimum. This can be compared to a ball rolling around the landscape. If we give the ball a nudge in some direction, generally downward, the ball will wind up in the minimum. We call this gradient descent. The gradient descent can be supplied by numerically changing input values or by an analytic formula of the wave function that describes the PES.</p>
			<p>To state that calculation of determining the PES we guess a trial wave function, which can be optimized in the calculation to enable us to find the global minimum of the energy. We call this global minimum the lowest energy possible for a given eigenvalue.</p>
			<p>We present several implementations of solving for the ground state and plotting the BOPES of three molecules with the classical PySCF RHF, PyQMC variational Monte Carlo, the QPE, and the VQE with Qiskit Nature using the STO-3G basis with the PySCF driver.</p>
			<p>In this section, we cover the following topics:</p>
			<ul>
				<li><em class="italic">Section 5.2.1, Hydrogen molecule</em></li>
				<li><em class="italic">Section 5.2.2, Lithium hydride molecule</em></li>
				<li><em class="italic">Section 5.2.3, Macro molecule</em></li>
			</ul>
			<p>We use the <strong class="source-inline">get_particle_number()</strong> function defined in <em class="italic">Section 4.6.1, Constructing a fermionic Hamiltonian operator of the hydrogen molecule</em>, which gets the particle <a id="_idIndexMarker517"/>number property of a given electronic structure problem.</p>
			<p>We use the <strong class="source-inline">fermion_to_qubit()</strong> function defined in <em class="italic">Section 4.8, Constructing a qubit Hamiltonian with Qiskit Nature,</em> to <a id="_idIndexMarker518"/>convert a fermionic operator to a qubit operator. It has the following input parameters:</p>
			<ul>
				<li><strong class="source-inline">f_op</strong>, a fermionic operator <a id="_idIndexMarker519"/>obtained as explained in <em class="italic">Section 4.6, Constructing a fermionic Hamiltonian with Qiskit Nature</em></li>
				<li><strong class="source-inline">mapper</strong>, either <strong class="source-inline">“Jordan-Wigner”</strong> or <strong class="source-inline">“Parity”</strong> or <strong class="source-inline">“Bravyi-Kitaev”</strong></li>
				<li><strong class="source-inline">truncate</strong>, an integer to truncate Pauli list by default set to 20 items</li>
				<li><strong class="source-inline">two_qubit_reduction</strong>, a Boolean, by default <strong class="source-inline">False</strong>, that determines whether to carry out two-qubit reduction when possible</li>
				<li><strong class="source-inline">z2symmetry_reduction</strong>, by default <strong class="source-inline">None</strong>, that indicates whether a Z2 symmetry reduction should be applied to resulting qubit operators that are computed based on mathematical symmetries that can be detected in the operator [de Keijzer]</li>
				<li><strong class="source-inline">show</strong>, set to <strong class="source-inline">True</strong> by default to display the name of the transformation and results</li>
			</ul>
			<p>Qiskit Nature provides a class called <strong class="source-inline">GroundStateEigensolver</strong> to calculate the ground state of a molecule. We define the <strong class="source-inline">run_vqe()</strong> function, which has the following input parameters:</p>
			<ul>
				<li><strong class="source-inline">name</strong>, a string of characters to be printed, such as<strong class="source-inline"> 'NumPy exact solver'</strong></li>
				<li><strong class="source-inline">f_op</strong>, a fermionic operator obtained as explained in <em class="italic">Section 4, Constructing a fermionic Hamiltonian with Qiskit Nature</em></li>
				<li><strong class="source-inline">qubit_converter</strong>, either <strong class="source-inline">JordanWignerMapper()</strong>, <strong class="source-inline">ParityMapper()</strong>, or <strong class="source-inline">BravyiKitaevMapper()</strong>, which is the output of the <strong class="source-inline">fermion_to_qubit()</strong> function</li>
				<li><strong class="source-inline">solver</strong>, either one of the solvers defined in <em class="italic">Section 5.2.3, Setting up the VQE solver</em>, <strong class="source-inline">numpy_solver</strong>, <strong class="source-inline">vqe_ucc_solver</strong>, or <strong class="source-inline">vqe_tl_solver</strong>.</li>
			</ul>
			<p>Here is <a id="_idIndexMarker520"/>the code:</p>
			<p class="source-code">def run_vqe(name, f_op, qubit_converter, solver, show=True):</p>
			<p class="source-code">  calc = GroundStateEigensolver(qubit_converter, solver)</p>
			<p class="source-code">  start = time.time()</p>
			<p class="source-code">  ground_state = calc.solve(f_op)</p>
			<p class="source-code">  elapsed = str(datetime.timedelta(seconds = time.time()-start))</p>
			<p class="source-code">  if show:</p>
			<p class="source-code">    print(“Running the VQE using the {}”.format(name))</p>
			<p class="source-code">    print(“Elapsed time: {} \n”.format(elapsed))</p>
			<p class="source-code">    print(ground_state)</p>
			<p class="source-code">  return ground_state</p>
			<p>We define the <strong class="source-inline">run_qpe()</strong> function to perform a quantum phase estimation and return an eigenvalue of a Hamiltonian as an estimation of the electronic ground state energy. It has the following input parameters:</p>
			<ul>
				<li><strong class="source-inline">particle_number</strong>, the property returned by the<strong class="source-inline"> get_particle_number()</strong> function</li>
				<li><strong class="source-inline">qubit_converter</strong>, either <strong class="source-inline">JordanWignerMapper()</strong>, <strong class="source-inline">ParityMapper()</strong>, or <strong class="source-inline">BravyiKitaevMapper()</strong>, which is the output of the <strong class="source-inline">fermion_to_qubit()</strong> function</li>
				<li><strong class="source-inline">qubit_op</strong>, a qubit Hamiltonian operator returned the <strong class="source-inline">fermion_to_qubit()</strong> function</li>
				<li><strong class="source-inline">n_ancillae</strong>, an integer that defaults to <strong class="source-inline">3</strong>, which is the number of ancillae qubits</li>
				<li><strong class="source-inline">num_time_slices</strong>, an integer that defaults to <strong class="source-inline">1</strong>, which is the number of <strong class="bold">Trotterization</strong> repetitions to make to improve the approximation accuracy, and is used by the Qiskit <strong class="source-inline">PauliTrotterEvolution</strong> class</li>
				<li><strong class="source-inline">show</strong>, set to <strong class="source-inline">True</strong> by <a id="_idIndexMarker521"/>default to display intermediate results</li>
			</ul>
			<p>Here is the code:</p>
			<p class="source-code">def run_qpe(particle_number, qubit_converter, qubit_op, n_ancillae=3, num_time_slices = 1, show=True):</p>
			<p class="source-code">  initial_state = HartreeFock(particle_number.num_spin_orbitals, </p>
			<p class="source-code">                            (particle_number.num_alpha, </p>
			<p class="source-code">                             particle_number.num_beta), qubit_converter)</p>
			<p class="source-code">  </p>
			<p class="source-code">  state_preparation = StateFn(initial_state)</p>
			<p class="source-code">  evolution = PauliTrotterEvolution('trotter', reps=num_time_slices)</p>
			<p class="source-code">  qpe = HamiltonianPhaseEstimation(n_ancillae, quantum_instance=quantum_instance)</p>
			<p class="source-code">  result = qpe.estimate(qubit_op, state_preparation, evolution=evolution)</p>
			<p class="source-code">  if show:</p>
			<p class="source-code">    print(“\nQPE initial Hartree Fock state”)</p>
			<p class="source-code">    display(initial_state.draw(output='mpl'))</p>
			<p class="source-code">    eigv = result.most_likely_eigenvalue</p>
			<p class="source-code">    print(“QPE computed electronic ground state energy (Hartree): {}”.format(eigv))</p>
			<p class="source-code">  </p>
			<p class="source-code">  return eigv</p>
			<p>We define the <strong class="source-inline">plot_energy_landscape()</strong> function to plot the energy as a function of atomic separation:</p>
			<p class="source-code">def plot_energy_landscape(energy_surface_result):</p>
			<p class="source-code">  if len(energy_surface_result.points) &gt; 1:</p>
			<p class="source-code">      plt.plot(energy_surface_result.points, energy_surface_result.energies, label=”VQE Energy”)</p>
			<p class="source-code">      plt.xlabel('Atomic distance Deviation(Angstrom)')</p>
			<p class="source-code">      plt.ylabel('Energy (hartree)')</p>
			<p class="source-code">      plt.legend()</p>
			<p class="source-code">      plt.show()</p>
			<p class="source-code">  else:</p>
			<p class="source-code">      print(“Total Energy is: “, energy_surface_result.energies[0], “hartree”)</p>
			<p class="source-code">      print(“(No need to plot, only one configuration calculated.)”)</p>
			<p class="source-code">  return</p>
			<p>We define the <strong class="source-inline">plot_loss()</strong> function, which accepts the following input parameters:</p>
			<ul>
				<li><strong class="source-inline">loss</strong>, an array of floats, optional, generated by the callback function</li>
				<li><strong class="source-inline">label</strong>, a character string to be displayed by the <strong class="source-inline">plot_loss()</strong> function</li>
				<li><strong class="source-inline">target</strong>, a float to be displayed by the <strong class="source-inline">plot_loss()</strong> function</li>
			</ul>
			<p>Here is the code:</p>
			<p class="source-code">def plot_loss(loss, label, target):</p>
			<p class="source-code">  plt.figure(figsize=(12, 6))</p>
			<p class="source-code">  plt.plot(loss, 'tab:green', ls='--', label=label)</p>
			<p class="source-code">  plt.axhline(target, c='tab:red', ls='--', label='target')</p>
			<p class="source-code">  plt.ylabel('loss')</p>
			<p class="source-code">  plt.xlabel('iterations')</p>
			<p class="source-code">  plt.legend()</p>
			<p>We now define the <strong class="source-inline">solve_ground_state()</strong> function, which solves for a ground state. It <a id="_idIndexMarker522"/>accepts as input the following parameters, which define the geometry of the molecule:</p>
			<ul>
				<li><strong class="source-inline">molecule</strong>, the geometry of the molecule, and the output of the <strong class="source-inline">Molecule</strong> function.</li>
				<li><strong class="source-inline">mapper</strong>, either <strong class="source-inline">“Jordan-Wigner”</strong> or <strong class="source-inline">“Parity”</strong> or <strong class="source-inline">“Bravyi-Kitaev”</strong>.</li>
				<li><strong class="source-inline">num_electrons</strong>, an integer, optional, number of electrons for the <strong class="source-inline">ActiveSpaceTransformer</strong>. Defaults to <strong class="source-inline">2</strong>.</li>
				<li><strong class="source-inline">num_molecular_orbitals</strong>, an integer, optional, number of electron orbitals for <strong class="source-inline">ActiveSpaceTransformer</strong>. Defaults to <strong class="source-inline">2</strong>.</li>
			</ul>
			<p>The following list <a id="_idIndexMarker523"/>of input parameters control the whole process:</p>
			<ul>
				<li><strong class="source-inline">transformers</strong>, an optional list of transformers. For example, for lithium hydride, we will use the following: <strong class="source-inline">transformers=[FreezeCoreTransformer(freeze_core=True, remove_orbitals=[4, 3])]</strong>.</li>
				<li><strong class="source-inline">two_qubit_reduction</strong>, a Boolean, by default <strong class="source-inline">False</strong>. It determines whether to carry out two-qubit reduction when possible.</li>
				<li><strong class="source-inline">z2symmetry_reduction</strong>, by default <strong class="source-inline">None</strong>, this indicates whether a Z2 symmetry reduction should be applied to resulting qubit operators that are computed based on mathematical symmetries that can be detected in the operator [de Keijzer].</li>
				<li><strong class="source-inline">name_solver</strong>, the name of the solver, which defaults to<strong class="source-inline"> 'NumPy exact solver'</strong>.</li>
				<li><strong class="source-inline">solver</strong>, either one of the solvers defined in Section <em class="italic">5.2.3, Setting up the VQE solver</em>, <strong class="source-inline">numpy_solver</strong>, <strong class="source-inline">vqe_ucc_solver</strong>, or <strong class="source-inline">vqe_tl_solver</strong>. It defaults to <strong class="source-inline">NumPyMinimumEigensolver()</strong>.</li>
				<li><strong class="source-inline">plot_bopes</strong>, a Boolean, set to <strong class="source-inline">True</strong> to compute and plot the BOPES of the molecule.</li>
				<li><strong class="source-inline">perturbation_steps</strong>, the points along the degrees of freedom to evaluate, in this case a distance in angstroms. It defaults to <strong class="source-inline">np.linspace(-1, 1, 3)</strong>.</li>
				<li><strong class="source-inline">pyqmc</strong>, set to <strong class="source-inline">True</strong> by default to run the PyQMC Python module.</li>
				<li><strong class="source-inline">n_ancillae</strong>, an integer that defaults to <strong class="source-inline">3</strong> that represents the number of ancillae qubits used by the <strong class="source-inline">run_qpe()</strong> function.</li>
				<li><strong class="source-inline">num_time_slices</strong>, an integer that defaults to <strong class="source-inline">1</strong>, which is number of <strong class="bold">Trotterization</strong> repetitions to make to improve the approximation accuracy. It's used by the Qiskit <strong class="source-inline">PauliTrotterEvolution</strong> class.</li>
				<li><strong class="source-inline">loss</strong>, an optional <a id="_idIndexMarker524"/>array of floats that is generated by the callback function.</li>
				<li><strong class="source-inline">label</strong>, a character string to be displayed by the <strong class="source-inline">plot_loss()</strong> function.</li>
				<li><strong class="source-inline">target</strong>, a float to be displayed by the <strong class="source-inline">plot_loss()</strong> function.</li>
				<li><strong class="source-inline">show</strong>, set to <strong class="source-inline">True</strong> by default to display intermediate results.</li>
			</ul>
			<p>Here is the definition of the <strong class="source-inline">solve_ground_state()</strong> function:</p>
			<p class="source-code">def solve_ground_state(</p>
			<p class="source-code">    molecule,</p>
			<p class="source-code">    mapper =”Parity”,</p>
			<p class="source-code">    num_electrons=None,</p>
			<p class="source-code">    num_molecular_orbitals=None,</p>
			<p class="source-code">    transformers=None,</p>
			<p class="source-code">    two_qubit_reduction=False,</p>
			<p class="source-code">    z2symmetry_reduction = “Auto”,</p>
			<p class="source-code">    name_solver='NumPy exact solver',</p>
			<p class="source-code">    solver=NumPyMinimumEigensolver(),</p>
			<p class="source-code">    plot_bopes=False,</p>
			<p class="source-code">    perturbation_steps=np.linspace(-1, 1, 3),</p>
			<p class="source-code">    pyqmc=True,</p>
			<p class="source-code">    n_ancillae=3, </p>
			<p class="source-code">    num_time_slices=1,</p>
			<p class="source-code">    loss=[],</p>
			<p class="source-code">    label=None,</p>
			<p class="source-code">    target=None,</p>
			<p class="source-code">    show=True</p>
			<p class="source-code">):</p>
			<p>We now present the code that is contained in the <strong class="source-inline">solve_ground_state()</strong> function.</p>
			<p>We first define the electronic structure molecule driver by selecting the PySCF driver type and the basis set <strong class="source-inline">sto3g</strong> in which the molecular orbitals are to be expanded into. Here is the code:</p>
			<p class="source-code">    # Defining the electronic structure molecule driver</p>
			<p class="source-code">    driver = ElectronicStructureMoleculeDriver(molecule, basis='sto3g', driver_type=ElectronicStructureDriverType.PYSCF)</p>
			<p>Then, if both <strong class="source-inline">num_electrons</strong> and <strong class="source-inline">num_molecular_orbitals</strong> are specified, we call the <strong class="source-inline">ActiveSpaceTransformer</strong> function to split the computation into a classical and a quantum part:</p>
			<p class="source-code"># Splitting into classical and quantum</p>
			<p class="source-code">    if num_electrons != None and num_molecular_orbitals != None:</p>
			<p class="source-code">      split = ActiveSpaceTransformer(num_electrons=num_electrons, num_molecular_orbitals=num_molecular_orbitals)</p>
			<p class="source-code">    else:</p>
			<p class="source-code">      split = None</p>
			<p>Next, we <a id="_idIndexMarker525"/>create an <strong class="source-inline">ElectronicStructureProblem</strong> that produces the list of fermionic operators as follows:</p>
			<p class="source-code"># Defining a fermionic Hamiltonian operator</p>
			<p class="source-code">    if split != None:</p>
			<p class="source-code">      fermionic_hamiltonian = ElectronicStructureProblem(driver, [split])</p>
			<p class="source-code">    elif transformers != None:</p>
			<p class="source-code">      fermionic_hamiltonian = ElectronicStructureProblem(driver, transformers=transformers)</p>
			<p class="source-code">    else:</p>
			<p class="source-code">      fermionic_hamiltonian = ElectronicStructureProblem(driver)</p>
			<p>We then use the <strong class="source-inline">second_q_ops()</strong> method [Qiskit_Nat_3], which returns a list of second quantized operators: Hamiltonian operator, total particle number operator, total angular momentum operator, total magnetization operator, and if available, <img src="Images/Formula_05_045.png" alt="" width="25" height="24"/>, <img src="Images/Formula_05_128.png" alt="" width="25" height="30"/>, <img src="Images/Formula_05_129.png" alt="" width="22" height="22"/> dipole operators:</p>
			<p class="source-code">second_q_op = fermionic_hamiltonian.second_q_ops()</p>
			<p>We get the particle number property of the molecule by calling the <strong class="source-inline">particle_number()</strong> function:</p>
			<p class="source-code">    # Get particle number</p>
			<p class="source-code">    particle_number = get_particle_number(fermionic_hamiltonian, show=show)</p>
			<p>If the input <a id="_idIndexMarker526"/>parameter <strong class="source-inline">show</strong> is set to <strong class="source-inline">True</strong>, we set truncation to <strong class="source-inline">1000</strong> with the <strong class="source-inline">set_truncation(1000)</strong> method and then we print the fermionic Hamiltonian operator of the molecule:</p>
			<p class="source-code">if show:</p>
			<p class="source-code">      # We set truncation to 1000 with the method set_truncation(1000)</p>
			<p class="source-code">      second_q_op[0].set_truncation(1000)</p>
			<p class="source-code">      # then we print the first 20 terms of the fermionic Hamiltonian operator of the molecule</p>
			<p class="source-code">      print(“Fermionic Hamiltonian operator”)</p>
			<p class="source-code">      print(second_q_op[0])</p>
			<p>Next, we use the <strong class="source-inline">fermion_to_qubit()</strong> function defined in <em class="italic">Section 4.8, Constructing a qubit Hamiltonian with Qiskit Nature,</em> to convert a fermionic operator to a qubit operator:</p>
			<p class="source-code"># Use the function fermion_to_qubit() to convert a fermionic operator to a qubit operator</p>
			<p class="source-code">    if show:</p>
			<p class="source-code">      print(“ “)</p>
			<p class="source-code">    qubit_op, qubit_converter = fermion_to_qubit(fermionic_hamiltonian, second_q_op, mapper=mapper, two_qubit_reduction=two_qubit_reduction, z2symmetry_reduction=z2symmetry_reduction, show=show)</p>
			<p>Then we call the <strong class="source-inline">run_PySCF()</strong> function that we defined earlier to run the PySCF RHF method:</p>
			<p class="source-code">    # Run the the PySCF RHF method</p>
			<p class="source-code">    if show:</p>
			<p class="source-code">      print(“ “)</p>
			<p class="source-code">    conv, e = run_PySCF(molecule, pyqmc=pyqmc, show=show)</p>
			<p>Then we call the <strong class="source-inline">run_qpe()</strong> function to perform a QPE and return the most likely eigenvalue of a Hamiltonian as an estimation of the electronic ground state energy:</p>
			<p class="source-code"> # Run QPE</p>
			<p class="source-code">    eigv = run_qpe(particle_number, qubit_converter, qubit_op, n_ancillae=n_ancillae, num_time_slices=num_time_slices, show=True)</p>
			<p>Next, we call the <strong class="source-inline">run_vqe()</strong> function defined earlier to solve for the ground state:</p>
			<p class="source-code">    # Run VQE</p>
			<p class="source-code">    if show:</p>
			<p class="source-code">      print(“ “)</p>
			<p class="source-code">    ground_state = run_vqe(name_solver, fermionic_hamiltonian, qubit_converter, solver, show=show)</p>
			<p>If the <strong class="source-inline">loss</strong> parameter is <a id="_idIndexMarker527"/>not an empty array, we call the <strong class="source-inline">plot_loss()</strong> function to plot the evolution of the loss as a function of the number of iterations:</p>
			<p class="source-code">    # Plot loss function</p>
			<p class="source-code">    if loss != []:</p>
			<p class="source-code">      plot_loss(loss, label, target)</p>
			<p>Next, if the <strong class="source-inline">plot_bopes</strong> parameter is set to <strong class="source-inline">True</strong>, we use the <strong class="source-inline">BOPESSampler</strong> Python class [Qiskit_Nat_6], which manages the process of varying the geometry and repeatedly calling the ground state solver, and then we get and plot the BOPES:</p>
			<p class="source-code">if plot_bopes:</p>
			<p class="source-code">      # Compute the potential energy surface as follows:</p>
			<p class="source-code">      energy_surface = BOPESSampler(gss=GroundStateEigensolver(qubit_converter, solver), bootstrap=False)</p>
			<p class="source-code">      # Set default to an empty dictionary instead of None:</p>
			<p class="source-code">      energy_surface._points_optparams = {}</p>
			<p class="source-code">      energy_surface_result = energy_surface.sample(fermionic_hamiltonian, perturbation_steps)</p>
			<p class="source-code">      # Plot the energy as a function of atomic separation</p>
			<p class="source-code">      plot_energy_landscape(energy_surface_result)</p>
			<p>Finally, we let the <strong class="source-inline">solve_ground_state()</strong> function return the following parameters to the caller:</p>
			<ul>
				<li><strong class="source-inline">fermionic hamiltonian</strong>, the Fermionic Hamiltonian operator of the molecule</li>
				<li><strong class="source-inline">particle number</strong>, the particle number property of the molecule</li>
				<li><strong class="source-inline">qubit_op</strong>, the qubit Hamiltonian operator</li>
				<li><strong class="source-inline">qubit_converter</strong>, either <strong class="source-inline">JordanWignerMapper()</strong>, <strong class="source-inline">ParityMapper()</strong>, or <strong class="source-inline">BravyiKitaevMapper()</strong>, which is the output of the <strong class="source-inline">fermion_to_qubit()</strong> function</li>
				<li><strong class="source-inline">ground_state</strong>, the ground state of the molecule, if convergence has been achieved</li>
			</ul>
			<p>with the <a id="_idIndexMarker528"/>following <strong class="source-inline">return</strong> statement:</p>
			<p class="source-code">return fermionic_hamiltonian, particle_number, qubit_op, qubit_converter, ground_state</p>
			<p>We now illustrate how to use the <strong class="source-inline">solve_ground_state()</strong> function with different molecules, different mappers, and different classical solvers.</p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor220"/>5.2.1. Hydrogen molecule (H2)</h2>
			<p>We follow the process <a id="_idIndexMarker529"/>described in <em class="italic">Section 4.6.1, Constructing a fermionic Hamiltonian operator of the hydrogen molecule</em>. First, we define the geometry of the hydrogen molecule as follows:</p>
			<p class="source-code">hydrogen_molecule = Molecule(geometry=[['H', [0., 0., 0.]],</p>
			<p class="source-code">                              ['H', [0., 0., 0.735]]],</p>
			<p class="source-code">                     charge=0, multiplicity=1)</p>
			<p>We showed the particle number property of the hydrogen molecule in <em class="italic">Figure 4.9</em> in <em class="italic">Section 4.6.1, Constructing a fermionic Hamiltonian operator of the hydrogen molecule,</em> where <a id="_idIndexMarker530"/>we see four <strong class="bold">spin orbitals</strong> (<strong class="bold">SOs</strong>), one <img src="Images/Formula_05_130.png" alt="" width="28" height="26"/> electron, and one <img src="Images/Formula_05_131.png" alt="" width="28" height="45"/> electron.</p>
			<p>We showed the fermionic Hamiltonian operator of the hydrogen molecule in <em class="italic">Figure 4.13</em> in <em class="italic">Section 4.6.1, Constructing a fermionic Hamiltonian operator of the hydrogen molecule</em>.</p>
			<h3>Varying the hydrogen molecule</h3>
			<p>We specify the type of <a id="_idIndexMarker531"/>molecular variation, <strong class="source-inline">Molecule.absolute_stretching</strong>, as follows:</p>
			<p class="source-code">molecular_variation = Molecule.absolute_stretching</p>
			<p>We specify that the first atom of the specified atom pair is moved closer to the second atom. The numbers refer to the index of the atom in the geometric definition list. Here is the code:</p>
			<p class="source-code">specific_molecular_variation = apply_variation(molecular_variation, atom_pair=(1, 0))</p>
			<p>We alter the original molecular definition as follows:</p>
			<p class="source-code">hydrogen_molecule_stretchable = Molecule(geometry=</p>
			<p class="source-code">                                 [['H', [0., 0., 0.]],</p>
			<p class="source-code">                                  ['H', [0., 0., 0.735]]],</p>
			<p class="source-code">                                  charge=0, multiplicity=1,</p>
			<p class="source-code">                                  degrees_of_freedom=[specific_molecular_variation])</p>
			<p>Now we proceed with solving for the ground state.</p>
			<h3>Solving for the ground state</h3>
			<p>We now run <a id="_idIndexMarker532"/>VQE using the NumPy exact minimum eigensolver:</p>
			<p class="source-code">H2_fermionic_hamiltonian, H2_particle_number, H2_qubit_op, H2_qubit_converter, H2_ground_state = \</p>
			<p class="source-code">                  solve_ground_state(hydrogen_molecule, mapper =”Parity”,</p>
			<p class="source-code">                   two_qubit_reduction=True, z2symmetry_reduction=None, </p>
			<p class="source-code">                   name_solver = 'NumPy exact solver', solver = numpy_solver)</p>
			<p><em class="italic">Figure 5.5</em> shows the results of the computation by the <strong class="source-inline">run_PySCF()</strong> and <strong class="source-inline">run_QPE()</strong>functions:</p>
			<div>
				<div id="_idContainer1540" class="IMG---Figure">
					<img src="Images/B18268_Figure_5.5.jpg" alt="" width="739" height="359"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.5 – Ground-state of the H2 molecule with PySCF RHF, PyQMC Monte Carlo, and QPE</p>
			<p><em class="italic">Figure 5.6</em> shows the result of the VQE computation:</p>
			<div>
				<div id="_idContainer1541" class="IMG---Figure">
					<img src="Images/B18268_Figure_5.6.jpg" alt="" width="759" height="406"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.6 – Ground-state of the H2 molecule with VQE using the NumPy minimum eigensolver</p>
			<p>Next, we <a id="_idIndexMarker533"/>run the VQE using the UCC factory ansatz [VQE_2] [VQE_3]:</p>
			<p class="source-code">H2_fermionic_hamiltonian, H2_particle_number, H2_qubit_op, H2_qubit_converter, H2_ground_state = \</p>
			<p class="source-code">                  solve_ground_state(hydrogen_molecule, mapper =”Parity”,</p>
			<p class="source-code">                   two_qubit_reduction=True, z2symmetry_reduction=None, </p>
			<p class="source-code">                   name_solver = 'Unitary Coupled Cluster (UCC) factory ansatz', solver = vqe_ucc_solver)</p>
			<p><em class="italic">Figure 5.7</em> shows the result:</p>
			<div>
				<div id="_idContainer1542" class="IMG---Figure">
					<img src="Images/B18268_Figure_5.7.jpg" alt="" width="828" height="405"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.7 – Ground-state of the H2 molecule with VQE using the UCC factory ansatz</p>
			<p>Now we run <a id="_idIndexMarker534"/>the VQE using a heuristic ansatz, the Two-Local circuit with the default SLSQP optimizer [Panagiotis]:</p>
			<p class="source-code">H2_fermionic_hamiltonian, H2_particle_number, H2_qubit_op, H2_qubit_converter, H2_ground_state = \</p>
			<p class="source-code">                  solve_ground_state(hydrogen_molecule, mapper =”Parity”,</p>
			<p class="source-code">                   two_qubit_reduction=True, z2symmetry_reduction=None, </p>
			<p class="source-code">                   name_solver = 'Heuristic ansatz, the Two-Local circuit with SLSQP',solver = vqe_tl_solver)</p>
			<p><em class="italic">Figure 5.8</em> shows the result:</p>
			<div>
				<div id="_idContainer1543" class="IMG---Figure">
					<img src="Images/B18268_Figure_5.8.jpg" alt="" width="711" height="363"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.8 – Ground-state of the H2 molecule with VQE using the Two-Local circuit and SLSQP</p>
			<p>We define the <strong class="source-inline">qnspsa()</strong> function as follows:</p>
			<p class="source-code">qnspsa_loss = []</p>
			<p class="source-code">ansatz = tl_circuit</p>
			<p class="source-code">fidelity = QNSPSA.get_fidelity(ansatz, quantum_instance, expectation=PauliExpectation())</p>
			<p class="source-code">qnspsa = QNSPSA(fidelity, maxiter=200, learning_rate=0.01, perturbation=0.7, callback=qnspsa_callback)</p>
			<p>Here is the code that <a id="_idIndexMarker535"/>sets up the VQE using a heuristic ansatz and the QN-SPSA optimizer:</p>
			<p class="source-code">vqe_tl_QNSPSA_solver = VQE(ansatz=tl_circuit, optimizer=qnspsa,</p>
			<p class="source-code">                     quantum_instance=quantum_instance)</p>
			<p>Now we call <strong class="source-inline">solve_ground_state()</strong> with the heuristic ansatz and the QN-SPSA optimizer:</p>
			<p class="source-code">H2_fermionic_hamiltonian, H2_particle_number, H2_qubit_op, H2_qubit_converter, H2_ground_state = \</p>
			<p class="source-code">                  solve_ground_state(hydrogen_molecule, mapper =”Parity”,</p>
			<p class="source-code">                  two_qubit_reduction=True, z2symmetry_reduction=None, loss=qnspsa_loss, label='QN-SPSA', target=-1.857274810366,</p>
			<p class="source-code">                  name_solver='Two-Local circuit and the QN-SPSA optimizer', solver=vqe_tl_QNSPSA_solver)</p>
			<p><em class="italic">Figure 5.9</em> shows the result:</p>
			<div>
				<div id="_idContainer1544" class="IMG---Figure">
					<img src="Images/B18268_Figure_5.9.jpg" alt="" width="637" height="473"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.9 – Ground-state of the H2 molecule with VQE using the Two-Local circuit and QN-SPSA</p>
			<p><em class="italic">Figure 5.10</em> shows the <a id="_idIndexMarker536"/>plot of the loss function of the QN-SPSA optimizer:</p>
			<div>
				<div id="_idContainer1545" class="IMG---Figure">
					<img src="Images/B18268_Figure_5.10.jpg" alt="" width="729" height="371"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.10 – Plot of the loss function of the VQE using the Two-Local circuit and QN-SPSA for the H2 molecule</p>
			<p>The table shown in <em class="italic">Figure 5.11</em> summarizes calculations obtained with the Python packages PySCF RHF, PyQMC, and with the Qiskit Nature classes, VQE with NumPy exact solver, SLSQP, QN-SPSA, and QPE.</p>
			<div>
				<div id="_idContainer1546" class="IMG---Figure">
					<img src="Images/B18268_Figure_5.11.jpg" alt="" width="1618" height="609"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.11 – Table summarizing the calculations of the ground state energy obtained with the H2 molecule</p>
			<p><em class="italic">Figure 5.11</em> shows close agreement between the different calculations of the electronic ground state and the <a id="_idIndexMarker537"/>total ground state energies with the same qubit mapper called the <strong class="source-inline">ParityMapper()</strong> with <strong class="source-inline">two_qubit_reduction=True</strong>. The PyQMC method gives the lowest total energy -1.162 Ha and is the most accurate. It is consistent with the result -1.168 Ha shown in Ref. [Ebomwonyi].</p>
			<h3>Computing the<a id="_idTextAnchor221"/> BOPES</h3>
			<p>We now compute and <a id="_idIndexMarker538"/>plot the BOPES of the <a id="_idIndexMarker539"/>hydrogen molecule as follows:</p>
			<p class="source-code">perturbation_steps = np.linspace(-0.5, 2, 25) # 25 equally spaced points from -0.5 to 2, inclusive.</p>
			<p class="source-code">H2_stretchable_fermionic_hamiltonian, H2_stretchable_particle_number, H2_stretchable_qubit_op, H2_stretchable_qubit_converter, H2_stretchable_ground_state = \</p>
			<p class="source-code">                  solve_ground_state(hydrogen_molecule_stretchable, mapper =”Parity”,</p>
			<p class="source-code">                   two_qubit_reduction=True, z2symmetry_reduction=None, </p>
			<p class="source-code">                   name_solver = 'NumPy exact solver', solver = numpy_solver,</p>
			<p class="source-code">                   plot_bopes = True, perturbation_steps=perturbation_steps)</p>
			<p><em class="italic">Figure 5.12</em> shows <a id="_idIndexMarker540"/>the plot of the BOPES of the <a id="_idIndexMarker541"/>hydrogen molecule:</p>
			<div>
				<div id="_idContainer1547" class="IMG---Figure">
					<img src="Images/B18268_Figure_5.12.jpg" alt="" width="394" height="262"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.12 – Plot of the BOPES of the hydrogen molecule</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor222"/>5.2.2. Lithium hydride molecule</h2>
			<p>We follow the <a id="_idIndexMarker542"/>process described in <em class="italic">Section 4.6.2, Constructing a fermionic Hamiltonian operator of the lithium hydride molecule</em>. First, we define the geometry of the lithium hydride (LiH) molecule as follows:</p>
			<p class="source-code">LiH_molecule = Molecule(geometry=[['Li', [0., 0., 0.]],</p>
			<p class="source-code">                              ['H', [0., 0., 1.5474]]],</p>
			<p class="source-code">                     charge=0, multiplicity=1)</p>
			<p>We showed the particle number property in <em class="italic">Figure 4.17</em> in <em class="italic">Section 4.6.2, Constructing a fermionic Hamiltonian operator of the lithium hydride molecule</em>, where we see six SOs, one <img src="Images/Formula_05_132.png" alt="" width="28" height="27"/> electron, and one <img src="Images/Formula_05_133.png" alt="" width="28" height="44"/> electron. We showed the fermionic Hamiltonian operator of the lithium hydride molecule in <em class="italic">Figure 4.20</em> in <em class="italic">Section 4.6.2, Constructing a fermionic Hamiltonian operator of the lithium hydride molecule</em>.</p>
			<h3>Varying the lithium hydride molecule</h3>
			<p>We alter the original <a id="_idIndexMarker543"/>molecular definition as follows:</p>
			<p class="source-code">LiH_molecule_stretchable = Molecule(geometry=[['Li', [0., 0., 0.]],</p>
			<p class="source-code">                              ['H', [0., 0., 1.5474]]],</p>
			<p class="source-code">                    charge=0, multiplicity=1,</p>
			<p class="source-code">                    degrees_of_freedom=[specific_molecular_variation])</p>
			<p class="source-code">reduction=True, z2symmetry_reduction=”auto”)</p>
			<h3>Solving for the ground state</h3>
			<p>We run VQE using <a id="_idIndexMarker544"/>the NumPy exact minimum eigensolver:</p>
			<p class="source-code">LiH_fermionic_hamiltonian, LiH_particle_number, LiH_qubit_op, LiH_qubit_converter, LiH_ground_state = \</p>
			<p class="source-code">                  solve_ground_state(LiH_molecule, mapper =”Parity”,</p>
			<p class="source-code">                  transformers=[FreezeCoreTransformer(freeze_core=True, remove_orbitals=[4, 3])],</p>
			<p class="source-code">                  two_qubit_reduction=True, z2symmetry_reduction=”auto”, </p>
			<p class="source-code">                  name_solver = 'NumPy exact solver', solver = numpy_solver)</p>
			<p><em class="italic">Figure 5.13</em> shows the result of the computation by the <strong class="source-inline">run_PySCF()</strong> and <strong class="source-inline">run_QPE()</strong> functions:</p>
			<div>
				<div id="_idContainer1550" class="IMG---Figure">
					<img src="Images/B18268_Figure_5.13.jpg" alt="" width="739" height="471"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.13 – Ground state of the LiH molecule with PySCF RHF, PyQMC Monte Carlo, and QPE</p>
			<p><em class="italic">Figure 5.14</em> shows the result of the VQE computation:</p>
			<div>
				<div id="_idContainer1551" class="IMG---Figure">
					<img src="Images/B18268_Figure_5.14.jpg" alt="" width="749" height="572"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.14 – Ground state of the LiH molecule with VQE using the NumPy minimum eigensolver</p>
			<p>We run the <a id="_idIndexMarker545"/>VQE using the Two-Local circuit and SLSQP:</p>
			<p class="source-code">LiH_fermionic_hamiltonian, LiH_particle_number, LiH_qubit_op, LiH_qubit_converter, LiH_ground_state = \</p>
			<p class="source-code">                  solve_ground_state(LiH_molecule, mapper =”Parity”,</p>
			<p class="source-code">                  transformers=[FreezeCoreTransformer(freeze_core=True, remove_orbitals=[4, 3])],</p>
			<p class="source-code">                  two_qubit_reduction=True, z2symmetry_reduction=”auto”, </p>
			<p class="source-code">                  name_solver = 'Heuristic ansatz, the Two-Local circuit with SLSQP', solver = vqe_tl_solver)</p>
			<p><em class="italic">Figure 5.15</em> shows the result:</p>
			<div>
				<div id="_idContainer1552" class="IMG---Figure">
					<img src="Images/B18268_Figure_5.15.jpg" alt="" width="898" height="658"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.15 – Ground state of the LiH molecule with VQE using the Two-Local circuit and SLSQP</p>
			<p>We define the <strong class="source-inline">qnspsa()</strong> function as follows:</p>
			<p class="source-code">qnspsa_loss = []</p>
			<p class="source-code">ansatz = tl_circuit</p>
			<p class="source-code">fidelity = QNSPSA.get_fidelity(ansatz, quantum_instance, expectation=PauliExpectation())</p>
			<p class="source-code">qnspsa = QNSPSA(fidelity, maxiter=500, learning_rate=0.01, perturbation=0.7, callback=qnspsa_callback)</p>
			<p>Here is the <a id="_idIndexMarker546"/>code that sets up the VQE using a heuristic ansatz and the QN-SPSA optimizer:</p>
			<p class="source-code">vqe_tl_QNSPSA_solver = VQE(ansatz=tl_circuit, optimizer=qnspsa,</p>
			<p class="source-code">                     quantum_instance=quantum_instance)</p>
			<p>Now we call <strong class="source-inline">solve_ground_state()</strong> with the heuristic ansatz and the QN-SPSA optimizer:</p>
			<p class="source-code">LiH_fermionic_hamiltonian, LiH_particle_number, LiH_qubit_op, LiH_qubit_converter, LiH_ground_state = \</p>
			<p class="source-code">                  solve_ground_state(LiH_molecule, mapper=”Parity”,</p>
			<p class="source-code">                  transformers=[FreezeCoreTransformer(freeze_core=True, remove_orbitals=[4, 3])],</p>
			<p class="source-code">                  two_qubit_reduction=True, z2symmetry_reduction=”auto”, loss=qnspsa_loss, label='QN-SPSA', target=-1.0703584,</p>
			<p class="source-code">                  name_solver='Two-Local circuit and the QN-SPSA optimizer', solver=vqe_tl_QNSPSA_solver)</p>
			<p><em class="italic">Figure 5.16</em> shows the result:</p>
			<div>
				<div id="_idContainer1553" class="IMG---Figure">
					<img src="Images/B18268_Figure_5.16.jpg" alt="" width="690" height="523"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.16 – Ground state of the LiH molecule with VQE using the Two-Local circuit and QN-SPSA</p>
			<p><em class="italic">Figure 5.17</em> shows <a id="_idIndexMarker547"/>the plot of the loss function of the QN-SPSA optimizer:</p>
			<div>
				<div id="_idContainer1554" class="IMG---Figure">
					<img src="Images/B18268_Figure_5.17.jpg" alt="" width="729" height="371"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.17 – Loss function of the VQE using the Two-Local circuit and QN-SPSA for the LiH molecule</p>
			<p>The table shown in <em class="italic">Figure 5.18</em> summarizes calculations obtained with the Python packages PySCF RHF, PyQMC, and with the Qiskit Nature classes, VQE with the NumPy exact solver, SLSQP, QN-SPSA, and QPE:</p>
			<div>
				<div id="_idContainer1555" class="IMG---Figure">
					<img src="Images/B18268_Figure_5.18.jpg" alt="" width="1620" height="609"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.18 – Table summarizing the calculations of the ground state energy obtained with the LiH molecule</p>
			<p><em class="italic">Figure 5.18</em> shows close agreement between the different calculations of the electronic ground state <a id="_idIndexMarker548"/>and the total ground state energies. The PyQMC method gives the lowest total energy -8.102 Ha and is the most accurate. It is consistent with the result -8.07 Ha shown in Ref. [Adamowicz_3].</p>
			<h3>Computing the BOPES</h3>
			<p>We now compute <a id="_idIndexMarker549"/>and plot the BOPES of <a id="_idIndexMarker550"/>the lithium hydride molecule as follows:</p>
			<p class="source-code">perturbation_steps = np.linspace(-0.8, 0.8, 10) # 10 equally spaced points from -0.8 to 0.8, inclusive.</p>
			<p class="source-code">LiH_stretchable_fermionic_hamiltonian, LiH_stretchable_particle_number, LiH_stretchable_qubit_op, LiH_stretchable_qubit_converter, LiH_stretchable_ground_state = \</p>
			<p class="source-code">                  solve_ground_state(LiH_molecule_stretchable, mapper =”Parity”,</p>
			<p class="source-code">                  transformers=[FreezeCoreTransformer(freeze_core=True, remove_orbitals=[4, 3])],</p>
			<p class="source-code">                   two_qubit_reduction=True, z2symmetry_reduction=”auto”, </p>
			<p class="source-code">                   name_solver='NumPy exact solver', solver=numpy_solver,</p>
			<p class="source-code">                   plot_bopes = True, perturbation_steps=perturbation_steps)</p>
			<p><em class="italic">Figure 5.19</em> shows <a id="_idIndexMarker551"/>the <a id="_idIndexMarker552"/>result:</p>
			<div>
				<div id="_idContainer1556" class="IMG---Figure">
					<img src="Images/B18268_Figure_5.19.jpg" alt="" width="509" height="262"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.19 – Plot of the BOPES of the LiH molecule</p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor223"/>5.2.3. Macro molecule </h2>
			<p>We now explore the HIV use case of the IBM Quantum Challenge Africa 2021, Quantum Chemistry for HIV [Africa21]. In their challenge they aimed to determine whether a toy model of an <a id="_idIndexMarker553"/>anti-retroviral molecule can bind with a toy model of a protease molecule. Since the anti-retroviral molecule has many atoms, it is approximated by using a single carbon atom. The toy model of the protease molecule is represented by a component of the formamide molecule (HCONH2); particularly it is the carbon-oxygen-nitrogen part of the formamide molecule. In short, the experiment is to determine whether a single carbon atom, can bind to the carbon-oxygen-nitrogen component of the formamide molecule. We will get the answer to the question posed by IBM by plotting the BOPES of a macro molecule, which is the formamide molecule plus the carbon atom. </p>
			<p>First, we define the macro molecule with the ASE <strong class="source-inline">Atoms</strong> object [ASE_1]:</p>
			<p class="source-code">macro_ASE = Atoms('ONCHHHC', [(1.1280, 0.2091, 0.0000), </p>
			<p class="source-code">                          (-1.1878, 0.1791, 0.0000), </p>
			<p class="source-code">                          (0.0598, -0.3882, 0.0000),</p>
			<p class="source-code">                          (-1.3085, 1.1864, 0.0001),</p>
			<p class="source-code">                          (-2.0305, -0.3861, -0.0001),</p>
			<p class="source-code">                          (-0.0014, -1.4883, -0.0001),</p>
			<p class="source-code">                          (-0.1805, 1.3955, 0.0000)])</p>
			<p>Then we display a 3D view of the molecule with the ASE viewer X3D for Jupyter notebooks [ASE2]:</p>
			<p class="source-code">view(macro_ASE, viewer='x3d')</p>
			<p><em class="italic">Figure 5.20</em> shows the result. The nitrogen atom is depicted on the left side in blue, the oxygen atom on the right side in red, the carbon atoms in the middle in gray, and the three hydrogen atoms are the smallest ones in light gray. The carbon atom on the top is not bound to the other atoms.</p>
			<div>
				<div id="_idContainer1557" class="IMG---Figure">
					<img src="Images/B18268_Figure_5.20.jpg" alt="" width="869" height="359"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.20 – Macro molecule </p>
			<p>We specify the type of molecular variation, <strong class="source-inline">Molecule.absolute_stretching</strong>, as follows:</p>
			<p class="source-code">molecular_variation = Molecule.absolute_stretching</p>
			<p>We specify which <a id="_idIndexMarker554"/>atoms the variation applies to. The numbers refer to the index of the atom in the geometric definition list. The single carbon atom is moved closer to the nitrogen atom:</p>
			<p class="source-code">specific_molecular_variation = apply_variation(molecular_variation, atom_pair=(6, 1))</p>
			<p>We define the molecular geometry of the macro molecule with the Qiskit <strong class="source-inline">Molecule</strong> class as follows:</p>
			<p class="source-code">macromolecule = Molecule(geometry=</p>
			<p class="source-code">   [['O', [1.1280, 0.2091, 0.0000]],</p>
			<p class="source-code">   ['N', [-1.1878, 0.1791, 0.0000]],</p>
			<p class="source-code">   ['C', [0.0598, -0.3882, 0.0000]],</p>
			<p class="source-code">   ['H', [-1.3085, 1.1864, 0.0001]],</p>
			<p class="source-code">   ['H', [-2.0305, -0.3861, -0.0001]],</p>
			<p class="source-code">   ['H', [-0.0014, -1.4883, -0.0001]],</p>
			<p class="source-code">   ['C', [-0.1805, 1.3955, 0.0000]]],</p>
			<p class="source-code">   charge=0, multiplicity=1,</p>
			<p class="source-code">   degrees_of_freedom=[specific_molecular_variation])</p>
			<p>Now we can <a id="_idIndexMarker555"/>solve for the ground state.</p>
			<h3>Solving for the ground state</h3>
			<p>We reduce the quantum workload by specifying that certain electrons should be treated with a quantum <a id="_idIndexMarker556"/>computing algorithm, while the remaining electrons should be classically approximated with the Qiskit <strong class="source-inline">ActiveSpaceTransformer</strong> class, which takes in two arguments:</p>
			<ul>
				<li><strong class="source-inline">num_electrons</strong>, the number of electrons selected from the outermost electrons, counting inwards, to be treated with a quantum computing algorithm.</li>
				<li><strong class="source-inline">num_molecular_orbitals</strong>, the number of orbitals to allow those electrons to roam over (around the so-called Fermi level). It determines how many qubits are needed.</li>
			</ul>
			<p>We print the selection of parameters of the VQE run:</p>
			<p class="source-code">print(“Macro molecule”)</p>
			<p class="source-code">print(“Using the ParityMapper with two_qubit_reduction=True to eliminate two qubits”)</p>
			<p class="source-code">print(“Parameters ActiveSpaceTransformer(num_electrons=2, num_molecular_orbitals=2)”)</p>
			<p class="source-code">print(“Setting z2symmetry_reduction=\”auto\””)</p>
			<p>Here is the result:</p>
			<p class="source-code">Macro molecule</p>
			<p class="source-code">Using the ParityMapper with two_qubit_reduction=True to eliminate two qubits</p>
			<p class="source-code">Parameters ActiveSpaceTransformer(num_electrons=2, num_molecular_orbitals=2)</p>
			<p class="source-code">Setting z2symmetry_reduction=”auto”</p>
			<p>We then run the VQE using the NumPy exact minimum eigensolver:</p>
			<p class="source-code">macro_fermionic_hamiltonian, macro_particle_number, macro_qubit_op, macro_qubit_converter, macro_ground_state = \</p>
			<p class="source-code">                  solve_ground_state(macromolecule, mapper=”Parity”,</p>
			<p class="source-code">                  num_electrons=2, num_molecular_orbitals=2,</p>
			<p class="source-code">                  two_qubit_reduction=True, z2symmetry_reduction=”auto”, </p>
			<p class="source-code">                  name_solver='NumPy exact solver', solver=numpy_solver, pyqmc=False)</p>
			<p><em class="italic">Figure 5.21</em> shows the first 20 terms of the fermionic operator of the macro molecule:</p>
			<div>
				<div id="_idContainer1558" class="IMG---Figure">
					<img src="Images/B18268_Figure_5.21.jpg" alt="" width="529" height="657"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.21 – First 20 terms of the fermionic Hamiltonian operator of the macro molecule </p>
			<p><em class="italic">Figure 5.22</em> shows the <a id="_idIndexMarker557"/>qubit Hamiltonian operator for the outermost two electrons of the macro molecule obtained with the parity transformation. Only two qubits are needed as expected for a parity mapping of the fermionic Hamiltonian operator to the qubit Hamiltonian operator:</p>
			<div>
				<div id="_idContainer1559" class="IMG---Figure">
					<img src="Images/B18268_Figure_5.22.jpg" alt="" width="550" height="283"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.22 – Qubit Hamiltonian operator of the outermost two electrons of the macro molecule </p>
			<p><em class="italic">Figure 5.23</em> shows the total ground state energy of the molecule computed by the PySCF RHF Python <a id="_idIndexMarker558"/>package and an estimation of the electronic ground state energy of the outermost two electrons of the molecule computed by the Qiskit Nature QPE class:</p>
			<div>
				<div id="_idContainer1560" class="IMG---Figure">
					<img src="Images/B18268_Figure_5.23.jpg" alt="" width="695" height="245"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.23 – Total and electronic ground state energy of the macro molecule by PySCF and QPE respectively</p>
			<p><em class="italic">Figure 5.24</em> shows the result of VQE computation:</p>
			<div>
				<div id="_idContainer1561" class="IMG---Figure">
					<img src="Images/B18268_Figure_5.24.jpg" alt="" width="953" height="619"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.24 – Ground state of macro molecule using the NumPy exact minimum eigensolver</p>
			<p>The electronic ground state energy of the outermost two electrons of the macromolecule <a id="_idIndexMarker559"/>computed by the QPE, <img src="Images/Formula_05_134.png" alt="" width="144" height="34"/> (Hartree), and by the VQE, <img src="Images/Formula_05_135.png" alt="" width="144" height="36"/>, Qiskit Nature classes are in good agreement.</p>
			<p>The total ground state energy of the macro molecule computed by the PySCF RHF Python package, <img src="Images/Formula_05_136.png" alt="" width="247" height="35"/> (Hartree), and by the Qiskit Nature VQE class, <img src="Images/Formula_05_137.png" alt="" width="247" height="40"/>, are in good agreement.</p>
			<h3>Computing the BOPES</h3>
			<p>We now compute and <a id="_idIndexMarker560"/>plot the BOPES of the macro molecule <a id="_idIndexMarker561"/>as follows:</p>
			<p class="source-code">perturbation_steps = np.linspace(-0.5, 3, 10) # 10 equally spaced points from -0.5 to 3, inclusive.</p>
			<p class="source-code">macro_fermionic_hamiltonian, macro_particle_number, macro_qubit_op, macro_qubit_converter, macro_ground_state = \</p>
			<p class="source-code">                  solve_ground_state(macromolecule, mapper =”Parity”,</p>
			<p class="source-code">                  num_electrons=2, num_molecular_orbitals=2,</p>
			<p class="source-code">                  two_qubit_reduction=True, z2symmetry_reduction=”auto”, </p>
			<p class="source-code">                  name_solver='NumPy exact solver', solver=numpy_solver, pyqmc=False,</p>
			<p class="source-code">                  plot_bopes=True, perturbation_steps=perturbation_steps)</p>
			<p><em class="italic">Figure 5.25</em> shows the result:</p>
			<div>
				<div id="_idContainer1566" class="IMG---Figure">
					<img src="Images/B18268_Figure_5.25.jpg" alt="" width="490" height="262"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.25 – Plot of the BOPES of the macro molecule </p>
			<p>The plot of the BOPES of the <a id="_idIndexMarker562"/>macro molecule shows no clear minimum <a id="_idIndexMarker563"/>for any separation. We conclude that there is no binding of the single carbon atom to the toy protease molecule of formamide.</p>
			<h1 id="_idParaDest-131"><a id="_idTextAnchor224"/>Summary</h1>
			<p>In this chapter, we have introduced classical and hybrid classical-quantum variational methods to find the lowest energy eigenvalue for a quantum system and their implementation with a classical PyQMC variational Monte Carlo Python package, which interoperates with the PySCF, and Qiskit Nature using the STO-3G basis with the Python-based PySCF driver.</p>
			<p>We have illustrated these methods, solving for the ground state and plotting the BOPES of the hydrogen molecule, the lithium hydride molecule, and the macro molecule.</p>
			<p>The results we obtained with Qiskit Nature VQE and QPE are in good agreement with those obtained with the PyQMC and PySCF RHF packages for several combinations of fermionic-to-qubit Hamiltonian mappers and classical gradient descent solvers and by reducing the quantum workload to the outermost two electrons of the formamide molecule. We hope these results will encourage the reader to replay these experiments with different choices of solvers and with other molecules.</p>
			<h1 id="_idParaDest-132"><a id="_idTextAnchor225"/>Questions</h1>
			<p>Please test your understanding of the concepts presented in this chapter with the corresponding Google Colab notebook:</p>
			<ol>
				<li>Does the variational theorem apply to excited states?</li>
				<li>True or False: The Metropolis-Hastings method is a way to approximate integration over spatial coordinates.</li>
				<li>True or False: VQE is only a quantum computing algorithm and does not require the use of classical computing.</li>
			</ol>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor226"/>Answers</h1>
			<ol>
				<li value="1">Yes</li>
				<li>True</li>
				<li>False</li>
			</ol>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor227"/>References</h1>
			<p>[ASE_0] Atomic Simulation Environment (ASE), <a href="https://wiki.fysik.dtu.dk/ase/index.html">https://wiki.fysik.dtu.dk/ase/index.html</a> </p>
			<p>[ASE_1] ASE, The Atoms object, <a href="https://wiki.fysik.dtu.dk/ase/ase/atoms.html">https://wiki.fysik.dtu.dk/ase/ase/atoms.html</a> </p>
			<p>[ASE_2] ASE Visualization, <a href="https://wiki.fysik.dtu.dk/ase/ase/visualize/visualize.html#module-ase.visualize">https://wiki.fysik.dtu.dk/ase/ase/visualize/visualize.html#module-ase.visualize</a> </p>
			<p>[Adamowicz_3] Tung WC, Pavanello M, Adamowicz L., Very accurate potential energy curve of the LiH molecule. TABLE I. Comparison of the convergence of the BO energy, in Eh, for the ground state of LiH molecule at R = 3.015 bohrs, J Chem Phys. 2011 Feb 14;134(6):064117. doi: 10.1063/1.3554211, <a href="https://doi.org/10.1063/1.3554211">https://doi.org/10.1063/1.3554211</a> </p>
			<p>[Africa21] IBM Quantum Challenge Africa 2021, <a href="https://github.com/qiskit-community/ibm-quantum-challenge-africa-2021">https://github.com/qiskit-community/ibm-quantum-challenge-africa-2021</a> </p>
			<p>[Burg] Vera von Burg, Guang Hao Low, Thomas Häner, Damian S. Steiger, Markus Reiher, Martin Roetteler, Matthias Troyer, Quantum computing enhanced computational catalysis, 3 Mar 2021, 10.1103/PhysRevResearch.3.033055, <a href="https://arxiv.org/abs/2007.14460">https://arxiv.org/abs/2007.14460</a> </p>
			<p>[Bushmanov] Sergey Bushmanov, How to plot a histogram using Matplotlib in Python with a list of data?, Stack Overflow, <a href="https://stackoverflow.com/questions/33203645/how-to-plot-a-histogram-using-matplotlib-in-python-with-a-list-of-data">https://stackoverflow.com/questions/33203645/how-to-plot-a-histogram-using-matplotlib-in-python-with-a-list-of-data</a> </p>
			<p>[Cao] Yudong Cao, Jonathan Romero, Jonathan P. Olson, Matthias Degroote, Peter D. Johnson, Mária Kieferová, Ian D. Kivlichan, Tim Menke, Borja Peropadre, Nicolas P. D. Sawaya, Sukin Sim, Libor Veis, Alán Aspuru-Guzik, Quantum Chemistry in the Age of Quantum Computing, Chem. Rev. 2019, 119, 19, 10856–10915, Aug 30, 2019, <a href="https://doi.org/10.1021/acs.chemrev.8b00803">https://doi.org/10.1021/acs.chemrev.8b00803</a> </p>
			<p>[Chen] Sija Chen, Quantum Monte Carlo Methods, Maplesoft, <a href="https://fr.maplesoft.com/Applications/Detail.aspx?id=154748">https://fr.maplesoft.com/Applications/Detail.aspx?id=154748</a> </p>
			<p>[Dagrada] Mario Dagrada, Improved quantum Monte Carlo simulations: from open to extended systems, Materials Science [cond-mat.mtrl-sci]. Université Pierre et Marie Curie - Paris VI; Universidad Nacional de San Martín, 2016. English. ⟨NNT: 2016PA066349⟩. ⟨tel-01478313⟩, <a href="https://tel.archives-ouvertes.fr/tel-01478313/document">https://tel.archives-ouvertes.fr/tel-01478313/document</a> </p>
			<p>[Ebomwonyi] Ebomwonyi, Osarodion, A Quantum Monte Carlo Calculation of the Ground State Energy for the Hydrogen Molecule Using the CASINO Code, 2013, Table 3.1: Comparative analysis of the ground state energies for the hydrogen molecule by different researchers, https://www.semanticscholar.org/paper/A-Quantum-Monte-Carlo-Calculation-of-the-Ground-for-Ebomwonyi/5316eb86f39cf4fa0a8fd06d136aac4db1105ad4 </p>
			<p>[Freeman] Freedman–Diaconis rule, Wikipedia, <a href="https://en.wikipedia.org/wiki/Freedman%E2%80%93Diaconis_rule">https://en.wikipedia.org/wiki/Freedman%E2%80%93Diaconis_rule</a> </p>
			<p>[Gorelov] Vitaly Gorelov, Quantum Monte Carlo methods for electronic structure calculations: application to hydrogen at extreme conditions, 1.4.1 Variational Monte Carlo (VMC), <a href="https://tel.archives-ouvertes.fr/tel-03045954/document">https://tel.archives-ouvertes.fr/tel-03045954/document</a> </p>
			<p>[Grok] Grok the Bloch Sphere, <a href="https://javafxpert.github.io/grok-bloch/">https://javafxpert.github.io/grok-bloch/</a> </p>
			<p>[H5py] Quick Start Guide, <a href="https://docs.h5py.org/en/stable/quick.html">https://docs.h5py.org/en/stable/quick.html</a> </p>
			<p>[IBM_CEO] IBM CEO: Quantum computing will take off 'like a rocket ship' this decade, Fast Company, Sept 28, 2021., <a href="https://www.fastcompany.com/90680174/ibm-ceo-quantum-computing-will-take-off-like-a-rocket-ship-this-decade">https://www.fastcompany.com/90680174/ibm-ceo-quantum-computing-will-take-off-like-a-rocket-ship-this-decade</a> </p>
			<p>[IBM_comp1] Welcome to IBM Quantum Composer, <a href="https://quantum-computing.ibm.com/composer/docs/iqx/">https://quantum-computing.ibm.com/composer/docs/iqx/</a> </p>
			<p>[IBM_comp2] IBM Quantum Composer, <a href="https://quantum-computing.ibm.com/composer/files/new">https://quantum-computing.ibm.com/composer/files/new</a> </p>
			<p>[Lolur] Lolur, Phalgun, Magnus Rahm, Marcus Skogh, Laura García-Álvarez and Göran Wendin, Benchmarking the Variational Quantum Eigensolver through Simulation of the Ground State Energy of Prebiotic Molecules on High-Performance Computers, arXiv:2010.13578v2 [quant-ph], 5 Jan 2021, <a href="https://arxiv.org/pdf/2010.13578.pdf">https://arxiv.org/pdf/2010.13578.pdf</a> </p>
			<p>[NumPy] NumPy: the absolute basics for beginners, <a href="https://numpy.org/doc/stable/user/absolute_beginners.html">https://numpy.org/doc/stable/user/absolute_beginners.html</a> </p>
			<p>[Panagiotis] Panagiotis Kl. Barkoutsos, Jerome F. Gonthier, Igor Sokolov, Nikolaj Moll, Gian Salis, Andreas Fuhrer, Marc Ganzhorn, Daniel J. Egger, Matthias Troyer, Antonio Mezzacapo, Stefan Filipp, Ivano Tavernelli, Quantum algorithms for electronic structure calculations: Particle-hole Hamiltonian and optimized wave-function expansions, Phys. Rev. A 98, 022322 – Published 20 August 2018, DOI: 10.1103/PhysRevA.98.022322, https://link.aps.org/doi/10.1103/PhysRevA.98.022322, <a href="https://arxiv.org/abs/1805.04340">https://arxiv.org/abs/1805.04340</a> </p>
			<p>[Pease] Christopher Pease, An Overview of Monte Carlo Methods, Towards Data Science, <a href="https://towardsdatascience.com/an-overview-of-monte-carlo-methods-675384eb1694">https://towardsdatascience.com/an-overview-of-monte-carlo-methods-675384eb1694</a> </p>
			<p>[PyQMC] PyQMC, a python module that implements real-space quantum Monte Carlo techniques, <a href="https://github.com/WagnerGroup/pyqmc">https://github.com/WagnerGroup/pyqmc</a> </p>
			<p>[PySCF] The Python-based Simulations of Chemistry Framework (PySCF), <a href="https://pyscf.org/">https://pyscf.org/</a> </p>
			<p>[Qiskit] Qiskit, <a href="https://qiskit.org/">https://qiskit.org/</a> </p>
			<p>[Qiskit_2021_Lab4] Julien Gacon, Lab 4: Introduction to Training Quantum Circuits, Qiskit Summer School 2021, <a href="https://learn.qiskit.org/summer-school/2021/lab4-introduction-training-quantum-circuits">https://learn.qiskit.org/summer-school/2021/lab4-introduction-training-quantum-circuits</a> </p>
			<p>[Qiskit_Nat_0] Qiskit_Nature, <a href="https://github.com/Qiskit/qiskit-nature/blob/main/README.md">https://github.com/Qiskit/qiskit-nature/blob/main/README.md</a> </p>
			<p>[Qiskit_Nat_3] ElectronicStructureProblem.second_q_ops, <a href="https://qiskit.org/documentation/nature/stubs/qiskit_nature.problems.second_quantization.ElectronicStructureProblem.second_q_ops.html">https://qiskit.org/documentation/nature/stubs/qiskit_nature.problems.second_quantization.ElectronicStructureProblem.second_q_ops.html</a> </p>
			<p>[Qiskit_Nat_4] QubitConverter, <a href="https://qiskit.org/documentation/nature/stubs/qiskit_nature.converters.second_quantization.QubitConverter.html">https://qiskit.org/documentation/nature/stubs/qiskit_nature.converters.second_quantization.QubitConverter.html</a> </p>
			<p>[Qiskit_Nat_5] Qiskit Nature Tutorials, Electronic structure, <a href="https://qiskit.org/documentation/nature/tutorials/01_electronic_structure.html">https://qiskit.org/documentation/nature/tutorials/01_electronic_structure.html</a> </p>
			<p>[Qiskit_Nat_6] Qiskit Nature Tutorials, Sampling the potential energy surface, <a href="https://qiskit.org/documentation/nature/_modules/qiskit_nature/algorithms/pes_samplers/bopes_sampler.html">https://qiskit.org/documentation/nature/_modules/qiskit_nature/algorithms/pes_samplers/bopes_sampler.html</a> </p>
			<p>[Qiskit_Nature] Introducing Qiskit Nature, Qiskit, Medium, April 6, 2021, <a href="https://medium.com/qiskit/introducing-qiskit-nature-cb9e588bb004">https://medium.com/qiskit/introducing-qiskit-nature-cb9e588bb004</a> </p>
			<p>[QuTiP] QuTiP, Plotting on the Bloch Sphere, <a href="https://qutip.org/docs/latest/guide/guide-bloch.html">https://qutip.org/docs/latest/guide/guide-bloch.html</a> </p>
			<p>[SciPy] Statistical functions (scipy.stats), <a href="https://docs.scipy.org/doc/scipy/getting_started.html">https://docs.scipy.org/doc/scipy/getting_started.html</a> </p>
			<p>[Stephens] Matthew Stephens, The Metropolis Hastings Algorithm, <a href="https://stephens999.github.io/fiveMinuteStats/MH_intro.html">https://stephens999.github.io/fiveMinuteStats/MH_intro.html</a>  </p>
			<p>[Toulouse] Julien Toulouse, Introduction to quantum chemistry, Jan 20, 2021, <a href="https://www.lct.jussieu.fr/pagesperso/toulouse/enseignement/introduction_qc.pdf">https://www.lct.jussieu.fr/pagesperso/toulouse/enseignement/introduction_qc.pdf</a> </p>
			<p>[Tamir] Abraham Tamir, Applications of Markov Chains in Chemical Engineering, Elsevier, 1998, 9780080527390, 0080527396, <a href="https://www.google.fr/books/edition/Applications_of_Markov_Chains_in_Chemica/X0ivOmHYPoYC">https://www.google.fr/books/edition/Applications_of_Markov_Chains_in_Chemica/X0ivOmHYPoYC</a> </p>
			<p>[Toulouse_1] Julien Toulouse, Quantum Monte Carlo wave functions and their optimization for quantum chemistry, CEA Saclay, SPhN Orme des Merisiers, April 2015, <a href="https://www.lct.jussieu.fr/pagesperso/toulouse/presentations/presentation_saclay_15.pdf">https://www.lct.jussieu.fr/pagesperso/toulouse/presentations/presentation_saclay_15.pdf</a> </p>
			<p>[Troyer] Matthias Troyer, Matthias Troyer: Achieving Practical Quantum Advantage in Chemistry Simulations, QuCQC 2021, <a href="https://www.youtube.com/watch?v=2MsfbPlKgyI">https://www.youtube.com/watch?v=2MsfbPlKgyI</a> </p>
			<p>[VQE_1] Peruzzo, A., McClean, J., Shadbolt, P. et al., A variational eigenvalue solver on a photonic quantum processor, Nat Commun 5, 4213 (2014), <a href="https://doi.org/10.1038/ncomms5213">https://doi.org/10.1038/ncomms5213</a> </p>
			<p>[VQE_2] Qiskit Nature, Ground state solvers, <a href="https://qiskit.org/documentation/nature/tutorials/03_ground_state_solvers.html">https://qiskit.org/documentation/nature/tutorials/03_ground_state_solvers.html</a> </p>
			<p>[VQE_3] Hardware-efficient variational quantum eigensolver for small molecules and quantum magnets, Nature 549, 242–246 (2017), <a href="https://doi.org/10.1038/nature23879">https://doi.org/10.1038/nature23879</a> </p>
			<p>[VQE_4] Running VQE on a Statevector Simulator, <a href="https://qiskit.org/textbook/ch-applications/vqe-molecules.html#Running-VQE-on-a-Statevector-Simulator">https://qiskit.org/textbook/ch-applications/vqe-molecules.html#Running-VQE-on-a-Statevector-Simulator</a> </p>
		</div>
	</div></body></html>