<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;Advanced Geometry Object Methods"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Advanced Geometry Object Methods</h1></div></div></div><p>In this chapter, we will discuss advanced Geometry object methods, previously discussed in <a class="link" href="ch06.html" title="Chapter 6. Working with ArcPy Geometry Objects">Chapter 6</a>, <span class="emphasis"><em>Working with ArcPy Geometry Objects</em></span>. The goal of this book is to give an introduction to ArcPy and its modules, while also demonstrating how to apply these tools when creating enduring GIS workflows. Performing an analysis once is good, but doing it over and over, with the click of a button, is better. Making the analysis results sharable in an industry standard format is also desirable. In the ArcGIS world, the best way to do this is with ArcPy and script tools that take advantage of Geometry object methods.</p><p>This chapter will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Adding common functions to a module in the Python path</li><li class="listitem" style="list-style-type: disc">Making the analysis more advanced by adding point generation</li><li class="listitem" style="list-style-type: disc">Advanced Polygon object methods</li><li class="listitem" style="list-style-type: disc">Using the XLWT to create Excel spreadsheets</li></ul></div><div class="section" title="Creating a Python module"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec49"/>Creating a Python module</h1></div></div></div><p>An<a id="id361" class="indexterm"/> important step towards creating reusable code is to package its component functions into a module that can be called from the Python path by any script. To start, we need to create a folder in the <code class="literal">site-packages</code> folder where Python modules are placed when downloaded and extracted using the Python module process, or when running the <code class="literal">setup.py</code> script included with shared modules.</p><p>Modules package together functions in one or more scripts into a folder that can be shared with others (though they often depend on other modules to run). We have used some of the built-in modules such as the <code class="literal">csv</code> module and third-party modules such as ArcPy. Let's explore their construction to get a feel of how a module is packaged for use and sharing.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>Many modules are not placed within the site-packages folder, but they require the Python path to be modified to make them <span class="strong"><strong>importable</strong></span>. Placing modules within the site-packages folder eliminates this requirement.</p></div></div><p>Open<a id="id362" class="indexterm"/> up the site-packages folder in Windows Explorer by navigating to <code class="literal">C:\Python27\ArcGIS10.2\Lib\site-packages</code> (or <code class="literal">C:\Python27\Lib\site-packages</code> if you're using the standard Python 2.7 installation) folder. Once in the folder, create a new folder called <span class="strong"><strong>common</strong></span>, as shown in the following screenshot:</p><p> </p><div class="mediaobject"><img src="graphics/8662OS_10_01.jpg" alt="Creating a Python module"/></div><p>
</p><div class="section" title="The __init__.py file"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec72"/>The __init__.py file</h2></div></div></div><p>Within <a id="id363" class="indexterm"/>this folder, a special file needs to be added to<a id="id364" class="indexterm"/> let Python recognize the folder as a module. This file, called <code class="literal">__init__.py</code>, takes advantage of the special property of Python called <code class="literal">magic</code> objects or attributes that are built into Python. These <code class="literal">magic</code> objects use the leading and trailing double underscore to avoid any confusion with custom functions.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>Note that these are <span class="emphasis"><em>double</em></span> underscores; single underscores are usually used for so-called private functions within custom Python classes.</p></div></div><p>The <code class="literal">__init__.py </code>file is used to indicate that the folder is a module (making it importable using the <code class="literal">import</code> keyword), and to initiate the module by calling any modules that it may in turn rely on. However, there is no requirement to add import commands to the <code class="literal">__init__.py</code> file; it can be an empty file and will still perform the module recognition<a id="id365" class="indexterm"/> functionality that we require.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open up <span class="strong"><strong>IDLE</strong></span> or <span class="strong"><strong>Aptana</strong></span> or your favorite IDE, and in the folder called <span class="strong"><strong>common</strong></span>, add <a id="id366" class="indexterm"/>a new <code class="literal">Python</code> file and call it <code class="literal">__init__.py</code>. This file will remain empty for now.<p> </p><div class="mediaobject"><img src="graphics/8662OS_10_02.jpg" alt="The __init__.py file"/></div><p>
</p></li><li class="listitem">Now that we have initiated the module, we need to create a script that will hold our common functions. Let's call it <code class="literal">useful.py</code> because these functions will be most useful for this analysis and others.</li><li class="listitem">The next step is to transfer functions that we had created in earlier chapters. These valuable functions are locked into those scripts, so by adding them to <code class="literal">useful.py</code>, we will make them available to all other scripts we craft.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>One important function is the <code class="literal">formatSQLMultiple</code> from <a class="link" href="ch04.html" title="Chapter 4. Complex ArcPy Scripts and Generalizing Functions">Chapter 4</a>, <span class="emphasis"><em>Complex ArcPy Scripts and Generalizing Functions,</em></span> which generates SQL statements using a template and a list of data. By adding it to <code class="literal">useful.py</code>, we will be able to call the function anytime a SQL statement is required.</p></div></div></li><li class="listitem">Open the script <code class="literal">Chapter4Modified2.py</code> and copy the function, and then paste it into <code class="literal">useful.py</code>. It has no dependencies, so it does not have to be modified.</li></ol></div><p>Another useful function from that script is the <code class="literal">formatIntersect</code> function that generates a string of file paths that are used when running the ArcToolbox Intersect tool. While we have <a id="id367" class="indexterm"/>reached deeper into ArcPy since that function was<a id="id368" class="indexterm"/> designed, and no longer need to call the Intersect tool in our bus stop analysis, it does not mean that we will never need to call it in the future. It is still useful and should be added to <code class="literal">useful.py</code>.</p><p>The last function that we can raid is the <code class="literal">createCSV()</code> function. Copy and paste it from <code class="literal">Chapter4Modified.py</code> into <code class="literal">useful.py</code>. However, to avoid the need to import the CSV module separately, we will need to modify the function slightly. Here is how it should look:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>def createCSV(data, csvname, mode ='ab'):</strong></span>
<span class="strong"><strong>    'creates a csv file'</strong></span>
<span class="strong"><strong>    import csv</strong></span>
<span class="strong"><strong>    with open(csvname, mode) as csvfile:</strong></span>
<span class="strong"><strong>        csvwriter = csv.writer(csvfile, delimiter=',')</strong></span>
<span class="strong"><strong>        csvwriter.writerow(data)</strong></span>
<span class="strong"><strong>    del csv</strong></span>
</pre></div><p>By importing and then deleting the <code class="literal">csv</code> module, we are able to use it to generate the <code class="literal">csv</code> file and then remove the module from memory using the <code class="literal">del</code> keyword.</p><p>Now that we have the functions we will be reusing saved in the <code class="literal">useful.py</code> script, inside the common module, let's explore how to call them using Python's <code class="literal">import</code> method. Open up a Python executable, using either <code class="literal">Python.exe</code> or IDLE, or the built-in terminal in Aptana. At the triple chevron prompt (<span class="strong"><strong>&gt;&gt;&gt;</strong></span>), write the following line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; from common.useful import createCSV&gt;&gt;&gt;</strong></span>
</pre></div><p>If the second triple chevron-shaped prompt appears, the function was correctly imported from the module. To import the functions in this module in a script, use the same import structure and list the functions desired, separating them using a comma:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>from common.useful import createCSV, formatSQLMultiple</strong></span>
</pre></div><p>The functions in the script <code class="literal">useful.py</code> were called using Python dot notation. This is made possible because the <code class="literal">__init__.py</code> file indicates to Python that the folder <code class="literal">common</code> is now a <a id="id369" class="indexterm"/>module, and that it should expect a method<a id="id370" class="indexterm"/> called <code class="literal">useful</code> to be present, with the functions <code class="literal">createCSV</code> and <code class="literal">formatSQLMultiple</code> inside it.</p></div></div></div>
<div class="section" title="Adding advanced analysis components"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec50"/>Adding advanced analysis components</h1></div></div></div><p>The bus <a id="id371" class="indexterm"/>stop analysis we have used to introduce ArcPy can be further extended to generate more refined results. To better estimate the true number of people that each bus stop serves, let's add a function that will generate random points within the blocks considered, while eliminating parks and other areas that do not contain housing.</p><p>To do this, we need to introduce a new data set from the <code class="literal">San Francisco</code> geodatabase, the <code class="literal">RPD_Parks</code> feature class. By using this feature class to reduce the area considered for our analysis, we can generate a more realistic assessment of the service area population for each bus stop.</p><p>While using the <span class="strong"><strong>ArcToolbox Erase tool</strong></span> to erase the area represented in the <code class="literal">RPD_Parks</code> polygons would be a usual step when running a spatial analysis, there are drawbacks to this option. The first is that the <span class="strong"><strong>Erase</strong></span> tool is only available with the ArcGIS for Desktop Advanced license level, making it available only to certain users. The second drawback is that the tool produces an intermediate data set, something to be avoided wherever possible.</p><p>Using ArcPy will give us the ability to avoid both of these drawbacks. We can create a script that will generate random points only within the fraction of the census block polygons that do not intersect with the <code class="literal">RPD_Parks</code> feature class. To do this, we will reach deeper into the methods of the ArcPy <code class="literal">Polygon</code> object.</p><div class="section" title="Advanced Polygon object methods"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec73"/>Advanced Polygon object methods</h2></div></div></div><p>In <a class="link" href="ch06.html" title="Chapter 6. Working with ArcPy Geometry Objects">Chapter 6</a>, <span class="emphasis"><em>Working with ArcPy Geometry Objects</em></span> we started exploring the ArcPy Geometry <a id="id372" class="indexterm"/>objects and how to use their methods <a id="id373" class="indexterm"/>to perform in-memory spatial analysis. The <span class="strong"><strong>Buffer</strong></span> and <span class="strong"><strong>Intersect</strong></span> methods of these objects were introduced and used to generate analysis results. Next, we will discuss more of these methods and show how they can help improve in-memory spatial analysis.</p><p>The <code class="literal">Polygon</code> object has a method called <code class="literal">Difference</code> that allows us to find the area of non-intersection when two polygons intersect. Passing a <code class="literal">census block polygon</code> and a <code class="literal">park polygon</code> as parameters will return (as a polygon object) the fraction of the first parameter where no overlap occurs. Another important method is called <code class="literal">Overlaps</code>, which is called to test whether two Geometry objects (points, lines, or polygons) intersect. If there is an overlap, the <code class="literal">Overlaps</code> method will return <span class="strong"><strong>True</strong></span>, while returning <span class="strong"><strong>False</strong></span> if there is no overlap between the two objects. <code class="literal">Union</code> is also an important method that will be used within this chapter, it allows for two Geometry objects to be <span class="strong"><strong>unioned</strong></span> into one object.</p><p>Let's explore<a id="id374" class="indexterm"/> these important methods. To find<a id="id375" class="indexterm"/> the non-intersect area of two polygon objects, the following function combines the <code class="literal">Overlaps</code> and <code class="literal">Difference</code> methods:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>def nonIntersect(poly1,poly2):</strong></span>
<span class="strong"><strong>    'returns area of non-intersect between two polygons'</strong></span>
<span class="strong"><strong>    if poly1.overlaps(poly2) == True:</strong></span>
<span class="strong"><strong>        return poly1.difference(poly2)</strong></span>
</pre></div><p>The function <code class="literal">nonIntersect</code> accepts two <code class="literal">Polygon</code> objects as parameters. The first parameter, <code class="literal">poly1</code>, is the polygon of intersect (the census block polygon) and the second parameter, <code class="literal">poly2</code>, is the polygon to be checked for overlap. The if conditional uses the <code class="literal">Overlaps</code> method and returns <span class="strong"><strong>True</strong></span> if there is an overlap between the two parameters. If there is any overlap, the <code class="literal">difference()</code> method returns the non-intersect area as a polygon object. However, this function should be extended to cover situations where the <code class="literal">Overlaps()</code> method returns False:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>def nonIntersect(poly1,poly2):</strong></span>
<span class="strong"><strong>    'returns area of non-intersect between two polygons'</strong></span>
<span class="strong"><strong>    if poly1.overlaps(poly2) == True:</strong></span>
<span class="strong"><strong>        return poly1.difference(poly2)</strong></span>
<span class="strong"><strong>    else:</strong></span>
<span class="strong"><strong>        return poly1</strong></span>
</pre></div><p>The function will now return the first parameter when the <code class="literal">Overlaps</code> method returns <code class="literal">False</code>, indicating that there is no overlap between the two polygon objects. This function is now complete and available to be used in an analysis. Because <code class="literal">nonIntersect()</code> is a function that can be used in other spatial analyses, copy it and add it to <code class="literal">useful.py</code>.</p></div><div class="section" title="Generating random points to represent population"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec74"/>Generating random points to represent population</h2></div></div></div><p>The <a id="id376" class="indexterm"/>next step to<a id="id377" class="indexterm"/> improve the bus stop analysis is to generate points to represent the population of each census block. While random points will not provide a perfect representation of the population, it will serve as a good model of the population and allow us to avoid area averaging to find the rough population of each census block served by a bus stop. The <code class="literal">CreateRandomPoints</code> tool in the ArcToolbox Data Management toolset makes it simple to generate the points.</p><p>The <code class="literal">CreateRandomPoints</code> tool accepts a number of required and optional parameters. As the tool generates a feature class, the required parameters are the workspace where the feature class will be <a id="id378" class="indexterm"/>placed and the name of the feature class. The optional parameters of interest are the <a id="id379" class="indexterm"/>constraining feature class and the number of points to be generated. As we are looking to avoid creating new feature classes in the intermediate steps of our analysis, we can utilize the <code class="literal">in_memory</code> workspace, which allows feature classes to be generated in memory, meaning they are not written to the hard drive.</p><p>Because there is a need to generate a specific number of random points for each census block, we should create a function that will accept a constraining polygon and population figure that represents each census block. The <code class="literal">in_memory</code> workspace won't work for every situation, however, so we'll provide the workspace parameter with a default value:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>def generatePoints(fc, pop,constrant, workspace='in_memory'):</strong></span>
<span class="strong"><strong>    'generate random points'</strong></span>
<span class="strong"><strong>    import os, arcpy</strong></span>
<span class="strong"><strong>    arcpy.CreateRandomPoints_management(workspace, fc,                  constrant, "", pop, "")</strong></span>
<span class="strong"><strong>    return os.path.join(workspace, fc)</strong></span>
</pre></div><p>The function will create the feature class in the workspace desired and will return the path (joined using the <code class="literal">os</code> module) to the feature class for use in the rest of the script. This function is also reusable and should be copied into <code class="literal">useful.py</code>.</p></div><div class="section" title="Using the functions within a script"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec75"/>Using the functions within a script</h2></div></div></div><p>Now <a id="id380" class="indexterm"/>that we have created the functions<a id="id381" class="indexterm"/> that will help us to run a more advanced spatial analysis, let's add them to a script along with some <code class="literal">SearchCursors</code> to iterate through the data:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># Import the necessary modules</strong></span>
<span class="strong"><strong>import arcpy, os</strong></span>
<span class="strong"><strong>from common.useful import nonIntersect, generatePoints,createCSV</strong></span>

<span class="strong"><strong># Add an overwrite statement</strong></span>
<span class="strong"><strong>arcpy.env.overwriteOutput = True</strong></span>

<span class="strong"><strong># Define the data inputs</strong></span>
<span class="strong"><strong>busStops = r'C:\Projects\SanFrancisco.gdb\SanFrancisco\Bus_Stops'</strong></span>
<span class="strong"><strong>parks = r'C:\Projects\SanFrancisco.gdb\SanFrancisco\RPD_Parks'</strong></span>
<span class="strong"><strong>censusBlocks = r'C:\Projects\SanFrancisco.gdb\SanFrancisco\CensusBlocks2010'</strong></span>
<span class="strong"><strong>csvName = r'C:\Projects\Output\Chapter10Analysis.csv'</strong></span>

<span class="strong"><strong># Create the spreadsheet in memory and add field headers</strong></span>
<span class="strong"><strong>headers = 'Line Name','Stop ID', 'Total Population Served'</strong></span>
<span class="strong"><strong>createCSV(headers,csvName,mode='wb')</strong></span>

<span class="strong"><strong># Copy the census block data into a feature layer</strong></span>
<span class="strong"><strong>arcpy.MakeFeatureLayer_management(censusBlocks,'census_lyr')</strong></span>

<span class="strong"><strong># Copy the park data geometries into a list and union them allparkGeoms = arcpy.CopyFeatures_management(parks,arcpy.Geometry())</strong></span>
<span class="strong"><strong>parkUnion = parkGeoms[0]</strong></span>
<span class="strong"><strong>for park in parkGeoms[1:]:</strong></span>
<span class="strong"><strong>    parkUnion = parkUnion.union(park)</strong></span>

<span class="strong"><strong># Create a search cursor to iterate the bus stop data</strong></span>
<span class="strong"><strong>sql = "NAME = '71 IB' AND BUS_SIGNAG = 'Ferry Plaza'"</strong></span>
<span class="strong"><strong>with arcpy.da.SearchCursor(busStops, ['NAME','STOPID','SHAPE@'],sql) as cursor:</strong></span>
<span class="strong"><strong>    for row in cursor:</strong></span>
<span class="strong"><strong>        </strong></span>
<span class="strong"><strong>lineName = row[0]</strong></span>
<span class="strong"><strong>        stopID = row[1]</strong></span>
<span class="strong"><strong>        stop = row[2]</strong></span>
<span class="strong"><strong>        busBuf = stop.buffer(400)</strong></span>
<span class="strong"><strong>        # Select census blocks that intersect the bus buffer</strong></span>
<span class="strong"><strong>        arcpy.SelectLayerByLocation_management("census_lyr","intersect", busBuf,'','NEW_SELECTION')</strong></span>
<span class="strong"><strong>        # Use a second Cursor to find the selected population</strong></span>
<span class="strong"><strong>       totalPopulation = 0</strong></span>
<span class="strong"><strong>        with arcpy.da.SearchCursor("census_lyr",['SHAPE@','POP10',</strong></span>
<span class="strong"><strong>             'BLOCKID10']) as ncursor:</strong></span>
<span class="strong"><strong>            for nrow in ncursor:</strong></span>
<span class="strong"><strong>                block = nrow[0]</strong></span>
<span class="strong"><strong>                checkedBlock = nonIntersect(block, parkUnion)</strong></span>
<span class="strong"><strong>                </strong></span>
<span class="strong"><strong>blockName = nrow[2]</strong></span>
<span class="strong"><strong>                population = nrow[1]</strong></span>
<span class="strong"><strong>                if population != 0:</strong></span>
<span class="strong"><strong>                    points = generatePoints("PopPoints",</strong></span>
<span class="strong"><strong>                      population,checkedBlock)</strong></span>
<span class="strong"><strong>          pointsGeoms = arcpy.CopyFeatures_management(points,arcpy.Geometry())</strong></span>
<span class="strong"><strong>                    pointsUnion = pointsGeoms[0]</strong></span>
<span class="strong"><strong>                    for point in pointsGeoms[1:]:</strong></span>
<span class="strong"><strong>                        pointsUnion = pointsUnion.union(point)</strong></span>
<span class="strong"><strong>                    pointsInBuffer=busBuf.intersect(pointsUnion, 1)</strong></span>
<span class="strong"><strong>                    intersectedPoints = pointsInBuffer.pointCount</strong></span>
<span class="strong"><strong>                    totalPopulation += intersectedPoints</strong></span>
<span class="strong"><strong>       # Add the tallied data to the spreadsheet</strong></span>
<span class="strong"><strong>        </strong></span>
<span class="strong"><strong>data = lineName, stopID, totalPopulation</strong></span>
<span class="strong"><strong>        print 'data written', data</strong></span>
<span class="strong"><strong>        createCSV(data, csvName)</strong></span>

<span class="strong"><strong>#Start the spreadsheet to see the results</strong></span>
<span class="strong"><strong>os.startfile(csvName)</strong></span>
</pre></div><p>Let's review the code, section by section, as that is a lot to take in at first.</p><p>The <a id="id382" class="indexterm"/>import portion is where we call the<a id="id383" class="indexterm"/> usual modules, arcpy and os, along with our custom functions in the common module:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>import arcpy, os</strong></span>
<span class="strong"><strong>from common.useful import nonIntersect</strong></span>
<span class="strong"><strong>from common.useful import generatePoints</strong></span>
<span class="strong"><strong>from common.useful import formatSQLMultiple</strong></span>
<span class="strong"><strong>from common.useful import nonIntersectcreateCSV</strong></span>
</pre></div><p>As discussed previously, the functions in the <code class="literal">common</code> module's <code class="literal">useful</code> method are called using the Python dot notation and the <code class="literal">from … import ...</code> importation style, making them available directly. Many functions can be imported on one line, separated by commas, or individually as shown here.</p><p>The next line, which sets the ArcPy Environment <code class="literal">overwrite</code> property to <code class="literal">True</code>, is very important because it allows us to overwrite the results of the Create random points operation. If the results were not overwritten, the function results, which otherwise would use all available memory and cause the script to fail:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>arcpy.env.overwriteOutput = True</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>It is important to be careful with this overwrite setting because it will allow for any feature class to be overwritten. All of our output is in memory and only generated for the analysis, so there is little need to worry here, but take care to make sure that nothing important is overwritten when running a script.</p></div></div><p>The next <a id="id384" class="indexterm"/>portion is the set of variables that<a id="id385" class="indexterm"/> will be used in this script, and will initiate the spreadsheet that will be used to collect the results of the analysis:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>busStops = r'C:\PacktDB.gdb\SanFrancisco\Bus_Stops'</strong></span>
<span class="strong"><strong>parks = r'C:\PacktDB.gdb\SanFrancisco\RPD_Parks'</strong></span>
<span class="strong"><strong>censusBlocks = r'C:\PacktDB.gdb\SanFrancisco\CensusBlocks2010'</strong></span>
<span class="strong"><strong>csvName = r'C:\Projects\Output\Chapter10Analysis.csv'</strong></span>
<span class="strong"><strong>headers = 'Line Name','Stop ID', 'Total Population Served'</strong></span>
<span class="strong"><strong>createCSV(headers,csvName,mode='wb')</strong></span>
</pre></div><p>The file paths assigned to variables here could be replaced with ArcPy parameters if we were to turn this into a script tool, but for now, the hard-coded paths are fine. Below the variables, the results spreadsheet is created and the column field headers are added.</p><p>It is worth noting that the spreadsheet is created using the <code class="literal">wb</code> mode. This mode of binary file opening, known as <code class="literal">wb</code> (write binary), is used for creating a new file. It must be explicitly passed into the <code class="literal">createCSV()</code> function as the default mode parameter is <code class="literal">ab</code> (append binary), which will create a new file if it does not exist, or add to one that already exists (a third binary mode is <span class="strong"><strong>rb</strong></span> or <span class="strong"><strong>read binary</strong></span>, which is used for opening an existing file).</p><p>The next few lines make data in the feature classes available in memory. The census block data is converted into a <code class="literal">Feature Layer</code>, while the <code class="literal">RPD_Parks</code> data is read into memory as a list of <code class="literal">Polygon</code> objects that is then unioned into a single, unified <code class="literal">Polygon</code> object called <code class="literal">parkUnion</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>arcpy.MakeFeatureLayer_management(censusBlocks,'census_lyr')parkGeoms = arcpy.CopyFeatures_management(parks,arcpy.Geometry())</strong></span>
<span class="strong"><strong>parkUnion = parkGeoms[0]</strong></span>
<span class="strong"><strong>for park in parkGeoms[1:]:</strong></span>
<span class="strong"><strong>    parkUnion = parkUnion.union(park)</strong></span>
</pre></div><p>By using the <code class="literal">CopyFeatures</code> tool in the <span class="strong"><strong>Data Management</strong></span> toolset, the <code class="literal">parkGeoms</code> variable is passed a list of the geometries for each row of data in the <code class="literal">RPD_Parks</code> feature class. However, we don't want to have to iterate through the park geometries to compare them to each census block, so the <code class="literal">Union</code> method is invoked to create one <code class="literal">Polygon</code> object from the entire list. By assigning the first member of the list to the <code class="literal">parkUnion</code> variable, and then iterating through the <code class="literal">parkGeoms</code> list to union the other geometries one by one, the result is one <code class="literal">Polygon</code> object that represents all parks within the <code class="literal">RPD_Parks</code> dataset.</p><p>Once <a id="id386" class="indexterm"/>all of the modules have been imported <a id="id387" class="indexterm"/>and the variables have been assigned, we can enter the <code class="literal">for</code> loop of the data access <code class="literal">SearchCursor</code> to begin the analysis. However, we don't want to run this for all of the bus stops, so we will use a SQL statement <code class="literal">where </code>clause, to limit the analysis to a single bus line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sql = "NAME = '71 IB' AND BUS_SIGNAG = 'Ferry Plaza'"</strong></span>
<span class="strong"><strong>with arcpy.da.SearchCursor(busStops, ['NAME','STOPID','SHAPE@'],sql) as cursor:</strong></span>
<span class="strong"><strong>    for row in cursor:</strong></span>
<span class="strong"><strong>        lineName = row[0]</strong></span>
<span class="strong"><strong>        stopID = row[1]</strong></span>
<span class="strong"><strong>        stop = row[2]</strong></span>
<span class="strong"><strong>        busBuf = stop.buffer(400)</strong></span>
<span class="strong"><strong>        arcpy.SelectLayerByLocation_management("census_lyr","intersect,busBuf,'','NEW_SELECTION')</strong></span>
<span class="strong"><strong>        totalPopulation = 0</strong></span>
</pre></div><p>The first portion of the iteration involves entering the <code class="literal">for</code> loop and assigning the values of each row to a variable. A <code class="literal">Polygon</code> object buffer of <code class="literal">400</code> feet is created around the <code class="literal">PointGeometry</code> object returned by the <code class="literal">SearchCursor</code>. This buffer is then used to intersect with the census blocks <code class="literal">Feature Layer</code> to find and select all of the census blocks that intersect the buffer. To tally the population served by each buffer, the variable <code class="literal">totalPopulation</code> is created.</p><p>Once the selection has been performed, a second <code class="literal">SearchCursor</code> can be used to iterate through the selected blocks to retrieve their population values and <code class="literal">Polygon</code> objects for random point generation:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>with arcpy.da.SearchCursor("census_lyr",['SHAPE@','POP10',</strong></span>
<span class="strong"><strong>                'BLOCKID10']) as ncursor:</strong></span>
<span class="strong"><strong>     for nrow in ncursor:</strong></span>
<span class="strong"><strong>            </strong></span>
<span class="strong"><strong>block = nrow[0]</strong></span>
<span class="strong"><strong>            checkedBlock = nonIntersect(block, parkUnion)</strong></span>
<span class="strong"><strong>            blockName = nrow[2]</strong></span>
<span class="strong"><strong>            population = nrow[1]</strong></span>
</pre></div><p>In this iteration, once each census block has been retrieved (in the form of a Polygon object), the block is then checked against the <span class="strong"><strong>unioned</strong></span> park geometry using the <code class="literal">nonIntersect</code> function created previously. This ensures that the points will only be created within areas that are not parks, that is, more likely to represent where people would live. The population values are also retrieved.</p><p>Once <a id="id388" class="indexterm"/>the constraining polygon (for example the census block) has been evaluated and any potential park portion has been removed, and the<a id="id389" class="indexterm"/> population value is available, the random points can be generated using the <code class="literal">generatePoints()</code> function:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>if population != 0:</strong></span>
<span class="strong"><strong>   points = generatePoints("PopPoints",population,checkedBlock)</strong></span>
<span class="strong"><strong>   pointsGeoms = arcpy.CopyFeatures_management(points,arcpy.Geometry())</strong></span>
<span class="strong"><strong>   pointsUnion = pointsGeoms[0]</strong></span>
<span class="strong"><strong>   for point in pointsGeoms[1:]:</strong></span>
<span class="strong"><strong>        pointsUnion = pointsUnion.union(point)</strong></span>
<span class="strong"><strong>   pointsInBuffer = busBuf.intersect(pointsUnion,1)</strong></span>
<span class="strong"><strong>   intersectedPoints = pointsInBuffer.pointCount</strong></span>
<span class="strong"><strong>   totalPopulation += intersectedPoints</strong></span>
</pre></div><p>The <code class="literal">generatePoints()</code> function requires three parameters. The first is the name of the feature class to be generated; this will be overwritten each time it is generated, thus avoiding the overuse of memory by creating an <code class="literal">in_memory</code> feature class for each census block. The other two parameters are the population value and the constraining Polygon object.</p><p>Once these have been passed to the function, it returns a file path to the newly created feature class and assigns the file path to the variable points. The geometries in points are then extracted using the <code class="literal">CopyFeatures</code> tool and assigned to the variable <code class="literal">points</code>. The <code class="literal">Union</code> method is again used to create a single, unified population <code class="literal">PointGeometry</code> object that will be intersected with the bus stop buffer. Once this intersection has been run, the resulting geometries are assigned to the <code class="literal">pointsInBuffer</code> variable and the <code class="literal">pointCount</code> method is used to find the number of points that were generated within the buffered area. This is our estimate of population within the census block, and this value is added to the <code class="literal">totalPopulation</code> variable to eventually yield the total estimated population within 400 feet of the bus stop.</p><p>The final lines of the script demonstrate how the data is collected into a tuple and passed to the <code class="literal">createCSV()</code> module to be written to our final spreadsheet:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>        data = lineName, stopID,totalPopulation</strong></span>
<span class="strong"><strong>        print 'data written', data</strong></span>
<span class="strong"><strong>        createCSV(data, csvName)</strong></span>
<span class="strong"><strong>os.startfile(csvName)</strong></span>
</pre></div><p>The last line, <code class="literal">os.startfile(csvName)</code>, uses the <code class="literal">startfile</code> method of the <code class="literal">os</code> module to automatically open the spreadsheet once the analysis is completed. In this case, the spreadsheet <code class="literal">C:\Projects\Output\Chapter10Analysis.csv</code> has been populated with the results <a id="id390" class="indexterm"/>of the analysis and is opened to <a id="id391" class="indexterm"/>display these results. However, the user may have to indicate that the lines are comma separated values to open the script.</p><div class="mediaobject"><img src="graphics/8662OS_10_03.jpg" alt="Using the functions within a script"/></div><p>Instead of creating a comma separated value, we can take advantage of another Python module that is installed when ArcGIS 10.2 and ArcPy is installed. This module, called <code class="literal">XLWT</code>, is used to generate Excel spreadsheets, and along with the Excel spreadsheet reading module <code class="literal">XLRD</code>, is one of the most useful modules available to users of Python.</p></div><div class="section" title="Creating an XLS using XLWT"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec76"/>Creating an XLS using XLWT</h2></div></div></div><p>XLWT is<a id="id392" class="indexterm"/> a powerful module that allows <a id="id393" class="indexterm"/>for a multitude of styling options. However, for our purposes we can ignore those options and create a function that will generate a spreadsheet with the results of our spatial analysis. This function can of course be added to <code class="literal">common.useful</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>def generateXLS(indatas, sheetName, fileName):</strong></span>
<span class="strong"><strong>    import xlwt</strong></span>
<span class="strong"><strong>    workbook = xlwt.Workbook()</strong></span>
<span class="strong"><strong>    sheet = workbook.add_sheet(sheetName)</strong></span>
<span class="strong"><strong>    for YCOUNTER, data in enumerate(indatas):</strong></span>
<span class="strong"><strong>        for XCOUNTER, value in enumerate(data):</strong></span>
<span class="strong"><strong>            sheet.write(YCOUNTER, XCOUNTER, value)</strong></span>
<span class="strong"><strong>    workbook.save(fileName)</strong></span>
</pre></div><p>This function requires three parameters, <code class="literal">indatas</code>- a list containing rows of iterable data, a string sheet name, and a string file name that ends with the <code class="literal">.xls</code> extension.</p><p>To use this function, add it to <code class="literal">common.useful</code>. Once it has been added, copy and rename the older analysis script so that it can be adjusted:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>import arcpy, os</strong></span>
<span class="strong"><strong>from common.useful import nonIntersect, generatePoints, generateXLS</strong></span>

<span class="strong"><strong>arcpy.env.overwriteOutput = True</strong></span>

<span class="strong"><strong>busStops = r'C:\Projects\PacktDB.gdb\SanFrancisco\Bus_Stops'</strong></span>
<span class="strong"><strong>parks = r'C:\Projects\PacktDB.gdb\SanFrancisco\RPD_Parks'</strong></span>
<span class="strong"><strong>censusBlocks = r'C:\Projects\PacktDB.gdb\SanFrancisco\CensusBlocks2010'</strong></span>
<span class="strong"><strong>xlsName = r'C:\Projects\Output\Chapter10Analysis.xls'</strong></span>

<span class="strong"><strong>headers = 'Line Name','Stop ID', 'Total Population Served'</strong></span>
<span class="strong"><strong>indatas = [headers]</strong></span>

<span class="strong"><strong>arcpy.MakeFeatureLayer_management(censusBlocks,'census_lyr')parkGeoms = arcpy.CopyFeatures_management(parks,arcpy.Geometry())</strong></span>
<span class="strong"><strong>parkUnion = parkGeoms[0]</strong></span>
<span class="strong"><strong>for park in parkGeoms[1:]:</strong></span>
<span class="strong"><strong>    </strong></span>
<span class="strong"><strong>parkUnion = parkUnion.union(park)</strong></span>


<span class="strong"><strong>sql = "NAME = '71 IB' AND BUS_SIGNAG = 'Ferry Plaza'"</strong></span>
<span class="strong"><strong>with arcpy.da.SearchCursor(busStops, ['NAME','STOPID',</strong></span>
<span class="strong"><strong>              'SHAPE@'],sql) as cursor:</strong></span>
<span class="strong"><strong>    for row in cursor:</strong></span>
<span class="strong"><strong>        lineName = row[0]</strong></span>
<span class="strong"><strong>        stopID = row[1]</strong></span>
<span class="strong"><strong>        stop = row[2]</strong></span>
<span class="strong"><strong>        busBuf = stop.buffer(400)</strong></span>
<span class="strong"><strong>        arcpy.SelectLayerByLocation_management("census_lyr","intersect",busBuf,'','NEW_SELECTION')</strong></span>
<span class="strong"><strong>        totalPopulation = 0</strong></span>
<span class="strong"><strong>        with arcpy.da.SearchCursor("census_lyr", ['SHAPE@','POP10',</strong></span>
<span class="strong"><strong>              'BLOCKID10']) as ncursor:</strong></span>
<span class="strong"><strong>            for nrow in ncursor:</strong></span>
<span class="strong"><strong>                </strong></span>
<span class="strong"><strong>block = nrow[0]</strong></span>
<span class="strong"><strong>                checkedBlock = nonIntersect(block, parkUnion)</strong></span>
<span class="strong"><strong>                blockName = nrow[2]</strong></span>
<span class="strong"><strong>                population = nrow[1]</strong></span>
<span class="strong"><strong>                if population != 0:</strong></span>
<span class="strong"><strong>                    points = generatePoints("PopPoints",population,checkedBlock)</strong></span>

<span class="strong"><strong>       pointsGeoms = arcpy.CopyFeatures_management(points,arcpy.Geometry())</strong></span>
<span class="strong"><strong>                    pointsUnion = pointsGeoms[0]</strong></span>
<span class="strong"><strong>                    for point in pointsGeoms[1:]:</strong></span>
<span class="strong"><strong>                        pointsUnion = pointsUnion.union(point)</strong></span>
<span class="strong"><strong>                    pointsInBuffer = busBuf.intersect(pointsUnion,1)</strong></span>
<span class="strong"><strong>                    </strong></span>
<span class="strong"><strong>intersectedPoints = pointsInBuffer.pointCount</strong></span>
<span class="strong"><strong>                    totalPopulation += intersectedPoints</strong></span>
<span class="strong"><strong>        data = lineName, stopID, totalPopulation</strong></span>
<span class="strong"><strong>        indatas.append(data)</strong></span>
<span class="strong"><strong>generateXLS(indatas, "Results", xlsName)</strong></span>
<span class="strong"><strong>os.startfile(xlsName)</strong></span>
</pre></div><p>We <a id="id394" class="indexterm"/>can now generate Excel spreadsheets<a id="id395" class="indexterm"/> just as easily as we have generated <code class="literal">CSV</code> files while employing a reusable function. We now have the ability to perform repeatable spatial analysis fast and can produce results in industry standard formats.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec51"/>Summary</h1></div></div></div><p>In this chapter, we have explored how to create modules and reusable functions that will save scripting time in the future by allowing us to avoid rewriting these useful functions. We further explored the methods available through ArcPy Geometry objects, including the <code class="literal">Intersect</code>, <code class="literal">Overlaps</code>, and <code class="literal">Union</code> methods. We created a spatial analysis that writes no feature classes to disk, making it so that the analysis time is reduced and unnecessary files are avoided. Finally, we explored how to generate Excel spreadsheets using the <code class="literal">XLWT</code> module so that analysis results can be shared in industry standard formats.</p><p>In the next chapter, we will explore how to use ArcPy to interact with the ArcGIS for desktop extensions such as Network Analyst and Spatial Analyst. By incorporating their functionality within a script, we further increase our ability to create fast and repeatable spatial analysis workflows.</p></div></body></html>