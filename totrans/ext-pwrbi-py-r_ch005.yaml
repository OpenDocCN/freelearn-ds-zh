- en: 4 Importing Unhandled Data Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you''ll look at using R and Python in what is typically the
    first phase of report creation: **data ingestion**. Power BI is a very powerful
    tool from this point of view, because it has many connectors to various data sources
    out of the box. In addition to being able to import data directly by connecting
    to data sources, you can easily solve more complex data loading scenarios with
    Power BI. For example, you can merge multiple CSV files or multiple Excel Workbook’s
    sheets dynamically directly from Power BI, even using the **M language** to apply
    special logic to the merge step. You can also scrape any web page by just clicking
    on web page contents without using any code. All this is possible thanks to Power
    BI''s standard features, without having to use R or Python.'
  prefs: []
  type: TYPE_NORMAL
- en: There are, however, cases in which the data to be imported and used in Power
    BI comes from **processing done on external systems**, which persist data in formats
    that are not directly managed by Power BI. Imagine being a Power BI report developer
    and having to interface with a team of data scientists. Some complex processing
    done by them on fairly large datasets might require non-trivial run times. That's
    why data scientists often **serialize the result** of such processing in files
    of an acceptable size, so they can deserialize them very quickly if needed. Now
    suppose the data scientist team provides you with one of these files serialized
    in R or Python and asks you to use it for some calculations needed to create a
    visual in your report. How would you do it?
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will see how to work with serialized files from R (`.rds`)
    and Python (`.pkl`) in Power BI. The following topics will be discussed in this
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Importing RDS files in R
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing PKL files in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter requires you to have a working internet connection and **Power
    BI Desktop** already installed on your machine. You must have properly configured
    the R and Python engines and IDEs as outlined in *Chapter 2, Configuring R with
    Power BI*, and *Chapter 3, Configuring Python with Power BI*.
  prefs: []
  type: TYPE_NORMAL
- en: Importing RDS files in R
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, you will develop mainly R code, and in the various examples,
    we will give you an overview of what we are going to do. If you have little experience
    with R, you should familiarize yourself with the data structures that R provides
    by starting with this quickstart: [http://bit.ly/r-data-struct-quickstart](http://bit.ly/r-data-struct-quickstart).
    Take a look at the *References* section for more in-depth information.'
  prefs: []
  type: TYPE_NORMAL
- en: A brief introduction to Tidyverse
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A data scientist using R as an analytical language for data analysis and data
    science must know the set of packages that goes by the name of **Tidyverse** ([https://www.tidyverse.org](https://www.tidyverse.org)).
    It provides everything needed for data wrangling and data visualization, giving
    the analyst a consistent approach to the entire ecosystem of packages it provides.
    In this way, it tries to heal the initial situation of "chaos" of R functionalities
    provided by packages developed by developers who had not agreed on a common framework.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you are new to R, you might want to start with this quickstart by Software
    Carpentry to get familiar with the main concepts: [http://bit.ly/tidy-quickstart](http://bit.ly/tidy-quickstart).
    The *References* section also contains links to in-depth information about Tidyverse.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The fundamental data type to know about in Tidyverse to be able to work with
    tabular data is the **tibble**. Tibbles (the New Zealand way of pronouncing "tables")
    are a modern version of R **dataframes**. Starting from a tibble, you can perform
    all the data transformations you want with simple functions provided by the Tidyverse
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: Today, you will often find the use of the **%>% pipe** (the R language allows
    symbols wrapped in `%` to be defined as functions and the `>` implies a chaining)
    in data analyses performed in the Tidyverse world. Borrowed from the **magrittr**
    package included in Tidyverse, the pipe has the function of forwarding the object
    on its left inside the function on its right as the first parameter. In short,
    if you need to select the `my_col` column from a `my_tbl` tibble, instead of using
    `select( my_tbl, my_col )`, you can use the piped form `my_tbl %>% select( my_col
    )`, making the code much more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Currently, R Core is planning to introduce a new graphical form of the pipe,
    which is `|>`. So, be ready to use it when they make it available.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For the purpose of summarily understanding the code used in this section, we
    will describe it piece by piece, explaining the functionality of each R object
    used.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a serialized R object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now imagine for a moment that you are part of the data scientist team that has
    to do the complex processing of a dataset and then serialize the result obtained
    in a file to be reused as needed. The first thing to do is to configure the environment
    to install the latest version of Tidyverse.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the environment and installing Tidyverse
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Open RStudio and proceed as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the most recent R engine (4.0.2 in our case) is selected (**Tools**
    and **Global Options…**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new project by clicking on the **Project** icon in the upper-right
    corner and then **New Project...**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Create a new RStudio project](img/file72.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.1 – Create a new RStudio project
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: An RStudio project makes it straightforward to divide your work into multiple
    contexts, each with its own working directory, workspace, history, and source
    documents.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on **New Directory** and then on **New Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now enter a name for the project folder, choose in which folder do you want
    to place it, and click **Create Project**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Create a new project folder](img/file73.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.2 – Create a new project folder
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can also find this project ready for you in the GitHub repository here:
    `Chapter04\importing-rds-files\importing-rds-files.Rproj`.RStudio will restart
    the R session and the project folder you have just created will become the working
    directory of your project.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you recall, back in *Chapter 3, Configuring Python with Power BI*, you already
    disabled the MRO restriction on using a snapshot made at an earlier date from
    which to download packages. This was meant to install the latest versions of the
    packages. The problem is that the effect of that operation was temporary. In order
    to see that, run the `getOption("repos")` command in the console right now. You'll
    see that the default repository is still the snapshot set by MRO.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order to permanently override the repository at the project level, you must
    write the same code you used previously inside an `.Rprofile` file located in
    the project folder. To do this, go to the console and type `file.edit(".Rprofile")`.
    This will create the `.Rprofile` file in the project folder if it does not exist,
    and will open it in an editor window in RStudio. At that point, enter the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now save the `.Rprofile` file by pressing *Ctrl + S* (or **File** | **Save**)
    and then close the project by clicking on the **Project** icon (a cube containing
    “R”) in the upper-right corner, and then click **Close Project**:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Close the current RStudio project](img/file74.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.3 – Close the current RStudio project
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Reopen the project you just closed (you can find it in the list in the usual
    project menu at the top right, or you can find the `.Rproj` file in the project
    folder). You will notice that the message *"Default repo replaced with 'https://cloud.r-project.org/'"*
    will appear in the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type the `getOption("repos")` command again in the console and press *Enter*.
    Now you’ll see the new CRAN repository as the default one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.4 – The new CRAN repository set as default](img/file75.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.4 – The new CRAN repository set as default
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now let''s install all Tidyverse packages by simply running the following command
    on the console: `install.packages("tidyverse")` (it’s equivalent to installing
    it through the GUI by clicking on the **Packages** tab at the bottom right and
    then on **Install**).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Awesome! Now you are sure that you have installed the latest version of Tidyverse.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the RDS files
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We will now walk you through creating the serialization of an R object in an
    RDS file. Assume that the computational time required to create this object is
    very large. We will also have you create an object that is not a simple tibble,
    which could have been easily exported first to CSV and then imported into Power
    BI. Let’s start:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a new R script in your project by pressing *Ctrl + Shift + N* (or by clicking
    the **+** **New File** icon and then **R Script**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now you will load in memory both the Tidyverse packages (using the `library`
    command) and the *growth population* tibble contained in the **tidyr** package
    (using the `data` command), consisting of a subset of data taken from the *World
    Health Organization Global Tuberculosis Report*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The latest command (which matches the name of the tibble) allows you to observe
    the contents of the first few lines of the tibble and its columns’ data types.
    Highlight all the commands and press *Ctrl + Enter* (or click on the **Run** icon
    on the top right of the panel) to run them. You will see the following result:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Load the “population” tibble](img/file76.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.5 – Load the “population” tibble
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Everything that follows **#** is a comment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now let’s check how many distinct countries there are in the tibble. You’ll
    use the `distinct` function and then the `pull` one in order to extract the single
    column of distinct countries from the tibble in vector format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You’ll see a list of all the distinct countries, like this one:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.6 – List of distinct countries](img/file77.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.6 – List of distinct countries
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Try highlighting the code only up to and including `distinct(country)` and running
    the highlighted code. You will always see distinct countries, but still as part
    of a tibble.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now we want to group the year and population information into separate tibbles
    for each country. In short, we want to have a tibble that contains the countries
    and for each of them another tibble with the demographic information by year.
    You can do that using the `nest` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You have just assigned the `nested_population_tbl` variable the new tibble
    containing the nested demographic data. Observe that we made the `nest` function
    call explicit by calling it from its `tidyr` source package using `::`. Also,
    observe how easy it is to "nest" everything except the country column into a list
    of tibbles contained in the new `demografic_data` column. Highlighting and running
    the previous chunk of code, you’ll see the following result:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Tibble of nested demographic data](img/file78.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.7 – Tibble of nested demographic data
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that the new `demographic_data` column is a list of tibbles.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now you can finally serialize the `nested_population_tbl` object into an RDS
    file using the `saveRDS` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can find the R code shown here in the GitHub repository associated with
    the book in the `Chapter04\importing-rds-files\01-create-object-to-serialize.R`
    file. To properly execute the code contained in the file, you should first open
    the RStudio project, double-clicking on the `Chapter04\importing-rds-files\importing-rds-files.Rproj`
    file. Then you can open the previously mentioned R script using the **Files**
    tab in the bottom-right panel of RStudio.
  prefs: []
  type: TYPE_NORMAL
- en: 'Awesome! You can verify that a file has been serialized correctly by taking
    a look at the same panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – The RDS file correctly created](img/file79.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – The RDS file correctly created
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same way, you’ll create an RDS object that contains time series views
    for four selected countries. The time series data is the same as the population
    growth data you saw earlier. Let''s see how you can generate this file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the fantastic **timetk** package by Matt Dancho by entering the `install.packages("timetk")`
    command into the RStudio console. It makes it easy to visualize, wrangle, and
    feature engineer time series data for forecasting and machine learning predictions.
    For more details, take a look here: [https://business-science.github.io/timetk/](https://business-science.github.io/timetk/).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `Chapter04\importing-rds-files\04-create-plots-object-to-serialize.R`
    file in RStudio. The first part of the file contains code already seen in the
    previous section and is used to generate the nested tibble of the population.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Immediately after creating the nested tibble, you’ll see how to plot the time
    series data related to country Sweden. Every single R function used is explained
    in the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is the result:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.9 – Population growth time series plot for Sweden](img/file80.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.9 – Population growth time series plot for Sweden
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You will now create a time series graph for each country in the nested tibble
    following the previous example. The great thing is that thanks to the power of
    **functional programming** provided by the **map functions** of the `purrr` package,
    you can do this in one go using only one function. As always, you’ll find detailed
    explanations in the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, only the plots list extracted by the `nested_population_plots_tbl`
    tibble is serialized in an RDS file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Well done! You've serialized your R objects into RDS files. If you want to try
    deserializing them, you can follow the code in the `02-deserialize-object-from-rds.R`
    and `05-deserialize-plots-object-from-rds.R` files you can found in the GitHub
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: You are now ready to use the nested tibble serialized in a file directly in
    Power BI.
  prefs: []
  type: TYPE_NORMAL
- en: Using an RDS file in Power BI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is clear that an RDS file must necessarily be used via R scripts in Power
    BI. As you may have learned by now, there are two Power BI objects through which
    you can use R scripts: **Power Query Editor** and **R visuals**. Let''s start
    with the simplest case, which is to import the RDS file into Power Query Editor.'
  prefs: []
  type: TYPE_NORMAL
- en: Importing an RDS file into Power Query Editor
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You''ll import a serialized R object into Power Query Editor when you know
    *you can extract tabular information from the object* and want to persist it in
    the Power BI data model. Let''s see how it''s done:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to RStudio and create a new R script into the project by pressing *Ctrl +
    Shift + N*. You could copy and paste the content of the `02-deserialize-object-from-rds.R`
    file (or open it directly if you used the GitHub `.Rproj` file to open the project).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Load the RDS file via the `readRDS` function and assign it to the new `deserialized_tbl`
    variable like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we are using an absolute path to read the RDS file, even though we
    are in an RStudio project and could have referenced the file without a path. This
    is because *Power BI does not have the concept of "projects" that RStudio does
    and therefore needs an absolute path* to locate the file correctly. Also, note
    that in R you can use either the double-backslash (`\\`) or the simple slash (`/`)
    as a separator in path strings.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now try extracting the demographics of Sweden from the nested tibble as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this piece of code, we are assigning to the `sweden_population_tbl` variable
    the content of the `deserialized_tbl` variable, to which we apply the following
    transformations:a) We filter it for the country Sweden through the filter function
    (thus obtaining the row associated with the country Sweden).b) From this row,
    we detach the content of the `demographic_data` field from the original tibble
    using the `pull` function (you’ll get a list).c) Since the content of the `demographic_data`
    column is a list containing only one tibble, the content must be unlisted using
    the `pluck` function. The result is the Sweden demographic data organized in one
    tibble, as shown in *Figure 4.11*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.10 – The content of the Sweden demographic data organized in a tibble](img/file81.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.10 – The content of the Sweden demographic data organized in a tibble
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now open Power BI Desktop and make sure it is referencing the earliest MRO.
    Click then on **Get data** and then **More…**. Start typing `script` into the
    search textbox and double-click on R script. The R script editor will pop up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy and paste the content of the `03-deserialize-object-from-rds-in-power-bi.R`
    file into the R script editor, changing the absolute path to the RDS file accordingly,
    and then click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The **Navigator** window will open, giving you the option to select which dataframe
    to import:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.11 – Import the deserialized dataframe into Power BI](img/file82.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.11 – Import the deserialized dataframe into Power BI
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You will see as many dataframes (remember that tibbles are specializations of
    dataframes) as you have defined within your script. Select the **sweden_population_tbl**
    dataframe and click **Load**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When loading is finished, click on the table icon on the left menu of Power
    BI Desktop to verify that the data has been imported correctly in tabular form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.12 – The dataframe is correctly imported](img/file83.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.12 – The dataframe is correctly imported
  prefs: []
  type: TYPE_NORMAL
- en: Great! You have correctly imported your RDS file into Power BI to use its contents
    with Power Query in the most appropriate way.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As you may have noticed, *the only R data structure that Power BI can work with
    are dataframes (or datatable) with columns that have standard data types*. It
    is not possible to import any other type of R objects. If you had imported the
    *deserialized_tbl* dataframe directly, the values in the *demographic_data* column
    would have generated an error and would have been unavailable.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Sometimes it may happen that you don't have the ability to deserialize an RDS
    file in Power Query Editor and extract its information in a tabular format in
    order to persist it in the Power BI data model. You may need to deserialize the
    content of an RDS file on the fly in an R visual in order to use its information
    in a visualization. You'll see how to solve this scenario in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Importing an RDS file in an R visual
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now suppose you have received the RDS file containing the time series charts
    for each country from the data scientists team. Your goal is to allow the report
    user to view the charts by selecting a country.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem you are facing is as follows: you know that in order to import
    any information from Power Query Editor via the R script, it must be in tabular
    format and must use standard data types. The charts made available by the data
    scientists are grouped in a list in the *ggplot* format (**ggplot** offers a powerful
    graphics language for creating elegant and complex plots in R), which in itself
    is not a standard data type. How do you import them into Power BI? You’ll need
    a little bit of *lateral thinking*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Important Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As you probably already know, it is possible to serialize any programming object
    in its **byte representation** (raw vector in R). The byte representation can
    in turn be transformed into its **string representation**. Once you have strings
    (a standard data type), you can organize them into a dataframe. After that's done,
    you can import that dataframe into Power BI.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The moment you need to "feed" an R visual with data, keep the following considerations
    in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Important Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When you select more than one column from more than one table in the Power BI
    data model (there must be a relationship between them) as values of an R visual,
    these values *will form a single dataframe (deduplicated)* to be referenced in
    the R script of the visual.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Also, keep the following in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In some cases, you may want to *not delete duplicate rows*. In that case, you
    can add an index field to your dataset (row number) that causes all rows to be
    considered unique and prevents grouping.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It wouldn't make sense to import a dataframe containing a string representation
    of something in Power Query Editor if you couldn't transform it back to the original
    object. Fortunately, the previously mentioned direct transformation operations
    are all invertible, so you can use the inverse transformations within an R visual
    to extract and display plots appropriately. Also added to this process is a limitation
    of the data handled in R visuals that appears to be undocumented.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If a string is longer than 32,766 characters, once passed into the default dataframe
    to be referenced within an R visual, *it is truncated*. To avoid truncation, it
    is necessary to split the string into smaller chunks (we chose an arbitrary length
    of 10,000) and persist those chunks in a dataframe column before using the data
    into the R visual.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'That said, in summary, what you will be doing in this section is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the RDS file containing the named list of plots in **Power Query Editor**.
    From it, extract a dataframe of country names and a dataframe containing plots
    information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the countries dataframe in a slicer with a single choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each time a country is selected from the slicer, the **R visual** will display
    the plot of the time series of the population growth of that country.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s summarize all the processes of wrangling the plots data in a figure that
    contains the functions you will find in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.13 – Deserialize the RDS file content into an R visual](img/file84.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.13 – Deserialize the RDS file content into an R visual
  prefs: []
  type: TYPE_NORMAL
- en: '**Important Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It hasn’t been possible to directly import the single dataframe containing both
    the country names and the corresponding plots, because the R engine returns a
    mysterious **ENVSXP Error**. A named list works like a charm.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In the following steps, we will not explain in detail all the functions used,
    simply because we will refer to the code shared in the GitHub associated with
    this book, in which every single detail is commented. So, let’s start:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Power BI Desktop and go to **Get data**, then **More…**, then **R Script**
    to import the RDL files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `06-deserialize-plots-object-from-rds-in-power-bi.R` file from the
    GitHub repository, copy the content, changing the absolute path to the RDL file
    accordingly, paste it into the R Script editor, and click **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Power Query will detect three dataframes created into your script. Select only
    the **plots_df** dataframe (the one containing the string representation of bytes
    of plots), and the **selected_countries_df** one. Then click **Load**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.14 – Select the two dataframes containing useful data](img/file85.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.14 – Select the two dataframes containing useful data
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Click on the **Data** icon on the left ribbon and then click on the **Manage
    relationships** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.15 – The Manage relationships button](img/file86.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.15 – The Manage relationships button
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The engine has automatically created the relationship between the two imported
    tables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.16 – Relation between tables automatically detected](img/file87.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.16 – Relation between tables automatically detected
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click **Close**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Go back to the report canvas clicking on the **Report** icon on the left ribbon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.17 – The Report icon](img/file88.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.17 – The Report icon
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now click on the **Slicer** icon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.18 – The Slicer icon](img/file89.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.18 – The Slicer icon
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Keeping the **Slicer** visual region selected into the canvas, click on the
    **selected_countries_df** table on the **Fields** panel, and select the **country**
    field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.19 – Select the country_name column for the Slicer visual](img/file90.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.19 – Select the country_name column for the Slicer visual
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then click the **Format** icon of the **Slicer** and enable the **Single select**
    option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.20 – Allow only a single selection](img/file91.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.20 – Allow only a single selection
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It is very important to set **Single select**, because *the logic inside the
    R visual will manage the deserialization of a single plot*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now the Slicer visual will show all the countries contained in the **selected_countries_tbl**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.21 – This is what the Slicer visual looks like](img/file92.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.21 – This is what the Slicer visual looks like
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Click on the report canvas in order to deselect the **Slicer** visual and click
    then on the **R script visual** icon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.22 – The R script visual icon](img/file93.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.22 – The R script visual icon
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The usual **Enable script visuals** window pops up. Click on **Enable**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Move and stretch the R visual borders in order to cover almost all the report
    canvas. Keeping it selected, click on the **plots_df** table into the **Fields**
    panel and select the **chunk_id**, **country_id**, and **plot_str** fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.23 – Select the fields to use in the R visual](img/file94.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.23 – Select the fields to use in the R visual
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to turn the R visual title off in the **Format** tab.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `07-deserialize-plots-df-into-r-visual.R` file from the GitHub repository,
    copy the content, and paste it into the R visual’s script editor. Then click on
    the **Run** icon on the top right of the R script editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now you can click on each country into the Slicer in order to see its population
    time series:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.24 – Showing the population growth for Italy](img/file95.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.24 – Showing the population growth for Italy
  prefs: []
  type: TYPE_NORMAL
- en: Outstanding! You have just created a report that very few could have made.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This technique can be very useful when you need to build complex visualizations
    in R that require the use of packages not provided by the R visual in Power BI
    Service. These visualizations can be made "offline," serialized to file, and then
    used on a shared report on the service.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You've just seen how to import an RDS file despite not being able to do so out
    of the box in Power BI, and how you can then use it directly within an R visual.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you'll see how you can do the same thing for files serialized
    with Python.
  prefs: []
  type: TYPE_NORMAL
- en: Importing PKL files in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s give you an overview of what you''re going to implement using the Python
    code on GitHub. If you are not familiar with Python, you should familiarize yourself
    with the basic structures through this tutorial: [http://bit.ly/py-data-struct-quickstart](http://bit.ly/py-data-struct-quickstart).
    For a more detailed study of how to implement algorithms and data structures in
    Python, we suggest this free e-book: [http://bit.ly/algo-py-ebook](http://bit.ly/algo-py-ebook).'
  prefs: []
  type: TYPE_NORMAL
- en: A very short introduction to the PyData world
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **PyData** world is made up of users and developers who are passionate
    about data analytics and love to use open source data tools. The PyData community
    also loves to share best practices, new approaches, and emerging technologies
    for managing, processing, analyzing, and visualizing data. The most important
    and popular packages used by the Python data management community are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**NumPy**: This is the main library for scientific computing in Python. It
    provides a high-performance multidimensional array object and tools for working
    with data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pandas**: The *Python Data Analysis Library* (pandas comes from *panel data*)
    is built upon NumPy and takes data in a tabular format (such as a CSV file, TSV
    file, or SQL database table) in order to create a Python object with rows and
    columns called a **DataFrame**. This object is very similar to a table in statistical
    software and people familiar with R conceptually equate the pandas DataFrame with
    R''s dataframe data type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Matplotlib**: This is a Python package used to produce plots. It began as
    a project in the early 2000s to use Python to visualize electronic signals in
    the brains of patients with epilepsy. The creator of Matplotlib was a neurobiologist
    and was looking for a way to replicate MATLAB''s graphing capabilities with Python.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scikit-learn**: Also known as **sklearn**, this derives its name from the
    fusion of the two words *"SciPy"* and *"Toolkit."* It is a free and robust machine
    learning library for Python designed to interact with the NumPy, SciPy, pandas,
    and Matplotlib, among others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Going into detail about what is possible using these libraries is not the purpose
    of this book.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you want to start learning how to work with data in Python by taking advantage
    of these libraries, we recommend starting with this free book: [http://bit.ly/data-science-py-ebook](http://bit.ly/data-science-py-ebook).
    After that, for further study, you can''t miss the opportunity to study this fantastic
    book: *Python Machine Learning: Machine Learning and Deep Learning with Python,
    Scikit-Learn, and TensorFlow 2, Third Edition*, by Sebastian Raschka, Packt.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to summarily understand the code used in this section, we will try
    to describe its functionality piece by piece, referring you to the comments in
    the code on GitHub for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a serialized Python object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As done in the previous section, now imagine that you are part of another team
    of data scientists that needs to do some complex, time-consuming data analysis
    with Python. Needing to reuse the results obtained in other processes, the team
    decides to use a **Pickle file** (PKL). It is obtained by serializing and then
    writing to a file any Python object, using the **pickle** library. As you have
    already seen in the previous section, serializing means converting an object in
    memory into a stream of bytes that can be either saved to disk or sent over a
    network. Obviously, this is an easily reversible operation. In fact, there is
    the possibility to deserialize a serialized object.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Before you start, make sure that the path where you unzipped the GitHub repository
    ZIP file **doesn't contain any spaces in the names of the folders that make it
    up**, otherwise the Python script execution will give an error.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So, let’s start to install what we need in our environment and initialize the
    IDE appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the environment and installing the PyData packages
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Open your **Anaconda Prompt** (from the **Start** menu) and proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure to use the `pbi_powerquery_env` environment, entering this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now you will install some missing packages that are necessary to be able to
    use the code in this section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Enter the following command to install **matplotlib**: `pip install matplotlib`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Great! Your Python environment is now ready to run your scripts. Now open Visual
    Studio Code and proceed as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to **File** and then **Open Folder…**. Make sure to choose the **importing-pkl-files**
    folder contained in the GitHub repository you previously unzipped, under the **Chapter04**
    folder. Click **Select Folder**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `01-create-object-to-serialize-in-pkl.py` file, clicking on it into
    the Explorer on the right, under the selected folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remember you have to choose the environment in which to run your script. So,
    press *Ctrl + Shift + P* to open the Visual Studio Code palette and start entering
    the text “interpreter.” Then, select **Python: Select Interpreter**, and then
    choose the `pbi_powerquery_env` environment.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Excellent! Now you are ready to serialize your first Python object.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the PKL files
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Two of the most commonly used data structures in Python are **lists** and **dictionaries**.
    While by now you're familiar with lists, which you've seen before in R, if you've
    never developed in a programming language, perhaps dictionaries might sound new
    to you. Dictionaries are data structures that consist of a collection of **key-value
    pairs**. You can define them using curly braces (`{…}`). Specifically, in this
    section, you will create a dictionary with key-value pairs that consists of the
    country name and a dataframe containing data about the growth of the country’s
    population.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data you will use is the same data you used in the previous section. This
    time, instead of loading it from a package in memory, you''ll do it directly from
    a CSV file. Let’s go:'
  prefs: []
  type: TYPE_NORMAL
- en: Since the `01-create-object-to-serialize-in-pkl.py` file is already open in
    Visual Studio Code, just run the code via the green arrow icon in the upper-right
    corner (**Run Python File in Terminal**). This way, the whole script will be executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You won''t see anything particular in the console, just the command that runs
    `python.exe` with the current script path as a parameter. But if you look in the
    explorer on the left, you will see that the `nested_population_dict.pkl` file
    has been created correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.25 – Your first PKL file has been created](img/file96.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.25 – Your first PKL file has been created
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Just like in Rstudio, you can only run pieces of code by highlighting them
    and pressing *Ctrl + Enter*. You need to change a settings option in order to
    allow the use of the **interactive window** with Python. Go to **Settings**, pressing
    *Ctrl + ,* (comma), then start entering `Send Selection To Interactive Window`
    in the search bar and check the selected option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.26 – Enable the execution of Python code chunks in the Jupyter interactive
    window](img/file97.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.26 – Enable the execution of Python code chunks in the Jupyter interactive
    window
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now you have to install the *IPython kernel* (`ipykernel`) into your `pbi_powerquery_env`
    environment. Usually, this operation is done automatically by Visual Studio Code,
    but sometimes you can run into errors. So, it’s better to do it manually. Open
    your Anaconda Prompt and enter the following command: `conda install --name pbi_powerquery_env
    ipykernel -y`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now select the code from the beginning (`import pandas as pd`) to the line
    where `countries` are defined (`countries = population_df.country.unique()`),
    then press *Shift + Enter*. Your chunk of code will be sent to the interactive
    window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.27 – Run selected chunks of script in Visual Studio Code](img/file98.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.27 – Run selected chunks of script in Visual Studio Code
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Clicking on the **Variables** icon into the interactive windows as shown in
    *Figure 4.28*, you can also inspect the content of each variable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Hey, maybe you didn't notice, but with minimal effort, you have just created
    your first PLK file! You can train yourself to deserialize the newly created PKL
    file by running the code in the `02-deserialize-object-from-pkl.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will now guide you in creating a second PKL file that contains a serialized
    dictionary with pairs composed of the country and the respective time series on
    population growth. This time, though, you will keep only four countries in the
    dictionary for simplicity. Let''s proceed:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `04-create-plots-object-to-serialize-in-pkl.py` file from the explorer
    on the left.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can run the code a piece at a time to better understand how it works. About
    halfway through the script, you will find the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After running that piece of code, an interactive window will open in which
    the time series graph of Sweden is shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.28 – Interactive window showing the time series plot of Sweden](img/file99.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.28 – Interactive window showing the time series plot of Sweden
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Keep it open if you want to create new figures, otherwise you might get a weird
    error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The last piece of code creates a new dictionary containing graphs for each
    country and serializes it to file. Once executed, you can see the `nested_population_plots_dict.pkl`
    file in the explorer on the left:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.29 – The new dictionary is correctly serialized in a PKL file](img/file100.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.29 – The new dictionary is correctly serialized in a PKL file
  prefs: []
  type: TYPE_NORMAL
- en: Amazing! You serialized your second dictionary as well. You can practice deserializing
    it using the code in the `05-deserialize-plots-object-from-pkl.py` script.
  prefs: []
  type: TYPE_NORMAL
- en: Now you're ready to test your PKL files in Power BI, either in Power Query Editor
    or in Python visuals.
  prefs: []
  type: TYPE_NORMAL
- en: Using a PKL file in Power BI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is clear that a PKL file must necessarily be used through Python scripts
    in Power BI. So, there are two Power BI objects through which you can use Python
    scripts: **Power Query Editor** and **Python visuals**. Let''s start with the
    simplest case, which is to import the PKL file into Power Query Editor.'
  prefs: []
  type: TYPE_NORMAL
- en: Importing a PKL file in Power Query Editor
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You will import a serialized Python object into Power Query Editor once you
    know how to extract tabular information from the object and then persist it in
    the Power BI data model. Let''s take a look at how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Power BI Desktop and make sure it is referencing the `pbi_powerquery_env`
    environment. Then click on **Get** **data** and then **More…**. Start typing `script`
    into the search textbox and double-click on Python script. The Python script editor
    will pop up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `03-deserialize-object-from-pkl-in-power-bi.py` file in Visual Studio
    Code and copy its content. Then paste it into the Python script editor in Power
    BI Desktop, changing the absolute path to the PKL file accordingly, and click
    **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The **Navigator** window will open, giving you the option to select which dataframe
    to import:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.30 – Import the deserialized dataframe into Power BI](img/file101.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.30 – Import the deserialized dataframe into Power BI
  prefs: []
  type: TYPE_NORMAL
- en: Select the **sweden_population_tbl** dataframe and click **Load**.
  prefs: []
  type: TYPE_NORMAL
- en: 'When loading is finished, click on the table icon on the left menu of Power
    BI Desktop to verify that the data has been imported correctly in tabular form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.31 – The dataframe is correctly imported](img/file102.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.31 – The dataframe is correctly imported
  prefs: []
  type: TYPE_NORMAL
- en: Nice job! You have correctly imported your PKL file into Power BI to use its
    contents with Power Query in the most appropriate way.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As with R scripts, **the only Python data structure that Power BI can work with
    are pandas DataFrames with columns that have standard data types**. It is not
    possible to import any other type of Python object. That’s exactly why you couldn't
    import the dictionary directly.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As should be clear to you by now from the previous section, it can happen that
    a PKL file doesn’t contain information in tabular format that can be extracted
    in Power Query Editor. You may need to deserialize the contents of a PKL file
    directly within a Python visual in order to use that information to create a chart.
    You will see how to solve this scenario in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Importing a PKL file in a Python visual
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now let's assume that you received a PKL file containing the time series graphs
    for each country from the data scientists team. Your goal is to allow the report
    user to view the graphs by selecting a country.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem you face is the following: you know that in order to import any
    information into Power Query Editor via Python scripts, it must be in tabular
    format and must use standard data types. The charts provided by the data scientists
    are grouped in a dictionary in the **figure format** of **Matplotlib**, which
    itself is not a standard data type. So, how do you import the dictionary into
    Power BI? The same "trick" used with R in the previous section applies.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, what you will do in this section is this:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the PKL file containing the dictionary of plots in Power Query Editor.
    Extract its keys (countries) and expose them in a dataframe. Use its byte stream
    representation to fill another dataframe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the countries dataframe as a slicer with a single choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each time a country is selected from the slicer, the Python visual will deserialize
    the byte stream into the input dataframe and it will display the plot of the time
    series of the population growth of that country.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Important Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Also, in this case, when you select more than one column from more than one
    table in the Power BI data model (there must be a relationship between them) as
    values of a Python visual, these values *will form a single dataframe (deduplicated)*
    to be referenced in the Python script of the Visual.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In addition, the same suggestion as was made for the R dataframe input applies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In some cases, you may want to *not delete duplicate rows*. In that case, you
    can add an index field to your Pandas dataset (row number) that causes all rows
    to be considered unique and prevents grouping.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Again, even the Python visuals add a size limitation to the data it imports
    that appears to be undocumented:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Important Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If a string is longer than 32,766 characters, *it is truncated* once passed
    into the input dataframe of a Python visual. To avoid truncation, we need to split
    the string into chunks of 32,000 characters each (this is an arbitrary value chosen
    by us) and persist these chunks in a column of the dataframe before using the
    data in the Python visual.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here is the process summarised in a figure that contains the functions you
    will find in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.32 – Deserialize the PKL file content into a Python visual](img/file103.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.32 – Deserialize the PKL file content into a Python visual
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following steps, we will not explain in detail all the Python functions
    used, simply because we will refer to the code shared in the GitHub repository
    associated with this book, where every single detail is commented. So, let''s
    get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Power BI Desktop and go to **Get data**, then **More…**, and then **Python
    Script** to import the PKL files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `06-deserialize-plots-object-from-pkl-in-power-bi.py` file from the
    GitHub repository, copy the content, paste it into the Python script editor, changing
    the absolute path to the PKL file accordingly, and click **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Power Query will detect three dataframes created in your script. Select only
    the `plots_df` (the one containing the chunks of byte strings of each plot) and
    selected `_countries_df` (the one containing the country names) dataframes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.33 – Selecting the two dataframes containing useful data](img/file104.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.33 – Selecting the two dataframes containing useful data
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then click **Load**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Click on the **Data** icon in the left ribbon and then click on the **Manage
    relationships** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.34 – The Manage relationships button](img/file105.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.34 – The Manage relationships button
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The engine has automatically created the relationship between the two imported
    tables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.35 – Relationship between tables automatically detected](img/file106.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.35 – Relationship between tables automatically detected
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click **Close** and go back to the report canvas using the **Report** icon in
    the left ribbon.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now click on the **Slicer** visual icon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.36 – The Slicer visual icon](img/file107.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.36 – The Slicer visual icon
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Keeping the Slicer visual region selected into the canvas, click on the **selected_countries_df**
    table on the **Fields** panel and select the **country_name** field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.37 – Select the country_name column for the Slicer visual](img/file108.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.37 – Select the country_name column for the Slicer visual
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then click the **Format** icon of the Slicer as you did in the previous section
    and enable the **Single select** option. The Slicer visual will show all the country
    names contained in the **selected_countries_df** table. It is very important to
    set **Single select**, because *the logic inside the Python visual will manage
    the deserialization of a single plot*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the report canvas in order to deselect the Slicer visual region and
    click on the **Python visual** icon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.39 – The Python visual icon](img/file109.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.39 – The Python visual icon
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The usual **Enable script visuals** window pops up. Click on **Enable**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Move and stretch the Python visual borders in order to cover almost all the
    report canvas. Keeping it selected, click on the **plots_df** table in the **Fields**
    panel and select all three `chunk_id`, `country_id`, and `plot_str` fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.40 – Select the fields to use in the Python visual](img/file110.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.40 – Select the fields to use in the Python visual
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Feel free to turn the Python visual title off in the **Format** tab.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open the `07-deserialize-plots-df-into-python-visual.py` file from the GitHub
    repository, copy the content, and paste it into the Python visual’s script editor.
    Then, click on the **Run** icon on the top right of the Python script editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now you can click on each country in the Slider in order to see the population
    time series:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.41 – Showing the population growth for Germany](img/file111.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.41 – Showing the population growth for Germany
  prefs: []
  type: TYPE_NORMAL
- en: Brilliant! You've just created a report using a methodology that few people
    in the world know about.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This technique can be very useful when you need to build complex visualizations
    in Python that require the use of packages not provided by Python visuals in Power
    BI Service. These visualizations can be made offline, serialized to a file, and
    then used on a shared report on the service.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you got to learn about the Tidyverse approach to R development
    and how to serialize R objects to files. After that, you learned how to use these
    serialized files, both in Power Query Editor and in R visuals.
  prefs: []
  type: TYPE_NORMAL
- en: You then approached the same issues using Python. Specifically, you learned
    which packages are most used by the PyData community, learned how to serialize
    Python objects to files, and how to use them in Power BI, both in Power Query
    Editor and in Python visuals.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll have a chance to learn how powerful regular expressions
    and fuzzy string matching are and what benefits they can bring to your Power BI
    reports.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For additional reading, check out the following books and articles:'
  prefs: []
  type: TYPE_NORMAL
- en: '*“An Introduction to R” by R Core* ([https://cran.r-project.org/doc/manuals/r-release/R-intro.html](https://cran.r-project.org/doc/manuals/r-release/R-intro.html)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*“R for Data Science”* by Hadley Wickham ([https://r4ds.had.co.nz/index.html](https://r4ds.had.co.nz/index.html)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*“Machine Learning with R: Expert techniques for predictive modeling, 3rd Edition”*
    by Brett Lantz, Packt Publishing ([https://www.packtpub.com/product/mastering-machine-learning-with-r-third-edition/9781789618006](https://www.packtpub.com/product/mastering-machine-learning-with-r-third-edition/9781789618006)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
