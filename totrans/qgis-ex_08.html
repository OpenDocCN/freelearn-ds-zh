<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Automating Analysis with Processing Models" id="aid-1R42S1"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Automating Analysis with Processing Models</h1></div></div></div><p>In this chapter, you will learn how to use the graphical modeler from the QGIS Processing framework to create models and automate complex analysis tasks. We will cover all the necessary steps starting from creating the model and ending up with sharing the model with other users.</p><p>In this chapter, we will go through the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The QGIS Processing framework</li><li class="listitem">The Graphical modeler</li><li class="listitem">Adding inputs</li><li class="listitem">Implementing the workflow</li><li class="listitem">Filling in model metadata and saving</li><li class="listitem">Editing models</li><li class="listitem">Sharing models</li></ul></div><div class="section" title="The QGIS Processing framework"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec56"/>The QGIS Processing framework</h1></div></div></div><p>The QGIS Processing<a id="id528" class="indexterm"/> framework (formerly SEXTANTE) is an QGIS core plugin that implements a powerful analysis and geoprocessing environment and provides a user-friendly interface for various native QGIS algorithms and third-party analysis software, such as GRASS, SAGA, Orfeo ToolBox, and many others.</p><div class="note" title="Note"><h3 class="title"><a id="tip25"/>Tip</h3><p>Refer to the QGIS user<a id="id529" class="indexterm"/> guide at <a class="ulink" href="http://docs.qgis.org/testing/en/docs/user_manual/processing/intro.html">http://docs.qgis.org/testing/en/docs/user_manual/processing/intro.html</a> if you want more information about the QGIS Processing framework.</p></div><p>The Processing user interface consists of four main components. Each of them allows you to run algorithms in a different way. Deciding which component to use depends on the task and type of analysis. As the Processing plugin is activated by default, we can access all of its components and<a id="id530" class="indexterm"/> functionality, except the batch processing interface, from the Processing menu:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="inlinemediaobject"><img src="../Images/image00498.jpeg" alt="The QGIS Processing framework"/></span>
 Toolbox: This is the main Processing GUI element. It provides access to all available algorithms (grouped by provider or purpose) and allows us to run them in single-pass and batch modes. The Processing Toolbox has two modes: simplified (default) and advanced. In simplified mode, all algorithms are placed in predefined<a id="id531" class="indexterm"/> groups and have user-friendly names, with the aim of helping novice users find the necessary tools. In advanced mode, algorithms are grouped by <span class="emphasis"><em>providers</em></span>. Each provider represents some analysis package or program, for example, GRASS, Orfeo ToolBox, and so on. Also, in advanced mode, we have access to a larger number of algorithms, as some special providers are available only in this mode.
In the upcoming sections, we will assume that the toolbox is used in advanced mode.<p>To activate advanced mode, just select the <span class="strong"><strong>Advanced</strong></span> interface from the combobox at the bottom of the Processing toolbox.</p></li><li class="listitem"><span class="inlinemediaobject"><img src="../Images/image00499.jpeg" alt="The QGIS Processing framework"/></span><span class="strong"><strong>history manager</strong></span>: This <a id="id532" class="indexterm"/>stores information about all executed algorithms and their parameters so that, if necessary, one can easily reproduce a past action. Also, all errors, warnings, and information messages are displayed here.
</li><li class="listitem"><span class="strong"><strong>batch processing interface</strong></span>: This<a id="id533" class="indexterm"/> is used to run individual algorithms on multiple datasets. This interface is accessible only from the Processing Toolbox and is not available in the Processing menu.</li><li class="listitem"><span class="inlinemediaobject"><img src="../Images/image00500.jpeg" alt="The QGIS Processing framework"/></span><span class="strong"><strong>graphical modeler</strong></span>: This is used<a id="id534" class="indexterm"/> to create new algorithms by combining existing ones into a single workflow. It allows us to easily automate a complex analysis that involves several steps.
</li></ul></div><p>In the next section, we will see how to use the Processing Graphical modeler and create our own models to automate <a id="id535" class="indexterm"/>analysis tasks.</p></div></div>
<div class="section" title="Graphical Modeler" id="aid-1S2JE1"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec57"/>Graphical Modeler</h1></div></div></div><p>As we have already seen in previous chapters, even a simple analysis may require several steps. In real-life applications, much more complex tasks exist, and they involve and combine different<a id="id536" class="indexterm"/> processes of analysis. Running them manually is a time-consuming process, and it may take hours to complete. Things become even worse and complicated when you need to run this analysis several times with different input data or use the same data with different settings.</p><p>This is where the QGIS Processing framework comes to help. It allows us to automate repeated tasks and create new complex algorithms that involve different types of data processing. With the help of the Graphical modeler from the Processing toolbox, we can easily create our own algorithms by combining existing algorithms. The created model can be executed like any other Processing algorithm, and even used as part of another, more complex model.</p><p>There are two common <a id="id537" class="indexterm"/>ways of opening the Graphical Modeler:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">From the menu, go to <span class="strong"><strong>Processing</strong></span> | <span class="strong"><strong>Graphical Modeler...</strong></span>.</li><li class="listitem">Use the Processing Toolbox. Ensure that the Processing Toolbox uses the <span class="strong"><strong>Advanced</strong></span> mode. Go to the <span class="strong"><strong>Models</strong></span> group and expand it. In the <span class="strong"><strong>Tools</strong></span> subgroup, find the <span class="strong"><strong>Create new model</strong></span> item and double-click on it.</li></ul></div><p>Any of these methods will open the <span class="strong"><strong>Processing modeler</strong></span> window, as shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00501.jpeg" alt="Graphical Modeler"/></div><p style="clear:both; height: 1em;"> </p><p>The <span class="strong"><strong>Processing modeler</strong></span> window can be<a id="id538" class="indexterm"/> divided into the following main areas:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Toolbar</strong></span>: This provides some useful actions, such as opening existing models, saving and exporting a model, the help editor, and so on.</li><li class="listitem"><span class="strong"><strong>Inputs and algorithm trees</strong></span>: These are located on the left side of the window and consist of two tabs: one contains the available inputs, and the second contains the available algorithms. It is worth mentioning that the <span class="strong"><strong>Algorithm</strong></span> tab supports the same modes for displays of algorithms as the toolbox: simplified and advanced. However, note that there are no switches in this tab for changing the display mode. If you need to change it, you should do it in the toolbox before opening the modeler.</li><li class="listitem"><span class="strong"><strong>Working area</strong></span>: This is used to display the model structure. Here, we will place our building blocks and connect them to each other.</li></ul></div><p>The creation of the model can be divided into two steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Defining the input: This means that we need to specify which data is necessary for analysis. All items of input that we define here will be represented later as algorithm parameters, and the user will <a id="id539" class="indexterm"/>be able to set them according to their requirements.</li><li class="listitem">Defining the workflow: At this step, we establish links between input items and algorithms. In other <a id="id540" class="indexterm"/>words, we determine how each algorithm in the model will use input and output from other algorithms.</li></ol><div style="height:10px; width: 1px"/></div><p>Let's create a model to generate<a id="id541" class="indexterm"/> density maps from a point vector layer using the binning technique, which was described in the <span class="emphasis"><em>Mapping density with a hexagonal grid</em></span> section of <a class="link" title="Chapter 5. Answering Questions with Density Analysis" href="part0043.xhtml#aid-190861">Chapter 5</a>, <span class="emphasis"><em>Answering Questions with Density Analysis</em></span>. To make this example more useful, we will create a model that generates not only a hexagonal density grid, but also a square density grid. This is done so that you can later compare the results and choose the one that you like more.</p></div>
<div class="section" title="Adding inputs"><div class="titlepage" id="aid-1T1402"><div><div><h1 class="title"><a id="ch08lvl1sec58"/>Adding inputs</h1></div></div></div><p>The first step of model <a id="id542" class="indexterm"/>creation is defining the input necessary for it. To do this, we should go over all the algorithms of the process that we want to automate and find out which input items are necessary. It is necessary to remember that some algorithms may not need separate inputs. They will use only results obtained in some previous steps, or in other words, the output of other algorithms. Also, some inputs may not be important and can be hardcoded in the model.</p><p>The <span class="strong"><strong>Processing modeler</strong></span> supports the following kinds of input, which can be found in the <span class="strong"><strong>Inputs</strong></span> tab on the left side of the modeler window:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Number: This is used for integer and floating-point values. When adding it, it is necessary to specify the minimum and maximum values allowed as well as a default value.</li><li class="listitem">String: This is a string literal. There is only one additional setting, namely the default value.</li><li class="listitem">Boolean: This is a boolean value, usually used as a checkbox. It is necessary to specify the default state: checked or unchecked.</li><li class="listitem">Extent: This represents a geographical extent.</li><li class="listitem">Vector layer: This is used for vector layers. If necessary, it is possible to limit the supported geometry types to one of the available types and make this input optional.</li><li class="listitem">Raster layer: This represents the raster layer in GDAL-supported format. It can be optional.</li><li class="listitem">Table: This is used for geometryless tables, for example, DBF files. It can be optional.</li><li class="listitem">Table field: This represents a field of the layer attribute table or geometryless table. It is necessary to specify the parent layer from which this field will be fetched.</li><li class="listitem">File: This is used to represent files and directories.</li></ul></div><p>To add an<a id="id543" class="indexterm"/> input, double-click on its name. A <span class="strong"><strong>Parameter definition</strong></span> dialog will open. Its content depends on the input type, but common for all input types is a <span class="strong"><strong>Parameter name</strong></span> field, where it is necessary to specify at least the name of the input. This text will be used as a caption for the corresponding field when the model will be executed. All other fields are different for different input.</p><div class="note" title="Note"><h3 class="title"><a id="tip26"/>Tip</h3><p>You can also use the drag-and-drop method from the inputs/algorithms tree to the modeler work area when adding inputs or algorithms.</p></div><p>Once all the settings are specified, click on the <span class="strong"><strong>OK</strong></span> button. A new input block will be added to the modeler's working area.</p><p>Let's start with adding input for our model. The first input is obvious; it is a vector layer to create a density map for. Double-click on the <span class="strong"><strong>Vector layer</strong></span> item in the <span class="strong"><strong>Inputs</strong></span> tab of the <span class="strong"><strong>Processing modeler</strong></span> window to open the <span class="strong"><strong>Parameter definition</strong></span> dialog, which looks like this:</p><div class="mediaobject"><img src="../Images/image00502.jpeg" alt="Adding inputs"/></div><p style="clear:both; height: 1em;"> </p><p>Enter a name in <span class="strong"><strong>Parameter name</strong></span>, for example, <code class="literal">Point layer</code>. As we don't want to see all available layers as input later, and search for a required layer through a long list, we can limit the supported geometry type by choosing the <span class="strong"><strong>Point</strong></span> geometry type in the <span class="strong"><strong>Shape type</strong></span> combobox. Finally, as this input is required, we leave the <span class="strong"><strong>Required</strong></span> field as <span class="strong"><strong>Yes</strong></span>. Click on the <span class="strong"><strong>OK</strong></span> button to add the input to the modeler working area.</p><p>To be able to<a id="id544" class="indexterm"/> make our final density map more detailed or more general, depending on our requirements, we need a way to adjust the cell size. So, double-click on the <span class="strong"><strong>Number</strong></span> item in the <span class="strong"><strong>Inputs</strong></span> tab to add another input.</p><div class="mediaobject"><img src="../Images/image00503.jpeg" alt="Adding inputs"/></div><p style="clear:both; height: 1em;"> </p><p>Enter <code class="literal">Vertical grid spacing</code> as <span class="strong"><strong>Parameter name</strong></span> as shown in the preceding screenshot. We can leave all other fields untouched, but it is better to specify them too. This should be done to prevent wrong input from users. We should now keep in mind the fact that different layers <a id="id545" class="indexterm"/>may have different coordinate reference systems (CRS). As a result, we will probably have different distance units. So, our numeric input should allow the user to enter values suitable for layers in geographic CRS (degrees) and projected CRS (meters, feet, and so on). That's why we use <code class="literal">0</code> as the minimum value and <code class="literal">99999999.999999</code> as the maximum value. These values allow us to change the cell size over a wide range, irrespective of the CRS used. Enter any reasonable value as <span class="strong"><strong>Default value</strong></span> and click on <span class="strong"><strong>OK</strong></span> when you're done.</p><p>As cell sizes in the horizontal and vertical directions can be different, we need to create another numeric parameter called <code class="literal">Horizontal grid spacing</code> using the same settings as you saw before.</p><div class="note" title="Note"><h3 class="title"><a id="tip27"/>Tip</h3><p>If you always need the same spacing in both the horizontal and vertical directions, it is better to use only one input parameter, as a single parameter can be used multiple times as an input in the same algorithm, or even in different algorithms. Later, we can adjust our model to use only one numeric parameter to define the grid spacing.</p></div><p>As you may remember from the <span class="emphasis"><em>Mapping density with a hexagonal grid</em></span> section of <a class="link" title="Chapter 5. Answering Questions with Density Analysis" href="part0043.xhtml#aid-190861">Chapter 5</a>, <span class="emphasis"><em>Answering Questions with Density Analysis</em></span>, when using a <code class="literal">Create grid</code> algorithm, it is necessary to specify the desired grid extent, and we take this extent from our input layer.</p><p>Now, for designing <a id="id546" class="indexterm"/>our model, we have two options:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Define the input for the grid extent. This will make our model a bit more complex, as we need to specify the grid extent each time we use the model, instead of specifying just the layer. But this option also brings more flexibility, because by having a separate input for the grid extent, we will be able to generate density maps not only for the entire layer but also for a specified region inside it.</li><li class="listitem">Take the extent from the input layer. In this case, our model will be simpler for users, as all they need to do is to define the layer and grid cell size. But on the other hand, the density map will be generated for the entire layer.</li></ol><div style="height:10px; width: 1px"/></div><p>As the most common use case is a density map for the entire layer, we choose the second option. The grid extent should be calculated automatically from the input point layer.</p><p>So, we have just defined almost all of the necessary input for our model: the input layer, and two numbers that represent the grid cell size in the horizontal and vertical directions. There is only one undefined input—the grid extent. You will learn how to extract it from the input layer in the next section, as this is closely related to workflow definition.</p></div>
<div class="section" title="Implementing the workflow"><div class="titlepage" id="aid-1TVKI2"><div><div><h1 class="title"><a id="ch08lvl1sec59"/>Implementing the workflow</h1></div></div></div><p>When all the input items are in place, we can start implementing a workflow. All the available algorithms can be found in the <span class="strong"><strong>Algorithms</strong></span> tab on the left side of the modeler window.</p><p>Workflow implementation is<a id="id547" class="indexterm"/> very similar to manual execution of all steps of analysis: we add algorithms one by one, choosing the correct input and, if necessary, defining the output. While the modeler allows us to add parameters and algorithms in any random order, it is better to add algorithms in the same order in which they should be executed to avoid confusion. Let's start!</p><p>As you may remember, we did not add a separate input for grid extent, and you may be curious to know how we will extract it from the point layer in a format compatible with the modeler input. The answer is simple: we will use special tools, which are so-called modeler-only tools. What are these? Well, all the algorithms that are available exclusively in the <span class="strong"><strong>Processing modeler</strong></span> are not available in the toolbox. Basically, these are helper tools that can be really useful in different models, for example, a simple calculator or a value converter. You can find these tools in the <span class="strong"><strong>Algorithms</strong></span> tab (as they are also algorithms) within the Modeler-only tools group.</p><p>Right now, we need a <span class="strong"><strong>Vector layer bounds</strong></span> tool, which takes a vector layer as the input and returns its extent<a id="id548" class="indexterm"/> as the output.</p><div class="note" title="Note"><h3 class="title"><a id="note34"/>Note</h3><p>Besides the extent, this tool also returns four numeric values: minimum and maximum <span class="emphasis"><em>x</em></span> coordinates, as well as minimum and maximum <span class="emphasis"><em>y</em></span> coordinates. You may use these values as input for different algorithms.</p></div><p>This output value can then be used as the input in any algorithm that requires the extent as the input. Find the <span class="strong"><strong>Vector layer bounds</strong></span> algorithm by typing its name in the filter field, and double-click on it to open the algorithm definition dialog as shown:</p><div class="mediaobject"><img src="../Images/image00504.jpeg" alt="Implementing the workflow"/></div><p style="clear:both; height: 1em;"> </p><p>The dialog is very simple. We will discuss definition dialogs a bit later. Right now, we just select our previously added <span class="strong"><strong>Point layer</strong></span> input in the <span class="strong"><strong>Layer</strong></span> combobox and click on the <span class="strong"><strong>OK</strong></span> button to close the dialog and add the algorithm to the modeler working area. Now that all preparation steps are done, we are ready to implement the main workflow.</p><p>The first step in our analysis is grid generation, so switch to the <span class="strong"><strong>Algorithms</strong></span> tab, find the <code class="literal">Create grid</code> algorithm by typing its name in the filter field, and double-click on it to open the algorithm definition dialog.</p><div class="mediaobject"><img src="../Images/image00505.jpeg" alt="Implementing the workflow"/></div><p style="clear:both; height: 1em;"> </p><p>As you can see, the algorithm definition dialog has almost the same content as the algorithm dialog <a id="id549" class="indexterm"/>opened from the toolbox. The main differences are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">There is no <span class="strong"><strong>Log</strong></span> tab where the algorithm reports its execution progress and other information. As the algorithm is not executed right now, this tab is not needed.</li><li class="listitem">There is a new <span class="strong"><strong>Description</strong></span> field. It is used to define the algorithm name inside the model. By default, this name is the same as the original algorithm name. This feature is very handy when the model contains several algorithm blocks that represent the same algorithm but use different inputs. In such a case, just assign different descriptions to this algorithm, and you will never be lost amid them. You will be able to identify their outputs easily.</li><li class="listitem">There is a new <span class="strong"><strong>Parent algorithms</strong></span> parameter at the bottom of the definition dialog, which does not exist when the algorithm is executed from the Processing toolbox. As the name implies, this parameter allows us to define parent algorithms for the selected algorithm, or in other words, set the algorithms' execution order. Parent algorithms will be executed in the specified order and before their children.<p>By default, when the current algorithm uses the output of another algorithm as its input, the latter automatically becomes a parent of the current algorithm, and a link between these two algorithms is created. But sometimes, one algorithm can depend on another even if it has not used any output from it. Here is a well-known example of such a situation: before executing a query against a database layer, it is necessary to create the database and the layer.</p></li><li class="listitem">There is a different approach for selecting inputs and outputs. All values can be selected from the list of already available model inputs and outputs, generated by algorithms that are already added to the model algorithms. Also, values such as numbers, strings, booleans, and table fields can be entered manually in the corresponding fields. Note that you cannot change values that are entered manually at design time if your model is executed from the toolbox or used as part<a id="id550" class="indexterm"/> of another model. So, don't hardcode values unless there is an urgent need.</li></ul></div><p>Now, proceed with the <code class="literal">Create grid</code> algorithm definition for our model. As we will generate two grids—hexagonal and square—using the same algorithm, we need to distinguish the algorithm blocks. So, change the <span class="strong"><strong>Description</strong></span> field to <code class="literal">Create hexagon grid</code>. We hardcode the <span class="strong"><strong>Grid type</strong></span> parameter by selecting <code class="literal">Hexagon (polygon)</code> from the combobox, as this is what we need.</p><p>In the <span class="strong"><strong>Grid extent</strong></span> combobox, select <code class="literal">'Extent' from algorithm 'Vector layer bounds'</code>. This is the extent of our input layer, so the generated hexagonal grid will cover it.</p><div class="note" title="Note"><h3 class="title"><a id="note35"/>Note</h3><p>In the <code class="literal">'Extent' from algorithm 'vector layer bounds'</code> text, <code class="literal">'Extent'</code> is the name of the output from the algorithm, and <code class="literal">'Vector layer bounds'</code> is an algorithm description from the <span class="strong"><strong>Description</strong></span> field of the corresponding definition dialog. So, you can easily detect which output is from which algorithm.</p></div><p>For horizontal and vertical grid spacing, select the previously defined input values from the corresponding comboboxes. You may notice that apart from the input values defined by us, there are some additional values produced by the <span class="strong"><strong>Vector layer bounds</strong></span> algorithm. Ignore them.</p><p>Don't enter any text in the <span class="strong"><strong>Output</strong></span> field, as the hexagonal grid generated by this algorithm is an intermediate, temporary output and not the final result. Temporary outputs will be generated and stored in the temporary directory, but will never be added to the QGIS main canvas after model execution. If you want to see these intermediate results, it is necessary to turn them into model output by entering descriptions for them.</p><p>When all parameters have their values assigned, click on the <span class="strong"><strong>OK</strong></span> button to add the algorithm to the modeler's working area. You will see that the algorithm block is now connected to its inputs. Clicking on the small <span class="strong"><strong>+</strong></span> sign near the <span class="strong"><strong>In</strong></span> or <span class="strong"><strong>Out</strong></span> labels will expand a list of inputs and/or outputs, so you can verify the correctness of the connections. The second click will collapse them back.</p><p>Add another <a id="id551" class="indexterm"/><span class="strong"><strong>Create grid</strong></span> algorithm. Change its <span class="strong"><strong>Description</strong></span> field to <code class="literal">Create square grid</code>, select <code class="literal">Rectangle (polygon)</code> as <span class="strong"><strong>Grid type</strong></span>, and set all other parameters as we did earlier with hexagon grid generation. Click on the <span class="strong"><strong>OK</strong></span> button when you are done. Now, we have two algorithm blocks in the modeler's working area that use the same input as shown in the following figure:</p><div class="mediaobject"><img src="../Images/image00506.jpeg" alt="Implementing the workflow"/></div><p style="clear:both; height: 1em;"> </p><p>The next algorithm we should add is <span class="strong"><strong>Count points in polygon</strong></span>. Find it in the <span class="strong"><strong>Algorithms</strong></span> tab of the modeler window by typing its name in the filter field, and double-click on it to open the algorithm definition dialog:</p><div class="mediaobject"><img src="../Images/image00507.jpeg" alt="Implementing the workflow"/></div><p style="clear:both; height: 1em;"> </p><p>Here, we also edit the <span class="strong"><strong>Description</strong></span> field to be able to distinguish the results of processing different grids, for example, <code class="literal">Count points in hexagon grid</code>. If you look at the available choices in the <span class="strong"><strong>Polygons</strong></span> and <span class="strong"><strong>Points</strong></span> comboboxes, you will see that both have an identical set of<a id="id552" class="indexterm"/> options: <code class="literal">Point layer</code>, <code class="literal">'Output' from algorithm 'Create hexagon grid'</code>, and <code class="literal">'Output' from algorithm 'Create square grid'</code>. The first is our previously defined input, and the second and third are the results produced by already added <span class="strong"><strong>Create grid</strong></span> algorithms. As you can see, we can easily identify the results produced by algorithms, thanks to their different descriptions.</p><p>Careful readers may ask, "Why do we see both the items in comboboxes? After all, they have different geometry types and we should see only those input items that have matching geometry types." Well, this is a current limitation of Processing—the modeler does not perform any accurate checks of the input. It always shows all of the available inputs with the corresponding type (vector, raster, or geometryless table) despite defined restrictions.</p><p>So, in the <span class="strong"><strong>Polygons</strong></span> combobox, we need to select the hexagonal grid produced by the <span class="strong"><strong>Create grid</strong></span> algorithm (<code class="literal">'Output' from algorithm 'Create hexagon grid'</code>), and in the <span class="strong"><strong>Points</strong></span> combobox, select the previously defined <code class="literal">Point layer</code> input. Leave the <span class="strong"><strong>Count field name</strong></span> field unchanged. This parameter will be used only in the next step and can be safely kept hardcoded.</p><p>We again leave the <span class="strong"><strong>Result</strong></span> field empty, as the density map produced at this stage is a temporary, intermediate result. It may contain empty cells, which should be deleted. Finally, press the <span class="strong"><strong>OK</strong></span> button to complete the algorithm definition and add it to the modeler working area.</p><p>Add another <span class="strong"><strong>Count points in polygon</strong></span> algorithm to create a square density map. Set its description to <code class="literal">Count points in square grid</code>, and as the <span class="strong"><strong>Polygon</strong></span> input, select the output from <code class="literal">'Output' from algorithm 'Create square grid'</code>. All other parameters should be the same as in the previous algorithm. Also, keep the <span class="strong"><strong>Result</strong></span> field empty.</p><p>Now, we can add the last algorithm to complete our simple model—<span class="strong"><strong>Extract by attribute</strong></span>. With this algorithm, we will clean up our density maps from cells that do not contain any useful information. In <a id="id553" class="indexterm"/>other words, we will remove empty cells.</p><p>Find the <span class="strong"><strong>Extract by attribute</strong></span> algorithm in the <span class="strong"><strong>Algorithms</strong></span> tab of the modeler window by typing its name in the filter field, and double-click on it to open the algorithm definition dialog:</p><div class="mediaobject"><img src="../Images/image00508.jpeg" alt="Implementing the workflow"/></div><p style="clear:both; height: 1em;"> </p><p>As before, we edit the <span class="strong"><strong>Description</strong></span> field to distinguish the same algorithm blocks and their output. For the description, we choose <code class="literal">Extract from hexagon grid</code>. In the <span class="strong"><strong>Input layer</strong></span> combobox, we should select the output of the <span class="strong"><strong>Count points in polygon</strong></span> algorithm—<code class="literal">'Result' from algorithm 'Count points in hexagon grid'</code>. As we have hardcoded the field name in the previous step, we enter the same name in the <span class="strong"><strong>Selection attribute</strong></span> field. Select <code class="literal">!=</code> (not equal to) from the <span class="strong"><strong>Operator</strong></span> combobox and enter <code class="literal">0</code> in the <span class="strong"><strong>Value</strong></span> field.</p><p>As this algorithm <a id="id554" class="indexterm"/>will produce a result that we want to use later, it is necessary to enter a result description in the <span class="strong"><strong>Output</strong></span> field, for example, <code class="literal">Hexagon density map</code>. Click on the <span class="strong"><strong>OK</strong></span> button to complete the algorithm definition and add it to the modeler working area. In addition to the algorithm block, this time, an output block will be added too.</p><p>Finally, add another <span class="strong"><strong>Extract by attribute</strong></span> algorithm to produce the final square density map. Don't forget to adjust the algorithm description, set the correct inputs, and specify the output name.</p><p>Currently, the model elements are placed in a slightly random order, and it is difficult to recognize the links between them. To improve readability and organize the model in a more structured way, we can drag all the blocks within working area. The links between them will be preserved. If necessary, you can also zoom in and out with the mouse wheel. Here is what final model may look like:</p><div class="mediaobject"><img src="../Images/image00509.jpeg" alt="Implementing the workflow"/></div><p style="clear:both; height: 1em;"> </p><p>That's all! We just<a id="id555" class="indexterm"/> create our first model, and if you have layers loaded in QGIS, you can try it out by clicking on the <span class="strong"><strong>Run model</strong></span> button on the toolbar.</p><div class="mediaobject"><img src="../Images/image00510.jpeg" alt="Implementing the workflow"/></div><p style="clear:both; height: 1em;"> </p><p>As you see, the model<a id="id556" class="indexterm"/> execution dialog has the same look and feel as all other Processing algorithms. Input vector layers can be selected from already available layers and loaded from the disk. Numerical values can be selected with spinboxes, can be accompanied by a calculator, and can maintain the restrictions we set.</p><p>But don't close the modeler right now! To fully use our model, run it from the toolbox as a batch process, and reuse it in other models, we need to save and document it first. That's what we are going to do in the next section.</p></div>
<div class="section" title="Filling model metadata and saving" id="aid-1UU541"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec60"/>Filling model metadata and saving</h1></div></div></div><p>After creating the model, is it necessary to save it on the disk so that Processing will be able to load it and register within toolbox.</p><p>By default, models are saved in <a id="id557" class="indexterm"/>JSON format with the <code class="literal">.model</code> extension in the models subdirectory inside the processing directory in the your QGIS user folder. Under Windows, this is usually <code class="literal">C:\Users\login\.qgis2</code> (<code class="literal">login</code> here is the name of your<a id="id558" class="indexterm"/> Windows user) and under Linux, it is <code class="literal">~/.qgis2</code>. If necessary, you can always change the location of the folder using the <span class="strong"><strong>Processing settings</strong></span> dialog.</p><p>When Processing starts, it looks for files with the <code class="literal">.model</code> extension in this directory and loads them. Loaded models appear in the toolbox, in the <span class="strong"><strong>Models</strong></span> group. Also, they are available in modeler like any other Processing algorithm.</p><div class="note" title="Note"><h3 class="title"><a id="note36"/>Note</h3><p>Sometimes, you may get errors if you are loading third-party models. This mainly occurs because some algorithms used in a particular model are not available. For example, a certain algorithm provider is deactivated from Processing settings, or the model requires additional scripts/models, which are not available in your Processing. In such cases, read the error message carefully and examine Processing's logs to learn which algorithms are missed. Activate or install them and try to load the problematic model again.</p></div><p>Before saving the model, it is necessary to define its name and the group where it will be placed. This information should be entered in fields above the modeler's working area. We choose <code class="literal">Density</code> maps as the model name and <code class="literal">Binning</code> as the group name. Feel free to choose your own names if you don't like these.</p><p>When the model name and group are defined, click on the <span class="strong"><strong>Save</strong></span> button in the toolbar and enter the name of the model. You will see a confirmation message when the model is saved.</p><p>We can close the modeler window right now, but don't rush! It is good practice to document your models, that is, describe the input, the actions performed, and the final results. Such information will be extremely useful for other users, who may want to reuse the model in their own tasks. Also, this metadata will afterwards help you recall what is this model is for.</p><p>To start editing the model metadata, click on the <span class="strong"><strong>Edit model help</strong></span> button in the modeler dialog toolbar. A <span class="strong"><strong>Help editor</strong></span> dialog will open, like this:</p><div class="mediaobject"><img src="../Images/image00511.jpeg" alt="Filling model metadata and saving"/></div><p style="clear:both; height: 1em;"> </p><p>This dialog is <a id="id559" class="indexterm"/>divided into three areas. At the top, there is a preview area. Here, the current help contents are displayed so that you can see how the final result will look in<a id="id560" class="indexterm"/> real-time mode. In the bottom-left part is the elements tree, where all help sections are listed, including algorithm description as well as parameters, input, and other information. In the bottom-right part, there is an editing area. Here, we will enter a description of the corresponding element.</p><p>To edit the description of the element, select it in the elements list and enter text in the <span class="strong"><strong>Element description</strong></span> field. To save the changes, just select another element in the elements tree.</p><p>Go through all the items in elements tree and enter their descriptions. For example, as <span class="strong"><strong>Algorithm description</strong></span>, you can use the following text:</p><div class="informalexample"><pre class="programlisting">Generates hexagonal and square density maps from point dataset using binning technique. Output maps contain only non-empty cells.
This is demo model from Packt's QGIS by Example book.</pre></div><p>Describe all the other fields yourself. Try to be short and, at the same time, give as much useful information <a id="id561" class="indexterm"/>as possible. Don't explain obvious things—it's better to concentrate on important details. For example, in the description of the grid spacing inputs, it is worth mentioning that <a id="id562" class="indexterm"/>grid spacing should be defined in the same distance units as those used by layer. When you're done, click on the <span class="strong"><strong>OK</strong></span> button to close the <span class="strong"><strong>Help editor</strong></span> dialog.</p><p>The model metadata will be saved automatically in the same file as the model itself when you click on the <span class="strong"><strong>Save</strong></span> button in the toolbar.</p></div>
<div class="section" title="Editing models" id="aid-1VSLM1"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec61"/>Editing models</h1></div></div></div><p>You can also load any <a id="id563" class="indexterm"/>existing model in the modeler to edit it. You can do this, for example, to adjust some hardcoded parameters, to redefine the workflow, or just to learn how it works. There are two ways of loading an existing model:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Find the model in toolbox by typing its name in the search field. Right-click on the model to open the context menu and select <span class="strong"><strong>Edit model</strong></span>.</li><li class="listitem">Open the Processing modeler from the <span class="strong"><strong>Processing</strong></span> menu, click on the <span class="strong"><strong>Open model</strong></span> button from the toolbar and navigate to the model file.</li></ol><div style="height:10px; width: 1px"/></div><p>To edit any input or algorithm, click on the small pencil icon in the bottom-right corner of the corresponding block. Also, you can choose <span class="strong"><strong>Edit</strong></span> from the context menu, opened by right-clicking. Any of these actions will open a definition dialog where you can perform the necessary changes, for example, update the values or restrictions or reconnect the elements. After you have clicked on the <span class="strong"><strong>OK</strong></span> button, the dialog will be closed and links between model blocks will be updated, if necessary.</p><p>To delete unnecessary items (input or algorithm), click on the cross button in the top-right corner of the corresponding block, or select <span class="strong"><strong>Remove</strong></span> from the item's context menu. Note that the algorithm or input can be removed only if there are no other elements depending on it. In other words, an input should not be used by any algorithm, and algorithm outputs should not be used as inputs in other algorithms. If you try to delete a block that has items depending on it, you will see a warning message and the operation will be canceled.</p><p>Now, let's edit our model. As in almost all use cases, grid cells should have equal dimensions in both horizontal and vertical directions. It is very good to leave only one numeric parameter in the model. This simplifies the model and makes the user's life simpler, as they will need to enter less data when executing the model.</p><p>First, we need to edit one of the numeric inputs and change its name to match the input meaning. Click on the pencil icon in the bottom-right corner of the <span class="strong"><strong>Vertical grid spacing</strong></span> block, change the <span class="strong"><strong>Parameter</strong></span> name to <code class="literal">Grid spacing</code>, and click on the <span class="strong"><strong>OK</strong></span> button to save your edits.</p><div class="note" title="Note"><h3 class="title"><a id="note37"/>Note</h3><p>Alternatively, you can edit the <span class="strong"><strong>Horizontal grid spacing</strong></span> input. This replacement is completely safe.</p></div><p>Now, open the <a id="id564" class="indexterm"/>definition dialog of the <span class="strong"><strong>Create grid</strong></span> algorithm and select the <code class="literal">Grid spacing</code> input in both fields: <span class="strong"><strong>Horizontal spacing</strong></span> and <span class="strong"><strong>Vertical spacing</strong></span>. When you're done, click on the <span class="strong"><strong>OK</strong></span> button to save your edits and close the dialog. You will see that the connections between blocks have now changed—one numeric input (its name depends on the input you edited previously) is not connected to any algorithm. To delete this input, click on the cross in the top-right corner. The updated model may look like this:</p><div class="mediaobject"><img src="../Images/image00512.jpeg" alt="Editing models"/></div><p style="clear:both; height: 1em;"> </p><p>If you want, you can save the updated model as a new model. To do this, just enter a different model name and, if necessary, a group name. Then, click on the <span class="strong"><strong>Save as...</strong></span> button and enter a <a id="id565" class="indexterm"/>name for the new model file.</p><p>It is also possible to deactivate some parts of the model—a particular algorithm or even an entire branch—without deleting the corresponding blocks. This feature is extremely useful when you don't want to get all of the output produced by the model or need to debug/test a small part of it.</p><p>To deactivate an algorithm, right-click on it and select <span class="strong"><strong>Deactivate</strong></span> in the context menu. The corresponding algorithm block will be grayed out, and all algorithm blocks that depend on it will be automatically deactivated too. Deactivated algorithms will be skipped during model execution and will not generate any output. This has an advantage—the model's execution time is reduced. Keep in mind that the status of the algorithms (active/deactivated) is being saved in the model file, and before saving a model, make sure that you don't miss anything.</p><p>To activate an algorithm, right-click on it and select <span class="strong"><strong>Activate</strong></span> from the context menu. Note that this activation affects only the selected algorithm. All algorithms that depend on it will remain deactivated, and you'll have to activate them one by one.</p><p>As an example, imagine that you don't need to generate square density maps. Of course, we can create a new model from an existing one by deleting unnecessary blocks and using the <span class="strong"><strong>Save as...</strong></span> functionality. Creating a new model makes sense when you often need to generate<a id="id566" class="indexterm"/> only hexagonal density maps. But if there is a one-time requirement, it is better to simply deactivate the <span class="strong"><strong>Create square grid</strong></span> block in our model, and all the dependent blocks will be deactivated too. So, you can execute the model, generate only hexagonal density maps, and then activate the disabled blocks again.</p></div>
<div class="section" title="Sharing models" id="aid-20R681"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec62"/>Sharing models</h1></div></div></div><p>If you have created useful models that may help other users, it would be good to share them with the community so that others don't need to reinvent the wheel.</p><p>As the saved Processing model is a single file in JSON format, the easiest way to share it with others is to send it to those who are interested in it, or upload the model file to any file sharing or hosting site<a id="id567" class="indexterm"/> and provide everyone with a link to this file.</p><p>A bit more complex—but at the same time, a very convenient and user-friendly—way is to publish your model in the Processing models and scripts community repository. This repository was created in the spring of 2014, and provides a centralized way to share Processing scripts and models among QGIS users.</p><p>To put your model into this repository, you need<a id="id568" class="indexterm"/> to fork the GitHub repository (<a class="ulink" href="https://github.com/qgis/QGIS-Processing">https://github.com/qgis/QGIS-Processing</a>), commit your model in your fork, and issue a pull request.</p><div class="note" title="Note"><h3 class="title"><a id="tip28"/>Tip</h3><p>To learn more about Git, use one of the Packt's books, such as <span class="emphasis"><em>Git: Version Control for Everyone</em></span>, and refer to the<a id="id569" class="indexterm"/> GitHub documentation at <a class="ulink" href="https://help.github.com/">https://help.github.com/</a>.</p></div><p>Another option is to send the model to the qgis-developer mailing list, or directly to one of Processing's developers and ask them to put it into the repository.</p><p>To get models from this repository, use the <span class="strong"><strong>Get models from on-line script collection</strong></span> tool located in the <span class="strong"><strong>Tools</strong></span> subgroup under the <span class="strong"><strong>Models</strong></span> item in the Processing toolbox.</p></div>
<div class="section" title="Summary" id="aid-21PMQ1"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec63"/>Summary</h1></div></div></div><p>In this chapter, you learned how to use the Graphical modeler from the QGIS Processing framework to create geoprocessing models from multiple algorithms. The Modeler allows us to automate analyses and increase productivity by combining complex analyses that require several steps into a single, easy-to-use algorithm that can be reused.</p><p>We also covered additional important topics, including documenting models and sharing them with other users.</p></div></body></html>