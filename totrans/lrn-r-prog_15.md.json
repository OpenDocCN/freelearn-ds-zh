["```py\nn <- 100 \nx <- rnorm(n) \ny <- 2 * x + rnorm(n) \nm <- lm(y ~ x) \ncoef(m) \n\n```", "```py\nSELECT name, price \nFROM products \nWHERE category = 'Food' \nORDER BY price desc \n\n```", "```py\n[ \n  { \n    \"id\": 1, \n    \"name\": \"Product-A\", \n    \"price\": 199.95 \n  }, \n  { \n    \"id\": 2, \n    \"name\": \"Product-B\", \n    \"price\": 129.95 \n  } \n] \n\n```", "```py\n<?xml version=\"1.0\"?> \n<root> \n  <product id=\"1\"> \n    <name>Product-A<name> \n    <price>$199.95</price> \n  </product> \n  <product id=\"2\"> \n    <name>Product-B</name> \n    <price>$129.95</price> \n  </product> \n</root> \n\n```", "```py\n<!DOCTYPE html> \n<html> \n<head> \n  <title>Simple page</title> \n</head> \n<body> \n  <h1>Heading 1</h1> \n  <p>This is a paragraph.</p> \n</body> \n</html> \n\n```", "```py\n# Heading 1 \n\nThis is a top level section. This paragraph contains both __bold__ text and _italic_ text. There are more than one syntax to represent **bold** text and *italic* text. \n\n## Heading 2 \n\nThis is a second level section. The following are some bullets. \n\n* Point 1 \n* Point 2 \n* Point 3 \n\n### Heading 3 \n\nThis is a third level section. Here are some numbered bullets. \n\n1\\. hello \n2\\. world \n\nLink: [click here](https://r-project.org) \nImage: ![image-title](https://www.r-project.org/Rlogo.png) \nImage link: [![image-title](https://www.r-project.org/Rlogo.png)](https://r-project.org) \n\n```", "```py` ```", "```py`) are used to contain a code block written in language X. Code blocks are shown in fixed-width font which is better for presenting program code. Also, we can preview what we have written so far:\n\n![Getting to know markdown](img/image_15_004.jpg)\n\nAnother special symbol, `$`, is used to quote math formulas. Single dollar (`$`) indicates inline math whereas double dollars (`$$`) displays math (in a new line). The math formula should be written in LaTeX math syntax ([https://en.wikibooks.org/wiki/LaTeX/Mathematics](https://en.wikibooks.org/wiki/LaTeX/Mathematics)).\n\nThe following math equation is not that simple: *$$x^2+y^2=z^2$$*, where *$x$*,*$y$*, and *$z$* are integers.\n\nNot all markdown editors support the preview of math formulas. In StackEdit, the preceding markdown is previewed as follows:\n\n![Getting to know markdown](img/image_15_005.jpg)\n\nIn addition, many markdown renderers support the table syntax shown as follows:\n\n```", "```py\n\nIn StackEdit, the preceding text table is rendered as follows:\n\n![Getting to know markdown](img/image_15_006.jpg)\n\n## Integrating R into Markdown\n\nMarkdown is easy to write and read, and has most necessary features for writing reports such as simple text formatting, embedding images, links, tables, quotes, math formula, and code blocks.\n\nAlthough writing plain texts in markdown is easy, creating reports with many images and tables is not, especially when the images and tables are produced dynamically by code. R Markdown is the killer app that integrates R into markdown.\n\nMore specifically, the markdowns we showed earlier in this chapter are all static documents; that is, they were determined when we wrote them. However, R Markdown is a combination of R code and markdown texts. The output of R code can be text, table, images, and interactive widgets. It can be rendered as an HTML web page, a PDF document, and even a Word document. Visit [http://rmarkdown.rstudio.com/formats.html](http://rmarkdown.rstudio.com/formats.html) to learn more about supported formats.\n\nTo create an R Markdown document, click the menu item, as shown in the following screenshot:\n\n![Integrating R into Markdown](img/image_15_007.jpg)\n\nIf you don't have `rmarkdown` and `knitr` installed, RStudio will install these necessary packages automatically. Then you can write a title and author and choose a default output format, as shown in the following screenshot:\n\n![Integrating R into Markdown](img/image_15_008.jpg)\n\nThen a new R Markdown document will be created. The new document is not empty but a demo document that shows the basics of writing texts and embedding R code which produces images. In the template document, we can see some code chunks like:\n\n![Integrating R into Markdown](img/image_15_009.jpg)\n\nThe preceding chunk evaluates `summary(cars)` and will produce some text output:\n\n![Integrating R into Markdown](img/image_15_010.jpg)\n\nThe preceding chunk evaluates `plot(pressure)` and will produce an image. Note that we can specify options for each chunk in the form of `{r [chunk_name], [options]}` where `[chunk_name]` is optional and is used to name the produced image and `[options]` is optional and may specify whether the code should appear in the output document, the width and height of the produced graphics, and so on. To find more options, visit [http://yihui.name/knitr/options/](http://yihui.name/knitr/options/).\n\nTo render the document, just click on the **Knit** button:\n\n![Integrating R into Markdown](img/image_15_011.jpg)\n\nWhen the document is properly saved to disk, RStudio will call functions to render the document into a web page. More specifically, the document is rendered in two steps:\n\n1.  The `knitr` module runs the code of each chunk and places the code and output according to the chunk options so that `Rmd` is fully rendered as a static markdown document.\n2.  The `pandoc` module renders the resulted markdown document as HTML, PDF, or DOCX according to the `Rmd` options specified in file header.\n\nAs we are editing an R Markdown document in RStudio, we can choose which format to produce anytime and then it will automatically call the `knitr` module to render the document into markdown and then run the `pandoc` module with the proper arguments to produce a document in that format. This can also be done with code using functions provided by `knitr` and `rmarkdown` modules.\n\nIn the new document dialog, we can also choose presentation and create slides using R Markdown. Since writing documents and writing slides are similar, we won't go into detail on this topic.\n\n## Embedding tables and charts\n\nWithout R code chunks, R Markdown is no different from a plain markdown document. With code chunks, the output of code is embedded into the document so that the final content is dynamic. If a code chunk uses a random number generator without fixing the random seed, each time we knit the document we will get different results.\n\nBy default, the output of a code chunk is put directly beneath the code in fixed-width font starting with `##` as if the code is run in the console. This form of output works but is not always satisfactory, especially when we want to present the data in more straightforward forms.\n\n### Embedding tables\n\nWhen writing a report, we often need to put tables within the contents. In an R Markdown document, we can directly evaluate a `data.frame` variable. Suppose we have the following `data.frame`:\n\n```", "```py\n\nTo output the variable in plain text, we only need to type the variable name in a code chunk:\n\n```", "```py\n\nNote that HTML, PDF, and Word documents all support native tables. To produce a native table for the chosen format, we can use `knitr::kable()` to produce the markdown representation of the table just like the following:\n\n```", "```py\n\nWhen `pandoc` renders the resulted markdown document to other formats, it will produce a native table from the markdown representation:\n\n```", "```py\n\nThe table generated native table is shown as follows:\n\n| **id** | **name** | **price** | **share** |\n| 1 | Car | 15 | 0.3 |\n| 2 | Plane | 25 | 0.1 |\n| 3 | Motocycle | 14 | 0.2 |\n\nThere are other packages that produce native tables but with enhanced features. For example, the `xtable` package not only supports converting `data.frame` to LaTeX, it also provides pre-defined templates to present the results of a number of statistical models.\n\n```", "```py\n\nWhen the preceding code is knitted with the `results='asis'` option, the linear model will be shown as the following table in the output PDF document:\n\n![Embedding tables](img/image_15_012.jpg)\n\nThe most well-known data software is perhaps Microsoft Excel. A very interesting feature of Excel is conditional formatting. To implement such features in R, I developed `formattable` package. To install, run `install.packages(\"formattable\")`. It enables cell formatting in a data frame to exhibit more comparative information:\n\n```", "```py\n\nThe generated table is shown as follows:\n\n![Embedding tables](img/image_15_013.jpg)\n\nSometimes, the data has many rows, which makes embedding such a table into the document not a good idea. But JavaScript libraries such as DataTables ([https://datatables.net/](https://datatables.net/)) make it easier to embed large data sets in a web page because it automatically performs paging and also supports search and filtering. Since an R Markdown document can be rendered into an HTML web page, it is natural to leverage the JavaScript package. An R package called DT ([http://rstudio.github.io/DT/](http://rstudio.github.io/DT/)) ports DataTables to R data frames and we can easily put a large data set into a document to let the reader explore and inspect the data in detail:\n\n```", "```py\n\nThe generated table is shown as follows:\n\n![Embedding tables](img/image_15_014.jpg)\n\nThe preceding packages, `formattable` and `DT` are two examples of a wide range of HTML widgets ([http://www.htmlwidgets.org/](http://www.htmlwidgets.org/)). Many of them are adapted from popular JavaScript libraries since there are already a good number of high quality JavaScript libraries in the community.\n\n### Embedding charts and diagrams\n\nEmbedding charts is as easy as embedding tables as we demonstrated. If a code chunk produces a plot, `knitr` will save the image to a file with the name of the code chunk and write `[name](image-file.png)` below the code so that when `pandoc` renders the document the image will be found and inserted to the right place:\n\n```", "```py\n\nThe plot generated is shown as follows:\n\n![Embedding charts and diagrams](img/image_15_015.jpg)\n\nThe default image size may not apply to all scenarios. We can specify chunk options `fig.height` and `fig.width` to alter the size of the image.\n\nIn addition to creating charts with basic graphics and packages like `ggplot2`, we can also create diagrams and graphs using `DiagrammeR` package. To install the package from CRAN, run `install.packages(\"DiagrammeR\")`.\n\nThis package uses Graphviz ([https://en.wikipedia.org/wiki/Graphviz](https://en.wikipedia.org/wiki/Graphviz)) to describe the relations and styling of a diagram. The following code produces a very simple directed graph:\n\n```", "```py\n\nThe generated graph is shown as follows:\n\n![Embedding charts and diagrams](img/image_15_016.jpg)\n\nDiagrammeR also provides a more programmable way to construct diagrams. It exports a set of functions to perform operations on a graph. Each function takes a graph and outputs a modified graph. Therefore it is easy to use pipeline to connect all operations to produce a graph in a streamline. For more details, visit the package website at [http://rich-iannone.github.io/DiagrammeR](http://rich-iannone.github.io/DiagrammeR).\n\n### Embedding interactive plots\n\nPreviously, we demonstrated both static tables (`knitr::kable`, `xtable`, and `formattable`) and interactive tables (`DT`). Similar things happen to plots too. We can not only place static images in the document as we did in the previous section, but also create dynamic and interactive plots in either the viewer or the output document.\n\nIn fact, there are more packages designed to produce interactive graphics than tables. Most of them take advantage of existing JavaScript libraries and make R data structures easier to work with them. In the following code, we introduce some of the most popular packages used to create interactive graphics.\n\nThe ggvis ([http://ggvis.rstudio.com/](http://ggvis.rstudio.com/)) developed by RStudio uses Vega ([https://vega.github.io/vega/](https://vega.github.io/vega/)) as its graphics backend:\n\n```", "```py\n\nThe plot generated is shown as follows:\n\n![Embedding interactive plots](img/image_15_017.jpg)\n\nNote that its grammar is a bit like `ggplot2`. It best works with a pipeline operator.\n\nAnother package is called `dygraphs` ([https://rstudio.github.io/dygraphs/](https://rstudio.github.io/dygraphs/)) which uses the JavaScript library ([http://dygraphs.com/](http://dygraphs.com/)) of the same name. This package specializes in plotting time series data with interactive capabilities.\n\nIn the following example, we use the temperature data of airports provided in the `nycflights13` package. To plot the daily temperature time series of each airport present in the data, we need to summarize the data by computing the mean temperature on each day, reshape the long-format data to wide-format, and convert the results to an `xts` time series object with a date index and temperature columns corresponding to each airport:\n\n```", "```py\n\nThen we supply `temp_xts` to `dygraph()` to create an interactive time series plot with a range selector and dynamic highlighting:\n\n```", "```py\n\nThe plot generated is shown as follows:\n\n![Embedding interactive plots](img/image_15_018.jpg)\n\nIf the code is run in R terminal, the web browser will launch and show a web page containing the plot. If the code is run in RStudio, the plot will show up in the **Viewer** pane. If the code is a chunk in R Markdown document, the plot will be embedded into the rendered document.\n\nThe main advantage of interactive graphics over static plots is that interactivity allows users to further examine and explore the data rather than forcing users to view it from a fixed perspective.\n\nThere are other remarkable packages of interactive graphics. For example, `plotly` ([https://plot.ly/r/](https://plot.ly/r/)) and `highcharter` ([http://jkunst.com/highcharter/](http://jkunst.com/highcharter/)) are nice packages to produce a wide range of interactive plots based on JavaScript backends.\n\nIn addition to the features we demonstrated in the previous sections, R Markdown can also be used to create presentation slides, journal articles, books and websites. Visit the official website at [http://rmarkdown.rstudio.com](http://rmarkdown.rstudio.com) to learn more.\n\n# Creating interactive apps\n\nIn the previous section, we demonstrated the use of R Markdown that is designed for creating dynamic documents. In this section, we will take a quick tour of creating interactive apps where we use a graphical user interface to interact with the data.\n\n## Creating a shiny app\n\nR itself is a great environment for data analysis and visualization. However, it is not usual to deliver R and some analytic scripts to the customers to run by themselves. The outcome of data analysis can be presented not only in a HTML page, PDF document, or a Word document, but also in an interactive app that allows readers to interact with the data by modifying some parameters and see what happens with the outcome.\n\nA powerful package, `shiny` ([http://shiny.rstudio.com/](http://shiny.rstudio.com/)), developed by RStudio, is designed exactly for this purpose. A shiny app is different from the interactive graphics we demonstrated previously. It works in a web browser and the developer has all the say about what appears in the web page and how users can interact with it. To achieve this, a shiny app basically consists of two important parts: An HTTP server that interacts with the web browser, and an R session that interacts with the HTTP server.\n\nThe following is a minimal shiny app. We write an R script to define its user interface (`ui`) and `server` logic. The user interface is a `boostrapPage` which contains a `numericInput` to take an integer of sample size and a `textOutput` to show the mean of the randomly generated sample. The logic behind `server` is to simply generate random numbers according to the sample size (`n`) in the `input` and put the mean of the random sample to the `output`:\n\n```", "```py\n\nThe definition is now complete and we can source the code in RStudio to play with this minimal shiny app, as shown in the following screenshot:\n\n![Creating a shiny app](img/image_15_019.jpg)\n\nEach time we change the number of the sample size, the HTTP server will ask the R backend to rerun the server logic and refresh the output mean.\n\nAlthough the preceding example is not useful, it at least demonstrates the basic components of a shiny app. Now we look at a more complicated but useful example.\n\nThe following example is a visualizer of many paths generated by geometric Brownian motion which is often used to model stock prices. As we know, a geometric Brownian motion is characterized by starting value, expected growth rate (`r`), volatility (`sigma`), duration (`T`) and the number of `periods`. Expect for `T = 1`, we allow users to modify all other parameters.\n\nNow we can define the user interface of the shiny app according to the parameters we want to expose to users. The `shiny` package provides a rich set of input controls listed as follows:\n\n```", "```py\n\nTo control the randomness of the generated paths, we allow users to specify the random seed (`seed`) so that the same seed produces the same paths. In the following code where `ui` is defined, we use `numericInput` for `seed` and `sliderInput` for other parameters. The `sliderInput` control has a certain range and step so that we can force a parameter to take reasonable values.\n\nThe user interface not only defines the input part but also the output part, that is, where to show what. The following is all output types shiny provides:\n\n```", "```py\n\nIn this example, the shiny app only shows a plot of all paths put together to indicate different possibilities with the same set of parameters:\n\n```", "```py\n\nOnce the user interface is defined, we need to implement the server logic which is basically about generating random paths according to user-specified parameters and put them together in the same plot.\n\nThe following code is a simple implementation of the server logic. First we set the random seed. Then we iteratively call `sde::GBM` to generate random paths from geometric Brownian motion. To install the package, run `install.packages(\"sde\")` before calling `GBM`:\n\nThe `GBM` package is responsible for generating one path while `sapply` is used to combine all generated paths into a matrix (`mat`) where each column represents a path. Finally, we use `matplot` to plot each path in different colors together in one chart.\n\nThe calculation is done in `render*` functions no matter whether it is a text, image, or a table. The following lists all the render functions shiny provides:\n\n```", "```py\n\nIn this example, we only need `renderPlot()` and to put the plotting code in it. The `output$plot` function will go to `plotOutput(\"plot\")` in the user interface when the input is modified:\n\n```", "```py\n\nNow both user interface and server logic are ready. We can combine them together to create a shiny app and run it in the web browser.\n\n```", "```py\n\nWhen the parameters are modified, the plot will be refreshed automatically:\n\n![Creating a shiny app](img/image_15_020.jpg)\n\nIf we set a significantly positive annualized expected return, the generated paths will tend to grow more than decline:\n\n![Creating a shiny app](img/image_15_021.jpg)\n\n## Using shinydashboard\n\nIn addition to the functions `shiny` provides, RStudio also develops `shinydashboard` ([http://rstudio.github.io/shinydashboard/](http://rstudio.github.io/shinydashboard/)) which is specialized in presenting data for overview or monitoring purposes.\n\nThe following example demonstrates how easy it is to create a simple dashboard to show the most popular R packages on CRAN with the most downloads in weekly and monthly time scale.\n\nThe data source is provided by `cranlogs` ([http://cranlogs.r-pkg.org](http://cranlogs.r-pkg.org)). First run the following code to install the packages we need:\n\n```", "```py\n\nThen we take a quick view of the data source of CRAN downloads:\n\n```", "```py\n\nAfter getting familiar with the form of data we want to present in the dashboard, we can now think about constructing the dashboard in exactly the same way as constructing a typical shiny app. To make the most of `shinydashboard`, it is better to go through [http://rstudio.github.io/shinydashboard/structure.html](http://rstudio.github.io/shinydashboard/structure.html) to get a general idea of the nice components it provides.\n\nSimilarly to shiny app, we start by creating the user interface. This time, we use `dashboardPage`, `dashboardSidebar` and `dashboardBody`. In the dashboard, we want to present the package download dynamics and tables of the most popular packages with top downloads in both monthly and weekly scales.\n\nWe put the menu of monthly and weekly in the side bar so users can choose which to see. In each tab page, we can put plots and tables together. In this example, we use `formattable` to add color bars on the download column to make the numbers more comparable and straightforward.\n\n```", "```py\n\nNote that `plotOutput` is provided by `shiny` while `formattableOutput` is provided by `formattable` package. In fact, developers can create all kinds of HTML widgets that can be embedded into a shiny app as long as the package properly defines the `render*` function and `*Output` function to produce the correct HTML code.\n\nThen we define the server logic. Since the output relies purely on the data source, we download the data before calling `formattable` and `plot`.\n\n```", "```py\n\nIn fact, if the data is updating, we can create a dynamic dashboard where the tables and charts periodically refresh. Using `?reactiveTimer` and `?reactive` will be the key to achieve this. Read the documentation for more information.\n\nBoth the user interface and the server logic are ready, so we can run the app now:\n\n```"]