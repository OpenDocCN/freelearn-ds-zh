<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 8. Using the ArcPy Data Access Module with Feature Classes and Tables"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Using the ArcPy Data Access Module with Feature Classes and Tables</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Retrieving features from a feature class with SearchCursor</li><li class="listitem" style="list-style-type: disc">Filtering records with a where clause</li><li class="listitem" style="list-style-type: disc">Improving cursor performance with geometry tokens</li><li class="listitem" style="list-style-type: disc">Inserting rows with InsertCursor</li><li class="listitem" style="list-style-type: disc">Updating rows with UpdateCursor</li><li class="listitem" style="list-style-type: disc">Deleting rows with UpdateCursor</li><li class="listitem" style="list-style-type: disc">Inserting and updating rows inside an edit session</li><li class="listitem" style="list-style-type: disc">Reading geometry from a feature class</li><li class="listitem" style="list-style-type: disc">Using Walk() to navigate directories</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec57"/>Introduction</h1></div></div></div><p>We'll start this chapter with a basic question. What are cursors? <span class="strong"><strong>Cursors</strong></span> are in-memory objects containing<a id="id436" class="indexterm"/> one or more rows of data from a table or feature class. Each row contains attributes from each field in a data source along with the geometry for each feature. Cursors allow you to search, add, insert, update, and delete data from tables and feature classes.</p><p>The <code class="literal">arcpy</code> data access module or <code class="literal">arcpy.da</code> was introduced in ArcGIS 10.1 and contains <a id="id437" class="indexterm"/>methods that allow you to iterate through each row in a cursor. Various types of cursors can be created depending on the needs of developers. For example, search cursors can be created to read values from rows. Update cursors can be created to update values in rows or delete rows, and insert cursors can be created to insert new rows.</p><p>There are a number of cursor improvements that have been introduced with the <code class="literal">arcpy</code> data access module. Prior to the development of ArcGIS 10.1, cursor performance was notoriously slow. Now, cursors are significantly faster. Esri has estimated that <code class="literal">SearchCursors</code> are up to 30 times faster, while <code class="literal">InsertCursors</code> are up to 12 times faster. In addition to these general performance improvements, the data access module also provides a number of new options that allow programmers to speed up processing. Rather than returning all the fields in a cursor, you can now specify that a subset of fields be returned. This increases the performance as less data needs to be returned. The same applies to geometry. Traditionally, when accessing the geometry of a feature, the entire geometric definition would be returned. You can now use geometry tokens to return a portion of the geometry rather than the full geometry of the feature. You can also use lists and tuples rather than using rows. There are also other new features, such as edit sessions and the ability to work with versions, domains, and subtypes.</p><p>There are three cursor functions in <code class="literal">arcpy.da</code>. Each returns a cursor object with the same name as the function. <code class="literal">SearchCursor()</code> creates a read-only <code class="literal">SearchCursor</code> object containing rows from a table or feature class. <code class="literal">InsertCursor()</code> creates an <code class="literal">InsertCursor</code> object that can be used to insert new records into a table or feature class. <code class="literal">UpdateCursor()</code> returns a cursor object that can be used to edit or delete records from a table or feature class. Each of these cursor objects has methods to access rows in the cursor. You can see the relationship between the cursor functions, the objects they create, and how they are used, as follows:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Function</p>
</th><th style="text-align: left" valign="bottom">
<p>Object created</p>
</th><th style="text-align: left" valign="bottom">
<p>Usage</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SearchCursor()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">SearchCursor</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id438" class="indexterm"/>is a read-only view of data from a table or feature class</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">InsertCursor()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">InsertCursor</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id439" class="indexterm"/>adds rows to a table or feature class</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">UpdateCursor()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">UpdateCursor</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id440" class="indexterm"/>edits or deletes rows in a table or feature class</p>
</td></tr></tbody></table></div><p>The <code class="literal">SearchCursor()</code> function is used to return a <code class="literal">SearchCursor</code> object. This object can only be used to iterate through a set of rows returned for read-only purposes. No insertions, deletions, or updates can occur through this object. An optional <code class="literal">where</code> clause can be set to limit the rows returned.</p><p>Once you've obtained a cursor instance, it is common to iterate the records, particularly with <code class="literal">SearchCursor</code> or <code class="literal">UpdateCursor</code>. There are some peculiarities that you need to understand when <a id="id441" class="indexterm"/>navigating the records in a cursor. Cursor navigation is forward-moving only. When a cursor is created, the pointer of the cursor sits just above the first row in the cursor. The first call to <code class="literal">next()</code> will move the pointer to the first row. Rather than calling the <code class="literal">next()</code> method, you can also use a <code class="literal">for</code> loop to process each of the records without the need to call the <code class="literal">next()</code> method. After performing whatever processing you need to do with this row, a subsequent call to <code class="literal">next()</code> will move the pointer to row 2. This process continues as long as you need to access additional rows. However, after a row has been visited, you can't go back a single record at a time. For instance, if the current row is row 3, you can't programmatically back up to row 2. You can only go forward. To revisit rows 1 and 2, you would need to either call the <code class="literal">reset()</code> method or recreate the cursor and move back through the object. As I mentioned earlier, cursors are often navigated through the use of <code class="literal">for</code> loops as well. In fact, this is a more common way to iterate a cursor and a more efficient way to code your scripts. Cursor navigation is illustrated in the following diagram:</p><div class="mediaobject"><img src="images/B04314_08_2.jpg" alt="Introduction"/></div><p>The <code class="literal">InsertCursor()</code> function is used to create an <code class="literal">InsertCursor</code> object that allows you to programmatically add new records to feature classes and tables. To insert rows, call the <code class="literal">insertRow()</code> method on this object. You can also retrieve a read-only tuple containing the <a id="id442" class="indexterm"/>field names in use by the cursor through the <code class="literal">fields</code> property. A lock is placed on the table or feature class being accessed through the cursor. Therefore, it is important to always design your script in a way that releases the cursor when you are done.</p><p>The <code class="literal">UpdateCursor()</code> function can be used to create an <code class="literal">UpdateCursor</code> object that can update and delete rows in a table or feature class. As is the case with <code class="literal">InsertCursor</code>, this function places a lock on the data while it's being edited or deleted. If the cursor is used inside a Python's <code class="literal">with</code> statement, the lock will automatically be freed after the data has been processed. This hasn't always been the case. Prior to ArcGIS 10.1, cursors were required to be manually released using the Python <code class="literal">del</code> statement. Once an instance of <code class="literal">UpdateCursor</code> has been obtained, you can then call the <code class="literal">updateCursor()</code> method to update records in tables or feature classes and the <code class="literal">deleteRow()</code> method to delete a row.</p><p>The subject of data locks requires a little more explanation. The <code class="literal">insert</code> and <code class="literal">update</code> cursors must obtain a lock on the data source they reference. This means that no other application can concurrently access this data source. Locks are a way of preventing multiple users from changing data at the same time and thus, corrupting the data. When the <code class="literal">InsertCursor()</code> and <code class="literal">UpdateCursor()</code> methods are called in your code, Python attempts to acquire<a id="id443" class="indexterm"/> a lock on the data. This lock must be specifically released after the cursor has finished processing so that the running applications of other users, such as <code class="literal">ArcMap</code> or <code class="literal">ArcCatalog</code>, can access the data sources. If this isn't done, no other application will be able to access the data. Prior to ArcGIS 10.1 and the <code class="literal">with</code> statement, cursors had to be specifically unlocked through Python's <code class="literal">del</code> statement. Similarly, <code class="literal">ArcMap</code> and <code class="literal">ArcCatalog</code> also acquire data locks when updating or deleting data. If a data source has been locked by either of these applications, your Python code will not be able to access the data. Therefore, the best practice is to close <code class="literal">ArcMap</code> and <code class="literal">ArcCatalog</code> before running any standalone Python scripts that use <code class="literal">insert</code> or <code class="literal">update</code> cursors.</p><p>In this chapter, we're going to cover the use of cursors to access and edit tables and feature classes. However, many of the cursor concepts that existed before ArcGIS 10.1 still apply.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Retrieving features from a feature class with SearchCursor"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec58"/>Retrieving features from a feature class with  SearchCursor</h1></div></div></div><p>There <a id="id444" class="indexterm"/>are many occasions <a id="id445" class="indexterm"/>when you need to retrieve rows from a table or feature class for read-only purposes. For example, you might want to generate a list of all land parcels in a city with a value greater than $100,000. In this case, you don't have any need to edit the data. Your needs are met simply by generating a list of rows that meet some sort of criteria. A <code class="literal">SearchCursor</code> object contains a read-only copy of rows from a table or feature class. These objects can also be filtered through the use of a <code class="literal">where</code> clause so that only a subset of the dataset is returned.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec149"/>Getting ready</h2></div></div></div><p>The <code class="literal">SearchCursor()</code> function is used to return a <code class="literal">SearchCursor</code> object. This object can only be used to iterate a set of rows returned for read-only purposes. No insertions, deletions, or updates can occur through this object. An optional <code class="literal">where</code> clause can be set to limit the rows returned. In this recipe, you will learn how to create a basic <code class="literal">SearchCursor</code> object on a feature class through the use of the <code class="literal">SearchCursor()</code> function.</p><p>The <code class="literal">SearchCursor</code> object contains a <code class="literal">fields</code> property along with the <code class="literal">next()</code> and <code class="literal">reset()</code> methods. The <code class="literal">fields</code> property is a read-only structure in the form of a Python <span class="strong"><strong>tuple</strong></span>, containing<a id="id446" class="indexterm"/> the fields requested from the feature class or table. You <a id="id447" class="indexterm"/>are going to hear the<a id="id448" class="indexterm"/> term tuple a lot in conjunction with cursors. If you haven't covered this topic before, tuples are a Python structure to store a sequence of data similar to Python lists. However, there are some important differences between Python tuples and lists. Tuples are defined as a sequence of values inside parentheses, while lists are defined as a sequence of values inside brackets. Unlike lists, tuples can't grow and shrink, which can be a very good thing in some cases when you want data values to occupy a specific position each time. This is the case with cursor objects that use tuples to store data from fields in tables and feature classes.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec150"/>How to do it…</h2></div></div></div><p>Follow these steps to learn how to retrieve rows from a table or feature class inside a <code class="literal">SearchCursor</code> object:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open <span class="strong"><strong>IDLE</strong></span> and create a new script window.</li><li class="listitem">Save the script as <code class="literal">C:\ArcpyBook\Ch8\SearchCursor.py</code>.</li><li class="listitem">Import the <code class="literal">arcpy.da</code> module:<div class="informalexample"><pre class="programlisting">import arcpy.da</pre></div></li><li class="listitem">Set the workspace:<div class="informalexample"><pre class="programlisting">arcpy.env.workspace = "c:/ArcpyBook/Ch8"</pre></div></li><li class="listitem">Use a Python <code class="literal">with</code> statement to create a cursor:<div class="informalexample"><pre class="programlisting">with arcpy.da.SearchCursor("Schools.shp",("Facility","Name")) as cursor:</pre></div></li><li class="listitem">Loop through each row in <code class="literal">SearchCursor</code> and print the name of the school. Make sure you indent the <code class="literal">for</code> loop inside the <code class="literal">with</code> block:<div class="informalexample"><pre class="programlisting">for row in sorted(cursor):
  print("School name: " + row[1])</pre></div></li><li class="listitem">The entire script should appear as follows:<div class="informalexample"><pre class="programlisting">import arcpy.da
arcpy.env.workspace = "c:/ArcpyBook/Ch8"
with arcpy.da.SearchCursor("Schools.shp",("Facility","Name")) as cursor:
    for row in sorted(cursor):
        print("School name: " + row[1])</pre></div></li><li class="listitem">Save the script.</li><li class="listitem">You can check your work by examining the <code class="literal">C:\ArcpyBook\code\Ch8\SearchCursor_Step1.py</code> solution file.</li><li class="listitem">Run the script. You should see the following output:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>School name: ALLAN</strong></span>
<span class="strong"><strong>School name: ALLISON</strong></span>
<span class="strong"><strong>School name: ANDREWS</strong></span>
<span class="strong"><strong>School name: BARANOFF</strong></span>
<span class="strong"><strong>School name: BARRINGTON</strong></span>
<span class="strong"><strong>School name: BARTON CREEK</strong></span>
<span class="strong"><strong>School name: BARTON HILLS</strong></span>
<span class="strong"><strong>School name: BATY</strong></span>
<span class="strong"><strong>School name: BECKER</strong></span>
<span class="strong"><strong>School name: BEE CAVE</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec151"/>How it works…</h2></div></div></div><p>The <code class="literal">with</code> statement used with the <code class="literal">SearchCursor()</code> function will create, open, and close the <a id="id449" class="indexterm"/>cursor. So, you no longer<a id="id450" class="indexterm"/> have to be concerned with explicitly releasing the lock on the cursor as you did prior to ArcGIS 10.1. The first parameter passed into the <code class="literal">SearchCursor()</code> function is a feature class, represented by the <code class="literal">Schools.shp</code> file. The second parameter is a Python tuple containing a list of fields that we want returned in the cursor. For performance reasons, it is a best practice to limit the fields returned in the cursor to only those that you need to complete the task. Here, we've specified that only the <code class="literal">Facility</code> and <code class="literal">Name</code> fields should be returned. The <code class="literal">SearchCursor</code> object is stored in a variable called <code class="literal">cursor</code>.</p><p>Inside the <code class="literal">with</code> block, we use a Python <code class="literal">for</code> loop to loop through each school returned. We also use the Python <code class="literal">sorted()</code> function to sort the contents of the cursor. To access the values from a field on the row, simply use the index number of the field you want to return. In this case, we want to return the contents of the <code class="literal">Name</code> column, which will be the <code class="literal">1</code> index number, since it is the second item in the tuple of field names that are returned.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Filtering records with a where clause"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec59"/>Filtering records with a where clause</h1></div></div></div><p>By default, <code class="literal">SearchCursor</code> will contain all rows in a table or feature class. However, in many cases, you <a id="id451" class="indexterm"/>will want to restrict the number of <a id="id452" class="indexterm"/>rows returned by some sort of criteria. Applying a filter through the use of a <code class="literal">where</code> clause limits the records returned.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec152"/>Getting ready</h2></div></div></div><p>By default, all rows from a table or feature class will be returned when you create a <code class="literal">SearchCursor</code> object. However, in many cases, you will want to restrict the records returned. You can do this by creating a query and passing it as a <code class="literal">where</code> clause parameter when calling the <code class="literal">SearchCursor()</code> function. In this recipe, you'll build on the script you created in <a id="id453" class="indexterm"/>the previous recipe by adding a <code class="literal">where</code> clause <a id="id454" class="indexterm"/>that restricts the records returned.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec153"/>How to do it…</h2></div></div></div><p>Follow these steps to apply a filter to a <code class="literal">SearchCursor</code> object that restricts the rows returned from a table or feature class:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open <span class="strong"><strong>IDLE</strong></span> and load the <code class="literal">SearchCursor.py</code> script that you created in the previous recipe.</li><li class="listitem">Update the <code class="literal">SearchCursor()</code> function by adding a <code class="literal">where</code> clause that queries the facility field for records that have the <code class="literal">HIGH SCHOOL</code> text:<div class="informalexample"><pre class="programlisting">with arcpy.da.SearchCursor("Schools.shp",("Facility","Name"), '"FACILITY" = \'HIGH SCHOOL\'') as cursor:</pre></div></li><li class="listitem">You can check your work by examining the <code class="literal">C:\ArcpyBook\code\Ch8\SearchCursor_Step2.py</code> solution file.</li><li class="listitem">Save and run the script. The output will now be much smaller and restricted to high schools only:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>High school name: AKINS</strong></span>
<span class="strong"><strong>High school name: ALTERNATIVE LEARNING CENTER</strong></span>
<span class="strong"><strong>High school name: ANDERSON</strong></span>
<span class="strong"><strong>High school name: AUSTIN</strong></span>
<span class="strong"><strong>High school name: BOWIE</strong></span>
<span class="strong"><strong>High school name: CROCKETT</strong></span>
<span class="strong"><strong>High school name: DEL VALLE</strong></span>
<span class="strong"><strong>High school name: ELGIN</strong></span>
<span class="strong"><strong>High school name: GARZA</strong></span>
<span class="strong"><strong>High school name: HENDRICKSON</strong></span>
<span class="strong"><strong>High school name: JOHN B CONNALLY</strong></span>
<span class="strong"><strong>High school name: JOHNSTON</strong></span>
<span class="strong"><strong>High school name: LAGO VISTA</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec154"/>How it works…</h2></div></div></div><p>We covered the creation of queries in <a class="link" href="ch07.html" title="Chapter 7. Querying and Selecting Data">Chapter 7</a>, <span class="emphasis"><em>Querying and Selecting Data</em></span>, so hopefully you <a id="id455" class="indexterm"/>now have a good grasp of how these <a id="id456" class="indexterm"/>are created along with all the rules you need to follow when coding these structures. The <code class="literal">where</code> clause parameter accepts any valid SQL query, and is used in this case to restrict the number of records that are returned.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Improving cursor performance with geometry tokens"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec60"/>Improving cursor performance with geometry tokens</h1></div></div></div><p>
<span class="strong"><strong>Geometry tokens</strong></span>
<a id="id457" class="indexterm"/> were introduced in ArcGIS 10.1 as a performance<a id="id458" class="indexterm"/> improvement<a id="id459" class="indexterm"/> for cursors. Rather than returning the entire geometry of a feature inside the cursor, only a portion of the geometry is returned. Returning the entire geometry of a feature can result in decreased cursor performance due to the amount of data that has to be returned. It's significantly faster to return only the specific portion of the geometry that is needed.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec155"/>Getting ready</h2></div></div></div><p>A token is provided as one of the fields in the field list passed into the constructor for a cursor and is in the <code class="literal">SHAPE@&lt;Part of Feature to be Returned&gt;</code> format. The only exception to this format is the <code class="literal">OID@</code> token, which returns the object ID of the feature. The following code example retrieves only the <code class="literal">X</code> and <code class="literal">Y</code> coordinates of a feature:</p><div class="informalexample"><pre class="programlisting">with arcpy.da.SearchCursor(fc, ("SHAPE@XY","Facility","Name")) as cursor:</pre></div><p>The following table lists the available geometry tokens. Not all cursors support the full list of tokens. Check the ArcGIS help files for information about the tokens supported by each cursor type. The <code class="literal">SHAPE@</code> token returns the entire geometry of the feature. Use this carefully though, because it is an expensive operation to return the entire geometry of a feature and can dramatically affect performance. If you don't need the entire geometry, then do not include this token!</p><div class="mediaobject"><img src="images/B04314_08_8.jpg" alt="Getting ready"/></div><p>In this<a id="id460" class="indexterm"/> recipe, you will use a<a id="id461" class="indexterm"/> geometry token to increase the performance of a cursor. You'll retrieve the <code class="literal">X</code> and <code class="literal">Y</code> coordinates of each land parcel from the <code class="literal">parcels</code> feature class along with some attribute information about the parcel.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec156"/>How to do it…</h2></div></div></div><p>Follow these steps to add a geometry token to a cursor, which should improve the performance of this object:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open <span class="strong"><strong>IDLE</strong></span> and create a new script window.</li><li class="listitem">Save the script as <code class="literal">C:\ArcpyBook\Ch8\GeometryToken.py</code>.</li><li class="listitem">Import the <code class="literal">arcpy.da</code> module and the time module:<div class="informalexample"><pre class="programlisting">import arcpy.da
import time</pre></div></li><li class="listitem">Set the workspace:<div class="informalexample"><pre class="programlisting">arcpy.env.workspace = "c:/ArcpyBook/Ch8"</pre></div></li><li class="listitem">We're going to measure how long it takes to execute the code using a geometry token. Add the <code class="literal">start</code> time for the script:<div class="informalexample"><pre class="programlisting">start = time.clock()</pre></div></li><li class="listitem">Use a Python <code class="literal">with</code> statement to create a cursor that includes the centroid of each <a id="id462" class="indexterm"/>feature<a id="id463" class="indexterm"/> as well as the ownership information stored in the <code class="literal">PY_FULL_OW</code> field:<div class="informalexample"><pre class="programlisting">with arcpy.da.SearchCursor("coa_parcels.shp",("PY_FULL_OW","SHAPE@XY")) as cursor:</pre></div></li><li class="listitem">Loop through each row in <code class="literal">SearchCursor</code> and print the name of the parcel and location. Make sure you indent the <code class="literal">for</code> loop inside the <code class="literal">with</code> block:<div class="informalexample"><pre class="programlisting">for row in cursor:
  print("Parcel owner: {0} has a location of: {1}".format(row[0], row[1]))</pre></div></li><li class="listitem">Measure the elapsed time:<div class="informalexample"><pre class="programlisting">elapsed = (time.clock() - start)</pre></div></li><li class="listitem">Print the execution time:<div class="informalexample"><pre class="programlisting">print("Execution time: " + str(elapsed))</pre></div></li><li class="listitem">The entire script should appear as follows:<div class="informalexample"><pre class="programlisting">import arcpy.da
import time
arcpy.env.workspace = "c:/ArcpyBook/Ch9"
start = time.clock()
with arcpy.da.SearchCursor("coa_parcels.shp",("PY_FULL_OW", "SHAPE@XY")) as cursor:
    for row in cursor:
        print("Parcel owner: {0} has a location of: {1}".format(row[0], row[1]))
elapsed = (time.clock() - start)
print("Execution time: " + str(elapsed))</pre></div></li><li class="listitem">You can check your work by examining the <code class="literal">C:\ArcpyBook\code\Ch8\GeometryToken.py</code> solution file.</li><li class="listitem">Save the script.</li><li class="listitem">Run the script. You should see something similar to the following output. Note the execution time; your time will vary:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Parcel owner: CITY OF AUSTIN ATTN REAL ESTATE DIVISION has a location of: (3110480.5197341456, 10070911.174956793)</strong></span>
<span class="strong"><strong>Parcel owner: CITY OF AUSTIN ATTN REAL ESTATE DIVISION has a location of: (3110670.413783513, 10070800.960865)</strong></span>
<span class="strong"><strong>Parcel owner: CITY OF AUSTIN has a location of: (3143925.0013213265, 10029388.97419636)</strong></span>
<span class="strong"><strong>Parcel owner: CITY OF AUSTIN % DOROTHY NELL ANDERSON ATTN BARRY LEE ANDERSON has a location of: (3134432.983822767, 10072192.047894118)</strong></span>
<span class="strong"><strong>Execution time: 9.08046185109</strong></span>
</pre></div></li></ol></div><p>Now, we're<a id="id464" class="indexterm"/> going to measure the <a id="id465" class="indexterm"/>execution time if the entire geometry is returned instead of just the portion of the geometry that we need:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Save a new copy of the script as <code class="literal">C:\ArcpyBook\Ch8\GeometryTokenEntireGeometry.py</code>.</li><li class="listitem">Change the <code class="literal">SearchCursor()</code> function to return the entire geometry using <code class="literal">SHAPE@</code> instead of <code class="literal">SHAPE@XY</code>:<div class="informalexample"><pre class="programlisting">with arcpy.da.SearchCursor("coa_parcels.shp",("PY_FULL_OW", "SHAPE@")) as cursor:</pre></div></li><li class="listitem">You can check your work by examining the <code class="literal">C:\ArcpyBook\code\Ch8\GeometryTokenEntireGeometry.py</code> solution file.</li><li class="listitem">Save and run the script. You should see the following output. Your time will vary from mine, but notice that the execution time is slower. In this case, it's only a little over a second slower, but we're only returning 2600 features. If the feature class were significantly larger, as many are, this would be amplified:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Parcel owner: CITY OF AUSTIN ATTN REAL ESTATE DIVISION has a location of: &lt;geoprocessing describe geometry object object at 0x06B9BE00&gt;</strong></span>
<span class="strong"><strong>Parcel owner: CITY OF AUSTIN ATTN REAL ESTATE DIVISION has a location of: &lt;geoprocessing describe geometry object object at 0x2400A700&gt;</strong></span>
<span class="strong"><strong>Parcel owner: CITY OF AUSTIN has a location of: &lt;geoprocessing describe geometry object object at 0x06B9BE00&gt;</strong></span>
<span class="strong"><strong>Parcel owner: CITY OF AUSTIN % DOROTHY NELL ANDERSON ATTN BARRY LEE ANDERSON has a location of: &lt;geoprocessing describe geometry object object at 0x2400A700&gt;</strong></span>
<span class="strong"><strong>Execution time: 10.1211390896</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec157"/>How it works…</h2></div></div></div><p>A geometry token can be supplied as one of the field names supplied in the constructor for the cursor. These tokens are used to increase the performance of a cursor by returning only a portion of the geometry instead of the entire geometry. This can dramatically increase the performance of a cursor, particularly when you are working with large polyline <a id="id466" class="indexterm"/>or polygon datasets. If <a id="id467" class="indexterm"/>you only need specific properties of the geometry in your cursor, you should use these tokens.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Inserting rows with InsertCursor"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec61"/>Inserting rows with InsertCursor</h1></div></div></div><p>You can insert a row into a table or feature class using an <code class="literal">InsertCursor</code> object. If you want to<a id="id468" class="indexterm"/> insert attribute values along with the new <a id="id469" class="indexterm"/>row, you'll need to supply the values in the order found in the attribute table.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec158"/>Getting ready</h2></div></div></div><p>The <code class="literal">InsertCursor()</code> function is used to create an <code class="literal">InsertCursor</code> object that allows you to programmatically add new records to feature classes and tables. The <code class="literal">insertRow()</code> method on the <code class="literal">InsertCursor</code> object adds the row. A row in the form of a list or tuple is passed into the <code class="literal">insertRow()</code> method. The values in the list must correspond to the field values defined when the <code class="literal">InsertCursor</code> object was created. Similar to instances that include other types of cursors, you can also limit the field names returned using the second parameter of the method. This function supports geometry tokens as well.</p><p>The following code example illustrates how you can use <code class="literal">InsertCursor</code> to insert new rows into a feature class. Here, we insert two new wildfire points into the <code class="literal">California</code> feature class. The row values to be inserted are defined in a <code class="literal">list</code> variable. Then, an <code class="literal">InsertCursor</code> object is created, passing in the feature class and fields. Finally, the new rows are inserted into the feature class by using the <code class="literal">insertRow()</code> method:</p><div class="informalexample"><pre class="programlisting">rowValues = [(Bastrop','N',3000,(-105.345,32.234)), ('Ft Davis','N', 456, (-109.456,33.468))]
fc = "c:/data/wildfires.gdb/California"
fields = ["FIRE_NAME", "FIRE_CONTAINED", "ACRES", "SHAPE@XY"]
with arcpy.da.InsertCursor(fc, fields) as cursor:
  for row in rowValues:
    cursor.insertRow(row)</pre></div><p>In this recipe, you will use <code class="literal">InsertCursor</code> to add wildfires retrieved from a <code class="literal">.txt</code> file into a point feature class. When inserting rows into a feature class, you will need to know how to add the geometric representation of a feature into the feature class. This can be accomplished by using <code class="literal">InsertCursor</code> along with two miscellaneous objects: <code class="literal">Array</code> and <code class="literal">Point</code>. In this exercise, we will add point features in the form of wildfire incidents to an empty point feature class. In addition to this, you will use Python file manipulation techniques to read the coordinate data from a text file.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec159"/>How to do it…</h2></div></div></div><p>We will be importing the North American wildland fire incident data from a single day in October, 2007. This data is contained in a comma-delimited text file containing one line for <a id="id470" class="indexterm"/>each fire incident on this particular day. Each fire <a id="id471" class="indexterm"/>incident has a latitude, longitude coordinate pair separated by commas along with a confidence value. This data was derived by automated methods that use remote sensing data to derive the presence or absence of a wildfire. Confidence values can range from 0 to 100. Higher numbers represent a greater confidence that this is indeed a wildfire:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the file at <code class="literal">C:\ArcpyBook\Ch8\Wildfire Data\NorthAmericaWildfire_2007275.txt</code> and examine the contents. <p>You will notice that this is a simple comma-delimited text file containing the longitude and latitude values for each fire along with a confidence value. We will use Python to read the contents of this file line by line and insert new point features into the <code class="literal">FireIncidents</code> feature class located in the <code class="literal">C:\ArcpyBook\Ch8 \WildfireData\WildlandFires.mdb</code> personal geodatabase.</p></li><li class="listitem">Close the file.</li><li class="listitem">Open <code class="literal">ArcCatalog</code>.</li><li class="listitem">Navigate to <code class="literal">C:\ArcpyBook\Ch8\WildfireData</code>.<p>You should see a personal geodatabase called <code class="literal">WildlandFires</code>. Open this geodatabase and you will see a point feature class called <code class="literal">FireIncidents</code>. Right now, this is an empty feature class. We will add features by reading the text file you examined earlier and inserting points.</p></li><li class="listitem">Right-click on <code class="literal">FireIncidents</code> and select <span class="strong"><strong>Properties</strong></span>.</li><li class="listitem">Click on the <span class="strong"><strong>Fields</strong></span> tab.<p>The latitude/longitude values found in the file we examined earlier will be imported into the <code class="literal">SHAPE</code> field and the confidence values will be written to the <code class="literal">CONFIDENCEVALUE</code> field.</p></li><li class="listitem">Open <span class="strong"><strong>IDLE</strong></span> and create a new script.</li><li class="listitem">Save the script to <code class="literal">C:\ArcpyBook\Ch8\InsertWildfires.py</code>.</li><li class="listitem">Import the <code class="literal">arcpy</code> modules:<div class="informalexample"><pre class="programlisting">import arcpy</pre></div></li><li class="listitem">Set the workspace:<div class="informalexample"><pre class="programlisting">arcpy.env.workspace = "C:/ArcpyBook/Ch8/WildfireData/WildlandFires.mdb"</pre></div></li><li class="listitem">Open the text file and read all the lines into a list:<div class="informalexample"><pre class="programlisting">f = open("C:/ArcpyBook/Ch8/WildfireData/NorthAmericaWildfires_2007275.txt","r")
lstFires = f.readlines()</pre></div></li><li class="listitem">Start<a id="id472" class="indexterm"/> a <code class="literal">try</code> block:<div class="informalexample"><pre class="programlisting">try:</pre></div></li><li class="listitem">Create <a id="id473" class="indexterm"/>an <code class="literal">InsertCursor</code> object using a <code class="literal">with</code> block. Make sure you indent inside the <code class="literal">try</code> statement. The cursor will be created in the <code class="literal">FireIncidents</code> feature class:<div class="informalexample"><pre class="programlisting">with arcpy.da.InsertCursor("FireIncidents",("SHAPE@XY","CONFIDENCEVALUE")) as cur:</pre></div></li><li class="listitem">Create a counter variable that will be used to print the progress of the script:<div class="informalexample"><pre class="programlisting">cntr = 1</pre></div></li><li class="listitem">Loop through the text file line by line using a <code class="literal">for</code> loop. Since the text file is comma-delimited, we'll use the Python <code class="literal">split()</code> function to separate each value into a list variable called <code class="literal">vals</code>. We'll then pull out the individual latitude, longitude, and confidence value items and assign them to variables. Finally, we'll place these values into a list variable called <code class="literal">rowValue</code>, which is then passed into the <code class="literal">insertRow()</code> function for the <code class="literal">InsertCursor</code> object, and we then print a message:<div class="informalexample"><pre class="programlisting">for fire in lstFires:
      if 'Latitude' in fire:
        continue
      vals = fire.split(",")
      latitude = float(vals[0])
      longitude = float(vals[1])
      confid = int(vals[2])
      rowValue = [(longitude,latitude),confid]
      cur.insertRow(rowValue)
      print("Record number " + str(cntr) + " written to feature class")
      #arcpy.AddMessage("Record number" + str(cntr) + " written to feature class")
      cntr = cntr + 1</pre></div></li><li class="listitem">Add the <code class="literal">except</code> block to print any errors that may occur:<div class="informalexample"><pre class="programlisting">except Exception as e:
  print(e.message)</pre></div></li><li class="listitem">Add a <code class="literal">finally</code> block to close the text file:<div class="informalexample"><pre class="programlisting">finally:
  f.close()</pre></div></li><li class="listitem">The<a id="id474" class="indexterm"/> entire <a id="id475" class="indexterm"/>script should appear as follows:<div class="informalexample"><pre class="programlisting">import arcpy

arcpy.env.workspace = "C:/ArcpyBook/Ch8/WildfireData/WildlandFires.mdb"
f = open("C:/ArcpyBook/Ch8/WildfireData/NorthAmericaWildfires_2007275.txt","r")
lstFires = f.readlines()
try:
  with arcpy.da.InsertCursor("FireIncidents", ("SHAPE@XY","CONFIDENCEVALUE")) as cur:
    cntr = 1
    for fire in lstFires:
      if 'Latitude' in fire:
        continue
      vals = fire.split(",")
      latitude = float(vals[0])
      longitude = float(vals[1])
      confid = int(vals[2])
      rowValue = [(longitude,latitude),confid]
      cur.insertRow(rowValue)
      print("Record number " + str(cntr) + " written to feature class")
      #arcpy.AddMessage("Record number" + str(cntr) + " written to feature class")
      cntr = cntr + 1
except Exception as e:
  print(e.message)
finally:
  f.close()</pre></div></li><li class="listitem">You can check your work by examining the <code class="literal">C:\ArcpyBook\code\Ch8\InsertWildfires.py</code> solution file.</li><li class="listitem">Save and run the script. You should see messages being written to the output window as the script runs:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Record number: 406 written to feature class</strong></span>
<span class="strong"><strong>Record number: 407 written to feature class</strong></span>
<span class="strong"><strong>Record number: 408 written to feature class</strong></span>
<span class="strong"><strong>Record number: 409 written to feature class</strong></span>
<span class="strong"><strong>Record number: 410 written to feature class</strong></span>
<span class="strong"><strong>Record number: 411 written to feature class</strong></span>
</pre></div></li><li class="listitem">Open <a id="id476" class="indexterm"/><span class="strong"><strong>ArcMap</strong></span> and add the <code class="literal">FireIncidents</code> feature class to the table of contents. The points should be visible, as <a id="id477" class="indexterm"/>shown in the following screenshot:<div class="mediaobject"><img src="images/B04314_08_3.jpg" alt="How to do it…"/></div></li><li class="listitem">You may want to add a basemap to provide some reference for the data. In ArcMap, click on the <span class="strong"><strong>Add Basemap</strong></span> button and select a basemap from the gallery.</li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec160"/>How it works…</h2></div></div></div><p>Some additional explanation may be needed here. The <code class="literal">lstFires</code> variable contains a list of all the wildfires that were contained in the comma-delimited text file. The <code class="literal">for</code> loop will loop through each of these records one by one, inserting each individual record into the <code class="literal">fire</code> variable. We also include an <code class="literal">if</code> statement that is used to skip the first record in the file, which serves as the header. As I explained earlier, we then pull out the individual latitude, longitude, and confidence value items from the <code class="literal">vals</code> variable, which is just a Python list<a id="id478" class="indexterm"/> object and assign them to variables called <code class="literal">latitude</code>, <code class="literal">longitude</code>, and <code class="literal">confid</code>. We then place these values into a new list variable <a id="id479" class="indexterm"/>called <code class="literal">rowValue</code> in the order that we defined when we created <code class="literal">InsertCursor</code>. Thus, the latitude and longitude pair should be placed first followed by the confidence value. Finally, we call the <code class="literal">insertRow()</code> function on the <code class="literal">InsertCursor</code> object assigned to the <code class="literal">cur</code> variable, passing in the new <code class="literal">rowValue</code> variable. We close by printing a message that indicates the progress of the script and also create the <code class="literal">except</code> and <code class="literal">finally</code> blocks to handle errors and close the text file. Placing the <code class="literal">file.close()</code> method in the <code class="literal">finally</code> block ensures that it will execute and close the file even if there is an error in the previous <code class="literal">try</code> statement.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Updating rows with UpdateCursor"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec62"/>Updating rows with UpdateCursor</h1></div></div></div><p>If you need to edit or delete rows from a table or feature class, you can use <code class="literal">UpdateCursor</code>. As is the case with <code class="literal">InsertCursor</code>, the contents of <code class="literal">UpdateCursor</code> can be limited <a id="id480" class="indexterm"/>through the use of a <code class="literal">where</code> clause.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec161"/>Getting ready</h2></div></div></div><p>The <code class="literal">UpdateCursor()</code> function can be used to either update or delete rows in a table or feature class. The<a id="id481" class="indexterm"/> returned cursor places a lock on the data, which will automatically be released if used inside a Python <code class="literal">with</code> statement. An <code class="literal">UpdateCursor</code> object is returned from a call to this method.</p><p>The <code class="literal">UpdateCursor</code> object places a lock on the data while it's being edited or deleted. If the cursor is used inside a Python <code class="literal">with</code> statement, the lock will automatically be freed after the data has been processed. This hasn't always been the case. Previous versions of cursors were required to be manually released using the Python <code class="literal">del</code> statement. Once an instance of <code class="literal">UpdateCursor</code> has been obtained, you can then call the <code class="literal">updateCursor()</code> method to update records in tables or feature classes and the <code class="literal">deleteRow()</code> method can be used to delete a row.</p><p>In this recipe, you're going to write a script that updates each feature in the <code class="literal">FireIncidents</code> feature class by assigning a value of <code class="literal">poor</code>, <code class="literal">fair</code>, <code class="literal">good</code>, or <code class="literal">excellent</code> to a new field that is more descriptive of the confidence values using an <code class="literal">UpdateCursor</code>. Prior to updating the records, your script will add the <code class="literal">new</code> field to the <code class="literal">FireIncidents</code> feature class.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec162"/>How to do it…</h2></div></div></div><p>Follow these steps to create an <code class="literal">UpdateCursor</code> object that will be used to edit rows in a feature class:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open <span class="strong"><strong>IDLE</strong></span> and create a new script.</li><li class="listitem">Save<a id="id482" class="indexterm"/> the script to <code class="literal">C:\ArcpyBook\Ch8\UpdateWildfires.py</code>.</li><li class="listitem">Import<a id="id483" class="indexterm"/> the <code class="literal">arcpy</code> module:<div class="informalexample"><pre class="programlisting">import arcpy</pre></div></li><li class="listitem">Set the workspace:<div class="informalexample"><pre class="programlisting">arcpy.env.workspace = "C:/ArcpyBook/Ch8/WildfireData/WildlandFires.mdb"</pre></div></li><li class="listitem">Start a <code class="literal">try</code> block:<div class="informalexample"><pre class="programlisting">try:</pre></div></li><li class="listitem">Add a new field called <code class="literal">CONFID_RATING</code> to the <code class="literal">FireIncidents</code> feature class. Make sure to indent inside the <code class="literal">try</code> statement:<div class="informalexample"><pre class="programlisting">arcpy.AddField_management("FireIncidents","CONFID_RATING", "TEXT","10")
print("CONFID_RATING field added to FireIncidents")</pre></div></li><li class="listitem">Create a new instance of <code class="literal">UpdateCursor</code> inside a <code class="literal">with</code> block:<div class="informalexample"><pre class="programlisting">with arcpy.da.UpdateCursor("FireIncidents", ("CONFIDENCEVALUE","CONFID_RATING")) as cursor:</pre></div></li><li class="listitem">Create a counter variable that will be used to print the progress of the script. Make sure you indent this line of code and all the lines of code that follow inside the <code class="literal">with</code> block:<div class="informalexample"><pre class="programlisting">cntr = 1</pre></div></li><li class="listitem">Loop through each of the rows in the <code class="literal">FireIncidents</code> fire class. Update the <code class="literal">CONFID_RATING</code> field according to the following guidelines: <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Confidence value 0 to 40 = <code class="literal">POOR</code></li><li class="listitem" style="list-style-type: disc">Confidence value 41 to 60 = <code class="literal">FAIR</code></li><li class="listitem" style="list-style-type: disc">Confidence value 61 to 85 = <code class="literal">GOOD</code></li><li class="listitem" style="list-style-type: disc">Confidence value 86 to 100 = <code class="literal">EXCELLENT</code></li></ul></div><p>This can be translated in the following block of code:</p><div class="informalexample"><pre class="programlisting">    for row in cursor:
      # update the confid_rating field
      if row[0] &lt;= 40:
        row[1] = 'POOR'
      elif row[0] &gt; 40 and row[0] &lt;= 60:
        row[1] = 'FAIR'
      elif row[0] &gt; 60 and row[0] &lt;= 85:
        row[1] = 'GOOD'
      else:
        row[1] = 'EXCELLENT'
      cursor.updateRow(row)			
      print("Record number " + str(cntr) + " updated")
      cntr = cntr + 1</pre></div></li><li class="listitem">Add the <code class="literal">except</code> block to print any errors that may occur:<div class="informalexample"><pre class="programlisting">except Exception as e:
  print(e.message)</pre></div></li><li class="listitem">The <a id="id484" class="indexterm"/>entire <a id="id485" class="indexterm"/>script should appear as follows:<div class="informalexample"><pre class="programlisting">import arcpy

arcpy.env.workspace = "C:/ArcpyBook/Ch8/WildfireData/WildlandFires.mdb"
try:
  #create a new field to hold the values
  arcpy.AddField_management("FireIncidents", "CONFID_RATING","TEXT","10")
  print("CONFID_RATING field added to FireIncidents")
  with arcpy.da.UpdateCursor("FireIncidents",("CONFIDENCEVALUE", "CONFID_RATING")) as cursor:
    cntr = 1
    for row in cursor:
      # update the confid_rating field
      if row[0] &lt;= 40:
        row[1] = 'POOR'
      elif row[0] &gt; 40 and row[0] &lt;= 60:
        row[1] = 'FAIR'
      elif row[0] &gt; 60 and row[0] &lt;= 85:
        row[1] = 'GOOD'
      else:
        row[1] = 'EXCELLENT'
      cursor.updateRow(row)			
      print("Record number " + str(cntr) + " updated")
      cntr = cntr + 1
except Exception as e:
  print(e.message)</pre></div></li><li class="listitem">You can check your work by examining the <code class="literal">C:\ArcpyBook\code\Ch8\UpdateWildfires.py</code> solution file.</li><li class="listitem">Save and run the script. You should see messages being written to the output window as the script runs:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Record number 406 updated</strong></span>
<span class="strong"><strong>Record number 407 updated</strong></span>
<span class="strong"><strong>Record number 408 updated</strong></span>
<span class="strong"><strong>Record number 409 updated</strong></span>
<span class="strong"><strong>Record number 410 updated</strong></span>
</pre></div></li><li class="listitem">Open <span class="strong"><strong>ArcMap</strong></span> and add the <code class="literal">FireIncidents</code> feature class. Open the attribute table <a id="id486" class="indexterm"/>and you should see that a new <code class="literal">CONFID_RATING</code> field <a id="id487" class="indexterm"/>has been added and populated by <code class="literal">UpdateCursor</code>:<div class="mediaobject"><img src="images/B04314_08_4.jpg" alt="How to do it…"/></div></li></ol></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>When you insert, update, or delete data in cursors, the changes are permanent and can't be undone if you're working outside an edit session. However, with the new edit session functionality provided by ArcGIS 10.1, you can now make these changes inside an edit session to avoid these problems. We'll cover edit sessions soon.</p></div></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec163"/>How it works…</h2></div></div></div><p>In this case, we've used <code class="literal">UpdateCursor</code> to update each of the features in a feature class. We first used the <code class="literal">Add Field</code> tool to add a new field called <code class="literal">CONFID_RATING</code>, which will hold new values that we assign based on values found in another field. The groups are poor, fair, good, and excellent and are based on numeric values found in the <code class="literal">CONFIDENCEVALUE</code> field. We then created a new instance of <code class="literal">UpdateCursor</code> based on the <code class="literal">FireIncidents</code> feature class, and returned the two fields mentioned previously. The script then loops through each of the features and assigns a value of poor, fair, good, or excellent to the <code class="literal">CONFID_RATING</code> field (<code class="literal">row[1]</code>), based on the numeric value found in <code class="literal">CONFIDENCEVALUE</code>. A Python <code class="literal">if</code>/<code class="literal">elif</code>/<code class="literal">else</code> structure is used to control the flow of the script based on the numeric value. The value for <code class="literal">CONFID_RATING</code> is then committed to the <a id="id488" class="indexterm"/>feature class by passing the row variable into <a id="id489" class="indexterm"/>the <code class="literal">updateRow</code>() method.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Deleting rows with UpdateCursor"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec63"/>Deleting rows with UpdateCursor</h1></div></div></div><p>In addition to being used to edit rows in a table or feature class, <code class="literal">UpdateCursor</code> can also be used to <a id="id490" class="indexterm"/>delete rows. Keep in mind that when rows are <a id="id491" class="indexterm"/>deleted outside an edit session, the changes are permanent.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec164"/>Getting ready</h2></div></div></div><p>In addition to updating records, <code class="literal">UpdateCursor</code> can also delete records from a table or feature class. The <code class="literal">UpdateCursor</code> object is created in the same way in either case, but instead of calling <code class="literal">updateRow()</code>, you call <code class="literal">deleteRow()</code> to delete a record. You can also apply a <code class="literal">where</code> clause to <code class="literal">UpdateCursor</code>, to limit the records returned. In this recipe, we'll use an <code class="literal">UpdateCursor</code> object that has been filtered using a <code class="literal">where</code> clause to delete records from our <code class="literal">FireIncidents</code> feature class.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec165"/>How to do it…</h2></div></div></div><p>Follow these steps to create an <code class="literal">UpdateCursor</code> object that will be used to delete rows from a feature class:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open <span class="strong"><strong>IDLE</strong></span> and create a new script.</li><li class="listitem">Save the script to <code class="literal">C:\ArcpyBook\Ch8\DeleteWildfires.py</code>.</li><li class="listitem">Import the <code class="literal">arcpy</code> and <code class="literal">os</code> modules:<div class="informalexample"><pre class="programlisting">import arcpy
import os</pre></div></li><li class="listitem">Set the workspace:<div class="informalexample"><pre class="programlisting">arcpy.env.workspace = "C:/ArcpyBook/Ch8/WildfireData/WildlandFires.mdb"</pre></div></li><li class="listitem">Start a <code class="literal">try</code> block:<div class="informalexample"><pre class="programlisting">try:</pre></div></li><li class="listitem">Create a new instance of <code class="literal">UpdateCursor</code> inside a <code class="literal">with</code> block. Make sure you indent inside the <code class="literal">try</code> statement:<div class="informalexample"><pre class="programlisting">with arcpy.da.UpdateCursor("FireIncidents",("CONFID_RATING"), '[CONFID_RATING] = \'POOR\'') as cursor:</pre></div></li><li class="listitem">Create a counter variable that will be used to print the progress of the script. Make sure you indent this line of code and all the lines of code that follow inside the <code class="literal">with</code> block:<div class="informalexample"><pre class="programlisting">cntr = 1</pre></div></li><li class="listitem">Delete <a id="id492" class="indexterm"/>the returned rows by calling the <code class="literal">deleteRow()</code> method. This is done by looping through the returned cursor and<a id="id493" class="indexterm"/> deleting the rows one at a time:<div class="informalexample"><pre class="programlisting">for row in cursor:
  cursor.deleteRow()
  print("Record number " + str(cntr) + " deleted")
  cntr = cntr + 1</pre></div></li><li class="listitem">Add the <code class="literal">except</code> block to print any errors that may occur:<div class="informalexample"><pre class="programlisting">except Exception as e:
  print(e.message)</pre></div></li><li class="listitem">The entire script should appear as follows:<div class="informalexample"><pre class="programlisting">import arcpy
import os

arcpy.env.workspace = "C:/ArcpyBook/Ch8/WildfireData/WildlandFires.mdb"
try:
  with arcpy.da.UpdateCursor("FireIncidents",("CONFID_RATING"), '[CONFID_RATING] = \'POOR\'') as cursor:
    cntr = 1
    for row in cursor:
      cursor.deleteRow()
      print("Record number " + str(cntr) + " deleted")
      cntr = cntr + 1
except Exception as e:
  print(e.message)</pre></div></li><li class="listitem">You can check your work by examining the <code class="literal">C:\ArcpyBook\code\Ch8\DeleteWildfires.py</code> solution file.</li><li class="listitem">Save and run the script. You should see messages being written to the output window as the script runs. 37 records should be deleted from the <code class="literal">FireIncidents</code> feature class:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Record number 1 deleted</strong></span>
<span class="strong"><strong>Record number 2 deleted</strong></span>
<span class="strong"><strong>Record number 3 deleted</strong></span>
<span class="strong"><strong>Record number 4 deleted</strong></span>
<span class="strong"><strong>Record number 5 deleted</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec166"/>How it works…</h2></div></div></div><p>Rows from<a id="id494" class="indexterm"/> feature classes and tables can be deleted using<a id="id495" class="indexterm"/> the <code class="literal">deleteRow()</code> method in <code class="literal">UpdateCursor</code>. In this recipe, we used a <code class="literal">where</code> clause in the constructor of <code class="literal">UpdateCursor</code> to limit the records returned to only features that included <code class="literal">CONFID_RATING</code> of <code class="literal">POOR</code>. We then looped through the features returned in the cursor and called the <code class="literal">deleteRow()</code> method to delete the row from the feature class.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Inserting and updating rows inside an edit session"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec64"/>Inserting and updating rows inside an edit session</h1></div></div></div><p>As I've mentioned throughout the chapter, inserts, updates, or deletes made to a table or feature <a id="id496" class="indexterm"/>class done outside an edit session are permanent. They<a id="id497" class="indexterm"/> can't be undone. Edit sessions<a id="id498" class="indexterm"/> give you much more flexibility to roll back any unwanted <a id="id499" class="indexterm"/>changes.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec167"/>Getting ready</h2></div></div></div><p>Up until now, we've used insert and update cursors to add, edit, and delete data from feature classes and tables. These changes are permanent as soon as the script is executed and can't be undone. The new <code class="literal">Editor</code> class in the data access module supports the ability to create edit sessions and operations. With edit sessions, changes applied to feature classes or tables are temporary until permanently applied with a specific method call. This is the same functionality provided by the <code class="literal">Edit</code> toolbar in ArcGIS for Desktop.</p><p>Edit sessions begin with a call to <code class="literal">Editor.startEditing()</code>, which initiates the session. Inside the session, you then start an operation with the <code class="literal">Editor.startOperation()</code> method. Within this operation, you then perform various operations that perform edits on your data. These edits can also be subject to undo, redo, and abort operations to roll back, roll forward, and abort your editing operations. After the operations have been completed, you then call the <code class="literal">Editor.stopOperation()</code> method followed by <code class="literal">Editor.stopEditing()</code>. Sessions can be ended without saving changes. In this event, changes are not permanently applied. An overview of this process is provided in the following screenshot:</p><div class="mediaobject"><img src="images/B04314_08_5.jpg" alt="Getting ready"/></div><p>Edit sessions<a id="id500" class="indexterm"/> can also be ended without saving changes. In <a id="id501" class="indexterm"/>this event, changes are not permanently applied. Edit <a id="id502" class="indexterm"/>sessions also allow for operations to be applied inside the <a id="id503" class="indexterm"/>session and then either applied permanently to the database or rolled back. Additionally, the <code class="literal">Editor</code> class also supports undo and redo operations.</p><p>The following code example shows the full edit session stack, including the creation of the <code class="literal">Editor</code> object, the beginning of an edit session and an operation, edits to the data (an insert operation in this case), stopping the operation, and finally, the end of the edit session by saving the data:</p><div class="informalexample"><pre class="programlisting">edit = arcpy.da.Editor('Database Connections/Portland.sde')
edit.startEditing(False)
edit.startOperation()
with arcpy.da.InsertCursor("Portland.jgp.schools",("SHAPE","Name")) as cursor:
  cursor.insertRow([(7642471.100, 686465.725), 'New School'])
edit.stopOperation()
edit.stopEditing(True)</pre></div><p>The <code class="literal">Editor</code> class can be used with personal, file, and ArcSDE geodatabases. Also, sessions can also be started and stopped on versioned databases. You are limited to editing only a single workspace at a time, and this workspace is specified in the constructor of the <code class="literal">Editor</code> object simply by passing in a string that references the workspace. Once created, this <code class="literal">Editor</code> object then has access to all the methods to start, stop, and abort operations as well as perform undo and redo operations.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec168"/>How to do it…</h2></div></div></div><p>Follow <a id="id504" class="indexterm"/>these steps to wrap <code class="literal">UpdateCursor</code> inside an <a id="id505" class="indexterm"/>edit session:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open <span class="strong"><strong>IDLE</strong></span>.</li><li class="listitem">Open<a id="id506" class="indexterm"/> the <code class="literal">C:\ArcpyBook\Ch8\UpdateWildfires.py</code> script and save it to a new script <a id="id507" class="indexterm"/>called <code class="literal">C:\ArcpyBook\Ch8\EditSessionUpdateWildfires.py</code>.</li><li class="listitem">We're going to make several alterations to this existing script that updates values in the <code class="literal">CONFID_RATING</code> field.</li><li class="listitem">Remove the following lines of code:<div class="informalexample"><pre class="programlisting">arcpy.AddField_management("FireIncidents","CONFID_RATING", "TEXT","10")
print("CONFID_RATING field added to FireIncidents")</pre></div></li><li class="listitem">Create an instance of the <code class="literal">Editor</code> class and start an edit session. These lines of code should be placed inside the <code class="literal">try</code> block:<div class="informalexample"><pre class="programlisting">edit = arcpy.da.Editor(r'C:\ArcpyBook\Ch8\WildfireData\WildlandFires.mdb')
edit.startEditing(True)</pre></div></li><li class="listitem">Alter the <code class="literal">if</code> statement so that it appears as follows:<div class="informalexample"><pre class="programlisting">if row[0] &gt; 40 and row[0] &lt;= 60:
  row[1] = 'GOOD'
elif row[0] &gt; 60 and row[0] &lt;= 85:
  row[1] = 'BETTER'
else:
  row[1] = 'BEST'</pre></div></li><li class="listitem">End the edit session and save the edits. Place this line of code just below the counter increment:<div class="informalexample"><pre class="programlisting">edit.stopEditing(True)</pre></div></li><li class="listitem">The entire script should appear as follows:<div class="informalexample"><pre class="programlisting">import arcpy
import os

arcpy.env.workspace = "C:/ArcpyBook/Ch8/WildfireData/WildlandFires.mdb"
try:
  edit = arcpy.da.Editor(r'C:\ArcpyBook\Ch8\WildfireData\WildlandFires.mdb')
  edit.startEditing(True)
  with arcpy.da.UpdateCursor("FireIncidents",("CONFIDENCEVALUE", "CONFID_RATING")) as cursor:
    cntr = 1
    for row in cursor:
      # update the confid_rating field
      if row[0] &gt; 40 and row[0] &lt;= 60:
        row[1] = 'GOOD'
      elif row[0] &gt; 60 and row[0] &lt;= 85:
        row[1] = 'BETTER'
      else:
        row[1] = 'BEST'
      cursor.updateRow(row)
      print("Record number " + str(cntr) + " updated")
      cntr = cntr + 1
  edit.stopEditing(True)
except Exception as e:
  print(e.message)</pre></div></li><li class="listitem">You can check your work by examining the <code class="literal">C:\ArcpyBook\code\Ch8\EditSessionUpdateWildfires.py</code> solution file.</li><li class="listitem">Save and run the script to update 374 records.</li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec169"/>How it works…</h2></div></div></div><p>Edit <a id="id508" class="indexterm"/>operations should take place inside an edit<a id="id509" class="indexterm"/> session, which can be initiated with the <code class="literal">Editor.startEditing()</code> method. The <code class="literal">startEditing()</code> method takes two optional parameters<a id="id510" class="indexterm"/> including <code class="literal">with_undo</code> and <code class="literal">multiuser_mode</code>. The <code class="literal">with_undo</code> parameter accepts a Boolean value of <code class="literal">true</code> or <code class="literal">false</code>, with a default<a id="id511" class="indexterm"/> of <code class="literal">true</code>. This creates an undo/redo stack when set to <code class="literal">true</code>. The <code class="literal">multiuser_mode</code> parameter defaults to <code class="literal">true</code>. When it's <code class="literal">false</code>, you have full control of editing a nonversioned or versioned dataset. If your dataset is nonversioned and you use <code class="literal">stopEditing(False)</code>, your edit will not be committed. Otherwise, if set to <code class="literal">true</code>, your edits will be committed. The <code class="literal">Editor.stopEditing()</code> method takes a single Boolean value of <code class="literal">true</code> or <code class="literal">false</code>, indicating whether changes should be saved or not. This defaults to <code class="literal">true</code>.</p><p>The <code class="literal">Editor</code> class supports undo and redo operations. We'll first look at undo operations. During an edit session, various edit operations can be applied. In the event that you need to undo a <a id="id512" class="indexterm"/>previous operation, a call to <code class="literal">Editor.undoOperation()</code> will remove the most recent edit operation in the stack. This is<a id="id513" class="indexterm"/> illustrated as follows:</p><div class="mediaobject"><img src="images/B04314_08_6.jpg" alt="How it works…"/></div><p>Redo <a id="id514" class="indexterm"/>operations, initiated by the <code class="literal">Editor.redoOperation()</code> method, will<a id="id515" class="indexterm"/> redo an operation that was previously undone. This is illustrated as follows:</p><div class="mediaobject"><img src="images/B04314_08_7.jpg" alt="How it works…"/></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Reading geometry from a feature class"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec65"/>Reading geometry from a feature class</h1></div></div></div><p>There may <a id="id516" class="indexterm"/>be times when you need to retrieve the <a id="id517" class="indexterm"/>geometric definition of features in a feature class. ArcPy provides the ability to read this information through various objects.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec170"/>Getting ready</h2></div></div></div><p>In ArcPy, feature classes have associated geometry objects, including <code class="literal">Polygon</code>, <code class="literal">Polyline</code>, <code class="literal">PointGeometry</code>, or <code class="literal">MultiPoint</code> that you can access from your cursors. These objects refer to the <code class="literal">shape</code> field in the <code class="literal">table</code> attribute of a feature class. You can read the geometries of each feature in a feature class through these objects.</p><p>Polyline and polygon feature classes are composed of features containing multiple parts. You can use the <code class="literal">partCount</code> property to return the number of parts per feature and then use <code class="literal">getPart()</code> for each part in the feature to loop through each of the points and pull out the coordinate information. Point feature classes are composed of one <code class="literal">PointGeometry</code> object per feature that contains the coordinate information for each point.</p><p>In this recipe, you will use the <code class="literal">SearchCursor</code> and <code class="literal">Polygon</code> objects to read the geometry of a polygon feature class.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec171"/>How to do it…</h2></div></div></div><p>Follow these steps to learn how to read the geometric information from each feature in a feature class:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open <span class="strong"><strong>IDLE</strong></span> and create a new script.</li><li class="listitem">Save <a id="id518" class="indexterm"/>the script to <code class="literal">C:\ArcpyBook\Ch8\ReadGeometry.py</code>.</li><li class="listitem">Import<a id="id519" class="indexterm"/> the <code class="literal">arcpy</code> module:<div class="informalexample"><pre class="programlisting">import arcpy</pre></div></li><li class="listitem">Set the input feature class to the <code class="literal">SchoolDistricts</code> polygon feature class:<div class="informalexample"><pre class="programlisting">infc = "c:/ArcpyBook/data/CityOfSanAntonio.gdb/SchoolDistricts"</pre></div></li><li class="listitem">Create a <code class="literal">SearchCursor</code> object with the input feature class, and return the <code class="literal">ObjectID</code> and <code class="literal">Shape</code> fields. The <code class="literal">Shape</code> field contains the geometry for each feature. The cursor will be created inside a <code class="literal">for</code> loop that we'll use to iterate all the features in the feature class:<div class="informalexample"><pre class="programlisting">for row in arcpy.da.SearchCursor(infc, ["OID@", "SHAPE@"]):
#Print the object id of each feature.
# Print the current ID
  print("Feature {0}:".format(row[0]))
  partnum = 0</pre></div></li><li class="listitem">Use a <code class="literal">for</code> loop to loop through each part of the feature:<div class="informalexample"><pre class="programlisting">  # Step through each part of the feature
  for part in row[1]:
    # Print the part number
    print("Part {0}:".format(partnum))</pre></div></li><li class="listitem">Use a <code class="literal">for</code> loop to loop through each vertex in each part and print the <code class="literal">X</code> and <code class="literal">Y</code> coordinates:<div class="informalexample"><pre class="programlisting">    # Step through each vertex in the feature
    #
    for pnt in part:
      if pnt:
        # Print x,y coordinates of current point
        #
        print("{0}, {1}".format(pnt.X, pnt.Y))
      else:
        # If pnt is None, this represents an interior ring
        #
        print("Interior Ring:")
    partnum += 1</pre></div></li><li class="listitem">You can check your work by examining the <code class="literal">C:\ArcpyBook\code\Ch8\ReadGeometry.py</code> solution file.</li><li class="listitem">Save and run the script. You should see the following output as the script writes <a id="id520" class="indexterm"/>the information for each feature, each <a id="id521" class="indexterm"/>part of the feature, and the <code class="literal">X</code> and <code class="literal">Y</code> coordinates that define each part:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Feature 1:</strong></span>
<span class="strong"><strong>Part 0:</strong></span>
<span class="strong"><strong>-98.492224986, 29.380866971</strong></span>
<span class="strong"><strong>-98.489300049, 29.379610054</strong></span>
<span class="strong"><strong>-98.486967023, 29.378995028</strong></span>
<span class="strong"><strong>-98.48503096, 29.376808947</strong></span>
<span class="strong"><strong>-98.481447988, 29.375624018</strong></span>
<span class="strong"><strong>-98.478799041, 29.374304981</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec172"/>How it works…</h2></div></div></div><p>We initially created a <code class="literal">SearchCursor</code> object to hold the contents of our feature class. After this, we looped through each row in the cursor by using a <code class="literal">for</code> loop. For each row, we looped through all the parts of the geometry. Remember that polyline and polygon features are composed of two or more parts. For each part, we also return the points associated with each part and we print the <code class="literal">X</code> and <code class="literal">Y</code> coordinates of each point.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Using Walk() to navigate directories"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec66"/>Using Walk() to navigate directories</h1></div></div></div><p>In this recipe,<a id="id522" class="indexterm"/> you will learn how to generate data <a id="id523" class="indexterm"/>names in a catalog tree using the <code class="literal">Arcpy Walk()</code> function. Though similar to the Python <code class="literal">os.walk()</code> function, the <code class="literal">da.Walk()</code> function provides some important enhancements related to geodatabases.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec173"/>Getting ready</h2></div></div></div><p>The <code class="literal">Walk()</code> function, which is part of <code class="literal">arcpy.da</code>, generates data names in a catalog tree by walking the tree top-down or bottom-up. Each directory or workspace yields a tuple containing the directory path, directory names, and filenames. This function is similar to the Python <code class="literal">os.walk()</code> function but it has the added advantage of being able to recognize geodatabase structures. The <code class="literal">os.walk()</code> function is file-based so it isn't able to tell you information about geodatabase structures while <code class="literal">arcpy.da.walk()</code> can do so.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec174"/>How to do it…</h2></div></div></div><p>Follow these steps to learn how to use the <code class="literal">da.Walk()</code> function to navigate directories and workspaces to reveal the structure of a geodatabase:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In <span class="strong"><strong>IDLE</strong></span>, create a new Python script called <code class="literal">DAWalk.py</code> and save it to the <code class="literal">C:\ArcpyBook\data</code> folder.</li><li class="listitem">Import the <code class="literal">arcpy</code>, <code class="literal">arcpy.da</code>, and <code class="literal">os</code> modules:<div class="informalexample"><pre class="programlisting">import arcpy.da as da
import os</pre></div></li><li class="listitem">First, we'll<a id="id524" class="indexterm"/> use <code class="literal">os.walk()</code> to<a id="id525" class="indexterm"/> obtain a list of filenames in the current directory. Add this code:<div class="informalexample"><pre class="programlisting">print("os walk")
for dirpath, dirnames, filenames in os.walk(os.getcwd()):
  for filename in filenames:
    print(filename)</pre></div></li><li class="listitem">Save the file and run it to see output similar to what you see here:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>a00000001.gdbindexes</strong></span>
<span class="strong"><strong>a00000001.gdbtable</strong></span>
<span class="strong"><strong>a00000001.gdbtablx</strong></span>
<span class="strong"><strong>a00000002.gdbtable</strong></span>
<span class="strong"><strong>a00000002.gdbtablx</strong></span>
<span class="strong"><strong>a00000003.gdbindexes</strong></span>
<span class="strong"><strong>a00000003.gdbtable</strong></span>
<span class="strong"><strong>a00000003.gdbtablx</strong></span>
<span class="strong"><strong>a00000004.CatItemsByPhysicalName.atx</strong></span>
<span class="strong"><strong>a00000004.CatItemsByType.atx</strong></span>
<span class="strong"><strong>a00000004.FDO_UUID.atx</strong></span>
<span class="strong"><strong>a00000004.freelist</strong></span>
<span class="strong"><strong>a00000004.gdbindexes</strong></span>
<span class="strong"><strong>a00000004.gdbtable</strong></span>
<span class="strong"><strong>a00000004.gdbtablx</strong></span>
</pre></div></li><li class="listitem">Although <code class="literal">os.walk()</code> can be used to print all filenames within a directory, you'll notice that it doesn't have an understanding of the structure of Esri GIS format datasets, such as file geodatabases. Files, such as <code class="literal">a000000001.gdbindexes</code>, are physical files that make up a feature class but <code class="literal">os.walk()</code> can't tell you the logical structure of a feature class. In the next step, we'll use <code class="literal">da.walk()</code> to resolve this problem.</li><li class="listitem">Comment out the code you just added.</li><li class="listitem">Add the following code block:<div class="informalexample"><pre class="programlisting">print("arcpy da walk")
for dirpath, dirnames, filenames in da.Walk(os.getcwd(),datatype="FeatureClass"):
  for filename in filenames:
    print(os.path.join(dirpath, filename)</pre></div></li><li class="listitem">The entire <a id="id526" class="indexterm"/>script should <a id="id527" class="indexterm"/>appear as follows:<div class="informalexample"><pre class="programlisting">import arcpy.da as da
import os

print("os walk")

for dirpath, dirnames, filenames in os.walk(os.getcwd()):
    for filename in filenames:
        print(filename)

print("arcpy da walk")

for dirpath, dirnames, filenames in da.Walk(os.getcwd(),datatype="FeatureClass"):
    for filename in filenames:
        print(os.path.join(dirpath, filename))</pre></div></li><li class="listitem">You can check your work by examining the <code class="literal">C:\ArcpyBook\code\Ch8\Walk.py</code> solution file.</li><li class="listitem">Save and execute the script to see the following output. Notice how much cleaner the output is and that the actual feature class names contained within the geodatabase are printed out instead of the physical filenames:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>C:\ArcpyBook\data\Building_Permits.shp</strong></span>
<span class="strong"><strong>C:\ArcpyBook\data\Burglaries_2009.shp</strong></span>
<span class="strong"><strong>C:\ArcpyBook\data\Streams.shp</strong></span>
<span class="strong"><strong>C:\ArcpyBook\data\CityOfSanAntonio.gdb\Crimes2009</strong></span>
<span class="strong"><strong>C:\ArcpyBook\data\CityOfSanAntonio.gdb\CityBoundaries</strong></span>
<span class="strong"><strong>C:\ArcpyBook\data\CityOfSanAntonio.gdb\CrimesBySchoolDistrict</strong></span>
<span class="strong"><strong>C:\ArcpyBook\data\CityOfSanAntonio.gdb\SchoolDistricts</strong></span>
<span class="strong"><strong>C:\ArcpyBook\data\CityOfSanAntonio.gdb\BexarCountyBoundaries</strong></span>
<span class="strong"><strong>C:\ArcpyBook\data\CityOfSanAntonio.gdb\Texas_Counties_LowRes</strong></span>
<span class="strong"><strong>C:\ArcpyBook\data\CityOfSanAntonio.gdb\Burglary</strong></span>
<span class="strong"><strong>C:\ArcpyBook\data\TravisCounty\BuildingPermits.shp</strong></span>
<span class="strong"><strong>C:\ArcpyBook\data\TravisCounty\CensusTracts.shp</strong></span>
<span class="strong"><strong>C:\ArcpyBook\data\TravisCounty\CityLimits.shp</strong></span>
<span class="strong"><strong>C:\ArcpyBook\data\TravisCounty\Floodplains.shp</strong></span>
<span class="strong"><strong>C:\ArcpyBook\data\TravisCounty\Hospitals.shp</strong></span>
<span class="strong"><strong>C:\ArcpyBook\data\TravisCounty\Schools.shp</strong></span>
<span class="strong"><strong>C:\ArcpyBook\data\TravisCounty\Streams.shp</strong></span>
<span class="strong"><strong>C:\ArcpyBook\data\TravisCounty\Streets.shp</strong></span>
<span class="strong"><strong>C:\ArcpyBook\data\TravisCounty\TravisCounty.shp</strong></span>
<span class="strong"><strong>C:\ArcpyBook\data\Wildfires\WildlandFires.mdb\FireIncidents</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec175"/>How it works…</h2></div></div></div><p>The <code class="literal">da.Walk()</code> function accepts two parameters including the top-level workspace that will be<a id="id528" class="indexterm"/> retrieved (the current working directory), as <a id="id529" class="indexterm"/>well as the data type that will be used to filter the returned list. In this case, we retrieved only feature class-related files. The <code class="literal">Walk()</code> function returns a tuple containing the directory path, directory names, and filenames.</p></div></div></div>
</body></html>