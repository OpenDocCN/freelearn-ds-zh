- en: Chapter 3. Dealing with Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Binding array as data
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding object literals as data
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding functions as data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with arrays
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering with data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting with data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading data from server
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to explore the most essential question in any
    data visualization project, how data can be represented both in programming constructs,
    and its visual metaphor. Before we start on this topic, some discussion on what
    data visualization is is necessary. In order to understand what data visualization
    is, first we need to understand the difference between data and information.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Data are raw facts. The word raw indicates that the facts have not yet been
    processed to reveal their meaning...Information is the result of processing raw
    data to reveal its meaning.
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (Rob P., S. Morris, and Coronel C. 2009)
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is how data and information are traditionally defined in the digital information
    world. However, data visualization provides a much richer interpretation of this
    definition since information is no longer the mere result of processed raw facts
    but rather a visual metaphor of the facts. As suggested by Manuel Lima in his
    *Information Visualization Manifesto* that design in the material world, where
    form is regarded to follow function.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'The same data set can generate any number of visualizations which may lay equal
    claim in terms of its validity. In a sense, visualization is more about communicating
    the creator''s insight into data than anything else. On a more provocative note,
    Card, McKinlay, and Shneiderman suggested that the practice of information visualization
    can be described as:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: The use of computer-supported, interactive, visual representations of abstract
    data to amplify cognition.
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (Card S. & Mackinly J. and Shneiderman B. 1999)
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the following sections, we will explore various techniques D3 provides to
    bridge the data with the visual domain. It is the very first step we need to take
    before we can create a **cognition amplifier** with our data.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: The enter-update-exit pattern
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The task of matching each datum with its visual representation, for example,
    drawing a single bar for every data point you have in your data set, updating
    the bars when the data points change, and then eventually removing the bars when
    certain data points no longer exist, seems to be a complicated and tedious task.
    This is precisely why D3 was designed to provide an ingenious way of simplifying
    the implementation of this connection. This way of defining the connection between
    data and its visual representation is usually referred to as the **enter-update-exit**
    pattern in D3\. This pattern is profoundly different from the typical **imperative
    method** most developers are familiar with. However, the understanding of this
    pattern is crucial to your effectiveness with D3 library, and therefore, in this
    section, we will focus on explaining the concept behind this pattern. First, let''s
    take a look at the following conceptual illustration of the two domains:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![The enter-update-exit pattern](img/2162OS_03_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: Data and Visual Set
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: In the previous illustration, the two circles represent two joined sets. Set
    **A** depicts your data set while set **B** represents the visual elements. This
    is essentially how D3 sees the connection between your data and visual elements.
    You might be asking how elementary set theory is going to help your data visualization
    effort here. Let me explain.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, let us consider the question, *how can I find all visual elements that
    currently represent its corresponding data point*? The answer is **A∩B**; this
    denotes the intersection of sets A and B, the elements that exist in both **Data**
    and **Visual** domains.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '![The enter-update-exit pattern](img/2162OS_03_02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
- en: Update Mode
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: The shaded area represents the intersection between the two sets—A and B. In
    D3, the `selection.data` function can be used to select this intersection—A∩B.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: The `selection.data(data)` function, on a selection, sets up the connection
    between the data domain and visual domain as we discussed above. The initial selection
    forms the visual set **B** while the data provided in the `data` function forms
    the data set **A** respectively. The return result of this function is a new selection
    (a data-bound selection) of all elements existing in this intersection. Now, you
    can invoke the modifier function on this new selection to update all the existing
    elements. This mode of selection is usually referred to as the **Update** mode.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'The second question we need to answer here is *how can I locate data that has
    not yet been visualized*. The answer is the set difference of A and B, denoted
    as **A\B**, or visually, the following illustration:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![The enter-update-exit pattern](img/2162OS_03_03.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: Enter Mode
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: The shaded area in set **A** represents the data points that have not yet been
    visualized. In order to gain access to this **A\B** subset, the following functions
    need to be performed on a data-bound D3 selection (a selection returned by the
    `data` function).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: The `selection.data(data).enter()` function returns a new selection representing
    the **A\B** subset, which contains all the data that has not yet been represented
    in the visual domain. The regular modifier function can then be chained to this
    new selection method to create new visual elements representing the given data
    elements. This mode of selection is simply referred to as the **Enter** mode.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: The last case in our discussion covers the visual elements that exist in our
    data set but no longer have any corresponding data element associated with them.
    You might ask how this kind of visual element can exist in the first place. This
    is usually caused by removing the elements from the data set. If you initially
    visualized all data elements within your data set, after that you have removed
    some data elements. Now, you have certain visual elements that are no longer representing
    any valid data point in your data set. This subset can be discovered by using
    an inverse of the **Update** difference, denoted as **B\A**.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '![The enter-update-exit pattern](img/2162OS_03_04.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
- en: Exit Mode
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: The shaded area in the previous illustration represents the difference we discussed
    here. The subset can be selected using the `selection.exit` function on a data-bound
    selection.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: The `selection.data(data).exit` function, when invoked on a data-bound D3 selection,
    computes a new selection which contains all visual elements that are no longer
    associated with any valid data element. As a valid D3 selection object, the modifier
    function can then be chained to this selection to update and remove these visual
    elements that are no longer needed as part of our visualization. This mode of
    selection is called the **Exit** mode.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Together, the three different selection modes cover all possible cases of interaction
    between the data and visual domain. The **enter-update-exit** pattern is the cornerstone
    of any D3-driven visualization. In the following recipes of this chapter, we will
    cover the topics on how these selection methods can be utilized to generate data-driven
    visual elements efficiently and easily.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Binding an array as data
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common and popular ways to define data in D3 visualization is
    through the use of JavaScript arrays. For example, say you have multiple data
    elements stored in an array, and you want to generate corresponding visual elements
    to represent each and every one of them. Additionally, when the data array gets
    updated, you want your visualization to reflect such changes immediately. In this
    recipe, we will accomplish this common approach.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/array-as-data.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/array-as-data.html)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first and most natural solution that might come to mind is iterating through
    the data array elements and generating their corresponding visual elements on
    the page. This is definitely a valid solution and it will work with D3, however,
    the enter-update-exit pattern we discussed in the introduction provides a much
    easier and more efficient way to generate visual elements. Let''s have a look
    at how we do that:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This recipe generates the following visual output:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/2162OS_03_05.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
- en: Data as Array
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, data (a list of integers in this case) is stored in a simple
    JavaScript array as shown on the line marked as `A` with an arrow left of it.
    The `render` function is defined on the line marked as `B` so that it can be repeatedly
    invoked to update our visualization. The `Enter` selection implementation starts
    on the line marked as `C`, which selects all `div` elements on the web page with
    `h-bar` CSS class. You are probably wondering why we are selecting these `div`
    elements since they don''t even exist on the web page yet. This is in fact true;
    however, the selection at this point is used to define the visual set we discussed
    in the introduction. By issuing this selection that we made in the previous line
    we are essentially declaring that there should be a set of `div.h-bar` elements
    on the web page to form our visual set. On the line marked as `D`, we invoke the
    `data` function on this initial selection to bind the array as our data set to
    the to-be-created visual elements. Once the two sets are defined, the `enter()`
    function can be used to select all data elements that are not yet visualized.
    When the `render` function is invoked for the very first time, it returns all
    elements in the data array, as shown in the following code snippet:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: On line `F`, a new `div` element is created and appended to the `body` element
    of each data element selected in the `enter` function; this essentially creates
    one `div` element for each data element. Finally, on line `G`, an element called
    `span` is created and appended to the `div` element and we set its CSS class to
    `h-bar`. At this point, we have basically created the skeleton of our visualization
    including empty `div` and `span` elements. Next step is to change the visual attributes
    of our elements based on the given data.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: D3 injects a property to the DOM element named `__data__` to make data sticky
    with visual elements so when selections are made using a modified data set, D3
    can compute the difference and intersection correctly. You can see this property
    easily if you inspect the DOM element either visually using a debugger or programmatically.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/2162OS_03_11.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
- en: As illustrated by the preceding screenshot, this is a very useful fact to know
    when you are debugging your visualization implementation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Update` section of `array-as-data.html`, the first two lines are identical
    to what we have done in the `Enter` section, and this essentially defines our
    data set and visual set respectively. The major difference here is on line `H`.
    Instead of calling the `enter` function, as we did in the code mentioned under
    `Enter` in the previous paragraphs, in the `Update` mode we directly apply modifier
    functions to the selection made by the `data` function. In the `Update` mode,
    `data` function returns the intersection between the data set and visual set (A∩B).
    On line `H`, we apply a dynamic style attribute `width` to be three times the
    integer value associated with each visual element shown in the following code
    snippet:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: All D3 modifier functions accept this type of dynamic function to compute its
    value on the fly. This is precisely what it means to "data drive" your visualization.
    Hence, it is crucial to understand what this function is designed to achieve in
    our example. This function receives a parameter `d`, which is the datum associated
    with the current element. In our example, the first `div` bar has the value `10`
    associated as its datum, while the second bar has `15`, and so on. Therefore,
    this function essentially computes a numeric value that is three times the datum
    for each bar and returns it as the `width` in pixels.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting point worth mentioning here is on line `I`, where we mention
    the `span` attribute. The child `span` element can also use dynamic modifier functions
    and has access to the same datum propagated from its parent element. This is the
    default behavior of D3 data binding. Any element you append to a data-bound element
    automatically inherits the parent's datum.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **dynamic modifier function** actually accepts two parameters `d` and `i`.
    The first parameter `d` is the associated datum we have discussed here and `i`
    is a zero-based index number for the current element. Some recipes in the previous
    chapter have relied on this index, and in the rest of this chapter, we will see
    other recipes that utilize this index in different ways.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the raw HTML code resulted from this update process:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Elements created and appended in the `enter` mode, that is, on line `F` and
    `G`, are automatically added to the `update` set. So, there is no need to repeat
    visual attributes modification logic in both `enter` and `update` section of code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'The last section—`Exit` section—is fairly simple as shown here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tip
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The selection returned by the `exit()` function is just like any other selection.
    Therefore, although `remove` is the most common action used against the `exit`
    selection, you can also apply other modifiers or transitions to this selection.
    We will explore some of these options in later chapters.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: On line `J`, the `exit()` function is called to compute the set difference of
    all visual elements that are no longer associated with any data. Finally, the
    `remove()` function is called on this selection to remove all the elements selected
    by the `exit()` function. This way, as long as we call the `render()` function
    after we change our data, we can always ensure that our visual representation
    and data are kept synchronized.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the last block of code is as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: On line `K`, a simple function called `function()` was created to remove the
    top element in the data array using the `shift` function, while appending a random
    integer to the data array using the `push()` function every 1.5 seconds. Once
    the data array is updated, the `render()` function is called again to update our
    visualization keeping it synchronized with the new data set. This is what gives
    our example its animated bar chart look.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Binding object literals as data
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With a more complex visualization, each element we have in a data array might
    not be a primitive integer value or a string, but a JavaScript object themselves.
    In this recipe, we will discuss how this more complex data structure can be leveraged
    to drive your visualization using D3.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/object-as-data.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/object-as-data.html)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript object literal is probably the most common data structure you will
    encounter when loading data sources on the Web. In this recipe, we will look at
    how these JavaScript objects can be leveraged to generate rich visualization.
    Here is how to do it in code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This recipe generates the following visualization:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/2162OS_03_06.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
- en: Data as Object
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, instead of simple integers as in the previous recipe, now our
    data array is filled with objects (see the line marked as `A` with an arrow left
    to it). Each data object contains two attributes—`width` and `color`—that are
    both integers in this case.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This recipe is built on top of the previous recipe so if you are not familiar
    with the fundamental enter-update-exit selection pattern, please review the previous
    recipe first.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: var data = [ // <- A
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On line `B`, we have a complicated-looking color scale defined. Scales, including
    color scale, will be discussed in depth in the next chapter, so for now let us
    just assume this is a scale function we can use to produce CSS-compatible color
    code given some integer input value. This is sufficient for the purpose of this
    recipe.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'The major difference between this recipe and the previous one is how data is
    handled as shown on line `C`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As we can see in the preceding code snippet, in this recipe the datum associated
    with each visual element is actually an object, not an integer. Therefore, we
    can access the `d.width` attribute on line `D`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your object has functions of its own, you can also access them here in a
    dynamic modifier function. This is a convenient way to add some data-specific
    helper functions in your data source. However, beware that since dynamic functions
    are usually invoked numerous times during visualization, the function you rely
    on should be implemented as efficiently as possible. If this is not possible,
    then it is best to preprocess your data before binding them to your visualization
    process.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly on line `E`, the `background-color` style can be computed using the
    `d.color` attribute with the color scale we defined earlier:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The child element `span` again inherits its parent's associated datum, and hence,
    it also has access to the same datum object in its dynamic modifier function on
    line `F` setting the textual content to `d.width` attribute.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: This recipe demonstrates how JavaScript objects can easily be bound to visual
    elements using exactly the same method discussed in the previous recipe. This
    is one of the most powerful capabilities of the D3 library; it allows you to re-use
    the same pattern and method to handle different types of data, simple or complex.
    We will see more examples on this topic in the next recipe.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Binding functions as data
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the benefits of D3's excellent support for functional style JavaScript
    programming is that it allows functions to be treated as data as well. This particular
    feature can offer some very powerful capabilities under certain circumstances.
    This is a more advanced recipe. Don't worry about it if you are new to D3 and
    having some difficulty understanding it at first. Over time, this kind of usage
    will become natural to you.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/function-as-data.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/function-as-data.html)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will explore the possibility of binding functions themselves
    as data to your visual elements. This capability is extremely powerful and flexible
    if used correctly:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This preceding code produces the following bar chart:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/2162OS_03_07.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
- en: Data as Function
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we chose to visualize the output of formula `15 + x * x` using
    a series of vertical bars, each of them annotated with its representing integral
    value. This visualization adds a new bar to the right of the previous one every
    one and a half seconds. We can of course implement this visualization using the
    techniques we have discussed in the previous two recipes. So we generated an array
    of integers using the formula, then just appended a new integer from *n* to *n+1*
    every 1.5 seconds before re-rendering the visualization. However, in this recipe,
    we decided to take a more functional approach.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'This time we started with an empty data array on line `A`. On line `B`, a simple
    function is defined to calculate the result of this formula *15+x^2*. Then on
    line `C`, another function is created to generate the current data set which contains
    *n+1* references to the `next` function. Here is the code for functional data
    definition:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This seems to be a strange setup to achieve our visualizational goal. Let''s
    see how we can leverage all these functions in our visualization code. On line
    `D`, we bind our data to a selection of `div` elements just as we did in previous
    recipes. However, this time the data is not an array but rather the `newData`
    function:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'D3 is pretty flexible when it comes to data. If you provide a function to the
    `data` function, D3 will simply invoke the given function and use the returned
    value of this function as a parameter of the `data` function. In this case, the
    data being returned by the `newData` function is an array of function references.
    As the result of this, now in our dynamic modifier function, on line `E` and `F`,
    the datum `d` that is being passed into these functions are actually references
    to the `next` function, as shown in the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As a reference to a function, `d` can now be invoked with index `i` as the parameter,
    which in turn generates the output of the formula needed for our visualization.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In JavaScript, functions are special objects, so semantically this is exactly
    the same as binding objects as data. Another note on this topic is that data can
    also be considered as functions. Constant values such as integers can be thought
    of as a static function that simply returns what it receives with no modification
    made.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: This technique might not be the most commonly-used technique in visualization,
    but when used properly, it is extremely flexible and powerful, especially when
    you have a fluid data set.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Datum function typically needs to be **idempotent** to make sense. Idempotence
    is the property of being able to apply the same function with the same inputs
    multiple times without changing the result beyond the initial application. For
    more detail on idempotence visit: [http://en.wikipedia.org/wiki/Idempotence](http://en.wikipedia.org/wiki/Idempotence)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Working with arrays
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of our data is stored in arrays, and we spend a lot of our effort working
    with arrays to format and restructure data. This is why D3 provides a rich set
    of array-oriented utilities functions, making this task a lot easier. In this
    recipe, we will explore some of the most common and helpful utilities in this
    aspect.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/working-with-array.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/working-with-array.html)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code example shows some of the most common and helpful array
    utility functions offered by the D3 library and their effects:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding code produces the following output:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: D3 provides a variety of utility functions to help perform operations on JavaScript
    arrays. Most of them are pretty intuitive and straightforward, however, there
    are a few intrinsic ones. We will discuss them briefly in this section.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'Given our array as `[3, 2, 11, 7, 6, 4, 10, 8, 15]`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '`d3.min`: This function retrieves the smallest element, that is, `2`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d3.max`: This function retrieve the largest element, that is, `15`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d3.extent`: This function retrieves both the smallest and the largest element,
    that is, `[2, 15]`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d3.sum`: This function retrieves the addition of all elements in the array,
    that is, `66`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d3.medium`: This function finds the medium, that is, `7`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d3.mean`: This function calculates the mean value, that is, `7.33`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d3.ascending` / `d3.descending`: The `d3` object comes with a built-in comparator
    function that you can use to sort the JavaScript array'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`d3.quantile`: This function calculates the quantile on an already sorted array
    in ascending order, that is, quantile of `0.25` is `4`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d3.bisect`: This function finds an insertion point that comes after (to the
    right of) any existing element of an already sorted array, that is, bisect `(array,
    6)` produce `4`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d3.nest`: D3''s `nest` function can be used to build an algorithm that transforms
    a flat array-based data structure into a hierarchical nested structure, that is,
    particularly suitable for some types of visualization. D3''s `nest` function can
    be configured using the `key` function chained to `nest`, as seen on lines `A`
    and `B`:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Multiple `key` functions can be provided to generate multiple levels of nesting.
    In our case the nesting consists of two levels, first by the `type` amount and
    then by the `tip` amount, as demonstrated in the output below:'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Finally, the `entries()` function is used to supply the flat array-based data
    set as shown on line `C`.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Filtering with data
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine you need to filter D3 selection based on the associated data elements
    so that you can hide/show different sub-datasets based on the user's input. D3
    selection provides a filter function to perform this kind of data-driven filtering.
    In this recipe, we will show you how this can be leveraged to filter visual elements
    in a data-driven fashion.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/data-filter.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/data-filter.html)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following example code shows how data-based filtering can be leveraged
    to highlight different visual elements based on its categorization:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding code generates the following visual output once the **Dinning**
    button is clicked:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/2162OS_03_08.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: Data-based Filtering
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we have a data set consisting of a list of personal expense
    records with `expense` and `category` as attributes, which is shown on the block
    of code marked as `A`. On line `B`, `C`, and `D`, a set of horizontal bars (HTML
    div) were created using the standard enter-update-exit pattern to represent the
    expense records. So far, this recipe is similar to the *Binding object literals
    as data* recipe. Now let''s take a look at line `E`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'D3 `selection.filter` function takes a function as its parameter. It applies
    the function against every element in the existing selection. The given function
    for `filter` takes two parameters with a hidden reference:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '`d:` It is the datum associated with the current element'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i`: It is a zero-based index for the current element'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`this`: This has the hidden reference points to the current DOM element'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: D3 `selection.filter` function expects the given function to return a Boolean
    value. If the returned value is true, the corresponding element will be included
    into the new selection being returned by the `filter` function. In our example,
    the `filter` function essentially selects all bars that match the user-selected
    category and applies a CSS class `selected` to each one of them. This method provides
    you a powerful way to filter and generate data-driven sub-selection, which you
    can further manipulate or dissect to generate focused visualization.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: D3 `selection.filter` function treats the returned value using JavaScript **truthy**
    and **falsy tests**, thus not exactly expecting a strict Boolean value. What this
    means is that false, null, `0`, "", undefined, and **NaN** (not a number) are
    all treated as false while other things are considered true.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Sorting with data
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many cases, it is desirable to sort your visual elements according to the
    data they represent so that you can highlight the significance of different elements
    visually. In this recipe, we will explore how this can be achieved in D3.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/data-sort.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/data-sort.html)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s see how data-driven sorting and further manipulation can be performed
    using D3\. In this example, we will sort the bar chart we created in the previous
    recipe based on either expense (width) or category using user''s input:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This preceding code generates sorted horizontal bars as shown in the following
    screenshot:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/2162OS_03_09.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
- en: Data-based Sorting
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we set up a simple row-based visualization (in line `B`, `C`,
    and `D`) of some simulated personal expense records containing two attributes:
    `expense` and `category` that are defined on line `A`. This is exactly the same
    as the previous recipe and quite similar to what we have done in the *Binding
    object literals as data* recipe. Once the basics are done, we then select all
    existing bars on line `E` and perform sorting using D3 `selection.sort` function:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `selection.sort` function accepts a comparator function:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The **comparator** function receives two data elements `a` and `b` to compare,
    returning either a negative, positive, or zero value. If the value is negative,
    `a` will be placed before `b`; if positive, `a` will be placed after `b`; otherwise,
    `a` and `b` are considered equal and the order is **arbitrary**. The `sort()`
    function returns a new selection with all elements sorted in an order which is
    determined by the specified comparator function. The newly-returned selection
    can then be manipulated further to generate the desired visualization.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because `a` and `b` are placed arbitrarily when they are equal, D3 `selection.sort`
    is not guaranteed to be stable, however, it is guaranteed to be consistent with
    your browser's built-in `sort` method on arrays.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Loading data from a server
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is probably very rare that you will only be visualizing static local data.
    The power of data visualization usually lays on the ability to visualize dynamic
    data typically generated by a server-side program. Since this is a common use
    case, D3 comes with some handy helper functions to make this task as easy as possible.
    In this recipe, we will see how a remote data set can be loaded dynamically, and
    we will update an existing visualization once loaded.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/asyn-data-load.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/asyn-data-load.html)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the code example of the `asyn-data-load.html` file, we will load data dynamically
    from the server on user''s request, and once the data is loaded, we also update
    our visualization to reflect the new expanded data set. Here is the code where
    we do that:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here is what our `data.json` file looks like:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This recipe generates the following visual output after clicking the **Load
    Data from JSON feed** button once:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/2162OS_03_10.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
- en: Data Loading from Server
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we initially have a local data set defined on the line marked
    as `A`, and a row-based visualization generated by lines `B`, `C`, and `D`. The
    `load` function is defined on line `E` that responds to the user''s click on the
    **Load Data from JSON feed** button, which loads the data from a separate file
    (`data.json`) served by the server. This is achieved by using the `d3.json` function
    as shown on line `F`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Since loading a remote data set from a JSON file could take some time, it is
    performed asynchronously. Once loaded, the data set will be passed to the given
    handler function, which is specified on line `F`. In this function, we simply
    concatenate the newly loaded data with our existing data set, then re-render the
    visualization to update the display.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 由于从 JSON 文件加载远程数据集可能需要一些时间，因此它是异步执行的。一旦加载完成，数据集将被传递给指定的处理函数，该函数在行 `F` 上指定。在这个函数中，我们只是将新加载的数据与现有数据集连接起来，然后重新渲染可视化以更新显示。
- en: Tip
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Similar functions are also provided by D3 to make the loading of CSV, TSV, TXT,
    HTML, and XML data a simple task.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: D3 还提供了类似的功能，使得加载 CSV、TSV、TXT、HTML 和 XML 数据变得简单易行。
- en: If a more customized and specific control is required, the `d3.xhr` function
    can be used to further customize the MIME type and request headers. Behind the
    scenes, `d3.json` and `d3.csv` are both using `d3.xhr` to generate the actual
    request.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要更定制化和具体的控制，可以使用 `d3.xhr` 函数来进一步自定义 MIME 类型和要求头。幕后，`d3.json` 和 `d3.csv` 都是在使用
    `d3.xhr` 来生成实际请求。
- en: Of course this is by no means the only way to load remote data from the server.
    D3 does not dictate how data should be loaded from the remote server. You are
    free to use your favorite JavaScript libraries, for example, jQuery or Zepto.js
    to issue an Ajax request and load a remote data set.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这绝对不是从服务器加载远程数据的唯一方法。D3 并不规定如何从远程服务器加载数据。你可以自由地使用你喜欢的 JavaScript 库，例如 jQuery
    或 Zepto.js 来发起 Ajax 请求并加载远程数据集。
