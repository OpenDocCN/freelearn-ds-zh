- en: Chapter 3. Dealing with Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 处理数据
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Binding array as data
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数组作为数据绑定
- en: Binding object literals as data
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将对象字面量作为数据绑定
- en: Binding functions as data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数作为数据绑定
- en: Working with arrays
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与数组一起工作
- en: Filtering with data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据过滤
- en: Sorting with data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据排序
- en: Loading data from server
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从服务器加载数据
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we are going to explore the most essential question in any
    data visualization project, how data can be represented both in programming constructs,
    and its visual metaphor. Before we start on this topic, some discussion on what
    data visualization is is necessary. In order to understand what data visualization
    is, first we need to understand the difference between data and information.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨任何数据可视化项目中最重要的基本问题，即数据如何在编程结构和其视觉隐喻中得以表示。在我们开始这个话题之前，对数据可视化是什么的讨论是必要的。为了理解数据可视化是什么，首先我们需要了解数据和信息之间的区别。
- en: Data are raw facts. The word raw indicates that the facts have not yet been
    processed to reveal their meaning...Information is the result of processing raw
    data to reveal its meaning.
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 数据是原始事实。这个词“原始”意味着这些事实尚未经过处理以揭示其含义...信息是处理原始数据以揭示其含义的结果。
- en: ''
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (Rob P., S. Morris, and Coronel C. 2009)
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (Rob P., S. Morris, and Coronel C. 2009)
- en: This is how data and information are traditionally defined in the digital information
    world. However, data visualization provides a much richer interpretation of this
    definition since information is no longer the mere result of processed raw facts
    but rather a visual metaphor of the facts. As suggested by Manuel Lima in his
    *Information Visualization Manifesto* that design in the material world, where
    form is regarded to follow function.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在数字信息世界中传统上定义数据和信息的途径。然而，数据可视化提供了对这个定义的更丰富解释，因为信息不再是经过处理的原始事实的简单结果，而是一种事实的视觉隐喻。正如Manuel
    Lima在他的《信息可视化宣言》中所建议的，在物质世界中，形式被视为功能的追随者。
- en: 'The same data set can generate any number of visualizations which may lay equal
    claim in terms of its validity. In a sense, visualization is more about communicating
    the creator''s insight into data than anything else. On a more provocative note,
    Card, McKinlay, and Shneiderman suggested that the practice of information visualization
    can be described as:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 同一个数据集可以生成任意数量的可视化，它们在有效性方面可能具有同等的要求。从某种意义上说，可视化更多的是关于传达创作者对数据的洞察，而不是其他任何事情。更进一步地说，Card、McKinlay和Shneiderman提出，信息可视化的实践可以描述为：
- en: The use of computer-supported, interactive, visual representations of abstract
    data to amplify cognition.
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用计算机支持的、交互的、抽象数据的视觉表示来增强认知。
- en: ''
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (Card S. & Mackinly J. and Shneiderman B. 1999)
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (Card S. & Mackinly J. and Shneiderman B. 1999)
- en: In the following sections, we will explore various techniques D3 provides to
    bridge the data with the visual domain. It is the very first step we need to take
    before we can create a **cognition amplifier** with our data.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨D3提供的各种技术，以在数据与视觉领域之间架起桥梁。这是我们能够用数据创建**认知放大器**之前需要采取的第一个步骤。
- en: The enter-update-exit pattern
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进入-更新-退出模式
- en: 'The task of matching each datum with its visual representation, for example,
    drawing a single bar for every data point you have in your data set, updating
    the bars when the data points change, and then eventually removing the bars when
    certain data points no longer exist, seems to be a complicated and tedious task.
    This is precisely why D3 was designed to provide an ingenious way of simplifying
    the implementation of this connection. This way of defining the connection between
    data and its visual representation is usually referred to as the **enter-update-exit**
    pattern in D3\. This pattern is profoundly different from the typical **imperative
    method** most developers are familiar with. However, the understanding of this
    pattern is crucial to your effectiveness with D3 library, and therefore, in this
    section, we will focus on explaining the concept behind this pattern. First, let''s
    take a look at the following conceptual illustration of the two domains:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 将每个数据点与其视觉表示相匹配的任务，例如，为数据集中的每个数据点绘制一个条形图，当数据点发生变化时更新条形图，然后最终在某个数据点不再存在时删除条形图，这似乎是一个复杂且繁琐的任务。这正是D3被设计用来提供一种巧妙的方法来简化这种连接的实现。这种定义数据与其视觉表示之间连接的方式通常被称为D3中的
    **进入-更新-退出** 模式。这种模式与大多数开发者熟悉的典型 **命令式方法** 有着根本的不同。然而，理解这个模式对于你在D3库中的有效性至关重要，因此，在本节中，我们将重点解释这个模式背后的概念。首先，让我们看一下以下两个域的概念性插图：
- en: '![The enter-update-exit pattern](img/2162OS_03_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![The enter-update-exit pattern](img/2162OS_03_01.jpg)'
- en: Data and Visual Set
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 数据和视觉集
- en: In the previous illustration, the two circles represent two joined sets. Set
    **A** depicts your data set while set **B** represents the visual elements. This
    is essentially how D3 sees the connection between your data and visual elements.
    You might be asking how elementary set theory is going to help your data visualization
    effort here. Let me explain.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，两个圆圈代表两个连接的集合。集合 **A** 描述了你的数据集，而集合 **B** 代表视觉元素。这正是D3看待数据与视觉元素之间联系的方式。你可能想知道基本的集合理论如何帮助你在这里的数据可视化工作中。让我来解释。
- en: Firstly, let us consider the question, *how can I find all visual elements that
    currently represent its corresponding data point*? The answer is **A∩B**; this
    denotes the intersection of sets A and B, the elements that exist in both **Data**
    and **Visual** domains.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑这样一个问题，*我如何找到所有当前代表其对应数据点的视觉元素*？答案是 **A∩B**；这表示集合A和B的交集，存在于**数据**和**视觉**域中的元素。
- en: '![The enter-update-exit pattern](img/2162OS_03_02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![The enter-update-exit pattern](img/2162OS_03_02.jpg)'
- en: Update Mode
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 更新模式
- en: The shaded area represents the intersection between the two sets—A and B. In
    D3, the `selection.data` function can be used to select this intersection—A∩B.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影区域表示两个集合——A和B之间的交集。在D3中，可以使用 `selection.data` 函数来选择这个交集——A∩B。
- en: The `selection.data(data)` function, on a selection, sets up the connection
    between the data domain and visual domain as we discussed above. The initial selection
    forms the visual set **B** while the data provided in the `data` function forms
    the data set **A** respectively. The return result of this function is a new selection
    (a data-bound selection) of all elements existing in this intersection. Now, you
    can invoke the modifier function on this new selection to update all the existing
    elements. This mode of selection is usually referred to as the **Update** mode.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择上，`selection.data(data)` 函数设置了数据域和视觉域之间的连接，正如我们上面讨论的那样。初始选择形成了视觉集 **B**，而
    `data` 函数中提供的数据形成了数据集 **A**。这个函数的返回结果是所有存在于这个交集中的新选择（数据绑定选择）。现在，你可以对这个新选择调用修改函数来更新所有现有元素。这种选择模式通常被称为
    **更新** 模式。
- en: 'The second question we need to answer here is *how can I locate data that has
    not yet been visualized*. The answer is the set difference of A and B, denoted
    as **A\B**, or visually, the following illustration:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里需要回答的第二个问题是 *我如何定位尚未可视化的数据*。答案是A和B的集合差，表示为 **A\B**，或者从视觉上看，以下插图：
- en: '![The enter-update-exit pattern](img/2162OS_03_03.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![The enter-update-exit pattern](img/2162OS_03_03.jpg)'
- en: Enter Mode
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 进入模式
- en: The shaded area in set **A** represents the data points that have not yet been
    visualized. In order to gain access to this **A\B** subset, the following functions
    need to be performed on a data-bound D3 selection (a selection returned by the
    `data` function).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 集合 **A** 中的阴影区域表示尚未可视化的数据点。为了访问这个 **A\B** 子集，需要在数据绑定的D3选择（由 `data` 函数返回的选择）上执行以下函数。
- en: The `selection.data(data).enter()` function returns a new selection representing
    the **A\B** subset, which contains all the data that has not yet been represented
    in the visual domain. The regular modifier function can then be chained to this
    new selection method to create new visual elements representing the given data
    elements. This mode of selection is simply referred to as the **Enter** mode.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`selection.data(data).enter()` 函数返回一个新的选择，表示 **A\B** 子集，其中包含所有尚未在视觉域中表示的数据。然后，常规的修改函数可以链接到这个新的选择方法，以创建表示给定数据元素的新的视觉元素。这种选择模式简单地被称为
    **Enter** 模式。'
- en: The last case in our discussion covers the visual elements that exist in our
    data set but no longer have any corresponding data element associated with them.
    You might ask how this kind of visual element can exist in the first place. This
    is usually caused by removing the elements from the data set. If you initially
    visualized all data elements within your data set, after that you have removed
    some data elements. Now, you have certain visual elements that are no longer representing
    any valid data point in your data set. This subset can be discovered by using
    an inverse of the **Update** difference, denoted as **B\A**.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论的最后一个案例涵盖了存在于我们的数据集中但不再与任何对应数据元素相关联的视觉元素。你可能会问这种类型的视觉元素最初是如何存在的。这通常是由于从数据集中删除元素造成的。如果你最初在数据集中可视化了所有数据元素，然后删除了一些数据元素。现在，你有一些视觉元素不再代表数据集中的任何有效数据点。这个子集可以通过使用
    **Update** 差分的逆运算来发现，表示为 **B\A**。
- en: '![The enter-update-exit pattern](img/2162OS_03_04.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![enter-update-exit 模式](img/2162OS_03_04.jpg)'
- en: Exit Mode
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Exit 模式
- en: The shaded area in the previous illustration represents the difference we discussed
    here. The subset can be selected using the `selection.exit` function on a data-bound
    selection.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 上一幅图中的阴影区域表示我们在这里讨论的差异。可以使用 `selection.exit` 函数在数据绑定选择上选择这个子集。
- en: The `selection.data(data).exit` function, when invoked on a data-bound D3 selection,
    computes a new selection which contains all visual elements that are no longer
    associated with any valid data element. As a valid D3 selection object, the modifier
    function can then be chained to this selection to update and remove these visual
    elements that are no longer needed as part of our visualization. This mode of
    selection is called the **Exit** mode.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当在数据绑定的 D3 选择上调用 `selection.data(data).exit()` 函数时，它会计算一个新的选择，其中包含所有不再与任何有效数据元素相关联的视觉元素。作为一个有效的
    D3 选择对象，修改函数可以链接到这个选择，以更新和删除不再需要的这些视觉元素。这种选择模式被称为 **Exit** 模式。
- en: Together, the three different selection modes cover all possible cases of interaction
    between the data and visual domain. The **enter-update-exit** pattern is the cornerstone
    of any D3-driven visualization. In the following recipes of this chapter, we will
    cover the topics on how these selection methods can be utilized to generate data-driven
    visual elements efficiently and easily.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 三个不同的选择模式共同涵盖了数据与视觉域之间所有可能的交互情况。**enter-update-exit** 模式是任何 D3 驱动的可视化的基石。在接下来的章节中，我们将介绍如何有效地利用这些选择方法来生成数据驱动的视觉元素。
- en: Binding an array as data
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数组绑定为数据
- en: One of the most common and popular ways to define data in D3 visualization is
    through the use of JavaScript arrays. For example, say you have multiple data
    elements stored in an array, and you want to generate corresponding visual elements
    to represent each and every one of them. Additionally, when the data array gets
    updated, you want your visualization to reflect such changes immediately. In this
    recipe, we will accomplish this common approach.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 D3 可视化中定义数据最常见和最受欢迎的方法是通过使用 JavaScript 数组。例如，假设你有一个数组中存储了多个数据元素，并且你想要生成相应的视觉元素来表示每一个。此外，当数据数组更新时，你希望你的可视化能够立即反映这些变化。在这个菜谱中，我们将完成这个常见的做法。
- en: Getting Ready
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的网络浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/array-as-data.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/array-as-data.html)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/array-as-data.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/array-as-data.html)'
- en: How to do it...
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The first and most natural solution that might come to mind is iterating through
    the data array elements and generating their corresponding visual elements on
    the page. This is definitely a valid solution and it will work with D3, however,
    the enter-update-exit pattern we discussed in the introduction provides a much
    easier and more efficient way to generate visual elements. Let''s have a look
    at how we do that:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 可能首先想到的第一个和最自然的解决方案是遍历数据数组元素，并在页面上生成它们对应的视觉元素。这绝对是一个有效的解决方案，并且它将使用 D3 工作得很好，然而，我们在介绍中讨论的
    enter-update-exit 模式提供了一个更简单、更有效的方法来生成视觉元素。让我们看看我们是如何做到这一点的：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This recipe generates the following visual output:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱生成以下视觉输出：
- en: '![How to do it...](img/2162OS_03_05.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/2162OS_03_05.jpg)'
- en: Data as Array
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 数据作为数组
- en: How it works...
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this example, data (a list of integers in this case) is stored in a simple
    JavaScript array as shown on the line marked as `A` with an arrow left of it.
    The `render` function is defined on the line marked as `B` so that it can be repeatedly
    invoked to update our visualization. The `Enter` selection implementation starts
    on the line marked as `C`, which selects all `div` elements on the web page with
    `h-bar` CSS class. You are probably wondering why we are selecting these `div`
    elements since they don''t even exist on the web page yet. This is in fact true;
    however, the selection at this point is used to define the visual set we discussed
    in the introduction. By issuing this selection that we made in the previous line
    we are essentially declaring that there should be a set of `div.h-bar` elements
    on the web page to form our visual set. On the line marked as `D`, we invoke the
    `data` function on this initial selection to bind the array as our data set to
    the to-be-created visual elements. Once the two sets are defined, the `enter()`
    function can be used to select all data elements that are not yet visualized.
    When the `render` function is invoked for the very first time, it returns all
    elements in the data array, as shown in the following code snippet:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，数据（在这种情况下是一个整数列表）存储在简单的 JavaScript 数组中，如标记为 `A` 的行所示，其左侧有一个箭头。`render`
    函数定义在标记为 `B` 的行上，以便它可以被重复调用以更新我们的可视化。`Enter` 选择实现从标记为 `C` 的行开始，选择网页上所有具有 `h-bar`
    CSS 类的 `div` 元素。你可能想知道为什么我们要选择这些 `div` 元素，因为它们甚至还没有在网页上存在。这实际上是正确的；然而，在这个阶段的这个选择是用来定义我们在介绍中讨论的视觉集。通过发出我们在上一行所做的这个选择，我们实际上是在声明应该在网页上有一组
    `div.h-bar` 元素来形成我们的视觉集。在标记为 `D` 的行上，我们调用这个初始选择上的 `data` 函数，将数组作为数据集绑定到即将创建的视觉元素。一旦定义了这两个集合，就可以使用
    `enter()` 函数来选择所有尚未可视化的数据元素。当 `render` 函数第一次被调用时，它返回数据数组中的所有元素，如下面的代码片段所示：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: On line `F`, a new `div` element is created and appended to the `body` element
    of each data element selected in the `enter` function; this essentially creates
    one `div` element for each data element. Finally, on line `G`, an element called
    `span` is created and appended to the `div` element and we set its CSS class to
    `h-bar`. At this point, we have basically created the skeleton of our visualization
    including empty `div` and `span` elements. Next step is to change the visual attributes
    of our elements based on the given data.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在行 `F` 上，创建了一个新的 `div` 元素，并将其附加到 `enter` 函数中选中的每个数据元素的 `body` 元素上；这实际上为每个数据元素创建了一个
    `div` 元素。最后，在行 `G` 上，创建了一个名为 `span` 的元素并将其附加到 `div` 元素上，我们将其 CSS 类设置为 `h-bar`。到此为止，我们基本上已经创建了可视化结构的骨架，包括空的
    `div` 和 `span` 元素。下一步是根据给定的数据更改元素的视觉属性。
- en: Tip
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: D3 injects a property to the DOM element named `__data__` to make data sticky
    with visual elements so when selections are made using a modified data set, D3
    can compute the difference and intersection correctly. You can see this property
    easily if you inspect the DOM element either visually using a debugger or programmatically.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: D3 向 DOM 元素注入一个名为 `__data__` 的属性，以便使数据与视觉元素粘合，因此当使用修改后的数据集进行选择时，D3 可以正确地计算差异和交集。如果您检查
    DOM 元素，无论是通过调试器进行视觉检查还是通过编程方式，都可以轻松地看到这个属性。
- en: '![How it works...](img/2162OS_03_11.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/2162OS_03_11.jpg)'
- en: As illustrated by the preceding screenshot, this is a very useful fact to know
    when you are debugging your visualization implementation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，当你调试可视化实现时，了解这一点非常有用。
- en: 'In the `Update` section of `array-as-data.html`, the first two lines are identical
    to what we have done in the `Enter` section, and this essentially defines our
    data set and visual set respectively. The major difference here is on line `H`.
    Instead of calling the `enter` function, as we did in the code mentioned under
    `Enter` in the previous paragraphs, in the `Update` mode we directly apply modifier
    functions to the selection made by the `data` function. In the `Update` mode,
    `data` function returns the intersection between the data set and visual set (A∩B).
    On line `H`, we apply a dynamic style attribute `width` to be three times the
    integer value associated with each visual element shown in the following code
    snippet:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在`array-as-data.html`的`Update`部分，前两行与我们之前在`Enter`部分所做的是相同的，这本质上定义了我们的数据集和视觉集。这里的主要区别在于行`H`。在`Update`模式下，我们直接将修饰函数应用到`data`函数所做的选择上，而不是像在前面段落中提到的`Enter`代码那样调用`enter`函数。在`Update`模式下，`data`函数返回数据集和视觉集的交集（A∩B）。在行`H`上，我们应用了一个动态样式属性`width`，其值是以下代码片段中显示的每个视觉元素的整数值的3倍：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: All D3 modifier functions accept this type of dynamic function to compute its
    value on the fly. This is precisely what it means to "data drive" your visualization.
    Hence, it is crucial to understand what this function is designed to achieve in
    our example. This function receives a parameter `d`, which is the datum associated
    with the current element. In our example, the first `div` bar has the value `10`
    associated as its datum, while the second bar has `15`, and so on. Therefore,
    this function essentially computes a numeric value that is three times the datum
    for each bar and returns it as the `width` in pixels.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 所有D3修饰函数都接受这种类型的动态函数来实时计算其值。这正是“数据驱动”你的可视化的含义。因此，理解这个函数在我们例子中的设计目的是至关重要的。这个函数接收一个参数`d`，它是与当前元素关联的数据。在我们的例子中，第一个`div`条形图具有与其数据关联的值`10`，而第二个条形图有`15`，依此类推。因此，这个函数本质上计算了一个数值，它是每个条形图数据的3倍，并将其作为像素值返回`width`。
- en: Another interesting point worth mentioning here is on line `I`, where we mention
    the `span` attribute. The child `span` element can also use dynamic modifier functions
    and has access to the same datum propagated from its parent element. This is the
    default behavior of D3 data binding. Any element you append to a data-bound element
    automatically inherits the parent's datum.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 值得在此一提的另一个有趣点是关于行`I`，我们提到了`span`属性。子`span`元素也可以使用动态修饰函数，并且可以访问从其父元素传播来的相同数据。这是D3数据绑定的默认行为。任何附加到数据绑定元素的元素都会自动继承父元素的数据。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The **dynamic modifier function** actually accepts two parameters `d` and `i`.
    The first parameter `d` is the associated datum we have discussed here and `i`
    is a zero-based index number for the current element. Some recipes in the previous
    chapter have relied on this index, and in the rest of this chapter, we will see
    other recipes that utilize this index in different ways.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**动态修饰函数**实际上接受两个参数`d`和`i`。第一个参数`d`是我们在这里讨论的关联数据，而`i`是当前元素的零基于索引号。前一章的一些食谱依赖于这个索引，在本章的其余部分，我们将看到其他利用这个索引以不同方式的应用食谱。'
- en: 'This is the raw HTML code resulted from this update process:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是更新过程产生的原始HTML代码：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Elements created and appended in the `enter` mode, that is, on line `F` and
    `G`, are automatically added to the `update` set. So, there is no need to repeat
    visual attributes modification logic in both `enter` and `update` section of code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在`enter`模式下创建并附加的元素，即行`F`和`G`，会自动添加到`update`集中。因此，不需要在代码的`enter`和`update`部分重复视觉属性修改逻辑。
- en: 'The last section—`Exit` section—is fairly simple as shown here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的部分——`Exit`部分——如所示相当简单：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tip
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The selection returned by the `exit()` function is just like any other selection.
    Therefore, although `remove` is the most common action used against the `exit`
    selection, you can also apply other modifiers or transitions to this selection.
    We will explore some of these options in later chapters.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`exit()`函数返回的选择与任何其他选择一样。因此，尽管`remove`是对`exit`选择最常用的操作，但你也可以将其他修饰符或过渡应用到这个选择上。我们将在后面的章节中探讨一些这些选项。'
- en: On line `J`, the `exit()` function is called to compute the set difference of
    all visual elements that are no longer associated with any data. Finally, the
    `remove()` function is called on this selection to remove all the elements selected
    by the `exit()` function. This way, as long as we call the `render()` function
    after we change our data, we can always ensure that our visual representation
    and data are kept synchronized.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在行 `J` 上，调用 `exit()` 函数来计算所有不再与任何数据关联的可视元素集合的差异。最后，在这个选择集上调用 `remove()` 函数来移除由
    `exit()` 函数选中的所有元素。这样，只要我们在更改数据后调用 `render()` 函数，我们总能确保我们的视觉表示和数据保持同步。
- en: 'Now, the last block of code is as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最后的代码块如下：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: On line `K`, a simple function called `function()` was created to remove the
    top element in the data array using the `shift` function, while appending a random
    integer to the data array using the `push()` function every 1.5 seconds. Once
    the data array is updated, the `render()` function is called again to update our
    visualization keeping it synchronized with the new data set. This is what gives
    our example its animated bar chart look.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在行 `K` 上，创建了一个简单的函数 `function()`，使用 `shift` 函数移除数据数组中的顶部元素，同时使用 `push()` 函数每1.5秒向数据数组中添加一个随机整数。一旦数据数组更新，就再次调用
    `render()` 函数来更新我们的可视化，使其与新数据集保持同步。这就是我们的示例具有动画条形图外观的原因。
- en: Binding object literals as data
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将对象字面量绑定为数据
- en: With a more complex visualization, each element we have in a data array might
    not be a primitive integer value or a string, but a JavaScript object themselves.
    In this recipe, we will discuss how this more complex data structure can be leveraged
    to drive your visualization using D3.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在更复杂的可视化中，数据数组中的每个元素可能不是原始整数值或字符串，而是一个JavaScript对象本身。在这个配方中，我们将讨论如何利用这种更复杂的数据结构来驱动使用D3的可视化。
- en: Getting Ready
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/object-as-data.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/object-as-data.html)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/object-as-data.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/object-as-data.html)'
- en: How to do it...
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'JavaScript object literal is probably the most common data structure you will
    encounter when loading data sources on the Web. In this recipe, we will look at
    how these JavaScript objects can be leveraged to generate rich visualization.
    Here is how to do it in code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript对象字面量可能是您在Web上加载数据源时遇到的最常见的数据结构。在这个配方中，我们将探讨如何利用这些JavaScript对象来生成丰富的可视化。以下是代码实现方式：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This recipe generates the following visualization:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方生成了以下可视化：
- en: '![How to do it...](img/2162OS_03_06.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![如何实现...](img/2162OS_03_06.jpg)'
- en: Data as Object
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 数据作为对象
- en: How it works...
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this recipe, instead of simple integers as in the previous recipe, now our
    data array is filled with objects (see the line marked as `A` with an arrow left
    to it). Each data object contains two attributes—`width` and `color`—that are
    both integers in this case.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，与上一个配方中的简单整数不同，现在我们的数据数组填充了对象（见带有箭头指向的标记为 `A` 的行）。每个数据对象包含两个属性——`width`
    和 `color`——在这个例子中这两个属性都是整数。
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: This recipe is built on top of the previous recipe so if you are not familiar
    with the fundamental enter-update-exit selection pattern, please review the previous
    recipe first.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方建立在之前的配方之上，所以如果您不熟悉基本的enter-update-exit选择模式，请首先查看之前的配方。
- en: var data = [ // <- A
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: var data = [ // <- A
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: On line `B`, we have a complicated-looking color scale defined. Scales, including
    color scale, will be discussed in depth in the next chapter, so for now let us
    just assume this is a scale function we can use to produce CSS-compatible color
    code given some integer input value. This is sufficient for the purpose of this
    recipe.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在行 `B` 上，定义了一个看起来很复杂的颜色比例。包括颜色比例在内的比例将在下一章中深入讨论，所以现在我们假设这是一个我们可以使用它来生成CSS兼容颜色代码的函数，给定一些整数输入值。这对于本配方来说是足够的。
- en: 'The major difference between this recipe and the previous one is how data is
    handled as shown on line `C`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一个配方相比，这个配方的主要区别在于如何处理数据，如行 `C` 所示：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As we can see in the preceding code snippet, in this recipe the datum associated
    with each visual element is actually an object, not an integer. Therefore, we
    can access the `d.width` attribute on line `D`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，在这个配方中，与每个可视元素关联的datum实际上是一个对象，而不是整数。因此，我们可以在行 `D` 上访问 `d.width` 属性。
- en: Tip
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If your object has functions of its own, you can also access them here in a
    dynamic modifier function. This is a convenient way to add some data-specific
    helper functions in your data source. However, beware that since dynamic functions
    are usually invoked numerous times during visualization, the function you rely
    on should be implemented as efficiently as possible. If this is not possible,
    then it is best to preprocess your data before binding them to your visualization
    process.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的对象有自己的函数，您也可以在这里通过动态修改函数访问它们。这是在数据源中添加一些数据特定辅助函数的一种方便方式。然而，请注意，由于动态函数通常在可视化过程中被多次调用，因此您所依赖的函数应该尽可能高效地实现。如果这不可能，那么在将它们绑定到可视化过程之前预处理您的数据是最好的选择。
- en: 'Similarly on line `E`, the `background-color` style can be computed using the
    `d.color` attribute with the color scale we defined earlier:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在行 `E` 上，可以使用 `d.color` 属性以及我们之前定义的颜色尺度来计算 `background-color` 样式：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The child element `span` again inherits its parent's associated datum, and hence,
    it also has access to the same datum object in its dynamic modifier function on
    line `F` setting the textual content to `d.width` attribute.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 子元素 `span` 再次继承了其父元素关联的数据，因此它在其行 `F` 上的动态修改函数中也有权访问相同的数据对象，设置文本内容为 `d.width`
    属性。
- en: This recipe demonstrates how JavaScript objects can easily be bound to visual
    elements using exactly the same method discussed in the previous recipe. This
    is one of the most powerful capabilities of the D3 library; it allows you to re-use
    the same pattern and method to handle different types of data, simple or complex.
    We will see more examples on this topic in the next recipe.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱展示了如何使用与之前菜谱中讨论的完全相同的方法轻松地将JavaScript对象绑定到视觉元素上。这是D3库最强大的功能之一；它允许您使用相同的模式和方式处理不同类型的数据，无论是简单还是复杂。我们将在下一个菜谱中看到更多关于这个主题的例子。
- en: Binding functions as data
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将函数作为数据绑定
- en: One of the benefits of D3's excellent support for functional style JavaScript
    programming is that it allows functions to be treated as data as well. This particular
    feature can offer some very powerful capabilities under certain circumstances.
    This is a more advanced recipe. Don't worry about it if you are new to D3 and
    having some difficulty understanding it at first. Over time, this kind of usage
    will become natural to you.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: D3对函数式JavaScript编程的优秀支持带来的一个好处是，它允许将函数本身作为数据来处理。在特定情况下，这个特性可以提供一些非常强大的功能。这是一个更高级的菜谱。如果您是D3的新手，并且一开始对它有些难以理解，请不要担心。随着时间的推移，这种用法将变得自然。
- en: Getting Ready
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/function-as-data.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/function-as-data.html)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/function-as-data.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/function-as-data.html)'
- en: How to do it...
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'In this recipe, we will explore the possibility of binding functions themselves
    as data to your visual elements. This capability is extremely powerful and flexible
    if used correctly:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨将函数本身作为数据绑定到您的视觉元素上的可能性。如果正确使用，这种能力非常强大且灵活：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This preceding code produces the following bar chart:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码产生了以下条形图：
- en: '![How to do it...](img/2162OS_03_07.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![如何实现...](img/2162OS_03_07.jpg)'
- en: Data as Function
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 数据作为函数
- en: How it works...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we chose to visualize the output of formula `15 + x * x` using
    a series of vertical bars, each of them annotated with its representing integral
    value. This visualization adds a new bar to the right of the previous one every
    one and a half seconds. We can of course implement this visualization using the
    techniques we have discussed in the previous two recipes. So we generated an array
    of integers using the formula, then just appended a new integer from *n* to *n+1*
    every 1.5 seconds before re-rendering the visualization. However, in this recipe,
    we decided to take a more functional approach.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们选择使用一系列垂直条来可视化公式 `15 + x * x` 的输出，每个条目都附有它所代表的积分值。这种可视化每1.5秒在上一条右侧添加一个新的条目。当然，我们可以使用之前两个菜谱中讨论的技术来实现这种可视化。因此，我们使用公式生成一个整数数组，然后在重新渲染可视化之前，每1.5秒从
    *n* 追加一个新的整数到 *n+1*。然而，在这个菜谱中，我们决定采取一种更函数式的方法。
- en: 'This time we started with an empty data array on line `A`. On line `B`, a simple
    function is defined to calculate the result of this formula *15+x^2*. Then on
    line `C`, another function is created to generate the current data set which contains
    *n+1* references to the `next` function. Here is the code for functional data
    definition:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们在行`A`上从一个空的数据数组开始。在行`B`，定义了一个简单的函数来计算公式*15+x^2*的结果。然后在行`C`，创建了一个函数来生成当前数据集，该数据集包含对`next`函数的*n+1*个引用。以下是功能数据定义的代码：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This seems to be a strange setup to achieve our visualizational goal. Let''s
    see how we can leverage all these functions in our visualization code. On line
    `D`, we bind our data to a selection of `div` elements just as we did in previous
    recipes. However, this time the data is not an array but rather the `newData`
    function:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设置似乎是为了达到我们的可视化目标而显得有些奇怪。让我们看看我们如何在可视化代码中利用所有这些函数。在行`D`，我们将数据绑定到`div`元素的选择上，就像我们在之前的食谱中所做的那样。然而，这次数据不是一个数组，而是`newData`函数：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'D3 is pretty flexible when it comes to data. If you provide a function to the
    `data` function, D3 will simply invoke the given function and use the returned
    value of this function as a parameter of the `data` function. In this case, the
    data being returned by the `newData` function is an array of function references.
    As the result of this, now in our dynamic modifier function, on line `E` and `F`,
    the datum `d` that is being passed into these functions are actually references
    to the `next` function, as shown in the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到数据时，D3非常灵活。如果你向`data`函数提供一个函数，D3将简单地调用该函数，并使用该函数返回的值作为`data`函数的参数。在这种情况下，`newData`函数返回的数据是一个函数引用数组。因此，现在在我们的动态修改函数中，在行`E`和`F`，传递给这些函数的数据`d`实际上是`next`函数的引用，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As a reference to a function, `d` can now be invoked with index `i` as the parameter,
    which in turn generates the output of the formula needed for our visualization.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对函数的引用，现在可以使用索引`i`作为参数调用`d`，这反过来又生成了我们可视化所需的公式输出。
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In JavaScript, functions are special objects, so semantically this is exactly
    the same as binding objects as data. Another note on this topic is that data can
    also be considered as functions. Constant values such as integers can be thought
    of as a static function that simply returns what it receives with no modification
    made.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，函数是特殊的对象，因此从语义上讲，这与绑定对象作为数据完全相同。关于这个话题的另一个注意事项是，数据也可以被认为是函数。例如，整数这样的常量值可以被视为一个静态函数，该函数简单地返回它接收的内容，而不进行任何修改。
- en: This technique might not be the most commonly-used technique in visualization,
    but when used properly, it is extremely flexible and powerful, especially when
    you have a fluid data set.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术可能不是可视化中最常用的技术，但使用得当，它非常灵活且强大，尤其是在你有流动数据集时。
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Datum function typically needs to be **idempotent** to make sense. Idempotence
    is the property of being able to apply the same function with the same inputs
    multiple times without changing the result beyond the initial application. For
    more detail on idempotence visit: [http://en.wikipedia.org/wiki/Idempotence](http://en.wikipedia.org/wiki/Idempotence)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 数据函数通常需要是**幂等的**才有意义。幂等性是指能够多次应用相同的函数和相同的输入，而不会改变结果超过初始应用。有关幂等性的更多详细信息，请访问：[http://en.wikipedia.org/wiki/Idempotence](http://en.wikipedia.org/wiki/Idempotence)
- en: Working with arrays
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与数组一起工作
- en: Most of our data is stored in arrays, and we spend a lot of our effort working
    with arrays to format and restructure data. This is why D3 provides a rich set
    of array-oriented utilities functions, making this task a lot easier. In this
    recipe, we will explore some of the most common and helpful utilities in this
    aspect.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的大部分数据都存储在数组中，我们花费了大量精力与数组一起工作，以格式化和重构数据。这就是为什么D3提供了一套丰富的面向数组的实用函数，使得这项任务变得容易得多。在本食谱中，我们将探讨一些在这个方面最常见和最有帮助的实用函数。
- en: Getting Ready
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/working-with-array.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/working-with-array.html)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/working-with-array.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/working-with-array.html)'
- en: How to do it...
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The following code example shows some of the most common and helpful array
    utility functions offered by the D3 library and their effects:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例展示了D3库提供的某些最常见和最有帮助的数组实用函数及其效果：
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding code produces the following output:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码产生以下输出：
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: D3 provides a variety of utility functions to help perform operations on JavaScript
    arrays. Most of them are pretty intuitive and straightforward, however, there
    are a few intrinsic ones. We will discuss them briefly in this section.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: D3 提供了各种实用函数来帮助在 JavaScript 数组上执行操作。大多数都很直观且简单，然而，也有一些是固有的。我们将在此部分简要讨论它们。
- en: 'Given our array as `[3, 2, 11, 7, 6, 4, 10, 8, 15]`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '给定我们的数组为 `[3, 2, 11, 7, 6, 4, 10, 8, 15]`:'
- en: '`d3.min`: This function retrieves the smallest element, that is, `2`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d3.min`: 此函数检索最小元素，即 `2`'
- en: '`d3.max`: This function retrieve the largest element, that is, `15`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d3.max`: 此函数检索最大元素，即 `15`'
- en: '`d3.extent`: This function retrieves both the smallest and the largest element,
    that is, `[2, 15]`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d3.extent`: 此函数检索最小和最大元素，即 `[2, 15]`'
- en: '`d3.sum`: This function retrieves the addition of all elements in the array,
    that is, `66`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d3.sum`: 此函数检索数组中所有元素的总和，即 `66`'
- en: '`d3.medium`: This function finds the medium, that is, `7`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d3.medium`: 此函数找到中值，即`7`'
- en: '`d3.mean`: This function calculates the mean value, that is, `7.33`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d3.mean`: 此函数计算平均值，即 `7.33`'
- en: '`d3.ascending` / `d3.descending`: The `d3` object comes with a built-in comparator
    function that you can use to sort the JavaScript array'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d3.ascending` / `d3.descending`: `d3` 对象提供了一个内置的比较函数，您可以使用它来对 JavaScript 数组进行排序'
- en: '[PRE16]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`d3.quantile`: This function calculates the quantile on an already sorted array
    in ascending order, that is, quantile of `0.25` is `4`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d3.quantile`: 此函数在已排序数组中按升序计算分位数，即 `0.25` 的分位数是 `4`'
- en: '`d3.bisect`: This function finds an insertion point that comes after (to the
    right of) any existing element of an already sorted array, that is, bisect `(array,
    6)` produce `4`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d3.bisect`: 此函数找到一个插入点，该点位于已排序数组中任何现有元素之后（右侧），即 bisect `(array, 6)` 产生 `4`'
- en: '`d3.nest`: D3''s `nest` function can be used to build an algorithm that transforms
    a flat array-based data structure into a hierarchical nested structure, that is,
    particularly suitable for some types of visualization. D3''s `nest` function can
    be configured using the `key` function chained to `nest`, as seen on lines `A`
    and `B`:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d3.nest`: D3 的 `nest` 函数可以用来构建将平铺数组数据结构转换为层次嵌套结构的算法，特别适合某些类型的可视化。D3 的 `nest`
    函数可以通过将 `key` 函数链接到 `nest` 来配置，如行 `A` 和 `B` 所示：'
- en: '[PRE17]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Multiple `key` functions can be provided to generate multiple levels of nesting.
    In our case the nesting consists of two levels, first by the `type` amount and
    then by the `tip` amount, as demonstrated in the output below:'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以提供多个 `key` 函数来生成多个嵌套级别。在我们的例子中，嵌套由两个级别组成，首先是 `type` 数量，然后是 `tip` 数量，如下面的输出所示：
- en: '[PRE18]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Finally, the `entries()` function is used to supply the flat array-based data
    set as shown on line `C`.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，使用 `entries()` 函数提供如行 `C` 所示的基于平铺数组的 dataset。
- en: Filtering with data
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于数据的过滤
- en: Imagine you need to filter D3 selection based on the associated data elements
    so that you can hide/show different sub-datasets based on the user's input. D3
    selection provides a filter function to perform this kind of data-driven filtering.
    In this recipe, we will show you how this can be leveraged to filter visual elements
    in a data-driven fashion.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要根据关联的数据元素过滤 D3 选择，以便根据用户的输入隐藏/显示不同的子数据集。D3 选择提供了一个过滤器函数来执行这种数据驱动的过滤。在本菜谱中，我们将向您展示如何利用这种方式来以数据驱动的方式过滤视觉元素。
- en: Getting Ready
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/data-filter.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/data-filter.html)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/data-filter.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/data-filter.html)'
- en: How to do it...
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following example code shows how data-based filtering can be leveraged
    to highlight different visual elements based on its categorization:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码展示了如何利用基于数据的过滤来根据其分类突出显示不同的视觉元素：
- en: '[PRE19]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding code generates the following visual output once the **Dinning**
    button is clicked:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在点击**Dinning**按钮后，前面的代码生成以下视觉输出：
- en: '![How to do it...](img/2162OS_03_08.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/2162OS_03_08.jpg)'
- en: Data-based Filtering
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 基于数据的过滤
- en: How it works...
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In this recipe, we have a data set consisting of a list of personal expense
    records with `expense` and `category` as attributes, which is shown on the block
    of code marked as `A`. On line `B`, `C`, and `D`, a set of horizontal bars (HTML
    div) were created using the standard enter-update-exit pattern to represent the
    expense records. So far, this recipe is similar to the *Binding object literals
    as data* recipe. Now let''s take a look at line `E`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们有一个数据集，它由一系列个人消费记录组成，这些记录以 `expense` 和 `category` 作为属性，显示在标记为 `A` 的代码块中。在
    `B`、`C` 和 `D` 行，使用标准的 enter-update-exit 模式创建了一组水平条（HTML div），以表示消费记录。到目前为止，这个菜谱与
    *将对象字面量绑定为数据* 的菜谱类似。现在让我们看看 `E` 行：
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'D3 `selection.filter` function takes a function as its parameter. It applies
    the function against every element in the existing selection. The given function
    for `filter` takes two parameters with a hidden reference:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: D3 的 `selection.filter` 函数接受一个函数作为其参数。它将函数应用于现有选择中的每个元素。`filter` 函数提供的函数有两个参数和一个隐藏的引用：
- en: '`d:` It is the datum associated with the current element'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d`：它是与当前元素关联的数据'
- en: '`i`: It is a zero-based index for the current element'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i`：它是当前元素的零基索引'
- en: '`this`: This has the hidden reference points to the current DOM element'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this`：这有一个隐藏的引用，指向当前 DOM 元素'
- en: D3 `selection.filter` function expects the given function to return a Boolean
    value. If the returned value is true, the corresponding element will be included
    into the new selection being returned by the `filter` function. In our example,
    the `filter` function essentially selects all bars that match the user-selected
    category and applies a CSS class `selected` to each one of them. This method provides
    you a powerful way to filter and generate data-driven sub-selection, which you
    can further manipulate or dissect to generate focused visualization.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: D3 的 `selection.filter` 函数期望提供的函数返回一个布尔值。如果返回的值为真，则相应的元素将被包含在由 `filter` 函数返回的新选择中。在我们的例子中，`filter`
    函数实际上选择了所有与用户选择的类别匹配的条形，并将 CSS 类 `selected` 应用到每个条形上。这种方法为你提供了一种强大的方式来过滤和生成数据驱动的子选择，你可以进一步操作或分析以生成专注的视觉化。
- en: Tip
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: D3 `selection.filter` function treats the returned value using JavaScript **truthy**
    and **falsy tests**, thus not exactly expecting a strict Boolean value. What this
    means is that false, null, `0`, "", undefined, and **NaN** (not a number) are
    all treated as false while other things are considered true.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: D3 的 `selection.filter` 函数使用 JavaScript 的 **真值** 和 **假值** 测试处理返回值，因此并不期望严格的布尔值。这意味着
    false、null、`0`、""、undefined 和 **NaN**（非数字）都被视为假，而其他东西被认为是真。
- en: Sorting with data
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于数据的排序
- en: In many cases, it is desirable to sort your visual elements according to the
    data they represent so that you can highlight the significance of different elements
    visually. In this recipe, we will explore how this can be achieved in D3.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，根据数据对视觉元素进行排序是可取的，这样你可以从视觉上突出不同元素的重要性。在这个菜谱中，我们将探讨如何在 D3 中实现这一点。
- en: Getting Ready
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/data-sort.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/data-sort.html)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/data-sort.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/data-sort.html)'
- en: How to do it...
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s see how data-driven sorting and further manipulation can be performed
    using D3\. In this example, we will sort the bar chart we created in the previous
    recipe based on either expense (width) or category using user''s input:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 D3 执行数据驱动的排序和进一步的操作。在这个例子中，我们将根据用户输入对之前菜谱中创建的条形图进行排序，基于支出（宽度）或类别：
- en: '[PRE21]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This preceding code generates sorted horizontal bars as shown in the following
    screenshot:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码生成了如下截图所示的排序后的水平条：
- en: '![How to do it...](img/2162OS_03_09.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/2162OS_03_09.jpg)'
- en: Data-based Sorting
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 基于数据的排序
- en: How it works...
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In this recipe, we set up a simple row-based visualization (in line `B`, `C`,
    and `D`) of some simulated personal expense records containing two attributes:
    `expense` and `category` that are defined on line `A`. This is exactly the same
    as the previous recipe and quite similar to what we have done in the *Binding
    object literals as data* recipe. Once the basics are done, we then select all
    existing bars on line `E` and perform sorting using D3 `selection.sort` function:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们设置了一个简单的基于行的可视化（在行 `B`、`C` 和 `D`），包含一些模拟的个人消费记录，这些记录包含两个属性：`expense`
    和 `category`，它们在行 `A` 上定义。这与之前的菜谱完全相同，并且与我们在 *将对象字面量绑定为数据* 菜谱中所做的工作非常相似。一旦完成基础知识，我们就在行
    `E` 上选择所有现有的条形图并使用 D3 `selection.sort` 函数进行排序：
- en: '[PRE22]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `selection.sort` function accepts a comparator function:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`selection.sort` 函数接受一个比较器函数：'
- en: '[PRE23]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The **comparator** function receives two data elements `a` and `b` to compare,
    returning either a negative, positive, or zero value. If the value is negative,
    `a` will be placed before `b`; if positive, `a` will be placed after `b`; otherwise,
    `a` and `b` are considered equal and the order is **arbitrary**. The `sort()`
    function returns a new selection with all elements sorted in an order which is
    determined by the specified comparator function. The newly-returned selection
    can then be manipulated further to generate the desired visualization.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**比较器**函数接收两个要比较的数据元素 `a` 和 `b`，返回一个负数、正数或零值。如果值为负数，则 `a` 将被放置在 `b` 之前；如果为正数，则
    `a` 将被放置在 `b` 之后；否则，`a` 和 `b` 被视为相等，顺序是**任意的**。`sort()` 函数返回一个新的选择集，其中所有元素按指定的比较器函数确定的顺序排序。新返回的选择集可以进一步操作以生成所需的可视化。'
- en: Tip
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Because `a` and `b` are placed arbitrarily when they are equal, D3 `selection.sort`
    is not guaranteed to be stable, however, it is guaranteed to be consistent with
    your browser's built-in `sort` method on arrays.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 由于当 `a` 和 `b` 相等时它们被任意放置，因此 D3 `selection.sort` 不保证是稳定的，然而，它保证与浏览器内置的数组 `sort`
    方法一致。
- en: Loading data from a server
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从服务器加载数据
- en: It is probably very rare that you will only be visualizing static local data.
    The power of data visualization usually lays on the ability to visualize dynamic
    data typically generated by a server-side program. Since this is a common use
    case, D3 comes with some handy helper functions to make this task as easy as possible.
    In this recipe, we will see how a remote data set can be loaded dynamically, and
    we will update an existing visualization once loaded.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能很少只可视化静态本地数据。数据可视化的力量通常在于能够可视化由服务器端程序生成的动态数据。由于这是一个常见的用例，D3 提供了一些方便的辅助函数，以尽可能简化这项任务。在这个菜谱中，我们将看到如何动态加载远程数据集，并在数据加载后更新现有的可视化。
- en: Getting Ready
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/asyn-data-load.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/asyn-data-load.html)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/asyn-data-load.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/asyn-data-load.html)'
- en: How to do it...
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In the code example of the `asyn-data-load.html` file, we will load data dynamically
    from the server on user''s request, and once the data is loaded, we also update
    our visualization to reflect the new expanded data set. Here is the code where
    we do that:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `asyn-data-load.html` 文件的代码示例中，我们将根据用户请求从服务器动态加载数据，一旦数据加载完成，我们还将更新我们的可视化以反映新的扩展数据集。以下是执行此操作的代码：
- en: '[PRE24]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here is what our `data.json` file looks like:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们 `data.json` 文件的样子：
- en: '[PRE25]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This recipe generates the following visual output after clicking the **Load
    Data from JSON feed** button once:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **从 JSON 提供程序加载数据** 按钮一次后，这个菜谱将生成以下视觉输出：
- en: '![How to do it...](img/2162OS_03_10.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/2162OS_03_10.jpg)'
- en: Data Loading from Server
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 从服务器加载数据
- en: How it works...
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In this recipe, we initially have a local data set defined on the line marked
    as `A`, and a row-based visualization generated by lines `B`, `C`, and `D`. The
    `load` function is defined on line `E` that responds to the user''s click on the
    **Load Data from JSON feed** button, which loads the data from a separate file
    (`data.json`) served by the server. This is achieved by using the `d3.json` function
    as shown on line `F`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们最初在标记为 `A` 的行上定义了一个本地数据集，以及由行 `B`、`C` 和 `D` 生成的基于行的可视化。`load` 函数在行
    `E` 上定义，它响应用户点击 **从 JSON 提供程序加载数据** 按钮，该按钮从服务器提供的单独文件（`data.json`）加载数据。这是通过在行
    `F` 上使用 `d3.json` 函数实现的：
- en: '[PRE26]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Since loading a remote data set from a JSON file could take some time, it is
    performed asynchronously. Once loaded, the data set will be passed to the given
    handler function, which is specified on line `F`. In this function, we simply
    concatenate the newly loaded data with our existing data set, then re-render the
    visualization to update the display.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 由于从 JSON 文件加载远程数据集可能需要一些时间，因此它是异步执行的。一旦加载完成，数据集将被传递给指定的处理函数，该函数在行 `F` 上指定。在这个函数中，我们只是将新加载的数据与现有数据集连接起来，然后重新渲染可视化以更新显示。
- en: Tip
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Similar functions are also provided by D3 to make the loading of CSV, TSV, TXT,
    HTML, and XML data a simple task.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: D3 还提供了类似的功能，使得加载 CSV、TSV、TXT、HTML 和 XML 数据变得简单易行。
- en: If a more customized and specific control is required, the `d3.xhr` function
    can be used to further customize the MIME type and request headers. Behind the
    scenes, `d3.json` and `d3.csv` are both using `d3.xhr` to generate the actual
    request.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要更定制化和具体的控制，可以使用 `d3.xhr` 函数来进一步自定义 MIME 类型和要求头。幕后，`d3.json` 和 `d3.csv` 都是在使用
    `d3.xhr` 来生成实际请求。
- en: Of course this is by no means the only way to load remote data from the server.
    D3 does not dictate how data should be loaded from the remote server. You are
    free to use your favorite JavaScript libraries, for example, jQuery or Zepto.js
    to issue an Ajax request and load a remote data set.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这绝对不是从服务器加载远程数据的唯一方法。D3 并不规定如何从远程服务器加载数据。你可以自由地使用你喜欢的 JavaScript 库，例如 jQuery
    或 Zepto.js 来发起 Ajax 请求并加载远程数据集。
