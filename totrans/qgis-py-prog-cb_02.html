<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02" class="calibre1"/>Chapter 2. Querying Vector Data</h1></div></div></div><p class="calibre9">In this chapter, we will cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem">Loading a vector layer from a file</li><li class="listitem">Loading a vector layer from a geodatabase</li><li class="listitem">Examining vector layer features</li><li class="listitem">Examining vector layer attributes</li><li class="listitem">Filtering a layer by geometry</li><li class="listitem">Filtering a layer by attributes</li><li class="listitem">Buffering a feature</li><li class="listitem">Measuring the distance between two points</li><li class="listitem">Measuring the distance along a line</li><li class="listitem">Calculating the area of a polygon</li><li class="listitem">Creating a spatial index</li><li class="listitem">Calculating the bearing of a line</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch02lvl1sec22" class="calibre1"/>Introduction</h1></div></div></div><p class="calibre9">This chapter demonstrates how to work with vector data through Python in QGIS. We will first work through loading different sources of vector data. Next, we'll move on to examining the contents of the data. Then, we'll spend the remainder of the chapter performing spatial and database operations on vector data.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec23" class="calibre1"/>Loading a vector layer from a file sample</h1></div></div></div><p class="calibre9">This recipe <a id="id98" class="calibre1"/>describes the most common type of data used in<a id="id99" class="calibre1"/> QGIS, a file. In most cases, you'll start a QGIS project by loading a shapefile.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec54" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">For ease of following the examples in this book, it is recommended that you create a directory called <code class="literal">qgis_data</code> in your root or user directory, which provides a short pathname. This setup will help prevent the occurrence of any frustrating errors resulting from path-related issues on a given system. In this recipe and others, we'll use a point shapefile of New York City museums, which you can download from <a class="calibre1" href="https://geospatialpython.googlecode.com/svn/NYC_MUSEUMS_GEO.zip">https://geospatialpython.googlecode.com/svn/NYC_MUSEUMS_GEO.zip</a>.</p><p class="calibre9">Unzip this file and place<a id="id100" class="calibre1"/> the shapfile's contents in a directory named <code class="literal">nyc</code> within your <code class="literal">qgis_data</code> directory.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec55" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">Now, we'll walk<a id="id101" class="calibre1"/> through the steps of loading a shapefile and adding it to the map, as follows:</p><div><ol class="orderedlist"><li class="listitem" value="1">Start QGIS.</li><li class="listitem" value="2">From the <strong class="calibre2">Plugins</strong> menu, select <strong class="calibre2">Python Console</strong>.</li><li class="listitem" value="3">In the Python console, create the layer:<div><pre class="programlisting"><strong class="calibre2">layer = QgsVectorLayer("/qgis_data/nyc/NYC_MUSEUMS_GEO.shp", "New York City Museums", "ogr")</strong>
</pre></div></li><li class="listitem" value="4">Next, ensure that the layer was created as expected:<div><pre class="programlisting"><strong class="calibre2">if not layer.isValid():</strong>
<strong class="calibre2">  print "Layer %s did not load" % layer.name()</strong>
</pre></div></li><li class="listitem" value="5">Finally, add the layer to the layer registry:<div><pre class="programlisting"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayers([layer])</strong>
</pre></div></li></ol><div></div><p class="calibre9">Verify that your QGIS map looks similar to the following image:</p><div><img src="img/00017.jpeg" alt="How to do it..." class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec56" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The <code class="literal">QgsVectorLayer</code> object requires the location of the file, a name for the layer in QGIS, and a data provider that provides the right parser and capabilities managed for the file format. Most vector layers are covered by the <code class="literal">ogr</code> data provider, which attempts to guess the format from the file name extension in order to use the appropriate driver. The formats available with this data<a id="id102" class="calibre1"/> provider are listed at <a class="calibre1" href="http://www.gdal.org/ogr_formats.html">http://www.gdal.org/ogr_formats.html</a>.</p><p class="calibre9">Once we have created the <code class="literal">QgsVector</code> object, we do a quick check using the <code class="literal">layer.isValid()</code> method to<a id="id103" class="calibre1"/> see whether the file was loaded properly. We won't use this method in every recipe to keep the code short, but this method is often very important. It's usually the only indication that something has gone wrong. If you have a typo in the filename or <a id="id104" class="calibre1"/>you try to connect to an online data source but have no network connection, you won't see any errors. Your first indication will be another method failing further into your code, which will make tracking down the root cause more difficult.</p><p class="calibre9">In the last line, we <a id="id105" class="calibre1"/>add the vector layer to the <code class="literal">QgsMapLayerRegistry</code>, which makes it available on the map. The registry keeps track of all the layers in the project. The reason why QGIS works this way is so you can load multiple layers, style them, filter them, and do other operations before exposing them to the user on the map.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec24" class="calibre1"/>Loading a vector layer from a spatial database</h1></div></div></div><p class="calibre9">The PostGIS geodatabase is based on the open source Postgres database. The geodatabase<a id="id106" class="calibre1"/> provides powerful geospatial data management and operations. PyQGIS fully supports PostGIS as a data source. In this recipe, we'll add a layer from a PostGIS database.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec57" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">Installing and <a id="id107" class="calibre1"/>configuring PostGIS is beyond the scope of this book, so we'll use a sample geospatial database interface from the excellent service <a class="calibre1" href="http://www.QGISCloud.com">www.QGISCloud.com</a>. <a class="calibre1" href="http://www.QGISCloud.com">www.QGISCloud.com</a> has its own Python plugin called <a id="id108" class="calibre1"/>
<strong class="calibre2">QGIS Cloud</strong>. You can sign up for free and create your own geodatabase online by following the site's instructions, or you can use the example used in the recipe.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec58" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">Perform the<a id="id109" class="calibre1"/> following steps to load a PostGIS layer into a QGIS map:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, create a new <code class="literal">DataSourceURI</code> instance:<div><pre class="programlisting"><strong class="calibre2">uri = QgsDataSourceURI()</strong>
</pre></div></li><li class="listitem" value="2">Next, create the database connection string:<div><pre class="programlisting"><strong class="calibre2">uri.setConnection("spacialdb.com", "9999", "lzmjzm_hwpqlf", "lzmjzm_hwpqlf", "0e9fcc39")</strong>
</pre></div></li><li class="listitem" value="3">Now, describe the data source:<div><pre class="programlisting"><strong class="calibre2">uri.setDataSource("public", "islands", "wkb_geometry", "")</strong>
</pre></div></li><li class="listitem" value="4">Then, create the layer:<div><pre class="programlisting"><strong class="calibre2">layer = QgsVectorLayer(uri.uri(), "Islands", "postgres")</strong>
</pre></div></li><li class="listitem" value="5">Just to be safe, make sure everything works:<div><pre class="programlisting"><strong class="calibre2">if not layer.isValid():</strong>
<strong class="calibre2">  print "Layer %s did not load" % layer.name()</strong>
</pre></div></li><li class="listitem" value="6">Finally, add the layer to the map if everything is okay:<div><pre class="programlisting"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayers([layer])</strong>
</pre></div></li></ol><div></div><p class="calibre9">You can see the <code class="literal">islands</code> layer in the map, as shown in the following screenshot:</p><div><img src="img/00018.jpeg" alt="How to do it..." class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec59" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">PyQGIS provides an object in the API to create a PostGIS data source in <code class="literal">QgsDataSourceURI()</code>. The <code class="literal">connection</code> string parameters in the second line of code are the database server, port, database name, user, and password. In the example, the database, username, and <a id="id110" class="calibre1"/>password are randomly <a id="id111" class="calibre1"/>generated unique names. The data source parameters are the schema name, table name, geometry column, and an optional SQL <code class="literal">WHERE</code> to subset the layer as needed.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec25" class="calibre1"/>Examining vector layer features</h1></div></div></div><p class="calibre9">Once a<a id="id112" class="calibre1"/> vector layer is loaded, you may want to investigate the data. In<a id="id113" class="calibre1"/> this recipe, we'll load a vector point layer from a shapefile and take a look at the <em class="calibre10">x</em> and <em class="calibre10">y</em> values of the first point.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec60" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">We'll use the same New York City Museums layer from <em class="calibre10">Loading a vector layer from a file</em> recipe in this chapter. You can download the layer from <a class="calibre1" href="https://geospatialpython.googlecode.com/svn/NYC_MUSEUMS_GEO.zip">https://geospatialpython.googlecode.com/svn/NYC_MUSEUMS_GEO.zip</a>.</p><p class="calibre9">Unzip that file and place the shapefile's contents in a directory named <code class="literal">nyc</code> within your <code class="literal">qgis_data</code> directory, within your root or home directory.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec61" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">In this recipe, we will load the layer, get the features, grab the first feature, obtain its geometry, and take a look at the values for the first point:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, load the layer:<div><pre class="programlisting"><strong class="calibre2">layer = QgsVectorLayer("/qgis_data/nyc/NYC_MUSEUMS_GEO.shp", "New York City Museums", "ogr")</strong>
</pre></div></li><li class="listitem" value="2">Next, get an iterator of the layer's features:<div><pre class="programlisting"><strong class="calibre2">features = layer.getFeatures()</strong>
</pre></div></li><li class="listitem" value="3">Now, get the first feature from the iterator:<div><pre class="programlisting"><strong class="calibre2">f = features.next()</strong>
</pre></div></li><li class="listitem" value="4">Then, get the feature's geometry:<div><pre class="programlisting"><strong class="calibre2">g = f.geometry()</strong>
</pre></div></li><li class="listitem" value="5">Finally, get the point's values:<div><pre class="programlisting"><strong class="calibre2">g.asPoint()</strong>
</pre></div></li><li class="listitem" value="6">Verify that the<a id="id114" class="calibre1"/> Python console output is similar to the following QgsPoint object:<div><pre class="programlisting"><strong class="calibre2">(-74.0138,40.7038)</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec62" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">When you<a id="id115" class="calibre1"/> access a layer's features or geometry using the previously demonstrated methods, PyQGIS returns a Python iterator. The iterator data structure allows Python to work efficiently with very large data sets without keeping the entire dataset in memory.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec26" class="calibre1"/>Examining vector layer attributes</h1></div></div></div><p class="calibre9">A true GIS layer<a id="id116" class="calibre1"/> contains both spatial geometry and database<a id="id117" class="calibre1"/> attributes. In this recipe, we'll access a vector point layer's attributes in PyQGIS. We'll use a file-based layer from a shapefile, but once a layer is loaded in QGIS, every vector layer works the same way.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec63" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">Once again, we'll use the same New York City Museums layer from the<em class="calibre10"> Loading a vector layer from a file</em> recipe in this chapter. You can download the layer from <a class="calibre1" href="https://geospatialpython.googlecode.com/svn/NYC_MUSEUMS_GEO.zip">https://geospatialpython.googlecode.com/svn/NYC_MUSEUMS_GEO.zip</a>.</p><p class="calibre9">Unzip that file and place the shapefile's contents in a directory named <code class="literal">nyc</code> within your <code class="literal">qgis_data </code>directory, within your root or home directory.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec64" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">In the following steps, we'll load<a id="id118" class="calibre1"/> the layer, access the <code class="literal">features</code> iterator, grab the first feature, and then view the attributes as a Python list:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, load the shapefile as a vector layer:<div><pre class="programlisting"><strong class="calibre2">layer = QgsVectorLayer("/qgis_data/nyc/NYC_MUSEUMS_GEO.shp", "New York City Museums", "ogr")</strong>
</pre></div></li><li class="listitem" value="2">Next, get the features iterator:<div><pre class="programlisting"><strong class="calibre2">features = layer.getFeatures()</strong>
</pre></div></li><li class="listitem" value="3">Now, grab the first feature from the iterator:<div><pre class="programlisting"><strong class="calibre2">f = features.next()</strong>
</pre></div></li><li class="listitem" value="4">Finally, examine the attributes as a Python list:<div><pre class="programlisting"><strong class="calibre2">f.attributes()</strong>
</pre></div></li><li class="listitem" value="5">Verify that the Python console's output resembles the following list:<div><pre class="programlisting"><strong class="calibre2">[u'Alexander Hamilton U.S. Custom House', u'(212) 514-3700', u'http://www.oldnycustomhouse.gov/', u'1 Bowling Grn', NULL, u'New York', 10004.0, -74.013756, 40.703817]</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec65" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">Examining<a id="id119" class="calibre1"/> attributes is consistent with accessing the point values of a layer's geometry. Note that all string attribute values are returned as unicode strings, which is the case for all QGIS strings. Unicode allows the internationalization (that is, translation) of QGIS for other languages besides English.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch02lvl2sec66" class="calibre1"/>There's more...</h2></div></div></div><p class="calibre9">The attribute values don't mean much without the knowledge of what those values represent. You will also need to know the fields. You can get the fields as a list by accessing the <code class="literal">fields</code> iterator and calling the <code class="literal">name()</code> method for each field. This operation is easily accomplished with a Python list comprehension:</p><div><pre class="programlisting"><strong class="calibre2">[c.name() for c in f.fields().toList()]</strong>
</pre></div><p class="calibre9">This example returns the following result:</p><div><pre class="programlisting"><strong class="calibre2">[u'NAME', u'TEL', u'URL', u'ADRESS1', u'ADDRESS2', u'CITY', u'ZIP', u'XCOORD', u'YCOORD']</strong>
</pre></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec27" class="calibre1"/>Filtering a layer by geometry</h1></div></div></div><p class="calibre9">In this recipe, we'll perform a spatial operation to select a subset of a point layer based on the points contained in an<a id="id120" class="calibre1"/> overlapping polygon layer. We'll use shapefiles in both cases, with one being a point layer and the other a polygon. This kind of subset is one of the most common GIS operations.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec67" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">We will need two new shapefiles that have not been used in previous recipes. You can download the p<a id="id121" class="calibre1"/>oint layer from <a class="calibre1" href="https://geospatialpython.googlecode.com/files/MSCities_Geo_Pts.zip">https://geospatialpython.googlecode.com/files/MSCities_Geo_Pts.zip</a>.</p><p class="calibre9">Similarly, you can download<a id="id122" class="calibre1"/> the geometry layer from <a class="calibre1" href="https://geospatialpython.googlecode.com/files/GIS_CensusTract.zip">https://geospatialpython.googlecode.com/files/GIS_CensusTract.zip</a>.</p><p class="calibre9">Unzip these shapefiles and place them in a directory named <code class="literal">ms</code> within your <code class="literal">qgis_data</code> directory, within your root or home directory.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec68" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">In this recipe, we will perform several steps to select features in the point layer that fall within the polygon layer, as follows:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, load the point layer:<div><pre class="programlisting"><strong class="calibre2">lyrPts = QgsVectorLayer("/qgis_data/ms/MSCities_Geo_Pts.shp", "MSCities_Geo_Pts", "ogr")</strong>
</pre></div></li><li class="listitem" value="2">Next, load the polygon layer:<div><pre class="programlisting"><strong class="calibre2">lyrPoly = QgsVectorLayer("/qgis_data/ms/GIS_CensusTract_poly.shp", "GIS_CensusTract_poly", "ogr")</strong>
</pre></div></li><li class="listitem" value="3">Add the layers to the map using a list:<div><pre class="programlisting"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayers([lyrPts,lyrPoly])</strong>
</pre></div></li><li class="listitem" value="4">Access the polygon layer's features:<div><pre class="programlisting"><strong class="calibre2">ftsPoly = lyrPoly.getFeatures()</strong>
</pre></div></li><li class="listitem" value="5">Now, iterate through the polygon's features:<div><pre class="programlisting"><strong class="calibre2">for feat in ftsPoly:</strong>
</pre></div></li><li class="listitem" value="6">Grab each feature's geometry:<div><pre class="programlisting"><strong class="calibre2">    geomPoly = feat.geometry() </strong>
</pre></div></li><li class="listitem" value="7">Access the point features and filter the point features by the polygon's bounding box:<div><pre class="programlisting"><strong class="calibre2">    featsPnt = lyrPts.getFeatures(QgsFeatureRequest().setFilterRect(geomPoly.boundingBox()))</strong>
</pre></div></li><li class="listitem" value="8">Iterate through each point and check whether it's within the polygon itself:<div><pre class="programlisting"><strong class="calibre2">    for featPnt in featsPnt:</strong>
<strong class="calibre2">        if featPnt.geometry().within(geomPoly):</strong>
</pre></div></li><li class="listitem" value="9">If the polygon contains the point, print the point's ID and select the point:<div><pre class="programlisting"><strong class="calibre2">            print featPnt.id()</strong>
<strong class="calibre2">            lyrPts.select(featPnt.id())</strong>
</pre></div></li><li class="listitem" value="10">Now, set the polygon layer as the active map layer:<div><pre class="programlisting"><strong class="calibre2">iface.setActiveLayer(lyrPoly)</strong>
</pre></div></li><li class="listitem" value="11">Zoom to the polygon layer's maximum extent:<div><pre class="programlisting"><strong class="calibre2">iface.zoomToActiveLayer()</strong>
</pre></div></li></ol><div></div><p class="calibre9">Verify that your<a id="id123" class="calibre1"/> map looks similar to the following image:</p><div><img src="img/00019.jpeg" alt="How to do it..." class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec69" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">While QGIS has a number of tools for spatial selection, PyQGIS doesn't have a dedicated API for these types of functions. However, there are just enough methods in the API, thanks to the underlying <code class="literal">ogr/GEOS</code> library, that you can easily create your own spatial filters for two<a id="id124" class="calibre1"/> layers. Step 7 isn't entirely necessary, but we gain some efficiency using the bounding box of the polygon to limit the number of point features we're examining. Calculations involving rectangles are far quicker than detailed point-in-polygon queries. So, we quickly reduce the number of points we need to iterate through for the more expensive spatial operations.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec28" class="calibre1"/>Filtering a layer by attributes</h1></div></div></div><p class="calibre9">In addition to the spatial queries outlined in the previous recipe, we can also subset a layer by its attributes. This<a id="id125" class="calibre1"/> type of query resembles a more traditional relational database query and in fact uses SQL statements. In this recipe, we will filter a point shapefile-based layer by an attribute.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec70" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">We'll use the same New York City Museums layer used in the previous recipes in this chapter. You can download the layer from <a class="calibre1" href="https://geospatialpython.googlecode.com/svn/NYC_MUSEUMS_GEO.zip">https://geospatialpython.googlecode.com/svn/NYC_MUSEUMS_GEO.zip</a>.</p><p class="calibre9">Unzip that file and place the shapefile's contents in a directory named <code class="literal">nyc</code>
 within your <code class="literal">qgis_data</code> directory, within your root or home directory.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec71" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">In this recipe, we'll filter the layer by an attribute, select the filtered features, and zoom to them, as follows:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we load the point layer:<div><pre class="programlisting"><strong class="calibre2">lyrPts = QgsVectorLayer("/qgis_data/nyc/NYC_MUSEUMS_GEO.shp", "Museums", "ogr")</strong>
</pre></div></li><li class="listitem" value="2">Next, we add the layer to the map in order to visualize the points:<div><pre class="programlisting"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayers([lyrPts])</strong>
</pre></div></li><li class="listitem" value="3">Now, we filter the point layer to points with attributes that match a specific zip code:<div><pre class="programlisting"><strong class="calibre2">selection = lyrPts.getFeatures(QgsFeatureRequest().setFilterExpression(u'"ZIP" = 10002'))</strong>
</pre></div></li><li class="listitem" value="4">Then, we use a list comprehension to create a list of feature IDs that are fed to the feature selection method:<div><pre class="programlisting"><strong class="calibre2">lyrPts.setSelectedFeatures([s.id() for s in selection])</strong>
</pre></div></li><li class="listitem" value="5">Finally, we zoom to the selection:<div><pre class="programlisting"><strong class="calibre2">iface.mapCanvas().zoomToSelected()</strong>
</pre></div></li></ol><div></div><p class="calibre9">Verify that the point layer has three selected features, shown in yellow.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec72" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">This recipe takes advantage of QGIS filter expressions, highlighted in step 3. These filter expressions are a subset of SQL. The <code class="literal">QgsFeatureRequest</code> handles the query expression as an optional argument to return an iterator with just the features you want. These queries also allow <a id="id126" class="calibre1"/>some basic geometry manipulation. This recipe also introduces the <code class="literal">mapCanvas().zoomToSelected()</code> method, which is a convenient way to set the map's extent to the features of interest.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec29" class="calibre1"/>Buffering a feature intermediate</h1></div></div></div><p class="calibre9">Buffering a feature<a id="id127" class="calibre1"/> creates a polygon around a feature as a selection geometry or just a simple visualization. In this recipe, we'll buffer a point in a point feature and add the returned polygon geometry to the map.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec73" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">Once again, we'll use the same New York City Museums layer. You can download the layer from <a class="calibre1" href="https://geospatialpython.googlecode.com/svn/NYC_MUSEUMS_GEO.zip">https://geospatialpython.googlecode.com/svn/NYC_MUSEUMS_GEO.zip</a>.</p><p class="calibre9">Unzip that file and place the shapefile's contents in a directory named <code class="literal">nyc</code>
 within your <code class="literal">qgis_data</code> directory, within your root or home directory.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec74" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">This recipe involves both a spatial operation and multiple visualizations. To do this, perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, load the layer:<div><pre class="programlisting"><strong class="calibre2">lyr = QgsVectorLayer("/qgis_data/nyc/NYC_MUSEUMS_GEO.shp", "Museums", "ogr")</strong>
</pre></div></li><li class="listitem" value="2">Next, visualize the layer on the map:<div><pre class="programlisting"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayers([lyr])</strong>
</pre></div></li><li class="listitem" value="3">Access the layer's features:<div><pre class="programlisting"><strong class="calibre2">fts = lyr.getFeatures()</strong>
</pre></div></li><li class="listitem" value="4">Grab the first feature:<div><pre class="programlisting"><strong class="calibre2">ft = fts.next()</strong>
</pre></div></li><li class="listitem" value="5">Select this feature:<div><pre class="programlisting"><strong class="calibre2">lyr.setSelectedFeatures([ft.id()])</strong>
</pre></div></li><li class="listitem" value="6">Create the buffer:<div><pre class="programlisting"><strong class="calibre2">buff = ft.geometry().buffer(.2,8)</strong>
</pre></div></li><li class="listitem" value="7">Set up a memory layer for the buffer's geometry:<div><pre class="programlisting"><strong class="calibre2">buffLyr =  QgsVectorLayer('Polygon?crs=EPSG:4326', 'Buffer' , 'memory')</strong>
</pre></div></li><li class="listitem" value="8">Access the layer's data provider:<div><pre class="programlisting"><strong class="calibre2">pr = buffLyr.dataProvider()</strong>
</pre></div></li><li class="listitem" value="9">Create a new feature:<div><pre class="programlisting"><strong class="calibre2">b = QgsFeature()</strong>
</pre></div></li><li class="listitem" value="10">Set the feature's geometry with the buffer geometry:<div><pre class="programlisting"><strong class="calibre2">b.setGeometry(buff)</strong>
</pre></div></li><li class="listitem" value="11">Add the feature to the data provider:<div><pre class="programlisting"><strong class="calibre2">pr.addFeatures([b])</strong>
</pre></div></li><li class="listitem" value="12">Update the buffer layer's extents:<div><pre class="programlisting"><strong class="calibre2">buffLyr.updateExtents()</strong>
</pre></div></li><li class="listitem" value="13">Set the <a id="id128" class="calibre1"/>buffer layer's transparency so that you can see other features as well:<div><pre class="programlisting"><strong class="calibre2">buffLyr.setLayerTransparency(70)</strong>
</pre></div></li><li class="listitem" value="14">Add the buffer layer to the map:<div><pre class="programlisting"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayers([buffLyr])</strong>
</pre></div></li></ol><div></div><p class="calibre9">Verify that your map looks similar to this screenshot:</p><div><img src="img/00020.jpeg" alt="How to do it..." class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec75" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The interesting portion of this recipe starts with Step 6, which creates the buffer geometry. The parameters for the <a id="id129" class="calibre1"/>
<code class="literal">buffer()</code> method are the distance in map units for the buffer followed by the number of straight line segments used to approximate curves. The more segments you specify, the more the buffer appears like a circle. However, more segments equals <a id="id130" class="calibre1"/>greater geometric complexity and therefore slower rendering, as well as slower geometry calculations. The other interesting feature of this recipe is Step 13, in which we set the transparency of the layer to 70 percent. We also introduce the way to create a new layer, which is done in memory. Later chapters will go more in depth on creating data.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec30" class="calibre1"/>Measuring the distance between two points</h1></div></div></div><p class="calibre9">In the<a id="id131" class="calibre1"/> <code class="literal">QgsDistanceArea</code> object, PyQGIS has excellent capabilities for measuring the distance. We'll use this object for several recipes, starting with measuring the distance between two points.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec76" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">If you don't already have the New York City Museums layer used in the previous recipes in this chapter, download the layer from <a class="calibre1" href="https://geospatialpython.googlecode.com/svn/NYC_MUSEUMS_GEO.zip">https://geospatialpython.googlecode.com/svn/NYC_MUSEUMS_GEO.zip</a>.</p><p class="calibre9">Unzip that file and place the shapefile's contents in a directory named <code class="literal">nyc</code>
 within your <code class="literal">qgis_data</code> directory, within your root or home directory.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec77" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">In the <a id="id132" class="calibre1"/>following steps, we'll extract the first and last points in the layer's point order and measure their distance:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, import the library that contains the QGIS contents:<div><pre class="programlisting"><strong class="calibre2">from qgis.core import QGis</strong>
</pre></div></li><li class="listitem" value="2">Then, load the layer:<div><pre class="programlisting"><strong class="calibre2">lyr = QgsVectorLayer("/qgis_data/nyc/NYC_MUSEUMS_GEO.shp", "Museums", "ogr")</strong>
</pre></div></li><li class="listitem" value="3">Access the features:<div><pre class="programlisting"><strong class="calibre2">fts = lyr.getFeatures()</strong>
</pre></div></li><li class="listitem" value="4">Get the first feature:<div><pre class="programlisting"><strong class="calibre2">first = fts.next()</strong>
</pre></div></li><li class="listitem" value="5">Set a placeholder for the last feature:<div><pre class="programlisting"><strong class="calibre2">last = fts.next()</strong>
</pre></div></li><li class="listitem" value="6">Iterate through the features until you get the last one:<div><pre class="programlisting"><strong class="calibre2">for f in fts:</strong>
<strong class="calibre2">  last = f</strong>
</pre></div></li><li class="listitem" value="7">Create a measurement object:<div><pre class="programlisting"><strong class="calibre2">d = QgsDistanceArea()</strong>
</pre></div></li><li class="listitem" value="8">Measure the distance:<div><pre class="programlisting"><strong class="calibre2">m = d.measureLine(first.geometry().asPoint(), last.geometry().asPoint())</strong>
</pre></div></li><li class="listitem" value="9">Convert the measurement value from decimal degrees to meters:<div><pre class="programlisting"><strong class="calibre2">d.convertMeasurement(m, 2, 0, False)</strong>
</pre></div></li><li class="listitem" value="10">Ensure that your Python console output looks similar to this tuple:<div><pre class="programlisting"><strong class="calibre2">(4401.1622240174165, 0)</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec78" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The <code class="literal">QgsDistanceArea</code> object accepts different types of geometry as input. In this case, we use two points. The map units for this layer are in decimal degrees, which isn't meaningful for a distance measurement. So, we use the <code class="literal">QgsDistanceArea.convertMeasurement()</code> method to<a id="id133" class="calibre1"/> covert the output to meters. The parameters for the method are the measurement output, the input units (in decimal degrees), the <a id="id134" class="calibre1"/>output units (meters), and a boolean to denote whether this conversion is an area calculation verses a linear measurement.</p><p class="calibre9">The returned tuple is the measurement value and the units. The value 0 tells us that the output is in meters.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec31" class="calibre1"/>Measuring the distance along a line sample</h1></div></div></div><p class="calibre9">In this recipe, we'll <a id="id135" class="calibre1"/>measure the distance along a line with multiple vertices.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec79" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">For this recipe, we'll use a line shapefile with two features. You can download the shapefile as a <code class="literal">.ZIP</code> file from <a class="calibre1" href="https://geospatialpython.googlecode.com/svn/paths.zip">https://geospatialpython.googlecode.com/svn/paths.zip</a>
</p><p class="calibre9">Unzip the shapefile into a directory named <code class="literal">qgis_data/shapes</code> within your root or home directory.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec80" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">The steps for this recipe are fairly straightforward. We'll extract the geometry from the first line feature and pass it to the measurement object, as shown here:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we must load the QGIS constants library:<div><pre class="programlisting"><strong class="calibre2">from qgis.core import QGis</strong>
</pre></div></li><li class="listitem" value="2">Load the line layer:<div><pre class="programlisting"><strong class="calibre2">lyr = QgsVectorLayer("/qgis_data/shapes/paths.shp", "Route", "ogr")</strong>
</pre></div></li><li class="listitem" value="3">Grab the features:<div><pre class="programlisting"><strong class="calibre2">fts = lyr.getFeatures()</strong>
</pre></div></li><li class="listitem" value="4">Get the first feature:<div><pre class="programlisting"><strong class="calibre2">route = fts.next()</strong>
</pre></div></li><li class="listitem" value="5">Create the measurement object instance:<div><pre class="programlisting"><strong class="calibre2">d = QgsDistanceArea()</strong>
</pre></div></li><li class="listitem" value="6">Then, we must configure the QgsDistanceArea object to use the ellipsoidal mode for accurate measurements in meters:<div><pre class="programlisting"><strong class="calibre2">d.setEllipsoidalMode(True)</strong>
</pre></div></li><li class="listitem" value="7">Pass the line's geometry to the <code class="literal">measureLine</code> method:<div><pre class="programlisting"><strong class="calibre2">m = d.measureLine(route.geometry().asPolyline())</strong>
</pre></div></li><li class="listitem" value="8">Convert the measurement output to miles:<div><pre class="programlisting"><strong class="calibre2">d.convertMeasurement(m, QGis.Meters, QGis.NauticalMiles, False)</strong>
</pre></div></li></ol><div></div><p class="calibre9">Ensure that your output looks similar to the following:</p><div><pre class="programlisting"><strong class="calibre2">(2314126.583384674, 7)</strong>
</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec81" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The QgsDistanceArea object can perform any type of measurement, based on the method you call. When you convert the<a id="id136" class="calibre1"/> measurement from meters (represented by 0) to miles (identified by the number 7), you will get a tuple with the measurement in miles and the unit identifier. The<a id="id137" class="calibre1"/> QGIS API documentation shows the values for all the unit constants</p><p class="calibre9">(<a class="calibre1" href="http://qgis.org/api/classQGis.html">http://qgis.org/api/classQGis.html</a>).</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec32" class="calibre1"/>Calculating the area of a polygon</h1></div></div></div><p class="calibre9">This recipe<a id="id138" class="calibre1"/> simply measures the area of a polygon.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec82" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">For this recipe, we'll use a single-feature polygon shapefile, which you can download from <a class="calibre1" href="https://geospatialpython.googlecode.com/files/Mississippi.zip">https://geospatialpython.googlecode.com/files/Mississippi.zip</a>
</p><p class="calibre9">Unzip the shapefile and put it in a directory named <strong class="calibre2">qgis_data/ms</strong> within your root or home directory.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec83" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">Perform the following steps to measure the area of a large polygon:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, import the QGIS constants library, as follows:<div><pre class="programlisting"><strong class="calibre2">from qgis.core import QGis</strong>
</pre></div></li><li class="listitem" value="2">Load the layer:<div><pre class="programlisting"><strong class="calibre2">lyr = QgsVectorLayer("/qgis_data/ms/mississippi.shp", "Mississippi", "ogr")</strong>
</pre></div></li><li class="listitem" value="3">Access the layer's features:<div><pre class="programlisting"><strong class="calibre2">fts = lyr.getFeatures()</strong>
</pre></div></li><li class="listitem" value="4">Get the boundary feature:<div><pre class="programlisting"><strong class="calibre2">boundary = fts.next()</strong>
</pre></div></li><li class="listitem" value="5">Create the measurement object instance:<div><pre class="programlisting"><strong class="calibre2">d = QgsDistanceArea()</strong>
</pre></div></li><li class="listitem" value="6">Pass the polygon list to the <code class="literal">measureArea()</code> method:<div><pre class="programlisting"><strong class="calibre2">m = d.measurePolygon(boundary.geometry().asPolygon()[0])</strong>
</pre></div></li><li class="listitem" value="7">Convert the measurement from decimal degrees to miles:<div><pre class="programlisting"><strong class="calibre2">d.convertMeasurement(m, QGis.Degrees, QGis.NauticalMiles, True) </strong>
</pre></div></li><li class="listitem" value="8">Verify that your output looks similar to the following:<div><pre class="programlisting"><strong class="calibre2">(42955.47889640281, 7)</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec84" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">PyQIS has no <code class="literal">measureArea()</code> method, but it has a <a id="id139" class="calibre1"/>
<code class="literal">measurePolygon() </code>method in the <code class="literal">QgsDistanceArea</code> object. The method accepts a list of points. In this case, when we convert the measurement output from decimal degrees to miles, we also specify <code class="literal">True</code> in the <code class="literal">convertMeasurement()</code> method so that QGIS knows that it is an area calculation. Note that when we get the boundary geometry as a polygon, we use an index of 0, suggesting that there<a id="id140" class="calibre1"/> is more than one polygon. A polygon geometry can have inner rings, which are specified as additional polygons. The outermost ring, in this case<a id="id141" class="calibre1"/> the only ring, is the first polygon.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec33" class="calibre1"/>Creating a spatial index</h1></div></div></div><p class="calibre9">Until now, the recipes in this book used the raw geometry for each layer of operations. In this recipe, we'll take a different approach and create a spatial index for a layer before we run operations on it. A <a id="id142" class="calibre1"/>spatial index optimizes a layer for spatial queries by creating additional, simpler geometries that can be used to narrow down the field of possibilities within the complex geometry.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec85" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">If you don't already have the New York City Museums layer used in the previous recipes in this chapter, download the layer from <a class="calibre1" href="https://geospatialpython.googlecode.com/svn/NYC_MUSEUMS_GEO.zip">https://geospatialpython.googlecode.com/svn/NYC_MUSEUMS_GEO.zip</a>.</p><p class="calibre9">Unzip that file and place the shapefile's contents in a directory named <code class="literal">nyc</code>
 within your <code class="literal">qgis_data</code> directory, within your root or home directory.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec86" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">In this recipe, we'll create a spatial index for a point layer and then we'll use it to perform a spatial query, as follows:</p><div><ol class="orderedlist"><li class="listitem" value="1">Load the layer:<div><pre class="programlisting"><strong class="calibre2">lyr = QgsVectorLayer("/qgis_data/nyc/NYC_MUSEUMS_GEO.shp", "Museums", "ogr")</strong>
</pre></div></li><li class="listitem" value="2">Get the features:<div><pre class="programlisting"><strong class="calibre2">fts = lyr.getFeatures()</strong>
</pre></div></li><li class="listitem" value="3">Get the first feature in the set:<div><pre class="programlisting"><strong class="calibre2">first = fts.next()</strong>
</pre></div></li><li class="listitem" value="4">Now, create the spatial index:<div><pre class="programlisting"><strong class="calibre2">index = QgsSpatialIndex()</strong>
</pre></div></li><li class="listitem" value="5">Begin loading the features:<div><pre class="programlisting"><strong class="calibre2">index.insertFeature(first)</strong>
</pre></div></li><li class="listitem" value="6">Insert the remaining features:<div><pre class="programlisting"><strong class="calibre2">for f in fts:</strong>
<strong class="calibre2">  index.insertFeature(f)</strong>
</pre></div></li><li class="listitem" value="7">Now, select the IDs of 3 points nearest to the first point. We use the number <code class="literal">4</code> because the starting point is included in the output:<div><pre class="programlisting"><strong class="calibre2">hood = index.nearestNeighbor(first.geometry().asPoint(), 4)</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec87" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The index <a id="id143" class="calibre1"/>speeds up spatial operations. However, you must add each feature one by one. Also, note that the <code class="literal">nearestNeighbor()</code> method returns the ID of the starting point as part of the output. So, if you want <code class="literal">4</code> points, you must specify <code class="literal">5</code>.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec34" class="calibre1"/>Calculating the bearing of a line</h1></div></div></div><p class="calibre9">Sometimes, you need to know the compass bearing of a line to create specialized symbology or use as input in a spatial calculation. Even though its name only mentions distance and area, the versatile <code class="literal">QgsDistanceArea</code> object includes this function as well. In this recipe, we'll calculate the bearing of the end points of a line. However, this recipe will work with any two points.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec88" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">We'll use the line shapefile used in a previous recipe. You can download the shapefile as a <code class="literal">.ZIP</code> file from <a class="calibre1" href="https://geospatialpython.googlecode.com/svn/paths.zip">https://geospatialpython.googlecode.com/svn/paths.zip</a>
</p><p class="calibre9">Unzip the shapefile into a directory named <code class="literal">qgis_data/shapes</code>
 within your root or home directory.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec89" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">The steps to be performed are as simple as getting the two points we need and running them through the<a id="id144" class="calibre1"/> bearing function, converting from radians to degrees, and then converting to a positive compass bearing:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, import the Python math module:<div><pre class="programlisting"><strong class="calibre2">import math</strong>
</pre></div></li><li class="listitem" value="2">Next, load the layer:<div><pre class="programlisting"><strong class="calibre2">lyr = QgsVectorLayer("/qgis_data/shapes/paths.shp", "Route", "ogr")</strong>
</pre></div></li><li class="listitem" value="3">Now, grab the features:<div><pre class="programlisting"><strong class="calibre2">fts = lyr.getFeatures()</strong>
</pre></div></li><li class="listitem" value="4">Then, grab the first line feature:<div><pre class="programlisting"><strong class="calibre2">route = fts.next()</strong>
</pre></div></li><li class="listitem" value="5">Create the measurement object:<div><pre class="programlisting"><strong class="calibre2">d = QgsDistanceArea()</strong>
</pre></div></li><li class="listitem" value="6">You must set the ellipsoidal mode to <code class="literal">True</code> in order to project the data before calculating the bearing:<div><pre class="programlisting"><strong class="calibre2">d.setEllipsoidalMode(True)</strong>
</pre></div></li><li class="listitem" value="7">Get all the points as a list:<div><pre class="programlisting"><strong class="calibre2">points = route.geometry().asPolyline()</strong>
</pre></div></li><li class="listitem" value="8">Get the first point:<div><pre class="programlisting"><strong class="calibre2">first = points[0]</strong>
</pre></div></li><li class="listitem" value="9">Grab the last point:<div><pre class="programlisting"><strong class="calibre2">last = points[-1]</strong>
</pre></div></li><li class="listitem" value="10">Calculate the bearing in radians:<div><pre class="programlisting"><strong class="calibre2">r = d.bearing(first, last)</strong>
</pre></div></li><li class="listitem" value="11">Now convert radians to degrees:<div><pre class="programlisting"><strong class="calibre2">b = math.degrees(r)</strong>
</pre></div></li><li class="listitem" value="12">Ensure that the bearing is positive:<div><pre class="programlisting"><strong class="calibre2">if b &lt; 0: b += 360</strong>
</pre></div></li><li class="listitem" value="13">View the output:<div><pre class="programlisting"><strong class="calibre2">print b</strong>
</pre></div></li></ol><div></div><p class="calibre9">Verify that the bearing is close to the following number:</p><div><pre class="programlisting"><strong class="calibre2">320.3356091875395</strong>
</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec90" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The default output of the bearing calculation is in radians. However, the Python <code class="literal">math</code> module makes <a id="id145" class="calibre1"/>conversion a snap of the fingers. If the conversion of degrees results in a negative number, most of the time we will want to add that number to 360 in order to get a compass bearing, as we did here.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec35" class="calibre1"/>Loading data from a spreadsheet</h1></div></div></div><p class="calibre9">Spreadsheets are <a id="id146" class="calibre1"/>one of the most common methods used to collect and store simple geographic data. QGIS can work with text files called CSV or comma-separated values files. Any spreadsheet can be converted to a CSV using the spreadsheet program. As long as the CSV data has a column representing <em class="calibre10">x</em> values, one column representing <em class="calibre10">y</em> values, and other columns<a id="id147" class="calibre1"/> representing data with the first row containing field names, QGIS can import it. Many organizations distribute geographic information as a CSV, so sooner or later you will find yourself importing a CSV. Moreover, PyQGIS let's you do it programmatically. Note that a CSV can be delimited by any character as long as it is consistent. Also, the file extension of the CSV file doesn't matter as long as you specify the file type for QGIS.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec91" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">We'll use a sample CSV file with point features representing points of interest in a region. You can download this sample from <a class="calibre1" href="https://geospatialpython.googlecode.com/svn/MS_Features.txt">https://geospatialpython.googlecode.com/svn/MS_Features.txt</a>.</p><p class="calibre9">Save this to your <code class="literal">qgis_data/ms</code> directory in your root or home directory.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec92" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will build a <code class="literal">URI</code> string to load the CSV as a vector layer. All of the parameters used to describe the structure<a id="id148" class="calibre1"/> of the CSV are included in the URI, as<a id="id149" class="calibre1"/> follows:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we build the base <code class="literal">URI</code> string with the filename:<div><pre class="programlisting"><strong class="calibre2">uri="""file:///qgis_data/ms/MS_Features.txt?"""</strong>
</pre></div></li><li class="listitem" value="2">Next, we tell QGIS that the file is a CSV file:<div><pre class="programlisting"><strong class="calibre2">uri += """type=csv&amp;"""</strong>
</pre></div></li><li class="listitem" value="3">Now, we specify our delimiter, which is a pipe (<strong class="calibre2">"|"</strong>), as a URL-encoded value:<div><pre class="programlisting"><strong class="calibre2">uri += """delimiter=%7C&amp;"""</strong>
</pre></div></li><li class="listitem" value="4">Next, we tell QGIS to trim any spaces at the ends of the fields:<div><pre class="programlisting"><strong class="calibre2">uri += """trimFields=Yes&amp;"""</strong>
</pre></div></li><li class="listitem" value="5">Now, the most important part, we specify the x field:<div><pre class="programlisting"><strong class="calibre2">uri += """xField=PRIM_LONG_DEC&amp;"""</strong>
</pre></div></li><li class="listitem" value="6">Then, we specify the y field:<div><pre class="programlisting"><strong class="calibre2">uri += """yField=PRIM_LAT_DEC&amp;"""</strong>
</pre></div></li><li class="listitem" value="7">We decline the spatial index option:<div><pre class="programlisting"><strong class="calibre2">uri += """spatialIndex=no&amp;"""</strong>
</pre></div></li><li class="listitem" value="8">We decline the subset option:<div><pre class="programlisting"><strong class="calibre2">uri += """subsetIndex=no&amp;"""</strong>
</pre></div></li><li class="listitem" value="9">We tell QGIS not to watch the file for changes:<div><pre class="programlisting"><strong class="calibre2">uri += """watchFile=no&amp;"""</strong>
</pre></div></li><li class="listitem" value="10">Finally, we complete the <code class="literal">uri </code>with the CRS of the layer:<div><pre class="programlisting"><strong class="calibre2">uri += """crs=epsg:4326"""</strong>
</pre></div></li><li class="listitem" value="11">We load the layer using the <code class="literal">delimitedtext</code> data provider:<div><pre class="programlisting"><strong class="calibre2">layer=QgsVectorLayer(uri,"MS Features","delimitedtext")</strong>
</pre></div></li><li class="listitem" value="12">Finally, we add it to the map:<div><pre class="programlisting"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayers([layer])</strong>
</pre></div></li></ol><div></div><p class="calibre9">Verify that your map looks similar to the map shown in the following screenshot:</p><div><img src="img/00021.jpeg" alt="How to do it..." class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec93" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The URI is quite extensive, but necessary to give QGIS enough information to properly load the layer. We used strings in<a id="id150" class="calibre1"/> this simple example, but<a id="id151" class="calibre1"/> using the <code class="literal">QUrl</code> object is safer, as it handles the encoding for you. The documentation for the <code class="literal">QUrl</code> class is in the <code class="literal">Qt</code> documentation at <a class="calibre1" href="http://qt-project.org/doc/qt-4.8/qurl.html">http://qt-project.org/doc/qt-4.8/qurl.html</a>.</p><p class="calibre9">Note that in the URI, we tell QGIS that the type is <strong class="calibre2">CSV</strong>, but when we load the layer, the type is <strong class="calibre2">delimitedtext</strong>. QGIS <a id="id152" class="calibre1"/>will ignore empty fields as long as all of the columns are balanced.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch02lvl2sec94" class="calibre1"/>There's more...</h2></div></div></div><p class="calibre9">If you're having trouble loading a layer, you can use the <strong class="calibre2">QGIS Add Delimited Text Layer…</strong> dialog<a id="id153" class="calibre1"/> under the <strong class="calibre2">Layer</strong> menu to figure out the correct parameters. Once the layer is loaded, you can take a look at its metadata to see the URI QGIS constructed to load it. You can also get the correct parameters from a loaded, delimited text layer <a id="id154" class="calibre1"/>using the <code class="literal">layer.source()</code> method<a id="id155" class="calibre1"/> programmatically. And, of course, both of these methods work with any type of layer, not just delimited text. Unlike other layer types, however, you cannot edit delimited text layers in QGIS.</p></div></div></body></html>