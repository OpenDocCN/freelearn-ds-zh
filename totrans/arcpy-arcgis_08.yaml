- en: Chapter 8. Introduction to ArcPy.Mapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating maps is an art, one that can be learned through years of dedicated
    study of cartography. The visual display of information is both exciting and difficult,
    and can be a rewarding part of the daily workflow of geospatial professionals.
    Once the basics have been learned and mastered, cartographic output becomes a
    constant battle to produce more maps at a faster pace. ArcPy, once again, has
    a powerful solution: the `arcpy.mapping` module.'
  prefs: []
  type: TYPE_NORMAL
- en: By allowing for the automatic manipulation of all map components, including
    the map window, the layers, the legend, and all text elements, `arcpy.mapping`
    makes creating, modifying, and outputting multiple maps fast and simple. Map book
    creation – another important skill for geospatial professionals, is also made
    easy using the module. In this chapter we will discuss some basic functionalities
    available through `arcpy.mapping` and use it to output a map book of bus stops
    and their surrounding census blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting and updating Map Document (MXD) layer data sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exporting MXDs to PDF or other image formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusting map document elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ArcPy with map documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recognizing the limitations of the previous `arcgisscripting` module, ESRI designed
    the ArcPy module to not only work with data but also included the `arcpy.mapping`
    module to allow direct interaction with map documents (MXDs) and the layers they
    contain. This new module opened up a multitude of map automation possibilities.
    A script might aid in identifying broken layer links, update the data source of
    these layers, and apply new color schemes to layers. Another script might use
    a map template and create a set of maps, one from each feature class in a feature
    dataset. A third script could create a map book from an MXD, moving from cell
    to cell in a grid layer to output the pages of the book, or even calculating the
    coordinates on the fly. Dynamically created maps, based on data from a fresh analysis,
    can be outputted at the same time the data is produced. `Arcpy.mapping` moves
    the ArcPy module from helpful to instrumental, in any geospatial workflow.
  prefs: []
  type: TYPE_NORMAL
- en: To investigate the utility of the `arcpy.mapping` module, we'll need the help
    of an MXD template. I've prepared a map package containing the data and MXD that
    we will use for the exercises in this chapter. It includes the data from our San
    Francisco bus stop's analysis, which we will continue and extend to include maps.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting and replacing layer sources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first and most important `arcpy.mapping` module use is to identify and fix
    the broken links between layers in a map document and their data sources. Layer
    symbology and GIS data storage are separated, meaning that layer data sources
    are often moved. `Arcpy.mapping` offers a quick solution, though imperfect.
  prefs: []
  type: TYPE_NORMAL
- en: This solution depends on a number of methods included in the `arcpy.mapping`
    module. First, we will need to identify the broken links, and then we will fix
    them. To identify the broken links we will use the `ListBrokenDataSources()` method
    included in `arcpy.mapping`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ListBrokenDataSources()` method requires an MXD path to be passed to the
    `MapDocument()` method of `arcpy.mapping`. Once the map document object has been
    created, it is passed to the `ListBrokenDataSources()` method, and a list will
    be generated containing layer objects, one for each layer with a broken link.
    The layer objects have a number of properties available to them. Using these properties,
    let''s print out the name and data source of each layer using the name and data
    source properties of each object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Fixing the broken links
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have identified the broken links, the next step is to fix them.
    In this case, it was revealed that the data sources should be in a folder called
    Data, but they are not contained within that folder. The script must then be stepped
    up to replace the data sources of each layer, so that they point at the actual
    location of the data source.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are methods included in both layer objects and map document objects that
    can accomplish this next step. If all of the data sources for an MXD have been
    moved, it is better to use the MXD object and its methods to fix the sources.
    In the example MXD, the data sources have all been moved into a new folder called
    `NewData`, so we will employ the `findAndReplaceWorkspacePaths()` method to repair
    the links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As long as the data sources are still in the same format (such that shapefiles
    are still shapefiles or feature classes are still feature classes), the `findAndReplaceWorkspacePaths()`
    method will work. If the data source types have been changed (such that, shapefiles
    are imported into a file geodatabase), the `replaceWorkspaces()` method will have
    to be used instead as it requires workspace type as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Fixing the links of individual layers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If the individual layers do not share a data source, the layer objects will
    need to be adjusted using the `findAndReplaceWorkspacePath()` method available
    to layers. This method is similar to the method used previously, but it will only
    replace the data source of the layer object it is applied to instead of all of
    the layers. When combined with a dictionary, the layer data sources can be updated
    using the layer name property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'These solutions work well for individual map documents and layers. They can
    also be extended to folders full of MXDs by using the `glob.glob()` method of
    the built-in `glob` module (which helps to generate a list of files that match
    a certain file extension) and the `os.path.join()` method of the `os` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Exporting to PDF from an MXD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next most important use of `arcpy.mapping` is to automatically export MXDs.
    The following code will highlight the export of PDFs, but note that the module
    also supports the export of JPEGs and other image formats. Using `arcpy.mapping`
    for this process is a joy, as the usual process of opening and exporting the MXDs
    involves a lot of waiting for ArcMap to start and the map to load, which can be
    a time sink:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the output folder must exist for this code to run correctly. While
    there are `os` module methods to check whether a path exists (`os.path.exists`)
    and to create a folder (`os.mkdir`), that is not included in this code snippet
    and the `arcpy.mapping.ExportToPDF()` method will throw an exception if the input
    or output paths do not exist.
  prefs: []
  type: TYPE_NORMAL
- en: This example code is very useful and can be converted into a function that would
    accept the folder path as a parameter. The function could then be added to a script
    tool, as discussed in the last chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting map document elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Arcpy.mapping` includes important methods that will facilitate the automation
    of map document manipulation. These include the ability to add new layers or turn
    layers on and off within MXDs, the ability to adjust the scale of the data frame
    or move a data frame to focus on a specific region, and the ability to adjust
    text components of the map (such as titles or subtitles). These methods will be
    addressed as we continue our bus stop analysis.'
  prefs: []
  type: TYPE_NORMAL
- en: Open up the MXD called `MapAdjust.mxd`. This represents our base map document,
    with layers and elements that we will adjust to our needs. It contains layers
    that we have generated from our analysis, and the base layers that fill out the
    map. There are also a number of text elements that will be automatically replaced
    by the script to fit the specific needs of each map. However, it does not do a
    good job of representing the results of the analysis as the census blocks that
    intersect the bus stop buffers overlap, making it hard to interpret the cartography.
  prefs: []
  type: TYPE_NORMAL
- en: The script will replace the data source of the census block layer and the bus
    stop layer to make it possible to only produce one map for each bus stop, and
    the census blocks that are intersected with each buffer surrounding the stops.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adjusting map document elements](img/8662OS_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To make this possible, we will have to create two empty feature classes: one,
    with all of the attributes of the census blocks, and the other, with the attributes
    of the bus stops. This will allow the data source to be replaced with the data
    produced by the analysis.'
  prefs: []
  type: TYPE_NORMAL
- en: Open up the `SanFrancisco.gdb` File Geodatabase and right click on the `Chapter8Results`
    feature dataset. Select **New** from the drop-down menu and then select **Feature
    Class. Name** the first feature class `SelectedCensusBlocks` and make it a polygon.
    Select the **defaults keyword** on the next menu, and then on the following menu,
    push the **import** button. Select the **CensusBlocks** feature class from the
    SanFrancisco feature dataset; this will load the fields into the new feature class.
    Do the same thing for a second feature class called `SelectedBusStops`, but make
    sure that it is a point geometry type and import the schema from the `BusStops`
    feature class. Repeat the same process for a third feature class called `SelectedStopBuffers`,
    but make sure that it is a point geometry type and import the schema from the
    `Buffers` feature class.
  prefs: []
  type: TYPE_NORMAL
- en: Once the feature classes have been created, it is now possible to use them to
    load the results of the analysis. We will be redoing the analysis in memory and
    writing out the results to the newly created feature classes, so that the entire
    census block will be captured, instead of only the portion that intersects with
    the buffer, as it will better illustrate the results of the analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial state of the `MapAdjust.mxd` map document features a number of
    feature classes with which we are now familiar: the downloaded feature class `Bus_Stops`,
    the generated feature class Buffers, the intersected and clipped Census Blocks,
    and four feature classes used for cartographic purposes, namely the **Streets
    feature** class, the **Parks feature** class, a **Neighborhoods feature** class,
    and an outline of **San Francisco**. There are two data frames, one with the default
    name **Layers** and another called **Inset**, that are used to create the small
    inset that will show the position of the Layers data frame as it moves around
    San Francisco. The small rectangle that depicts the extent of the Layers data
    frame is an Extent frame created in the properties of the Inset data frame.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an exported view of the initial state of the map document:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adjusting map document elements](img/8662OS_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The idea here, is to use the initial results of our analysis to generate the
    symbology of the population layer as well as the bus stop layer and the buffer
    layer. Once they have been set and saved, they can be used as a basis for the
    individual map pages that we will be producing from this basic map document.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note the text elements that make up the title and subtitle, as well as the legend
    and attribution text at the bottom of the right pane. These elements are available
    for adjustment along with the layers and data sources that make up the map document
    by using the `arcpy.mapping.ListElements()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Automated map document adjustment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we understand the initial configuration of the map document, we will
    introduce a script that will automate the adjustment. This script will include
    a number of concepts that we have covered in this chapter and earlier chapters,
    and will also introduce some new methods for map document adjustments that we
    will detail in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Wow! That's a lot of code. Let's review it section by section to address what
    each part of the script is doing.
  prefs: []
  type: TYPE_NORMAL
- en: This code will be run in the Python Window of the MXD, so make sure to open
    the MXD. Once it is, open the **Python** Window and right click in it, and then
    select **Load** from the right-click menu. Using the file navigation browser,
    find the script called `Chapter8_6_AdjustmapCURRENT.py` and select it by clicking
    on it. Push **OK** and it will load in the Python Window. Pushing **Enter** will
    execute the script, or use the scroll bar to peruse the loaded lines.
  prefs: []
  type: TYPE_NORMAL
- en: The variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Within the script, a number of variables are first created to hold the `string`
    file paths, the `integer` buffer distance, and the `sql` statement used to identify
    the bus line of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: These will be used later to allow us to search the layers and perform analysis
    on them.
  prefs: []
  type: TYPE_NORMAL
- en: The map document object and the text elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because this code will be executed in an open map document, we don''t have
    to pass an MXD file path to the `arcpy.mapping.MapDocument()` method. Instead,
    we will use the keyword `CURRENT` to indicate that we are referencing the open
    map document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Once the map document object has been created, the Layers data frame is selected
    from a list of data frames using the `ListDataFrames()` method and passed to the
    variable called dataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the layout elements are passed as a list to the elements variable using
    the `ListLayoutElements()` method. The layout elements include the various elements
    of the map document layout view: the legend, the neat lines, the north arrow,
    the scale bar, and the text elements used as titles and descriptions. Unfortunately,
    there is no nice order to the list returned, as their position throughout the
    layout is undetermined. Access to the text elements, which we would like to assign
    to a variable for later use, must be identified using two properties of the element
    objects: the type and the text. We want to adjust the title and subtitle elements,
    so a `for` loop is used to search through the list of elements and the properties
    are used to find the elements of interest.'
  prefs: []
  type: TYPE_NORMAL
- en: The layer objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Make Feature Layer tool, part of the Data Management toolset, is used to
    copy data from disk into memory as a layer. ArcGIS requires the generation of
    layers to perform selections and operations on data, instead of operating on the
    feature classes directly. By using layers to perform these operations, the source
    feature classes are protected.
  prefs: []
  type: TYPE_NORMAL
- en: The Make Feature Layer tool is accessed using ArcPy's `MakeFeatureLayer_management()`
    method. When using this tool in the Python Window, the result is added to the
    map document as a layer that will be visible in the Table of Contents. When the
    tool is not used in the Python Window in ArcMap, the resulting layer is only generated
    in memory and is not added to the map document.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the portion of the following code, a layer called `blocks_lyr` is generated
    in memory by passing the file path of the census blocks feature class. The layer
    objects contained within the initial MXD are then accessed using the `ListLayers()`
    method of the `arcpy.mapping()` module. They are returned in the order that they
    are listed in the Table of Contents of the map document and are assigned to variables
    using list indexing, including the newly created `blocks_lyr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Replacing the data sources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have assigned the layer objects to variables, we will check whether
    their data sources are the correct feature classes that we use for map production.
    Using the `dataSource` property of each layer object, they are compared to the
    file path variables that we want to use as data sources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`If` statements are used to check whether the data sources are correct. If
    not, they are replaced with the correct data sources using the `replaceDataSource()`
    layer method. This method requires three parameters: the workspace (in this case,
    the File Geodatabase), the workspace type, and the name of the new feature class
    data source, which must be in the same workspace for the `replaceDataSource()`
    method to work (though it does not need to be in the same feature dataset).'
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting layer visibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The layer objects have a property that allows us to adjust their visibility.
    Setting this Boolean property to `True` or `False` will adjust the layer''s visibility
    on (True) or off (False):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We want the layer variable `layerCensus`, which is the new `blocks_lyr` object,
    to be turned off, so it is set to `False`, but the bus stops and buffer layer
    objects need to be visible, so they are set to `True`.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a buffer from the bus stops feature class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All of the variables have been generated or assigned, so the next step is to
    use a `SearchCursor` to search through the selected bus stops. For each bus stop,
    buffer objects will be generated to find census blocks that intersect with these
    individual bus stops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: For each row of data retrieved from the Bus Stops feature class, a number of
    attributes are returned, contained in a tuple. The first of these, row[0], is
    a `PointGeometry` object. This object has a buffer method that is used to generate
    a buffer `Polygon` object in memory, which is then assigned to the `stopBuffer`
    variable. Once the buffer object is created, the data access UpdateCursor's `deleteRow()`
    method is used to erase the rows in the census blocks layer. Once the rows have
    been deleted, the layer can then be repopulated with newly selected census blocks
    that will be identified in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Intersecting the bus stop buffer and census blocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To identify the census blocks intersecting with the buffer around each bus
    stop, the ArcToolbox tool SelectLayerByLocation is invoked using the ArcPy method
    `SelectLayerByLocation_management()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This method requires the in-memory `blocks_lyr` layer object and the newly created
    buffer object assigned to the variable `stopBuffer`. It also requires the type
    of selection `intersect` and another parameter that controls whether the selection
    will be added to an existing selection or will be a new selection. In this case,
    we want a new selection, as only the census blocks that intersect the current
    bus stop are needed.
  prefs: []
  type: TYPE_NORMAL
- en: Once the census blocks have been selected and identified, the shape data and
    population data is passed to the feature class represented by the variable `selectedBlock`
    using an `InsertCursor`. The InsertCursor must be deleted using the del keyword,
    as only one `InsertCursor` or `UpdateCursor` can be in memory at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Populating the selected bus stop and buffer feature classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In a similar manner, the next step is to populate the bus stop and buffer feature
    classes that will be used in the map production. The bus stops feature class is
    first made blank using the `deleteRow()` method, and then the selected bus stop
    shape field data is inserted into the feature class. The same steps are then taken
    with the bus stop buffers feature class and the buffer geometry object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Updating the text elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that the data has been generated and written to the feature classes created
    to hold them, the next step is to update the layout elements. This includes layer
    properties that will affect the legend, the extent of the data frame, and the
    text elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The name of the bus stops layer is adjusted using its name property to reflect
    the current bus stop. The data frame extent is adjusted by creating an `arcpy.Extent`
    object and passing it four parameters: *Xmin*, *Ymin*, *Xmax*, *Ymax*. To generate
    these values I have used the somewhat arbitrary value of 1200 feet to create a
    square around the bus stop. The text elements are updated using their text property.
    Finally, the `RefreshActiveView()` method is used to ensure that the map document
    window is correctly updated to the new extent.'
  prefs: []
  type: TYPE_NORMAL
- en: Exporting the adjusted map to PDF
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The final step is to pass the newly adjusted map document object to ArcPy''s
    `ExportToPDF` method. This method requires two parameters, the map document object
    and a string that represents the file path of the PDF:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The PDF file path string is generated from the pdfFolder string template and
    the ID of the bus stop, along with the object ID and the file extension `.pdf`.
    Once that and the map document object represented by the variable `mxdObject`
    are passed to the `ExportToPDF` method, the PDF will be generated. The text elements
    are then reset and the view is refreshed to ensure that the map document will
    be ready for the next time the script is used.
  prefs: []
  type: TYPE_NORMAL
- en: Running the script in the Python Window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open up the map document called `MapAdjust.mxd` if it is not open already. Open
    the **Python** Window and right click in the window. Select **Load** from the
    menu. When the file dialog opens, find the script called `Chapter8_6_AdjustmapCURRENT.py`
    and select it, making sure that the file paths within it are correct. Push **OK**
    and it will load in the Python Window. Push **Enter** once the script is loaded
    to run the script. It can take a few seconds or more for it to be obvious that
    the script is running.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the Python Window is not a great place to execute ArcPy scripts in
    most cases, as it is somewhat limited when compared to IDEs. Using it to load
    and execute a script that performs these map document adjustments is one of the
    best uses of the Python Window.
  prefs: []
  type: TYPE_NORMAL
- en: Once the script is running, the adjustments to the map document will begin to
    appear and repeat. This is a fascinating process, as the effects of running the
    script are visible in a manner that is not readily available when running Python
    scripts. Once the PDFs begin to be generated, open one up to view the output.
    The script will generate a map for each bus stop on the selected bus line, so
    feel free to shut down the map document after generating a set number of the PDFs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the script in the Python Window](img/8662OS_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The maps generated by the script show each bus stop at the center, surrounded
    by the buffer and the symbolized census blocks with which the buffer intersects.
    The title, subtitle and the legend have been adjusted to indicate the bus stop
    depicted in the map. With ArcPy, we are now in control of both the parts of geospatial
    analysis: the analysis itself, and the cartographic production depicting the result
    of the output.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter arcpy.mapping was introduced and used to control the elements
    of map documents that need to be adjusted to create custom maps. By joining geospatial
    analysis and map production together, we are closer to utilizing the full power
    of ArcPy.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will go further with arcpy.mapping and create a script
    tool that can be added to ArcToolbox, which will run the analysis as well as generate
    maps from the resulting data. We will also refine the script and introduce Data
    Driven Pages to discuss how that powerful tool can be used in an ArcPy script.
  prefs: []
  type: TYPE_NORMAL
