- en: Chapter 6. Analyzing Geographic Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At some point, after acquiring, preparing, and organizing data to fit your
    needs, you eventually get to the point where you can actually use this data for
    some greater good: to form queries, explore, answer questions, test hypotheses,
    and so on. In this chapter, you will develop some of these capabilities along
    with their application components, specifically:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the analysis functionality:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overlay summary and distance buffer for vector data
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Zonal summary statistics for raster data
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Add ways to access them through the user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the analysis module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We start by creating what we will call the `app/analyzer.py` module with the
    necessary imports. One in the `vector` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And one in the `raster` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, we must make these new modules importable from their parent packages,
    to add the following import statement in both `vector/__init__.py` and `raster/__init__.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Analyzing data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first half of this chapter creates the analysis functionality, while the
    other half weaves the functionality into the application design. Let's begin by
    making the functionality. This includes overlap summary and buffer for vector
    data and zonal statistics for raster data.
  prefs: []
  type: TYPE_NORMAL
- en: Vector data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For vector data, we will focus on two commonly used analysis tools: overlap
    summary and buffer.'
  prefs: []
  type: TYPE_NORMAL
- en: Overlap summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the most basic spatial analysis operations in a GIS is to summarize
    statistics for a layer of features that touches or overlaps another layer of features.
    Typical questions to warrant such analysis include: how many points fall within
    each country polygon, or what is the sum or average of their values for each country?
    This type of analysis is typically done using a *spatial join* tool, with the
    many-to-one option representing multiple matching features with a summary statistic.
    These summary statistics are then attached to the original country polygons. A
    spatial join is not an analysis in itself, it just does the number crunching that
    the user can later use to analyze, for instance, visually on a map or in a table
    graph. In my experience, this is one of the most common reasons for using spatial
    joins, as a preprocessing step, but it is still a crucial part of overlay analysis.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows a typical way that overlay analysis can be used
    to aggregate values and visualize patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Overlap summary](img/5407OS_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Since our application is geared more toward less technical users, and we want
    to make everything as obvious as possible, we make this particular usage of spatial
    join into a tool of its own and give it a name that more appropriately describes
    the analysis end product: overlap summary. The tool has been assigned the data,
    to group the statistics into the data, containing the values that will be summarized,
    and a list of fieldname statistic tuples to be calculated in the output, also
    known as a **fieldmapping**. Valid statistic values are count, sum, max, min,
    and average. As an example of a fieldmapping, this tool expects that if we want
    the output file to calculate the count of major cities and the sum of their populations,
    we will write it as `[("city_id", "count"), ("city_pop", "sum")]`. Note that the
    fieldmapping follows the usual Python syntax with strings having quote marks around
    them, which is also how we input them through the user interface later in text.
    For detecting overlap, we use the Shapely module''s `intersects` operation. Also
    note that the use of Shapely''s less known `prep` function (imported as `supershapely`)
    gives incredible speedups for multiple repeated intersect comparisons on the same
    geometry.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, head into `vector/analyzer.py` and add the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Buffer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If, in your analysis, you also want to include features that don''t necessarily
    overlap the grouping features but are within a certain distance, then buffering
    is a good tool to use. A buffer operation is one where a geometric feature is
    grown or shrunk by a specified distance. After expanding the geometries to the
    desired distance, one can then follow up with the previously implemented overlap
    summary tool and, this way, also include near-overlap features in the statistics.
    Refer to the following screenshot to see an example of a polygon buffer operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Buffer](img/5407OS_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We implement this quite simply with Shapely''s `buffer` method, with positive
    numbers for growing and negative numbers for shrinking. To make it a bit more
    interesting, we let the user dynamically set the buffer distance based on an expression.
    The expression should take the form of a string representing Python code, referencing
    the feature as **feat**, which allows buffering based on one or more of its attributes
    or even math expressions. For instance, to buffer a layer of countries based on
    GDP per capita and scaled down for visibility, we may write something like: *(feat[''GDP'']
    / float(feat[''population''])) / 500.0*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `vector/analyzer.py`, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Raster data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To analyze raster data in our lightweight application, we are somewhat constrained
    by the speed and capabilities that our main dependency PIL has to offer. Luckily,
    there are many hidden gems inside the PIL package, one of them being the `ImageStat`
    module that we use to implement zonal statistics analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Other useful functionalities from the PIL library can be found in its `ImageMath`
    module. This will allow us to produce an output raster based on a math expression
    combining one or more input raster layers. However, if your application is first
    and foremost meant for advanced analysis of raster data or satellite imagery,
    you may want to consider going the GDAL/NumPy/SciPy route. We return to some of
    these possibilities in the final chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Zonal statistics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Zonal statistics is a common GIS tool that takes each category or zone from
    one raster and summarizes the values of overlapping cells from another raster.
    In a sense, zonal statistics is the raster equivalent of overlap summary. In our
    implementation, we return both a dictionary containing various statistics for
    each zone and a copy of the zonal raster, where the value for each zone is based
    on one of its global summary statistics. The user must specify which band from
    the zonal and value data to use, and set the outstat statistics option to one
    of: `mean`, `median`, `max`, `min`, `stdev`, `var`, `count`, or `sum`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `raster/analyser.py` write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Weaving functionality into the user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, let's make the analysis functionality created so far accessible in the
    user interface of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Layer-specific right-click functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Chapter 5](ch05.html "Chapter 5. Managing and Organizing Geographic Data"),
    *Managing and Organizing Geographic Data*, we instructed our application that
    right-clicking a layer in the LayersPane give us a menu of actions to choose from
    that is specific to that particular layer. In the current chapter, the only layer-specific
    functionality we made is the `buffer` operation. Therefore, we add the buffer
    menu option to the `RightClickMenu_VectorLayer` class in `app/dialogues.py`. Remember
    to find and save an `app/icons/buffer.png` icon so that it can be displayed next
    to the menu''s buffer item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Defining the tool options windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Still in `app/dialogues.py`, we define the layer-specific tool options windows
    that should pop up. Since they are layer-specific, we add the LayerItem's data
    as a hidden option that the user shouldn't worry about setting. The only user
    input here is the buffer distance expression we introduced earlier based on the
    units of the data's coordinate reference system, which can be either positive
    for growing or negative for shrinking. An expression calculator may be a nice
    touch for the user to add here on their own.
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining the tool options windows](img/5407OS_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the code for the mentioned functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Setting up the analysis tab
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we focus on those tools that should be available in the top ribbon area.
    First, we go to `app/builder.py` in the initialization phase of the GUI class,
    add a new tab for analysis, and add toolbars and buttons for our remaining functionality,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the analysis tab](img/5407OS_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the code to create the **Analyze** tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Defining the tool options window
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the tool options window, for overlap summary, we define the standard way
    in `app/dialogues.py`. Note that the process of adding fieldname statistic tuples
    for the output should ideally be chosen from two drop-down lists (one for available
    fieldnames and one for available statistic types). Since we have no such double
    drop-down widget readily available, we instead settle for having the user spell
    it out as a tuple with two quote-enclosed strings, which, unfortunately, is not
    very user friendly. Using double drop-down lists can be an exercise for the reader
    to implement. Furthermore, since we have no way of visualizing the output data
    based on their attributes, this method is currently useless within the confines
    of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining the tool options window](img/5407OS_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the code to implement the mentioned functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'For the zonal statistics tool, we do the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining the tool options window](img/5407OS_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the code to implement the mentioned functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'However, when it is time to process the zonal statistics results, we not only
    add the output raster as a layer, but also pop up a scrollable window displaying
    the summary statistics for all the zones. To create the scrollable text widget,
    Tkinter already has a prebuilt scrollable text widget (which for some odd reason
    is placed in a module of its own, imported here as `tkst`), so we use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we added the bare minimum of basic and commonly used GIS analysis
    tools. Specifically, we added a flexible buffer tool available when right-clicking
    on a vector layer, and an analysis tab with one button for overlap summary between
    vector data, and another button for zonal statistics between raster data.
  prefs: []
  type: TYPE_NORMAL
- en: However, this is only barely scratching the surface of the types of analyses
    one can do in a GIS application, and the fun part comes when you choose to take
    the application further and build additional functionalities. For instance, how
    you can link tools together to simplify the steps needed and create custom analysis
    tools that help you, or your intended target audience, become more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: With the completion of the analysis component of our application, we are left
    with a very simple but functional GIS application that works, at least for demonstration
    purposes. In order for the application to be usable outside of our own development
    environment, especially to non-programmers, you must turn our attention to making
    it a self-contained application, which is what we will do in the next chapter.
  prefs: []
  type: TYPE_NORMAL
