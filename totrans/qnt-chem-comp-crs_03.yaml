- en: 'Chapter 3: Quantum Circuit Model of Computation'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"As we scale towards a million [qubits], I think we''ve got some fundamental
    issues in error correction, control, and maybe quantum physics that can rear their
    heads," he said, adding that even those problems are "solvable."'
  prefs: []
  type: TYPE_NORMAL
- en: – Arvind Krishna, IBM chairman and CEO
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_3.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Scaling of the quantum computer [authors]
  prefs: []
  type: TYPE_NORMAL
- en: There are fundamental differences between classical computing and quantum computing;
    classical computing is deterministic with 1s and 0s, and quantum is probabilistic
    with a twist. Quantum computers work with probability amplitudes, which is a postulate
    of quantum mechanics (see *Section 2.2, Postulate 2 – Probability amplitudes*).
    The probabilistic amplitudes of quantum computing behave differently from classical
    probabilities in that these values can cancel each other out, which is known as
    **destructive interference**.
  prefs: []
  type: TYPE_NORMAL
- en: Destructive interference can be illustrated with noise-canceling headphones.
    Specifically, it is when two or more waves come together, eliminating the waves
    altogether. In other words, the waves that come together are opposite in phase
    and equal in amplitude. **Constructive interference** is when two or more waves
    come together, and the amplitudes add positively. These two properties are essential
    to enable the desired result to come out of the computer with the highest probability.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, interference is at the core of what quantum computing should be, and we
    also use the concept of the wave function as introduced in *Section 2.1,* *Postulate
    1 – Wave function*, and it is used to define the idea of the **qubit**: the quantum
    bit of information. Typically, in the quantum computing industry, **state vector**
    is used as the term for the wave function.'
  prefs: []
  type: TYPE_NORMAL
- en: Another difference between the two methods of computing is that in quantum computing,
    when we add one more unit of information, the size of the computational space
    is doubled. In theory, this allows us to speed up exponentially.
  prefs: []
  type: TYPE_NORMAL
- en: Quantum computing also uses the superposition property to achieve parallelism
    up until the moment a measurement is performed. Recall we discussed superposition
    in *Section 2.3, Postulate 3 – Measurable quantities and operators*. A quantum
    algorithm needs to be repeated multiplied times to get the probability distribution
    of the measurement.
  prefs: []
  type: TYPE_NORMAL
- en: The scaling of quantum computers paves the way for simulating chemical systems
    that could enable researchers to conduct virtual experiments and discover new
    molecules much faster than by performing physical experiments in a lab. In parallel
    to building a scalable quantum computer, research into optimal mappings of fermionic
    states and operators to qubit states and quantum gates is essential to exploit
    the potential of near-term quantum computers.
  prefs: []
  type: TYPE_NORMAL
- en: We give an illustration of a key component of such mappings, a quantum circuit
    that creates permutation symmetric or permutation asymmetric states in a probabilistic
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Section 3.1, Qubits, entanglement, Bloch sphere, Pauli matrices*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Section 3.2, Quantum gates*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Section 3.3, Computation-driven interference*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Section 3.4, Preparing a permutation symmetric or asymmetric state*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A companion Jupyter notebook for this chapter can be downloaded from GitHub
    at [https://github.com/PacktPublishing/Quantum-Chemistry-and-Computing-for-the-Curious](https://github.com/PacktPublishing/Quantum-Chemistry-and-Computing-for-the-Curious),
    which has been tested in the Google Colab environment, which is free and runs
    entirely in the cloud, and in the IBM Quantum Lab environment. Please refer to
    [*Appendix B*](B18268_Appendix_B_ePub.xhtml#_idTextAnchor313) *– Leveraging Jupyter
    Notebooks in the Cloud*, for more information. The companion Jupyter notebook
    automatically installs the following list of libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Numerical Python** (**NumPy**) [NumPy], an open-source Python library that
    is used in almost every field of science and engineering'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qiskit [Qiskit], an open-source SDK for working with quantum computers at the
    level of pulses, circuits, and application modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qiskit visualization support to enable visualization and Jupyter notebooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quantum Toolbox in Python** (**QuTiP**) [QuTiP], which is designed to be
    a general framework for solving quantum mechanics problems such as systems composed
    of few-level quantum systems and harmonic oscillators'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We recommend using the following online graphical tools:'
  prefs: []
  type: TYPE_NORMAL
- en: IBM Quantum Composer, which is a graphical quantum programming tool that lets
    you drag and drop operations to build quantum circuits and run them on real quantum
    hardware or simulators [IBM_comp1] [IBM_comp2]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grok the Bloch Sphere, a web-based application that displays the Bloch sphere
    and shows the action of gates as rotations [Grok]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing NumPy, Qiskit, QuTiP, and importing various modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install NumPy with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Install Qiskit with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Install Qiskit visualization support with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Install QuTiP with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Import NumPy with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Import the required functions and class methods. The `array_to_latex function()`
    returns a LaTeX representation of a complex array with dimension 1 or 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Import the math libraries with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Import QuTiP with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 3.1\. Qubits, entanglement, Bloch sphere, Pauli matrices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concepts presented in this section are a specific application of the five
    postulates of quantum mechanics that were presented in [*Chapter 2*](B18268_02_ePub.xhtml#_idTextAnchor077)*,
    Postulates of Quantum Mechanics*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we describe the following in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Section 3.1.1, Qubits*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Section 3.1.2, Tensor ordering of qubits*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Section 3.1.3, Quantum entanglement*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Section 3.1.4, Bloch sphere*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Section 3.1.5, Displaying the Bloch vector corresponding to a state vector*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Section 3.1.6, Pauli matrices*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3.1.1\. Qubits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we describe the current setup for quantum computation and
    the definition of a qubit. A qubit is a unit of information that represents a
    two-level quantum system and lives in a two-dimensional Hilbert space ![](img/Formula_03_001.png).
    The basis vectors of the quantum space are denoted as ![](img/Formula_03_002.png),
    which are referred to as the computational basis states:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A general single-qubit state is described by a superposition of the computational
    basis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'where ![](img/Formula_03_005.png) and ![](img/Formula_03_006.png) are linear
    expansion coefficients that satisfy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_007.png)'
  prefs: []
  type: TYPE_IMG
- en: Although the qubit is in a quantum superposition during the algorithm, when
    it is measured in the computational basis, it will be found in state ![](img/Formula_03_008.png)
    or state ![](img/Formula_03_009.png), not in a superposition. These measurement
    outcomes occur with probability ![](img/Formula_03_010.png) and ![](img/Formula_03_011.png)
    respectively. If there are ![](img/Formula_03_012.png) qubits in the system, the
    state is described by a vector in the ![](img/Formula_03_013.png) dimensional
    Hilbert space ![](img/Formula_03_014.png) formed by taking the tensor product
    of the Hilbert spaces of the individual qubits. For 10 qubits, the state is described
    by a vector in a 1,024-dimensional Hilbert space.
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.2\. Tensor ordering of qubits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The physics community typically orders a tensor product of ![](img/Formula_03_012.png)
    qubits with the ![](img/Formula_03_016.png) qubit on the left-most side of the
    tensor product:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_017.png)'
  prefs: []
  type: TYPE_IMG
- en: 'where ![](img/Formula_03_018.png). However, Qiskit uses an ordering in which
    the ![](img/Formula_03_019.png) qubit is first in the order and the ![](img/Formula_03_020.png)
    qubit is last:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_021.png)'
  prefs: []
  type: TYPE_IMG
- en: In other words, if qubit 0 is in state ![](img/Formula_03_022.png), qubit 1
    is in state ![](img/Formula_03_022.png), and qubit 2 is in state ![](img/Formula_03_024.png)
    , many physics textbooks would represent this as ![](img/Formula_03_025.png),
    whereas Qiskit would represent this state as ![](img/Formula_03_026.png). This
    difference affects the way multi-qubit operations are represented as matrices,
    so please be on the lookout as we are using Qiskit in the book.
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.3\. Quantum entanglement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A quantum system is entangled when its quantum state cannot be factored as
    a tensor product of states of its constituents. States can be classified as either
    a product of single particle states or **entangled**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Product states can be decomposed into tensor products of fewer qubits, such
    as:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/Formula_03_027.png)'
  prefs: []
  type: TYPE_IMG
- en: Entangled states cannot be decomposed into tensor products of states. For example,
    the Bell state ![](img/Formula_03_028.png) is entangled and can only be measured
    either in the state ![](img/Formula_03_029.png) or in the state ![](img/Formula_03_030.png),
    each with a probability of 1/2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3.1.4\. Bloch sphere
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Bloch sphere describes a qubit in space and is a specific form of the coordinate
    system (*Figure 3.2*) presented in *Section 2.1, Postulate 1 – Wave functions*.
    The ![](img/Formula_03_031.png) vector, or the length, of a qubit is always equal
    to 1, so the coordinates of the Bloch sphere are:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_032.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s focus on the general normalized pure state for a single qubit, as presented
    in *Section 3.1.1, Qubits*:'
  prefs: []
  type: TYPE_NORMAL
- en: When ![](img/Formula_03_033.png) and ![](img/Formula_03_034.png), the ![](img/Formula_03_035.png)
    state is "up" in the ![](img/Formula_03_036.png)-direction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When ![](img/Formula_03_037.png) and ![](img/Formula_03_038.png), the ![](img/Formula_03_024.png)
    state is "down" in the ![](img/Formula_02_107.png)-direction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_3.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Bloch sphere [authors]
  prefs: []
  type: TYPE_NORMAL
- en: 'We derived the generalized formula for a qubit in *Section 2.1.2, Addition
    of momenta using Clebsch-Gordan coefficients, example: Coupling spin and angular
    momentum (*![](img/Formula_03_041.png)*):*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_042.png)'
  prefs: []
  type: TYPE_IMG
- en: 'However, established by the quantum computing industry and set as a convention,
    we have a change of variables for the angles ![](img/Formula_03_043.png) and ![](img/Formula_03_044.png)
    for a qubit defined on the Bloch sphere where the following applies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_045.png) in ![](img/Formula_03_046.png), which becomes ![](img/Formula_03_047.png)
    in ![](img/Formula_03_048.png) (please note that the arccosine of a positive number
    is a first quadrant angle)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: '![](img/Formula_03_049.png) is the relative phase in ![](img/Formula_03_050.png),
    neglecting the global phase ![](img/Formula_03_051.png)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: 'This change of variables results in the following form of the state vector
    (or wave function) for a qubit on the Bloch sphere:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_052.png)'
  prefs: []
  type: TYPE_IMG
- en: where we have replaced the spin-up and spin-down functions with the state vectors
    ![](img/Formula_03_053.png) and ![](img/Formula_03_054.png), respectively. From
    a chemical perspective, please note that the qubit state ![](img/Formula_03_055.png)
    indicates the angular momentum quantum numbers ![](img/Formula_03_056.png) with
    spin-up, and therefore does not have any angular momentum projection on the ![](img/Formula_02_513.png)-axis.
    Furthermore, the qubit state ![](img/Formula_03_058.png) indicates the angular
    momentum quantum numbers ![](img/Formula_03_059.png) with spin-down and does have
    angular momentum projection on the ![](img/Formula_03_060.png)-axis. This is important
    to remember when we introduce the Pauli matrices in *Section 3.1.6, Pauli matrices*,
    as we will see how the chemical information is modified when we apply operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the Bloch sphere, angles are twice as big as in Hilbert space. For instance,
    ![](img/Formula_03_055.png) and ![](img/Formula_03_062.png) are orthogonal in
    Hilbert space, and on the Bloch sphere their angle is ![](img/Formula_03_063.png).
    Further, we would like to point out that ![](img/Formula_03_064.png) determines
    the probability to measure the ![](img/Formula_03_055.png) and ![](img/Formula_03_054.png)
    states with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_053.png) such that ![](img/Formula_03_068.png)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: '![](img/Formula_03_054.png) such that ![](img/Formula_03_070.png)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: 'We show the Bloch vector for a qubit in different directions on the Bloch sphere,
    which we call pole states, as shown in the table shown in Figure 3.3:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_03_Table_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Pole states in the computational basis and their representation
    on the Bloch sphere
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.5\. Displaying the Bloch vector corresponding to a state vector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following code, the `check` function performs sanity checks on a given
    complex vector ![](img/Formula_03_101.png) to ensure it is a state vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the `ToBloch()` function computes the Bloch vector of a given state vector
    (complex vector) and displays the angles in LaTeX format and the vector on the
    Bloch sphere. It has two input parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`s`: A state vector, a complex vector ![](img/Formula_03_102.png).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`show`: Set to `True` to display the angles and the vector on the Bloch sphere.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It has three output parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`theta`: ![](img/Formula_03_103.png) in ![](img/Formula_03_104.png) is the
    angle on the Bloch sphere.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`phi`: ![](img/Formula_03_105.png) in ![](img/Formula_03_106.png) is the relative
    phase, neglecting the global phase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r`: This is the vector on the Bloch sphere.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code displays the Bloch vector corresponding to the state vector
    ![](img/Formula_03_107.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the result with the Bloch sphere displayed using the `QuTiP Bloch()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_3.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Displaying a vector on the Bloch sphere
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `ToS` function computes a state vector of a Bloch vector. It has
    three input parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`theta`: ![](img/Formula_03_108.png) in ![](img/Formula_03_109.png) is the
    angle on the Bloch sphere.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`phi`: ![](img/Formula_03_051.png) in ![](img/Formula_03_106.png) is the relative
    phase, neglecting the global phase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`show`: This is set to `True` to display the input angles and the state vector.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It has one output parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`s`: a state vector, a complex vector ![](img/Formula_03_112.png)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we compute the complex amplitudes of a Bloch vector with ![](img/Formula_03_113.png)
    and ![](img/Formula_03_114.png) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_115.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_03_116.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 3.1.6\. Pauli matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three Pauli matrices, ![](img/Formula_03_117.png) , ![](img/Formula_03_118.png),
    and ![](img/Formula_03_119.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_120.png), ![](img/Formula_03_121.png), ![](img/Formula_03_122.png)'
  prefs: []
  type: TYPE_IMG
- en: 'which are Hermitian and unitary, making the square of each equal to the ![](img/Formula_03_123.png)
    identity matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_124.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Each of the Pauli matrices is equal to its inverse:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_125.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_03_126.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_03_127.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We summarize the Pauli matrices and the operations on a qubit that yields the
    associated eigenvectors in *Figure 3.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_03_Table_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Pauli matrices and the associated eigenvectors
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 3.6*, we display on the far-left side the ![](img/Formula_03_140.png)
    qubit state, which has zero angular momentum projection on the ![](img/Formula_02_107.png)-axis,
    as indicated by the dark circle under the Bloch sphere. In the middle, we display
    the ![](img/Formula_03_142.png) qubit state, which has an angular momentum projection
    on the ![](img/Formula_03_143.png)-axis indicated by a light grey circle under
    the Bloch sphere. Recall we discussed the angular momentum projection for the
    ![](img/Formula_03_144.png) and ![](img/Formula_03_145.png) qubit states in *Section
    3.1.4, Bloch sphere*. On the far-right side, we indicate the ![](img/Formula_03_146.png)
    operation on the ![](img/Formula_03_147.png) qubit state, which modifies the angular
    momentum projection by ![](img/Formula_03_148.png).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_3.6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Pauli Z operation on basis states ![](img/Formula_03_144.png) and
    ![](img/Formula_03_1451.png) illustrated with Grok the Bloch sphere
  prefs: []
  type: TYPE_NORMAL
- en: The ![](img/Formula_03_151.png) operation does not have an effect on the angular
    momentum projection, while the ![](img/Formula_03_152.png) operation modifies
    the angular momentum projection by ![](img/Formula_03_153.png).
  prefs: []
  type: TYPE_NORMAL
- en: Measurement in the sign basis ![](img/Formula_03_154.png)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us measure a state ![](img/Formula_03_155.png) in the sign basis ![](img/Formula_03_156.png)
    which is also known as a measurement according to the Pauli matrix ![](img/Formula_03_157.png).
    To make this measurement, we perform a change of basis from the sign basis ![](img/Formula_03_158.png)
    to the standard basis ![](img/Formula_03_159.png) where:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_160.jpg)![](img/Formula_03_161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'which allows us to rewrite the state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_162.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The possible outcomes of a measurement with their corresponding probabilities
    and new state are listed in *Figure 3.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_03_Table_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – Measurement in the sign basis ![](img/Formula_03_168.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'The expectation value of the measurement of a state ![](img/Formula_03_169.png)
    according to the Pauli ![](img/Formula_03_170.png) operation is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_171.png)'
  prefs: []
  type: TYPE_IMG
- en: 'which means we need to calculate the bra in the sign basis by taking the complex
    conjugate transpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_172.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We also need to transform the Pauli operation from the standard basis to the
    sign basis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_173.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Recall that a ket times a bra, as seen previously (![](img/Formula_03_174.png)
    and ![](img/Formula_03_175.png)), is an outer product that yields a matrix, whereas
    a bra times a ket is a scalar. With this, we have the expectation value calculated
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_176.jpg)![](img/Formula_03_177.jpg)![](img/Formula_03_178.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Please remember that in general, ![](img/Formula_03_005.png) and ![](img/Formula_03_006.png)
    are complex numbers, and the imaginary part can be zero. The expectation value
    is the sum of all the possible outcomes (1 and -1) of a measurement of a state
    ![](img/Formula_03_181.png) in the sign basis weighted by their probabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Decomposing a matrix into the weighted sum of the tensor product of Pauli matrices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It can be shown that any matrix can be decomposed into the weighted sum of
    the tensor product of the identity matrix and the Pauli matrices ![](img/Formula_03_182.png),
    where ![](img/Formula_03_183.png) with weights ![](img/Formula_03_184.png) and
    ![](img/Formula_03_185.png) qubits:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_186.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For Hermitian matrices, all weights ![](img/Formula_03_187.png) are real.
  prefs: []
  type: TYPE_NORMAL
- en: 'We provide a proof for any 2x2 matrix, ![](img/Formula_03_188.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_189.jpg)![](img/Formula_03_190.jpg)![](img/Formula_03_191.jpg)![](img/Formula_03_192.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Since ![](img/Formula_03_193.png), hence ![](img/Formula_03_194.png), we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_195.jpg)![](img/Formula_03_196.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Starting from the decomposition of a 2x2 matrix as a sum of outer products:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_197.png)'
  prefs: []
  type: TYPE_IMG
- en: 'we can then write:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_198.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_03_199.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 3.2\. Quantum gates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Quantum gates are unitary operators (![](img/Formula_03_200.png)) working on
    one, two, or three qubits. The norm is preserved when applied to a quantum state.
    The action of a quantum gate on a quantum state corresponds to the multiplication
    of the matrix representing the gate by the vector representing the quantum state:
    ![](img/Formula_03_201.png).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, a tensor product of ![](img/Formula_03_202.png) qubits is
    represented with the first qubit on the left-most side of the tensor product:
    ![](img/Formula_03_203.png) where ![](img/Formula_03_204.png). Please note that
    we are not using the Qiskit tensor ordering of qubits unless specifically specified.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Section 3.2.1, Single-qubit quantum gates*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Section 3.2.2, Two-qubit quantum gates*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Section 3.2.3, Three-qubit quantum gates*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Section 3.2.4, Serial wired gates and parallel quantum gates*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Section 3.2.5, Creation of a Bell state*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Section 3.2.6, Parallel Hadamard gates*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3.2.1\. Single-qubit quantum gates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A single-qubit gate ![](img/Formula_03_205.png) has a ![](img/Formula_03_206.png)
    unitary matrix form: ![](img/Formula_03_207.png).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we describe in detail the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_208.png) gate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hadamard (![](img/Formula_03_209.png)) gate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generalized single-qubit quantum gate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We summarize commonly used quantum gates as well as provide some useful relationships.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_210.png) gate'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An ![](img/Formula_03_208.png) gate maps ![](img/Formula_03_140.png) to ![](img/Formula_03_213.png)
    and ![](img/Formula_03_214.png) to ![](img/Formula_03_053.png). It is the quantum
    equivalent of the NOT gate for classical computers and is sometimes called a bit-flip.
    For classical computing, the NOT gate changes a 0 to a 1 and a 1 to a 0\. The
    ![](img/Formula_03_216.png) gate equates to a rotation by π radians around the
    X-axis of the Bloch sphere.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_217.png)'
  prefs: []
  type: TYPE_IMG
- en: Hadamard (![](img/Formula_03_218.png)) gate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A Hadamard gate maps the basis state ![](img/Formula_03_219.png) to ![](img/Formula_03_220.png),
    which is also written as ![](img/Formula_03_221.png), and ![](img/Formula_03_222.png)
    to ![](img/Formula_03_223.png), which is also written as ![](img/Formula_03_224.png).
    It represents a rotation of π about the axis that is in the middle (45![](img/Formula_03_225.png)
    angle) of the ![](img/Formula_03_226.png)- and ![](img/Formula_03_227.png)-axis.
    A measurement of the state ![](img/Formula_03_228.png) or of the state ![](img/Formula_03_229.png)
    will have equal probabilities of being 0 or 1, creating a superposition of states.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_230.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It is convenient to write the Hadamard gate applied to the 0th qubit (![](img/Formula_03_231.png))
    in the register as follows: ![](img/Formula_03_232.png) where ![](img/Formula_03_233.png).
    Please note that the Hadamard gate (![](img/Formula_03_209.png)) has similar notation
    to the Hamiltonian operator (![](img/Formula_03_235.png); the difference is the
    hat (![](img/Formula_03_236.png)) symbol.'
  prefs: []
  type: TYPE_NORMAL
- en: General single-qubit quantum gate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All single-qubit gates can be obtained from the following matrix ![](img/Formula_03_237.png),
    which describes all unitary matrices up to a global phase factor by an appropriate
    choice of parameters ![](img/Formula_03_238.png) with ![](img/Formula_03_239.png)
    , ![](img/Formula_03_240.png) , ![](img/Formula_03_241.png) [Qiskit_Op]:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_242.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The gate ![](img/Formula_03_243.png) has the matrix form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The gate ![](img/Formula_03_245.png) and has the matrix form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_246.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary of single-qubit quantum gates and useful relationships
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Figure 3.8* presents the main list of single-qubit quantum gates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_03_Table_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – Single-qubit quantum gates
  prefs: []
  type: TYPE_NORMAL
- en: 'The rotation operator gates ![](img/Formula_03_312.png), ![](img/Formula_03_313.png),
    and ![](img/Formula_03_314.png) perform rotations about the ![](img/Formula_03_315.png),
    ![](img/Formula_03_316.png), and ![](img/Formula_03_317.png) axes respectively
    of the Bloch sphere:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_318.jpg)![](img/Formula_03_319.jpg)![](img/Formula_03_320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We would like to point out that the ![](img/Formula_03_321.png) gate can be
    obtained by using a combination of the Hadamard gate and the ![](img/Formula_03_322.png)
    gate: ![](img/Formula_03_323.png). The converse is also true: ![](img/Formula_03_324.png).
    It means we can project a state onto the ![](img/Formula_03_315.png)-axis of the
    Bloch sphere when applying a ![](img/Formula_03_326.png) gate before measuring.
    Same with the ![](img/Formula_03_316.png)-axis when applying first an ![](img/Formula_03_328.png)
    gate, then an ![](img/Formula_03_326.png) gate. This way we can perform qubit
    tomography (that is, reconstructing the Bloch vector through ![](img/Formula_03_330.png),
    ![](img/Formula_03_316.png), and ![](img/Formula_03_332.png) measurements). These
    gate operations are summarized in *Figure 3.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_3.9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – Relations ![](img/Formula_03_333.png), ![](img/Formula_03_334.png)
  prefs: []
  type: TYPE_NORMAL
- en: 3.2.2\. Two-qubit quantum gates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A two-qubit gate ![](img/Formula_03_335.png) is a ![](img/Formula_03_336.png)
    unitary matrix, ![](img/Formula_03_337.png) that acts on two qubits.
  prefs: []
  type: TYPE_NORMAL
- en: We summarize commonly used two-qubit quantum gates in *Figure 3.10*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_03_Table_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – Two-qubit quantum gates
  prefs: []
  type: TYPE_NORMAL
- en: 3.2.3\. Three-qubit quantum gates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A three-qubit gate U is an ![](img/Formula_03_364.png) unitary matrix ![](img/Formula_03_365.png)
    that acts on three qubits. We summarize commonly used three-qubit quantum gates
    in *Figure 3.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_03_Table_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – Three-qubit quantum gates
  prefs: []
  type: TYPE_NORMAL
- en: 3.2.4\. Serially wired gates and parallel quantum gates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Operations on quantum gates are applied sequentially from left to right, and
    there are no loops. Two gates ![](img/Formula_03_335.png) and ![](img/Formula_03_384.png)
    in series are equivalent to the matrix product of the two gates, as shown in *Figure
    3.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_03_Table_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – Serially wired quantum gates
  prefs: []
  type: TYPE_NORMAL
- en: 'Two gates ![](img/Formula_03_391.png) and ![](img/Formula_03_392.png) in parallel
    are equivalent to the tensor product of the two gates ![](img/Formula_03_393.png),
    as shown in *Figure 3.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_03_Table_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.13 – Parallel quantum gates
  prefs: []
  type: TYPE_NORMAL
- en: 3.2.5\. Creation of a Bell state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Bell states are maximally entangled pure quantum states, and there are only
    four:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_409.jpg)![](img/Formula_03_410.jpg)![](img/Formula_03_411.jpg)![](img/Formula_03_412.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A quantum circuit is an ordered sequence of instructions, quantum gates, measurements,
    and resets that is applied to registers of qubits and may be conditioned on real-time
    classical computation. Several quantum hardware platforms now support dynamic
    quantum circuits, which allow concurrent classical processing of mid-circuit measurement
    results [Corcoles] [IBM_mid]. In *Section 3.4, Preparing a permutation symmetric
    or antisymmetric state*, we demonstrate a classical program that aims to obtain
    the desired quantum state by post selecting the result of a measurement of a control
    qubit. There is no loop in a quantum circuit, but we can have a classical loop
    that appends a quantum sub-circuit. In Qiskit, we use the `QuantumRegister` class
    to create a register of qubits and the `QuantumCircuit` class to create a quantum
    circuit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build a quantum circuit that creates the first Bell state ![](img/Formula_03_413.png)
    with Qiskit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 3.14* shows the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_3.14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.14 – Qiskit quantum circuit that creates a Bell state
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `Statevector.from_instruction()` class method from the `quantum_info`
    module to get the final state vector ![](img/Formula_03_414.png) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 3.15* shows the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_3.15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.15 – Final state vector – Bell state
  prefs: []
  type: TYPE_NORMAL
- en: The final state vector can only be measured in either the state ![](img/Formula_03_415.png)
    or ![](img/Formula_03_416.png), each with a probability of 1/2.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `DensityMatrix.from_instruction()` class method to obtain the density
    matrix representation of the final state vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 3.16* shows the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_3.16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.16 – Density matrix – Bell state
  prefs: []
  type: TYPE_NORMAL
- en: 'We can visualize the density matrix using a cityscape plot of the state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 3.17* shows the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_3.17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.17 – Cityscape plot – Bell state
  prefs: []
  type: TYPE_NORMAL
- en: 3.2.6\. Parallel Hadamard gates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It can be shown that applying parallel Hadamard gates to a register of qubits
    initialized in the zero state puts it in a uniform superposition of all possible
    states. Let''s experiment with the effect of applying one, two, and three Hadamard
    gates. In this section, we''ll build the following:'
  prefs: []
  type: TYPE_NORMAL
- en: One Hadamard gate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two parallel Hadamard gates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three parallel Hadamard gates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `create_parallel_H()` function creates a quantum circuit with n parallel
    Hadamard gates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The function `run_parallel_H()` creates and executes a quantum circuit with
    n parallel Hadamard gates and displays a diagram of the final state vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a quantum circuit with just one Hadamard gate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 3.18* shows the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_3.18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.18 – One Hadamard gate
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we build a quantum circuit with two parallel Hadamard gates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 3.19* shows the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_3.19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.19 – Two parallel Hadamard gates
  prefs: []
  type: TYPE_NORMAL
- en: 'Last, let''s build a circuit with three parallel Hadamard gates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 3.20* shows the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_3.20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.20 – Three parallel Hadamard gates
  prefs: []
  type: TYPE_NORMAL
- en: 3.3\. Computation-driven interference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we introduce the process of a generic quantum computation in
    *Section 3.3.1, Quantum computation process*. Then we give an example of a simulation
    inspired by a chemical experiment in *Section 3.3.2, Simulating interferometric
    sensing of a quantum superposition of left- and right-handed enantiomer states*.
    In chemistry, molecules or ions that are mirror images of each other are called
    enantiomers or optical isomers. If these images are non-superimposable, they are
    called chiral molecules [ChemChiral] and they differ in their ability to rotate
    plane polarized light either to the left or to the right [Wonders]. Researchers
    have proposed an experiment to prepare a quantum superposition of left- and right-handed
    states of enantiomers and to perform interferometric sensing of chirality-dependent
    forces [Stickler].
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.1\. Quantum computation process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Quantum computing uses interference and the quantum physical phenomena of superposition
    and entanglement. A typical quantum computation comprises the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Prepare a uniform superposition of all possible basis states. A register of
    qubits initialized in the zero state is put in a uniform superposition of all
    possible basis states simply by applying parallel Hadamard gates, as we illustrated
    previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Orchestrate quantum interference and entanglement. A quantum algorithm ought
    to be designed such that at the end of a computation, only the relative amplitudes
    and the phases of those quantum states that are of interest will remain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the measurements multiple times. Measurements are repeated hundreds or
    thousands of times in order to obtain a distribution over the possible measurement
    outcomes. This is the key difference between quantum and classical computing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 3.3.2\. Simulating interferometric sensing of a quantum superposition of left-
    and right-handed enantiomer states
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s design, with Qiskit, a quantum circuit inspired by the interferometer
    involving enantiomers. We represent a single enantiomer with two qubits. We encode
    in the direction of propagation qubit ![](img/Formula_03_417.png) the horizontal
    propagation as the state ![](img/Formula_03_418.png) and the vertical propagation
    as the state ![](img/Formula_03_024.png) . We simulate a mirror by the Pauli ![](img/Formula_03_420.png)
    matrix and a beam splitter (![](img/Formula_03_421.png)) by the matrix ![](img/Formula_03_422.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_423.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'By convention, a phase shift of ![](img/Formula_03_424.png) is assigned to
    reflection. From the preceding unitary matrix, we create a beam splitter gate
    named BS with the following Qiskit code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We encode the following in the handedness qubit ![](img/Formula_03_425.png)
    :'
  prefs: []
  type: TYPE_NORMAL
- en: A left-handed state as the ![](img/Formula_03_426.png) state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A right-handed state as the ![](img/Formula_03_024.png) state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A superposition of left- and right-handed states as ![](img/Formula_03_428.png)
    obtained by applying a Hadamard gate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We simulate a polarizing beam splitter (![](img/Formula_03_429.png)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_430.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'which transmits left-handed and reflects right-handed states with the matrix
    PBS [Rioux]. Unlike the beam splitter, there is no phase change on reflection.
    From the preceding unitary matrix, we create a polarizing beam splitter gate named
    PBS with the following Qiskit code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We define the `show()` function, which displays the drawing of a quantum circuit
    and the state of the state vector using LaTeX as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We simulate the action of a polarizing beam splitter on an enantiomer moving
    horizontally and in the right-handed state with the following Qiskit code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 3.21* shows the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_3.21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.21 – Simulation of the interaction of a right-handed enantiomer with
    a polarizing beam splitter
  prefs: []
  type: TYPE_NORMAL
- en: The enantiomer moving horizontally and in the right-handed state, represented
    by ![](img/Formula_03_431.png), using Qiskit tensor ordering of qubits, has been
    reflected in the vertical direction of propagation by the polarizing beam splitter,
    represented by ![](img/Formula_03_432.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'We simulate the action of a polarizing beam splitter on an enantiomer moving
    horizontally and in a superposition of left- and right-handed states with the
    following Qiskit code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 3.22* shows the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_3.22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.22 – Simulation of the interaction of a left- and right-handed enantiomer
    with a polarizing beam splitter
  prefs: []
  type: TYPE_NORMAL
- en: The enantiomer moving horizontally and in a superposition of the left- and right-handed
    states, represented by ![](img/Formula_03_433.png), using Qiskit tensor ordering
    of qubits, has been put by the polarizing beam splitter in the Bell state ![](img/Formula_03_434.png),
    a superposition of left-handed moving horizontally and right-handed moving vertically,
    thereby achieving interferometric sensing.
  prefs: []
  type: TYPE_NORMAL
- en: Now we move on to preparing permutation symmetric and antisymmetic states.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4\. Preparing a permutation symmetric or antisymmetric state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Given two qubits ![](img/Formula_03_435.png) and ![](img/Formula_03_436.png)
    , we want to build a symmetrized state that remains invariant under a permutation
    of the qubits ![](img/Formula_03_437.png) and ![](img/Formula_03_438.png), or
    an antisymmetrized state that is multiplied by ![](img/Formula_03_439.png) under
    a permutation of the qubits ![](img/Formula_03_440.png) and ![](img/Formula_03_441.png).
    In this section, we show how to prepare such states in a probabilistic manner
    with a quantum circuit prepared and simulated with Qiskit:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Section 3.4.1, Creating random states*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Section 3.4.2, Creating a quantum circuit and initializing qubits*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Section 3.4.3, Creating a circuit that swaps two qubits with a controlled
    swap gate*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Section 3.4.4, Post selecting the control qubit until the desired state is
    obtained*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Section 3.4.5, Examples of final symmetrized and antisymmetrized states*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3.4.1\. Creating random states
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We define a function called `init_random()` that creates random 1-qubit states
    `s1` and `s2` that we will use later to run experiments with random states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 3.4.2\. Creating a quantum circuit and initializing qubits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We define the `setup_qc()` function, which sets up the initialization instruction
    to create qubits ![](img/Formula_03_442.png) and ![](img/Formula_03_443.png) from
    the state vectors `s1` and `s2` given as input and a quantum circuit `qc` with
    a control qubit ![](img/Formula_03_425.png) initialized in state ![](img/Formula_03_445.png),
    qubits ![](img/Formula_03_446.png) and ![](img/Formula_03_447.png), and a classical
    register `c` for measuring ![](img/Formula_03_448.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 3.4.3\. Creating a circuit that swaps two qubits with a controlled swap gate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We define the `swapper()` function, which creates a quantum circuit as follows
    [Spheres]:'
  prefs: []
  type: TYPE_NORMAL
- en: Applying a Hadamard gate to the control qubit ![](img/Formula_03_449.png) which
    puts it in the state ![](img/Formula_03_450.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying a controlled swap gate, which puts the two qubits ![](img/Formula_03_451.png)
    and ![](img/Formula_03_452.png) in a superposition of being swapped and not swapped
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying again a Hadamard gate to the control qubit ![](img/Formula_03_453.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s get the unitary matrix corresponding to the swapper quantum circuit
    with the unitary simulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 3.23* shows the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_3.23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.23 – Unitary matrix of the swapper circuit
  prefs: []
  type: TYPE_NORMAL
- en: Computing the action of the swapper unitary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The initial state vector pertaining to the two qubits ![](img/Formula_03_454.png)
    and ![](img/Formula_03_455.png) can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_456.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The swapper unitary acts on the initial state vector as follows, using Qiskit
    ordering of the tensor product:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_457.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_03_458.png)'
  prefs: []
  type: TYPE_IMG
- en: Computing the final state when the control qubit ![](img/Formula_03_459.png)
    is measured in state ![](img/Formula_03_460.png)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If the control qubit ![](img/Formula_03_461.png) is measured in state ![](img/Formula_03_462.png),
    then the final state is computed by discarding all amplitudes that do not contribute
    to this outcome, ![](img/Formula_03_463.png) ![](img/Formula_03_464.png), ![](img/Formula_03_465.png)
    ![](img/Formula_03_466.png) and then renormalizing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_467.png)'
  prefs: []
  type: TYPE_IMG
- en: Recall that ![](img/Formula_03_468.png), ![](img/Formula_03_469.png), ![](img/Formula_03_470.png)
    and ![](img/Formula_03_471.png) are the Bell states we introduced in *Section
    3.2.5, Creation of a Bell state*. The amplitudes ![](img/Formula_03_472.png) of
    ![](img/Formula_03_473.png) and ![](img/Formula_03_474.png) of ![](img/Formula_03_475.png)
    are left unchanged up to a renormalization factor in the final state. The symmetrized
    Bell state ![](img/Formula_03_476.png) is left unchanged. The amplitudes ![](img/Formula_03_477.png)
    of ![](img/Formula_03_478.png) and ![](img/Formula_03_479.png) of ![](img/Formula_03_480.png)
    are mixed in the Bell state ![](img/Formula_03_481.png), which is symmetrized.
  prefs: []
  type: TYPE_NORMAL
- en: Computing the final state when the control qubit ![](img/Formula_03_482.png)
    is measured in state ![](img/Formula_03_483.png)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If the control qubit ![](img/Formula_03_484.png) is measured in state ![](img/Formula_03_485.png),
    then the final state is computed by discarding all amplitudes that do not contribute
    to this outcome, ![](img/Formula_03_486.png) ![](img/Formula_03_487.png), ![](img/Formula_03_488.png)
    and ![](img/Formula_03_489.png), and then renormalizing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_490.png)'
  prefs: []
  type: TYPE_IMG
- en: The only non-null amplitudes of the final state are those in the ![](img/Formula_03_491.png)
    and ![](img/Formula_03_492.png) subspace, which are mixed in the Bell state ![](img/Formula_03_493.png),
    which is antisymmetrized.
  prefs: []
  type: TYPE_NORMAL
- en: These properties of symmetry and antisymmetry are key to efficient implementations
    of the **Variational Quantum Eigensolver** (**VQE**) algorithms [Gard] that we
    will cover in [*Chapter 6*](B18268_06_ePub.xhtml#_idTextAnchor228)*, Variational
    Quantum Eigensolver Algorithm*.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.4\. Post selecting the control qubit until the desired state is obtained
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We define the `post_select()` function, which performs a loop that executes
    the swapper circuit and measures the state of the control qubit ![](img/Formula_03_425.png)
    until the desired symmetrized or antisymmetrized state is obtained, or until the
    maximum number of iterations is reached:'
  prefs: []
  type: TYPE_NORMAL
- en: Append a circuit created by the `swapper()` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measure the control qubit ![](img/Formula_03_495.png). If we get 0, then qubits
    ![](img/Formula_03_496.png) and ![](img/Formula_03_436.png) are in a symmetrized
    state and if we get 1, then qubits ![](img/Formula_03_498.png) and ![](img/Formula_03_499.png)
    are in an antisymmetrized state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, `post_select()` calls the `proc_result()` function to process the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `post_select()` function has the following input parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`simulator`, by default `statevector_simulator`, which simulates perfect qubits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`symm:` set to `True` to get a symmetrized state and `False` to get an antisymmetrized
    state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shots` is the number of shots, and by default is set to `1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max_iter` is the maximum number of iterations, and by default is set to `20`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`swap_test` is set to `True` to perform a swap test to determine whether the
    final state is permutation symmetric or permutation asymmetric, and by default
    is set to `False`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `proc_result()` function processes the results, displays the saved state
    vector, and calls the `factor()` function. If the input parameter `swap_test`
    is set to `True`, it calls the `swap_check()` function, which tests whether the
    final state is permutation symmetric or permutation asymmetric.
  prefs: []
  type: TYPE_NORMAL
- en: 'It returns `Success`, a Boolean; `True` if the desired state has been obtained,
    `False` otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sym_test()` function determines whether two amplitudes of a state vector
    are equal or opposite to one another and the sum of their modulus squared is equal
    to 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `factor()` function attempts to factor the final state into a tensor product
    of the control qubit ![](img/Formula_03_500.png) and the permutation symmetric
    Bell states ![](img/Formula_03_501.png) or ![](img/Formula_03_502.png), or the
    permutation antisymmetric Bell states ![](img/Formula_03_503.png) or ![](img/Formula_03_504.png),
    which were introduced in *Section 3.2.5, Creation of a Bell state*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `swap_check()` function tests whether the final state is permutation symmetric
    or permutation asymmetric. It calls the `swap()` function and then compares the
    states before and after the swap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `swap()` function performs a swap of qubits ![](img/Formula_03_505.png)
    and ![](img/Formula_03_455.png), measures the control qubit, and returns the final
    state vector for comparison purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 3.4.5\. Examples of final symmetrized and antisymmetrized states
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We now implement five experiments creating:'
  prefs: []
  type: TYPE_NORMAL
- en: A symmetrized state from state ![](img/Formula_03_507.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An antisymmetrized state from state ![](img/Formula_03_508.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A symmetrized state from qubits initialized with random states
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An antisymmetrized state from qubits initialized with random states
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A symmetrized state from the Bell state ![](img/Formula_03_509.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Experiment creating a symmetrized state from state ![](img/Formula_03_510.png)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We create two state vectors in states ![](img/Formula_03_511.png) and ![](img/Formula_03_022.png)
    , we give them as input to the `setup_qc()` function, and then we call the `post_select()`
    function with `symm` set to `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We have obtained the symmetrized state ![](img/Formula_03_513.png) , as shown
    in *Figure 3.24*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_3.24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.24 – Symmetrized state obtained from state ![](img/Formula_03_514.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'We show the density matrix using a cityscape plot of the final state in *Figure
    3.25*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_3.25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.25 – Cityscape plot of the symmetrized state obtained from state ![](img/Formula_03_515.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'We display the quantum circuit with the `draw()` method of the quantum circuit
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'After one iteration, the quantum circuit looks like *Figure 3.26*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_3.26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.26 – Quantum circuit after one iteration
  prefs: []
  type: TYPE_NORMAL
- en: Experiment creating an antisymmetrized state from state ![](img/Formula_03_516.png)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We create two state vectors in states ![](img/Formula_03_517.png) and ![](img/Formula_03_022.png)
    , we give them as input to the `setup_qc()` function, and then we call the `post_select()`
    function with `symm` set to `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We have obtained the antisymmetrized state ![](img/Formula_03_519.png), as
    shown in *Figure 3.27*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_3.27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.27 – Antisymmetrized state obtained from state ![](img/Formula_03_520.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'We show the density matrix using a cityscape plot of the final state in *Figure
    3.28*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_3.28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.28 – Cityscape plot of the antisymmetrized state obtained from state
    ![](img/Formula_03_521.png)
  prefs: []
  type: TYPE_NORMAL
- en: Experiment creating a symmetrized state from qubits initialized with random
    states
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We create two state vectors in random states with `init_random()`, we give them
    as input to the `setup_qc()` function, and then we call the `post_select()` function
    with `symm` set to `True` and `swap_test` set to `True` to confirm that the final
    state is indeed permutation symmetric. We expect the final state to have four
    non-null amplitudes, based on the computation made in *Section 3.4.3, Creating
    a circuit that swaps two qubits with a controlled swap gate, Computing the final
    state when the control qubit* ![](img/Formula_03_522.png) *is measured in state*
    ![](img/Formula_03_523.png)*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In *Figure 3.29*, we show a result where the final state has four non-null
    amplitudes, as expected, and the swap test has confirmed that the final state
    is permutation symmetric:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_3.29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.29 – Symmetrized state obtained from qubits initialized in random states
  prefs: []
  type: TYPE_NORMAL
- en: 'In the cityscape plot of the final state shown in *Figure 3.30*, we see that
    the state ![](img/Formula_03_524.png) has the largest probability to come out
    after measuring the final state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_3.30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.30 – Cityscape plot of symmetrized state obtained from qubits initialized
    in random states
  prefs: []
  type: TYPE_NORMAL
- en: Experiment creating an antisymmetrized state from qubits initialized with random
    states
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We create two state vectors in random states with `init_random()`, we give
    them as input to the `setup_qc()` function, and then we call the `post_select()`
    function with `symm` set to `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We have obtained the antisymmetrized state ![](img/Formula_03_525.png) up to
    a global phase, as shown in *Figure 3.31*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_3.31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.31 – Antisymmetrized state obtained from qubits initialized in random
    states
  prefs: []
  type: TYPE_NORMAL
- en: 'We show the density matrix using a cityscape plot of the final state in *Figure
    3.32*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_3.32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.32 – Cityscape plot of the antisymmetrized state obtained from qubits
    initialized in random states
  prefs: []
  type: TYPE_NORMAL
- en: Experiment creating a symmetrized state from the Bell state ![](img/Formula_03_526.png)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We define a function called `setup1_qc()`, which sets up a quantum circuit
    that puts qubits ![](img/Formula_03_527.png) and ![](img/Formula_03_528.png) into
    the Bell state ![](img/Formula_03_529.png), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We execute the following code, which calls `setup1_qc()` to create a Bell state
    ![](img/Formula_03_530.png) and then calls the `post_select()` function with `symm`
    set to `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected in *Section 3.4.3, Creating a circuit that swaps two qubits with
    a controlled swap gate*, the swapper circuit followed by a measurement of the
    qubit ![](img/Formula_03_531.png) in state 0 leaves the symmetrized Bell state
    ![](img/Formula_03_532.png) unchanged, as shown in *Figure 3.33*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_3.33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.33 – Symmetrized state obtained from the Bell state ![](img/Formula_03_533.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'We show the density matrix using a cityscape plot of the final state in *Figure
    3.34*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_3.34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.34 – Cityscape plot of the final state obtained from the Bell state
    ![](img/Formula_03_533.png)
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[ChemChiral] 5.1 Chiral Molecules, Chemistry LibreTexts, 5 Jul 2015, [https://chem.libretexts.org/Bookshelves/Organic_Chemistry/Map%3A_Organic_Chemistry_(Vollhardt_and_Schore)/05._Stereoisomers/5.1%3A_Chiral__Molecules](https://chem.libretexts.org/Bookshelves/Organic_Chemistry/Map%3A_Organic_Chemistry_(Vollhardt_and_Schore)/05._Stereoisomers/5.1%3A_Chiral__Molecules)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Corcoles] A. D. Córcoles, Maika Takita, Ken Inoue, Scott Lekuch, Zlatko K.
    Minev, Jerry M. Chow, and Jay M. Gambetta, Exploiting Dynamic Quantum Circuits
    in a Quantum Algorithm with Superconducting Qubits, Phys. Rev. Lett. 127, 100501,
    31 August 2021, [https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.127.100501](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.127.100501)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Crockett] Christopher Crockett, Superpositions of Chiral Molecules, September
    14, 2021, Physics 14, s108, [https://physics.aps.org/articles/v14/s108](https://physics.aps.org/articles/v14/s108)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Gard] Gard, B.T., Zhu, L., Barron, G.S. et al., Efficient symmetry-preserving
    state preparation circuits for the variational quantum eigensolver algorithm,
    npj Quantum Inf 6, 10 (2020), [https://doi.org/10.1038/s41534-019-0240-1](https://doi.org/10.1038/s41534-019-0240-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Grok] Grok the Bloch Sphere, [https://javafxpert.github.io/grok-bloch/](https://javafxpert.github.io/grok-bloch/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[IBM_CEO] IBM CEO: Quantum computing will take off ''like a rocket ship'' this
    decade, Fast Company, Sept 28, 2021., [https://www.fastcompany.com/90680174/ibm-ceo-quantum-computing-will-take-off-like-a-rocket-ship-this-decade](https://www.fastcompany.com/90680174/ibm-ceo-quantum-computing-will-take-off-like-a-rocket-ship-this-decade)'
  prefs: []
  type: TYPE_NORMAL
- en: '[IBM_comp1] Welcome to IBM Quantum Composer, [https://quantum-computing.ibm.com/composer/docs/iqx/](https://quantum-computing.ibm.com/composer/docs/iqx/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[IBM_comp2] IBM Quantum Composer, [https://quantum-computing.ibm.com/composer/files/new](https://quantum-computing.ibm.com/composer/files/new)'
  prefs: []
  type: TYPE_NORMAL
- en: '[IBM_mid] Mid-Circuit Measurements Tutorial, IBM Quantum systems, [https://quantum-computing.ibm.com/lab/docs/iql/manage/systems/midcircuit-measurement/](https://quantum-computing.ibm.com/lab/docs/iql/manage/systems/midcircuit-measurement/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[NumPy] NumPy: the absolute basics for beginners, [https://numpy.org/doc/stable/user/absolute_beginners.html](https://numpy.org/doc/stable/user/absolute_beginners.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Qiskit] Qiskit, [https://qiskit.org/](https://qiskit.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[QuTiP] QuTiP, Plotting on the Bloch Sphere, [https://qutip.org/docs/latest/guide/guide-bloch.html](https://qutip.org/docs/latest/guide/guide-bloch.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Rioux] Mach-Zehnder Polarizing Interferometer Analyzed Using Tensor Algebra,
    [https://faculty.csbsju.edu/frioux/photon/MZ-Polarization.pdf](https://faculty.csbsju.edu/frioux/photon/MZ-Polarization.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Spheres] How to Prepare a Permutation Symmetric Multiqubit State on an Actual
    Quantum Computer, [https://spheres.readthedocs.io/en/stable/notebooks/9_Symmetrized_Qubits.html](https://spheres.readthedocs.io/en/stable/notebooks/9_Symmetrized_Qubits.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Stickler] B. A. Stickler et al., Enantiomer superpositions from matter-wave
    interference of chiral molecules, Phys. Rev. X 11, 031056 (2021), [https://journals.aps.org/prx/abstract/10.1103/PhysRevX.11.031056](https://journals.aps.org/prx/abstract/10.1103/PhysRevX.11.031056)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Wonders] Optical Isomers, Enantiomers and Chiral Molecules, WondersofChemistry,
    [https://www.youtube.com/watch?v=8TIZdWR4gIU](https://www.youtube.com/watch?v=8TIZdWR4gIU)'
  prefs: []
  type: TYPE_NORMAL
