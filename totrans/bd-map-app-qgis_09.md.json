["```py\nclass MapToolMixin\n    def setLayer(self, layer):\n        self.layer = layer\n\n    def transformCoordinates(self, screenPt):\n        return (self.toMapCoordinates(screenPt),\n                self.toLayerCoordinates(self.layer, screenPt))\n\n    def calcTolerance(self, pos):\n        pt1 = QPoint(pos.x(), pos.y())\n        pt2 = QPoint(pos.x() + 10, pos.y())\n\n        mapPt1,layerPt1 = self.transformCoordinates(pt1)\n        mapPt2,layerPt2 = self.transformCoordinates(pt2)\n        tolerance = layerPt2.x() - layerPt1.x()\n\n        return tolerance\n```", "```py\nclass AddTrackTool(QgsMapTool, MapToolMixin):\n    def __init__(self, canvas, layer, onTrackAdded):\n        QgsMapTool.__init__(self, canvas)\n        self.canvas         = canvas\n        self.onTrackAdded   = onTrackAdded\n        self.rubberBand     = None\n        self.tempRubberBand = None\n        self.capturedPoints = []\n        self.capturing      = False\n        self.setLayer(layer)\n        self.setCursor(Qt.CrossCursor)\n```", "```py\n    def canvasReleaseEvent(self, event):\n        if event.button() == Qt.LeftButton:\n            if not self.capturing:\n                self.startCapturing()\n            self.addVertex(event.pos())\n        elif event.button() == Qt.RightButton:\n            points = self.getCapturedPoints()\n            self.stopCapturing()\n            if points != None:\n                self.pointsCaptured(points)\n\n    def canvasMoveEvent(self, event):\n        if self.tempRubberBand != None and self.capturing:\n            mapPt,layerPt = self.transformCoordinates(event.pos())\n            self.tempRubberBand.movePoint(mapPt)\n\n    def keyPressEvent(self, event):\n        if event.key() == Qt.Key_Backspace or \\\n           event.key() == Qt.Key_Delete:\n            self.removeLastVertex()\n            event.ignore()\n        if event.key() == Qt.Key_Return or \\\n           event.key() == Qt.Key_Enter:\n            points = self.getCapturedPoints()\n            self.stopCapturing()\n            if points != None:\n                self.pointsCaptured(points)\n```", "```py\n    def startCapturing(self):\n        color = QColor(\"red\")\n        color.setAlphaF(0.78)\n\n        self.rubberBand = QgsRubberBand(self.canvas, QGis.Line)\n        self.rubberBand.setWidth(2)\n        self.rubberBand.setColor(color)\n        self.rubberBand.show()\n\n        self.tempRubberBand = QgsRubberBand(self.canvas, QGis.Line)\n        self.tempRubberBand.setWidth(2)\n        self.tempRubberBand.setColor(color)\n        self.tempRubberBand.setLineStyle(Qt.DotLine)\n        self.tempRubberBand.show()\n\n        self.capturing = True\n\n    def stopCapturing(self):\n        if self.rubberBand:\n            self.canvas.scene().removeItem(self.rubberBand)\n            self.rubberBand = None\n        if self.tempRubberBand:\n            self.canvas.scene().removeItem(self.tempRubberBand)\n            self.tempRubberBand = None\n        self.capturing = False\n        self.capturedPoints = []\n        self.canvas.refresh()\n```", "```py\n    def addVertex(self, canvasPoint):\n        mapPt,layerPt = self.transformCoordinates(canvasPoint)\n\n        self.rubberBand.addPoint(mapPt)\n        self.capturedPoints.append(layerPt)\n\n        self.tempRubberBand.reset(QGis.Line)\n        self.tempRubberBand.addPoint(mapPt)\n```", "```py\n    def removeLastVertex(self):\n        if not self.capturing: return\n\n        bandSize     = self.rubberBand.numberOfVertices()\n        tempBandSize = self.tempRubberBand.numberOfVertices()\n        numPoints    = len(self.capturedPoints)\n\n        if bandSize < 1 or numPoints < 1:\n            return\n\n        self.rubberBand.removePoint(-1)\n\n        if bandSize > 1:\n            if tempBandSize > 1:\n                point = self.rubberBand.getPoint(0, bandSize-2)\n                self.tempRubberBand.movePoint(tempBandSize-2,\n                                              point)\n        else:\n            self.tempRubberBand.reset(QGis.Line)\n\n        del self.capturedPoints[-1]\n```", "```py\n    def getCapturedPoints(self):\n        points = self.capturedPoints\n        if len(points) < 2:\n            return None\n        else:\n            return points\n```", "```py\n    def pointsCaptured(self, points):\n        fields = self.layer.dataProvider().fields()\n\n        feature = QgsFeature()\n        feature.setGeometry(QgsGeometry.fromPolyline(points))\n        feature.setFields(fields)\n        feature.setAttribute(\"type\",      TRACK_TYPE_ROAD)\n        feature.setAttribute(\"status\",    TRACK_STATUS_OPEN)\n        feature.setAttribute(\"direction\", TRACK_DIRECTION_BOTH)\n\n        self.layer.addFeature(feature)\n        self.layer.updateExtents()\n        self.onTrackAdded()\n```", "```py\n        self.addTrackTool = AddTrackTool(self.mapCanvas,\n                                         self.trackLayer,\n                                         self.onTrackAdded)\n        self.addTrackTool.setAction(self.actionAddTrack)\n```", "```py\n    def addTrack(self):\n        if self.actionAddTrack.isChecked():\n            self.mapCanvas.setMapTool(self.addTrackTool)\n        else:\n            self.setPanMode()\n```", "```py\n    def onTrackAdded(self):\n        self.modified = True\n        self.mapCanvas.refresh()\n        self.actionAddTrack.setChecked(False)\n        self.setPanMode()\n```", "```py\n    def findFeatureAt(self, pos, excludeFeature=None):\n        mapPt,layerPt = self.transformCoordinates(pos)\n        tolerance = self.calcTolerance(pos)\n        searchRect = QgsRectangle(layerPt.x() - tolerance,\n                                  layerPt.y() - tolerance,\n                                  layerPt.x() + tolerance,\n                                  layerPt.y() + tolerance)\n\n        request = QgsFeatureRequest()\n        request.setFilterRect(searchRect)\n        request.setFlags(QgsFeatureRequest.ExactIntersect)\n\n        for feature in self.layer.getFeatures(request):\n            if excludeFeature != None:\n                if feature.id() == excludeFeature.id():\n                    continue\n            return feature\n\n        return None\n```", "```py\n    def findVertexAt(self, feature, pos):\n        mapPt,layerPt = self.transformCoordinates(pos)\n        tolerance     = self.calcTolerance(pos)\n\n        vertexCoord,vertex,prevVertex,nextVertex,distSquared = \\\n            feature.geometry().closestVertex(layerPt)\n\n        distance = math.sqrt(distSquared)\n        if distance > tolerance:\n            return None\n        else:\n            return vertex\n```", "```py\nimport math\n```", "```py\nsnapToNearestVertex(pos, trackLayer, excludeFeature=None)\n```", "```py\n    def snapToNearestVertex(self, pos, trackLayer,\n                            excludeFeature=None):\n        mapPt,layerPt = self.transformCoordinates(pos)\n        feature = self.findFeatureAt(pos, excludeFeature)\n        if feature == None: return layerPt\n\n        vertex = self.findVertexAt(feature, pos)\n        if vertex == None: return layerPt\n\n        return feature.geometry().vertexAt(vertex)\n```", "```py\n    def addVertex(self, canvasPoint):\n        snapPt = self.snapToNearestVertex(canvasPoint, self.layer)\n        mapPt = self.toMapCoordinates(self.layer, snapPt)\n\n        self.rubberBand.addPoint(mapPt)\n        self.capturedPoints.append(snapPt)\n\n        self.tempRubberBand.reset(QGis.Line)\n        self.tempRubberBand.addPoint(mapPt)\n```", "```py\nclass EditTrackTool(QgsMapTool, MapToolMixin):\n    def __init__(self, canvas, layer, onTrackEdited):\n        QgsMapTool.__init__(self, canvas)\n        self.onTrackEdited = onTrackEdited\n        self.dragging      = False\n        self.feature       = None\n        self.vertex        = None\n        self.setLayer(layer)\n        self.setCursor(Qt.CrossCursor)\n```", "```py\n    def canvasPressEvent(self, event):\n        feature = self.findFeatureAt(event.pos())\n        if feature == None:\n            return\n\n        vertex = self.findVertexAt(feature, event.pos())\n        if vertex == None: return\n\n        if event.button() == Qt.LeftButton:\n            # Left click -> move vertex.\n            self.dragging = True\n            self.feature  = feature\n            self.vertex   = vertex\n            self.moveVertexTo(event.pos())\n            self.canvas().refresh()\n        elif event.button() == Qt.RightButton:\n            # Right click -> delete vertex.\n            self.deleteVertex(feature, vertex)\n            self.canvas().refresh()\n```", "```py\n    def canvasMoveEvent(self, event):\n        if self.dragging:\n            self.moveVertexTo(event.pos())\n            self.canvas().refresh()\n\n    def canvasReleaseEvent(self, event):\n        if self.dragging:\n            self.moveVertexTo(event.pos())\n            self.layer.updateExtents()\n            self.canvas().refresh()\n            self.dragging = False\n            self.feature  = None\n            self.vertex   = None\n```", "```py\n    def canvasDoubleClickEvent(self, event):\n        feature = self.findFeatureAt(event.pos())\n        if feature == None:\n            return\n\n        mapPt,layerPt = self.transformCoordinates(event.pos())\n        geometry      = feature.geometry()\n\n        distSquared,closestPt,beforeVertex = \\\n            geometry.closestSegmentWithContext(layerPt)\n\n        distance = math.sqrt(distSquared)\n        tolerance = self.calcTolerance(event.pos())\n        if distance > tolerance: return\n\n        geometry.insertVertex(closestPt.x(), closestPt.y(),\n                              beforeVertex)\n        self.layer.changeGeometry(feature.id(), geometry)\n        self.onTrackEdited()\n        self.canvas().refresh()\n```", "```py\n    def moveVertexTo(self, pos):\n        snappedPt = self.snapToNearestVertex(pos, self.layer,\n                                             self.feature)\n\n        geometry = self.feature.geometry()\n        layerPt = self.toLayerCoordinates(self.layer, pos)\n        geometry.moveVertex(snappedPt.x(), snappedPt.y(),\n                            self.vertex)\n        self.layer.changeGeometry(self.feature.id(), geometry)\n        self.onTrackEdited()\n```", "```py\n    def deleteVertex(self, feature, vertex):\n        geometry = feature.geometry()\n\n        lineString = geometry.asPolyline()\n        if len(lineString) <= 2:\n            return\n\n        if geometry.deleteVertex(vertex):\n            self.layer.changeGeometry(feature.id(), geometry)\n            self.onTrackEdited()\n```", "```py\n        self.editTrackTool = EditTrackTool(self.mapCanvas,\n                                           self.trackLayer,\n                                           self.onTrackEdited)\n        self.editTrackTool.setAction(self.actionEditTrack)\n```", "```py\n    def editTrack(self):\n        if self.actionEditTrack.isChecked():\n            self.mapCanvas.setMapTool(self.editTrackTool)\n        else:\n            self.setPanMode()\n```", "```py\n    def onTrackEdited(self):\n        self.modified = True\n        self.mapCanvas.refresh()\n```", "```py\nclass DeleteTrackTool(QgsMapTool, MapToolMixin):\n    def __init__(self, canvas, layer, onTrackDeleted):\n        QgsMapTool.__init__(self, canvas)\n        self.onTrackDeleted = onTrackDeleted\n        self.feature        = None\n        self.setLayer(layer)\n        self.setCursor(Qt.CrossCursor)\n\n    def canvasPressEvent(self, event):\n        self.feature = self.findFeatureAt(event.pos())\n\n    def canvasReleaseEvent(self, event):\n        feature = self.findFeatureAt(event.pos())\n        if feature != None and feature.id() == self.feature.id():\n            self.layer.deleteFeature(self.feature.id())\n            self.onTrackDeleted()\n```", "```py\n        self.deleteTrackTool = DeleteTrackTool(\n            self.mapCanvas, self.trackLayer, self.onTrackDeleted)\n        self.deleteTrackTool.setAction(self.actionDeleteTrack)\n```", "```py\n    def deleteTrack(self):\n        if self.actionDeleteTrack.isChecked():\n            self.mapCanvas.setMapTool(self.deleteTrackTool)\n        else:\n            self.setPanMode()\n```", "```py\n    def onTrackDeleted(self):\n        self.modified = True\n        self.mapCanvas.refresh()\n        self.actionDeleteTrack.setChecked(False)\n        self.setPanMode()\n```", "```py\nclass GetInfoTool(QgsMapTool, MapToolMixin):\n    def __init__(self, canvas, layer, onGetInfo):\n        QgsMapTool.__init__(self, canvas)\n        self.onGetInfo = onGetInfo\n        self.setLayer(layer)\n        self.setCursor(Qt.WhatsThisCursor)\n\n    def canvasReleaseEvent(self, event):\n        if event.button() != Qt.LeftButton: return\n        feature = self.findFeatureAt(event.pos())\n        if feature != None:\n            self.onGetInfo(feature)\n```", "```py\n        self.getInfoTool = GetInfoTool(self.mapCanvas,\n                                       self.trackLayer,\n                                       self.onGetInfo)\n        self.getInfoTool.setAction(self.actionGetInfo)\n```", "```py\n    def getInfo(self):\n        self.mapCanvas.setMapTool(self.getInfoTool)\n```", "```py\nclass TrackInfoDialog(QDialog):\n    def __init__(self, parent=None):\n        QDialog.__init__(self, parent)\n        self.setWindowTitle(\"Track Info\")\n```", "```py\n        self.trackTypes = [\"Road\",\n                           \"Walking Trail\",\n                           \"Bike Trail\",\n                           \"Horse Trail\"]\n```", "```py\n        self.directions = [\"Both\",\n                           \"Forward\",\n                           \"Backward\"]\n```", "```py\n        self.statuses = [\"Open\",\n                         \"Closed\"]\n```", "```py\n        self.form = QFormLayout()\n```", "```py\n        self.trackType = QComboBox(self)\n        self.trackType.addItems(self.trackTypes)\n\n        self.trackName = QLineEdit(self)\n\n        self.trackDirection = QComboBox(self)\n        self.trackDirection.addItems(self.directions)\n\n        self.trackStatus = QComboBox(self)\n        self.trackStatus.addItems(self.statuses)\n```", "```py\n        self.form.addRow(\"Type\",      self.trackType)\n        self.form.addRow(\"Name\",      self.trackName)\n        self.form.addRow(\"Direction\", self.trackDirection)\n        self.form.addRow(\"Status\",    self.trackStatus)\n```", "```py\n        self.buttons = QHBoxLayout()\n\n        self.okButton = QPushButton(\"OK\", self)\n        self.connect(self.okButton, SIGNAL(\"clicked()\"),\n                     self.accept)\n\n        self.cancelButton = QPushButton(\"Cancel\", self)\n        self.connect(self.cancelButton, SIGNAL(\"clicked()\"),\n                     self.reject)\n\n        self.buttons.addStretch(1)\n        self.buttons.addWidget(self.okButton)\n        self.buttons.addWidget(self.cancelButton)\n```", "```py\n        self.layout = QVBoxLayout(self)\n        self.layout.addLayout(self.form)\n        self.layout.addSpacing(10)\n\n        self.layout.addLayout(self.buttons)\n        self.setLayout(self.layout)\n        self.resize(self.sizeHint())\n```", "```py\n    def loadAttributes(self, feature):\n        type_attr      = feature.attribute(\"type\")\n        name_attr      = feature.attribute(\"name\")\n        direction_attr = feature.attribute(\"direction\")\n        status_attr    = feature.attribute(\"status\")\n\n        if   type_attr == TRACK_TYPE_ROAD:    index = 0\n        elif type_attr == TRACK_TYPE_WALKING: index = 1\n        elif type_attr == TRACK_TYPE_BIKE:    index = 2\n        elif type_attr == TRACK_TYPE_HORSE:   index = 3\n        else:                                 index = 0\n        self.trackType.setCurrentIndex(index)\n\n        if name_attr != None:\n            self.trackName.setText(name_attr)\n        else:\n            self.trackName.setText(\"\")\n\n        if   direction_attr == TRACK_DIRECTION_BOTH:     index = 0\n        elif direction_attr == TRACK_DIRECTION_FORWARD:  index = 1\n        elif direction_attr == TRACK_DIRECTION_BACKWARD: index = 2\n        else:                                            index = 0\n        self.trackDirection.setCurrentIndex(index)\n\n        if   status_attr == TRACK_STATUS_OPEN:   index = 0\n        elif status_attr == TRACK_STATUS_CLOSED: index = 1\n        else:                                    index = 0\n        self.trackStatus.setCurrentIndex(index)\n```", "```py\n    def saveAttributes(self, feature):\n        index = self.trackType.currentIndex()\n        if   index == 0: type_attr = TRACK_TYPE_ROAD\n        elif index == 1: type_attr = TRACK_TYPE_WALKING\n        elif index == 2: type_attr = TRACK_TYPE_BIKE\n        elif index == 3: type_attr = TRACK_TYPE_HORSE\n        else:            type_attr = TRACK_TYPE_ROAD\n\n        name_attr = self.trackName.text()\n\n        index = self.trackDirection.currentIndex()\n        if   index == 0: direction_attr = TRACK_DIRECTION_BOTH\n        elif index == 1: direction_attr = TRACK_DIRECTION_FORWARD\n        elif index == 2: direction_attr = TRACK_DIRECTION_BACKWARD\n        else:            direction_attr = TRACK_DIRECTION_BOTH\n\n        index = self.trackStatus.currentIndex()\n        if   index == 0: status_attr = TRACK_STATUS_OPEN\n        elif index == 1: status_attr = TRACK_STATUS_CLOSED\n        else:            status_attr = TRACK_STATUS_OPEN\n\n        feature.setAttribute(\"type\",      type_attr)\n        feature.setAttribute(\"name\",      name_attr)\n        feature.setAttribute(\"direction\", direction_attr)\n        feature.setAttribute(\"status\",    status_attr)\n```", "```py\n    def onGetInfo(self, feature):\n        dialog = TrackInfoDialog(self)\n        dialog.loadAttributes(feature)\n        if dialog.exec_():\n            dialog.saveAttributes(feature)\n            self.trackLayer.updateFeature(feature)\n            self.modified = True\n            self.mapCanvas.refresh()\n```", "```py\nclass SelectVertexTool(QgsMapTool, MapToolMixin):\n    def __init__(self, canvas, trackLayer, onVertexSelected):\n        QgsMapTool.__init__(self, canvas)\n        self.onVertexSelected = onVertexSelected\n        self.setLayer(trackLayer)\n        self.setCursor(Qt.CrossCursor)\n\n    def canvasReleaseEvent(self, event):\n        feature = self.findFeatureAt(event.pos())\n        if feature != None:\n            vertex = self.findVertexAt(feature, event.pos())\n            if vertex != None:\n                self.onVertexSelected(feature, vertex)\n```", "```py\n        self.selectStartPointTool = SelectVertexTool(\n            self.mapCanvas, self.trackLayer,\n            self.onStartPointSelected)\n\n        self.selectEndPointTool = SelectVertexTool(\n            self.mapCanvas, self.trackLayer,\n            self.onEndPointSelected)\n```", "```py\n    def setStartPoint(self):\n        if self.actionSetStartPoint.isChecked():\n            self.mapCanvas.setMapTool(self.selectStartPointTool)\n        else:\n            self.setPanMode()\n\n    def setEndPoint(self):\n        if self.actionSetEndPoint.isChecked():\n            self.mapCanvas.setMapTool(self.selectEndPointTool)\n        else:\n            self.setPanMode()\n```", "```py\n    def onStartPointSelected(self, feature, vertex):\n        self.curStartPt = feature.geometry().vertexAt(vertex)\n```", "```py\n        self.clearMemoryLayer(self.startPointLayer)\n\n        feature = QgsFeature()\n        feature.setGeometry(QgsGeometry.fromPoint(\n                                            self.curStartPt))\n        self.startPointLayer.dataProvider().addFeatures([feature])\n        self.startPointLayer.updateExtents()\n```", "```py\n        self.mapCanvas.refresh()\n        self.setPanMode()\n        self.adjustActions()\n```", "```py\n    def onEndPointSelected(self, feature, vertex):\n        self.curEndPt = feature.geometry().vertexAt(vertex)\n\n        self.clearMemoryLayer(self.endPointLayer)\n\n        feature = QgsFeature()\n        feature.setGeometry(QgsGeometry.fromPoint(self.curEndPt))\n        self.endPointLayer.dataProvider().addFeatures([feature])\n        self.endPointLayer.updateExtents()\n        self.mapCanvas.refresh()\n        self.setPanMode()\n        self.adjustActions()\n```", "```py\n    def clearMemoryLayer(self, layer):\n        featureIDs = []\n        provider = layer.dataProvider()\n        for feature in provider.getFeatures(QgsFeatureRequest()):\n            featureIDs.append(feature.id())\n        provider.deleteFeatures(featureIDs)\n```", "```py\n        self.curStartPt = None\n        self.curEndPt   = None\n```", "```py\n    def findShortestPath(self):\n        if not self.actionFindShortestPath.isChecked():\n            self.clearMemoryLayer(self.shortestPathLayer)\n            self.setPanMode()\n            self.mapCanvas.refresh()\n            return\n```", "```py\n        directionField = self.trackLayer.fieldNameIndex(\n            \"direction\")\n        director = QgsLineVectorLayerDirector(\n                       self.trackLayer, directionField,\n                       TRACK_DIRECTION_FORWARD,\n                       TRACK_DIRECTION_BACKWARD,\n                       TRACK_DIRECTION_BOTH, 3)\n\n        properter = QgsDistanceArcProperter()\n        director.addProperter(properter)\n\n        crs = self.mapCanvas.mapRenderer().destinationCrs()\n        builder = QgsGraphBuilder(crs)\n\n        tiedPoints = director.makeGraph(builder, [self.curStartPt,\n                                                  self.curEndPt])\n        graph = builder.graph()\n\n        startPt = tiedPoints[0]\n        endPt   = tiedPoints[1]\n\n        startVertex = graph.findVertex(startPt)\n        tree = QgsGraphAnalyzer.shortestTree(graph,\n                                             startVertex, 0)\n\n        startVertex = tree.findVertex(startPt)\n        endVertex   = tree.findVertex(endPt)\n\n        if endVertex == -1:\n            QMessageBox.information(self.window,\n                                    \"Not Found\",\n                                    \"No path found.\")\n            return\n\n        points = []\n        while startVertex != endVertex:\n            incomingEdges = tree.vertex(endVertex).inArc()\n            if len(incomingEdges) == 0:\n                break\n            edge = tree.arc(incomingEdges[0])\n            points.insert(0, tree.vertex(edge.inVertex()).point())\n            endVertex = edge.outVertex()\n\n        points.insert(0, startPt)\n```", "```py\ndirector = QgsLineVectorLayerDirector(\n                       self.trackLayer, directionField,\n                       TRACK_DIRECTION_FORWARD,\n                       TRACK_DIRECTION_BACKWARD,\n                       TRACK_DIRECTION_BOTH, 3)\n```", "```py\n        self.clearMemoryLayer(self.shortestPathLayer)\n\n        provider = self.shortestPathLayer.dataProvider()\n        feature = QgsFeature()\n        feature.setGeometry(QgsGeometry.fromPolyline(points))\n        provider.addFeatures([feature])\n        self.shortestPathLayer.updateExtents()\n        self.mapCanvas.refresh()\n```", "```py\nself.actionFindShortestPath.setEnabled(\n     self.curStartPt != None andself.curEndPt != None)\n```", "```py\n        curTool = self.mapCanvas.mapTool()\n\n        self.actionPan.setChecked(curTool == self.panTool)\n        self.actionEdit.setChecked(self.editing)\n        self.actionAddTrack.setChecked(\n                        curTool == self.addTrackTool)\n        self.actionEditTrack.setChecked(\n                        curTool == self.editTrackTool)\n        self.actionDeleteTrack.setChecked(\n                        curTool == self.deleteTrackTool)\n        self.actionGetInfo.setChecked(curTool == self.getInfoTool)\n        self.actionSetStartPoint.setChecked(\n                        curTool == self.selectStartPointTool)\n        self.actionSetEndPoint.setChecked(\n                        curTool == self.selectEndPointTool)\n        self.actionFindShortestPath.setChecked(False)\n```"]