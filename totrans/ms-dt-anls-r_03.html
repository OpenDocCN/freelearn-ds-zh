<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Filtering and Summarizing Data"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Filtering and Summarizing Data</h1></div></div></div><p>After loading data from either flat files or databases (as we have seen in <a class="link" href="ch01.html" title="Chapter 1. Hello, Data!">Chapter 1</a>, <span class="emphasis"><em>Hello, Data!</em></span>), or directly from the web via some APIs (as covered in <a class="link" href="ch02.html" title="Chapter 2. Getting Data from the Web">Chapter 2</a>, <span class="emphasis"><em>Getting Data from the Web</em></span>), we often have to aggregate, transform, or filter the original dataset before the actual data analysis could take place.</p><p>In this chapter, we will focus on how to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Filter rows and columns in data frames</li><li class="listitem" style="list-style-type: disc">Summarize and aggregate data</li><li class="listitem" style="list-style-type: disc">Improve the performance of such tasks with the <code class="literal">dplyr</code> and <code class="literal">data.table</code> packages besides the base R methods</li></ul></div><div class="section" title="Drop needless data"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Drop needless data</h1></div></div></div><p>Although not loading the needless data is the optimal solution (see the <span class="emphasis"><em>Loading a subset of text files</em></span> and <span class="emphasis"><em>Loading data from databases</em></span> sections in <a class="link" href="ch01.html" title="Chapter 1. Hello, Data!">Chapter 1</a>, <span class="emphasis"><em>Hello, Data!</em></span>), we often have to filter the<a class="indexterm" id="id256"/> original dataset inside R. This can be done with the traditional tools and functions from base R, such as <code class="literal">subset</code>, by using <code class="literal">which</code> and the <code class="literal">[</code> or <code class="literal">[[</code> operator (see the following code), or for example with the SQL-like approach of the <code class="literal">sqldf</code> package:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; library(sqldf)</strong></span>
<span class="strong"><strong>&gt; sqldf("SELECT * FROM mtcars WHERE am=1 AND vs=1")</strong></span>
<span class="strong"><strong>   mpg cyl  disp  hp drat    wt  qsec vs am gear carb</strong></span>
<span class="strong"><strong>1 22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1</strong></span>
<span class="strong"><strong>2 32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1</strong></span>
<span class="strong"><strong>3 30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2</strong></span>
<span class="strong"><strong>4 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1</strong></span>
<span class="strong"><strong>5 27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1</strong></span>
<span class="strong"><strong>6 30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2</strong></span>
<span class="strong"><strong>7 21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2</strong></span>
</pre></div><p>I am sure that all readers who have a decent SQL background and are just getting in touch with R appreciate this alternative way of filtering data, but I personally prefer the following rather similar, native, and much more concise R version:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; subset(mtcars, am == 1 &amp; vs == 1)</strong></span>
<span class="strong"><strong>                mpg cyl  disp  hp drat    wt  qsec vs am gear carb</strong></span>
<span class="strong"><strong>Datsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1</strong></span>
<span class="strong"><strong>Fiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1</strong></span>
<span class="strong"><strong>Honda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2</strong></span>
<span class="strong"><strong>Toyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1</strong></span>
<span class="strong"><strong>Fiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1</strong></span>
<span class="strong"><strong>Lotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2</strong></span>
<span class="strong"><strong>Volvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2</strong></span>
</pre></div><p>Please note the slight difference in the results. This is attributed to the fact that the <code class="literal">row.names</code> argument of <code class="literal">sqldf</code> is <code class="literal">FALSE</code> by default, which can of course be overridden to get the exact same results:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; identical(</strong></span>
<span class="strong"><strong>+     sqldf("SELECT * FROM mtcars WHERE am=1 AND vs=1",</strong></span>
<span class="strong"><strong>+       row.names = TRUE),</strong></span>
<span class="strong"><strong>+     subset(mtcars, am == 1 &amp; vs == 1)</strong></span>
<span class="strong"><strong>+     )</strong></span>
<span class="strong"><strong>[1] TRUE</strong></span>
</pre></div><p>These examples<a class="indexterm" id="id257"/> focused on how to drop rows from <code class="literal">data.frame</code>, but what if we also want to remove some columns?</p><p>The SQL approach is really straightforward; just specify the required columns instead of <code class="literal">*</code> in the <code class="literal">SELECT</code> statement. On the other hand, <code class="literal">subset</code> also supports this approach by the <code class="literal">select</code> argument, which can take vectors or an R expression describing, for example, a range of columns:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; subset(mtcars, am == 1 &amp; vs == 1, select = hp:wt)</strong></span>
<span class="strong"><strong>                hp drat    wt</strong></span>
<span class="strong"><strong>Datsun 710      93 3.85 2.320</strong></span>
<span class="strong"><strong>Fiat 128        66 4.08 2.200</strong></span>
<span class="strong"><strong>Honda Civic     52 4.93 1.615</strong></span>
<span class="strong"><strong>Toyota Corolla  65 4.22 1.835</strong></span>
<span class="strong"><strong>Fiat X1-9       66 4.08 1.935</strong></span>
<span class="strong"><strong>Lotus Europa   113 3.77 1.513</strong></span>
<span class="strong"><strong>Volvo 142E     109 4.11 2.780</strong></span>
</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip06"/>Tip</h3><p>Pass the unquoted column names as a<a class="indexterm" id="id258"/> vector via the <code class="literal">c</code> function to select an arbitrary list of columns in the given order, or exclude the specified columns by using the - operator, for example, <code class="literal">subset(mtcars, select = -c(hp, wt))</code>.</p></div></div><p>Let's take this to the <a class="indexterm" id="id259"/>next step, and see how we can apply the forementioned filters on some larger datasets, when we face some performance issues with the <code class="literal">base</code> functions.</p><div class="section" title="Drop needless data in an efficient way"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec25"/>Drop needless data in an efficient way</h2></div></div></div><p>R works best with datasets that can fit in the <a class="indexterm" id="id260"/>actual physical memory, and some R packages provide extremely fast access to this amount of data.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note29"/>Note</h3><p>Some benchmarks (see the <span class="emphasis"><em>References</em></span> section at the end of the book) provide real-life examples of more efficient summarizing R functions than what the current open source (for example, MySQL, PostgreSQL, and Impala) and commercial databases (such as HP Vertica) provide.</p></div></div><p>Some of the related packages were already mentioned in <a class="link" href="ch01.html" title="Chapter 1. Hello, Data!">Chapter 1</a>, <span class="emphasis"><em>Hello, Data!</em></span>, where we benchmarked reading a relatively large amount of data from the <code class="literal">hflights</code> package into R.</p><p>Let's see how the preceding examples perform on this dataset of a quarter of a million rows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; library(hflights)</strong></span>
<span class="strong"><strong>&gt; system.time(sqldf("SELECT * FROM hflights WHERE Dest == 'BNA'", </strong></span>
<span class="strong"><strong>+   row.names = TRUE))</strong></span>
<span class="strong"><strong>   user  system elapsed </strong></span>
<span class="strong"><strong>  1.487   0.000   1.493 </strong></span>
<span class="strong"><strong>&gt; system.time(subset(hflights, Dest == 'BNA'))</strong></span>
<span class="strong"><strong>   user  system elapsed </strong></span>
<span class="strong"><strong>  0.132   0.000   0.131</strong></span>
</pre></div><p>The <code class="literal">base::subset</code> function seems to <a class="indexterm" id="id261"/>perform pretty well, but can we make it any faster? Well, the second generation of the <a class="indexterm" id="id262"/>
<code class="literal">plyr</code> package, called <code class="literal">dplyr</code> (the relevant details are discussed <span class="emphasis"><em>High-performance helper functions</em></span> section in this chapter and <a class="link" href="ch04.html" title="Chapter 4. Restructuring Data">Chapter 4</a>, <span class="emphasis"><em>Restructuring Data</em></span>), provides extremely fast C++ implementations of the most common database manipulation methods in a rather intuitive way:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; library(dplyr)</strong></span>
<span class="strong"><strong>&gt; system.time(filter(hflights, Dest == 'BNA'))</strong></span>
<span class="strong"><strong>   user  system elapsed </strong></span>
<span class="strong"><strong>  0.021   0.000   0.022</strong></span>
</pre></div><p>Further, we can extend this solution by dropping some columns from the dataset just like we did with <code class="literal">subset</code> before, although now, we call the <code class="literal">select</code> function instead of passing an argument with the same name:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; str(select(filter(hflights, Dest == 'BNA'), DepTime:ArrTime))</strong></span>
<span class="strong"><strong>'data.frame':  3481 obs. of  2 variables:</strong></span>
<span class="strong"><strong> $ DepTime: int  1419 1232 1813 900 716 1357 2000 1142 811 1341 ...</strong></span>
<span class="strong"><strong> $ ArrTime: int  1553 1402 1948 1032 845 1529 2132 1317 945 1519 ...</strong></span>
</pre></div><p>Therefore, it's like calling the <code class="literal">filter</code> function instead of <code class="literal">subset</code>, and we get the results faster than the blink of an eye! The <code class="literal">dplyr</code> package can<a class="indexterm" id="id263"/> work with traditional <code class="literal">data.frame</code> or <code class="literal">data.table</code> objects, or can interact directly with the most widely used database engines. Please note that row names are not preserved in <code class="literal">dplyr</code>, so if you require them, it's worth copying the names to explicit variables before passing them to <code class="literal">dplyr</code> or directly to <code class="literal">data.table</code> as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; mtcars$rownames &lt;- rownames(mtcars)</strong></span>
<span class="strong"><strong>&gt; select(filter(mtcars, hp &gt; 300), c(rownames, hp))</strong></span>
<span class="strong"><strong>       rownames  hp</strong></span>
<span class="strong"><strong>1 Maserati Bora 335</strong></span>
</pre></div></div><div class="section" title="Drop needless data in another efficient way"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec26"/>Drop needless data in another efficient way</h2></div></div></div><p>Let's see a quick example <a class="indexterm" id="id264"/>of the <code class="literal">data.table</code> solution on its own, without <code class="literal">dplyr</code>.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note30"/>Note</h3><p>The <code class="literal">data.table</code> package provides an extremely efficient way to handle larger datasets in a column-based, auto-indexed in-memory data structure, with backward compatibility for the traditional <a class="indexterm" id="id265"/>
<code class="literal">data.frame</code> methods.</p></div></div><p>After loading the package, we have to transform the <code class="literal">hflights</code> traditional <code class="literal">data.frame</code> to <code class="literal">data.table</code>. Then, we create a new column, called <code class="literal">rownames</code>, to which we assign the <code class="literal">rownames</code> of the original dataset with the help of the := assignment operator specific to <code class="literal">data.table</code>:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; library(data.table)</strong></span>
<span class="strong"><strong>&gt; hflights_dt &lt;- data.table(hflights)</strong></span>
<span class="strong"><strong>&gt; hflights_dt[, rownames := rownames(hflights)]</strong></span>
<span class="strong"><strong>&gt; system.time(hflights_dt[Dest == 'BNA'])</strong></span>
<span class="strong"><strong>   user  system elapsed </strong></span>
<span class="strong"><strong>  0.021   0.000   0.020</strong></span>
</pre></div><p>Well, it takes some time to get used to the custom <code class="literal">data.table</code> syntax and it might even seem a bit strange to the traditional R user at first sight, but it's definitely worth mastering in the long run. You get great performance, and the syntax turns out to be natural and flexible after the relatively steep learning curve of the first few examples.</p><p>As a matter of fact, the <code class="literal">data.table</code> syntax is pretty similar to SQL:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>DT[i, j, ... , drop = TRUE]</strong></span>
</pre></div><p>This could be described with SQL commands as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>DT[where, select | update, group by][having][order by][ ]...[ ]</strong></span>
</pre></div><p>Therefore, <code class="literal">[.data.table</code> (which stands for the <code class="literal">[</code> operator applied to a <code class="literal">data.table</code> object) has some different arguments as compared to the traditional <code class="literal">[.data.frame</code> syntax, as you have already seen in the preceding example.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note31"/>Note</h3><p>Now, we are not dealing with the assignment operator in detail, as this example might be too complex for such an introductory part of the book, and we are probably getting out of our comfort zone. Therefore, please find more details in <a class="link" href="ch04.html" title="Chapter 4. Restructuring Data">Chapter 4</a>, <span class="emphasis"><em>Restructuring Data</em></span>, or head to <code class="literal">?data.table</code> for a rather technical overview.</p></div></div><p>It seems that the<a class="indexterm" id="id266"/> first argument (<code class="literal">i</code>) of the <code class="literal">[.data.table</code> operator stands for filtering, or in other words, for the <code class="literal">WHERE</code> statement in SQL parlance, while <code class="literal">[.data.frame</code> expects indices specifying which rows to keep from the original dataset. The real difference between the two arguments is that the former can take any R expression, while the latter traditional method expects mainly integers or logical values.</p><p>Anyway, filtering is as easy as passing an R expression to the <code class="literal">i</code> argument of the <code class="literal">[</code> operator specific to <code class="literal">data.table</code>. Further, let's see how we can select the columns in the <code class="literal">data.table</code> syntax, which should be done in the second argument (<code class="literal">j</code>) of the call on the basis of the abovementioned general <code class="literal">data.table</code> syntax:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; str(hflights_dt[Dest == 'BNA', list(DepTime, ArrTime)]) </strong></span>
<span class="strong"><strong>Classes 'data.table' and 'data.frame':     3481 obs. of 2 variables:</strong></span>
<span class="strong"><strong> $ DepTime: int  1419 1232 1813 900 716 1357 2000 1142 811 1341 ...</strong></span>
<span class="strong"><strong> $ ArrTime: int  1553 1402 1948 1032 845 1529 2132 1317 945 1519 ...</strong></span>
<span class="strong"><strong> - attr(*, ".internal.selfref")=&lt;externalptr&gt;</strong></span>
</pre></div><p>Okay, so we now have the two expected columns with the 3,481 observations. Note that <code class="literal">list</code> was used to define the required columns to keep, although the use of <code class="literal">c</code> (a function from base R to concatenate vector elements) is more traditionally used with <code class="literal">[.data.frame</code>. The latter is also possible with <code class="literal">[.data.table</code>, but then, you have to pass the variable names as a character vector and set <code class="literal">with</code> to <code class="literal">FALSE</code>:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; hflights_dt[Dest == 'BNA', c('DepTime', 'ArrTime'), with = FALSE] </strong></span>
</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note32"/>Note</h3><p>Instead of <code class="literal">list</code>, you can use a dot as the function name in the style of the <code class="literal">plyr</code> package; for example: <code class="literal">hflights_dt[, .(DepTime, ArrTime)]</code>.</p></div></div><p>Now that we are more<a class="indexterm" id="id267"/> or less familiar with our options for filtering data inside a live R session, and we know the overall syntax of the <code class="literal">dplyr</code> and <code class="literal">data.table</code> packages, let's see how these can be used to aggregate and summarize data in action.</p></div></div></div>
<div class="section" title="Aggregation"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Aggregation</h1></div></div></div><p>The most straightforward way of summarizing<a class="indexterm" id="id268"/> data is calling the <code class="literal">aggregate</code> function from the <code class="literal">stats</code> package, which does exactly what we are looking for: splitting the data into subsets by a grouping variable, then computing summary statistics for them separately. The most basic way to call the <code class="literal">aggregate</code> function is to pass the<a class="indexterm" id="id269"/> numeric vector to be aggregated, and a factor variable to define the splits for the function passed in the <code class="literal">FUN</code> argument to be applied. Now, let's see the average ratio of diverted flights on each weekday:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; aggregate(hflights$Diverted, by = list(hflights$DayOfWeek),</strong></span>
<span class="strong"><strong>+   FUN = mean)</strong></span>
<span class="strong"><strong>  Group.1           x</strong></span>
<span class="strong"><strong>1       1 0.002997672</strong></span>
<span class="strong"><strong>2       2 0.002559323</strong></span>
<span class="strong"><strong>3       3 0.003226211</strong></span>
<span class="strong"><strong>4       4 0.003065727</strong></span>
<span class="strong"><strong>5       5 0.002687865</strong></span>
<span class="strong"><strong>6       6 0.002823121</strong></span>
<span class="strong"><strong>7       7 0.002589057</strong></span>
</pre></div><p>Well, it took some time to run the preceding script, but please bear in mind that we have just aggregated around a quarter of a million rows to see the daily averages for the number of diverted flights departing from the Houston airport in 2011.</p><p>In other words, which also makes sense for all those not into statistics, the percentage of diverted flights per weekday. The results are rather interesting, as it seems that flights are more often diverted in the middle of the week (around 0.3 percent) than over the weekends (around 0.05 percent less), at least from Houston.</p><p>An alternative way of calling the preceding function is to supply the arguments inside of the <code class="literal">with</code> function, which seems to be a more human-friendly expression after all because it saves us from the repeated mention of the <code class="literal">hflights</code> database:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; with(hflights, aggregate(Diverted, by = list(DayOfWeek),</strong></span>
<span class="strong"><strong>+   FUN = mean))</strong></span>
</pre></div><p>The results are not shown here, as they are exactly the same as those shown earlier. The manual for the <code class="literal">aggregate</code> function (see <code class="literal">?aggregate</code>) states that it returns the results in a convenient form. Well, checking the column names of the abovementioned returned data does not seem convenient, right? We can overcome this issue by using the formula notation instead <a class="indexterm" id="id270"/>of defining the numeric and factor variables separately:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; aggregate(Diverted ~ DayOfWeek, data = hflights, FUN = mean)</strong></span>
<span class="strong"><strong>  DayOfWeek    Diverted</strong></span>
<span class="strong"><strong>1         1 0.002997672</strong></span>
<span class="strong"><strong>2         2 0.002559323</strong></span>
<span class="strong"><strong>3         3 0.003226211</strong></span>
<span class="strong"><strong>4         4 0.003065727</strong></span>
<span class="strong"><strong>5         5 0.002687865</strong></span>
<span class="strong"><strong>6         6 0.002823121</strong></span>
<span class="strong"><strong>7         7 0.002589057</strong></span>
</pre></div><p>The gain by using the formula notation is at least two-fold:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">There are relatively few characters to type</li><li class="listitem" style="list-style-type: disc">The headers and row names are correct in the results</li><li class="listitem" style="list-style-type: disc">This version also runs a bit faster than the previous <code class="literal">aggregate</code> calls; please see the all-out benchmark at the end of this section</li></ul></div><p>The only downside of using the formula notation is that you have to learn it, which might seem a bit awkward at first, but as formulas are highly used in a bunch of R functions and packages, particularly for defining models, it's definitely worth learning how to use them in the long run.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note33"/>Note</h3><p>The formula notation is inherited from the S language with the following general syntax: <code class="literal">response_variable ~ predictor_variable_1 + … + predictor_variable_n</code>. The notation also includes some other symbols, such as <code class="literal">-</code> for excluding variables and <code class="literal">:</code> or <code class="literal">*</code> to include the interaction between the variables with or without themselves. See <a class="link" href="ch05.html" title="Chapter 5. Building Models (authored by Renata Nemeth and Gergely Toth)">Chapter 5</a>, <span class="emphasis"><em>Building Models (authored by Renata Nemeth and Gergely Toth)</em></span>, and <code class="literal">?formula</code> in the R console for more details.</p></div></div><div class="section" title="Quicker aggregation with base R commands"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec27"/>Quicker aggregation with base R commands</h2></div></div></div><p>An alternative solution to<a class="indexterm" id="id271"/> aggregate data might be to call the <code class="literal">tapply</code> or <code class="literal">by</code> function, which can apply an R function over a <span class="emphasis"><em>ragged</em></span> array. The latter means that we<a class="indexterm" id="id272"/> can provide one or more <code class="literal">INDEX</code> variables, which will be coerced to factor, and then, run the provided R function separately on all cells in each subset. The following is a quick example:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; tapply(hflights$Diverted, hflights$DayOfWeek, mean)</strong></span>
<span class="strong"><strong>       1        2        3        4        5        6        7 </strong></span>
<span class="strong"><strong>0.002998 0.002559 0.003226 0.003066 0.002688 0.002823 0.002589 </strong></span>
</pre></div><p>Please note that <code class="literal">tapply</code> returns an <code class="literal">array</code> object instead of convenient data frames; on the other hand, it runs <a class="indexterm" id="id273"/>a lot quicker than the abovementioned aggregate calls. Thus, it might be reasonable to use <code class="literal">tapply</code> for the computations and<a class="indexterm" id="id274"/> then, convert the results to <code class="literal">data.frame</code> with the appropriate column names.</p></div><div class="section" title="Convenient helper functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec28"/>Convenient helper functions</h2></div></div></div><p>Such conversions can be done easily and in a very user-friendly way by, for example, using the <code class="literal">plyr</code> package, a general version of the <code class="literal">dplyr</code> package, which stands for <span class="emphasis"><em>plyr specialized f</em></span>
<span class="emphasis"><em>or data frames</em></span>.</p><p>The <code class="literal">plyr</code> package provides a <a class="indexterm" id="id275"/>variety of functions to apply data<a class="indexterm" id="id276"/> from <code class="literal">data.frame</code>, <code class="literal">list</code>, or <code class="literal">array</code> objects, and can return the results in any of the mentioned formats. The naming scheme of these functions is easy to remember: the first character of the function name stands for the class of the input data, and the second character represents the<a class="indexterm" id="id277"/> output format, all followed by <span class="emphasis"><em>ply</em></span> in all cases. Besides the three abovementioned R classes, there are some special options coded by the characters:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">d</code> stands for <code class="literal">data.frame</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">s</code> stands for <code class="literal">array</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">l</code> stands for <code class="literal">list</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">m</code> is a special input type, which means that we provide multiple arguments in a tabular format for the function</li><li class="listitem" style="list-style-type: disc"><code class="literal">r</code> input type expects an integer, which specifies the number of times the function will be replicated</li><li class="listitem" style="list-style-type: disc"><code class="literal">_</code> is a special output type that does not return anything for the function</li></ul></div><p>Thus, the following most frequently used combinations are available:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ddply</code> takes <code class="literal">data.frame</code> as input and returns <code class="literal">data.frame</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ldply</code> takes <code class="literal">list</code> as input but returns <code class="literal">data.frame</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">l_ply</code> does not return anything, but it's really useful for example, to iterate through a number of elements instead of a <code class="literal">for</code> loop; as with a set <code class="literal">.progress</code> argument, the function can show the current state of iterations, the remaining time</li></ul></div><p>Please find more details, examples, and use cases of <code class="literal">plyr</code> in <a class="link" href="ch04.html" title="Chapter 4. Restructuring Data">Chapter 4</a>, <span class="emphasis"><em>Restructuring Data</em></span>. Here, we will only concentrate on how to summarize data. To this end, we will use <code class="literal">ddply</code> (not to be confused with the <code class="literal">dplyr</code> package) in all the following examples: taking <code class="literal">data.frame</code> as the input argument and returning data with the same class.</p><p>So, let's load the package and apply the <code class="literal">mean</code> function on the <code class="literal">Diverted</code> column over each subset by <code class="literal">DayOfWeek</code>:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; library(plyr)</strong></span>
<span class="strong"><strong>&gt; ddply(hflights, .(DayOfWeek), function(x) mean(x$Diverted))</strong></span>
<span class="strong"><strong>  DayOfWeek          V1</strong></span>
<span class="strong"><strong>1         1 0.002997672</strong></span>
<span class="strong"><strong>2         2 0.002559323</strong></span>
<span class="strong"><strong>3         3 0.003226211</strong></span>
<span class="strong"><strong>4         4 0.003065727</strong></span>
<span class="strong"><strong>5         5 0.002687865</strong></span>
<span class="strong"><strong>6         6 0.002823121</strong></span>
<span class="strong"><strong>7         7 0.002589057</strong></span>
</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note34"/>Note</h3><p>The <code class="literal">.</code> function of the <code class="literal">plyr</code> package<a class="indexterm" id="id278"/> provides us with a convenient way of referring to a variable (name) as is; otherwise, the content of the <code class="literal">DayOfWeek</code> columns would be interpreted by <code class="literal">ddply</code>, resulting in an error.</p></div></div><p>An important thing to<a class="indexterm" id="id279"/> note here is that <code class="literal">ddply</code> is much quicker than our first attempt with the <code class="literal">aggregate</code> function. On the other hand, I am not yet pleased with<a class="indexterm" id="id280"/> the results, <code class="literal">V1</code> and such creative column names have always freaked me out. Instead of updating the names of the <code class="literal">data.frame</code> post processing let's call the <code class="literal">summarise</code> helper function instead of the previously applied anonymous one; here, we can also provide the desired name for our newly computed column:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; ddply(hflights, .(DayOfWeek), summarise, Diverted = mean(Diverted))</strong></span>
<span class="strong"><strong>  DayOfWeek    Diverted</strong></span>
<span class="strong"><strong>1         1 0.002997672</strong></span>
<span class="strong"><strong>2         2 0.002559323</strong></span>
<span class="strong"><strong>3         3 0.003226211</strong></span>
<span class="strong"><strong>4         4 0.003065727</strong></span>
<span class="strong"><strong>5         5 0.002687865</strong></span>
<span class="strong"><strong>6         6 0.002823121</strong></span>
<span class="strong"><strong>7         7 0.002589057</strong></span>
</pre></div><p>Okay, much better. But, can we do even better?</p></div><div class="section" title="High-performance helper functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec29"/>High-performance helper functions</h2></div></div></div><p>Hadley Wickham, the author of <code class="literal">ggplot</code>, <code class="literal">reshape</code>, and several other R packages, started working on the <a class="indexterm" id="id281"/>second generation, or rather a specialized version, of <code class="literal">plyr</code> in 2008. The basic concept was that <code class="literal">plyr</code> is most frequently used to transform one <code class="literal">data.frame</code> to another <code class="literal">data.frame</code>; therefore, its operation requires <a class="indexterm" id="id282"/>extra attention. The <code class="literal">dplyr</code> package, <code class="literal">plyr</code> specialized for data frames, provides a faster implementation of the <a class="indexterm" id="id283"/>
<code class="literal">plyr</code> functions, written in raw C++, and <code class="literal">dplyr</code> can also deal with remote databases.</p><p>However, the performance improvements<a class="indexterm" id="id284"/> also go hand-in-hand with some other changes; for example, the syntax of <code class="literal">dplyr</code> has changed a lot as compared to <code class="literal">plyr</code>. Although the previously mentioned <code class="literal">summarise</code> function does exist in <code class="literal">dplyr</code>, we do not have the <code class="literal">ddplyr</code> function any more, as all functions in the package are dedicated to act as some component of <code class="literal">plyr::ddplyr</code>.</p><p>Anyway, to keep the<a class="indexterm" id="id285"/> theoretical background short, if we want to summarize the subgroups of a dataset, we have to define the groups before aggregation:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; hflights_DayOfWeek &lt;- group_by(hflights, DayOfWeek)</strong></span>
</pre></div><p>The resulting object is the very same <code class="literal">data.frame</code> that we had previously with one exception: a bunch of metadata was merged to the object by the means of attributes. To keep the following output short, we do not list the whole structure (<code class="literal">str</code>) of the object, but only the attributes are shown:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; str(attributes(hflights_DayOfWeek))</strong></span>
<span class="strong"><strong>List of 9</strong></span>
<span class="strong"><strong> $ names             : chr [1:21] "Year" "Month" "DayofMonth" ...</strong></span>
<span class="strong"><strong> $ class             : chr [1:4] "grouped_df" "tbl_df" "tbl" ...</strong></span>
<span class="strong"><strong> $ row.names         : int [1:227496] 5424 5425 5426 5427 5428 ...</strong></span>
<span class="strong"><strong> $ vars              :List of 1</strong></span>
<span class="strong"><strong>  ..$ : symbol DayOfWeek</strong></span>
<span class="strong"><strong> $ drop              : logi TRUE</strong></span>
<span class="strong"><strong> $ indices           :List of 7</strong></span>
<span class="strong"><strong>  ..$ : int [1:34360] 2 9 16 23 30 33 40 47 54 61 ...</strong></span>
<span class="strong"><strong>  ..$ : int [1:31649] 3 10 17 24 34 41 48 55 64 70 ...</strong></span>
<span class="strong"><strong>  ..$ : int [1:31926] 4 11 18 25 35 42 49 56 65 71 ...</strong></span>
<span class="strong"><strong>  ..$ : int [1:34902] 5 12 19 26 36 43 50 57 66 72 ...</strong></span>
<span class="strong"><strong>  ..$ : int [1:34972] 6 13 20 27 37 44 51 58 67 73 ...</strong></span>
<span class="strong"><strong>  ..$ : int [1:27629] 0 7 14 21 28 31 38 45 52 59 ...</strong></span>
<span class="strong"><strong>  ..$ : int [1:32058] 1 8 15 22 29 32 39 46 53 60 ...</strong></span>
<span class="strong"><strong> $ group_sizes       : int [1:7] 34360 31649 31926 34902 34972 ...</strong></span>
<span class="strong"><strong> $ biggest_group_size: int 34972</strong></span>
<span class="strong"><strong> $ labels            :'data.frame':  7 obs. of  1 variable:</strong></span>
<span class="strong"><strong>  ..$ DayOfWeek: int [1:7] 1 2 3 4 5 6 7</strong></span>
<span class="strong"><strong>  ..- attr(*, "vars")=List of 1</strong></span>
<span class="strong"><strong>  .. ..$ : symbol DayOfWeek</strong></span>
</pre></div><p>From this metadata, the <code class="literal">indices</code> attribute is important. It simply lists the IDs of each row for one of the weekdays, so later operations can easily select the subgroups from the whole dataset. So, let's see how the proportion of diverted flights looks like with some performance boost due to<a class="indexterm" id="id286"/> using <code class="literal">summarise</code> from <code class="literal">dplyr</code> instead of <code class="literal">plyr</code>:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; dplyr::summarise(hflights_DayOfWeek, mean(Diverted))</strong></span>
<span class="strong"><strong>Source: local data frame [7 x 2]</strong></span>

<span class="strong"><strong>  DayOfWeek mean(Diverted)</strong></span>
<span class="strong"><strong>1         1    0.002997672</strong></span>
<span class="strong"><strong>2         2    0.002559323</strong></span>
<span class="strong"><strong>3         3    0.003226211</strong></span>
<span class="strong"><strong>4         4    0.003065727</strong></span>
<span class="strong"><strong>5         5    0.002687865</strong></span>
<span class="strong"><strong>6         6    0.002823121</strong></span>
<span class="strong"><strong>7         7    0.002589057 </strong></span>
</pre></div><p>The results are <a class="indexterm" id="id287"/>pretty familiar, which is good. However, while running this example, did you measure the execution time? This was close to an instant, which makes <code class="literal">dplyr</code> even better.</p></div><div class="section" title="Aggregate with data.table"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec30"/>Aggregate with data.table</h2></div></div></div><p>Do you remember the second argument of <code class="literal">[.data.table</code>? It's called <code class="literal">j</code>, which stands for a <code class="literal">SELECT</code> or an <code class="literal">UPDATE</code> SQL statement, and the most important feature is that it can be any R expression. Thus, we can simply <a class="indexterm" id="id288"/>pass a function there and set groups with the help of the <code class="literal">by</code> argument:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; hflights_dt[, mean(Diverted), by = DayOfWeek]</strong></span>
<span class="strong"><strong>   DayOfWeek          V1</strong></span>
<span class="strong"><strong>1:         6 0.002823121</strong></span>
<span class="strong"><strong>2:         7 0.002589057</strong></span>
<span class="strong"><strong>3:         1 0.002997672</strong></span>
<span class="strong"><strong>4:         2 0.002559323</strong></span>
<span class="strong"><strong>5:         3 0.003226211</strong></span>
<span class="strong"><strong>6:         4 0.003065727</strong></span>
<span class="strong"><strong>7:         5 0.002687865</strong></span>
</pre></div><p>I am pretty sure that you are not in the least surprised by how fast the results were returned by <code class="literal">data.table</code>, as people can get used to great tools very quickly. Further, it was very concise as compared to the previous two-line <code class="literal">dplyr</code> call, right? The only downside of this solution is that the weekdays are ordered by some hardly intelligible rank. Please see <a class="link" href="ch04.html" title="Chapter 4. Restructuring Data">Chapter 4</a>, <span class="emphasis"><em>Restructuring Data</em></span>, for more details on this; for now, let's fix the issue quickly by setting a key, which means that we order <code class="literal">data.table</code> first by <code class="literal">DayOfWeek</code>:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; setkey(hflights_dt, 'DayOfWeek')</strong></span>
<span class="strong"><strong>&gt; hflights_dt[, mean(Diverted), by = DayOfWeek]</strong></span>
<span class="strong"><strong>   DayOfWeek          V1</strong></span>
<span class="strong"><strong>1:         1 0.002997672</strong></span>
<span class="strong"><strong>2:         2 0.002559323</strong></span>
<span class="strong"><strong>3:         3 0.003226211</strong></span>
<span class="strong"><strong>4:         4 0.003065727</strong></span>
<span class="strong"><strong>5:         5 0.002687865</strong></span>
<span class="strong"><strong>6:         6 0.002823121</strong></span>
<span class="strong"><strong>7:         7 0.002589057</strong></span>
</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note35"/>Note</h3><p>To specify a name for the second column in the resulting tabular object instead of <code class="literal">V1</code>, you can specify the <code class="literal">summary</code> object as a named list, for example, as <code class="literal">hflights_dt[, list('mean(Diverted)' = mean(Diverted)), by = DayOfWeek]</code>, where you can use <code class="literal">.</code> (dot) instead of <code class="literal">list</code>, just like in <code class="literal">ply</code>
<code class="literal">r</code>.</p></div></div><p>Besides getting the<a class="indexterm" id="id289"/> results in the expected order, summarizing data by an already existing key also runs relatively fast. Let's verify this with some empirical evidence on your machine!</p></div></div>
<div class="section" title="Running benchmarks"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Running benchmarks</h1></div></div></div><p>As already discussed in the previous chapters, with<a class="indexterm" id="id290"/> the help of the <code class="literal">microbenchmark</code> package, we can run any number of different functions for a specified number of times on the same machine to get some reproducible results on the performance.</p><p>To this end, we<a class="indexterm" id="id291"/> have to define the functions that we want to benchmark first. These were compiled from the preceding examples:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; AGGR1     &lt;- function() aggregate(hflights$Diverted,</strong></span>
<span class="strong"><strong>+   by = list(hflights$DayOfWeek), FUN = mean)</strong></span>
<span class="strong"><strong>&gt; AGGR2     &lt;- function() with(hflights, aggregate(Diverted,</strong></span>
<span class="strong"><strong>+   by = list(DayOfWeek), FUN = mean))</strong></span>
<span class="strong"><strong>&gt; AGGR3     &lt;- function() aggregate(Diverted ~ DayOfWeek,</strong></span>
<span class="strong"><strong>+   data = hflights, FUN = mean)</strong></span>
<span class="strong"><strong>&gt; TAPPLY    &lt;- function() tapply(X = hflights$Diverted, </strong></span>
<span class="strong"><strong>+   INDEX = hflights$DayOfWeek, FUN = mean)</strong></span>
<span class="strong"><strong>&gt; PLYR1     &lt;- function() ddply(hflights, .(DayOfWeek),</strong></span>
<span class="strong"><strong>+   function(x) mean(x$Diverted))</strong></span>
<span class="strong"><strong>&gt; PLYR2     &lt;- function() ddply(hflights, .(DayOfWeek), summarise,</strong></span>
<span class="strong"><strong>+   Diverted = mean(Diverted))</strong></span>
<span class="strong"><strong>&gt; DPLYR     &lt;- function() dplyr::summarise(hflights_DayOfWeek,</strong></span>
<span class="strong"><strong>+   mean(Diverted))</strong></span>
</pre></div><p>However, as mentioned before, the <code class="literal">summarise</code> function in <code class="literal">dplyr</code> needs some prior data restructuring, which also takes time. To this end, let's define another function that also includes the creation of the new data structure along with the real aggregation:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; DPLYR_ALL &lt;- function() {</strong></span>
<span class="strong"><strong>+     hflights_DayOfWeek &lt;- group_by(hflights, DayOfWeek)</strong></span>
<span class="strong"><strong>+     dplyr::summarise(hflights_DayOfWeek, mean(Diverted))</strong></span>
<span class="strong"><strong>+ }</strong></span>
</pre></div><p>Similarly, benchmarking <code class="literal">data.table</code> also requires some additional variables for the test environment; as <code class="literal">hlfights_dt</code> is already sorted by <code class="literal">DayOfWeek</code>, let's create a new <code class="literal">data.table</code> object for benchmarking:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; hflights_dt_nokey &lt;- data.table(hflights)</strong></span>
</pre></div><p>Further, it probably makes sense to verify that it has no keys:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; key(hflights_dt_nokey)</strong></span>
<span class="strong"><strong>NULL</strong></span>
</pre></div><p>Okay, now, we can <a class="indexterm" id="id292"/>define the <code class="literal">data.table</code> test cases along with a function that also includes the transformation to <code class="literal">data.table</code>, and adding an index just to be fair with <code class="literal">dplyr</code>:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; DT     &lt;- function() hflights_dt_nokey[, mean(FlightNum),</strong></span>
<span class="strong"><strong>+   by = DayOfWeek]</strong></span>
<span class="strong"><strong>&gt; DT_KEY &lt;- function() hflights_dt[, mean(FlightNum),</strong></span>
<span class="strong"><strong>+   by = DayOfWeek]</strong></span>
<span class="strong"><strong>&gt; DT_ALL &lt;- function() {</strong></span>
<span class="strong"><strong>+     setkey(hflights_dt_nokey, 'DayOfWeek')</strong></span>
<span class="strong"><strong>+     hflights_dt[, mean(FlightNum), by = DayOfWeek]</strong></span>
<span class="strong"><strong>+     setkey(hflights_dt_nokey, NULL)</strong></span>
<span class="strong"><strong>+ }</strong></span>
</pre></div><p>Now that we have all the described implementations ready for testing, let's load the <code class="literal">microbenchmark</code> <a class="indexterm" id="id293"/>package to do its job:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; library(microbenchmark)</strong></span>
<span class="strong"><strong>&gt; res &lt;- microbenchmark(AGGR1(), AGGR2(), AGGR3(), TAPPLY(), PLYR1(),</strong></span>
<span class="strong"><strong>+          PLYR2(), DPLYR(), DPLYR_ALL(), DT(), DT_KEY(), DT_ALL())</strong></span>
<span class="strong"><strong>&gt; print(res, digits = 3)</strong></span>
<span class="strong"><strong>Unit: milliseconds</strong></span>
<span class="strong"><strong>        expr     min      lq  median      uq     max neval</strong></span>
<span class="strong"><strong>     AGGR1() 2279.82 2348.14 2462.02 2597.70 2719.88    10</strong></span>
<span class="strong"><strong>     AGGR2() 2278.15 2465.09 2528.55 2796.35 2996.98    10</strong></span>
<span class="strong"><strong>     AGGR3() 2358.71 2528.23 2726.66 2879.89 3177.63    10</strong></span>
<span class="strong"><strong>    TAPPLY()   19.90   21.05   23.56   29.65   33.88    10</strong></span>
<span class="strong"><strong>     PLYR1()   56.93   59.16   70.73   82.41  155.88    10</strong></span>
<span class="strong"><strong>     PLYR2()   58.31   65.71   76.51   98.92  103.48    10</strong></span>
<span class="strong"><strong>     DPLYR()    1.18    1.21    1.30    1.74    1.84    10</strong></span>
<span class="strong"><strong> DPLYR_ALL()    7.40    7.65    7.93    8.25   14.51    10</strong></span>
<span class="strong"><strong>        DT()    5.45    5.73    5.99    7.75    9.00    10</strong></span>
<span class="strong"><strong>    DT_KEY()    5.22    5.45    5.63    6.26   13.64    10</strong></span>
<span class="strong"><strong>    DT_ALL()   31.31   33.26   35.19   38.34   42.83    10</strong></span>
</pre></div><p>The results are pretty<a class="indexterm" id="id294"/> spectacular: from more than 2,000 milliseconds, we could improve our tools to provide the very same results in only a bit more than 1 millisecond. The spread can be demonstrated easily on a violin plot with a logarithmic scale:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; autoplot(res)</strong></span>
</pre></div><div class="mediaobject"><img alt="Running benchmarks" src="graphics/2028OS_03_01.jpg"/></div><p>Therefore, <code class="literal">dplyr</code> seems to be the most efficient solution, although if we also take the extra step (to group <code class="literal">data.frame</code>) into account, it makes the otherwise clear advantage rather unconvincing. As a matter of fact, if we already have a <code class="literal">data.table</code> object, and we can save the transformation of a traditional <code class="literal">data.frame</code> object into <code class="literal">data.table</code>, then <code class="literal">data.table</code> performs better than <code class="literal">dplyr</code>. However, I am pretty sure that you will not really notice the time difference between the two high-performance solutions; both of these do a very good job with even larger datasets.</p><p>It's worth mentioning that <code class="literal">dplyr</code> can work with <code class="literal">data.table</code> objects as well; therefore, to ensure that you are not locked to either package, it's definitely worth using both if needed. The following is a POC example:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; dplyr::summarise(group_by(hflights_dt, DayOfWeek), mean(Diverted))</strong></span>
<span class="strong"><strong>Source: local data table [7 x 2]</strong></span>

<span class="strong"><strong>  DayOfWeek mean(Diverted)</strong></span>
<span class="strong"><strong>1         1    0.002997672</strong></span>
<span class="strong"><strong>2         2    0.002559323</strong></span>
<span class="strong"><strong>3         3    0.003226211</strong></span>
<span class="strong"><strong>4         4    0.003065727</strong></span>
<span class="strong"><strong>5         5    0.002687865</strong></span>
<span class="strong"><strong>6         6    0.002823121</strong></span>
<span class="strong"><strong>7         7    0.002589057 </strong></span>
</pre></div><p>Okay, so now we are pretty<a class="indexterm" id="id295"/> sure to use either <code class="literal">data.table</code> or <code class="literal">dplyr</code> for computing group averages in the future. However, what about more complex operations?</p></div>
<div class="section" title="Summary functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Summary functions</h1></div></div></div><p>As we have discussed earlier, all <a class="indexterm" id="id296"/>aggregating functions can take any valid R functions to apply on the subsets of the data. Some of the R packages make it extremely easy for the users, while a few functions do require you to fully understand the package concept, custom syntax, and options to get the most out of the high-performance opportunities. </p><p>For such more advanced topics, please see <a class="link" href="ch04.html" title="Chapter 4. Restructuring Data">Chapter 4</a>, <span class="emphasis"><em>Restructuring Data</em></span>, and the further readings listed in the <span class="emphasis"><em>References</em></span> section at the end of the book.</p><p>Now, we will concentrate on a very simple <code class="literal">summary</code> function, which is extremely common in any general data analysis project: counting the number of cases per group. This quick example will also highlight some of the differences among the referenced alternatives mentioned in this chapter.</p><div class="section" title="Adding up the number of cases in subgroups"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec31"/>Adding up the number of cases in subgroups</h2></div></div></div><p>Let's focus on <code class="literal">plyr</code>, <code class="literal">dplyr</code> and <code class="literal">data.table</code> now, as I am pretty sure that you can construct the <code class="literal">aggregate</code> and <code class="literal">tapply</code> versions without any serious issues. On the basis of the previous examples, the current task <a class="indexterm" id="id297"/>seems fairly easy: instead of the <code class="literal">mean</code> function, we can simply call the <code class="literal">length</code> function to return the number of elements in the <code class="literal">Diverted</code> column:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; ddply(hflights, .(DayOfWeek), summarise, n = length(Diverted))</strong></span>
<span class="strong"><strong>  DayOfWeek     n</strong></span>
<span class="strong"><strong>1         1 34360</strong></span>
<span class="strong"><strong>2         2 31649</strong></span>
<span class="strong"><strong>3         3 31926</strong></span>
<span class="strong"><strong>4         4 34902</strong></span>
<span class="strong"><strong>5         5 34972</strong></span>
<span class="strong"><strong>6         6 27629</strong></span>
<span class="strong"><strong>7         7 32058</strong></span>
</pre></div><p>Now, we also know that a relatively low number of flights leave Houston on Saturday. However, do we really have to type so much to answer such a simple question? Further, do we really have to name a variable in which we can count the number of cases? You already know the answer:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; ddply(hflights, .(DayOfWeek), nrow)</strong></span>
<span class="strong"><strong>  DayOfWeek    V1</strong></span>
<span class="strong"><strong>1         1 34360</strong></span>
<span class="strong"><strong>2         2 31649</strong></span>
<span class="strong"><strong>3         3 31926</strong></span>
<span class="strong"><strong>4         4 34902</strong></span>
<span class="strong"><strong>5         5 34972</strong></span>
<span class="strong"><strong>6         6 27629</strong></span>
<span class="strong"><strong>7         7 32058</strong></span>
</pre></div><p>In short, there is no need to choose a variable from <code class="literal">data.frame</code> to determine its length, as it's a lot easier (and faster) to simply check the number of rows in the (sub)datasets.</p><p>However, we can also<a class="indexterm" id="id298"/> return the very same results in a much easier and quicker way. Probably, you have already thought of using the good old <code class="literal">table</code> function for such a straightforward task:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; table(hflights$DayOfWeek)</strong></span>

<span class="strong"><strong>    1     2     3     4     5     6     7 </strong></span>
<span class="strong"><strong>34360 31649 31926 34902 34972 27629 32058</strong></span>
</pre></div><p>The only problem with the resulting object is that we have to transform it further, for example, to <code class="literal">data.frame</code> in most cases. Well, <code class="literal">plyr</code> already has a helper function to do this in one step, with a very intuitive name:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; count(hflights, 'DayOfWeek')</strong></span>
<span class="strong"><strong>  DayOfWeek  freq</strong></span>
<span class="strong"><strong>1         1 34360</strong></span>
<span class="strong"><strong>2         2 31649</strong></span>
<span class="strong"><strong>3         3 31926</strong></span>
<span class="strong"><strong>4         4 34902</strong></span>
<span class="strong"><strong>5         5 34972</strong></span>
<span class="strong"><strong>6         6 27629</strong></span>
<span class="strong"><strong>7         7 32058</strong></span>
</pre></div><p>Therefore, we end up with some rather simple examples for counting data, but let us also see how to implement summary tables with <code class="literal">dplyr</code>. If you simply try to modify our previous <code class="literal">dplyr</code> commands, you will soon realize that passing the <code class="literal">length</code> or <code class="literal">nrow</code> function, as we did in <code class="literal">plyr</code>, simply does not work. However, reading the manuals or some related questions on StackOverflow soon points our attention to a handy helper function called <code class="literal">n</code>:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; dplyr::summarise(hflights_DayOfWeek, n())</strong></span>
<span class="strong"><strong>Source: local data frame [7 x 2]</strong></span>

<span class="strong"><strong>  DayOfWeek   n()</strong></span>
<span class="strong"><strong>1         1 34360</strong></span>
<span class="strong"><strong>2         2 31649</strong></span>
<span class="strong"><strong>3         3 31926</strong></span>
<span class="strong"><strong>4         4 34902</strong></span>
<span class="strong"><strong>5         5 34972</strong></span>
<span class="strong"><strong>6         6 27629</strong></span>
<span class="strong"><strong>7         7 32058</strong></span>
</pre></div><p>However, to be<a class="indexterm" id="id299"/> honest, do we really need this relatively complex approach? If you remember the structure of <code class="literal">hflights_DayOfWeek</code>, you will soon realize that there is a lot easier and quicker way to find out the overall number of flights on each weekday:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; attr(hflights_DayOfWeek, 'group_sizes')</strong></span>
<span class="strong"><strong>[1] 34360 31649 31926 34902 34972 27629 32058</strong></span>
</pre></div><p>Further, just to make sure that we do not forget the custom (yet pretty) syntax of <code class="literal">data.table</code>, let us compute the results with another helper function:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; hflights_dt[, .N, by = list(DayOfWeek)]</strong></span>
<span class="strong"><strong>   DayOfWeek     N</strong></span>
<span class="strong"><strong>1:         1 34360</strong></span>
<span class="strong"><strong>2:         2 31649</strong></span>
<span class="strong"><strong>3:         3 31926</strong></span>
<span class="strong"><strong>4:         4 34902</strong></span>
<span class="strong"><strong>5:         5 34972</strong></span>
<span class="strong"><strong>6:         6 27629</strong></span>
<span class="strong"><strong>7:         7 32058</strong></span>
</pre></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Summary</h1></div></div></div><p>In this chapter, we introduced some effective and convenient ways of filtering and summarizing data. We discussed some use cases on filtering the rows and columns of datasets. We also learned how to summarize data for further analysis. After getting familiar with the most popular implementations of such tasks, we compared them with reproducible examples and a benchmarking package.</p><p>In the next chapter, we will continue this journey of restructuring datasets and creating new variables.</p></div></body></html>