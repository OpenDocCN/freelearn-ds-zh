<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Recommender Systems</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Collaborative filtering using explicit feedback</li><li class="listitem" style="list-style-type: disc">Collaborative filtering using implicit feedback</li></ul></div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec67"/>Introduction</h1></div></div></div><p>The following is Wikipedia's definition of recommender systems:</p><div><blockquote class="blockquote"><p><em>"Recommender systems are a subclass of information filtering system that seek to predict the 'rating' or 'preference' that user would give to an item."</em></p></blockquote></div><p>Recommender systems<a id="id562" class="indexterm"/> have gained immense popularity in recent years. Amazon uses them to recommend books, Netflix for movies, and Google News to recommend news stories. As the proof is in the pudding, here are some examples of the impact recommendations can have (source: Celma, Lamere, 2008):</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Two-thirds of the movies watched on Netflix are recommended</li><li class="listitem" style="list-style-type: disc">38 percent of the news clicks on Google News are recommended</li><li class="listitem" style="list-style-type: disc">35 percent of the sales at Amazon sales are the result of recommendations</li></ul></div><p>As we have seen in the previous chapters, features and feature selection play a major role in the efficacy of machine learning algorithms. Recommender engine algorithms discover these features, called <strong>latent features</strong>, automatically. In short, there are latent features responsible for a user<a id="id563" class="indexterm"/> to like one movie and dislike another. If another user has corresponding latent features, there is a good chance that this person will also have a similar taste for movies.</p><p>To understand this better, let's look at some sample movie ratings:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Movie</p>
</th><th style="text-align: left" valign="bottom">
<p>Rich</p>
</th><th style="text-align: left" valign="bottom">
<p>Bob</p>
</th><th style="text-align: left" valign="bottom">
<p>Peter</p>
</th><th style="text-align: left" valign="bottom">
<p>Chris</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><em>Titanic</em></p>
</td><td style="text-align: left" valign="top">
<p>5</p>
</td><td style="text-align: left" valign="top">
<p>3</p>
</td><td style="text-align: left" valign="top">
<p>5</p>
</td><td style="text-align: left" valign="top">
<p>?</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><em>GoldenEye</em></p>
</td><td style="text-align: left" valign="top">
<p>3</p>
</td><td style="text-align: left" valign="top">
<p>2</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>5</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><em>Toy Story</em></p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>?</p>
</td><td style="text-align: left" valign="top">
<p>2</p>
</td><td style="text-align: left" valign="top">
<p>2</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><em>Disclosure</em></p>
</td><td style="text-align: left" valign="top">
<p>4</p>
</td><td style="text-align: left" valign="top">
<p>4</p>
</td><td style="text-align: left" valign="top">
<p>?</p>
</td><td style="text-align: left" valign="top">
<p>4</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><em>Ace Ventura</em></p>
</td><td style="text-align: left" valign="top">
<p>4</p>
</td><td style="text-align: left" valign="top">
<p>?</p>
</td><td style="text-align: left" valign="top">
<p>4</p>
</td><td style="text-align: left" valign="top">
<p>?</p>
</td></tr></tbody></table></div><p>Our goal is to predict the missing entries shown with the ? symbol. Let's see if we can find some features associated with movies. At first, you will look at the genres, as shown here:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Movie</p>
</th><th style="text-align: left" valign="bottom">
<p>Genre</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><em>Titanic</em></p>
</td><td style="text-align: left" valign="top">
<p>Action, Romance</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><em>GoldenEye</em></p>
</td><td style="text-align: left" valign="top">
<p>Action, Adventure, Thriller</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><em>Toy Story</em></p>
</td><td style="text-align: left" valign="top">
<p>Animation, Children's, Comedy</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><em>Disclosure</em></p>
</td><td style="text-align: left" valign="top">
<p>Drama, Thriller</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><em>Ace Ventura</em></p>
</td><td style="text-align: left" valign="top">
<p>Comedy</p>
</td></tr></tbody></table></div><p>Now each movie can be rated for each genre from 0 to 1. For example, <em>GoldenEye</em> is not primarily a romance, so it may have 0.1 rating for romance, but 0.98 rating for action. Therefore, each movie can be represented as a feature vector.</p><div><div><h3 class="title"><a id="note21"/>Note</h3><p>In this chapter, we <a id="id564" class="indexterm"/>are going to use the MovieLens dataset from <a class="ulink" href="http://grouplens.org/datasets/movielens/">grouplens.org/datasets/movielens/</a>.</p></div></div><p>The InfoObjects big data sandbox comes loaded with 100k movie ratings. From GroupLens you can also download 1 million-or even up to 10 million-ratings if you would like to analyze bigger dataset for better predictions.</p><p>We are going to use two files from this dataset:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">u.data</code>: This has a tab-separated list of movie ratings in the following format:<div><pre class="programlisting">user id | item id | rating | epoch time</pre></div><p>Since we are not going to need the time stamp, we are going to filter it out from the data in our recipe</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">u.item</code>: This has a tab-separated list of movies in the following format:<div><pre class="programlisting">movie id | movie title | release date | video release date |               IMDb URL | unknown | Action | Adventure | Animation |               Children's | Comedy | Crime | Documentary | Drama | Fantasy |               Film-Noir | Horror | Musical | Mystery | Romance | Sci-Fi |               Thriller | War | Western |</pre></div></li></ul></div><p>This chapter will cover how we can make recommendations using MLlib, the Spark's machine learning library.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec68"/>Collaborative filtering using explicit feedback</h1></div></div></div><p>Collaborative filtering is the most commonly used technique for recommender systems. It has an <a id="id565" class="indexterm"/>interesting property—it learns the features on its own. So, in<a id="id566" class="indexterm"/> the case of movie ratings, we do <a id="id567" class="indexterm"/>not need to provide actual human feedback on whether the movie is romantic or action.</p><p>As we saw in the <em>Introduction</em> section that movies have some latent features, such as genre, in the same way users have some latent features, such as age, gender, and more. Collaborative filtering does not need them, and figures out latent features on its own.</p><p>We are going to <a id="id568" class="indexterm"/>use an algorithm called <strong>Alternating Least Squares</strong> (<strong>ALS</strong>) in this example. This algorithm explains the association between a movie and a user based on a small number of latent features. It uses three training parameters: rank, number of iterations, and lambda (explained later in the chapter). The best way to figure out the optimum values of these three parameters is to try<a id="id569" class="indexterm"/> different values and see which value has the smallest amount of <strong>Root Mean Square Error</strong> (<strong>RMSE</strong>). This error is like a standard deviation, but it is based on model results rather than actual data.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec99"/>Getting ready</h2></div></div></div><p>Upload the <code class="literal">moviedata</code> downloaded from GroupLens to the <code class="literal">moviedata</code> folder in <code class="literal">hdfs</code>:</p><div><pre class="programlisting">
<strong>$ hdfs dfs -put moviedata moviedata</strong>
</pre></div><p>We are going to add some personalized ratings to this database so that we can test the accuracy of the recommendations.</p><p>You can look at <code class="literal">u.item</code> to pick some movies and rate them. The following are some movies I chose, alongside my ratings. Feel free to choose the movies you would like to rate and provide your own ratings.</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Movie ID</p>
</th><th style="text-align: left" valign="bottom">
<p>Movie name</p>
</th><th style="text-align: left" valign="bottom">
<p>Rating (1-5)</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>313</p>
</td><td style="text-align: left" valign="top">
<p><em>Titanic</em></p>
</td><td style="text-align: left" valign="top">
<p>5</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>2</p>
</td><td style="text-align: left" valign="top">
<p><em>GoldenEye</em></p>
</td><td style="text-align: left" valign="top">
<p>3</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p><em>Toy Story</em></p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>43</p>
</td><td style="text-align: left" valign="top">
<p><em>Disclosure</em></p>
</td><td style="text-align: left" valign="top">
<p>4</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>67</p>
</td><td style="text-align: left" valign="top">
<p><em>Ace Ventura</em></p>
</td><td style="text-align: left" valign="top">
<p>4</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>82</p>
</td><td style="text-align: left" valign="top">
<p><em>Jurassic Park</em></p>
</td><td style="text-align: left" valign="top">
<p>5</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>96</p>
</td><td style="text-align: left" valign="top">
<p><em>Terminator 2</em></p>
</td><td style="text-align: left" valign="top">
<p>5</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>121</p>
</td><td style="text-align: left" valign="top">
<p><em>Independence Day</em></p>
</td><td style="text-align: left" valign="top">
<p>4</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>148</p>
</td><td style="text-align: left" valign="top">
<p><em>The Ghost and the Darkness</em></p>
</td><td style="text-align: left" valign="top">
<p>4</p>
</td></tr></tbody></table></div><p>The<a id="id570" class="indexterm"/> highest user ID is 943, so we are going<a id="id571" class="indexterm"/> to add the new user as 944. Let's create a new comma-separated file <code class="literal">p.data</code> with the following data:</p><div><pre class="programlisting">944,313,5
944,2,3
944,1,1
944,43,4
944,67,4
944,82,5
944,96,5
944,121,4
944,148,4</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec100"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Upload the personalized movie data to <code class="literal">hdfs</code>:<div><pre class="programlisting">
<strong>$ hdfs dfs -put p.data p.data</strong>
</pre></div></li><li class="listitem">Import the ALS and rating classes:<div><pre class="programlisting">
<strong>scala&gt; import org.apache.spark.mllib.recommendation.ALS</strong>
<strong>scala&gt; import org.apache.spark.mllib.recommendation.Rating</strong>
</pre></div></li><li class="listitem">Load the rating data into an RDD:<div><pre class="programlisting">
<strong>scala&gt; val data = sc.textFile("moviedata/u.data")</strong>
</pre></div></li><li class="listitem">Transform the <code class="literal">val data</code> into the RDD of rating:<div><pre class="programlisting">
<strong>scala&gt; val ratings = data.map { line =&gt; </strong>
<strong>  val Array(userId, itemId, rating, _) = line.split("\t") </strong>
<strong>  Rating(userId.toInt, itemId.toInt, rating.toDouble) </strong>
<strong>}</strong>
</pre></div></li><li class="listitem">Load the personalized rating data into the RDD:<div><pre class="programlisting">
<strong>scala&gt; val pdata = sc.textFile("p.data")</strong>
</pre></div></li><li class="listitem">Transform the data into the RDD of personalized rating:<div><pre class="programlisting">
<strong>scala&gt; val pratings = pdata.map { line =&gt; </strong>
<strong>  val Array(userId, itemId, rating) = line.split(",")</strong>
<strong>  Rating(userId.toInt, itemId.toInt, rating.toDouble) </strong>
<strong>}</strong>
</pre></div></li><li class="listitem">Combine ratings with personalized ratings:<div><pre class="programlisting">
<strong>scala&gt; val movieratings = ratings.union(pratings)</strong>
</pre></div></li><li class="listitem">Build the model using ALS with rank 5 and 10 iterations and 0.01 as lambda:<div><pre class="programlisting">
<strong>scala&gt; val model = ALS.train(movieratings, 10, 10, 0.01)</strong>
</pre></div></li><li class="listitem">Let's <a id="id572" class="indexterm"/>predict what my rating <a id="id573" class="indexterm"/>would be for a given movie based on this model.</li><li class="listitem">Let's start with original <em>Terminator</em> with movie ID 195:<div><pre class="programlisting">
<strong>scala&gt; model.predict(sc.parallelize(Array((944,195)))).collect.foreach(println)</strong>
<strong>Rating(944,195,4.198642954004738)</strong>
</pre></div><p>Since I rated <em>Terminator</em> <em>2</em> 5, this is a reasonable prediction.</p></li><li class="listitem">Let's try <em>Ghost</em> with movie ID 402:<div><pre class="programlisting">
<strong>scala&gt; model.predict(sc.parallelize(Array((944,402)))).collect.foreach(println)</strong>
<strong>Rating(944,402,2.982213836456829)</strong>
</pre></div><p>It's a reasonable guess.</p></li><li class="listitem">Let's try <em>The Ghost and the Darkness</em>, the movie I already rated, with the ID 148:<div><pre class="programlisting">
<strong>scala&gt; model.predict(sc.parallelize(Array((944,402)))).collect.foreach(println)</strong>
<strong>Rating(944,148,3.8629938805450035)</strong>
</pre></div><p>Very close prediction, knowing that I rated the movie 4.</p></li></ol></div><p>You can use more movies to the <code class="literal">train</code> dataset. There are also 1 million and 10 million rating datasets available that will refine the algorithm even more.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec69"/>Collaborative filtering using implicit feedback</h1></div></div></div><p>Sometimes<a id="id574" class="indexterm"/> the feedback available is <a id="id575" class="indexterm"/>not in the form of ratings but in the form of audio tracks played, movies watched, and so on. This data, at first glance, may not look as good as explicit ratings by users, but this is much more exhaustive.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec101"/>Getting ready</h2></div></div></div><p>We are going to use million song data from <a class="ulink" href="http://www.kaggle.com/c/msdchallenge/data">http://www.kaggle.com/c/msdchallenge/data</a>. You need to download three files:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">kaggle_visible_evaluation_triplets</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">kaggle_users.txt</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">kaggle_songs.txt</code></li></ul></div><p>Now perform<a id="id576" class="indexterm"/> the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create <a id="id577" class="indexterm"/>a <code class="literal">songdata</code> folder in <code class="literal">hdfs</code> and put all the three files here:<div><pre class="programlisting">
<strong>$ hdfs dfs -mkdir songdata</strong>
</pre></div></li><li class="listitem">Upload the song data to <code class="literal">hdfs</code>:<div><pre class="programlisting">
<strong>$ hdfs dfs -put kaggle_visible_evaluation_triplets.txt songdata/</strong>
<strong>$ hdfs dfs -put kaggle_users.txt songdata/</strong>
<strong>$ hdfs dfs -put kaggle_songs.txt songdata/</strong>
</pre></div></li></ol></div><p>We still need to do some more preprocessing. ALS in MLlib takes both user and product IDs as integer. The <code class="literal">Kaggle_songs.txt</code> file has song IDs and sequence number next to it, The <code class="literal">Kaggle_users.txt</code> file does not have it. Our goal is to replace the <code class="literal">userid</code> and <code class="literal">songid</code> in <code class="literal">triplets</code> data with the corresponding integer sequence numbers. To do this, follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Load the <code class="literal">kaggle_songs</code> data as an RDD:<div><pre class="programlisting">
<strong>scala&gt; val songs = sc.textFile("songdata/kaggle_songs.txt")</strong>
</pre></div></li><li class="listitem">Load the user data as an RDD:<div><pre class="programlisting">
<strong>scala&gt; val users = sc.textFile("songdata/kaggle_users.txt")</strong>
</pre></div></li><li class="listitem">Load the triplets (user, song, plays) data as an RDD:<div><pre class="programlisting">
<strong>scala&gt; val triplets = sc.textFile("songdata/kaggle_visible_evaluation_triplets.txt")</strong>
</pre></div></li><li class="listitem">Convert the song data into the <code class="literal">PairRDD</code>:<div><pre class="programlisting">
<strong>scala&gt; val songIndex = songs.map(_.split("\\W+")).map(v =&gt; (v(0),v(1).toInt))</strong>
</pre></div></li><li class="listitem">Collect the <code class="literal">songIndex</code> as Map:<div><pre class="programlisting">
<strong>scala&gt; val songMap = songIndex.collectAsMap</strong>
</pre></div></li><li class="listitem">Convert the user data into the <code class="literal">PairRDD</code>:<div><pre class="programlisting">
<strong>scala&gt; val userIndex = users.zipWithIndex.map( t =&gt; (t._1,t._2.toInt))</strong>
</pre></div></li><li class="listitem">Collect the <code class="literal">userIndex</code> as Map:<div><pre class="programlisting">
<strong>scala&gt; val userMap = userIndex.collectAsMap</strong>
</pre></div></li></ol></div><p>We will need both <code class="literal">songMap</code> and <code class="literal">userMap</code> to replace <code class="literal">userId</code> and <code class="literal">songId</code> in triplets. Spark will <a id="id578" class="indexterm"/>automatically make both these <a id="id579" class="indexterm"/>maps available on the cluster as needed. This works fine but is expensive to send across the cluster every time it is needed.</p><p>A better approach is to use a Spark feature called <code class="literal">broadcast</code> variables. The <code class="literal">broadcast</code> variables allow the Spark job to keep a read-only copy of a variable cached on each machine, rather than shipping a copy with each task. Spark distributes broadcast variables using efficient broadcast algorithms, so communication cost over the network is negligible.</p><p>As you can guess, both <code class="literal">songMap</code> and <code class="literal">userMap</code> are good candidates to be wrapped around the <code class="literal">broadcast</code> variables. Perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Broadcast the <code class="literal">userMap</code>:<div><pre class="programlisting">
<strong>scala&gt; val broadcastUserMap = sc.broadcast(userMap)</strong>
</pre></div></li><li class="listitem">Broadcast the <code class="literal">songMap</code>:<div><pre class="programlisting">
<strong>scala&gt; val broadcastSongMap = sc.broadcast(songMap)</strong>
</pre></div></li><li class="listitem">Convert the <code class="literal">triplet</code> into an array:<div><pre class="programlisting">
<strong>scala&gt; val tripArray = triplets.map(_.split("\\W+"))</strong>
</pre></div></li><li class="listitem">Import the rating:<div><pre class="programlisting">
<strong>scala&gt; import org.apache.spark.mllib.recommendation.Rating</strong>
</pre></div></li><li class="listitem">Convert the <code class="literal">triplet</code> array into an RDD of rating objects:<div><pre class="programlisting">
<strong>scala&gt; val ratings = tripArray.map { case Array(user, song, plays) =&gt;</strong>
<strong>  val userId = broadcastUserMap.value.getOrElse(user, 0)</strong>
<strong>  val songId = broadcastUserMap.value.getOrElse(song, 0)</strong>
<strong>  Rating(userId, songId, plays.toDouble)</strong>
<strong>}</strong>
</pre></div></li></ol></div><p>Now, our data is ready to do the modeling and prediction.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec102"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Import ALS:<div><pre class="programlisting">
<strong>scala&gt; import org.apache.spark.mllib.recommendation.ALS</strong>
</pre></div></li><li class="listitem">Build a model using the ALS with rank 10 and 10 iterations:<div><pre class="programlisting">
<strong>scala&gt; val model = ALS.trainImplicit(ratings, 10, 10)</strong>
</pre></div></li><li class="listitem">Extract the user and song tuples from the triplet:<div><pre class="programlisting">
<strong>scala&gt; val usersSongs = ratings.map( r =&gt; (r.user, r.product) )</strong>
</pre></div></li><li class="listitem">Make predictions for the user and song tuples:<div><pre class="programlisting">
<strong>scala&gt; val predictions = model.predict(usersSongs)</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec103"/>How it works…</h2></div></div></div><p>Our <a id="id580" class="indexterm"/>model takes four parameters<a id="id581" class="indexterm"/> to work, as shown here:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Parameter name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Rank</p>
</td><td style="text-align: left" valign="top">
<p>Number of latent features in the model</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Iterations</p>
</td><td style="text-align: left" valign="top">
<p>Number of iterations for this factorization to run</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Lambda</p>
</td><td style="text-align: left" valign="top">
<p>Over fitting parameter</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Alpha</p>
</td><td style="text-align: left" valign="top">
<p>Relative weight of observed interactions</p>
</td></tr></tbody></table></div><p>As you saw in the case of gradient descent, these parameters need to be set by hand. We can try different values, but the value that works best is rank=50, iterations=30, lambda=0.00001, and alpha= 40.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec104"/>There's more…</h2></div></div></div><p>One way to test different parameters quickly is to spawn a spark cluster on Amazon EC2. This gives you flexibility to go with a powerful instance to test these parameters fast. I have created a public s3 bucket <code class="literal">com.infoobjects.songdata</code> to pull data to Spark.</p><p>Here are the steps you need to follow to load the data from S3 and run the ALS:</p><div><pre class="programlisting">
<strong>sc.hadoopConfiguration.set("fs.s3n.awsAccessKeyId", "&lt;your access key&gt;")</strong>
<strong>sc.hadoopConfiguration.set("fs.s3n.awsSecretAccessKey","&lt;your secret key&gt;")</strong>
<strong>val songs = sc.textFile("s3n://com.infoobjects.songdata/kaggle_songs.txt")</strong>
<strong>val users = sc.textFile("s3n://com.infoobjects.songdata/kaggle_users.txt")</strong>
<strong>val triplets = sc.textFile("s3n://com.infoobjects.songdata/kaggle_visible_evaluation_triplets.txt")</strong>
<strong>val songIndex = songs.map(_.split("\\W+")).map(v =&gt; (v(0),v(1).toInt))</strong>
<strong>val songMap = songIndex.collectAsMap</strong>
<strong>val userIndex = users.zipWithIndex.map( t =&gt; (t._1,t._2.toInt))</strong>
<strong>val userMap = userIndex.collectAsMap</strong>
<strong>val broadcastUserMap = sc.broadcast(userMap)</strong>
<strong>val broadcastSongMap = sc.broadcast(songMap)</strong>
<strong>val tripArray = triplets.map(_.split("\\W+"))</strong>
<strong>import org.apache.spark.mllib.recommendation.Rating</strong>
<strong>val ratings = tripArray.map{ v =&gt;</strong>
<strong>  val userId: Int = broadcastUserMap.value.get(v(0)).fold(0)(num =&gt; num)</strong>
<strong>  val songId: Int = broadcastSongMap.value.get(v(1)).fold(0)(num =&gt; num)</strong>
<strong>  Rating(userId,songId,v(2).toDouble)</strong>
<strong>  }</strong>
<strong>import org.apache.spark.mllib.recommendation.ALS</strong>
<strong>val model = ALS.trainImplicit(ratings, 50, 30, 0.000001, 40)</strong>
<strong>val usersSongs = ratings.map( r =&gt; (r.user, r.product) )</strong>
<strong>val predictions =model.predict(usersSongs)</strong>
</pre></div><p>These<a id="id582" class="indexterm"/> are the predictions made on <a id="id583" class="indexterm"/>the <code class="literal">usersSongs</code> matrix.</p></div></div></body></html>