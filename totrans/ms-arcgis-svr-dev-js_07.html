<html><head></head><body><div><div><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Plays Well with Others</h1></div></div></div><p>JavaScript development has matured over recent years. Once a simple language used to script a few animations and user interactions, JavaScript applications now support a full range of tasks that were only possible with desktop applications a few years ago. There are numerous well-documented libraries and frameworks that make complicated applications manageable through a web browser.</p><p>No JavaScript library or framework does everything perfectly. Most libraries focus on improving a few key requirements for application development, such as DOM manipulation, data binding, animation, or graphics. Some focus on speed; others focus on cross-browser compatibility.</p><p>A successful JavaScript developer doesn't have to build an application from scratch using one library or raw JavaScript to make it work. By adding current libraries that work well together, the developer can speed up development and handle multiple browser types without having to worry about them.</p><p>In this chapter, we'll cover the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Integrating jQuery into the applications</li><li class="listitem" style="list-style-type: disc">Integrating Backbone.js into the applications</li><li class="listitem" style="list-style-type: disc">Integrating Knockout.js into the applications</li><li class="listitem" style="list-style-type: disc">Discuss Using AngularJS in a mapping application</li></ul></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec67"/>Compatibility with other libraries and frameworks</h1></div></div></div><p>One way developers <a id="id593" class="indexterm"/>describe the usability of JavaScript libraries is how compatible they are with other libraries. The more libraries your library plays well with, the more likely it can be used on projects. When libraries don't play well with other libraries and frameworks, it can lead to unintended code bugs and actions that nobody saw coming. Since a developer cannot control what other libraries are used in a project with their library, it is better if a library plays well with others.</p><p>There are several ways that libraries can conflict with one another. One way that was more common in the past is through namespace collision. If two libraries create the same <code class="literal">cut()</code> function in the global namespace, you can't be sure which one will be called. Another, more subtle conflict arises through manipulating the prototype of standard JavaScript types. One library will expect the <code class="literal">map()</code> method called on an array to perform a specific task, but if another library overwrote <code class="literal">Array.prototype.map()</code>, the results may not turn out as expected, and may break the application. Typically, it's only polite to manipulate the prototype of base JavaScript types if you are patching support for older browsers.</p><p>A more recent way that JavaScript libraries can clash is in how they implement modules. Before ECMAScript 6 came out with the standard for modules, there were two schools of module development. One revolved around using CommonJS to define modules, and the other was AMD. Typically, modules from one can be loaded by the other, as they are called and constructed differently. Most small libraries that aren't defined one way or another can be loaded into either one, with a little work.</p><p>Even within AMD, there can be some conflicts. Some libraries and frameworks use Require.JS to load their modules. While syntactily similar, there are some differences in older versions of Dojo that create errors when mixing with Require.JS modules. It's something to be aware of when mixing and mashing up JavaScript libraries in your application.</p></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec68"/>Popular libraries to play with</h1></div></div></div><p>Now that we've looked at <a id="id594" class="indexterm"/>library compatibility as a whole, it's time to check out how the ArcGIS API for JavaScript plays with other JavaScript libraries and frameworks. We'll look at some of the popular libraries used by developers, and attempt to load them along with the ArcGIS API for JavaScript. We'll create the same application using jQuery, Backbone.js, Knockout.js, and AngularJS, and see how they compare. Finally, we'll look at a few do's and don'ts with any framework and the ArcGIS API.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec96"/>Our story continues</h2></div></div></div><p>So, our census <a id="id595" class="indexterm"/>data app is a big hit for the Y2K society. They like the look of the graphics, and want us to expand it. The functionality of the widget is great, but they've made a new request. It seems that one of the members watched a late night comedian on television the other night, and found out that there are people out there who can't find their state or county on a map.</p><p>After discussing possible solutions with our client, we've decided to add some drop-down controls that let the user select a state, county, and even a census block group. On picking a state, the map zooms to the state and shows the data in a popup. Also, the county dropdown is populated with the county names in that state. When the county is selected, the county is selected with a popup, and the block group names are populated for that county and state. Finally, if the block group is selected, the block group is zoomed to, and the data is displayed on the map.</p><p>In somewhat related news, we've picked up an intern. He's an eager young kid who likes to follow the latest in JavaScript. He wants to contribute something to this project, and this looks like a good task to let him cut his teeth on.</p><p>The problem is, our intern wants to write the code using another library or framework, and not just a simple one. He wants to bring in a number of popular libraries including jQuery, Backbone, Knockout, Node.js, and Angular. While we appreciate his desire to learn (and to pad his resume), we have to have a serious talk with him about picking libraries appropriate for the project.</p><p>After talking the intern out of a Node.js project (since this is a client-side app, with no need for server-side work at this point), we explain the general use of the other libraries, he had on his list. We decide to give the intern a learning project, and let him build four copies of the app, each incorporating either jQuery, Backbone, Knockout, or Angular. He can evaluate each app and let us know which worked best with the application. We figure it's okay that he does four times the work, since he's not a paid intern.</p><p>We should go ahead and set up four project folders with copies of the <code class="literal">D3.js</code> app from our previous chapter's work. In each of the projects, we need to modify the <code class="literal">Census.html</code> template in the <code class="literal">/js/template</code> folder to show the drop-down menus. We'll add three drop-down menus with bold labels and selects that will be populated later by the four libraries. It should look like the following:</p><div><pre class="programlisting">&lt;div class="${baseClass}" style="display: none;"&gt;
  &lt;span class="${baseClass}-close" data-dojo-attach-event="ondijitclick:hide"&gt;X&lt;/span&gt;
  &lt;b&gt;Census Data&lt;/b&gt;&lt;br /&gt;
  &lt;p&gt;
    Click on a location in the United States to view the census  data for that region. <strong>You can also use the dropdown tools to  select a State, County, or Blockgroup.</strong>
  &lt;/p&gt;
  <strong>&lt;div &gt;</strong>
<strong>    &lt;b&gt;State Selector: &lt;/b&gt;</strong>
<strong>    &lt;select&gt;&lt;/select&gt;</strong>
<strong>  &lt;/div&gt;</strong>
<strong>  &lt;div&gt;</strong>
<strong>    &lt;b&gt;County Selector: &lt;/b&gt;</strong>
<strong>    &lt;select&gt;&lt;/select&gt;</strong>
<strong>  &lt;/div&gt;</strong>
<strong>  &lt;div&gt;</strong>
<strong>    &lt;b&gt;Block Group Selector: &lt;/b&gt;</strong>
<strong>    &lt;select&gt;&lt;/select&gt;</strong>
<strong>  &lt;/div&gt;</strong>
&lt;/div&gt;</pre></div><p>When the new <a id="id596" class="indexterm"/>application loads, the new widget should look something like the following:</p><div><img src="img/6459OT_07_01.jpg" alt="Our story continues" width="843" height="565"/></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec69"/>An overview of jQuery</h1></div></div></div><p>The most <a id="id597" class="indexterm"/>popular library for a number of years has to be jQuery. jQuery was originally created by John Resig as a library to handle DOM manipulation and events. Cross-browser compatibility is a strong selling point for this library, since it works in everything from the newest version of Chrome to Internet Explorer versions so old they make most developers cringe. Its intuitive commands and functionality make it easy to pick up for novice developers. The library is so popular that, as of the end of 2013, it is estimated to be used in 61 percent of the top 100,000 websites in the world, according to the jQuery blog (<a class="ulink" href="http://blog.jquery.com/2014/01/13/the-state-of-jquery-2014/">http://blog.jquery.com/2014/01/13/the-state-of-jquery-2014/</a>).</p><p>If you understand how jQuery works, you can skip the next section and go to <em>Adding jQuery in our App</em>. If not, here's a quick rundown on how jQuery works.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec97"/>How jQuery works</h2></div></div></div><p>The jQuery library <a id="id598" class="indexterm"/>is incredibly useful for selecting and manipulating DOM elements on a web page. DOM elements can be selected using the <code class="literal">jQuery()</code> function, or its common shortcut method <code class="literal">$()</code>. It accepts either a DOM element or a string with a CSS selector. To select an element with an <code class="literal">id</code>, you would put a <code class="literal">#</code> in front of the ID name. To select a CSS class, you insert a <code class="literal">.</code> in front of the class name. To select all elements of a tag name, just use the tag name. In fact, almost any legal CSS <code class="literal">select</code> statement is supported by jQuery. Here are some examples in the following code:</p><div><pre class="programlisting">jQuery("#main"); // selects a node with an id="main"
$("#main"); // A common shortcut for jQuery; same as above.
$(".classy"); // selects all elements with class="classy"
$("p"); // selects all paragraphs
$(".article p"); // selects all paragraphs in nodes of
                 // class="article"
$("input[type='text']"); // selects all text inputs</pre></div><p>Once the nodes are selected by the jQuery object, you can perform a number of functions on them. You can make them appear and disappear using the <code class="literal">show()</code> and <code class="literal">hide()</code> methods. You can change their style using <code class="literal">css()</code>, their properties using <code class="literal">attr()</code>, and their content using <code class="literal">html()</code> or <code class="literal">text()</code> methods. Selected form element values can be retrieved and set using the <code class="literal">val()</code>. You can also find elements within the selected elements with <code class="literal">find()</code>, and iterate through each item with the <code class="literal">each()</code> method. Events can also be assigned using the <code class="literal">on()</code> method, and removed using <code class="literal">off()</code>. These are just the most common jQuery methods.</p><p>Another powerful feature of jQuery is a property called <a id="id599" class="indexterm"/><strong>chaining</strong>. jQuery functions return the jQuery object. You can immediately call another function on what was returned. These chained commands are evaluated from left to right. You can create some powerful transformations on your HTML using this code. For example, if you wanted to turn every unordered list item into a green frog and every ordered list item to a big brown toad, you could do the following:</p><div><pre class="programlisting">$("ul &gt; li").css("color", "green").text("Frog"); 
$("ol &gt; li").css({"color": "green", "font-size": "72px"})
  .text("Toad"); // totally legal to do this.</pre></div><p>Just be warned, as <a id="id600" class="indexterm"/>you work with complex chained functions in jQuery, sometimes the target of the function will change. Functions like <code class="literal">each()</code> and <code class="literal">find()</code> will change the selection that is passed to the next function. In this example, the developer wants to show a form, set its width to <code class="literal">400px</code>, clear the values of the text blanks, and turn the labels blue. When they run it, they will find that the labels don't turn blue as they expected:</p><div><pre class="programlisting">$("form").show().css("width", "400px")
  .find('input').val('')
  .find('label').css('color', '#0f0');</pre></div><p>When the developer called <code class="literal">find('input')</code>, it changed the selected items from form elements to input elements. Then, when the <code class="literal">find('label')</code> was called, jQuery searched for labels that were inside the input tags. Not finding any, nothing turned blue. Thankfully, the developer remembered that jQuery also provides an <code class="literal">end()</code> function that returns you to your original selection. The following bit of code works much better:</p><div><pre class="programlisting">$("form").show().css("width", "400px")
  .find('input').val('')<strong>.end()</strong>
  .find('label').css('color', '#0f0');</pre></div><p>Now that we've taken a crash course in jQuery, let's try to use it in our application.</p></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec70"/>Adding jQuery to your app</h1></div></div></div><p>So, our intern is <a id="id601" class="indexterm"/>starting to work with the jQuery-based app when he runs into his first problem. How does he make jQuery and Dojo play well together? For the answer to that, we can look at some of the lessons from <a class="link" href="ch06.html" title="Chapter 6. Charting Your Progress">Chapter 6</a>, <em>Charting Your Progress</em>, when we added <code class="literal">D3.js</code> to our application.</p><p>Loading a copy of our <code class="literal">D3.js</code> app, we'll start by adding a reference to the jQuery library in our <code class="literal">dojoConfig</code> packages. Remember that it is the JavaScript configuration object that is loaded before we load the ArcGIS Javascript API. We'll add a package with the name and file location, but we'll also add a <code class="literal">main</code> property that will make the application <a id="id602" class="indexterm"/>load the jQuery library. You can download a copy of the jQuery library and place it in an accessible folder in your application, or you can make a reference to an external <a id="id603" class="indexterm"/><strong>content delivery network</strong> (or <strong>CDN</strong>) that's hosting the library. Using an external reference to jQuery hosted by Google, it should look something like the following code:</p><div><pre class="programlisting">dojoConfig = {
  async: true,
  packages: [
    {
     name: 'y2k',
     location: location.pathname.replace(/\/[^\/]*$/, '') + '/js'
    }, {
      name: "d3",
      location: "http://cdnjs.cloudflare.com/ajax/libs/d3/3.4.12/"
    }, <strong>{</strong>
<strong>      name: "jquery",</strong>
<strong>      location:"http://ajax.googleapis.com/ajax/libs/jquery/1.11.2",</strong>
<strong>      main: "jquery"</strong>
<strong>    }</strong>
  ]
};</pre></div><p>Now that we can access jQuery through AMD, let's open our <code class="literal">Census.js</code> file and add it as a module in our file. We'll add a reference to it in the <code class="literal">require</code> statement, and assign it to the module <code class="literal">$</code>, as it is commonly referred to in most jQuery examples. It should look something like the following code:</p><div><pre class="programlisting">require([…, "d3/d3", <strong>"jquery"</strong>], function (…, d3, <strong>$</strong>) {
  …
});</pre></div><p>Next, we'll need to update the <code class="literal">Census</code> widget template to give jQuery something to search for. While updating <code class="literal">Census.html</code> in the <code class="literal">js/templates/</code> folder, we'll add a <code class="literal">stateselect</code>, <code class="literal">countyselect</code>, and <code class="literal">blockgroupselect</code> class to each of the <code class="literal">select</code> menus. While <a id="id604" class="indexterm"/>adding IDs would make selecting the elements faster, adding class names will ensure that there is no ID name collision with other widgets in the application. The template will look like the following example:</p><div><pre class="programlisting">…
  &lt;p&gt;
  Click on a location in the United States to view the census data for that region. You can also use the dropdown tools to select a State, County, or Blockgroup.
  &lt;/p&gt;
  &lt;div &gt;
    &lt;b&gt;State Selector: &lt;/b&gt;
    &lt;select <strong>class="stateselect"</strong>&gt;&lt;/select&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;b&gt;County Selector: &lt;/b&gt;
    &lt;select <strong>class="countyselect"</strong>&gt;&lt;/select&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;b&gt;Block Group Selector: &lt;/b&gt;
    &lt;select <strong>class="blockgroupselect"</strong>&gt;&lt;/select&gt;
  &lt;/div&gt;
…</pre></div><p>Since we have something for jQuery to select, we need to let jQuery select it in our code. Add some jQuery selectors to the constructor of our <code class="literal">Census</code> widget to get the nodes that have the <code class="literal">stateselect</code>, <code class="literal">countyselect</code>, and <code class="literal">blockgroupselect</code> classes, and assign them to the <code class="literal">stateSelect</code>, <code class="literal">countySelect</code>, and <code class="literal">blockGroupSelect</code> properties of our widget, in that order. This is referred to as <a id="id605" class="indexterm"/><strong>caching</strong> our selections, which is a good practice for jQuery apps, since repeating DOM searches can take a long time, especially in a larger application:</p><div><pre class="programlisting">constructor: function (options, srcNodeRef) {
  …
  this.map = options.map || null;
  this.domNode = srcRefNode;

<strong>  this.stateSelect = $(".stateselect");</strong>
<strong>  this.countySelect = $(".countyselect");</strong>
<strong>  this.blockGroupSelect = $(".blockgroupselect");</strong>
  …
},</pre></div><p>If we ran the application now, we would find that there was nothing in the <code class="literal">stateSelect</code>, <code class="literal">countySelect</code>, and <code class="literal">blockGroupSelect</code> properties. Why? If you remember, back in <a class="link" href="ch03.html" title="Chapter 3. The Dojo Widget System">Chapter 3</a>, <em>The Dojo Widget System</em>, we talked about the lifecycle of a <code class="literal">Dojo</code> widget. We discussed the fact that, while the constructor function runs, the template won't have loaded yet. In fact, it will not be available until the widget runs the <code class="literal">postCreate()</code> method. We'll <a id="id606" class="indexterm"/>need to add <code class="literal">postCreate()</code> to our application, add a line that refers to the <code class="literal">postCreate</code> function inherited from the <code class="literal">WidgetBase</code> class, and then cut and paste the jQuery code we wrote earlier into this function. It should look something like the following code:</p><div><pre class="programlisting">constructor: function (options, srcNodeRef) { 
  …
  this.domNode = srcRefNode;
  /* stateSelect, countySelect, and blockGroupSelect removed */
  …
},

<strong>postCreate: function () {</strong>
<strong>  this.inherited(arguments);</strong>

  <strong>this.stateSelect = $(".stateselect");</strong>
<strong>  this.countySelect = $(".countyselect");</strong>
<strong>  this.blockGroupSelect = $(".blockgroupselect");</strong>
<strong>},</strong>
</pre></div><p>Now, when the <code class="literal">postCreate</code> method is called, <code class="literal">stateSelect</code>, <code class="literal">countySelect</code>, and <code class="literal">blockGroupSelect</code> will be filled with appropriate objects.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec98"/>Filling in our dropdowns</h2></div></div></div><p>We need data to<a id="id607" class="indexterm"/> fill in our <a id="id608" class="indexterm"/>select dropdowns. For that, we'll need to get state, county, and block group names from the map services and fill them in the dropdowns. For the fifty or more states, that is easy, but what about counties and block groups? There are over 250 counties in the state of Texas alone, and even more block groups. We need a systematic way to populate the dropdowns.</p><p>What if, every time we selected a state, the county dropdown was filled with all the counties in that state? Also, what if the block groups list wasn't populated until the user selected the county of interest? We can achieve this if we listen to the <code class="literal">select</code> element's <code class="literal">change</code> event. When the event fires, we'll have a new selection result from the previous level query for the new list.</p><p>We'll start by stubbing out two new methods in the <code class="literal">Census</code> module, called <code class="literal">queryDropdownData()</code> and <code class="literal">populateDropdown()</code>. Instead of adding a list of parameters that we don't know <a id="id609" class="indexterm"/>yet, we'll add a single argument called <code class="literal">args</code> to the <code class="literal">queryDropdownData()</code> method. To the <code class="literal">populateDropdown()</code> method, we'll add the <code class="literal">args</code> parameter, plus <a id="id610" class="indexterm"/>a <code class="literal">featureSet</code> parameter that will come from querying the map data:</p><div><pre class="programlisting">…
getDropDownData: function (args) { },
populateDropdown: function (args, featureSet) { },
…</pre></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec88"/>Adding the QueryTask</h3></div></div></div><p>Inside <a id="id611" class="indexterm"/>the <code class="literal">queryDropdownData()</code> method, we're going to query a map service to get the list of counties in a state, or block groups in a county. For this, we'll need to add the ArcGIS JavaScript API's <code class="literal">QueryTask</code>. If you remember from <a class="link" href="ch02.html" title="Chapter 2. Digging into the API">Chapter 2</a>, <em>Digging into the API</em>, <code class="literal">QueryTask</code> lets us pull SQL-like queries to single layers in a map service. We'll need to add references to the <code class="literal">require</code> statement for the <code class="literal">QueryTask</code> and its associated task parameter builder, the <code class="literal">Query</code>. We'll go ahead and construct these in our <code class="literal">getDropdown()</code> method:</p><div><pre class="programlisting">require([…, "esri/tasks/Query", "esri/tasks/QueryTask", …], 
  function (…, Query, QueryTask, …) {
    …
  queryDropdownData: function (args) {
    var queryTask = new QueryTask(/* url */),
        query = new Query();
  },
  …
});</pre></div><p>Now we need to define the parameters for both <code class="literal">QueryTask</code> and the query. For that, we'll use parameters passed through the <code class="literal">args</code> object. We can define an <code class="literal">args.url</code> to send a URL string to the <code class="literal">QueryTask</code>. We can also use <code class="literal">args.field</code> to set the field name for the data we want returned in the query object, and <code class="literal">args.where</code> to supply a <code class="literal">where</code> clause to filter the results. <code class="literal">queryDropdownData()</code> should now look like the following:</p><div><pre class="programlisting">queryDropdownData: function (args) {
  var queryTask = new QueryTask(args.url),
  query = new Query();
  query.returnGeometry = false;
  query.outFields = args.fields;
  query.orderByFields = args.fields;
  query.where = args.where;
  query.returnDistinctValues = true;

  return queryTask.execute(query); 
},</pre></div><p>For <a id="id612" class="indexterm"/>our <code class="literal">populateDropdown()</code> method, we'll take the jQuery-based selector and add the <code class="literal">featureSet</code> features that will be returned from the <code class="literal">queryDropdownData()</code> method. Remember that a <code class="literal">featureSet</code> contains a <code class="literal">features</code> parameter, which contains a list of graphic results. Out of the graphics returned, we're only interested in the attributes of the field returned. It should look as follows. We're going to use the jQuery <code class="literal">each()</code> function on the list of features to iterate through, create an option for each result, attach it to the selector, and fill it in with values. It should look like the following:</p><div><pre class="programlisting">_populateDropdown: function (args, featureSet) {
  args.selector.empty();
  $.each(featureSet.features, function () {
    args.selector.append($("&lt;option /&gt;")
      .val(this.attributes[args.fieldName])
      .text(this.attributes[args.fieldName])
      .attr("data-fips", this.attributes[args.fips]));
  });
},</pre></div></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec89"/>Other helper functions</h3></div></div></div><p>With the <a id="id613" class="indexterm"/>addition of <code class="literal">QueryTask</code>, we can now directly query the state, county, or block group we select from the drop-down menu. We need to define the function that will collect that information from the server. We can call the method in our widget <code class="literal">queryShapeAndData()</code>, and it will take a single <code class="literal">args</code> parameter with the data we need from it:</p><div><pre class="programlisting">queryShapeAndData: function (args) {
  var queryTask = new QueryTask(<strong>args.url</strong>),
    query = new Query();
  query.returnGeometry = true;
  query.outFields = ["*"];
  query.outSpatialReference = this.map.spatialReference;
  query.where = <strong>args.where</strong>;

  return queryTask.execute(query);
},</pre></div><p>While it is possible to add these graphics directly to the map, we should format the data so that it brings up an <code class="literal">infoWindow</code> as if we clicked it ourselves. For this, we'll add an <code class="literal">_onQueryComplete()</code> method. It will accept a <code class="literal">featureSet</code> returned from a <code class="literal">QueryTask</code>, and return a list of features with appropriate popup templates just like the ones we assign when we identify through clicks. Unfortunately, <code class="literal">featureSets</code> do not return the same descriptive information as <code class="literal">IdentifyResults</code>, so we will have to manually add the title of the feature for it to accurately pick the right <code class="literal">InfoTemplate</code>:</p><div><pre class="programlisting">_onQueryComplete: function (title, featureSet) {
  <strong>featureSet.features = arrayUtils.map(</strong>
<strong>    featureSet.features, </strong>
<strong>    lang.hitch(this, function (feature) {</strong>
<strong>      return this._processFeature(feature, title);</strong>
<strong>    }));</strong>
},</pre></div><p>Going back <a id="id614" class="indexterm"/>to the <code class="literal">queryShapeAndData()</code> method, we can add the <code class="literal">callback</code> function to the <code class="literal">execute</code> statement and have it return a processed result every time. The last part of <code class="literal">queryShapeAndData()</code>will look like the following:</p><div><pre class="programlisting">  …  
  return queryTask.execute(query)
    <strong>.addCallback(lang.hitch(</strong>
<strong>      this, this._onQueryComplete, args.title)</strong>
<strong>    );</strong>
},</pre></div><p>Finally, we need a way to show the queried graphics on the map. We'll create a method called <code class="literal">_updateInfoWindowFromQuery()</code> that takes a <code class="literal">featureSet</code>, zooms to its features, and adds the <code class="literal">infoWindow</code>. We're going to use the <code class="literal">esri/graphicsUtils</code> module to collect the overall extent of the graphics, so that we can zoom to it. Once the asynchronous zoom finishes, we'll set the graphic on the <code class="literal">infoWindow</code> and show it. You can see the code that does all this in the following:</p><div><pre class="programlisting">_updateInfoWindowFromQuery: function (results) {
  var resultExtent = graphicsUtils.graphicsExtent(results.features);

  this.map.setExtent(resultExtent)
    .then(lang.hitch(this, function () {
       this.map.infoWindow.setFeatures(results.features);
       this.map.infoWindow.show(resultExtent.getCenter());
     }));
},</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec99"/>Handling events</h2></div></div></div><p>Now, we will add <a id="id615" class="indexterm"/>event listeners to the <code class="literal">stateSelect</code>, <code class="literal">countySelect</code>, and <code class="literal">blockGroupSelect</code> items. We'll use the helper functions we developed in previous sections to populate the data, using some of our knowledge of <code class="literal">dojo/Deferred</code> to connect them asynchronously. Let's begin with the states.</p><p>When you select a <a id="id616" class="indexterm"/>state from the drop-down menu, the <code class="literal">select</code> element will fire a <code class="literal">change</code> event. We're not going to collect data on this event. Instead, we'll get data directly from the drop-down selectors and use that to generate the queries we need.</p><p>Let's go ahead and stub out the <code class="literal">_stateSelectChanged()</code> method in the <code class="literal">Census</code> widget. It takes no arguments. We'll do the same with the <code class="literal">_countySelectChanged()</code> and <code class="literal">_blockGroupSelectChanged()</code> methods as well. Then, using jQuery's <code class="literal">.on()</code> method, we'll listen for the <code class="literal">change</code> events in the <code class="literal">stateSelect</code>, <code class="literal">countySelect</code>, and <code class="literal">blockGroupSelect</code> controls. We'll use dojo's <code class="literal">lang.hitch()</code> method to make sure that, when we say <code class="literal">this</code>, we mean <code class="literal">this</code> widget. It should look like the following:</p><div><pre class="programlisting">postCreate: function () {
  this.stateSelect = $(".stateselect")
<strong>    .on("change", lang.hitch(this, this._stateSelectChanged));</strong>
  this.countySelect = $(".countyselect")
<strong>    .on("change", lang.hitch(this, this._countySelectChanged));</strong>
  this.blockGroupSelect = $(".blockgroupselect")
<strong>    .on("change",lang.hitch(this, this._blockGroupSelectChanged));</strong>
},
…
<strong>_stateSelectChanged: function () {},</strong>
<strong>_countySelectChanged: function () {},</strong>
<strong>_blockGroupSelectChanged: function () {},</strong>
…</pre></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec90"/>Handling the state</h3></div></div></div><p>In the <code class="literal">_stateSelectChanged()</code> method, we'll <a id="id617" class="indexterm"/>start by collecting the name of the state selected in <code class="literal">stateSelect</code>. If there is a value, we'll start by querying for the graphical data on that state. We'll use the <code class="literal">queryShapeAndData()</code> method to query for the shape data and process it. When that is complete, we can pass it along to the <code class="literal">_updateInfoWindowFromQuery()</code> method:</p><div><pre class="programlisting">_stateSelectChanged: function () {
  var stateName = this.stateSelect.val();
  if (value &amp;&amp; value.length &gt; 0) {
    this.queryShapeAndData({
      title: "states",
      url:  "http://sampleserver6.arcgisonline.com/arcgis/rest/services/Census/MapServer/3",
      where: "STATE_NAME = '" + stateName + "'"
    }).then(lang.hitch(this, this._updateInfoWindowFromQuery),
      function (err) { console.log(err); });
  }
},
…</pre></div><p>Now that we're <a id="id618" class="indexterm"/>showing the graphic, it's time to fill in the county name. We'll use the <code class="literal">queryDropdownData()</code> method to query for the list of counties, and using <code class="literal">.then()</code> asynchronously, pass the results to our <code class="literal">_populateDropdown()</code> method. We'll assign the county names first in the list of queried values, because we want them in alphabetical order. We'll tack that on at the end of the <code class="literal">_stateSelectChanged()</code> method, and it should appear like the following:</p><div><pre class="programlisting">…
// search for counties in that state.
this.queryDropdownData({
  url: "http://sampleserver6.arcgisonline.com/arcgis/rest/services/Census/MapServer/2",
  fields: ["NAME", "CNTY_FIPS"],
  where: "STATE_NAME = '" + stateName + "'",
}).then(lang.hitch(this, this._populateDropdown, {
  selector: this.countySelect,
  fieldName: "NAME",
  fips: "CNTY_FIPS"
}));
…</pre></div></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec91"/>How the counties differ</h3></div></div></div><p>The counties <a id="id619" class="indexterm"/>should load similarly to the states. The big issue is that we are required to query for the underlying block groups in a county with state and county FIPs codes. There are no state or county names available in the block group census data.</p><p>Since we assigned the FIP codes to the <code class="literal">data-fips</code> attributes of the drop-down options, there should be a way we can get them, right? Yes we can, but we'll have to take advantage of jQuery's chaining methods. From <code class="literal">stateSelect</code>, for instance, we can use the<code class="literal"> jQuery.find(":selected")</code> method to find the selected option inside the <code class="literal">select</code>. From there, we can call jQuery's <code class="literal">attr()</code> method to grab the <code class="literal">data-fips</code> attribute. For the state and county names and FIPs codes, it should look like the following:</p><div><pre class="programlisting">_countySelectChanged: function () {
  var stateName = this.stateSelect.val(),
    <strong>stateFIPS = this.stateSelect.find(":selected")</strong>
<strong>      .attr("data-fips"),</strong>
   countyName = this.countySelect.val(),
   <strong>countyFIPS = this.countySelect.find(":selected")</strong>
<strong>      .attr("data-fips");</strong>
…</pre></div><p>From here, we <a id="id620" class="indexterm"/>can use <code class="literal">stateName</code> and <code class="literal">countyName</code> to query for the correct county to show, and <code class="literal">stateFIPS</code> and <code class="literal">countyFIPS</code> to get the list of block groups. They'll use the same functions as the <code class="literal">_stateSelectChanged()</code> method, but with different map services and <code class="literal">where</code> clauses.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec92"/>Finally, the block groups</h3></div></div></div><p>The <code class="literal">_blockGroupSelectChanged()</code> method <a id="id621" class="indexterm"/>is much easier to write, because we're only interested in showing the block group. The key here is to collect the selected state FIP code, the selected county FIP code, and the <code class="literal">blockgroup</code> value from their respective dropdowns. Then we'll piece together the <code class="literal">where</code> clause on the query, and request the graphics for the map. The method should look like the following code:</p><div><pre class="programlisting">_blockGroupSelectChanged: function () {
  var stateFIPS = this.stateSelect.find(":selected").attr("data- fips"),
    countyFIPS = this.countySelect.find(":selected").attr("data- fips"),
    blockGroup = this.blockGroupSelect.val();
  this.queryShapeAndData({
     title: "Census Block Group",
     url: "http://sampleserver6.arcgisonline.com/arcgis/rest/services/Census/MapServer/1",
     where: "STATE_FIPS = '" + stateFIPS + "' AND CNTY_FIPS = '" + countyFIPS + "' AND BLKGRP = '" + blockGroup + "'"
  }).then(
    lang.hitch(this, this._updateInfoWindowFromQuery),
    function (err) { console.log(err); });
},</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec100"/>Filling in the states</h2></div></div></div><p>Now <a id="id622" class="indexterm"/>that the application is wired, we can finally load the state data from the map service. We'll start by querying the state layer for state names and state FIP codes. To get all the states, we'll use a little SQL trick. SQL will return all rows where the <code class="literal">where</code> clause is true, so if you want all the rows, you have to return something that's always true. In this case, we'll assign <code class="literal">1=1</code> to the where clause for <code class="literal">queryDropdownData()</code>, because it is always true that <code class="literal">1=1</code>.</p><p>Once we receive the query results from the server, we'll pass them to our <code class="literal">_populateDropdown()</code> method. We'll assign the options to the <code class="literal">stateSelect</code> drop-down, show the state names on each choice, and store the FIP codes in the options as well. We'll add the following snippet to the end of our <code class="literal">postCreate()</code> method:</p><div><pre class="programlisting">this.queryDropdownData({
  url: "http://sampleserver6.arcgisonline.com/arcgis/rest/services/Census/MapServer/3",
  fields: ["STATE_NAME", "STATE_FIPS"],
  where: "1=1",
}).then(lang.hitch(this, this._populateDropdown, {
  selector: this.stateSelect,
  fieldName: "STATE_NAME",
  fips: "STATE_FIPS"
}));</pre></div><p>So, if we've wired everything up correctly, we can view the site in the browser and open the <code class="literal">Census</code> widget. We should then see the states already loaded in the drop-down menu. You will have to select a state before the counties fill in, and select a county for the block groups.</p><p>Keep this project handy. We'll make copies of this one as a starting point for the other projects. Now let's try to build a Backbone app.</p></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec71"/>An overview of Backbone.js</h1></div></div></div><p>With a simple application like <a id="id623" class="indexterm"/>the one we wrote with jQuery, the logic can turn into spaghetti-code rather quickly. We need to implement good practices to organize our code. Which practices do we implement? One of the first libraries to try to answer this question is Backbone.js.</p><p>Backbone.js is one of the earliest JavaScript libraries to implement a <a id="id624" class="indexterm"/><strong>Model View Controller (MVC)</strong> architecture. MVC organizes code by separating data and business logic (the <code class="literal">Model</code>) from the output (the <code class="literal">View</code>) and updates both through a separate component (the <code class="literal">Controller</code>). With MVC, you don't write a complicated JavaScript function that gets input from some text blanks, adds the contents together, and saves the results. Those three actions can be written into three different functions, separated by what they do and how they fit into the <code class="literal">Model</code>, <code class="literal">View</code>, and <code class="literal">Controller</code> classifications.</p><p>Backbone.js <a id="id625" class="indexterm"/>requires a couple of other libraries in order to work properly. Backbone uses jQuery to handle DOM manipulation, including showing and hiding elements on the page. Backbone also requires another library called Underscore.js. This library provides a number of functions and shortcuts for dealing with JavaScript objects, arrays, and so forth. Underscore.js provides methods found in <code class="literal">dojo/_base/lang</code> and <code class="literal">dojo/_base/array</code>, as well as other methods that can help you pull out relevant data from your feature graphics.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec101"/>Components of Backbone</h2></div></div></div><p>Compared to <a id="id626" class="indexterm"/>most <a id="id627" class="indexterm"/>popular libraries and frameworks, Backbone.js is rather simple. It organizes your code into five categories: <code class="literal">Model</code>, <code class="literal">View</code>, <code class="literal">Collection</code>, <code class="literal">Event</code>, and <code class="literal">Router</code>. These work together to showcase your data and react to user input. All but the events are created through Backbone's <code class="literal">extend()</code> method, which contains a JavaScript object that defines the <code class="literal">Model</code>, <code class="literal">View</code>, <code class="literal">Collection</code>, or <code class="literal">Router</code>. Events, on the other hand, are defined through the creation of the other items. Let's review each item individually.</p><div><div><div><div><h3 class="title"><a id="ch07lvl3sec93"/>The Model</h3></div></div></div><p>Backbone.js' <code class="literal">Model</code> provides <a id="id628" class="indexterm"/>a description of the data you're going to use. You can assign default properties, methods, and events to the model that will be called by application features created in the other categories. Models are created through the <code class="literal">Backbone.Model.extend()</code> constructor method. Models created with this method become constructors for model data in your application. Data created through models have different methods to <code class="literal">get()</code> and <code class="literal">set()</code> data, test for the presence of data through <code class="literal">has()</code>, and even detect changes in the data through <code class="literal">isChanged()</code> or <code class="literal">changedAttributes()</code>.</p><p>Here's an example of a playing card model, as well as a card created using the model. The <code class="literal">CardModel</code> variable<a id="id629" class="indexterm"/> includes <code class="literal">rank</code> and <code class="literal">suit</code> properties, as well as a function to describe the card in a single string:</p><div><pre class="programlisting">var CardModel = Backbone.Model.extend({
  defaults: {
    "rank": "2",
    "suit": "heart"
  },
  description: function () {
    return this.rank + " of " + this.suit + "s";
  }
});
var myCard = new CardModel({rank: "9", suit: "spade"});
myCard.description(); // returns "9 of spades";</pre></div></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec94"/>The View</h3></div></div></div><p>The Backbone <code class="literal">View</code> <a id="id630" class="indexterm"/>sets up how the data will be presented in the application. The <code class="literal">View</code> defines the HTML output through a series of parameters defined in the <code class="literal">Backbone.View.extend()</code> constructor. You can create a view on a particular DOM element in your HTML by assigning the <code class="literal">.el</code> property in the <code class="literal">extend()</code> constructor method. You can also assign a <code class="literal">tagName</code> property to define the HTML element that is created, a <code class="literal">template</code> property if the content is more complicated than a single element, and even a <code class="literal">className</code> property to assign a CSS class to the main element.</p><p>The view makes heavy use of both jQuery and Underscore.js. For example, while the element of the view is defined by the view's <code class="literal">.el</code> property, a jQuery version is available by referring to the Views <code class="literal">$el</code> property. Also, HTML content can be defined through the view's template, which is created through Underscore's <code class="literal">.template()</code> creator.</p><p>When a view is first created, it starts with a method called <code class="literal">initialize()</code> that you define. In the <code class="literal">initialize()</code> method, you can assign event listeners to other parts of the view, including models and collections. You can also tell the view to <code class="literal">render()</code>, or write out the HTML code. The <code class="literal">render()</code> method that you define is used to add the custom HTML within the <code class="literal">View</code> element. You can also render other views within the <code class="literal">View</code>.</p><p>In the following code, you can <a id="id631" class="indexterm"/>find a sample <code class="literal">View</code> to show a card:</p><div><pre class="programlisting">var CardView = Backbone.View.extend({
  tagName: "li"
  className: "card"
  template: _.template("&lt;%= description %&gt; &lt;button&gt;Discard&lt;/button&gt;"),
  initialize: function () {
    this.render();
  }
  render: function () {
    this.$el.html(
      this.template(this.model.toJSON())
    );
  }
});</pre></div></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec95"/>The Collection</h3></div></div></div><p>If a <code class="literal">Backbone</code> model <a id="id632" class="indexterm"/>describes one piece of data, how do you describe a list of them? That's where a <code class="literal">Collection</code> comes in. A collection represents a list of data items of a particular model. As is probably no surprise, a <code class="literal">Collection</code> constructor can be created using the <code class="literal">Backbone.Collection.extend()</code> method.</p><p>Collections offer a number of methods for managing the content of your list. You can <code class="literal">.add()</code> or <code class="literal">.remove()</code> model-defined items from your collection list, as well as <code class="literal">.reset()</code> the entire list to whatever you pass as a parameter. You can define a <code class="literal">url</code> parameter as a JSON data source, and <code class="literal">.fetch()</code> the data.</p><p>In the following code, you can see how a <code class="literal">Collection</code> is created using a deck of cards. It is based on the <code class="literal">CardModel</code> defined in the model:</p><div><pre class="programlisting">Var CardCollection = Backbone.Collection.extend({
  model: CardModel,
  url: "http://cardjson.com", // made up for this example
  deal: function () {
    return this.shift();
  }
});
var deck = new CardCollection();
deck.fetch(); //load cards from website if it existed.</pre></div></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec96"/>Implementing a router</h3></div></div></div><p>Backbone <a id="id633" class="indexterm"/>routers help define the state of the application through the URL. They respond to changes in the URL hash, or the text following the <code class="literal">#</code> symbol in the URL. The hash was originally created in web pages to allow you to click an anchor tag to move down the page to related content, without reloading the entire page. When a <code class="literal">Backbone</code> router is enabled, you can change the hash, say, through a button or anchor click, and it will run some JavaScript code in response to the content. All this happens, and the page doesn't reload.</p><p>This lack of page reloads when the router changes makes single-page applications possible. Instead of loading new pages, Backbone can simply show different views in response to the router. This gives a snappier response on the page.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec97"/>Handling events</h3></div></div></div><p>Events are defined <a id="id634" class="indexterm"/>within the other items created by Backbone. Event listeners are attached to elements of the <code class="literal">Model</code>, <code class="literal">View</code>, <code class="literal">Collection</code>, or <code class="literal">Router</code>, by way of the <code class="literal">on()</code> method. The <code class="literal">on()</code> method takes three parameters, a string containing the name of the event, the function that is to be called when the event occurs, and the context that defines what <code class="literal">this</code> is.</p><p>Events within HTML elements created by the view are defined in a different way. The <code class="literal">Backbone.View.extend()</code> constructor contains an <code class="literal">events</code> parameter that is defined by an unusually formatted JSON object. Event names, and jQuery selectors for the elements, are used as the key, and a string containing the name of the function called in the view makes up the key value. Example events might look like the following:</p><div><pre class="programlisting">…
events: {
  "keypress input": "stopOnEnter",
  "click #mybutton": "itsMine",
  "focus .tinything": "bigScare",
  "blur .tinything": "makeSmallAgain"
}
…</pre></div></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec72"/>Putting some Backbone in your app</h1></div></div></div><p>Since <a id="id635" class="indexterm"/>Backbone uses jQuery under the hood to work with the DOM, we can reuse much of the code from our jQuery application. We'll be using the same ArcGIS JavaScript API modules to interact with the map services. We'll only change how the drop-down options are rendered and how the change events on those dropdowns are handled. So, let's start by making a copy of our jQuery application and naming the folder <code class="literal">Backbone</code>.</p><p>Next, we'll need to add references to the Backbone and Underscore libraries in our <code class="literal">dojoConfig</code>, so that they are available through AMD. We'll load them from a CDN source for this application, although you're free to download them into folders for your own applications:</p><div><pre class="programlisting">dojoConfig = {
  async: true,
  packages: [
    …
    {
      name: "jquery",
      location: "http://ajax.googleapis.com/ajax/libs/jquery/1.11.2",
      main: "jquery"
    },<strong> {</strong>
<strong>      name: "underscore",</strong>
<strong>      location: "http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.7.0",</strong>
<strong>      main: "underscore"</strong>
<strong>    }, {</strong>
<strong>      name: "backbone",</strong>
<strong>      location: "http://cdnjs.cloudflare.com/ajax/libs/backbone.js/1.1.2",</strong>
<strong>      main: "backbone"</strong>
<strong>    }</strong>
  ]
};</pre></div><p>After that, we'll make reference to the jQuery, Underscore, and Backbone libraries in our <code class="literal">define</code> statement in <a id="id636" class="indexterm"/>the <code class="literal">Census.js</code> file. The files should load in as so:</p><div><pre class="programlisting">define([…, "d3/d3", <strong>"jquery", "underscore", "backbone"</strong>], 
  function (…, <strong>d3, $, _, Backbone</strong>), {
    …
});</pre></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec102"/>Defining the models</h2></div></div></div><p>Now, we have the <a id="id637" class="indexterm"/>opportunity to define the data models that we'll be working with. If you remember from the jQuery exercise, we were primarily interested in the names and the FIP codes for the census locations. In the <code class="literal">postCreate()</code> method of the census widget, we'll define our models using default values from those fields:</p><div><pre class="programlisting">postCreate: function () {
  …
  // Backbone Models
  var State = Backbone.Model.extend({
  defaults: {
    "STATE_NAME": "",
    "STATE_FIPS": ""
  }
  });

  var County = Backbone.Model.extend({
  defaults: {
    "STATE_NAME": "",
    "STATE_FIPS": "",
    "NAME": "",
    "CNTY_FIPS": ""
  }
  });

  var BlockGroup = Backbone.Model.extend({
  defaults: {
    "BLKGRP": "0"
  }
  });
},</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec103"/>Defining the collections</h2></div></div></div><p>For the state, county, and <a id="id638" class="indexterm"/>block group collections, we'll simply define them based on the corresponding models we defined previously. We'll then create collection objects that are tied to the Dojo <code class="literal">dijit</code>. It should look like the following:</p><div><pre class="programlisting">postCreate: function () {

  // Backbone Collections
  var StateCollection = Backbone.Collection.extend({
    model: State
  });
  var CountyCollection = Backbone.Collection.extend({
    model: County
  });
  var BlockGroupCollection = Backbone.Collection.extend({
    model: BlockGroup
  });

  this.stateCollection = new StateCollection([]);
  this.countyCollection = new CountyCollection([]);
  this.blockGroupCollection = new BlockGroupCollection([]);
},</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec104"/>Defining the views</h2></div></div></div><p>Now that we've defined <a id="id639" class="indexterm"/>our models and collections, it's time to create a view for them. Our view should create the options with the data that we need in our application. We'll need to create a separate view for each of the dropdowns, since assigning templates when the view is created causes errors with this version of the Backbone.</p><p>Let's start with the <code class="literal">StateView</code> variable. The <code class="literal">StateView</code> variable will be created through <code class="literal">Backbone.View.extend</code>. In the <code class="literal">StateView</code> variable, we want to define a template, an <code class="literal">initialize()</code> method, and a <code class="literal">render()</code> method. The <code class="literal">initialize()</code> method will listen for the collection's <code class="literal">reset</code> event, and cause it to <code class="literal">render()</code> again. The template is defined by Underscore's <code class="literal">_.template</code> function called on an HTML string pulled up by jQuery. The jQuery selector will look for our state option template by looking for an element with the ID of <code class="literal">stateitemtemplate</code>:</p><div><pre class="programlisting">// Backbone Views
var StateView = Backbone.View.extend({
  initialize: function () {
   this.collection.on("reset", this.render, this);
  },
  template: _.template( $("#stateitemtemplate").html()),
  render: function () {
    // compile the template using underscore
    var template = this.template,
      el = this.$el.empty();
    // load the compiled HTML into the Backbone "el"ement
    _.each(this.collection.models, function (item) {
       el.append(template(item.toJSON()));
      });
  }
});</pre></div><p>In the preceding view, the <a id="id640" class="indexterm"/><code class="literal">render</code> function does two things. First, it loads the view template and the empty jQuery selection object into variables. Next, it iterates over each of the collection models using Underscore's <code class="literal">each()</code> method, fills in the template with the JSON content from the model, and appends it inside the <code class="literal">select</code> element. Some other Backbone examples would stop the option creation from appending the options to the <code class="literal">select</code> element in a separate view, but this method was chosen for compact purposes.</p><p>Now that the <code class="literal">StateView</code> is defined, you can copy and paste the code and tweak it to create separate <code class="literal">CountyView</code> and <code class="literal">BlockGroupView</code> constructors. In each of those, the only thing you need to change is the template jQuery selector, to <code class="literal">#countyitemtemplate</code> and <code class="literal">#blkgrpitemtemplate</code>, respectively. Keep the <code class="literal">initialize()</code> and <code class="literal">render()</code> methods the same:</p><div><pre class="programlisting">…
var CountyView = Backbone.View.extend({
  …
  template: _.template( $("#countyitemtemplate").html()),
  …
});

var BlockGroupView = Backbone.View.extend({
  …
  template: _.template( $("#blkgrpitemtemplate").html()), 
  …
});</pre></div><p>Finally, we'll assign our actual view properties to these <code class="literal">View</code> constructors. With each view, we'll assign the element they'll be rendered from, which are the <code class="literal">select</code> elements in our widget and the <a id="id641" class="indexterm"/>collections they will be using:</p><div><pre class="programlisting">this.stateView = new StateView({
  el: $(".stateselect"),
  collection: this.stateCollection
});

this.countyView = new CountyView({
  el: $(".countyselect"),
  collection: this.countyCollection
});

this.blockGroupView = new BlockGroupView({
  el: $(".blockgroupselect"),
  collection: this.blockGroupCollection
});</pre></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec98"/>Creating templates</h3></div></div></div><p>Thinking <a id="id642" class="indexterm"/>back to the jQuery app, we filled in the select dropdowns with options tags that contained data on both the name of the feature and a FIP code with which we could query the next level down. We need to create the same HTML elements in HTML templates rather than piecing them together through code. We'll do this by adding HTML templates to our main page.</p><p>How do we create HTML templates that aren't visible on the page? We can do this by inserting them into script tags. We'll give each template script tag a type of <code class="literal">text/template</code>. This lets us know that the content of the script is actually HTML code. Browsers will look at the type, not know what to do with a <code class="literal">text/template</code> type, and simply ignore it.</p><p>So, let's create templates for the state options, county options, and block group options. We'll assign the templates IDs of <code class="literal">stateitemtemplate</code>, <code class="literal">countyitemtemplate</code>, and <code class="literal">blkgrpitemtemplate</code>, as we added in our code. In each template, we'll assign the value, text, and <code class="literal">data-fips</code> value to the appropriate item in the model. Take a look at the following templates:</p><div><pre class="programlisting">&lt;script type="text/template" id="<strong>stateitemtemplate</strong>"&gt;
  &lt;option value="<strong>&lt;%= STATE_NAME %&gt;</strong>" data-fips="<strong>&lt;%= STATE_FIPS %&gt;</strong>"&gt;
    <strong>&lt;%= STATE_NAME %&gt;</strong>
  &lt;/option&gt;
&lt;/script&gt;
&lt;script type="text/template" id="<strong>countyitemtemplate</strong>"&gt;
  &lt;option value="<strong>&lt;%= NAME %&gt;</strong>" data-fips="<strong>&lt;%= CNTY_FIPS %&gt;</strong>"&gt;
    <strong>&lt;%= NAME %&gt;</strong>
  &lt;/option&gt;
&lt;/script&gt;
&lt;script type="text/template" id="<strong>blkgrpitemtemplate</strong>"&gt;
  &lt;option value="<strong>&lt;%= BLKGRP %&gt;</strong>" data-fips="<strong>&lt;%= BLKGRP %&gt;</strong>"&gt;
    <strong>&lt;%= BLKGRP %&gt;</strong>
  &lt;/option&gt;
&lt;/script&gt;</pre></div><p>Depending on <a id="id643" class="indexterm"/>the template library you use, different libraries have different ways to assign values. Underscore's <code class="literal">template()</code> method wraps the attribute names in <code class="literal">&lt;%= %&gt;</code> tags. You can use other template libraries, such as Handlebars.js, but, since Underscore is required, why not use what we have?</p></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec105"/>Wiring events</h2></div></div></div><p>Now let's make <a id="id644" class="indexterm"/>things happen. We're going to reuse the event listeners we created for the jQuery exercise, and make them work for Backbone. We'll start by looking at the <code class="literal">_stateSelectChanged()</code> method.</p><p>The first thing that changes is how we collect <code class="literal">stateName</code> and <code class="literal">stateFIPS</code>. Instead of referring the <code class="literal">stateSelect</code> that was previously defined as a jQuery object, we'll access the <code class="literal">select</code> through the <code class="literal">stateView.$el</code> property. Remember that, in a <code class="literal">View</code>, the <code class="literal">el</code> property exposes the DOM element, while the <code class="literal">$el</code> property exposes the jQuery element. For the other selection change listeners, we can find and replace <code class="literal">countySelect</code> and <code class="literal">blockGroupSelect</code> with <code class="literal">countyView.$el</code> and <code class="literal">blockGroupView.$el</code>, respectively.</p><p>The only other part that needs changing is how the new drop-down data is populated after it is queried form the map service. We can replace the <code class="literal">_populateDropdown()</code> method with a simple anonymous function. In the anonymous function, we'll create a list of feature attributes from the <code class="literal">featureSet</code> using Underscore's <code class="literal">pluck()</code> method. It goes item by item through an array, and grabs the property of the item you describe and puts that in a new list. Next, we'll assign that list to the <code class="literal">countyCollection</code> through its <code class="literal">reset()</code> method. That's all that is needed to update the county list. The same process can be performed on the <code class="literal">_countySelectChanged()</code> method to repopulate the block groups. Your code changes should look like the following:</p><div><pre class="programlisting">_stateSelectChanged: function () {
  <strong>var stateName = this.stateView.$el.val();</strong>
  …
  This.queryDropdownData({
    …
  }).then(lang.hitch(this, <strong>function (featureSet) {</strong>
<strong>    this.countyCollection.reset(</strong>
<strong>      _.pluck(featureSet.features, "attributes")</strong>
<strong>    );</strong>
<strong>  }</strong>);
}, 

_countySelectChanged: function () {
  var stateValue = this.stateView.$el.val(),
    stateFIPS = this.stateView.$el.find(":selected")
      .attr("data-fips"),
    countyValue = this.countyView.$el.val(),
    countyFIPS = this.countyView.$el.find(":selected")
      .attr("data-fips");
  …
  This.queryDropdownData({
    …
  }).then(lang.hitch(this, <strong>function (featureSet) {</strong>
<strong>    this.blockGroupCollection.reset(</strong>
<strong>      _.pluck(featureSet.features, "attributes")</strong>
<strong>    );</strong>
<strong>  }</strong>);
},

_blockGroupSelectChanged: function () {
  var stateFIPS = this.stateView.$el.find(":selected")
      .attr("data-fips"),
    countyFIPS = this.countyView.$el.find(":selected")
      .attr("data-fips"),
    blockGroup = this.blockGroupView.$el.val();
…
},</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec106"/>Getting the Backbone to dance</h2></div></div></div><p>Finally, we need to <a id="id645" class="indexterm"/>populate the initial value of <code class="literal">stateView</code>. We'll use the <code class="literal">queryDropdownData()</code> method call at the end of jQuery's <code class="literal">postCreate()</code>. If we make the same changes to this call that we made to the event listeners, we should be able to populate the state drop-down menu. From there, we should be able to populate the other menus through the event listeners we assigned to the <code class="literal">View</code> elements:</p><div><pre class="programlisting">postCreate: function () {
  …
  this.queryDropdownData({
    url: "http://sampleserver6.arcgisonline.com/arcgis/rest/services/Census/MapServer/3",
    fields: ["STATE_NAME", "STATE_FIPS"],
    where: "1=1",
  }).then(lang.hitch(this, <strong>function (featureSet) {</strong>
<strong>    this.stateCollection.reset(</strong>
<strong>        _.pluck(featureSet.features, "attributes")</strong>
<strong>     );</strong>
<strong>  })</strong>);</pre></div><div><div><h3 class="title"><a id="note16"/>Note</h3><p>If you want to learn more about implementing ArcGIS JavaScript APIs using Backbone.js and Marionette, you can review the blog posts by Dave Bouwman on the matter at <a class="ulink" href="http://blog.davebouwman.com/2013/02/20/part-1-app-design-and-page-layout/">http://blog.davebouwman.com/2013/02/20/part-1-app-design-and-page-layout/</a>. For more information on Backbone.js, you can read <em>Backbone.js Patterns and Best Practices</em> by Swarnendu De.</p></div></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec73"/>An overview of Knockout.js</h1></div></div></div><p>Another <a id="id646" class="indexterm"/>JavaScript library that can be used to create an interactive single page application is Knockout.js. Knockout was developed by Steve Sanderson of Microsoft, though it's not considered a Microsoft product. It's based on Windows Presentation Framework in that it uses the <a id="id647" class="indexterm"/><strong>Model-View-ViewModel (MVVM)</strong> architecture and allows two-way binding on observed properties. Two-way binding means that data isn't just written to an HTML element, but it can also be updated, like a text input field in a form, and the data will be already reflected in the application.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec107"/>Knockout and MVVM</h2></div></div></div><p>The MVVM is similar<a id="id648" class="indexterm"/> in nature to MVC architecture. Both use a model to get to the data, and a <code class="literal">View</code> to show the data. However, instead of an active controller directing the model and views, the <code class="literal">ViewModel</code> sits under the UI layer and exposes functions and data from the model to the <code class="literal">View</code>. The <code class="literal">ViewModel</code> typically knows nothing about the <code class="literal">View</code> it's working with. It simply stores and provides information as requested by the HTML <code class="literal">View</code>.</p><p>In Knockout, the <code class="literal">ViewModel</code> is created like any normal JavaScript object, with a few additions from Knockout. Properties of the <code class="literal">ViewModel</code> that are used in two-way binding are created using Knockout's <code class="literal">observable()</code> and <code class="literal">observableArray()</code> constructors. This allows these properties to be accessed by the <code class="literal">View</code>, and updated without having to update the DOM, as you would have to in jQuery. A constructor looks something like the following:</p><div><pre class="programlisting">// note that ko is the global library object for knockout.js
function PersonViewModel (firstName, lastName) {
  this.firstName = <strong>ko.observable(firstName);</strong>
  this.lastName = <strong>ko.observable(lastName);</strong>
}</pre></div><p>The HTML document acts as a <code class="literal">View</code>, and can be bound to the <code class="literal">ViewModel</code> through the HTML5-based <code class="literal">data-*</code> attributes (more specifically, the <code class="literal">data-bind</code> attribute). When the browser loads an HTML view and a script containing the <code class="literal">ViewModel</code>, the Knockout will bind attributes in the data-bind tags to the appropriate fields in the <code class="literal">ViewModel</code>. For the preceding <code class="literal">ViewModel</code> created, you might see some HTML like the following:</p><div><pre class="programlisting">&lt;div&gt;
  &lt;label for='fninput'&gt;First Name:&lt;/label&gt;
  &lt;input type='text' id='fninput' data-bind='value:firstName' /&gt;
  &lt;br /&gt;
  &lt;label for='lninput'&gt;Last Name:&lt;/label&gt;
  &lt;input type='text' id='lninput' data-bind='value:lastName'/&gt;
  &lt;br /&gt;
  &lt;p&gt;
    Hello, 
    &lt;span data-bind='text: firstName'&gt;&lt;/span&gt;&amp;nbsp;
    &lt;span data-bind='text: lastName&gt;&lt;/span&gt;!
  &lt;/p&gt;
&lt;/div&gt;</pre></div><p>In the <code class="literal">ViewModel</code>, properties can be added that are computed values based on other observables in the <code class="literal">ViewModel</code>. These are created with the <code class="literal">ko.computed()</code> constructor. For example, we can take the <code class="literal">PersonViewModel</code> in the preceding code and add a computed <code class="literal">fullName</code> property that automatically updates when the first or last name changes:</p><div><pre class="programlisting">function PersonViewModel (firstName, lastName) {
  this.firstName = ko.observable(firstName);
  this.lastName = ko.observable(lastName);
<strong>  this.fullName = ko.computed(function () {</strong>
<strong>    return this.firstName() + " " + this.lastName();</strong>
<strong>  }, this);</strong>
}</pre></div><p>Knockout <a id="id649" class="indexterm"/>doesn't have many extra features that other libraries and frameworks possess, such as routers and AJAX requests. It typically relies on other libraries, such as <code class="literal">Sammy.js</code> for routing and jQuery for AJAX. However, what it does offer is two-way binding that works even in older browsers.</p></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec74"/>Using Knockout in our app</h1></div></div></div><p>Let's make <a id="id650" class="indexterm"/>another copy of our jQuery app and name the folder <code class="literal">Knockout</code>. We will not need jQuery for this application, since we can use Knockout and the ArcGIS JavaScript API to handle those functions. We'll start by replacing all the references to jQuery with Knockout references. The <code class="literal">dojoConfig</code> script at the head of the document should look like the following:</p><div><pre class="programlisting">dojoConfig = {
  async: true,
  packages: [
    {
      name: 'y2k',
      location: location.pathname.replace(/\/[^\/]*$/, '') + '/js'
   }, {
      name: "d3",
      location: "http://cdnjs.cloudflare.com/ajax/libs/d3/3.4.12/"
    }, {
     name: "knockout",
     location: "http://cdnjs.cloudflare.com/ajax/libs/knockout/3.2.0",
     main: "knockout-min"
   }
  ]
};</pre></div><p>Next, we'll add a reference to Knockout in our <code class="literal">Census.js</code> file. We'll keep the other AMD modules and code, and <a id="id651" class="indexterm"/>we'll replace things as we go. The <code class="literal">define()</code> statement at the top of <code class="literal">Census.js</code> should look a bit like the following:</p><div><pre class="programlisting">define([…, "d3/d3", "knockout"], function (…, d3, ko) {
  …
});</pre></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec108"/>Defining the ViewModel</h2></div></div></div><p>We know what <a id="id652" class="indexterm"/>kind of data model we're dealing with, but what we need is a <code class="literal">ViewModel</code> to organize it. We can create the <code class="literal">ViewModel</code> constructor in our <code class="literal">Census</code> dijit, and expose it for use by our widget.</p><p>Our <code class="literal">ViewModel</code> for this widget only requires six items. We need to maintain the lists of states, counties, and block groups, to populate the <code class="literal">select</code> elements, as well as the selected values. For the <code class="literal">stateList</code>, <code class="literal">countyList</code>, and <code class="literal">blockGroupList</code> properties of the <code class="literal">ViewModel</code>, we'll construct Knockout's <code class="literal">observableArrays</code> for each. <code class="literal">selectedState</code>, <code class="literal">selectedCounty</code>, and <code class="literal">selectedBlockGroup</code> will each be created using Knockout observables. You can see how we construct the <code class="literal">ViewModel</code> in the widget in the following example:</p><div><pre class="programlisting">…
SelectorViewModel: function () {
  this.stateList = ko.observableArray([]);
  this.selectedState = ko.observable();
  this.countyList = ko.observableArray([]);
  this.selectedCounty = ko.observable();
  this.blockGroupList = ko.observableArray([]);
  this.selectedBlockGroup = ko.observable();
},
…</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec109"/>Adding custom binding handlers</h2></div></div></div><p>In our jQuery <a id="id653" class="indexterm"/>and Backbone applications, we attached event listeners to the <code class="literal">select</code> elements so that, when they change, we can query for census data and populate the next select down. In Knockout, we can do the same thing using custom binding handlers. Binding handlers have two optional methods: <code class="literal">init()</code> and <code class="literal">update()</code>. The <code class="literal">init()</code> method runs when binding first occurs, while the <code class="literal">update()</code> method runs every time the bound value changes. Both <code class="literal">init()</code> and <code class="literal">update()</code> have five arguments, as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">element</code>: The HTML DOM element involved in the binding.</li><li class="listitem" style="list-style-type: disc"><code class="literal">valueAccessor</code>: A function that gives access to the observable property bound to the element. To get the value of this property, call the <code class="literal">ko.unwrap()</code> method on the value returned from <code class="literal">ValueAccessor()</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">allBindings</code>: An object used to get the particular bindings to the element, like the text, value, or name. Binding properties can be retrieved using <code class="literal">allBindings.get()</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">viewModel</code>: This was the old way to get at the entire <code class="literal">ViewModel</code>, prior to version 3.x.</li><li class="listitem" style="list-style-type: disc"><code class="literal">bindingContext</code>: This is the way to get to all the bindings. <code class="literal">bindingContext</code> may have at least some of the following:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">$data</code>: The current <code class="literal">ViewModel</code> assigned to this element</li><li class="listitem" style="list-style-type: disc"><code class="literal">$rawData</code>: Direct access to the values held in the <code class="literal">ViewModel</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">$parent</code>: Access to the parent <code class="literal">ViewModel</code> this <code class="literal">ViewModel</code> may be assigned to</li><li class="listitem" style="list-style-type: disc"><code class="literal">$parents</code>: An array object providing access to each tier of <code class="literal">ViewModel</code> connected to this <code class="literal">ViewModel</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">$root</code>: This grants direct access to the base <code class="literal">ViewModel</code>, originally bound to the entire page</li></ul></div></li></ul></div><p>We need to create the binding handlers before we apply bindings to the page. While we can create the binding handlers earlier, we're going to assign them in the <code class="literal">postCreate()</code> method of our widget, since that's where we've applied the changes in our other applications. We'll start by creating some empty binding handlers for <code class="literal">stateUpdate</code>, <code class="literal">countyUpdate</code>, and <code class="literal">blockGroupUpdate</code>. We're only interested in the <code class="literal">update()</code> methods, so we'll leave the <code class="literal">init()</code> method out. The following code is the empty version of <code class="literal">stateUpdate</code>:</p><div><pre class="programlisting">…
postCreate: function () {
  <strong>ko.bindingHandlers.stateUpdate = {</strong>
<strong>    update: function (</strong>
<strong>      element, valueAccessor, allBindings, viewModel, bindingAccessor</strong>
<strong>    ) {</strong>
<strong>      // content will come here shortly.</strong>
<strong>    }</strong>
<strong>  };</strong>

},
…</pre></div><p>Within the <a id="id654" class="indexterm"/>binding handlers, and the subsequent calls to the ArcGIS JavaScript API modules, the widget scope is going to get lost. In the <code class="literal">postCreate()</code> method, we'll create a variable named <code class="literal">self</code>, and assign a reference to the widget to it, like so:</p><div><pre class="programlisting">postCreate: function () {
<strong>  var self = this;</strong>
  ko.bindingHandlers.stateUpdate = {…};
…
},</pre></div><p>With the binding handlers set, we'll bring our code over from our previous event handlers. From _<code class="literal">stateSelectChanged()</code>, we'll copy over the code and make our changes. First, we'll change how the functions collect the state names and census FIP codes for the queries. Once we have the names, getting the visual data will be easy. Finally, we'll change how the <code class="literal">ViewModel</code> is updated once the query for the counties in the state is finished. The <code class="literal">stateUpdate</code> binding handler should look like the following:</p><div><pre class="programlisting">… 
// within the postCreate() method.
var self = this;

ko.bindingHandlers.stateUpdate = {
  update: function (
    element, valueAccessor, allBindings, viewModel, 
    bindingAccessor
  ) {
    <strong>// retrieve the selected state data.</strong>
<strong>    var stateData = ko.unwrap(valueAccessor()),</strong>
      stateName, stateFIPS;

      // if stateData is valid and has a state name…
    if (stateData &amp;&amp; stateData.STATE_NAME) {
       // assign state name and FIPS code.
      <strong>stateName = stateData.STATE_NAME;</strong>
<strong>      stateFIPS = stateData.STATE_FIPS;</strong>

       // query for shape and attributes to show on the map.
       // Replace all "this" references with "self" variable.
       <strong>self</strong>.queryShapeAndData({
         url: "http://sampleserver6.arcgisonline.com/arcgis/rest/services/Census/MapServer/3",
         where: "STATE_NAME = '" + stateName + "'"
       }).then(
         lang.hitch(self, self._updateInfoWindowFromQuery),
         function (err) { console.log(err); });

      // search for counties in that state.
      self.queryDropdownData({
        url: "http://sampleserver6.arcgisonline.com/arcgis/rest/services/Census/MapServer/2",
        fields: ["NAME","STATE_NAME","CNTY_FIPS","STATE_FIPS"],
        where: "STATE_NAME = '" + stateName + "'",
      }).then(function (featureSet) {

         // create an array of county data attributes
         <strong>var theCounties = arrayUtils.map(</strong>
<strong>           featureSet.features, </strong>
<strong>           function (feature) {</strong>
<strong>             return feature.attributes;</strong>
<strong>           });</strong>

        // insert a blank value in the beginning of the array.
        <strong>theCounties.splice(0, 0, {</strong>
<strong>            NAME:"",STATE_NAME:"",CNTY_FIPS:"",STATE_FIPS:""});</strong>

         // assign the list to the countyList in the ViewModel
         <strong>bindingContext.$data.countyList(theCounties);</strong>
       });
    }
  }
 };</pre></div><p>For the county and the block groups, we'll follow similar patterns in <code class="literal">countyUpdate</code> and <code class="literal">blockGroupUpdate</code>. Remember <a id="id655" class="indexterm"/>the following changes for this app:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Replacing references to <code class="literal">this</code> with the variable <code class="literal">self</code></li><li class="listitem" style="list-style-type: disc">Get county and block group feature attribute data from <code class="literal">ko.unwrap(valueAccessor())</code></li><li class="listitem" style="list-style-type: disc">Collect the list of feature attributes for the drop-down list using the <code class="literal">Dojo</code> module method <code class="literal">arrayUtils.map()</code></li><li class="listitem" style="list-style-type: disc">Add an attribute with blank values to the first feature of the feature attributes list</li><li class="listitem" style="list-style-type: disc">Add the new list to the <code class="literal">bindingContext.$data</code> array</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec110"/>Defining the View</h2></div></div></div><p>Now that we've <a id="id656" class="indexterm"/>done all the hard work setting up the <code class="literal">ViewModel</code> and the related functionality, let's work with some HTML. Open the <code class="literal">Census.html</code> template in the <code class="literal">js/template/</code> folder. This is where we are going to apply our <code class="literal">View</code>. Start by removing the class assignments on the three <code class="literal">select</code> elements, and replace them with the text <code class="literal">data-bind=""</code>.</p><p>Next, we're going to assign four properties within each data-bind context: <code class="literal">options</code>, <code class="literal">optionsText</code>, <code class="literal">value</code>, and the appropriate binding handler we created in the previous section. The options will be assigned to the appropriate <code class="literal">observableArray</code> list. The <code class="literal">optionsText</code> will be the field name that we want to see on the options. Both the value and the binding handler we created will be bound to the selected observable for that type. The <code class="literal">Census.html</code> file should look like the following:</p><div><pre class="programlisting">…
&lt;div &gt;
  &lt;b&gt;State Selector: &lt;/b&gt;
  &lt;select data-bind="<strong>options: stateList,</strong>
<strong>                      optionsText: 'STATE_NAME',</strong>
<strong>                      value: selectedState,</strong>
<strong>                      stateUpdate: selectedState</strong>"&gt;&lt;/select&gt;
&lt;/div&gt;
&lt;div&gt;
  &lt;b&gt;County Selector: &lt;/b&gt;
  &lt;select data-bind="<strong>options: countyList,</strong>
<strong>                      optionsText: 'NAME',</strong>
<strong>                      value: selectedCounty,</strong>
<strong>                      countyUpdate: selectedCounty</strong>"&gt;&lt;/select&gt;
&lt;/div&gt;
&lt;div&gt;
  &lt;b&gt;Block Group Selector: &lt;/b&gt;
  &lt;select data-bind="<strong>options: blockGroupList,</strong>
<strong>                      optionsText: 'BLKGRP',</strong>
<strong>                      value: selectedBlockGroup,</strong>
<strong>                      blockGroupUpdate: selectedBlockGroup</strong>"&gt;&lt;/select&gt;
&lt;/div&gt;
…</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec111"/>Applying the ViewModel</h2></div></div></div><p>Now that we have <a id="id657" class="indexterm"/>a working <code class="literal">View</code> and <code class="literal">ViewModel</code>, and the code that links it to our <code class="literal">Model</code>, it's time to put it all together. Once the page has loaded in the <code class="literal">postCreate()</code> method, and all our binding handlers have been assigned, it's safe to call <code class="literal">ko.applyBindings()</code> to the <code class="literal">ViewModel</code>. In most examples that you see online, the <code class="literal">ViewModel</code> is bound as follows:</p><div><pre class="programlisting">ko.applyBindings(new ViewModel());</pre></div><p>It would be great to finish with that and call it a day, but we don't have any state data to start out the <code class="literal">SelectViewModel</code>. We're going to have it assign it some way. We're going to take some code from the jQuery and Backbone code to assign the initial values to the state dropdowns. We'll then modify it to fit the pattern we established for assigning the other dropdowns. We'll query for a list of states, and add the list to our working <code class="literal">ViewModel</code>, like so:</p><div><pre class="programlisting">…
var viewModel = new this.SelectorViewModel();
ko.applyBindings(viewModel);

this.queryDropdownData({
  url: "http://sampleserver6.arcgisonline.com/arcgis/rest/services/Census/MapServer/3",
  fields: ["STATE_NAME", "STATE_FIPS"],
  where: "1=1",
}).then(function (featureSet) {
  // make a list of the feature attributes of the states
  var theStates = arrayUtils.map(
    featureSet.features, 
    function (feature) { return feature.attributes; });
  // add in a blank value to the beginning of the list
<strong>  theStates.splice(0, 0, {STATE_NAME: "", STATE_FIPS: ""});</strong>
  // apply the list of states to our viewModel
  <strong>viewModel.stateList(theStates);</strong>

});</pre></div><div><div><h3 class="title"><a id="note17"/>Note</h3><p>For more information on KnockoutJS, you can visit <a class="ulink" href="http://knockoutjs.com">http://knockoutjs.com</a> or <a class="ulink" href="http://learn.knockoutjs.com">http://learn.knockoutjs.com</a> for interactive tutorials. For books on the library, you can check out <em>KnockoutJS Starter</em> by Eric M. Barnard, or <em>Mastering KnockoutJS</em> by Timothy Moran.</p></div></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec75"/>A brief overview of AngularJS</h1></div></div></div><p>One of the <a id="id658" class="indexterm"/>more recent popular frameworks that we can use alongside our JavaScript application is AngularJS. Angular was originally created at Google as a language to help designers code. It quickly grew into the JavaScript framework of choice, both at Google and abroad. The core Angular development team makes sure that Angular excels in data binding and testability.</p><p>Angular works by parsing through the HTML page for specific element attributes. These attributes give directives to Angular about how to bind input and output elements on the page to JavaScript variables in memory. Data that is bound to the HTML can either be defined in code or requested from a JSON source. The binding is two way, similar to Knockout, but this framework has been fleshed out to provide more popular features found in other libraries.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec112"/>Angular and MV*</h2></div></div></div><p>While Angular <a id="id659" class="indexterm"/>was designed with MVC in mind, developers argue that it doesn't follow the MVC pattern. They say that the controller aspects don't really behave as controllers, but more like presenters (in MVP) or <code class="literal">ViewModel</code> (MVVM). This led some Angular developers to coin the term <a id="id660" class="indexterm"/><strong>Model View Whatever</strong> (<strong>MVW</strong> or <strong>MV*</strong> for short). Whatever architecture style it uses, it has caught the attention of many developers. It's currently one of the most popular frameworks, favored even more than jQuery by most JavaScript developers.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec113"/>Angular vocabulary</h2></div></div></div><p>One <a id="id661" class="indexterm"/>of the barriers to using AngularJS is the new vocabulary it introduces. Many of the terms were created by computer scientists at Google, so they may sound very academic. However, when we place them within the context of a language we know, we can understand the concepts better. We're going to discuss the following Angular terms, and how they relate to our mapping application:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Controller</li><li class="listitem" style="list-style-type: disc">Service</li><li class="listitem" style="list-style-type: disc">Directive</li></ul></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec99"/>The app controller</h3></div></div></div><p>In Angular, the <a id="id662" class="indexterm"/><strong>Controller</strong> is a JavaScript object connected by two-way binding to an HTML document using Angular tags. Changes to values within the scope of the controller will change the values displayed on the HTML document. The Angular controller is comparable to the <code class="literal">ViewModel</code> in Knockout. For map-driven applications written with Angular, the map is often defined as part of the main controller.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec100"/>The app service</h3></div></div></div><p>In Angular, a <a id="id663" class="indexterm"/><strong>service</strong> is a JavaScript object used to communicate with servers and other data sources. Services are created once, and keep running through the life of the application in the browser. The equivalent item in the ArcGIS JavaScript API would be a task like <code class="literal">QueryTask</code> or <code class="literal">GeometryService</code>. In fact, if you wrote an Angular app using the ArcGIS JavaScript API, you could wrap a <code class="literal">QueryTask</code> within an Angular service and serve data that way.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec101"/>The app directive</h3></div></div></div><p>In <a id="id664" class="indexterm"/>Angular, a <strong>directive</strong> is a custom element with its own behavior defined in code. The directive loads a template HTML file, applies its own bindings, and displays on a web page. In the ArcGIS JavaScript API, the equivalent to a directive is the Dojo <code class="literal">dijit</code> that we learned about in <a class="link" href="ch03.html" title="Chapter 3. The Dojo Widget System">Chapter 3</a>, <em>The Dojo Widget System</em>. The <code class="literal">dijit</code> defines an HTML template and the JavaScript behavior bound to it. One difference between directives and dijits is that Angular directives are allowed to give an HTML element a custom name, such as <code class="literal">&lt;overviewmap&gt;&lt;/overviewmap&gt;</code>, while <code class="literal">dijits</code> must be built on existing HTML elements. Also, Angular events and descriptions are described with <code class="literal">ng-*</code> HTML parameters rather than <code class="literal">data-dojo-*</code> parameters.</p></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec76"/>Making a web mapping app more Angular</h1></div></div></div><p>Since <a id="id665" class="indexterm"/>AngularJS is a framework, it is expected to handle the work of page layout, event handling, and so on. However, Dojo is also a framework, and has its own opinions about how those page events should be handled. Can the two get along?</p><p>The key to using AngularJS and the ArcGIS JavaScript API side by side is to let Angular handle most of the page layout, but use the map, widgets, and task from the ArcGIS JavaScript API to communicate with ArcGIS Server.</p><p>Much of the work needed to make our application run with AngularJS would take far too long to explain, and deserves its own chapter. Instead, I've supplied a few resources you can look over to integrate Angular into your own application.</p><div><div><h3 class="title"><a id="note18"/>Note</h3><p>For more information about incorporating ArcGIS JavaScript API with Angular.JS, you can read blog posts by Rene Rubalcava at <a class="ulink" href="http://odoe.net/blog/using-angularjs-with-arcgis-api-for-javascript/">http://odoe.net/blog/using-angularjs-with-arcgis-api-for-javascript/</a> or read his book <em>ArcGIS Web Development</em>, published by Manning Press. You can also review code from ESRI at <a class="ulink" href="https://github.com/Esri/angular-esri-map">https://github.com/Esri/angular-esri-map</a>. Finally, for more information about Angular.JS, you can read <em>Instant AngularJS Starter</em> by Dan Menard, or <em>Mastering Web Application Development with AngularJS</em> by Pawel Kozlowski and Peter Bacon Darwin.</p></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec77"/>Overall results with other frameworks</h1></div></div></div><p>All the frameworks we have reviewed in this chapter have worked with the ArcGIS API for JavaScript. Some, such as jQuery, slipped right and could be used right away. Others, such as Backbone and Angular, required a significant rewrite of the application. Each of these libraries takes up significant bandwidth when the browser downloads the website. These libraries and frameworks would have to bring something very important to make it worth the wait.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec114"/>jQuery</h2></div></div></div><p>The jQuery<a id="id666" class="indexterm"/> library performs a number of functions found in Dojo. Both work well in a wide array of browsers. While jQuery's functionality and style make it easier to work with the HTML DOM, its event handling doesn't couple directly with Dojo's event handlers. In other words, <code class="literal">$(map).on("click", …)</code> doesn't do the same thing as <code class="literal">map.on("click", …)</code>.</p><p>If you're creating an application that's jQuery centric and you want to add an ArcGIS-based map, it's perfectly fine to mix the two libraries together. You can easily define map operations with Dojo and other form operations through jQuery. However, jQuery doesn't <a id="id667" class="indexterm"/>add anything to the ArcGIS JavaScript library that can't be accomplished by importing a couple of extra Dojo modules (which saves on download bandwidth as well).</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec115"/>Backbone.js</h2></div></div></div><p>Backbone organizes <a id="id668" class="indexterm"/>your code well, but it requires a lot of code to make it work. All the models, views, and other features have to be defined individually, and coupled with one another. There are other extension libraries, such as <code class="literal">Marionette.js</code>, that can make Backbone easier to code. Using Backbone could be very beneficial to architect the application around the map, but for this simple job, it was a little excessive.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec116"/>Knockout and Angular</h2></div></div></div><p>Both Knockout <a id="id669" class="indexterm"/>and Angular <a id="id670" class="indexterm"/>are great frameworks for CRUD (Create, Read, Update, and Destroy) applications, but they don't bring anything new and powerful to web mapping applications. They can slow an application down if a lot of two-way binding is applied to an HTML document. Also, since Angular is a framework, it is written to handle many of the user interactions behind the scenes. Large portions of the code would have to be rewritten if Angular was added to an existing ArcGIS JavaScript API application.</p><p>In conclusion, we could have easily accomplished what we wanted using Dojo and the ArcGIS JavaScript API. We could save time and bandwidth on a smaller device like a smartphone or tablet by writing these portions using the ArcGIS JavaScript API. However, it helps to know how to incorporate ArcGIS maps with existing applications written in these other frameworks.</p></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec78"/>Summary</h1></div></div></div><p>In this chapter, you have learned how to use the ArcGIS JavaScript API along with other JavaScript libraries. We built applications using jQuery, Backbone.js, Knockout.js, and Angular.js. We compared the different uses of the libraries and frameworks, and how they worked with the ArcGIS API and Dojo.</p><p>In the next chapter, we'll tackle a topic that strikes fear into the hearts of some JavaScript developers… styling.</p></div></div></div></body></html>