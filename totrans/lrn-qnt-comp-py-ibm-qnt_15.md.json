["```py\nqc = QuantumCircuit(2,2)\nqc.h(0)\nqc.x(1)\nqc.cx(0,1)\nqc.measure([0,1], [0,1])\nqc.draw() \n```", "```py\nqc = QuantumCircuit(2,2)\nqc.h(0)\nqc.ch(0,1)\nqc.draw() \n```", "```py\nqc = QuantumCircuit(2,2)\nqc.h(0)\nqc.cx(0,1)\nqc.draw() \n```", "```py\nqc = QuantumCircuit(3)\nqc.ccx(0,2,1)\nqc.draw() \n```", "```py\nqc = QuantumCircuit(2)\nqc.x(0)\n# current state is '01'\nqc.swap(0,1)\n# current state is reversed, '10' \n```", "```py\nfrom qiskit.circuit.random import random_circuit\n#Circuit with a width = 4, a depth = 9\nqc = random_circuit(4, 9, measure=True) \n```", "```py\nqc1 = random_circuit(2,2)\nqc_combined = qc.compose(qc1, [0,1], front=True) \n```", "```py\nqc_combined.draw()\nqc_combined.count_ops() \n```", "```py\nimport numpy as np\nfrom qiskit.circuit import Parameter\nparam_theta = Parameter('ÆŸ')\nqc = QuantumCircuit(2)\nqc.rz(param_theta,0)\nqc = qc.assign_parameters({param_theta: np.pi/2})\nqc.draw() \n```", "```py\nqc = QuantumCircuit(1)\nqc.h(0)\nqc.sdg(0)\nsimulator = Aer.get_backend('statevector_simulator')\ntranspiled_qc = transpile(qc, backend=simulator)\nresult = simulator.run(transpiled_qc).result()\nstatevector = result.get_statevector(transpiled_qc)\nstatevector \n```", "```py\nimport numpy as np\nqc = QuantumCircuit(2, 2)\ninit_qubits = [0, 1]\nqc.initialize([1, 0, 0, 1] / np.sqrt(2), init_qubits) \n```"]