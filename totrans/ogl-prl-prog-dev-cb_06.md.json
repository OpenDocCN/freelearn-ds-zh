["```py\n// dataCount is size of elements in the 1D array\n// kernelCount is the pre-defined kernel/filter e.g. h[0]=2,h[1]=1 \n// h[x]=0 for x ={…,-1,2,3,…}\nfor(int i = 0; i < dataCount; ++i) {\n  y[i] = 0;\n  for(int j = 0; j < kernelCount; ++j) {\n    y[i] += x[i – j] * h[j]; // statement 1\n  }\n}\n```", "```py\n// find centre position of kernel (assuming a 2D array of equal\n// dimensions)\nint centerX = kernelCols/2;\nint centerY = kernelRows/2;\nfor(int i = 0; i < numRows2D; ++i) {\n  for(int j = 0; j < numCols2D; ++j) {\n    for(m = 0; m < kernelRows; ++m) {\n          mm = kernelRows - 1 – m;\n    for(n = 0; n < kernelCols; ++n) {\n              nn = kernelCols - 1 – n;\n        ii = i + (m – centerX);\n        jj = j + (n – centerY);\n        if (ii >= 0 && ii < rows && jj >= 0 && jj < numCols)\n       out[i][j] += in[ii][jj] * kernel[mm][nn]; // statement 1\n    }\n    }\n  }\n}\n```", "```py\n__kernel void SobelDetector(__global uchar4* input, \n                            __global uchar4* output) {\n      uint x = get_global_id(0);\n      uint y = get_global_id(1);\n\n  uint width = get_global_size(0);\n  uint height = get_global_size(1);\n\n  float4 Gx = (float4)(0);\n  float4 Gy = (float4)(0);\n\n    // Given that we know the (x,y) coordinates of the pixel we're \n    // looking at, its natural to use (x,y) to look at its\n    // neighbouring pixels\n    // Convince yourself that the indexing operation below is\n    // doing exactly that\n\n    // the variables i00 through to i22 seek to identify the pixels\n    // following the naming convention in graphics programming e.g.   \n    // OpenGL where i00 refers\n    // to the top-left-hand corner and iterates through to the bottom\n    // right-hand corner\n\n  if( x >= 1 && x < (width-1) && y >= 1 && y < height - 1)\n  {\n    float4 i00 = convert_float4(input[(x - 1) + (y - 1) * width]);\n    float4 i10 = convert_float4(input[x + (y - 1) * width]);\n    float4 i20 = convert_float4(input[(x + 1) + (y - 1) * width]);\n    float4 i01 = convert_float4(input[(x - 1) + y * width]);\n    float4 i11 = convert_float4(input[x + y * width]);\n    float4 i21 = convert_float4(input[(x + 1) + y * width]);\n    float4 i02 = convert_float4(input[(x - 1) + (y + 1) * width]);\n    float4 i12 = convert_float4(input[x + (y + 1) * width]);\n    float4 i22 = convert_float4(input[(x + 1) + (y + 1) * width]);\n\n        // To understand why the masks are applied this way, look\n        // at the mask for Gy and Gx which are respectively equal \n        // to the matrices:\n        // { {-1, 0, 1}, { {-1,-2,-1},\n        //   {-2, 0, 2},   { 0, 0, 0},\n        //   {-1, 0, 1}}   { 1, 2, 1}}\n\nGx = i00 + (float4)(2) * i10 + i20 - i02  - (float4)(2) * i12 -i22;\nGy = i00 - i20  + (float4)(2)*i01 - (float4)(2)*i21 + i02  -  i22;\n\n        // The math operation here is applied to each element of\n        // the unsigned char vector and the final result is applied \n        // back to the output image\n  output[x + y *width] = convert_uchar4(hypot(Gx, Gy)/(float4)(2));\n  }  \n}\n```", "```py\nGx = i00 + (float4)(2) * i10 + i20 - i02  - (float4)(2) * i12 - i22+ 0*i01+0*i11+0*i21;\nGy = i00 - i20  + (float4)(2)*i01 - (float4)(2)*i21 + i02 - i22+ 0*i10+0*i11+0*i12;\n```", "```py\ngcc -std=c99 -Wall -DUNIX -g -DDEBUG -DAPPLE -arch i386 -o SobelFilter SobelFilter.c -framework OpenCL\n\n```", "```py\nclEnqueueNDRangeKernel(command, queue, 2, NULL, globalThreads, localThreads, 0, NULL, NULL);\n```", "```py\ncl_command_queue \nclCreateCommandQueue(cl_context context,\n                     cl_device_id device,\n                     cl_command_queue_properties properties, cl_int* error_ret);\n```", "```py\ncl_int\nclGetEventProfilingInfo(cl_event event,\n                        cl_profiling_info param_name,               \n                        size_t param_value_size, \n                        void* param_value,\n                        size_t* param_value_size_ret);\n```", "```py\ncl_event readEvt;\ncl_ulong startTime;\ncl_ulong endTime;\ncl_ulong timeToRead;\ncl_command_queue queue = clCreateCommandQueue(context, device, CL_QUEUE_PROFILING_ENABLE, NULL);\nclEnqueueReadBuffer(queue, some_buffer, TRUE, 0, sizeof(data), data,0, NULL, &readEvt);\nclGetEventProfilingInfo(readEvt, CL_PROFILING_COMMAND_START,sizeof(startTime),&startTime, NULL);\nclGetEventProfilingInfo(readEvt, CL_PROFILING_COMMAND_END,sizeof(endTime),&endTime, NULL);\ntimeToRead = endTime – startTim;\n\n```"]