["```py\nncols 250\nnrows 250\nxllcorner 277750.0\nyllcorner 6122250.0\ncellsize 1.0\nNODATA_value -9999\n```", "```py\nmyArray  = numpy.loadtxt(\"myGrid.asc\", skiprows=6)\n```", "```py\nimport linecache\nline1 = linecache.getline(\"myGrid.asc\", 1)\n```", "```py\npython -c \"import numpy;print(numpy.__version__)\"\n1.8.2\n```", "```py\nheader = \"ncols {}\\n\".format(myArray.shape[1])\nheader += \"nrows {}\\n\".format(myArray.shape[0])\nheader += \"xllcorner 277750.0\\n\"\nheader += \"yllcorner 6122250.0\\n\"\nheader += \"cellsize 1.0\\n\"\nheader += \"NODATA_value -9999\"\nnumpy.savetxt(\"myGrid.asc\", myArray, header=header, fmt=\"%1.2f\")\n```", "```py\nwith open(\"myGrid.asc\", \"w\") as f:\n f.write(header)\n numpy.savetxt(f, str(myArray), fmt=\"%1.2f\")\n```", "```py\nfrom linecache import getline\nimport numpy as np\n```", "```py\n# File name of ASCII digital elevation model\nsource = \"dem.asc\"\n\n# File name of the slope grid\nslopegrid = \"slope.asc\"\n\n# File name of the aspect grid\naspectgrid = \"aspect.asc\"\n\n# Output file name for shaded relief\nshadegrid = \"relief.asc\"\n\n# Shaded elevation parameters\n# Sun direction\nazimuth = 315.0\n\n# Sun angle\naltitude = 45.0\n\n# Elevation exageration\nz = 1.0\n\n# Resolution\nscale = 1.0\n\n# No data value for output\nNODATA = -9999\n\n# Needed for numpy conversions\ndeg2rad = 3.141592653589793 / 180.0\nrad2deg = 180.0 / 3.141592653589793\n```", "```py\n# Parse the header using a loop and\n# the built-in linecache module\nhdr = [getline(source, i) for i in range(1, 7)]\nvalues = [float(h.split(\" \")[-1].strip()) for h in hdr]\ncols, rows, lx, ly, cell, nd = values\nxres = cell\nyres = cell * -1\n```", "```py\n# Load the dem into a numpy array\narr = np.loadtxt(source, skiprows=6)\n```", "```py\n# Exclude 2 pixels around the edges which are usually NODATA.\n# Also set up structure for 3 x 3 windows to process the slope\n# throughout the grid\nwindow = []\nfor row in range(3):\n for col in range(3):\n window.append(arr[row:(row + arr.shape[0] - 2),\n col:(col + arr.shape[1] - 2)])\n\n# Process each 3x3 window in both the x and y directions\nx = ((z * window[0] + z * window[3] + z * window[3] + z * \n window[6]) -\n (z * window[2] + z * window[5] + z * window[5] + z * \n window[8])) / \\\n (8.0 * xres * scale)\ny = ((z * window[6] + z * window[7] + z * window[7] + z * \n window[8]) -\n (z * window[0] + z * window[1] + z * window[1] + z * \n window[2])) / \\\n (8.0 * yres * scale)\n```", "```py\n# Calculate slope\nslope = 90.0 - np.arctan(np.sqrt(x * x + y * y)) * rad2deg\n\n# Calculate aspect\naspect = np.arctan2(x, y)\n\n# Calculate the shaded relief\nshaded = np.sin(altitude * deg2rad) * np.sin(slope * deg2rad) + \\\n np.cos(altitude * deg2rad) * np.cos(slope * deg2rad) * \\\n np.cos((azimuth - 90.0) * deg2rad - aspect)\n```", "```py\n# Scale values from 0-1 to 0-255\nshaded = shaded * 255\n```", "```py\n# Rebuild the new header\nheader = \"ncols {}\\n\".format(shaded.shape[1])\nheader += \"nrows {}\\n\".format(shaded.shape[0])\nheader += \"xllcorner {}\\n\".format(lx + (cell * (cols - \n shaded.shape[1])))\nheader += \"yllcorner {}\\n\".format(ly + (cell * (rows - \n shaded.shape[0])))\nheader += \"cellsize {}\\n\".format(cell)\nheader += \"NODATA_value {}\\n\".format(NODATA)\n```", "```py\n\n# Set no-data values\nfor pane in window:\n slope[pane == nd] = NODATA\n aspect[pane == nd] = NODATA\n shaded[pane == nd] = NODATA\n```", "```py\n# Open the output file, add the header, save the slope grid\nwith open(slopegrid, \"wb\") as f:\n f.write(bytes(header, \"UTF-8\")\n np.savetxt(f, slope, fmt=\"%4i\")\n\n# Open the output file, add the header, save the aspectgrid\nwith open(aspectgrid, \"wb\") as f:\n f.write(bytes(header, \"UTF-8\")\n np.savetxt(f, aspect, fmt=\"%4i\")\n\n# Open the output file, add the header, save the relief grid\nwith open(shadegrid, \"wb\") as f:\n f.write(bytes(header, 'UTF-8'))\n np.savetxt(f, shaded, fmt=\"%4i\")\n```", "```py\nimport gdal\nimport ogr\n```", "```py\n# Elevation DEM\nsource = \"dem.asc\"\n```", "```py\n# Output shapefile\ntarget = \"contour\"\nogr_driver = ogr.GetDriverByName(\"ESRI Shapefile\")\nogr_ds = ogr_driver.CreateDataSource(target + \".shp\")\nogr_lyr = ogr_ds.CreateLayer(target, \n# wkbLineString25D is the type code for geometry with a z \n# elevation value.\ngeom_type=ogr.wkbLineString25D)\nfield_defn = ogr.FieldDefn(\"ID\" ogr.OFTInteger)\nogr_lyr.CreateField(field_defn)\nfield_defn = ogr.FieldDefn(\"ELEV\" ogr.OFTReal)\nogr_lyr.CreateField(field_defn)\n```", "```py\n# gdal.ContourGenerate() arguments\n# Band srcBand,\n# double contourInterval,\n# double contourBase,\n# double[] fixedLevelCount,\n# int useNoData,\n# double noDataValue,\n# Layer dstLayer,\n# int idField,\n# int elevField\nds = gdal.Open(source)\n\n# EPGS:3157\ngdal.ContourGenerate(ds.GetRasterBand(1), 400, 10, [], 0, 0, ogr_lyr, 0, 1))\nogr_ds = None\n```", "```py\nimport shapefile\nimport pngcanvas\n\n# Open the contours\nr = shapefile.Reader(\"contour.shp\")\n\n# Setup the world to pixels conversion\nxdist = r.bbox[2] - r.bbox[0]\nydist = r.bbox[3] - r.bbox[1]\niwidth = 800\niheight = 600\nxratio = iwidth/xdist\nyratio = iheight/ydist\ncontours = []\n\n# Loop through all shapes\nfor shape in r.shapes():\n # Loop through all parts\n for i in range(len(shape.parts)):\n   pixels = []\n   pt = None\n   if i < len(shape.parts) - 1:\n     pt = shape.points[shape.parts[i]:shape.parts[i+1]]\n   else:\n     pt = shape.points[shape.parts[i]:]\n   for x, y in pt:\n     px = int(iwidth - ((r.bbox[2] - x) * xratio))\n     py = int((r.bbox[3] - y) * yratio)\n     pixels.append([px, py])\n     contours.append(pixels)\n\n# Set up the output canvas\ncanvas = pngcanvas.PNGCanvas(iwidth, iheight)\n\n# PNGCanvas accepts rgba byte arrays for colors\nred = [0xff, 0, 0, 0xff]\ncanvas.color = red\n\n# Loop through the polygons and draw them\nfor c in contours:\n canvas.polyline(c)\n\n# Save the image\nwith open(\"contours.png\", \"wb\") as f:\n f.write(canvas.dump())\n```", "```py\npip install http://git.io/vOER9\n```", "```py\nfrom laspy.file import File\nimport numpy as np\n\n# Source LAS file\nsource = \"lidar.las\"\n\n# Output ASCII DEM file\ntarget = \"lidar.asc\"\n\n# Grid cell size (data units)\ncell = 1.0\n\n# No data value for output DEM\nNODATA = 0\n\n# Open LIDAR LAS file\nlas = File(source, mode=\"r\")\n\n# xyz min and max\nmin = las.header.min\nmax = las.header.max\n\n# Get the x axis distance in meters\nxdist = max[0] - min[0]\n\n# Get the y axis distance in meters\nydist = max[1] - min[1]\n\n# Number of columns for our grid\ncols = int(xdist) / cell\n\n# Number of rows for our grid\nrows = int(ydist) / cell\ncols += 1\nrows += 1\n\n# Track how many elevation\n# values we aggregate\ncount = np.zeros((rows, cols)).astype(np.float32)\n\n# Aggregate elevation values\nzsum = np.zeros((rows, cols)).astype(np.float32)\n\n# Y resolution is negative\nycell = -1 * cell\n\n# Project x, y values to grid\nprojx = (las.x - min[0]) / cell\nprojy = (las.y - min[1]) / ycell\n\n# Cast to integers and clip for use as index\nix = projx.astype(np.int32)\niy = projy.astype(np.int32)\n\n# Loop through x, y, z arrays, add to grid shape,\n# and aggregate values for averaging\nfor x, y, z in np.nditer([ix, iy, las.z]):\n count[y, x] += 1\n zsum[y, x] += z\n\n# Change 0 values to 1 to avoid numpy warnings,\n# and NaN values in array\nnonzero = np.where(count > 0, count, 1)\n\n# Average our z values\nzavg = zsum / nonzero\n\n# Interpolate 0 values in array to avoid any\n# holes in the grid\nmean = np.ones((rows, cols)) * np.mean(zavg)\nleft = np.roll(zavg, -1, 1)\nlavg = np.where(left > 0, left, mean)\nright = np.roll(zavg, 1, 1)\nravg = np.where(right > 0, right, mean)\ninterpolate = (lavg + ravg) / 2\nfill = np.where(zavg > 0, zavg, interpolate)\n\n# Create our ASCII DEM header\nheader = \"ncols {}\\n\".format(fill.shape[1])\nheader += \"nrows {}\\n\".format(fill.shape[0])\nheader += \"xllcorner {}\\n\".format(min[0])\nheader += \"yllcorner {}\\n\".format(min[1])\nheader += \"cellsize {}\\n\".format(cell)\nheader += \"NODATA_value {}\\n\".format(NODATA)\n\n# Open the output file, add the header, save the array\nwith open(target, \"wb\") as f:\n f.write(bytes(header, 'UTF-8'))\n # The fmt string ensures we output floats\n # that have at least one number but only\n # two decimal places\n np.savetxt(f, fill, fmt=\"%1.2f\")\n```", "```py\nimport numpy as np\n\ntry:\n import Image\n import ImageOps\nexcept ImportError:\n from PIL import Image, ImageOps\n\n# Source gridded LIDAR DEM file\nsource = \"lidar.asc\"\n\n# Output image file\ntarget = \"lidar.bmp\"\n\n# Load the ASCII DEM into a numpy array\narr = np.loadtxt(source, skiprows=6)\n\n# Convert array to numpy image\nim = Image.fromarray(arr).convert(\"RGB\")\n\n# Enhance the image:\n# equalize and increase contrast\nim = ImageOps.equalize(im)\nim = ImageOps.autocontrast(im)\n\n# Save the image\nim.save(target)\n```", "```py\nimport numpy as np\n\ntry:\n import Image\n import ImageOps\nexcept:\n from PIL import Image, ImageOps\nimport colorsys\n\n# Source LIDAR DEM file\nsource = \"lidar.asc\"\n\n# Output image file\ntarget = \"lidar.bmp\"\n\n# Load the ASCII DEM into a numpy array\narr = np.loadtxt(source, skiprows=6)\n\n# Convert the numpy array to a PIL image.\n# Use black and white mode so we can stack\n# three bands for the color image.\nim = Image.fromarray(arr).convert('L')\n\n# Enhance the image\nim = ImageOps.equalize(im)\nim = ImageOps.autocontrast(im)\n\n# Begin building our color ramp\npalette = []\n\n# Hue, Saturation, Value\n# color space starting with yellow.\nh = .67\ns = 1\nv = 1\n\n# We'll step through colors from:\n# blue-green-yellow-orange-red.\n# Blue=low elevation, Red=high-elevation\nstep = h / 256.0\n\n# Build the palette\nfor i in range(256):\n rp, gp, bp = colorsys.hsv_to_rgb(h, s, v)\n r = int(rp * 255)\n g = int(gp * 255)\n b = int(bp * 255)\n palette.extend([r, g, b])\n h -= step\n\n# Apply the palette to the image\nim.putpalette(palette)\n\n# Save the image\nim.save(target)\n```", "```py\nimport pickle\nimport os\nimport time\nimport math\nimport numpy as np\nimport shapefile\nfrom laspy.file import File\n# voronoi.py for Python 3: pip install http://git.io/vOEuJ\nimport voronoi\n```", "```py\n# Source LAS file\nsource = \"clippedLAS.las\"\n\n# Output shapefile\ntarget = \"mesh\"\n\n# Triangles pickle archive\narchive = \"triangles.p\"\n```", "```py\nclass Point:\n \"\"\"Point class required by the voronoi module\"\"\"\n def __init__(self, x, y):\n   self.px = x\n   self.py = y\n\ndef x(self):\n return self.px\n\ndef y(self):\n return self.py\n```", "```py\n# The triangle array holds tuples\n# 3 point indices used to retrieve the points.\n# Load it from a pickle\n# file or use the voronoi module\n# to create the triangles.\ntriangles = None\n```", "```py\n # Open LIDAR LAS file\n las = File(source, mode=\"r\")\nelse:\n\n# Open LIDAR LAS file\n las = File(source, mode=\"r\")\n points = []\n print(\"Assembling points...\")\n\n# Pull points from LAS file\n for x, y in np.nditer((las.x, las.y)):\n points.append(Point(x, y))\n print(\"Composing triangles...\")\n```", "```py\n# Delaunay Triangulation\n triangles = voronoi.computeDelaunayTriangulation(points)\n```", "```py\n # Save the triangles to save time if we write more than\n # one shapefile.\n f = open(archive, \"wb\")\n pickle.dump(triangles, f, protocol=2)\n f.close()\n```", "```py\nprint(\"Creating shapefile...\")\n # PolygonZ shapefile (x, y, z, m)\n w = shapefile.Writer(target, shapefile.POLYGONZ)\n w.field(\"X1\", \"C\", \"40\")\n w.field(\"X2\", \"C\", \"40\")\n w.field(\"X3\", \"C\", \"40\")\n w.field(\"Y1\", \"C\", \"40\")\n w.field(\"Y2\", \"C\", \"40\")\n w.field(\"Y3\", \"C\", \"40\")\n w.field(\"Z1\", \"C\", \"40\")\n w.field(\"Z2\", \"C\", \"40\")\n w.field(\"Z3\", \"C\", \"40\")\n tris = len(triangles)\n```", "```py\n# Loop through shapes and\n # track progress every 10 percent\n last_percent = 0\n for i in range(tris):\n     t = triangles[i]\n     percent = int((i/(tris*1.0))*100.0)\n     if percent % 10.0 == 0 and percent > last_percent:\n         last_percent = percent\n         print(\"{} % done - Shape {}/{} at {}\".format(percent, \n         i, tris, time.asctime()))\n part = []\n x1 = las.x[t[0]]\n y1 = las.y[t[0]]\n z1 = las.z[t[0]]\n x2 = las.x[t[1]]\n y2 = las.y[t[1]]\n z2 = las.z[t[1]]\n x3 = las.x[t[2]]\n y3 = las.y[t[2]]\n z3 = las.z[t[2]]\n```", "```py\n # Check segments for large triangles\n # along the convex hull which is a common\n # artifact in Delaunay triangulation\n max = 3\n if math.sqrt((x2-x1)**2+(y2-y1)**2) > max:\n continue\n if math.sqrt((x3-x2)**2+(y3-y2)**2) > max:\n continue\n if math.sqrt((x3-x1)**2+(y3-y1)**2) > max:\n continue\n part.append([x1, y1, z1, 0])\n part.append([x2, y2, z2, 0])\n part.append([x3, y3, z3, 0])\n w.poly(parts=[part])\n w.record(x1, x2, x3, y1, y2, y3, z1, z2, z3)\n print(\"Saving shapefile...\")\n```", "```py\nw.close()\nprint(\"Done.\")\n```"]