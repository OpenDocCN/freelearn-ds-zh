["```py\nimport scipy.linalg as sl\n\nclass PolyNomial:\n    base='monomial'\n    def __init__(self,**args):\n        if 'points' in args:\n            self.points = array(args['points'])\n            self.xi = self.points[:,0]\n            self.coeff = self.point_2_coeff()\n            self.degree = len(self.coeff)-1\n        elif 'coeff' in args:\n            self.coeff = array(args['coeff'])\n            self.degree = len(self.coeff)-1\n            self.points = self.coeff_2_point()\n        else:\n            self.points = array([[0,0]])\n            self.xi = array([1.])\n            self.coeff = self.point_2_coeff()\n            self.degree = 0\n```", "```py\ndef point_2_coeff(self):\n    return sl.solve(vander(self.x),self.y)\n```", "```py\ndef coeff_2_point(self):\n    points = [[x,self(x)] for x in linspace(0,1,self.degree+1)]\n    return array(points)\n```", "```py\ndef __call__(self,x):\n    return polyval(self.coeff,x)\n```", "```py\n@property\ndef x(self):\n    return self.points[:,0]\n@property\ndef y(self):\n    return self.points[:,1]\n```", "```py\n          def x(self):\n              return self.interppoints[:,0]\n    ```", "```py\ndef __repr__(self):\n    txt  = 'Polynomial of degree {degree} \\n'\n    txt += 'with coefficients {coeff} \\n in {base} basis.'\n    return txt.format(coeff=self.coeff, degree=self.degree,\n                                            base=self.base)\n```", "```py\nmargin = .05\nplotres = 500\ndef plot(self,ab=None,plotinterp=True):\n    if ab is None: # guess a and b\n       x = self.x\n       a, b = x.min(), x.max()\n       h = b-a\n       a -= self.margin*h\n       b += self.margin*h\n    else:\n       a,b = ab\n    x = linspace(a,b,self.plotres)\n    y = vectorize(self.__call__)(x)\n    plot(x,y)\n    xlabel('$x$')\n    ylabel('$p(x)$')\n    if plotinterp:\n        plot(self.x, self.y, 'ro')\n```", "```py\ndef companion(self):\n    companion = eye(self.degree, k=-1)\n    companion[0,:] -= self.coeff[1:]/self.coeff[0]\n    return companion\n```", "```py\ndef zeros(self):\n   companion = self.companion()\n   return sl.eigvals(companion)\n```", "```py\np = PolyNomial(points=[(1,0),(2,3),(3,8)])\n```", "```py\np.coeff # returns array([ 1., 0., -1.])\n```", "```py\npz = p.zeros() # returns array([-1.+0.j, 1.+0.j])\n```", "```py\np(pz) # returns array([0.+0.j, 0.+0.j])\n```", "```py\nclass NewtonPolynomial(PolyNomial):\n    base = 'Newton'\n    def __init__(self,**args):\n        if 'coeff' in args:\n            try:\n                self.xi = array(args['xi'])\n            except KeyError: \n                raise ValueError('Coefficients need to be given'\n                'together with abscissae values xi')\n        super(NewtonPolynomial, self).__init__(**args)\n```", "```py\ndef point_2_coeff(self):\n    return array(list(self.divdiff()))\n```", "```py\ndef divdiff(self): \n    xi = self.xi\n    row = self.y\n    yield row[0]\n    for level in range(1,len(xi)):\n        row = (row[1:] - row[:-1])/(xi[level:] - xi[:-level])\n        if allclose(row,0): # check: elements of row nearly zero\n           self.degree = level-1\n           break\n        yield row[0]\n```", "```py\npts = array([[0.,0],[.5,1],[1.,0],[2,0.]]) # here we define the\n  interpolation data: (x,y) pairs\npN = NewtonPolynomial(points=pts) # this creates an instance of the\n  polynomial class\npN.coeff # returns the coefficients array([ 0\\. , 2\\. , -4\\. ,\n  2.66666667])\nprint(pN)\n```", "```py\nPolynomial of degree 3\n with coefficients [ 0.     2.    -4.      2.66666667]\n in Newton basis.\n```", "```py\ndef __call__(self,x):\n    # first compute the sequence 1, (x-x_1), (x-x_1)(x-x_2),...\n    nps = hstack([1., cumprod(x-self.xi[:self.degree])])\n    return dot(self.coeff, nps)\n```", "```py\ndef companion(self):\n    degree = self.degree\n    companion = eye(degree, k=-1)\n    diagonal = identity(degree,dtype=bool)\n    companion[diagonal] = self.x[:degree]\n    companion[:,-1] -= self.coeff[:degree]/self.coeff[degree]\n    return companion\n```", "```py\nimport scipy.linalg as sl\n\n# create some data points\nn = 100\nx1 = 1.2 * random.randn(n, 2)\nx2 = 0.8 * random.randn(n, 2) + tile([7, 0],(n, 1))\nx = vstack((x1, x2))\n\n# pairwise distance matrix\nM = array([[ sqrt(sum((x[i] - x[j])**2)) \n                                  for i in range(2*n)]          \n                                    for j in range(2 * n)])\n\n# create the Laplacian matrix\nD = diag(1 / sqrt( M.sum(axis = 0) ))\nL = identity(2 * n) - dot(D, dot(M, D))\n\n# compute eigenvectors of L\nS, V = sl.eig(L)\n# As L is symmetric the imaginary parts\n# in the eigenvalues are only due to negligible numerical errors S=S.real\nV=V.real\n```", "```py\nlargest=abs(S).argmax()\nplot(V[:,largest])\n```", "```py\nimport scipy.linalg as sl\nimport scipy.cluster.vq as sc\n# simple 4 class data\nx = random.rand(1000,2)\nndx = ((x[:,0] < 0.4) | (x[:,0] > 0.6)) & \n                     ((x[:,1] < 0.4) | (x[:,1] > 0.6))\nx = x[ndx]\nn = x.shape[0]\n\n# pairwise distance matrix\nM = array([[ sqrt(sum((x[i]-x[j])**2)) for i in range(n) ]\n                                       for j in range(n)])\n\n# create the Laplacian matrix\nD = diag(1 / sqrt( M.sum(axis=0) ))\nL = identity(n) - dot(D, dot(M, D))\n\n# compute eigenvectors of L\n_,_,V = sl.svd(L)\n\nk = 4\n# take k first eigenvectors\neigv = V[:k,:].T\n\n# k-means\ncentroids,dist = sc.kmeans(eigv,k)\nclust_id = sc.vq(eigv,centroids)[0]\n```", "```py\nU, S, V = sl.svd(L)\n```", "```py\n_, _, V = sl.svd(L)\n```", "```py\nfor i in range(k):\n    ndx = where(clust_id == i)[0]\n    plot(x[ndx, 0], x[ndx, 1],'o')\naxis('equal')\n```", "```py\nclass IV_Problem:\n    \"\"\"\n    Initial value problem (IVP) class\n    \"\"\"\n    def __init__(self, rhs, y0, interval, name='IVP'):\n        \"\"\"\n        rhs 'right hand side' function of the ordinary differential\n                                                   equation f(t,y)\n        y0 array with initial values\n        interval start and end value of the interval of independent\n        variables often initial and end time\n        name descriptive name of the problem\n        \"\"\"\n        self.rhs = rhs\n        self.y0 = y0\n        self.t0, self.tend = interval\n        self.name = name\n```", "```py\ndef rhs(t,y):\n    g = 9.81\n    l = 1.\n    yprime = array([y[1], g / l * sin(y[0])])\n    return yprime\n\npendulum = IV_Problem(rhs, array([pi / 2, 0.]), [0., 10.] ,\n                                            'mathem. pendulum')\n```", "```py\nclass IVPsolver:\n    \"\"\"\n    IVP solver class for explicit one-step discretization methods\n    with constant step size\n    \"\"\"\n    def __init__(self, problem, discretization, stepsize):\n        self.problem = problem\n        self.discretization = discretization\n        self.stepsize = stepsize\n    def one_stepper(self):\n        yield self.problem.t0, self.problem.y0\n        ys = self.problem.y0\n        ts = self.problem.t0\n        while ts <= self.problem.tend:\n            ts, ys = self.discretization(self.problem.rhs, ts, ys,\n                                                self.stepsize)\n            yield ts, ys\n    def solve(self):\n        return list(self.one_stepper())\n```", "```py\n      def expliciteuler(rhs, ts, ys, h):\n          return ts + h, ys + h * rhs(ts, ys)\n```", "```py\n      def rungekutta4(rhs, ts, ys, h):\n          k1 = h * rhs(ts, ys)\n          k2 = h * rhs(ts + h/2., ys + k1/2.) \n          k3 = h * rhs(ts + h/2., ys + k2/2.)\n          k4 = h * rhs(ts + h, ys +  k3)\n          return ts + h, ys + (k1 + 2*k2 + 2*k3 + k4)/6.\n```", "```py\npendulum_Euler = IVPsolver(pendulum, expliciteuler, 0.001) \npendulum_RK4 = IVPsolver(pendulum, rungekutta4, 0.001)\n```", "```py\nsol_Euler = pendulum_Euler.solve()\nsol_RK4 = pendulum_RK4.solve()\ntEuler, yEuler = zip(*sol_Euler)\ntRK4, yRK4 = zip(*sol_RK4)\nsubplot(1,2,1), plot(tEuler,yEuler),\\\n       title('Pendulum result with Explicit Euler'),\\\n       xlabel('Time'), ylabel('Angle and angular velocity')\nsubplot(1,2,2), plot(tRK4,abs(array(yRK4)-array(yEuler))),\\\n       title('Difference between both methods'),\\\n       xlabel('Time'), ylabel('Angle and angular velocity')\n```"]