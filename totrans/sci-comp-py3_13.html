<html><head></head><body><div class="chapter" title="Chapter&#xA0;13.&#xA0;Testing"><div class="titlepage"><div><div><h1 class="title"><a id="ch13"/>Chapter 13. Testing</h1></div></div></div><p>In this chapter, we will focus on two aspects of testing for scientific programming. The first aspect is the often difficult topic of what to test in scientific computing. The second aspect covers the question of how to test. We will distinguish between manual and automated testing. Manual testing is what is done by every programmer to quickly check that an implementation is working or not. Automated testing is the refined, automated variant of that idea. We will introduce some tools available for automatic testing in general, with a view on the particular case of scientific computing.</p><div class="section" title="Manual testing"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec99"/>Manual testing</h1></div></div></div><p>During the development of code, you do a lot of small tests in order to test its functionality. This could be called manual testing. Typically, you would test if a given function does what it is supposed to do, by manually testing the function in an interactive environment. For instance, suppose that you implement the bisection algorithm. It is an algorithm that finds a zero (root) of a scalar non-linear function. To start the algorithm, an interval has to be given with the property that the function takes different signs on the interval boundaries, see <span class="emphasis"><em>Exercise 4</em></span>, <a class="link" href="ch07.html" title="Chapter 7. Functions">Chapter 7</a>, <span class="emphasis"><em>Functions</em></span>, for more information.</p><p>You will then test an implementation of that algorithm, typically by checking that:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A solution is found when the function has opposite signs at the interval boundaries</li><li class="listitem" style="list-style-type: disc">An exception is raised when the function has the same sign at the interval boundaries</li></ul></div><p>Manual testing, as necessary as it may seem to be, is unsatisfactory. Once you have convinced yourself that the code does what it is supposed to do, you formulate a relatively small number of demonstration examples to convince others of the quality of the code. At that stage, one often looses interest in the tests made during development and they are forgotten or even deleted. As soon as you change a detail and things no longer work correctly, you might regret that your earlier tests are no longer available.</p></div></div>
<div class="section" title="Automatic testing"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec100"/>Automatic testing</h1></div></div></div><p>The correct way to develop any piece of code is to use automatic testing. The advantages are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The automated repetition of a large number of tests after every code refactoring and before any new versions are launched.</li><li class="listitem" style="list-style-type: disc">A silent documentation of the use of the code.</li><li class="listitem" style="list-style-type: disc">A documentation of the test coverage of your code: Did things work before a change or was a certain aspect never tested?</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note28"/>Note</h3><p>Changes in the program and in particular in its structure which do not affect its functionality are called code refactoring.</p></div></div><p>We suggest developing tests in parallel to the code. Good design of tests is an art of its own and there is rarely an investment which guarantees such a good pay-off in development time savings as the investment in good tests.</p><p>Now we will go through the implementation of a simple algorithm with the automated testing methods in mind.</p><div class="section" title="Testing the bisection algorithm"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec123"/>Testing the bisection algorithm</h2></div></div></div><p>Let us examine automated testing for the bisection algorithm. With this algorithm, a zero of a real valued function is found. It is described section <span class="emphasis"><em>Exercise 4</em></span> in <a class="link" href="ch07.html" title="Chapter 7. Functions">Chapter 7</a>, <span class="emphasis"><em>Functions</em></span>. An implementation of the algorithm can have the following form:</p><pre class="programlisting">def bisect(f, a, b, tol=1.e-8):&#13;
    """&#13;
    Implementation of the bisection algorithm &#13;
    f real valued function&#13;
    a,b interval boundaries (float) with the property &#13;
    f(a) * f(b) &lt;= 0&#13;
    tol tolerance (float)&#13;
    """&#13;
    if f(a) * f(b)&gt; 0:&#13;
        raise ValueError("Incorrect initial interval [a, b]") &#13;
    for i in range(100):&#13;
        c = (a + b) / 2.&#13;
        if f(a) * f(c) &lt;= 0:&#13;
            b = c&#13;
        else:&#13;
            a = c&#13;
        if abs(a - b) &lt; tol:&#13;
            return (a + b) / 2&#13;
    raise Exception(&#13;
          'No root found within the given tolerance {}'.format(tol))</pre><p>We assume this to be stored in the <code class="literal">bisection.py</code> file. As the first test case, we test that the zero of the function <span class="emphasis"><em>f</em></span>(<span class="emphasis"><em>x</em></span>) =<span class="emphasis"><em> x</em></span> is found:</p><pre class="programlisting">def test_identity():&#13;
    result = bisect(lambda x: x, -1., 1.) &#13;
    expected = 0.&#13;
    assert allclose(result, expected),'expected zero not found'&#13;
&#13;
test_identity()</pre><p>In this code, you meet the Python keyword <code class="literal">assert</code> for the first time. It raises <code class="literal">AssertionError</code> exception if its first argument returns the <code class="literal">False</code> value. Its optional second argument is a string with additional information. We use the function <code class="literal">allclose</code> in order to test for equality of floats.</p><p>Let us comment on some of the features of the test function. We use an assertion to make sure that an exception will be raised if the code does not behave as expected. We have to manually run the test in the <code class="literal">test_identity()</code> line.</p><p>There are many tools to automate this kind of call.</p><p>Let us now set up a test that checks if <code class="literal">bisect</code> raises an exception when the function has the same sign on both ends of the interval. For now, we will suppose that the exception raised is a <code class="literal">ValueError</code> exception. In the following example, we will check the initial interval [<span class="emphasis"><em>a</em></span>,<span class="emphasis"><em>b</em></span>]. For the bisection algorithm it should fulfill a sign condition:</p><pre class="programlisting">def test_badinput():&#13;
    try:&#13;
        bisect(lambda x: x,0.5,1)&#13;
    except ValueError:&#13;
        pass&#13;
    else:&#13;
        raise AssertionError()&#13;
&#13;
test_badinput()</pre><p>In this case, an <code class="literal">AssertionError</code> is raised if the exception is not of the <code class="literal">ValueError</code> type . There are tools to simplify the preceding construction to check that an exception is raised.</p><p>Another useful test is the edge case test. Here we test arguments or user input, which is likely to create mathematically undefined situations or states of the program not foreseen by the programmer. For instance, what happens if both bounds are equal? What happens if <span class="emphasis"><em>a &gt; b</em></span>?</p><pre class="programlisting">def test_equal_boundaries():&#13;
    result = bisect(lambda x: x, 0., 0.)&#13;
    expected = 0.&#13;
    assert allclose(result, expected), \&#13;
                   'test equal interval bounds failed'&#13;
&#13;
def test_reverse_boundaries():&#13;
    result = bisect(lambda x: x, 1., -1.)&#13;
    expected = 0.&#13;
    assert allclose(result, expected),\&#13;
                 'test reverse interval bounds failed'&#13;
 &#13;
test_equal_boundaries()&#13;
test_reverse_boundaries()</pre></div></div>
<div class="section" title="Using unittest package"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec101"/>Using unittest package</h1></div></div></div><p>The standard <code class="literal">unittest</code> Python package greatly facilitates automated testing. This package requires that we rewrite our tests to be compatible. The first test would have to be rewritten in a <code class="literal">class</code>, as follows:</p><pre class="programlisting">from bisection import bisect&#13;
import unittest&#13;
&#13;
class TestIdentity(unittest.TestCase):&#13;
    def test(self):&#13;
        result = bisect(lambda x: x, -1.2, 1.,tol=1.e-8)&#13;
        expected = 0.&#13;
        self.assertAlmostEqual(result, expected)&#13;
&#13;
if __name__=='__main__':&#13;
    unittest.main()</pre><p>Let's examine the differences to the previous implementation. First, the test is now a method and a part of a class. The class must inherit from <code class="literal">unittest.TestCase</code>. The test method's name must start with <code class="literal">test</code>. Note that we may now use one of the assertion tools of the <code class="literal">unittest</code> package, namely <code class="literal">assertAlmostEqual</code>. Finally, the tests are run using <code class="literal">unittest.main</code>. We recommend to write the tests in a file separate from the code to be tested. That is why it starts with an <code class="literal">import</code>. The test passes and returns as follows: </p><pre class="programlisting">
<span class="strong"><strong>Ran 1 test in 0.002s</strong></span>
<span class="strong"><strong>OK</strong></span>
</pre><p>If we run it with a loose tolerance parameter, for example, <code class="literal">1.e-3</code>, a failure of the test would have been reported:</p><pre class="programlisting">
<span class="strong"><strong>F</strong></span>
<span class="strong"><strong>======================================================================</strong></span>
<span class="strong"><strong>FAIL: test (__main__.TestIdentity)</strong></span>
<span class="strong"><strong>----------------------------------------------------------------------</strong></span>
<span class="strong"><strong>Traceback (most recent call last):</strong></span>
<span class="strong"><strong>  File "&lt;ipython-input-11-e44778304d6f&gt;", line 5, in test</strong></span>
<span class="strong"><strong>    self.assertAlmostEqual(result, expected)</strong></span>
<span class="strong"><strong>AssertionError: 0.00017089843750002018 != 0.0 within 7 places</strong></span>
<span class="strong"><strong>----------------------------------------------------------------------</strong></span>
<span class="strong"><strong>Ran 1 test in 0.004s</strong></span>
<span class="strong"><strong>FAILED (failures=1)</strong></span>
</pre><p>Tests can and should be grouped together as methods of a test class, as given in the following example:</p><pre class="programlisting">import unittest&#13;
from bisection import bisect&#13;
&#13;
class TestIdentity(unittest.TestCase):&#13;
    def identity_fcn(self,x):&#13;
        return x&#13;
    def test_functionality(self):&#13;
        result = bisect(self.identity_fcn, -1.2, 1.,tol=1.e-8)&#13;
        expected = 0.&#13;
        self.assertAlmostEqual(result, expected)&#13;
    def test_reverse_boundaries(self):&#13;
        result = bisect(self.identity_fcn, 1., -1.)&#13;
        expected = 0.&#13;
        self.assertAlmostEqual(result, expected)&#13;
    def test_exceeded_tolerance(self):&#13;
        tol=1.e-80&#13;
        self.assertRaises(Exception, bisect, self.identity_fcn,&#13;
                                               -1.2, 1.,tol)&#13;
if __name__=='__main__':&#13;
    unittest.main()</pre><p>Here, in the last test we used the method <code class="literal">unittest.TestCase.assertRaises</code>. It tests whether an exception is correctly raised. Its first parameter is the exception type, for example, <code class="literal">ValueError</code>, <code class="literal">Exception</code>, and its second argument is the name of the function, which is expected to raise the exception. The remaining arguments are the arguments for this function. The command <code class="literal">unittest.main()</code> creates an instance of the <code class="literal">TestIdentity</code> class and executes those methods starting with <code class="literal">test</code>.</p><div class="section" title="Test setUp and tearDown methods"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec124"/>Test setUp and tearDown methods</h2></div></div></div><p>The class <code class="literal">unittest.TestCase</code> provides two special methods, <code class="literal">setUp</code> and <code class="literal">tearDown</code>, which run before and after every call to a test method. This is needed when testing generators, which are exhausted after every test. We demonstrate this by testing a program which checks the line in a file in which a given string occurs for the first time:</p><pre class="programlisting">class NotFoundError(Exception):&#13;
  pass&#13;
&#13;
def find_string(file, string):&#13;
    for i,lines in enumerate(file.readlines()):&#13;
        if string in lines:&#13;
            return i&#13;
    raise NotFoundError(&#13;
         'String {} not found in File {}'.format(string,file.name))</pre><p>We assume that this code is saved in the <code class="literal">find_in_file.py</code> file. A test has to prepare a file and open it and remove it after the test as given in the following example:</p><pre class="programlisting">import unittest&#13;
import os # used for, for example, deleting files&#13;
&#13;
from find_in_file import find_string, NotFoundError&#13;
&#13;
class TestFindInFile(unittest.TestCase):&#13;
    def setUp(self):&#13;
        file = open('test_file.txt', 'w')&#13;
        file.write('aha')&#13;
        file.close()&#13;
        self.file = open('test_file.txt', 'r')&#13;
    def tearDown(self):&#13;
        self.file.close()&#13;
        os.remove(self.file.name)&#13;
    def test_exists(self):&#13;
        line_no=find_string(self.file, 'aha')&#13;
        self.assertEqual(line_no, 0)&#13;
    def test_not_exists(self):&#13;
        self.assertRaises(NotFoundError, find_string,&#13;
                                              self.file, 'bha')&#13;
&#13;
if __name__=='__main__':&#13;
    unittest.main()</pre><p>Before each test <code class="literal">setUp</code> is run and then <code class="literal">tearDown</code> is executed.</p></div></div>
<div class="section" title="Parameterizing tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec102"/>Parameterizing tests</h1></div></div></div><p>One frequently wants to repeat the same test with different data sets. When using the functionalities of <code class="literal">unittest</code> this requires us to automatically generate test cases with the corresponding methods injected:</p><p>To this end, we first construct a test case with one or several methods that will be used, when we later set up test methods. Let's consider the bisection method again and let's check if the values it returns are really zeros of the given function.</p><p>We first build the test case and the method which we will use for the tests as follows:</p><pre class="programlisting">class Tests(unittest.TestCase):&#13;
    def checkifzero(self,fcn_with_zero,interval):&#13;
        result = bisect(fcn_with_zero,*interval,tol=1.e-8)&#13;
        function_value=fcn_with_zero(result)&#13;
        expected=0.&#13;
        self.assertAlmostEqual(function_value, expected)</pre><p>Then we dynamically create test functions as attributes of this class:</p><pre class="programlisting">test_data=[&#13;
           {'name':'identity', 'function':lambda x: x,&#13;
                                     'interval' : [-1.2, 1.]},&#13;
           {'name':'parabola', 'function':lambda x: x**2-1,&#13;
                                        'interval' :[0, 10.]},&#13;
           {'name':'cubic', 'function':lambda x: x**3-2*x**2,&#13;
                                       'interval':[0.1, 5.]},&#13;
               ] &#13;
def make_test_function(dic):&#13;
        return lambda self :\&#13;
                   self.checkifzero(dic['function'],dic['interval'])&#13;
for data in test_data:&#13;
    setattr(Tests, "test_{name}".format(name=data['name']),&#13;
                                           make_test_function(data))&#13;
if __name__=='__main__':&#13;
  unittest.main()</pre><p>In this example, the data is provided as a list of dictionaries. The <code class="literal">make_test_function</code> function dynamically generates a test function, which uses a particular data dictionary to perform the test with the previously defined method <code class="literal">checkifzero</code>. Finally, the command <code class="literal">setattr</code> is used to make these test functions methods of the class <code class="literal">Tests</code>.</p></div>
<div class="section" title="Assertion tools"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec103"/>Assertion tools</h1></div></div></div><p>In this section, we collect the most important tools for raising an <code class="literal">AssertionError</code>. We saw the <code class="literal">assert</code> command and two tools from <code class="literal">unittest</code>, namely <code class="literal">assertAlmostEqual</code>. The following table (<span class="emphasis"><em>Table 13.1</em></span>) summarizes the most important assertion tools and the related modules:</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><tbody><tr><td>
<p>
<span class="strong"><strong>Assertion tool and application example</strong></span>
</p>
</td><td>
<p>
<span class="strong"><strong>Module</strong></span>
</p>
</td></tr><tr><td>
<p>
<code class="literal">assert 5==5</code>
</p>
</td><td>
<p>–</p>
</td></tr><tr><td>
<p>
<code class="literal">assertEqual(5.27, 5.27)</code>
</p>
</td><td>
<p>
<code class="literal">unittest.TestCase</code>
</p>
</td></tr><tr><td>
<p>
<code class="literal">assertAlmostEqual(5.24, 5.2,places = 1)</code>
</p>
</td><td>
<p> <code class="literal">unittest.TestCase</code>
</p>
</td></tr><tr><td>
<p>
<code class="literal">assertTrue(5 &gt; 2)</code>
</p>
</td><td>
<p>
<code class="literal">unittest.TestCase</code>
</p>
</td></tr><tr><td>
<p>
<code class="literal">assertFalse(2 &lt; 5)</code>
</p>
</td><td>
<p>
<code class="literal">unittest.TestCase</code>
</p>
</td></tr><tr><td>
<p>
<code class="literal">assertRaises(ZeroDivisionError,lambda x: 1/x,0.)</code>
</p>
</td><td>
<p>
<code class="literal">unittest.TestCase</code>
</p>
</td></tr><tr><td>
<p>
<code class="literal">assertIn(3,{3,4})</code>
</p>
</td><td>
<p>
<code class="literal">unittest.TestCase</code>
</p>
</td></tr><tr><td>
<p>
<code class="literal">assert_array_equal(A,B)</code>
</p>
</td><td>
<p>
<code class="literal">numpy.testing</code>
</p>
</td></tr><tr><td>
<p>
<code class="literal">assert_array_almost_equal(A, B, decimal=5)</code>
</p>
</td><td>
<p>
<code class="literal">numpy.testing</code>
</p>
</td></tr><tr><td>
<p>
<code class="literal">assert_allclose(A, B, rtol=1.e-3,atol=1.e-5)</code>
</p>
</td><td>
<p>
<code class="literal">numpy.testing</code>
</p>
</td></tr></tbody></table></div><p>Table 13.1: Assertion tools in Python, unittest and NumPy</p></div>
<div class="section" title="Float comparisons"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec104"/>Float comparisons</h1></div></div></div><p>Two floating point numbers should not be compared with the <code class="literal">==</code> comparison, because the result of a computation is often slightly off due to rounding errors. There are numerous tools to test equality of floats for testing purposes. First, <code class="literal">allclose</code> checks that two arrays are almost equal. It can be used in a test function, as shown:</p><pre class="programlisting">self.assertTrue(allclose(computed, expected))</pre><p>Here, <code class="literal">self</code> refers to a <code class="literal">unittest.Testcase</code> instance. There are also testing tools in the <code class="literal">numpy</code> package <code class="literal">testing</code>. These are imported by using:</p><pre class="programlisting">import numpy.testing</pre><p>Testing that two scalars or two arrays are equal is done using <code class="literal">numpy.testing.assert_array_allmost_equal</code> or <code class="literal">numpy.testing.assert_allclose</code>. These methods differ in the way they describe the required accuracy, as shown in the preceding table.</p><p>
<span class="emphasis"><em>QR</em></span> factorization decomposes a given matrix into a product of an orthogonal matrix <span class="emphasis"><em>Q</em></span> and an upper triangular matrix <span class="emphasis"><em>R</em></span> as given in the following example:</p><pre class="programlisting">import scipy.linalg as sl&#13;
A=rand(10,10)&#13;
[Q,R]=sl.qr(A)</pre><p>Is the method applied correctly? We can check this by verifying that <span class="emphasis"><em>Q</em></span> is indeed an orthogonal matrix:</p><pre class="programlisting">import numpy.testing as npt &#13;
npt.assert_allclose(&#13;
               dot(Q.T,self.Q),identity(Q.shape[0]),atol=1.e-12)</pre><p>Furthermore, we might perform a sanity test by checking if <span class="emphasis"><em>A = QR</em></span>:</p><pre class="programlisting">import numpy.testing as npt&#13;
npt.assert_allclose(dot(Q,R),A))</pre><p>All this can be collected into a <code class="literal">unittest</code> test case as follows:</p><pre class="programlisting">import unittest&#13;
import numpy.testing as npt&#13;
from scipy.linalg import qr&#13;
from scipy import *&#13;
&#13;
class TestQR(unittest.TestCase):&#13;
    def setUp(self):&#13;
        self.A=rand(10,10)&#13;
        [self.Q,self.R]=qr(self.A)&#13;
    def test_orthogonal(self):&#13;
        npt.assert_allclose(&#13;
            dot(self.Q.T,self.Q),identity(self.Q.shape[0]),&#13;
                                                        atol=1.e-12)&#13;
    def test_sanity(self):&#13;
            npt.assert_allclose(dot(self.Q,self.R),self.A)&#13;
&#13;
if __name__=='__main__':&#13;
    unittest.main()</pre><p>Note in <code class="literal">assert_allclose</code> the parameter <code class="literal">atol</code> defaults to zero, which often causes problems, when working with matrices having small elements.</p></div>
<div class="section" title="Unit and functional tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec105"/>Unit and functional tests</h1></div></div></div><p>Up to now, we have only used functional tests. A functional test checks whether the functionality is correct. For the bisection algorithm, this algorithm actually finds a zero when there is one. In that simple example, it is not really clear what a unit test is. Although, it might seem slightly contrived, it is still possible to make a unit test for the bisection algorithm. It will demonstrate how unit testing often leads to more compartmentalized implementation.</p><p>So, in the bisection method, we would like to check, for instance, that at each step the interval is chosen correctly. How to do that? Note that it is absolutely impossible with the current implementation, because the algorithm is hidden inside the function. One possible remedy is to run only one step of the bisection algorithm. Since all the steps are similar, we might argue that we have tested all the possible steps. We also need to be able to inspect the current bounds <code class="literal">a</code> and <code class="literal">b</code> at the current step of the algorithm. So we have to add the number of steps to be run as a parameter and change the return interface of the function. We will do that as shown:</p><pre class="programlisting">def bisect(f,a,b,n=100):&#13;
  ...&#13;
  for iteration in range(n):&#13;
    ...&#13;
  return a,b</pre><p>Note that we have to change the existing unit tests in order to accommodate for that change. We may now add a unit test as shown:</p><pre class="programlisting">def test_midpoint(self):&#13;
  a,b = bisect(identity,-2.,1.,1)&#13;
  self.assertAlmostEqual(a,-0.5)&#13;
  self.assertAlmostEqual(b,1.)</pre></div>
<div class="section" title="Debugging"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec106"/>Debugging</h1></div></div></div><p>Debugging is sometimes necessary while testing, in particular if it is not immediately clear why a given test does not pass. In that case, it is useful to be able to debug a given test in an interactive session. This is however, made difficult by the design of the <code class="literal">unittest.TestCase</code> class, which prevents easy instantiation of test case objects. The solution is to create a special instance for debugging purpose only.</p><p>Suppose that, in the example of the <code class="literal">TestIdentity</code> class above, we want to test the <code class="literal">test_functionality</code> method. This would be achieved as follows:</p><pre class="programlisting">test_case = TestIdentity(methodName='test_functionality')</pre><p>Now this test can be run individually by:</p><pre class="programlisting">test_case.debug()</pre><p>This will run this individual test and it allows for debugging.</p></div>
<div class="section" title="Test discovery"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec107"/>Test discovery</h1></div></div></div><p>If you write a Python package, various tests might be spread out through the package. The <code class="literal">discover</code> module finds, imports, and runs these test cases. The basic call from the command line is:</p><pre class="programlisting">
<span class="strong"><strong>python -m unittest discover</strong></span>
</pre><p>It starts looking for test cases in the current directory and recurses the directory tree downward to find Python objects with the <code class="literal">'test'</code> string contained in its name. The command takes optional arguments. Most important are <code class="literal">-s</code> to modify the start directory and <code class="literal">-p</code> to define the pattern to recognize the tests:</p><pre class="programlisting">
<span class="strong"><strong>python -m unittest discover -s '.' -p 'Test*.py'</strong></span>
</pre></div>
<div class="section" title="Measuring execution time"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec108"/>Measuring execution time</h1></div></div></div><p>In order to take decisions on code optimization, one often has to compare several code alternatives and decide which code should be preferred based on the execution time. Furthermore, discussing execution time is an issue when comparing different algorithms. In this section, we present a simple and easy way to measure execution time.</p><div class="section" title="Timing with a magic function"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec125"/>Timing with a magic function</h2></div></div></div><p>The easiest way to measure the execution time of a single statement is to use IPython’s magic function <code class="literal">%timeit</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note29"/>Note</h3><p>The shell IPython adds additional functionality to standard Python. These extra functions are called magic functions.</p></div></div><p>As the execution time of a single statement can be extremely short, the statement is placed in a loop and executed several times. By taking the minimum measured time, one makes sure that other tasks running on the computer do not influence the measured result too much. Let's consider four alternative ways to extract nonzero elements from an array as follows:</p><pre class="programlisting">A=zeros((1000,1000))&#13;
A[53,67]=10&#13;
&#13;
def find_elements_1(A):&#13;
    b = []&#13;
    n, m = A.shape&#13;
    for i in range(n):&#13;
        for j in range(m):&#13;
            if abs(A[i, j]) &gt; 1.e-10:&#13;
                b.append(A[i, j])&#13;
    return b&#13;
&#13;
def find_elements_2(A):&#13;
    return [a for a in A.reshape((-1, )) if abs(a) &gt; 1.e-10]&#13;
&#13;
def find_elements_3(A):&#13;
    return [a for a in A.flatten() if abs(a) &gt; 1.e-10]&#13;
 &#13;
def find_elements_4(A):&#13;
    return A[where(0.0 != A)]</pre><p>Measuring time with IPython’s magic function <code class="literal">%timeit</code> gives the following result:</p><pre class="programlisting">In [50]: %timeit -n 50 -r 3 find_elements_1(A)&#13;
50 loops, best of 3: 585 ms per loop&#13;
&#13;
In [51]: %timeit -n 50 -r 3 find_elements_2(A)&#13;
50 loops, best of 3: 514 ms per loop&#13;
&#13;
In [52]: %timeit -n 50 -r 3 find_elements_3(A)&#13;
50 loops, best of 3: 519 ms per loop&#13;
&#13;
In [53]: %timeit -n 50 -r 3 find_elements_4(A)&#13;
50 loops, best of 3: 7.29 ms per loop</pre><p>The parameter <code class="literal">-n</code> controls how often the statement is executed before time is measured and the <code class="literal">-r</code> parameter controls the number of repetitions.</p></div><div class="section" title="Timing with the Python module timeit"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec126"/>Timing with the Python module timeit</h2></div></div></div><p>Python provides a <code class="literal">timeit</code> module, which can be used to measure execution time. It requires that first a time object is constructed. It is constructed from two strings, a string with setup commands and a string with the commands to be executed. We take the same four alternatives as in the preceding example. The array and function definitions are written now in a string called <code class="literal">setup_statements</code> and four-time objects are constructed as follows:</p><pre class="programlisting">import timeit&#13;
setup_statements="""&#13;
from scipy import zeros&#13;
from numpy import where&#13;
A=zeros((1000,1000))&#13;
A[57,63]=10.&#13;
&#13;
def find_elements_1(A):&#13;
    b = []&#13;
    n, m = A.shape&#13;
    for i in range(n):&#13;
        for j in range(m):&#13;
            if abs(A[i, j]) &gt; 1.e-10:&#13;
               b.append(A[i, j])&#13;
    return b&#13;
&#13;
def find_elements_2(A):&#13;
    return [a for a in A.reshape((-1,)) if abs(a) &gt; 1.e-10]&#13;
&#13;
def find_elements_3(A):&#13;
    return [a for a in A.flatten() if abs(a) &gt; 1.e-10]&#13;
&#13;
def find_elements_4(A):&#13;
    return A[where( 0.0 != A)]&#13;
"""&#13;
experiment_1 = timeit.Timer(stmt = 'find_elements_1(A)',&#13;
                            setup = setup_statements)&#13;
experiment_2 = timeit.Timer(stmt = 'find_elements_2(A)',&#13;
                            setup = setup_statements)&#13;
experiment_3 = timeit.Timer(stmt = 'find_elements_3(A)',&#13;
                            setup = setup_statements)&#13;
experiment_4 = timeit.Timer(stmt = 'find_elements_4(A)',&#13;
                            setup = setup_statements)</pre><p>The timer objects have a <code class="literal">repeat</code> method . It takes <code class="literal">repeat</code> and <code class="literal">number</code> parameters. It executes the statement of the timer object in a loop, measures the time, and repeats this experiment corresponding to the <code class="literal">repeat</code> parameter:</p><p>We continue the preceding example and measure execution times as shown:</p><pre class="programlisting">t1 = experiment_1.repeat(3,5) &#13;
t2 = experiment_2.repeat(3,5) &#13;
t3 = experiment_3.repeat(3,5) &#13;
t4 = experiment_4.repeat(3,5) &#13;
# Results per loop in ms&#13;
min(t1)*1000/5 # 615 ms&#13;
min(t2)*1000/5 # 543 ms&#13;
min(t3)*1000/5 # 546 ms&#13;
min(t4)*1000/5 # 7.26 ms</pre><p>In contrast to the method in the preceding example, we obtain lists of all the obtained measurements. As computing time may vary depending on the overall load of the computer, the minimal value in such a list can be considered a good approximation to the computation time necessary to execute the statement.</p></div><div class="section" title="Timing with a context manager"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec127"/>Timing with a context manager</h2></div></div></div><p>Finally, we present the third method. It serves to show another application of a context manager. We first construct a context manager object for measuring the elapsed time as shown:</p><pre class="programlisting">import time&#13;
class Timer:&#13;
    def __enter__(self):&#13;
        self.start = time.time()&#13;
        # return self&#13;
    def __exit__(self, ty, val, tb):&#13;
        end = time.time()&#13;
        self.elapsed=end-self.start&#13;
        print('Time elapsed {} seconds'.format(self.elapsed))&#13;
        return False</pre><p>Recall that the <code class="literal">_ _enter_ _</code> and <code class="literal">_ _exit_ _</code> methods make this class a context manager. The <code class="literal">_ _exit_ _</code> method’s parameters <code class="literal">ty</code>, <code class="literal">val</code>, and <code class="literal">tb</code> are in the normal case <code class="literal">None</code>. If an exception is raised during execution, they take the exception type, its value, and traceback information. The <code class="literal">return False</code> indicates that the exception has not been caught so far.</p><p>We now show the use of the context manager to measure the execution time of the four alternatives in the previous example:</p><pre class="programlisting">with Timer():&#13;
  find_elements_1(A)&#13;
</pre><p>This will then display a message like <code class="literal">Time elapsed 15.0129795074 ms</code>.</p><p>If the timing result should be accessible in a variable, the <code class="literal">enter</code> method must return the <code class="literal">Timer</code> instance (uncomment the <code class="literal">return</code> statement) and a <code class="literal">with ... as ...</code> construction has to be used:</p><pre class="programlisting">with Timer() as t1:&#13;
    find_elements_1(A)&#13;
t1.elapsed # contains the result</pre></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec109"/>Summary</h1></div></div></div><p>No program development without testing! We showed the importance of well organized and documented tests. Some professionals even start development by first specifying tests. A useful tool for automatic testing is the module <code class="literal">unittest</code>, which we explained in detail. While testing improves the reliability of a code, profiling is needed to improve the performance. Alternative ways to code may result in large performance differences. We showed how to measure computation time and how to localize bottlenecks in your code.</p></div>
<div class="section" title="Exercises"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec110"/>Exercises</h1></div></div></div><p>
<span class="strong"><strong>Ex. 1</strong></span> → Two matrices <span class="emphasis"><em>A</em></span>, <span class="emphasis"><em>B</em></span> are called similar, if there exists a matrix <span class="emphasis"><em>S</em></span>, such that <span class="emphasis"><em>B = S<sup>-1 </sup>A S</em></span>. <span class="emphasis"><em>A</em></span> and <span class="emphasis"><em>B</em></span> have the same eigenvalues. Write a test checking that two matrices are similar, by comparing their eigenvalues. Is it a functional or a unit test?</p><p>
<span class="strong"><strong>Ex. 2</strong></span> → Create two vectors of large dimension. Compare the execution time of various ways to compute their <code class="literal">dot</code> product:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">SciPy function: <code class="literal">dot(v,w)</code></li><li class="listitem" style="list-style-type: disc">Generator and sum: <code class="literal">sum((x*y for x,y in zip(v,w)))</code></li><li class="listitem" style="list-style-type: disc">Comprehensive list and sum: <code class="literal">sum([x*y for x,y in zip(v,w)])</code></li></ul></div><p>
<span class="strong"><strong>Ex. 3</strong></span> → Let <span class="emphasis"><em>u</em></span> be a vector. The vector <span class="emphasis"><em>v</em></span> with components</p><p>      </p><div class="mediaobject"><img src="graphics/moveaverage.jpg" alt="Exercises"/></div><p>
</p><p> is called a moving average of <span class="emphasis"><em>u</em></span>. Determine which of the two alternatives to compute <span class="emphasis"><em>v</em></span> is faster:</p><pre class="programlisting">v = (u[:-2] + u[1:-1] + u[2:]) / 3</pre><p>or</p><pre class="programlisting">v = array([(u[i] + u[i + 1] + u[i + 2]) / 3&#13;
  for i in range(len(u)-3)])</pre></div></body></html>