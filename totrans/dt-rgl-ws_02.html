<html><head></head><body><div id="sbo-rt-content"><div>
			<div id="_idContainer033" class="Content">
			</div>
		</div>
		<div id="_idContainer034" class="Content">
			<h1 id="_idParaDest-51"><a id="_idTextAnchor051"/>2. Advanced Operations on Built-In Data Structures</h1>
		</div>
		<div id="_idContainer049" class="Content">
			<p class="callout-heading"><a id="_idTextAnchor052"/>Overview</p>
			<p class="callout">This chapter will introduce advanced data operations on built-in data structures. You can utilize these data structures to solve data-wrangling problems. After reading this chapter, you will be able to compare Python's advanced data structures and make use of the Operating System (OS) file-handling operations. This chapter focuses on the data structures in Python and the OS functions that are the foundation of this book. By the end of this chapter, you will have learned how to handle advanced data structures.</p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor053"/>Introduction</h1>
			<p>We were introduced to the basic concepts of different fundamental data structures in the previous chapter. We learned about lists, sets, dictionaries, tuples, and strings. However, what we have covered so far were only basic operations on those data structures. They have much more to offer once you learn how to utilize them effectively. In this chapter, we will venture further into the land of data structures. We will learn about advanced operations and manipulations and use fundamental data structures to represent more complex and higher-level data structures; this is often handy while wrangling data in real life. These higher-level topics will include stacks, queues, interiors, and file operations.</p>
			<p>In this chapter, we will also learn how to open a file using built-in Python methods and about the many different file operations, such as reading and writing data, and safely closing files once we are done. We will also take a look at some of the problems to avoid while dealing with files. </p>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor054"/>Advanced Data Structures</h1>
			<p>We will start this chapter by discussing advanced data structures. Initially, we will be revisiting lists. Then, we will construct a stack and a queue, explore multiple-element membership checking to check whether the data is accurate, and throw a bit of functional programming in for good measure. Don't worry if all of this sounds intimidating. We will take things step by step, and you will feel confident about handling advanced data structures once you have finished this chapter.</p>
			<p>Before we jump into constructing data structures, we'll look at a few methods to manipulate them. </p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor055"/>Iterator </h2>
			<p>Iterators in Python are very useful when dealing with data as they allow you to parse the data one unit at a time. Iterators are stateful, which means it will be helpful to keep track of the previous state. An iterator is an object that implements the <strong class="source-inline">next</strong> method—meaning an iterator can iterate over collections such as lists, tuples, dictionaries, and more. Practically, this means that each time we call the method, it gives us the next element from the collection; if there is no further element in the list, then it raises a <strong class="source-inline">StopIteration</strong> exception.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">A <strong class="source-inline">StopIteration</strong> exception occurs with the iterator's <strong class="source-inline">next</strong> method when there are no further values to iterate.</p>
			<p>If you are familiar with a programming language such as C, C++, Java, JavaScript, or PHP, you may have noticed the difference between the <strong class="source-inline">for</strong> loop implementation in those languages, which consists of three distinct parts (the initiation, the increment, and the termination condition), and the <strong class="source-inline">for</strong> loop in Python. In Python, we do not use that kind of a <strong class="source-inline">for</strong> loop. What we use in Python is more like a <strong class="source-inline">foreach</strong> loop: </p>
			<p class="source-code">for i in list_1 </p>
			<p>This is because, under the hood, the <strong class="source-inline">for</strong> loop is using an iterator, and thus we do not need to do all the extra steps. The iterator does them for us.</p>
			<p>Let's learn about the various functions we can use with <strong class="source-inline">itertools</strong>. As you execute each line of the code after the <strong class="source-inline">import</strong> statement, you will be able to see details about what that particular function does and how to use it: </p>
			<p class="source-code">from itertools import (permutations, combinations, \</p>
			<p class="source-code">                       dropwhile, repeat, zip_longest)</p>
			<p class="source-code"><strong class="bold">permutations?</strong></p>
			<p class="source-code"><strong class="bold">combinations?</strong></p>
			<p class="source-code"><strong class="bold">dropwhile?</strong></p>
			<p class="source-code"><strong class="bold">repeat?</strong></p>
			<p class="source-code"><strong class="bold">zip_longest?</strong></p>
			<p>For example, after executing <strong class="source-inline">zip_longest?</strong>, we'll see the following output:</p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="Images/B15780_02_01.jpg" alt="Figure 2.1: Help file for the zip_longest function&#13;&#10;" width="802" height="380"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1: Help file for the zip_longest function</p>
			<p>The preceding screenshot shows how the <strong class="source-inline">zip_longest</strong> function could be used from the <strong class="source-inline">itertools</strong> module. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">To look up the definition of any function, type the function name, followed by <em class="italic">?</em>, and then press <em class="italic">Shift</em> + <em class="italic">Enter</em> in a Jupyter Notebook.</p>
			<p>Let's go through the following exercise to understand how to use an iterator to iterate through a list. </p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor056"/>Exercise 2.01: Introducing to the Iterator</h2>
			<p>In this exercise, we're going to generate a long list containing numbers. We will first check the memory occupied by the generated list. We will then check how we can use the <strong class="source-inline">iterator</strong> module to reduce memory utilization, and finally, we will use this iterator to loop over the list. To do this, let's go through the following steps:</p>
			<ol>
				<li>Open a new Jupyter Notebook and generate a list that will contain <strong class="source-inline">10000000</strong> ones. Then, store this list in a variable called <strong class="source-inline">big_list_of_numbers</strong>:<p class="source-code">big_list_of_numbers = [1 for x in range (0, 10000000)] </p><p class="source-code">big_list_of_numbers</p><p>The output (partially shown) is as follows:</p><p class="source-code">[1,</p><p class="source-code"> 1,</p><p class="source-code"> 1,</p><p class="source-code"> 1,</p><p class="source-code"> 1,</p><p class="source-code"> 1,</p><p class="source-code"> 1,</p><p class="source-code"> 1,</p><p class="source-code"> 1,</p><p class="source-code"> 1,</p></li>
				<li>Check the size of this variable:<p class="source-code">from sys import getsizeof</p><p class="source-code">getsizeof(big_list_of_numbers)</p><p>The output should be as follows:</p><p class="source-code">81528056</p><p>The value shown is <strong class="source-inline">81528056</strong> (in bytes). This is a huge chunk of memory occupied by the list. And the <strong class="source-inline">big_list_of_numbers</strong> variable is only available once the list comprehension is over. It can also overflow the available system memory if you try too big a number. </p></li>
				<li>Let's use the <strong class="source-inline">repeat()</strong> method from <strong class="source-inline">itertools</strong> to get the same number but with less memory:<p class="source-code">from itertools import repeat</p><p class="source-code">small_list_of_numbers = repeat(1, times=10000000)</p><p class="source-code">getsizeof(small_list_of_numbers)</p><p>The output should be:</p><p class="source-code">56</p><p>The last line shows that our list <strong class="source-inline">small_list_of_numbers</strong> is only <strong class="source-inline">56</strong> bytes in size. Also, it is a lazy method, a technique used in functional programming that will delay the execution of a method or a function by a few seconds. In this case, Python will not generate all the elements initially. It will, instead, generate them one by one when asked, thus saving us time. In fact, if you omit the <strong class="source-inline">times</strong> keyword argument in the <strong class="source-inline">repeat()</strong> method in the preceding code, then you can practically generate an infinite number of ones.</p></li>
				<li>Loop over the newly generated iterator:<p class="source-code">for i, x in enumerate(small_list_of_numbers): </p><p class="source-code">    print(x)</p><p class="source-code">    if i &gt; 10:</p><p class="source-code">        break</p><p>The output is as follows:</p><p class="source-code">1</p><p class="source-code">1</p><p class="source-code">1</p><p class="source-code">1</p><p class="source-code">1</p><p class="source-code">1</p><p class="source-code">1</p><p class="source-code">1</p><p class="source-code">1</p><p class="source-code">1</p><p class="source-code">1</p><p class="source-code">1</p></li>
			</ol>
			<p>We use the <strong class="source-inline">enumerate</strong> function so that we get the loop counter, along with the values. This will help us break the loop once we reach a certain number (<strong class="source-inline">10</strong>, for example).</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2N8odTH">https://packt.live/2N8odTH</a>. </p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3fAPFGa">https://packt.live/3fAPFGa</a>.</p>
			<p>In this exercise, we first learned how to use the iterator function to reduce memory usage. Then, we used an iterator to loop over a list. Now, we'll see how to create stacks. </p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor057"/>Stacks</h2>
			<p>A stack is a very useful data structure. If you know a bit about CPU internals and how a program gets executed, then you will know that a stack is present in many such cases. It is simply a list with one restriction, <strong class="bold">Last In First Out</strong> (<strong class="bold">LIFO</strong>), meaning an element that comes in last goes out first when a value is read from a stack. The following illustration will make this a bit clearer:</p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="Images/B15780_02_02.jpg" alt="Figure 2.2: A stack with two insert elements and one pop operation&#13;&#10;" width="1665" height="635"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.2: A stack with two insert elements and one pop operation</p>
			<p>As you can see, we have a LIFO strategy to read values from a stack. We will implement a stack using a Python list. Python lists have a method called <strong class="source-inline">pop</strong>, which does the exact same <strong class="source-inline">pop</strong> operation that you can see in the preceding illustration. Basically, the <strong class="source-inline">pop</strong> function will take an element off the stack, using the <strong class="bold">Last in First Out</strong> (<strong class="bold">LIFO</strong>) rules. We will use that to implement a stack in the following exercise.</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor058"/>Exercise 2.02: Implementing a Stack in Python</h2>
			<p>In this exercise, we'll implement a stack in Python. We will first create an empty stack and add new elements to it using the <strong class="source-inline">append</strong> method. Next, we'll take out elements from the stack using the <strong class="source-inline">pop</strong> method. Let's go through the following steps:</p>
			<ol>
				<li value="1">Import the necessary Python library and define an empty stack:<p class="source-code">import pandas as pd</p><p class="source-code">stack = []</p><p class="callout-heading">Note</p><p class="callout"><strong class="source-inline">pandas</strong> is an open source data analysis library in Python.</p></li>
				<li>Use the <strong class="source-inline">append</strong> method to add multiple elements to the stack. Thanks to the <strong class="source-inline">append</strong> method, the element will always be appended at the end of the list:<p class="source-code">stack.append('my_test@test.edu')</p><p class="source-code">stack.append('rahul.subhramanian@test.edu')</p><p class="source-code">stack.append('sania.test@test.edu')</p><p class="source-code">stack.append('alec_baldwin@test.edu')</p><p class="source-code">stack.append('albert90@test.edu')</p><p class="source-code">stack.append('stewartj@test.edu')</p><p class="source-code">stack</p><p>The output is as follows:</p><p class="source-code">['my_test@test.edu',</p><p class="source-code"> 'rahul.subhramanian@test.edu',</p><p class="source-code"> 'sania.test@test.edu',</p><p class="source-code"> 'alec_baldwin@test.edu',</p><p class="source-code"> 'albert90@test.edu',</p><p class="source-code"> 'stewartj@test.edu']</p></li>
				<li>Let's read a value from our stack using the <strong class="source-inline">pop</strong> method. This method reads the current last index of the list and returns it to us. It also deletes the index once the read is done:<p class="source-code">tos = stack.pop()</p><p class="source-code">tos</p><p>The output is as follows:</p><p class="source-code">'stewartj@test.edu'</p><p>As you can see, the last value of the stack has been retrieved. Now, if we add another value to the stack, the new value will be appended at the end of the stack. </p></li>
				<li>Append <strong class="source-inline">Hello@test.com</strong> to the stack:<p class="source-code">stack.append("Hello@test.com")</p><p class="source-code">stack</p><p>The output is as follows:</p><p class="source-code">['my_test@test.edu',</p><p class="source-code"> 'rahul.subhramanian@test.edu',</p><p class="source-code"> 'sania.test@test.edu',</p><p class="source-code"> 'alec_baldwin@test.edu',</p><p class="source-code"> 'albert90@test.edu',</p><p class="source-code"> 'Hello@test.com']</p><p class="callout-heading">Note</p><p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/3hACc2B">https://packt.live/3hACc2B</a>. </p><p class="callout">You can also run this example online at <a href="https://packt.live/2Yb4uct">https://packt.live/2Yb4uct</a>.</p></li>
			</ol>
			<p>From the exercise, we can see that the basic stack operations, <strong class="source-inline">append</strong> and <strong class="source-inline">pop</strong>, are pretty easy to perform.</p>
			<p>Let's visualize a problem where you are scraping a web page and you want to follow each URL present there (backlinks). Let's split the solution to this problem into three parts. In the first part, we would append all the URLs scraped off the page into the stack. In the second part, we would pop each element in the stack, and then lastly, we would examine every URL, repeating the same process for each page. We will examine a part of this task in the next exercise. </p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor059"/>Exercise 2.03: Implementing a Stack Using User-Defined Methods</h2>
			<p>In this exercise, we will continue the topic of stacks from the last exercise. This time, we will implement the <strong class="source-inline">append</strong> and <strong class="source-inline">pop</strong> functions by creating user-defined methods. We will implement a stack, and this time with a business use case example (taking Wikipedia as a source). The aim of this exercise is twofold. In the first few steps, we will extract and append the URLs scraped off a web page in a stack, which also involves the <strong class="source-inline">string</strong> methods discussed in the last chapter. In the next few steps, we will use the <strong class="source-inline">stack_pop</strong> function to iterate over the stack and print them. This exercise will show us a subtle feature of Python and how it handles passing list variables to functions. Let's go through the following steps:</p>
			<ol>
				<li value="1">First, define two functions: <strong class="source-inline">stack_push</strong> and <strong class="source-inline">stack_pop</strong>. We renamed them so that we do not have a namespace conflict. Also, create a stack called <strong class="source-inline">url_stack</strong> for later use:<p class="source-code">def stack_push(s, value):</p><p class="source-code">    return s + [value]</p><p class="source-code">def stack_pop(s):</p><p class="source-code">    tos = s[-1]</p><p class="source-code">    del s[-1]</p><p class="source-code">    return tos</p><p class="source-code">url_stack = []</p><p class="source-code">url_stack</p><p>The output is as follows:</p><p class="source-code">[]</p><p>The first function takes the already existing stack and adds the value at the end of it. </p><p class="callout-heading">Note</p><p class="callout">Notice the square brackets around the value to convert it into a one-element list using the <strong class="source-inline">+</strong> operation. The second function reads the value that's currently at the <strong class="source-inline">-1</strong> index of the stack, then uses the <strong class="source-inline">del</strong> operator to delete that index, and finally returns the value it read earlier.</p><p>Now, we are going to have a string with a few URLs in it. </p></li>
				<li>Analyze the string so that we push the URLs in the stack one by one as we encounter them, and then use a <strong class="source-inline">for</strong> loop to pop them one by one. Let's take the first line from the <strong class="source-inline">Wikipedia</strong> article (<a href="https://en.wikipedia.org/wiki/Data_mining">https://en.wikipedia.org/wiki/Data_mining</a>) about data science:<p class="source-code">wikipedia_datascience = """Data science is an interdisciplinary field that uses scientific methods, processes, algorithms and systems to extract knowledge [https://en.wikipedia.org/wiki/Knowledge] and insights from data [https://en.wikipedia.org/wiki/Data] in various forms, both structured and unstructured,similar to data mining [https://en.wikipedia.org/wiki/Data_mining]""" </p><p>For the sake of the simplicity of this exercise, we have kept the links in square brackets beside the target words.</p></li>
				<li>Find the length of the string:<p class="source-code">len(wikipedia_datascience) </p><p>The output is as follows:</p><p class="source-code">347</p></li>
				<li>Convert this string into a list by using the <strong class="source-inline">split</strong> method from the string, and then calculate its length:<p class="source-code">wd_list = wikipedia_datascience.split()</p><p class="source-code">wd_list</p><p>The output is as follows (partial output):</p><p class="source-code">['Data',</p><p class="source-code"> 'science',</p><p class="source-code"> 'is',</p><p class="source-code"> 'an',</p><p class="source-code"> 'interdisciplinary',</p><p class="source-code"> 'field',</p><p class="source-code"> 'that',</p><p class="source-code"> 'uses',</p><p class="source-code"> 'scientific',</p><p class="source-code"> 'methods,',</p></li>
				<li>Check the length of the list:<p class="source-code">len(wd_list)</p><p>The output is as follows:</p><p class="source-code">34</p></li>
				<li>Use a <strong class="source-inline">for</strong> loop to go over each word and check whether it is a URL. To do that, we will use the <strong class="source-inline">startswith</strong> method from the string, and if it is a URL, then we push it into the stack:<p class="source-code">for word in wd_list:</p><p class="source-code">    if word.startswith("[https://"):</p><p class="source-code">        url_stack = stack_push(url_stack, word[1:-1])  </p><p class="source-code">        print(word[1:-1])</p><p>The output is as follows:</p><p class="source-code">https://en.wikipedia.org/wiki/Knowledge</p><p class="source-code">https://en.wikipedia.org/wiki/Data</p><p class="source-code">https://en.wikipedia.org/wiki/Data_mining</p><p>Notice the use of string slicing to remove the surrounding double quotes <strong class="source-inline">"[" "]"</strong>.</p></li>
				<li>Print the value in <strong class="source-inline">url_stack</strong>:<p class="source-code">print(url_stack) </p><p>The output is as follows:</p><p class="source-code">['https://en.wikipedia.org/wiki/Knowledge',</p><p class="source-code"> 'https://en.wikipedia.org/wiki/Data',</p><p class="source-code"> 'https://en.wikipedia.org/wiki/Data_mining']</p></li>
				<li>Iterate over the list and print the URLs one by one by using the <strong class="source-inline">stack_pop</strong>z function:<p class="source-code">for i in range(0, len(url_stack)):</p><p class="source-code">    print(stack_pop(url_stack)) </p><p>The output is as follows:</p><div id="_idContainer037" class="IMG---Figure"><img src="Images/B15780_02_03.jpg" alt="Figure 2.3: Output of the URLs that are printed using a stack&#13;&#10;" width="1665" height="193"/></div><p class="figure-caption">Figure 2.3: Output of the URLs that are printed using a stack</p></li>
				<li>Print it again to make sure that the stack is empty after the final <strong class="source-inline">for</strong> loop:<p class="source-code">print(url_stack) </p><p>The output is as follows:</p><p class="source-code">[]</p><p class="callout-heading">Note</p><p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2Y7oXyT">https://packt.live/2Y7oXyT</a>. </p><p class="callout">You can also run this example online at <a href="https://packt.live/3e9Smhz">https://packt.live/3e9Smhz</a>.</p></li>
			</ol>
			<p>In this exercise, we have noticed a strange phenomenon in the <strong class="source-inline">stack_pop</strong> method. We passed the <strong class="source-inline">list</strong> variable there, and we used the <strong class="source-inline">del</strong> operator inside the function in <em class="italic">step 1</em>, but it changed the original variable by deleting the last index each time we called the function. If you use languages like C, C++, and Java, then this is a completely unexpected behavior as, in those languages, this can only happen if we pass the variable by reference, and it can lead to subtle bugs in Python code. So, be careful when using the user-defined methods. </p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor060"/>Lambda Expressions</h2>
			<p>In general, it is not a good idea to change a variable's value inside a function. Any variable that is passed to the function should be considered and treated as immutable. This is close to the principles of functional programming. However, in that case, we could use unnamed functions that are neither immutable nor mutable and are typically not stored in a variable. Such an expression or function, called a <strong class="bold">lambda expression</strong> in Python, is a way to construct one-line, nameless functions that are, by convention, side-effect-free and are loosely considered as implementing functional programming.</p>
			<p>Let's look at the following exercise to understand how we use a lambda expression. </p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor061"/>Exercise 2.04: Implementing a Lambda Expression </h2>
			<p>In this exercise, we will use a lambda expression to prove the famous trigonometric identity:</p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="Images/B15780_02_04.jpg" alt="Figure 2.4: Trigonometric identity&#13;&#10;" width="963" height="58"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.4: Trigonometric identity</p>
			<p>Let's go through the following steps to do this:</p>
			<ol>
				<li value="1">Import the <strong class="source-inline">math</strong> package:<p class="source-code">import math </p></li>
				<li>Define two functions, <strong class="source-inline">my_sine</strong> and <strong class="source-inline">my_cosine</strong>, using the <strong class="source-inline">def</strong> keyword. The reason we are declaring these functions is the original <strong class="source-inline">sin</strong> and <strong class="source-inline">cos</strong> functions from the <strong class="source-inline">math</strong> package take <strong class="source-inline">radians</strong> as input, but we are more familiar with <strong class="source-inline">degrees</strong>. So, we will use a lambda expression to define a wrapper function for <strong class="source-inline">sine</strong> and <strong class="source-inline">cosine</strong>, then use it. This <strong class="source-inline">lambda</strong> function will automatically convert our degree input to radians and then apply <strong class="source-inline">sin</strong> or <strong class="source-inline">cos</strong> on it and return the value: <p class="source-code">def my_sine():</p><p class="source-code">    return lambda x: math.sin(math.radians(x))</p><p class="source-code">def my_cosine():</p><p class="source-code">    return lambda x: math.cos(math.radians(x)) </p></li>
				<li>Define <strong class="source-inline">sine</strong> and <strong class="source-inline">cosine</strong> for our purpose: <p class="source-code">sine = my_sine()</p><p class="source-code">cosine = my_cosine()</p><p class="source-code">math.pow(sine(30), 2) + math.pow(cosine(30), 2) </p><p>The output is as follows:</p><p class="source-code">1.0</p></li>
			</ol>
			<p>Notice that we have assigned the return value from both <strong class="source-inline">my_sine</strong> and <strong class="source-inline">my_cosine</strong> to two variables, and then used them directly as the functions. It is a much cleaner approach than using them explicitly. Notice that we did not explicitly write a <strong class="source-inline">return</strong> statement inside the lambda function; it is assumed.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/3fJW9mb">https://packt.live/3fJW9mb</a>. </p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/30Pn8by">https://packt.live/30Pn8by</a>.</p>
			<p>Now, in the next section, we will be using lambda functions, also known as anonymous functions, which come from lambda calculus. Lambda functions are useful for creating temporary functions that are not named. The lambda expression will take an input and then return the first character of that input.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor062"/>Exercise 2.05: Lambda Expression for Sorting</h2>
			<p>In this exercise, we will be exploring the <strong class="source-inline">sort</strong> function to take advantage of the lambda function. What makes this exercise useful is that you will be learning how to create any unique algorithm that could be used for sorting a dataset. The syntax for a lambda function is as follows:</p>
			<p class="source-code">lambda x  :   &lt;do something with x&gt;</p>
			<p>A lambda expression can take one or more inputs. A lambda expression can also be used to reverse sort by using the parameter of <strong class="source-inline">reverse</strong> as <strong class="source-inline">True</strong>. We'll use the reverse functionality as well in this exercise. Let's go through the following steps:</p>
			<ol>
				<li value="1">Let's store the list of tuples we want to sort in a variable called <strong class="source-inline">capitals</strong>:<p class="source-code">capitals = [("USA", "Washington"), ("India", "Delhi"), ("France", "Paris"), ("UK", "London")]</p></li>
				<li>Print the output of this list:<p class="source-code">capitals </p><p>The output will be as follows:</p><p class="source-code">[('USA', 'Washington'),</p><p class="source-code"> ('India', 'Delhi'),</p><p class="source-code"> ('France', 'Paris'),</p><p class="source-code"> ('UK', 'London')]</p></li>
				<li>Sort this list by the name of the capitals of each country, using a simple lambda expression. The following code uses a lambda function as the <strong class="source-inline">sort</strong> function. It will sort based on the first element in each tuple:<p class="source-code">capitals.sort(key=lambda item: item[1])</p><p class="source-code">capitals </p><p>The output will be as follows:</p><p class="source-code">[('India', 'Delhi'),</p><p class="source-code"> ('UK', 'London'),</p><p class="source-code"> ('France', 'Paris'),</p><p class="source-code"> ('USA', 'Washington')]</p></li>
			</ol>
			<p>As we can see, lambda expressions are powerful if we master them and use them in our data wrangling jobs. They are also side-effect-free—meaning that they do not change the values of the variables that are passed to them in place.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2AzcTxv">https://packt.live/2AzcTxv</a>. </p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3hDpe4o">https://packt.live/3hDpe4o</a>.</p>
			<p>We will now move<a id="_idTextAnchor063"/> on to the next section, where we will discuss membership checking for each element. Membership checking is commonly used terminology in qualitative research and describes the process of checking that the data present in a dataset is accurate.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor064"/>Exercise 2.06: Multi-Element Membership Checking</h2>
			<p>In this exercise, we will create a list of words using  <strong class="source-inline">for</strong> loop to validate that all the elements in the first list are present in the second list. Let's see how:</p>
			<ol>
				<li value="1">Create a <strong class="source-inline">list_of_words</strong> list with words scraped from a text corpus:<p class="source-code">list_of_words = ["Hello", "there.", "How", "are", "you", "doing?"] </p><p class="source-code">list_of_words</p><p>The output is as follows:</p><p class="source-code">['Hello', 'there.', 'How', 'are', 'you', 'doing?']</p></li>
				<li>Define a <strong class="source-inline">check_for</strong> list, which will contain two similar elements of <strong class="source-inline">list_of_words</strong>:<p class="source-code">check_for = ["How", "are"] </p><p class="source-code">check_for</p><p>The output is as follows:</p><p class="source-code">['How', 'are']</p><p>There is an elaborate solution, which involves a <strong class="source-inline">for</strong> loop and a few <strong class="source-inline">if</strong>/<strong class="source-inline">else</strong> conditions (and you should try to write it), but there is also an elegant Pythonic solution to this problem, which takes one line and uses the <strong class="source-inline">all</strong> function. The <strong class="source-inline">all</strong> function returns <strong class="source-inline">True</strong> if all elements of the iterable are <strong class="source-inline">True</strong>.</p></li>
				<li>Use the <strong class="source-inline">in</strong> keyword to check membership of the elements in the <strong class="source-inline">check_for</strong> list in <strong class="source-inline">list_of_words</strong>:<p class="source-code">all(w in list_of_words for w in check_for) </p><p>The output is as follows:</p><p class="source-code">True</p><p class="callout-heading">Note</p><p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/3d5pyVT">https://packt.live/3d5pyVT</a>. </p><p class="callout">You can also run this example online at <a href="https://packt.live/2C7GPB1">https://packt.live/2C7GPB1</a>.</p></li>
			</ol>
			<p>It is indeed elegant and simple to reason about, and this neat trick is very important while dealing with lists. Basically, what we are doing is looping over the first list with the comprehension and then looping over the second list using the <strong class="source-inline">for</strong> loop. What makes this elegant is how compactly we can represent this complex process. Caution should be taken when using very complex list comprehension—the more complex you make it, the harder it is to read.</p>
			<p>Let's look at the next data structure: a <strong class="bold">queue</strong>. </p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor065"/>Queue</h2>
			<p>Apart from stacks, another high-level data structure type that we are interested in is queues. A queue is like a stack, which means that you continue adding elements one by one. With a queue, the reading of elements obeys the <strong class="bold">First in First Out (FIFO)</strong> strategy. Check out the following diagram to understand this better:</p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="Images/B15780_02_05.jpg" alt="Figure 2.5: Pictorial representation of a queue&#13;&#10;" width="820" height="360"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.5: Pictorial representation of a queue</p>
			<p>We will accomplish this first using list methods and will show you that, for this purpose, they are inefficient. Then, we will learn about the <strong class="source-inline">dequeue</strong> data structure from the collections module of Python. A queue is a very important data structure. We can think of a scenario on a producer-consumer system design. When doing data wrangling, you will often come across a problem where you must process very big files. One of the ways to deal with this problem is to split the chunk the contents of the file into smaller parts and then push them into a queue while creating small, dedicated worker processes, to read off the queue and process one small chunk at a time. This is a very powerful design, and you can even use it efficiently to design huge multi-node data wrangling pipelines.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor066"/>Exercise 2.07: Implementing a Queue in Python</h2>
			<p>In this exercise, we'll implement a queue in Python. We'll use the <strong class="source-inline">append</strong> function to add elements to the queue and use the <strong class="source-inline">pop</strong> function to take elements out of the queue. We'll also use the <strong class="source-inline">deque</strong> data structure and compare it with the queue in order to understand the wall time required to complete the execution of an operation. To do so, perform the following steps: </p>
			<ol>
				<li value="1">Create a Python queue with the plain list methods. To record the time the <strong class="source-inline">append</strong> operation in the queue data structure takes, we use the <strong class="source-inline">%%time</strong> command:<p class="source-code">%%time</p><p class="source-code">queue = []</p><p class="source-code">for i in range(0, 100000):</p><p class="source-code">    queue.append(i)</p><p class="source-code">print("Queue created")</p><p class="source-code">queue </p><p class="callout-heading">Note</p><p class="callout"><strong class="source-inline">%%time</strong> is a regular built-in magic command in Python to capture the time required for an operation to execute.</p><p>The output (partially shown) is as follows:</p><div id="_idContainer040" class="IMG---Figure"><img src="Images/B15780_02_06.jpg" alt="Figure 2.6: Wall time recorded for the append function in the queue&#13;&#10;" width="682" height="609"/></div><p class="figure-caption">Figure 2.6: Wall time recorded for the append function in the queue</p></li>
				<li>If we were to use the <strong class="source-inline">pop</strong> function to empty the queue and check the items in it:<p class="source-code">for i in range(0, 100000):</p><p class="source-code">    queue.pop(0)</p><p class="source-code">print("Queue emptied") </p><p>The output would be as follows:</p><p class="source-code">Queue emptied</p><p>However, this time, we'll use the <strong class="source-inline">%%time</strong> magic command while executing the preceding code to see that it takes a while to finish: </p><p class="source-code">%%time</p><p class="source-code">for i in range(0, 100000):</p><p class="source-code">    queue.pop(0)</p><p class="source-code">print("Queue emptied") </p><p class="source-code">queue</p><p>The output is as follows:</p><div id="_idContainer041" class="IMG---Figure"><img src="Images/B15780_02_07.jpg" alt="Figure 2.7: Wall time recorded for the pop function in the queue&#13;&#10;" width="733" height="85"/></div><p class="figure-caption">Figure 2.7: Wall time recorded for the pop function in the queue</p><p class="callout-heading">Note</p><p class="callout">If you are working on Google Colab or other virtual environments, you will see an additional line indicating the CPU time present in the output. This is the CPU time of the server on which Google Colab (or any other virtual environment) is running on. However, if you are working on your local system, this information will not be a part of the output. </p><p>In a modern MacBook, with a quad-core processor and <strong class="source-inline">8</strong> GB of RAM, it took around <strong class="source-inline">1.20</strong> seconds to finish. With Windows 10, it took around 2.24 seconds to finish. It takes this amount of time because of the <strong class="source-inline">pop(0)</strong> operation, which means every time we pop a value from the left of the list (the current <strong class="source-inline">0</strong> index), Python has to rearrange all the other elements of the list by shifting them one space left. Indeed, it is not a very optimized implementation. </p></li>
				<li>Implement the same queue using the <strong class="source-inline">deque</strong> data structure from Python's <strong class="source-inline">collections</strong> package and perform the <strong class="source-inline">append</strong> and <strong class="source-inline">pop</strong> functions on this data structure:<p class="source-code">%%time</p><p class="source-code">from collections import deque</p><p class="source-code">queue2 = deque()</p><p class="source-code">for i in range(0, 100000):</p><p class="source-code">    queue2.append(i)</p><p class="source-code">print("Queue created")</p><p class="source-code">for i in range(0, 100000):</p><p class="source-code">    queue2.popleft()</p><p class="source-code">print("Queue emptied") </p><p>The output is as follows:</p><div id="_idContainer042" class="IMG---Figure"><img src="Images/B15780_02_08.jpg" alt="Figure 2.8: Wall time measured for deque&#13;&#10;" width="661" height="118"/></div></li>
			</ol>
			<p class="figure-caption">Figure 2.8: Wall time measured for deque</p>
			<p>With the specialized and optimized queue implementation from Python's standard library, the time that this should take for both the operations is only approximately <strong class="source-inline">27.9</strong> milliseconds. This is a huge improvement on the previous one.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/30R69Wc">https://packt.live/30R69Wc</a>. </p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3dazIEL">https://packt.live/3dazIEL</a>.</p>
			<p>We will end the discussion on data structures here. What we discussed here is just the tip of the iceberg. Data structures are a fascinating subject. There are many other data structures that we did not touch on and that, when used efficiently, can offer enormous added value. We strongly encourage you to explore data structures more. Try to learn about linked lists, trees, graphs, and all the different variations of them as much as you can; you will find there are many similarities between them and you will benefit greatly from studying them. Not only do they offer the joy of learning, but they are also the secret mega-weapons in the arsenal of a data practitioner that you can bring out every time you are challenged with a difficult data wrangling job.</p>
			<h2 id="_idParaDest-65">Activity<a id="_idTextAnchor067"/> 2.01: Permutation, Iterator, Lambda, and List</h2>
			<p>In this activity, we will be using <strong class="source-inline">permutations</strong> to generate all possible three-digit numbers that can be generated using <strong class="source-inline">0</strong>, <strong class="source-inline">1</strong>, and <strong class="source-inline">2</strong>. A permutation is a mathematical way to represent all possible outcomes. Then, we'll loop over this iterator and also use <strong class="source-inline">isinstance</strong> and <strong class="source-inline">assert</strong> to make sure that the return types are tuples. Use a single line of code involving <strong class="source-inline">dropwhile</strong> and <strong class="source-inline">lambda</strong> expressions to convert all the tuples to lists while dropping any leading zeros (for example, <strong class="source-inline">(0, 1, 2)</strong> becomes <strong class="source-inline">[1, 2]</strong>). Finally, we will write a function that takes a list like before and returns the actual number contained in it. </p>
			<p>These steps will guide you as to how to solve this activity:</p>
			<ol>
				<li value="1">Look up the definition of <strong class="source-inline">permutations</strong> and <strong class="source-inline">dropwhile</strong> from <strong class="source-inline">itertools</strong>.</li>
				<li>Write an expression to generate all the possible three-digit numbers, using <strong class="source-inline">0</strong>, <strong class="source-inline">1</strong>, and <strong class="source-inline">2</strong>.</li>
				<li>Loop over the iterator expression you generated before. Print each element returned by the iterator. Use <strong class="source-inline">assert</strong> and <strong class="source-inline">isinstance</strong> to make sure that the elements are of the tuple type.</li>
				<li>Write the loop again, using <strong class="source-inline">dropwhile</strong>, with a lambda expression to drop any leading zeros from the tuples. As an example, <strong class="source-inline">(0, 1, 2)</strong> will become <strong class="source-inline">[0, 2]</strong>. Also, cast the output of <strong class="source-inline">dropwhile</strong> to a list.</li>
				<li>Check the actual type that <strong class="source-inline">dropwhile</strong> returns.</li>
				<li>Combine the preceding code into one block; this time, write a separate function where you will pass the list generated from <strong class="source-inline">dropwhile</strong> and the function will return the whole number contained in the list. As an example, if you pass <strong class="source-inline">[1, 2]</strong> to the function, it will return <strong class="source-inline">12</strong>. Make sure that the return type is indeed a number and not a string. Although this task can be achieved using other tricks, treat the incoming list as a stack in the function and generate the number by reading the individual digits from the stack.<p>The final output should look like this:</p><p class="source-code">12.0</p><p class="source-code">21.0</p><p class="source-code">102.0</p><p class="source-code">120.0</p><p class="source-code">201.0</p><p class="source-code">210.0</p><p class="callout-heading">Note</p><p class="callout">The solution for this activity can be found via <a href="B15780_Solution_Final_RK.xhtml#_idTextAnchor307">this link</a>.</p></li>
			</ol>
			<p>With this activity, we have finished this topic and will move on to the next topic, which involves basic file-level operations. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">We encourage you to think about a solution to the preceding problem without using all the advanced operations and data structures we have used here. You will soon realize how complex the solution is, and how much more detailed it must be. Then, you will understand how much value these data structures and operations bring.</p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor068"/>Basic File Operations in Python</h1>
			<p>In the previous topic, we investigated a few advanced data structures and also learned neat and useful functional programming methods to manipulate them without side effects. In this topic, we will learn about a few OS-level functions in Python, such as working with files, but these could also include working with printers, and even the internet. We will concentrate mainly on file-related functions and learn how to open a file, read the data line by line or all at once, and finally, how to cleanly close the file we opened. The closing operation of a file should be done cautiously, which is ignored most of the time by developers. When handling file operations, we often run into very strange and hard-to-track-down bugs because a process opened a file and did not close it properly. We will apply a few of the techniques we have learned about to a file that we will read to practice our data wrangling skills further.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor069"/>Exercise 2.08: File Operations</h2>
			<p>In this exercise, we will learn about the OS module of Python, and we will also look at two very useful ways to write and read environment variables. The power of writing and reading environment variables is often very important when designing and developing data-wrangling pipelines. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">In fact, one of the factors of the famous 12-factor app design is the very idea of storing configuration in the environment. You can check it out at this URL: <a href="https://12factor.net/config">https://12factor.net/config</a>.</p>
			<p>The purpose of the OS module is to give you ways to interact with OS-dependent functionalities. In general, it is pretty low-level and most of the functions from there are not useful on a day-to-day basis; however, some are worth learning. <strong class="source-inline">os.environ</strong> is the collection Python maintains with all the present environment variables in your OS. It gives you the power to create new ones. The <strong class="source-inline">os.getenv</strong> function gives you the ability to read an environment variable:</p>
			<ol>
				<li value="1">Import the <strong class="source-inline">os</strong> module.<p class="source-code">import os </p></li>
				<li>Set a few environment variables:<p class="source-code">os.environ['MY_KEY'] = "MY_VAL"</p><p class="source-code">os.getenv('MY_KEY') </p><p>The output is as follows:</p><p class="source-code">'MY_VAL'</p></li>
				<li>Print the environment variable when it is not set:<p class="source-code">print(os.getenv('MY_KEY_NOT_SET')) </p><p>The output is as follows:</p><p class="source-code">None</p></li>
				<li>Print the <strong class="source-inline">os</strong> environment:<p class="source-code">print(os.environ) </p><p class="callout-heading">Note</p><p class="callout">The output has not been added for security reasons.</p><p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2YCZAnC">https://packt.live/2YCZAnC</a>. </p><p class="callout">You can also run this example online at <a href="https://packt.live/3fCqnaB">https://packt.live/3fCqnaB</a>.</p></li>
			</ol>
			<p>After executing the preceding code, you will be able to see that you have successfully printed the value of <strong class="source-inline">MY_KEY</strong>, and when you tried to print <strong class="source-inline">MY_KEY_NOT_SET</strong>, it printed <strong class="source-inline">None</strong>. Therefore, utilizing the OS module, you will be able to set the value of environment variables in your system. </p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor070"/>File Handling</h2>
			<p>In this section, we will learn about how to open a file in Python. We will learn about the different modes that we can use and what they stand for when opening a file. Python has a built-in <strong class="source-inline">open</strong> function that we will use to open a file. The <strong class="source-inline">open</strong> function takes a few arguments as input. Among them, the first one, which stands for the name of the file you want to open, is the only one that's mandatory. Everything else has a default value. When you call <strong class="source-inline">open</strong>, Python uses underlying system-level calls to open a file handler and return it to the caller. </p>
			<p>Usually, a file can be opened either for reading or writing. If we open a file in one mode, the other operation is not supported. Whereas reading usually means we start to read from the beginning of an existing file, writing can mean either starting a new file and writing from the beginning or opening an existing file and appending to it. </p>
			<p>Here is a table showing you all the different modes Python supports for opening a file:</p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="Images/B15780_02_09.jpg" alt="Figure 2.9: Modes to read a file&#13;&#10;" width="694" height="273"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.9: Modes to read a file</p>
			<p>There is also a deprecated mode, <strong class="source-inline">U</strong>, which does nothing in a Python 3 environment. One thing we must remember here is that Python will always differentiate between <strong class="source-inline">t</strong> and <strong class="source-inline">b</strong> modes, even if the underlying OS doesn't. This is because, in <strong class="source-inline">b</strong> mode, Python does not try to decode what it is reading and gives us back the <strong class="source-inline">byteobject</strong> instead, whereas, in <strong class="source-inline">t</strong> mode, it does try to decode the stream and gives us back the <strong class="source-inline">string</strong> representation. </p>
			<p>You can open a file for reading with the command that follows. The path (highlighted) would need to be changed based on the location of the file on your system.</p>
			<p class="source-code">fd = open("<strong class="bold">../datasets/data_temporary_files.txt</strong>")</p>
			<p>We will discuss some more functions in the following section.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The file can be found here <a href="https://packt.live/2YGpbfv">https://packt.live/2YGpbfv</a>.</p>
			<p>This is opened in <strong class="source-inline">rt</strong> mode (opened for the <strong class="source-inline">reading+text</strong> mode). You can open the same file in <strong class="source-inline">binary</strong> mode if you want. To open the file in binary mode, use the <strong class="source-inline">rb (read, byte)</strong> mode:</p>
			<p class="source-code">fd = open('AA.txt',"rb")</p>
			<p class="source-code">fd</p>
			<p>The output is as follows:</p>
			<p class="source-code">&lt;_io.BufferedReader name='../datasets/AA.txt'&gt;</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The file can be found here: <a href="https://packt.live/30OSkaP">https://packt.live/30OSkaP</a>. </p>
			<p>This is how we open a file for writing:</p>
			<p class="source-code">fd = open("../datasets/data_temporary_files.txt ", "w")</p>
			<p class="source-code">fd</p>
			<p>The output is as follows:</p>
			<p class="source-code">&lt;_io.TextIOWrapper name='../datasets/data_temporary_files.txt ' mode='w' encoding='cp1252'&gt;</p>
			<p>Let's practice this concept in the following exercise.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor071"/>Exercise 2.09: Opening and Closing a File</h2>
			<p>In this exercise, we will learn how to close a file after opening it.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The file we will be working on can be found here: <a href="https://packt.live/30OSkaP">https://packt.live/30OSkaP</a>. </p>
			<p>We must close a file once we have opened it. A lot of system-level bugs can occur due to a dangling file handler, which means the file is still being modified, even though the application is done using it. Once we close a file, no further operations can be performed on that file using that specific file handler.</p>
			<ol>
				<li value="1">Open a file in binary mode: <p class="source-code">fd = open("<strong class="bold">../datasets/AA.txt</strong>", "rb")</p><p class="callout-heading">Note</p><p class="callout">Change the highlighted path based on the location of the file on your system. The video of this exercise shows how to use the same function on a different file. There, you'll also get a glimpse of the function used to write to files, which is something you'll learn about later in the chapter. </p></li>
				<li>Close a file using <strong class="source-inline">close()</strong>: <p class="source-code">fd.close()</p></li>
			</ol>
			<p>Python also gives us a <strong class="source-inline">closed</strong> flag with the file handler. If we print it before closing, then we will see <strong class="source-inline">False</strong>, whereas if we print it after closing, then we will see <strong class="source-inline">True</strong>. If our logic checks whether a file is properly closed or not, then this is the flag we want to use.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/30R6FDC">https://packt.live/30R6FDC</a>. </p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3edLoI8">https://packt.live/3edLoI8</a>.</p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor072"/>The with Statement</h2>
			<p>In this section, we will learn about the <strong class="source-inline">with</strong> statement in Python and how we can effectively use it in the context of opening and closing files. </p>
			<p>The <strong class="source-inline">with</strong> command is a compound statement in Python, like <strong class="source-inline">if</strong> and <strong class="source-inline">for</strong>, designed to combine multiple lines. Like any compound statement, <strong class="source-inline">with</strong> also affects the execution of the code enclosed by it. In the case of <strong class="source-inline">with</strong>, it is used to wrap a block of code in the scope of what we call a <em class="italic">Context Manager</em> in Python. A context manager is a convenient way to work with resources and will help avoid forgetting to close the resource. A detailed discussion of context managers is out of the scope of this exercise and this topic in general, but it is sufficient to say that if a context manager is implemented inside the <strong class="source-inline">open</strong> call for opening a file in Python, it is guaranteed that a close call will automatically be made if we wrap it inside a <strong class="source-inline">with</strong> statement. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">There is an entire PEP for <strong class="source-inline">with</strong> at <a href="https://www.python.org/dev/peps/pep-0343/">https://www.python.org/dev/peps/pep-0343/</a>. We encourage you to look into it.</p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor073"/>Opening a File Using the with Statement</h2>
			<p>Open a file using the <strong class="source-inline">with</strong> statement:</p>
			<p class="source-code">with open("../datasets/AA.txt") as fd:</p>
			<p class="source-code">    print(fd.closed)</p>
			<p class="source-code">print(fd.closed) </p>
			<p>The output is as follows:</p>
			<p class="source-code">False</p>
			<p class="source-code">True</p>
			<p>If we execute the preceding code, we will see that the first <strong class="source-inline">print</strong> will end up printing <strong class="source-inline">False</strong>, whereas the second one will print <strong class="source-inline">True</strong>. This means that as soon as the control goes out of the <strong class="source-inline">with</strong> block, the file descriptor is automatically closed.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">This is by far the cleanest and most Pythonic way to open a file and obtain a file descriptor for it. We encourage you to use this pattern whenever you need to open a file by yourself. </p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor074"/>Exercise 2.10: Reading a File Line by Line</h2>
			<p>In this exercise, we'll read a file line by line. Let's go through the following steps to do so: </p>
			<ol>
				<li value="1">Open a file and then read the file line by line and print it as we read it:<p class="source-code">with open("<strong class="bold">../datasets/Alice`s Adventures in Wonderland, "\</strong></p><p class="source-code"><strong class="bold">          "by Lewis Carroll</strong>", encoding="utf8") as fd: </p><p class="source-code">    for line in fd: </p><p class="source-code">        print(line)</p><p class="callout-heading">Note</p><p class="callout">Do not forget to change the path (highlighted) of the file based on its location on your system.</p><p>The output (partially shown) is as follows:</p><div id="_idContainer044" class="IMG---Figure"><img src="Images/B15780_02_10.jpg" alt="Figure 2.10: Screenshot from the Jupyter notebook&#13;&#10;" width="1343" height="505"/></div><p class="figure-caption">Figure 2.10: Screenshot from the Jupyter notebook</p><p>Looking at the preceding code, we can see why it is important. With this short snippet of code, you can even open and read files that are many gigabytes in size, line by line, and without flooding or overrunning the system memory. There is another explicit method in the file descriptor object, called <strong class="source-inline">readline</strong>, which reads one line at a time from a file.</p></li>
				<li>Duplicate the same <strong class="source-inline">for</strong> loop, just after the first one: <p class="source-code">with open("<strong class="bold">../datasets/Alice`s Adventures in Wonderland, "\</strong></p><p class="source-code"><strong class="bold">          "by Lewis Carroll</strong>", encoding="utf8") as fd: </p><p class="source-code">    for line in fd:</p><p class="source-code">        print(line)</p><p class="source-code">    print("Ended first loop")</p><p class="source-code">    for line in fd:</p><p class="source-code">        print(line)</p><p class="callout-heading">Note</p><p class="callout">Do not forget to change the path (highlighted) of the file based on its location on your system.</p><p>The output (partially shown) is as follows:</p><div id="_idContainer045" class="IMG---Figure"><img src="Images/B15780_02_11.jpg" alt="Figure 2.11: Section of the open file&#13;&#10;" width="1265" height="483"/></div></li>
			</ol>
			<p class="figure-caption">Figure 2.11: Section of the open file</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/37B7aTX">https://packt.live/37B7aTX</a>. </p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3fCqWBf">https://packt.live/3fCqWBf</a>.</p>
			<p>Let's look at the last exercise of this chapter.</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor075"/>Exercise 2.11: Writing to a File</h2>
			<p>In this exercise, we'll look into file operations by showing you how to read from a dictionary and write to a file. We will write a few lines to a file and read the file: </p>
			<p class="callout-heading">Note</p>
			<p class="callout"><strong class="source-inline">data_temporary_files.txt</strong> can be found at <a href="https://packt.live/2YGpbfv">https://packt.live/2YGpbfv</a>.</p>
			<p>Let's go through the following steps:</p>
			<ol>
				<li value="1">Use the <strong class="source-inline">write</strong> function from the file descriptor object:<p class="source-code">data_dict = {"India": "Delhi", "France": "Paris",\</p><p class="source-code">             "UK": "London", "USA": "Washington"}</p><p class="source-code">with open("<strong class="bold">../datasets/data_temporary_files.txt</strong>", "w") as fd:</p><p class="source-code">    for country, capital in data_dict.items():</p><p class="source-code">        fd.write("The capital of {} is {}\n"\</p><p class="source-code">                 .format(country, capital))</p><p class="callout-heading">Note</p><p class="callout">Throughout this exercise, don't forget to change the path (highlighted) based on where you have stored the text file.</p></li>
				<li>Read the file using the following command:<p class="source-code">with open("<strong class="bold">../datasets/data_temporary_files.txt</strong>", "r") as fd:</p><p class="source-code">    for line in fd:</p><p class="source-code">        print(line)</p><p>The output is as follows:</p><p class="source-code">The capital of India is Delhi</p><p class="source-code">The capital of France is Paris</p><p class="source-code">The capital of UK is London</p><p class="source-code">The capital of USA is Washington</p></li>
				<li>Use the <strong class="source-inline">print</strong> function to write to a file using the following command:<p class="source-code">data_dict_2 = {"China": "Beijing", "Japan": "Tokyo"}</p><p class="source-code">with open("<strong class="bold">../datasets/data_temporary_files.txt</strong>", "a") as fd:</p><p class="source-code">    for country, capital in data_dict_2.items():</p><p class="source-code">        print("The capital of {} is {}"\</p><p class="source-code">              .format(country, capital), file=fd)</p></li>
				<li>Read the file using the following command:<p class="source-code">with open("<strong class="bold">../datasets/data_temporary_files.txt</strong>", "r") as fd:</p><p class="source-code">    for line in fd:</p><p class="source-code">        print(line)</p><p>The output is as follows:</p><p class="source-code">The capital of India is Delhi</p><p class="source-code">The capital of France is Paris</p><p class="source-code">The capital of UK is London</p><p class="source-code">The capital of USA is Washington</p><p class="source-code">The capital of China is Beijing</p><p class="source-code">The capital of Japan is Tokyo</p><p class="callout-heading">Note</p><p class="callout">In the second case, we did not add an extra newline character, <strong class="source-inline">\n</strong>, at the end of the string to be written. The <strong class="source-inline">print</strong> function does that automatically for us.</p><p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2BkVh8j">https://packt.live/2BkVh8j</a>. </p><p class="callout">You can also run this example online at <a href="https://packt.live/3hB7xT0">https://packt.live/3hB7xT0</a>.</p></li>
			</ol>
			<p>With this, we will end this topic. Just like the previous topics, we have designed an activity for you to practice your newly acquired skills.</p>
			<h2 id="_idParaDest-74">Activity 2.<a id="_idTextAnchor076"/>02: Designing Your Own CSV Parser</h2>
			<p>A CSV file is something you will encounter a lot in your life as a data practitioner. A CSV file is a comma-separated file where data from a tabular format is generally stored and separated using commas, although other characters can also be used, such as <strong class="source-inline">tab</strong> or <strong class="source-inline">*</strong>. Here's an example CSV file:</p>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<img src="Images/B15780_02_12.jpg" alt="Figure 2.12: Partial output of a CSV file&#13;&#10;" width="644" height="179"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.12: Partial output of a CSV file</p>
			<p>In this activity, we will be tasked with building our own CSV reader and parser. Although it is a big task if we try to cover all use cases and edge cases, along with escape characters, for the sake of this short activity, we will keep our requirements small. We will assume that there is no escape character—meaning that if you use a comma at any place in your row, you are starting a new column. We will also assume that the only function we are interested in is to be able to read a CSV file line by line, where each read will generate a new dictionary with the column names as keys and row names as values.</p>
			<p>Here is an example:</p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="Images/B15780_02_13.jpg" alt="Figure 2.13: Table with sample data&#13;&#10;" width="1462" height="246"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.13: Table with sample data</p>
			<p>We can convert the data in the preceding table into a Python dictionary, which would look as follows: <strong class="source-inline">{"Name": "Bob", "Age": "24", "Location": "California"}</strong>:</p>
			<ol>
				<li value="1">Import <strong class="source-inline">zip_longest</strong> from <strong class="source-inline">itertools</strong>. Create a function to zip <strong class="source-inline">header</strong>, <strong class="source-inline">line</strong>, and <strong class="source-inline">fillvalue=None</strong>.<p>Open the accompanying <strong class="source-inline">sales_record.csv</strong> file from the GitHub link (<a href="https://packt.live/2Yb6iCh">https://packt.live/2Yb6iCh</a>) by using <strong class="source-inline">r</strong> mode inside a <strong class="source-inline">with</strong> block and check that it is opened.</p></li>
				<li>Read the first line and use string methods to generate a list of all the column names.</li>
				<li>Start reading the file. Read it line by line.</li>
				<li>Read each line and pass that line to a function, along with the list of the headers. The work of the function is to construct a <strong class="source-inline">dictionary</strong> out of these two and fill up the <strong class="source-inline">key:values</strong> variables. Keep in mind that a missing value should result in <strong class="source-inline">None</strong>.<p>The partial output of this should look like this:</p></li>
			</ol>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="Images/B15780_02_14.jpg" alt="Figure 2.14: Partial output of the sales_record file&#13;&#10;" width="628" height="171"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.14: Partial output of the sales_record file</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found via <a href="B15780_Solution_Final_RK.xhtml#_idTextAnchor309">this link</a>.</p>
			<p>With this, we conclude the chapter.</p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor077"/>Summary</h1>
			<p>This chapter covered manipulation techniques of advanced data structures such as stacks and queues. We then focused on different methods of functional programming, including iterators, and combined lists and functions together. Later, we looked at OS-level functions and the management of environment variables. We examined how, using Python, we can open, close, and even write to local files in a variety of ways. Knowing how to deal with files in a clean way is a critical skill in a data wrangler's repertoire. Toward the end, we tested our newly learned skills by creating our own CSV parser.</p>
			<p>In the next chapter, we will be dealing with the three most important libraries, namely <strong class="source-inline">NumPy</strong>, <strong class="source-inline">pandas</strong>, and <strong class="source-inline">matplotlib</strong>.</p>
		</div>
		<div>
			<div id="_idContainer050" class="Content">
			</div>
		</div>
	</div></body></html>