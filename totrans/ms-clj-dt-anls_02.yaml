- en: Chapter 2. GIS Analysis – Mapping Climate Change
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One area of data analysis that's gotten a lot of attention is **Geographic Information
    Systems** (**GIS**). GIS is a system that is designed to store, manage, manipulate,
    and analyze geographic data. As such, GIS sits at the intersection of cartography,
    computers, statistics, and information science.
  prefs: []
  type: TYPE_NORMAL
- en: GIS is applied to fields as diverse as military planning, epidemiology, architecture,
    urban planning, archaeology, and many other fields. Basically, any domain or problem
    that involves location or topology can use GIS techniques or methods.
  prefs: []
  type: TYPE_NORMAL
- en: As you can imagine from this very brief description, we won't even scratch the
    surface of GIS in this chapter. However, we'll apply it to a small problem to
    see how it can help us understand the way climate change affects the continental
    **United States** in a better manner.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding GIS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the preceding description is accurate, it doesn't really help us much.
    As befits a field concerned with the lay of the land, GIS really begins in the
    field. Data is gathered using aerial and satellite photography, and it is also
    gathered from people on the ground using GPS, laser range finders, and surveying
    tools. GIS can also make use of existing maps, especially for historical research
    and to compare time periods. For example, this may involve studying how a city
    has evolved over time or national boundaries have changed. A lot of time and energy
    in GIS goes into gathering this data and entering it into the computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the data is in the computer, GIS can perform a wide range and variety
    of analyses on the data, depending on the questions being asked and the task at
    hand. For example, the following are some of the many things you can do with GIS:'
  prefs: []
  type: TYPE_NORMAL
- en: '**View-shed analysis**: This attempts to answer the question, "What can someone
    standing right here at this elevation (and perhaps at a second story window) see?".
    This takes into account the elevation and slope of the terrain around the viewer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Topological modeling**: This combines the GIS data with other data in the
    data mining and modeling to add a geospatial component to more mainstream data
    mining and modeling. This allows the models to account for the geographical proximity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hydrological modeling**: This models the way in which water interacts with
    the environment through rainfall, watershed, runoff, and catchment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Geocoding**: This involves associating human-readable addresses with their
    geospatial coordinates. When you click on a **Google Map** or **Bing Map** and
    get the business or address of a location, it''s because it''s been geocoded for
    the coordinates you tapped on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The primary tool for most GIS specialists is **ArcGIS** by **ESRI** ([http://www.esri.com/](http://www.esri.com/)).
    This is a powerful, full-featured GIS workbench. It interoperates with most data
    sources and performs most of the analyses. It also has an **API** for **Python**
    and APIs in **Java** and **.NET** to interact with ArcGIS servers. We'll use ArcGIS
    at the end of this chapter to generate the visualization.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are other options as well. Most databases have some GIS capabilities,
    and **Quantum GIS** ([http://www.qgis.org/](http://www.qgis.org/)) is an open
    source alternative to ArcGIS. It isn't as polished or as fully featured, but it's
    still powerful in its own right and is freely available. **GeoServer** ([http://geoserver.org/](http://geoserver.org/))
    is an enterprise-level server and management system for the GIS data. There are
    also libraries in a number of programming languages; **Geospatial Data Abstraction
    Layer**, also known as **GDAL**, ([http://www.gdal.org/](http://www.gdal.org/))
    deserves special mention here, both in its own right and because it serves as
    the foundation for libraries in a number of other programming languages. One of
    the libraries for Java is **GeoTools** ([http://www.geotools.org/](http://www.geotools.org/)),
    and part of it calls GDAL under the table.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping the climate change
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, let's roll up our sleeves and perform some geospatially informed data analysis.
  prefs: []
  type: TYPE_NORMAL
- en: For our problem, we'll look at how the climate change affects the continental
    United States over the last century or so. Specifically, we'll look at how the
    average maximum temperature for July has changed. For North America, this should
    give us a good snapshot of the hottest temperatures.
  prefs: []
  type: TYPE_NORMAL
- en: One nice thing about working with the weather data is that there's a lot of
    it, and it's easily available. **US National Oceanic and Atmospheric Administration**
    (**NOAA**) collects it and maintains archives of it.
  prefs: []
  type: TYPE_NORMAL
- en: For this project, we'll use the **Global Summary of the Day** ([http://www.ncdc.noaa.gov/cgi-bin/res40.pl](http://www.ncdc.noaa.gov/cgi-bin/res40.pl)).
    This includes daily summaries from each active weather station. We'll filter out
    any weather stations that aren't in the US, and we'll filter out any data that
    is not in use for the month of July.
  prefs: []
  type: TYPE_NORMAL
- en: Climate is typically defined on thirty-year periods. For example, the climate
    for a location would be the average temperature of thirty years, not the temperature
    for the year. However, there won't be that many thirty-year periods for the time
    span that we're covering, so instead, we'll look at the maximum temperature for
    July from each weather station in ten-year rolling averages.
  prefs: []
  type: TYPE_NORMAL
- en: To find out how much the maximum temperature has changed, we'll find the rolling
    average for these ten-year periods. Then, for each station, we'll find the difference
    between the first ten year period's average and the last one's.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the stations aren't evenly or closely spaced; as we'll see, they
    also open and close over the years. So we'll do the best we can with this data,
    and we'll fill in the geospatial gaps in the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we''ll graph this data over a map of the US. This will make it easy
    to see how temperatures have changed in different places. What will this process
    look like? Let''s outline the steps for the rest of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the data from NOAA's FTP servers. Extract it from the files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Filter out the data that we won't need for this analysis. We'll only hang onto
    places and the month that we're interested in (the US for July).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Average the maximum temperatures for each month.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the ten-year rolling averages of the averages from step three.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the difference between the first and last ten-year averages for each weather
    station.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Interpolate the temperature differences for the areas between the stations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a heat map of the differences.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Downloading and extracting the data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned above, NOAA maintains an archive of GSOD. For each weather station
    around the world, these daily summaries track a wide variety of weather data for
    all active weather stations around the globe. We'll use the data from here as
    the basis of our analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data is available at [ftp://ftp.ncdc.noaa.gov/pub/data/gsod/](ftp://ftp.ncdc.noaa.gov/pub/data/gsod/).
    Let''s look at how this data is stored and structured:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Downloading and extracting the data](img/4139OS_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, the main directory on the FTP site (`/pub/data/gsod/`) has a directory for
    each year that has the weather data. There's also a file called `ish-history.csv`.
    This contains information about the weather stations, when they were operational,
    and where they were located. (Also, the text files and `README` files are always
    important for more specific, detailed information about what's in each file.)
  prefs: []
  type: TYPE_NORMAL
- en: Now let's check out one of the data directories; this is for 2013.
  prefs: []
  type: TYPE_NORMAL
- en: The data directories contain a large number of data files. Each of the files
    that ends in `.op.gz` has three components for its file name. The first two parts
    are identifiers for the weather station and the third is the year.
  prefs: []
  type: TYPE_NORMAL
- en: Each data directory also has a tarball that contains all of the `*.op.gz` data
    files. That file will be the easiest to download, and then we can extract the
    `*.op.gz` files from it. Afterwards, we'll need to decompress these files to get
    the `*.op` data files. Let's do that, and then we can look at the data that we
    have.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading the files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we actually get into any of the code to do this, let's take a look at
    the dependencies that we'll need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get started, let''s set up our project. For this chapter, our Leiningen
    2 ([http://leiningen.org/](http://leiningen.org/)) `project.clj` file should look
    something like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for this section of code, let''s open the `src/clj_gis/download.clj` file.
    We''ll use this namespace declaration for this code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the next two functions together download the GSOD data files. The main
    function is `download-data`. It walks the directory tree on the FTP server, and
    whenever it identifies a file to be downloaded, it hands it off to `download-file`.
    This function figures out where to put the file and downloads it to that location.
    I''ve left out the source code for some of the utilities and secondary functions
    listed here, such as `download-src`, so that we can focus on the larger issues.
    You can find these functions in the file in this chapter''s code download. The
    following code snippet is part of the code that is available for download:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Extracting the files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, we've downloaded the files from the NOAA FTP server onto the local hard
    drive. However, we still need to use the `tar` utility to extract the files we've
    downloaded and then decompress them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use the **FS** library to extract the downloaded files. Currently, the
    individual data files are in a common Unix file format called `tar`, which collects
    multiple files into one larger file. These files are also compressed using the
    utility **gzip**. We''ll use Java''s `GZIPOutputStream` to decompress `gz`. Let''s
    see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can put these functions together with the download functions that we just
    looked at. This function, `download-all`, will download all the data and then
    decompress all of the data files into a directory specified by `clj-gis.locations/*data-dir*`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, what do these files look like? The header line of one of them is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is one of the data rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: So, there are some identification fields, some for temperature, dew point, wind,
    and other weather data. Next, let's see how to winnow the data down to just the
    information that we plan to use.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming the data – filtering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we just noticed, there''s a lot of data in the GSOD files that we don''t
    plan to use. This includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Too many files with data for places that we aren't interested in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Too many rows with data for months that we aren't interested in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Too many columns with weather data that we aren't interested in (dew points,
    for instance)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, we'll only worry about the first problem. Just filtering out
    the places we're not looking at will dramatically reduce the amount of data that
    we're dealing with from approximately 20 GB of data to just 3 GB.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this section will be in the `src/clj_gis/filter_data.clj` file.
    Give it the following namespace declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now it's time for the code that is to be put in the rest of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To filter out the data that we won''t use, we''ll copy files for stations in
    the United States into their own directory. We can create a set of these stations
    from the `ish-history.csv` file that we noticed earlier, so our first task will
    be parsing that file. This code will read the CSV file and put the data from each
    line into a new data record, `IshHistory`. Having its own data type for this information
    isn''t necessary, but it makes the rest of the code much more readable. For example,
    we can reference the country field using `(:country h)` instead of `(nth h 3)`
    later. This type can also reflect the column order from the input file, which
    makes reading the data easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The stations are identified by the combination of the USAF and WBAN fields.
    Some stations use USAF, some use WBAN, and some use both. So we''ll need to track
    both to uniquely identify the stations. This function will create a set of the
    stations in a given country:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to tie these functions together. This function, `filter-data-files`,
    reads the history and creates the set of stations that we want to keep. Then,
    it walks through the data directory and parses the file names to get the station
    identifiers for each file. Files from the stations in the set are then copied
    to a directory with the same name as the country code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This set of functions will filter out most of the data and leave us with only
    the observations from the stations we're interested in.
  prefs: []
  type: TYPE_NORMAL
- en: Rolling averages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We aren''t plotting the raw data. Instead, we want to filter it further and
    summarize it. This transformation can be described in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Process only the observations for the month of July.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the mean temperature for the observations for the month of July for each
    year, so we'll have an average for July 2013, July 2012, July 2011, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Group these monthly averages into rolling ten-year windows. For example, one
    window will have the observations for 1950 to 1960, another window will have observations
    for 1951 to 1961, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the mean temperature for each of these windows for a climatic average temperature
    for July for that period.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the change in the maximum temperature by subtracting the climatic
    average for the last window for a station from the average of its first window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This breaks down the rest of the transformation process pretty well. We can
    use this to help us structure and write the functions that we'll need to implement
    the process. However, before we can get into that, we need to read the data.
  prefs: []
  type: TYPE_NORMAL
- en: Reading the data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ll read the data from the space-delimited data files and store the rows
    in a new record type. For this section, let''s create the `src/clj_gis/rolling_avg.clj`
    file. It will begin with the following namespace declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can define a data type for the weather data. We''ll read the data into
    an instance of `WeatherRow`, and then we''ll need to normalize the data to make
    sure that the values are ones that we can use. This will involve converting strings
    to numbers and dates, for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the weather data, we can work it through the pipeline as outlined
    in the preceding code snippet. This series of functions will construct a sequence
    of reducers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Reducers**, introduced in Clojure 1.5, are a relatively new addition to the
    language. They refine traditional functional-style programming. Instead of `map`
    taking a function and a sequence and constructing a new sequence, the reducers''
    version of `map` takes a function and a sequence or folder (the core reducer data
    type) and constructs a new folder that will apply the function to the elements
    of the input when required. So, instead of constructing a series of sequences,
    it composes the functions into a larger function that performs the same processing,
    but only produces the final output. This saves on allocating the memory, and if
    the input data types are structured correctly, the processing can also be automatically
    parallelized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the first step, we want to return only the rows that fall in the month
    we''re interested in. This looks almost exactly like a regular call to `filter`,
    but instead of returning a new, lazy sequence, it returns a folder that has the
    same effect; it produces a sequence with only the data rows we want. Or, we can
    compose this with other folders to further modify the output. This is what we
    will do in the next few steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This function takes the reducer from the first step and passes it through a
    few more steps. The `group-by` function finally reifies the sequence into a hash
    map. However, it''s immediately fed into another reducer chain that averages the
    accumulated temperatures for each month:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For step three, we create a series of moving windows across the monthly averages.
    If there aren''t enough averages to create a full window, or if there are only
    enough to create one window, then we throw those extra observations out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This step uses a utility function, `mean`, to get the average temperature for
    each window. We saw this defined in step two. This keeps hold of the starting
    year for that window so they can be properly ordered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After this, we do a little more filtering to only pass the averages through,and
    then we replace the list of averages with the difference between the initial and
    the final averages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There's more to this, of course. We have to get a list of the files to be processed,
    and we need to do something with the output; either send it to a vector or to
    a file.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've made it this far, we're done transforming our data, and we're
    ready to start our analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Interpolating sample points and generating heat maps using inverse distance
    weighting (IDW)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the end, we're going to feed the data we've just created to ArcGIS in order
    to create the heat map, but before we do that, let's try to understand what will
    happen under the covers.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this code, let''s open up the `src/clj_gis/idw.clj` file. The namespace
    for this should be like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: To generate a **heat map**, we first start with a sample of points for the space
    we're looking at. Often, this space is geographical, but it doesn't have to be.
    Values for a complex, computationally-expensive, two-dimensional function are
    another example where a heat map would be useful. It would take too long to completely
    cover the input domain, and inverse distance weighting could be used to fill in
    the gaps.
  prefs: []
  type: TYPE_NORMAL
- en: The sample data points each have a value, often labeled *z* to imply a third
    dimension. We want a way to interpolate the *z* value from the sample points onto
    the spaces between them. The heat map visualization is just the result of assigning
    colors to ranges of *z* and plotting these values.
  prefs: []
  type: TYPE_NORMAL
- en: One common technique to interpolate the value of *z* to points between the sample
    points is called **inverse distance weighting (IDW)**. To find the interpolated
    value of *z* for a point *x, y*, IDW sees how much the value of each sample point
    influences that location, given each sample's distance away and a value *p* that
    determines how far each sample point's influence carries. Low values of *p* don't
    project much beyond their immediate vicinity. High values of *p* can be projected
    too far. We'll see some examples of this in a minute.
  prefs: []
  type: TYPE_NORMAL
- en: There are a variety of ways to calculate the IDW. One general form is to sum
    the weighted difference between the data point in question and all others, and
    divide it by the non-weighted sum.
  prefs: []
  type: TYPE_NORMAL
- en: '![Interpolating sample points and generating heat maps using inverse distance
    weighting (IDW)](img/4139OS_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are several variations of IDW, but here, we''ll just describe the base
    version, as outlined by Donald Shepard in 1968\. First, we have to determine the
    inverse distance function. It''s given here as `w`. Also, `x_i` is the sample
    point, and `x` is the point to estimate the interpolation for, just as given in
    the preceding formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, IDW is the sum of `w` for each point in the sample, multiplied
    by that sample point''s value and divided by the sum of `w` for all the samples.
    It''s probably easier to parse the code than it is to describe it verbosely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted part of the function is the part to pay attention to. The rest
    makes it easier to call `idw` in different contexts. I precompute the denominator
    in the `let` form, as it won't change for each sample point that is considered.
    Then, the distances of each sample point and the target point are multiplied by
    the value of each sample point and divided by the denominator, and this is summed
    together.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function is easy to call with the charting library that **Incanter** provides,
    which has a very nice heat map function. Incanter is a library used to perform
    data analysis and visualization in Clojure by interfacing with high-performance
    Java libraries. This function first gets the bounding box around the data and
    pads it a little. It then uses Incanter''s `heat-map` function to generate the
    heat map. To make it more useful, however, we then make the heat map transparent
    and plot the points from the sample onto the chart. This is found in `src/clj_gis/heatmap.clj`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a random data sample and use it to see what different values of `p`
    do.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the first experiment, let''s look at *p=1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The graph it produces looks like the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Interpolating sample points and generating heat maps using inverse distance
    weighting (IDW)](img/4139OS_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can see that the influence for each sample point is tightly bound to its
    immediate neighborhood. More moderate values, around 4 and 5, dominate.
  prefs: []
  type: TYPE_NORMAL
- en: 'For *p=8*, the picture is a bit different, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Interpolating sample points and generating heat maps using inverse distance
    weighting (IDW)](img/4139OS_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding figure, each interpolated point is more heavily influenced
    by the data points closest to it, and further points are less influential. More
    extreme regions have great influence over larger distances, except around sample
    points with moderate values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we''ll look at an interpolated point that''s more balanced. The following
    is the chart for when *p=3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Interpolating sample points and generating heat maps using inverse distance
    weighting (IDW)](img/4139OS_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This seems much more balanced. Each sample point clearly exerts its influence
    across its own neighborhood. However, no point, and no range of values, appears
    to dominate. A more meaningful graph with real data would probably look quite
    good.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we've been playing with the toy data. Before we can apply this to the
    climate data that we prepared earlier, there are several things we need to take
    into consideration.
  prefs: []
  type: TYPE_NORMAL
- en: Working with map projections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have you looked at a world wall map and noticed how big Greenland is? It's huge.
    It's larger than China, the United States, and Australia, and is about as big
    as Africa. Too bad it's so cold, or we could fit a lot of people up there. Or
    could we?
  prefs: []
  type: TYPE_NORMAL
- en: Actually, Australia is about three and a half times as big as Greenland, China
    is almost four and a half times as big, and Africa is almost fourteen times as
    large!
  prefs: []
  type: TYPE_NORMAL
- en: What's going on? The **Mercator projection** is what's going on. It was developed
    by the Flemish cartographer Gerardus Mercator in 1569\. Over time, it's become
    very popular, at least partially so because it fits nicely onto a rectangular
    page without wasting a lot of space around the edges, the way some projections
    do.
  prefs: []
  type: TYPE_NORMAL
- en: A map projection is a transformation of locations on a sphere or ellipsoid onto
    locations on a plane. You can think of it as a function that transforms latitudes
    and longitudes of the earth into the x and y coordinates on a sheet of paper.
    This allows us to take a point on a map and find it on the earth, take a point
    on the earth and find it on the map, or take a point on one map and find it on
    another.
  prefs: []
  type: TYPE_NORMAL
- en: Mercator is a common projection. It's created by wrapping a cylindrical sheet
    of paper around the globe, only touching along the equator. Then, the shapes on
    the globe are cast out onto the paper roll like beams of light spreading out.
    This was developed for navigation, and if you chart a course with a constant bearing,
    it plots on a Mercator map as a straight line. However, its major problem is that
    it distorts shapes around the edges, for example, Greenland or Antarctica.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of other common projections, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Gall-Peters** projection accurately shows the area but distorts the shape.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Eckert IV** projection distorts the outer shape of the map onto an ovoid
    to minimize the area distortions of the Mercator projection, although it still
    distorts the shapes of things near the poles.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Goode homolosine** projection attempts to accurately portray both the
    area and shape by cutting the *skin* off the globe into some awkward shapes. It's
    sometimes called the *orange peel map* because the outlines of the map look like
    you peeled an orange by hand and flattened it on the table top.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So how does this apply to our project?
  prefs: []
  type: TYPE_NORMAL
- en: On the one hand, we need some way to accurately measure the distances between
    points in the real world. For example, as we're working in the northern hemisphere,
    the points near the top of the map, to the north, will be closer together than
    the points near the bottom. We need to know the projection in order to measure
    these distances correctly and correctly calculate the interpolations.
  prefs: []
  type: TYPE_NORMAL
- en: To put it another way, the distance between two points that are a degree of
    longitude apart would be different, depending on their latitude. In Grand Forks,
    North Dakota, the distance between longitude -97 and -96 is approximately 46 miles
    (74.5 km). On the other hand, the distance between longitudes -97 and -96, just
    west of Houston, Texas, is almost 60 miles (96.52 km). Think of the way in which
    two lines that are parallel on the equator have to curve towards each other as
    they converge at the poles.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, we also need to then be able to know which pixel a set of
    latitude and longitude correspond to. In order to actually plot the heat map on
    the screen, we have to be able to determine which pixel gets which color, depending
    on the interpolated points on the map.
  prefs: []
  type: TYPE_NORMAL
- en: Finding a base map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Related to the projections, we also need to have a base layer to display the
    heat map on top of it. Without being able to see the context of the underlying
    geography, a heat map is more confusing than it is illuminating.
  prefs: []
  type: TYPE_NORMAL
- en: There are maps available that have their locations encoded in their metadata.
    **GeoTIFF** is one such format. GIS packages can layer the data and information
    on top of these base maps to provide more complex, interesting, and useful visualizations
    and analyses.
  prefs: []
  type: TYPE_NORMAL
- en: Working with ArcGIS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with projections and base maps can be fiddly and prone to errors. While
    there are Java libraries that can help us with this, let's use the major software
    package in this domain, **ArcGIS**, for the purposes of this demonstration. While
    it's awesome to be able to program solutions in a powerful, flexible language
    like Clojure, sometimes, it's nicer to get pretty pictures quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to start this by getting the base layer. ESRI maintains a set
    of topological maps, and this map of the United States is perfect for this:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to [http://www.arcgis.com/home/item.html?id=99cd5fbd98934028802b4f797c4b1732](http://www.arcgis.com/home/item.html?id=99cd5fbd98934028802b4f797c4b1732)
    to view ESRI's page on the **US Topo Maps**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Open** dropdown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the option that allows you to get **ArcGIS Desktop** to open the layer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Working with ArcGIS](img/4139OS_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we''ll add our data. This was created using the functions that we defined
    earlier as well as a few more that are available in this chapter''s code download:'
  prefs: []
  type: TYPE_NORMAL
- en: The data is available at [http://www.ericrochester.com/clj-data-master/temp-diffs.csv](http://www.ericrochester.com/clj-data-master/temp-diffs.csv).
    Point your web browser there and download the file. Don't forget where you put
    it!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In ArcGIS, navigate to **File** | **Add Data** | **Add XY Data**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `temp-diffs.csv` file, and specify `z` for the **z** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll also need to change the projection of the input data. To do this, click
    on **Edit...** to edit the projection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the new dialog box, **Select** a predefined coordinate system. Navigate to
    **Coordinate Systems** | **Geographic Coordinate Systems** | **North America**
    | **NAD 1983**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the file is ready to load, the dialog should look like what is shown in
    the following screenshot:![Working with ArcGIS](img/4139OS_02_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the data is in place, we need to set the color scheme for the **z** field.
    Right-click on the new layer and select **Properties**. Select the **Symbology**
    tab and get the graduated colors the way you like them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After I was done playing, the dialog box looked like what is shown in the following
    screenshot:![Working with ArcGIS](img/4139OS_02_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we get to the good part. Open up **Catalog** and select **IDW tool**. It
    is done by navigating to **System Toolboxes** | **Geostatistical Analyst Tools**
    | **Interpolation**. Generate the heat map into a new layer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once ArcGIS is done, the heat map will be too opaque to see the underlying geography.
    Right-click on the heat map layer and select **Properties**. In the **Display**
    tab, change the opacity to something reasonable. I used `0.40`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final results are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with ArcGIS](img/4139OS_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can see that for a large part of the nation, things have heated up. The west
    part of the great lakes have cooled a bit, but the Rocky Mountains have especially
    gotten warmer.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This has been a fun little experiment. Looking at the data, however, suggests
    caution. Some of the stations have been in operation long enough to have only
    a few of the sliding windows defined. Others have been operational for much longer.
    This makes it difficult to compare the aggregated numbers from the different different
    stations, which is what we're doing by creating the heat map.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, this does point to some interesting areas of future enquiry, and
    it provides a brief glimpse of what geographical information systems can provide
    and how to use them. They can add a geospatially informed edge to the modeling
    and analysis, which isn't possible with the data, tools, and techniques they bring
    to the table.
  prefs: []
  type: TYPE_NORMAL
- en: In this next chapter, we'll turn our attention to sifting through free-form
    textual data using topic modeling.
  prefs: []
  type: TYPE_NORMAL
