<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;3.&#xA0;Learning the QGIS Python API"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03" class="calibre1"/>Chapter 3. Learning the QGIS Python API</h1></div></div></div><p class="calibre8">In this chapter, we will take a closer look at the Python libraries available for the QGIS Python developer, and also look at the various ways in which we can use these libraries to perform useful tasks within QGIS.</p><p class="calibre8">In particular, you will learn:</p><div class="book"><ul class="itemizedlist"><li class="listitem">How the QGIS Python libraries are based on the underlying C++ APIs</li><li class="listitem">How to use the C++ API documentation as a reference to work with the Python APIs</li><li class="listitem">How the PyQGIS libraries are organized</li><li class="listitem">The most important concepts and classes within the PyQGIS libraries and how to use them</li><li class="listitem">Some practical examples of performing useful tasks using PyQGIS</li></ul></div></div>

<div class="book" title="Chapter&#xA0;3.&#xA0;Learning the QGIS Python API">
<div class="book" title="About the QGIS Python APIs"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch03lvl1sec15" class="calibre1"/>About the QGIS Python APIs</h1></div></div></div><p class="calibre8">The QGIS <a id="id115" class="calibre1"/>system itself is written in C++, and has its own set of APIs that are also written in C++. The Python APIs are implemented as wrappers around these C++ APIs. For example, there is a Python class named <code class="email">QgisInterface</code> that acts as a wrapper around a C++ class of the same name. All the methods, class variables, and the like that are implemented by the C++ version of <code class="email">QgisInterface</code> are made available through the Python wrapper.</p><p class="calibre8">What this means is that when you access the Python QGIS APIs, you aren't accessing the API directly. Instead, the wrapper connects your code to the underlying C++ objects and methods, as follows:</p><div class="mediaobject"><img src="../images/00021.jpeg" alt="About the QGIS Python APIs" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Fortunately, in most cases, the QGIS Python wrappers simply hide away the complexity of the underlying C++ code, so the PyQGIS libraries work as you would expect them to. There are some <a id="id116" class="calibre1"/>gotchas, however, and we will cover these as they come up.</p></div></div>
<div class="book" title="Deciphering the C++ documentation"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec16" class="calibre1"/>Deciphering the C++ documentation</h1></div></div></div><p class="calibre8">As QGIS is <a id="id117" class="calibre1"/>implemented in C++, the documentation for QGIS APIs is all based on C++. This can make it difficult for Python developers to understand and work with the QGIS APIs. For example, the API documentation for the <code class="email">QgsInterface.zoomToActiveLayer()</code> method:</p><div class="mediaobject"><img src="../images/00022.jpeg" alt="Deciphering the C++ documentation" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">If you're not familiar with C++, this can be quite confusing. Fortunately, as a Python programmer, you can skip over much of the complexity as it doesn't apply to you. In particular:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The <code class="email">virtual</code> keyword is an implementation detail you don't need to worry about</li><li class="listitem"><code class="email">void</code> indicates that the method doesn't return a value</li><li class="listitem">The double colons in <code class="email">QgisInterface::zoomToActiveLayer</code> are simply a C++ convention for separating the class name from the method name</li></ul></div><p class="calibre8">Just like in Python, the parentheses show that the method doesn't take any parameters. So if you have an instance of <code class="email">QgisInterface</code> (for example, as the standard <code class="email">iface</code> variable available in the Python Console), you can call this method simply by typing the following:</p><div class="informalexample"><pre class="programlisting">iface.zoomToActiveLayer()</pre></div><p class="calibre8">Now, let's take <a id="id118" class="calibre1"/>a look at a slightly more complex example: the C++ documentation for the <code class="email">QgisInterface.addVectorLayer()</code> method looks like the following:</p><div class="mediaobject"><img src="../images/00023.jpeg" alt="Deciphering the C++ documentation" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Notice how the <code class="email">virtual</code> keyword is followed by <code class="email">QgsVectorLayer*</code> instead of <code class="email">void</code>. This is the return value for this method; it returns a <code class="email">QgsVector</code> object.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note12" class="calibre1"/>Note</h3><p class="calibre8">Technically speaking, <code class="email">*</code> means that the method returns a <span class="strong"><strong class="calibre9">pointer</strong></span> to an object of type <code class="email">QgsVectorLayer</code>. Fortunately, Python wrappers automatically handle pointers, so you don't need to worry about this.</p></div><p class="calibre8">Notice the brief description at the bottom of the documentation for this method; while many of the C++ methods have very little, if any, additional information, other methods have more extensive information. Obviously, you should read these descriptions carefully as they tell you more about what the method does.</p><p class="calibre8">Even without any description, the C++ documentation is still useful as it tells you what the method is called, what parameters it accepts, and what type of data is being returned.</p><p class="calibre8">In the preceding method, you can see that there are three parameters listed in between the parentheses. As C++ is a <span class="strong"><em class="calibre10">strongly typed</em></span> language, you have to define the type of each parameter when you define a function. This is helpful for Python programmers as it tells you what type of value to supply. Apart from QGIS objects, you might also encounter the following data types in the C++ documentation:</p><div class="informalexample"><table border="1" class="calibre14"><colgroup class="calibre15"><col class="calibre16"/><col class="calibre16"/></colgroup><thead class="calibre17"><tr class="calibre18"><th valign="bottom" class="calibre19">
<p class="calibre20">Data type</p>
</th><th valign="bottom" class="calibre19">
<p class="calibre20">Description</p>
</th></tr></thead><tbody class="calibre21"><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">int</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">A <a id="id119" class="indexterm"/>standard Python integer value</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">long</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">A <a id="id120" class="indexterm"/>standard Python long integer value</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">float</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">A <a id="id121" class="indexterm"/>standard Python floating point (real) number</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">bool</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">A <a id="id122" class="indexterm"/>Boolean value (<code class="literal">true</code> or <code class="literal">false</code>)</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">QString</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">A <a id="id123" class="indexterm"/>string value. Note that the QGIS Python wrappers automatically convert Python strings to C++ strings, so you don't need to deal with <code class="literal">QString</code> objects directly</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">QList</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">This <a id="id124" class="indexterm"/>object is used to encapsulate a list of other objects. For example, <code class="literal">QList&lt;QString*&gt;</code> represents a list of strings</p>
</td></tr></tbody></table></div><p class="calibre8">Just as in Python, a method can take default values for each parameter. For example, the <code class="email">QgisInterface.newProject()</code> method looks like the following:</p><div class="mediaobject"><img src="../images/00024.jpeg" alt="Deciphering the C++ documentation" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">In this case, the <code class="email">thePromptToSaveFlag</code> parameter has a default value, and this default value will be used if no value is supplied.</p><p class="calibre8">In Python, classes are initialized using the <code class="email">__init__</code> method. In C++, this is called a <span class="strong"><em class="calibre10">constructor</em></span>. For <a id="id125" class="calibre1"/>example, the constructor for the <code class="email">QgsLabel</code> class looks like the following:</p><div class="mediaobject"><img src="../images/00025.jpeg" alt="Deciphering the C++ documentation" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Just as in Python, C++ classes <span class="strong"><em class="calibre10">inherit</em></span> the methods defined in their superclass. Fortunately, QGIS doesn't have an extensive class hierarchy, so most of the classes don't have a superclass. However, don't forget to check for a superclass if you can't find the method you're looking for in the documentation for the class itself.</p><p class="calibre8">Finally, be <a id="id126" class="calibre1"/>aware that C++ supports the concept of <span class="strong"><em class="calibre10">method overloading</em></span>. A single method can be defined more than once, where each version accepts a different set of parameters. For example, take a look at the constructor for the <code class="email">QgsRectangle</code> class—you will see that there are four different versions of this method.</p><p class="calibre8">The first version accepts the four coordinates as floating point numbers:</p><div class="mediaobject"><img src="../images/00026.jpeg" alt="Deciphering the C++ documentation" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">The second <a id="id127" class="calibre1"/>version constructs a rectangle using two <code class="email">QgsPoint</code> objects:</p><div class="mediaobject"><img src="../images/00027.jpeg" alt="Deciphering the C++ documentation" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">The third version copies the coordinates from <code class="email">QRectF</code> (which is a Qt data type) into a <code class="email">QgsRectangle</code> object:</p><div class="mediaobject"><img src="../images/00028.jpeg" alt="Deciphering the C++ documentation" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">The final version copies the coordinates from another <code class="email">QgsRectangle</code> object:</p><div class="mediaobject"><img src="../images/00029.jpeg" alt="Deciphering the C++ documentation" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">The C++ compiler chooses the correct method to use based on the parameters that have been supplied. Python has no concept of method overloading; just choose the version of the method that accepts the parameters you want to supply, and the QGIS Python wrappers will automatically choose the correct method for you.</p><p class="calibre8">If you keep these guidelines in mind, deciphering the C++ documentation for QGIS isn't all that hard. It <a id="id128" class="calibre1"/>just looks more complicated than it really is, thanks to all the complexity specific to C++. However, it doesn't take long for your brain to start filtering out the C++ gobbledygook, and you'll be able to use the QGIS reference documentation almost as easily as if it was written for Python rather than C++.</p></div>

<div id="page" style="height:0pt"/><div class="book" title="Organizing the QGIS Python libraries"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec17" class="calibre1"/>Organizing the QGIS Python libraries</h1></div></div></div><p class="calibre8">Now that we <a id="id129" class="calibre1"/>can understand the C++-oriented documentation, let's see how the PyQGIS libraries are structured. All of the PyQGIS libraries are organized under a package named <code class="email">qgis</code>. You wouldn't normally import <code class="email">qgis</code> directly, however, as all the interesting libraries are subpackages within this main package; here are the five packages that make up the PyQGIS library:</p><div class="informalexample"><table border="1" class="calibre14"><colgroup class="calibre15"><col class="calibre16"/><col class="calibre16"/></colgroup><tbody class="calibre21"><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">qgis.core</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">This <a id="id130" class="indexterm"/>provides access to the core GIS functionality used throughout QGIS.</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">qgis.gui</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">This <a id="id131" class="indexterm"/>defines a range of GUI widgets that you can include in your own programs.</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">qgis.analysis</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">This <a id="id132" class="indexterm"/>provides spatial analysis tools to analyze vector and raster format data.</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">qgis.networkanalysis</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">This <a id="id133" class="indexterm"/>provides tools to build and analyze topologies.</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">qgis.utils</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">This <a id="id134" class="indexterm"/>implements miscellaneous functions that allow you to work with the QGIS application using Python.</p>
</td></tr></tbody></table></div><p class="calibre8">The first two packages (<code class="email">qgis.core</code> and <code class="email">qgis.gui</code>) implement the most important parts of the PyQGIS <a id="id135" class="calibre1"/>library, and it's worth spending some time to become more familiar with the concepts and classes they define. Let's take a closer look at these two packages now.</p></div>

<div class="book" title="Organizing the QGIS Python libraries">
<div class="book" title="The qgis.core package"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec18" class="calibre1"/>The qgis.core package</h2></div></div></div><p class="calibre8">The <code class="email">qgis.core</code> <a id="id136" class="calibre1"/>package defines fundamental classes used throughout the QGIS system. A large part of this package is dedicated to <a id="id137" class="calibre1"/>working with vector and raster format geospatial data, and displaying these types of data within a map. Let's see how this is done.</p><div class="book" title="Maps and map layers"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec01" class="calibre1"/>Maps and map layers</h3></div></div></div><p class="calibre8">A map <a id="id138" class="calibre1"/>consists of multiple layers drawn one on top of the other:</p><div class="mediaobject"><img src="../images/00030.jpeg" alt="Maps and map layers" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">There are three types of map layers supported by QGIS:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre9">Vector layer</strong></span>: This <a id="id139" class="calibre1"/>layer draws geospatial features such as points, lines, and polygons</li><li class="listitem"><span class="strong"><strong class="calibre9">Raster layer</strong></span>: This <a id="id140" class="calibre1"/>layer draws raster (bitmapped) data onto a map</li><li class="listitem"><span class="strong"><strong class="calibre9">Plugin layer</strong></span>: This <a id="id141" class="calibre1"/>layer allows a plugin to draw directly onto a map</li></ul></div><p class="calibre8">Each of these types of <a id="id142" class="calibre1"/>map layers has a corresponding class within the <code class="email">qgis.core</code> library. For example, a vector map layer will be represented by an object of type <code class="email">qgis.core.QgsVectorLayer</code>.</p><p class="calibre8">We will <a id="id143" class="calibre1"/>take a closer look at vector and raster map layers <a id="id144" class="calibre1"/>shortly. Before we do this, though, we need to learn how geospatial data (both vector and raster data) is positioned on a map.</p></div><div class="book" title="Coordinate reference systems"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec02" class="calibre1"/>Coordinate reference systems</h3></div></div></div><p class="calibre8">Since <a id="id145" class="calibre1"/>the Earth is a three-dimensional object, while maps represent the Earth's surface as a two-dimensional plane, there <a id="id146" class="calibre1"/>has to be a way of translating from points on the Earth's surface into (x,y) coordinates within a map. This is done using a <span class="strong"><strong class="calibre9">Coordinate Reference System</strong></span> (<span class="strong"><strong class="calibre9">CRS</strong></span>):</p><div class="mediaobject"><img src="../images/00031.jpeg" alt="Coordinate reference systems" class="calibre11"/><div class="caption"><p class="calibre28">Globe image courtesy Wikimedia (<a class="calibre1" href="http://commons.wikimedia.org/wiki/File:Rotating_globe.gif">http://commons.wikimedia.org/wiki/File:Rotating_globe.gif</a>)</p></div></div><p class="calibre12"> </p><p class="calibre8">A CRS has two parts: an <a id="id147" class="calibre1"/>
<span class="strong"><strong class="calibre9">ellipsoid</strong></span>, which is a mathematical model of the Earth's surface, and a <span class="strong"><strong class="calibre9">projection</strong></span>, which is a formula that converts points on the surface of the <a id="id148" class="calibre1"/>spheroid into (x,y) coordinates on a map.</p><p class="calibre8">Fortunately, most of the time you can simply select the appropriate CRS that matches the CRS of the data you are using. However, because many different coordinate reference systems have been devised over the years, it is vital that you use the correct CRS when plotting your geospatial data. If you don't do this, your features will be displayed in the wrong place or have the wrong shape.</p><p class="calibre8">The majority of geospatial data available today uses the <span class="strong"><strong class="calibre9">EPSG 4326</strong></span> coordinate reference system (sometimes also referred to as WGS84). This CRS defines coordinates as latitude and <a id="id149" class="calibre1"/>longitude values. This is the default CRS used for new data imported into QGIS. However, if your data uses a different coordinate reference system, you will need to create and use a different CRS for your map layer.</p><p class="calibre8">The <code class="email">qgis.core.QgsCoordinateReferenceSystem</code> class represents a CRS. Once you create <a id="id150" class="calibre1"/>your coordinate reference system, you can tell your map layer to use that CRS when accessing the underlying data. For example:</p><div class="informalexample"><pre class="programlisting">crs = QgsCoordinateReferenceSystem(4326,
           QgsCoordinateReferenceSystem.EpsgCrsId)
layer.setCrs(crs)</pre></div><p class="calibre8">Note that different map layers can use different coordinate reference systems. Each layer will use its CRS when drawing the contents of the layer onto the map.</p></div><div class="book" title="Vector layers"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec03" class="calibre1"/>Vector layers</h3></div></div></div><p class="calibre8">A vector <a id="id151" class="calibre1"/>layer draws geospatial data onto a map in the form of points, lines, polygons, and so on. Vector-format geospatial data is typically loaded from a <span class="strong"><strong class="calibre9">vector data source</strong></span> such as a shapefile or database. Other vector data sources <a id="id152" class="calibre1"/>can hold vector data in memory, or load data from a web service across the Internet.</p><p class="calibre8">A vector-format data source has a number of features, where each feature represents a single <span class="strong"><em class="calibre10">record</em></span> within the data source. The <code class="email">qgis.core.QgsFeature</code> class represents a feature within a data source. Each feature has the following components:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre9">ID</strong></span>: This <a id="id153" class="calibre1"/>is the feature's unique identifier within the data source</li><li class="listitem"><span class="strong"><strong class="calibre9">Geometry</strong></span>: This <a id="id154" class="calibre1"/>is the underlying point, line, polygon, and so on, which represents the feature on the map. For example, a <span class="strong"><strong class="calibre9">city</strong></span> data source would have one feature for each city, and the geometry would typically be either a point that represents the center of the city, or a polygon (or a multipolygon) that represents the city's outline.</li><li class="listitem"><span class="strong"><strong class="calibre9">Attributes</strong></span>: These <a id="id155" class="calibre1"/>are key/value pairs that provide additional information about the feature. For example, a city data source representing cities might have attributes such as <code class="email">total_area</code>, <code class="email">population</code>, <code class="email">elevation</code>, and so on. Attribute values can be strings, integers, or floating point numbers.</li></ul></div><p class="calibre8">In QGIS, a <span class="strong"><strong class="calibre9">data provider</strong></span> allows the vector layer to access the features within the data source. The data provider, an instance of <code class="email">qgis.core.QgsVectorDataProvider</code>, includes:</p><div class="book"><ul class="itemizedlist"><li class="listitem">A <span class="strong"><strong class="calibre9">geometry type</strong></span> that is stored in the data source</li><li class="listitem">A list of <span class="strong"><strong class="calibre9">fields</strong></span> that provide information about the attributes stored for each feature</li><li class="listitem">The ability to search through the features within the data source, using the <code class="email">getFeatures()</code> method and the <code class="email">QgsFeatureRequest</code> class</li></ul></div><p class="calibre8">You can access the various vector (and also raster) data providers by using the <code class="email">qgis.core.QgsProviderRegistry</code> class.</p><p class="calibre8">The vector layer itself is represented by a <code class="email">qgis.core.QgsVectorLayer</code> object. Each vector layer includes:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre9">Data provider</strong></span>: This <a id="id156" class="calibre1"/>is the connection to the underlying file or database that holds the geospatial information to be displayed</li><li class="listitem"><span class="strong"><strong class="calibre9">Coordinate reference system</strong></span>: This <a id="id157" class="calibre1"/>indicates which CRS the geospatial data uses</li><li class="listitem"><span class="strong"><strong class="calibre9">Renderer</strong></span>: This <a id="id158" class="calibre1"/>chooses how the features are to be displayed</li></ul></div><p class="calibre8">Let's take a closer <a id="id159" class="calibre1"/>look at the concept of a renderer and how features are displayed within a vector map layer.</p><div class="book" title="Displaying vector data"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch03lvl4sec01" class="calibre1"/>Displaying vector data</h4></div></div></div><p class="calibre8">The features within a vector map layer are displayed using a combination of <span class="strong"><strong class="calibre9">renderer</strong></span> and <span class="strong"><strong class="calibre9">symbol</strong></span> <a id="id160" class="calibre1"/>objects. The renderer chooses the symbol that has to be used for a given feature, and the symbol that does the actual drawing.</p><p class="calibre8">There are three basic types of symbols defined by QGIS:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre9">Marker symbol</strong></span>: This <a id="id161" class="calibre1"/>displays a point as a filled circle</li><li class="listitem"><span class="strong"><strong class="calibre9">Line symbol</strong></span>: This <a id="id162" class="calibre1"/>draws a line using a given line width and color</li><li class="listitem"><span class="strong"><strong class="calibre9">Fill symbol</strong></span>: This <a id="id163" class="calibre1"/>draws the interior of a polygon with a given color</li></ul></div><p class="calibre8">These three types of symbols are implemented as subclasses of the <code class="email">qgis.core.QgsSymbolV2</code> class:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">qgis.core.QgsMarkerSymbolV2</code></li><li class="listitem"><code class="email">qgis.core.QgsLineSymbolV2</code></li><li class="listitem"><code class="email">qgis.core.QgsFillSymbolV2</code><div class="note" title="Note"><h3 class="title2"><a id="note13" class="calibre1"/>Note</h3><p class="calibre8">You might be wondering why all these classes have "V2" in their name. This is a historical quirk of QGIS. Earlier versions of QGIS supported both an "old" and a "new" system of rendering, and the "V2" naming refers to the new rendering system. The old rendering system no longer exists, but the "V2" naming continues to maintain backward compatibility with existing code.</p></div></li></ul></div><p class="calibre8">Internally, symbols are rather complex, using "symbol layers" to draw multiple elements on top of each other. In most cases, however, you can make use of the "simple" version of the symbol. This makes it easier to create a new symbol without having to deal with the internal complexity of symbol layers. For example:</p><div class="informalexample"><pre class="programlisting">symbol = QgsMarkerSymbolV2.createSimple({'width' : 1.0,
                                         'color' : "255,0,0"})</pre></div><p class="calibre8">While symbols draw the features onto the map, a renderer is used to choose which symbol to use to draw a particular feature. In the simplest case, the same symbol is used for every <a id="id164" class="calibre1"/>feature within a layer. This is called a <span class="strong"><strong class="calibre9">single symbol renderer</strong></span>, and is represented by the <code class="email">qgis.core.QgsSingleSymbolRenderV2</code> class. Other possibilities include:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre9">Categorized symbol renderer</strong></span> (<code class="email">qgis.core.QgsCategorizedSymbolRendererV2</code>): This renderer chooses a symbol <a id="id165" class="calibre1"/>based on the value of an attribute. The categorized symbol renderer has a mapping <a id="id166" class="calibre1"/>from attribute values to symbols.</li><li class="listitem"><span class="strong"><strong class="calibre9">Graduated symbol renderer</strong></span> (<code class="email">qgis.core.QgsGraduatedSymbolRendererV2</code>): This type of renderer uses <a id="id167" class="calibre1"/>ranges of <a id="id168" class="calibre1"/>attribute values, and maps each range to an appropriate symbol.</li></ul></div><p class="calibre8">Using a single symbol renderer is very straightforward:</p><div class="informalexample"><pre class="programlisting">symbol = ...
renderer = QgsSingleSymbolRendererV2(symbol)
layer.setRendererV2(renderer)</pre></div><p class="calibre8">To use a categorized <a id="id169" class="calibre1"/>symbol renderer, you first define a list of <code class="email">qgis.core.QgsRendererCategoryV2</code> objects, and then use that to create the renderer. For example:</p><div class="informalexample"><pre class="programlisting">symbol_male = ...
symbol_female = ...

categories = []
categories.append(QgsRendererCategoryV2("M", symbol_male, "Male"))
categories.append(QgsRendererCategoryV2("F", symbol_female,
                    "Female"))

renderer = QgsCategorizedSymbolRendererV2("", categories)
renderer.setClassAttribute("GENDER")
layer.setRendererV2(renderer)</pre></div><p class="calibre8">Notice that the <code class="email">QgsRendererCategoryV2</code> constructor takes three parameters: the desired value, the symbol used, and the label used to describe that category.</p><p class="calibre8">Finally, to use a graduated symbol renderer, you define a list of <code class="email">qgis.core.QgsRendererRangeV2</code> objects and then use that to create your renderer. For example:</p><div class="informalexample"><pre class="programlisting">symbol1 = ...
symbol2 = ...

ranges = []
ranges.append(QgsRendererRangeV2(0, 10, symbol1, "Range 1"))
ranges.append(QgsRendererRange(11, 20, symbol2, "Range 2"))

renderer = QgsGraduatedSymbolRendererV2("", ranges)
renderer.setClassAttribute("FIELD")
layer.setRendererV2(renderer)</pre></div></div><div class="book" title="Accessing vector data"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch03lvl4sec02" class="calibre1"/>Accessing vector data</h4></div></div></div><p class="calibre8">In addition to <a id="id170" class="calibre1"/>displaying the contents <a id="id171" class="calibre1"/>of a vector layer within a map, you can use Python to directly access the underlying data. This can be done using the data provider's <code class="email">getFeatures()</code> method. For example, to iterate over all the features within the layer, you can do the following:</p><div class="informalexample"><pre class="programlisting">provider = layer.dataProvider()
for feature in provider.getFeatures(QgsFeatureRequest()):
  ...</pre></div><p class="calibre8">If you want to search for features based on some criteria, you can use the <code class="email">QgsFeatureRequest</code> object's <code class="email">setFilterExpression()</code> method, as follows:</p><div class="informalexample"><pre class="programlisting">provider = layer.dataProvider()
request = QgsFeatureRequest()
request.setFilterExpression('"GENDER" = "M"')
for feature in provider.getFeatures(QgsFeatureRequest()):
  ...</pre></div><p class="calibre8">Once you have the features, it's easy to get access to the feature's geometry, ID, and attributes. For example:</p><div class="informalexample"><pre class="programlisting">  geometry = feature.geometry()
  id = feature.id()
  name = feature.attribute("NAME")</pre></div><p class="calibre8">The object returned by the <code class="email">feature.geometry()</code> call, which will be an instance of <code class="email">qgis.core.QgsGeometry</code>, represents the feature's geometry. This object has a large number of methods you can use to extract the underlying data and perform various geospatial calculations.</p></div><div class="book" title="Spatial indexes"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch03lvl4sec03" class="calibre1"/>Spatial indexes</h4></div></div></div><p class="calibre8">In the <a id="id172" class="calibre1"/>previous section, we searched for features based on their attribute values. There are times, though, when you might <a id="id173" class="calibre1"/>want to find features based on their position in space. For example, you might want to find all features that lie within a certain distance of a given point. To do this, you can use a <span class="strong"><strong class="calibre9">spatial index</strong></span>, which indexes features according to their location and extent. Spatial indexes are represented in QGIS by the <code class="email">QgsSpatialIndex</code> class.</p><p class="calibre8">For performance reasons, a spatial index is not created automatically for each vector layer. However, it's easy to create one when you need it:</p><div class="informalexample"><pre class="programlisting">provider = layer.dataProvider()
index = QgsSpatialIndex()
for feature in provider.getFeatures(QgsFeatureRequest()):
  index.insertFeature(feature)</pre></div><p class="calibre8">Don't forget that you can use the <code class="email">QgsFeatureRequest.setFilterExpression()</code> method to limit the set of features that get added to the index.</p><p class="calibre8">Once you have the spatial index, you can use it to perform queries based on the position of the <a id="id174" class="calibre1"/>features. In particular:</p><div class="book"><ul class="itemizedlist"><li class="listitem">You can find one or more features that are closest to a given point using the <code class="email">nearestNeighbor()</code> method. For example:<div class="informalexample"><pre class="programlisting">features = index.nearestNeighbor(QgsPoint(long, lat), 5)</pre></div><p class="calibre26">Note that this method takes two parameters: the desired point as a <code class="email">QgsPoint</code> object and the number of features to return.</p></li><li class="listitem">You can <a id="id175" class="calibre1"/>find all features that intersect with a given rectangular area by using the <code class="email">intersects()</code> method, as follows:<div class="informalexample"><pre class="programlisting">features = index.intersects(QgsRectangle(left, bottom,
                     right, top))</pre></div></li></ul></div></div></div><div class="book" title="Raster layers"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec04" class="calibre1"/>Raster layers</h3></div></div></div><p class="calibre8">Raster-format <a id="id176" class="calibre1"/>geospatial data is essentially a bitmapped image, where each pixel or "cell" in the image corresponds to a particular part of the Earth's surface. Raster data is often organized into <span class="strong"><strong class="calibre9">bands</strong></span>, where each band represents a different piece of information. A common use for bands is to store the red, green, and blue component of the pixel's color in a separate band. Bands might also represent other types of information, such as moisture level, elevation, or soil type.</p><p class="calibre8">There are many ways in which raster information can be displayed. For example:</p><div class="book"><ul class="itemizedlist"><li class="listitem">If the raster data only has one band, the pixel value can be used as an index into a <span class="strong"><strong class="calibre9">palette</strong></span>. The palette maps each pixel value maps to a particular color.</li><li class="listitem">If the raster data has only one band but no palette is provided, the pixel values can be used directly as a <span class="strong"><strong class="calibre9">grayscale</strong></span> value; that is, larger numbers are lighter and smaller numbers are darker. Alternatively, the pixel values can be passed <a id="id177" class="calibre1"/>through a <span class="strong"><strong class="calibre9">pseudocolor algorithm</strong></span> to calculate the color to be displayed.</li><li class="listitem">If the raster data has multiple bands, then typically, the bands would be combined to generate the desired color. For example, one band might represent the red component of the color, another band might represent the green component, and yet another band might represent the blue component.</li><li class="listitem">Alternatively, a multiband raster data source might be drawn using a palette, or as a grayscale or a pseudocolor image, by selecting a particular band to use for the color calculation.</li></ul></div><p class="calibre8">Let's take a <a id="id178" class="calibre1"/>closer look at how raster data can be drawn onto the map.</p><div class="book" title="How raster data is displayed"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch03lvl4sec04" class="calibre1"/>How raster data is displayed</h4></div></div></div><p class="calibre8">The <a id="id179" class="calibre1"/>
<span class="strong"><strong class="calibre9">drawing style</strong></span> associated with the raster band controls how the raster data will be displayed. The following drawing styles are currently supported:</p><div class="informalexample"><table border="1" class="calibre14"><colgroup class="calibre15"><col class="calibre16"/><col class="calibre16"/></colgroup><thead class="calibre17"><tr class="calibre18"><th valign="bottom" class="calibre19">
<p class="calibre20">Drawing style</p>
</th><th valign="bottom" class="calibre19">
<p class="calibre20">Description</p>
</th></tr></thead><tbody class="calibre21"><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">PalettedColor</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">For a <a id="id180" class="indexterm"/>single band raster data source, a palette maps each raster value to a color.</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">SingleBandGray</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">For a <a id="id181" class="indexterm"/>single band raster data source, the raster value is used directly as a grayscale value.</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">SingleBandPseudoColor</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">For a <a id="id182" class="indexterm"/>single band raster data source, the raster value is used to calculate a pseudocolor.</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">PalettedSingleBandGray</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">For a <a id="id183" class="indexterm"/>single band raster data source that has a palette, this drawing style tells QGIS to ignore the palette and use the raster value directly as a grayscale value.</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">PalettedSingleBandPseudoColor</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">For a <a id="id184" class="indexterm"/>single band raster data source that has a palette, this drawing style tells QGIS to ignore the palette and use the raster value to calculate a pseudocolor.</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">MultiBandColor</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">For <a id="id185" class="indexterm"/>multiband raster data sources, use a separate band for each of the red, green, and blue color components. For this drawing style, the <code class="literal">setRedBand()</code>, <code class="literal">setGreenBand()</code>, and <code class="literal">setBlueBand()</code> methods can be used to choose which band to use for each color component.</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">MultiBandSingleBandGray</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">For <a id="id186" class="indexterm"/>multiband raster data sources, choose a single band to use as the grayscale color value. For this drawing style, use the <code class="literal">setGrayBand()</code> method to specify the band to use.</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">MultiBandSingleBandPseudoColor</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">For <a id="id187" class="indexterm"/>multiband raster data sources, choose a single band to use to calculate a pseudocolor. For this drawing style, use the <code class="literal">setGrayBand()</code> method to specify the band to use.</p>
</td></tr></tbody></table></div><p class="calibre8">To set the drawing style, use the <code class="email">layer.setDrawingStyle()</code> method, passing in a string that contains the name of the desired drawing style. You will also need to call the various <code class="email">setXXXBand()</code> methods, as described in the preceding table, to tell the raster layer which bands contain the value(s) to use to draw each pixel.</p><p class="calibre8">Note that QGIS doesn't automatically update the map when you call the preceding functions to <a id="id188" class="calibre1"/>change the way the raster data is displayed. To have your changes displayed right away, you'll need to do the following:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Turn off raster image caching. This can be done by calling <code class="email">layer.setImageCache(None)</code>.</li><li class="listitem" value="2">Tell the raster layer to redraw itself, by calling <code class="email">layer.triggerRepaint()</code>.</li></ol><div class="calibre24"/></div></div><div class="book" title="Accessing raster data"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch03lvl4sec05" class="calibre1"/>Accessing raster data</h4></div></div></div><p class="calibre8">As with <a id="id189" class="calibre1"/>vector-format data, you can access the underlying raster data via the data provider's <code class="email">identify()</code> method. The <a id="id190" class="calibre1"/>easiest way to do this is to pass in a single coordinate and retrieve the value or values at that coordinate. For example:</p><div class="informalexample"><pre class="programlisting">provider = layer.dataProvider()
values = provider.identify(QgsPoint(x, y),
              QgsRaster.IdentifyFormatValue)
if values.isValid():
  for band,value in values.results().items():
    ...</pre></div><p class="calibre8">As you can see, you need to check whether the given coordinate exists within the raster data (using the <code class="email">isValid()</code> call). The <code class="email">values.results()</code> method returns a dictionary that maps band numbers to values.</p><p class="calibre8">Using this technique, you can extract all the underlying data associated with a given coordinate <a id="id191" class="calibre1"/>within the raster layer.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip08" class="calibre1"/>Tip</h3><p class="calibre8">You can also use the <code class="email">provider.block()</code> method to retrieve the band data for a large number <a id="id192" class="calibre1"/>of coordinates all at once. We will look at how to do this later in this chapter.</p></div></div></div><div class="book" title="Other useful qgis.core classes"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec05" class="calibre1"/>Other useful qgis.core classes</h3></div></div></div><p class="calibre8">Apart from all the classes and functionality involved in working with data sources and map layers, the <code class="email">qgis.core</code> library also defines a number of other classes that you might find useful:</p><div class="informalexample"><table border="1" class="calibre14"><colgroup class="calibre15"><col class="calibre16"/><col class="calibre16"/></colgroup><thead class="calibre17"><tr class="calibre18"><th valign="bottom" class="calibre19">
<p class="calibre20">Class</p>
</th><th valign="bottom" class="calibre19">
<p class="calibre20">Description</p>
</th></tr></thead><tbody class="calibre21"><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">QgsProject</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">This represents the current QGIS project. Note that this is a singleton object, as only one project can be open at a time. The <code class="literal">QgsProject</code> class is responsible for loading and storing properties, which can be useful for plugins.</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">QGis</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">This class defines various constants, data types, and functions used throughout the QGIS system.</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">QgsPoint</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">This is a generic class that stores the coordinates for a point within a two-dimensional plane.</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">QgsRectangle</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">This is a generic class that stores the coordinates for a rectangular area within a two-dimensional plane.</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">QgsRasterInterface</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">This is the base class to use for processing raster data, for example, to reproject a set of raster data into a new coordinate system, to apply filters to change the brightness or color of your raster data, to resample the raster data, and to generate new raster data by rendering the existing data in various ways.</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">QgsDistanceArea</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">This class can be used to calculate distances and areas for a given geometry, automatically converting from the source coordinate reference system into meters.</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">QgsMapLayerRegistry</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">This class provides access to all the registered map layers in the current project.</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">QgsMessageLog</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">This class provides general logging features within a QGIS program. This lets you send debugging messages, warnings, and errors to the QGIS "Log Messages" panel.</p>
</td></tr></tbody></table></div></div></div></div>

<div class="book" title="Organizing the QGIS Python libraries">
<div class="book" title="The qgis.gui package"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec19" class="calibre1"/>The qgis.gui package</h2></div></div></div><p class="calibre8">The <code class="email">qgis.gui</code> package defines a number of user-interface widgets that you can include in your <a id="id193" class="calibre1"/>programs. Let's start by looking at the most important <code class="email">qgis.gui</code> classes, and follow this up with a brief look at some of the other classes that you might find useful.</p><div class="book" title="The QgisInterface class"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec06" class="calibre1"/>The QgisInterface class</h3></div></div></div><p class="calibre8">
<code class="email">QgisInterface</code> represents the QGIS system's user interface. It allows programmatic access to the <a id="id194" class="calibre1"/>map canvas, the menu bar, and other parts of the QGIS application. When running Python code within a script or a plugin, or directly <a id="id195" class="calibre1"/>from the QGIS Python console, a reference to <code class="email">QgisInterface</code> is typically available through the <code class="email">iface</code> global variable.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note14" class="calibre1"/>Note</h3><p class="calibre8">The <code class="email">QgisInterface</code> object is only available when running the QGIS application itself. If you are running an external application and import the PyQGIS library into your application, <code class="email">QgisInterface</code> won't be available.</p></div><p class="calibre8">Some of the more important things you can do with the <code class="email">QgisInterface</code> object are:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Get a reference to the list of layers within the current QGIS project via the <code class="email">legendInterface()</code> method.</li><li class="listitem">Get a reference to the map canvas displayed within the main application window, using the <code class="email">mapCanvas()</code> method.</li><li class="listitem">Retrieve the currently active layer within the project, using the <code class="email">activeLayer()</code> method, and set the currently active layer by using the <code class="email">setActiveLayer()</code> method.</li><li class="listitem">Get a reference to the application's main window by calling the <code class="email">mainWindow()</code> method. This can be useful if you want to create additional Qt windows or dialogs that use the main window as their parent.</li><li class="listitem">Get a reference to the <a id="id196" class="calibre1"/>QGIS system's message bar by calling the <code class="email">messageBar()</code> method. This allows you to display messages to the user directly within the QGIS main window.</li></ul></div></div><div class="book" title="The QgsMapCanvas class"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec07" class="calibre1"/>The QgsMapCanvas class</h3></div></div></div><p class="calibre8">The <span class="strong"><strong class="calibre9">map canvas</strong></span> <a id="id197" class="calibre1"/>is responsible for drawing the various map layers into a window. The <code class="email">QgsMapCanvas</code> class represents a map canvas. This <a id="id198" class="calibre1"/>class includes:</p><div class="book"><ul class="itemizedlist"><li class="listitem">A list of the <a id="id199" class="calibre1"/>currently shown <span class="strong"><strong class="calibre9">map layers</strong></span>. This can be accessed using the <code class="email">layers()</code> method.<div class="note" title="Note"><h3 class="title2"><a id="tip09" class="calibre1"/>Tip</h3><p class="calibre8">Note that there is a subtle difference between the list of map layers available within the map canvas and the list of map layers included in the <code class="email">QgisInterface.legendInterface()</code> method. The map canvas's list of layers only includes the list of layers currently visible, while <code class="email">QgisInterface.legendInterface()</code> returns all the map layers, including those that are currently hidden.</p></div></li><li class="listitem">The <span class="strong"><strong class="calibre9">map units</strong></span> used by this map (meters, feet, degrees, and so on). The map's map units can be retrieved by calling the <code class="email">mapUnits()</code> method.</li><li class="listitem">An <span class="strong"><strong class="calibre9">extent</strong></span>,<span class="strong"><strong class="calibre9"> which</strong></span> is the area of the map currently shown within the canvas. The map's extent will change as the user zooms in and out, and pans across the map. The current map extent can be obtained by calling the <code class="email">extent()</code> method.</li><li class="listitem"><span class="strong"><strong class="calibre9">A current map tool</strong></span> that is used to control the user's interaction with the contents of the map canvas. The current map tool can be set using the <code class="email">setMapTool()</code> method, and you can retrieve the current map tool (if any) by calling the <code class="email">mapTool()</code> method.</li><li class="listitem">A <span class="strong"><strong class="calibre9">background color</strong></span> used to draw the background behind all the map layers. You can change the map's background color by calling the <code class="email">canvasColor()</code> method.</li><li class="listitem">A <span class="strong"><strong class="calibre9">coordinate transform</strong></span> that converts from map coordinates (that is, coordinates in the data <a id="id200" class="calibre1"/>source's coordinate reference system) to pixels within the window. You can retrieve the current <a id="id201" class="calibre1"/>coordinate transform by calling the <code class="email">getCoordinateTransform()</code> method.</li></ul></div></div><div class="book" title="The QgsMapCanvasItem class"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec08" class="calibre1"/>The QgsMapCanvasItem class</h3></div></div></div><p class="calibre8">A <span class="strong"><strong class="calibre9">map canvas item</strong></span> <a id="id202" class="calibre1"/>is an item drawn on top of the map canvas. The map canvas item will appear in front of the map layers. While you can create your own subclass of <code class="email">QgsMapCanvasItem</code> if you want to draw custom <a id="id203" class="calibre1"/>items on top of the map canvas, you will find it easier to use an existing subclass that does much of the work for you. There are currently three subclasses of <code class="email">QgsMapCanvasItem</code> that you might find useful:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">QgsVertexMarker</code>: This draws an icon (an "X", a "+", or a small box) centered <a id="id204" class="calibre1"/>around a given point on the map.</li><li class="listitem"><code class="email">QgsRubberBand</code>: This draws an arbitrary polygon or polyline onto the map. It is <a id="id205" class="calibre1"/>intended to provide visual feedback as the user draws a polygon onto the map.</li><li class="listitem"><code class="email">QgsAnnotationItem</code>: This is used to display additional information about a feature, in <a id="id206" class="calibre1"/>the form of a balloon that is connected to the feature. The <code class="email">QgsAnnotationItem</code> class has various subclasses that allow you to customize the <a id="id207" class="calibre1"/>way the information is displayed.</li></ul></div></div><div class="book" title="The QgsMapTool class"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec09" class="calibre1"/>The QgsMapTool class</h3></div></div></div><p class="calibre8">A <span class="strong"><strong class="calibre9">map tool</strong></span> <a id="id208" class="calibre1"/>allows the user to interact with and manipulate the map canvas, capturing mouse events and responding appropriately. A number of <code class="email">QgsMapTool</code> subclasses provide standard map interaction behavior such as clicking to <a id="id209" class="calibre1"/>zoom in, dragging to pan the map, and clicking on a feature to identify it. You can also create your own custom map tools by subclassing <code class="email">QgsMapTool</code> and implementing the various methods that respond to user-interface events such as pressing down the mouse button, dragging the canvas, and so on.</p><p class="calibre8">Once you have created a map tool, you can allow the user to activate it by associating the map tool with a toolbar button. Alternatively, you can activate it from within your Python code by calling the <code class="email">mapCanvas.setMapTool(...)</code> method.</p><p class="calibre8">We will look <a id="id210" class="calibre1"/>at the process of creating your own custom map tool in the section <span class="strong"><em class="calibre10">Using the PyQGIS library</em></span>.</p></div><div class="book" title="Other useful qgis.gui classes"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec10" class="calibre1"/>Other useful qgis.gui classes</h3></div></div></div><p class="calibre8">While the <code class="email">qgis.gui</code> package defines a large number of classes, the ones you are most likely to find useful are given in the following table:</p><div class="informalexample"><table border="1" class="calibre14"><colgroup class="calibre15"><col class="calibre16"/><col class="calibre16"/></colgroup><thead class="calibre17"><tr class="calibre18"><th valign="bottom" class="calibre19">
<p class="calibre20">Class</p>
</th><th valign="bottom" class="calibre19">
<p class="calibre20">Description</p>
</th></tr></thead><tbody class="calibre21"><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">QgsLegendInterface</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">This <a id="id211" class="indexterm"/>provides access to the map legend, that is, the list of map layers within the current project. Note that map layers <a id="id212" class="indexterm"/>can be grouped, hidden, and shown within the map legend.</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">QgsMapTip</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">This <a id="id213" class="indexterm"/>displays a tip on a map canvas when the user holds the mouse over a feature. The map tip will <a id="id214" class="indexterm"/>show the display field for the feature; you can set this by calling <code class="literal">layer.setDisplayField("FIELD")</code>.</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">QgsColorDialog</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">This <a id="id215" class="indexterm"/>is a dialog box that allows the user to select <a id="id216" class="indexterm"/>a color.</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">QgsDialog</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">This <a id="id217" class="indexterm"/>is a generic dialog with a vertical box layout and <a id="id218" class="indexterm"/>a button box, making it easy to add content and standard buttons to your dialog.</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">QgsMessageBar</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">This <a id="id219" class="indexterm"/>is a bar that displays non-blocking messages to the user. We looked at the message bar <a id="id220" class="indexterm"/>class in the previous chapter.</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">QgsMessageViewer</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">This <a id="id221" class="indexterm"/>is a generic class that displays long messages <a id="id222" class="indexterm"/>to the user within a modal dialog.</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">QgsBlendModeComboBox</code>
</p>
<p class="calibre20">
<code class="literal">QgsBrushStyleComboBox</code>
</p>
<p class="calibre20">
<code class="literal">QgsColorRampComboBox</code>
</p>
<p class="calibre20">
<code class="literal">QgsPenCapStyleComboBox</code>
</p>
<p class="calibre20">
<code class="literal">QgsPenJoinStyleComboBox</code>
</p>
<p class="calibre20">
<code class="literal">QgsScaleComboBox</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">These <a id="id223" class="indexterm"/>
<code class="literal">QComboBox</code> user-interface widgets allow you to prompt the user for various drawing options. With the exception of the <code class="literal">QgsScaleComboBox</code>, which lets the user <a id="id224" class="indexterm"/>choose a map scale, all the other <code class="literal">QComboBox</code> subclasses let the user choose various Qt drawing options.</p>
</td></tr></tbody></table></div></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Using the PyQGIS library"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec18" class="calibre1"/>Using the PyQGIS library</h1></div></div></div><p class="calibre8">In the <a id="id225" class="calibre1"/>previous section, we looked at a number of classes provided by the PyQGIS library. Let's make use of these classes to perform some real-world geospatial development tasks.</p></div>

<div class="book" title="Using the PyQGIS library">
<div class="book" title="Analyzing raster data"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec20" class="calibre1"/>Analyzing raster data</h2></div></div></div><p class="calibre8">We're going <a id="id226" class="calibre1"/>to start by writing a program to load in some raster-format data and analyze its contents. To make this more interesting, we'll <a id="id227" class="calibre1"/>use a <span class="strong"><strong class="calibre9">Digital Elevation Model</strong></span> (<span class="strong"><strong class="calibre9">DEM</strong></span>) file, which is a raster format data file that contains elevation data.</p><p class="calibre8">The <a id="id228" class="calibre1"/>
<span class="strong"><strong class="calibre9">Global Land One-Kilometer Base Elevation Project</strong></span> (<span class="strong"><strong class="calibre9">GLOBE</strong></span>) provides free DEM data for the world, where each pixel represents one square kilometer of the Earth's surface. GLOBE data <a id="id229" class="calibre1"/>can be downloaded from <a class="calibre1" href="http://www.ngdc.noaa.gov/mgg/topo/gltiles.html">http://www.ngdc.noaa.gov/mgg/topo/gltiles.html</a>. Download the E tile, which includes the western half of the USA. The resulting file, which is named <code class="email">e10g</code>, contains the height information you need. You'll also need to download the <code class="email">e10g.hdr</code> header file so that QGIS <a id="id230" class="calibre1"/>can read the file—you can download this from <a class="calibre1" href="http://www.ngdc.noaa.gov/mgg/topo/elev/esri/hdr">http://www.ngdc.noaa.gov/mgg/topo/elev/esri/hdr</a>. Once you've downloaded these two files, put them together into a convenient directory.</p><p class="calibre8">You can now load the DEM data into QGIS using the following code:</p><div class="informalexample"><pre class="programlisting">registry = QgsProviderRegistry.instance()
provider = registry.provider("gdal", "/path/to/e10g")</pre></div><p class="calibre8">Unfortunately, there is a slight complexity here. Since QGIS doesn't know which coordinate reference system is used for the data, it displays a dialog box that asks you to choose the CRS. Since the GLOBE DEM data is in the WGS84 CRS, which QGIS uses by default, this dialog box is redundant. To disable it, we need to add the following to the top of our program:</p><div class="informalexample"><pre class="programlisting">from PyQt4.QtCore import QSettings
QSettings().setValue("/Projections/defaultBehaviour", "useGlobal")</pre></div><p class="calibre8">Now that we've loaded our raster DEM data into QGIS, we can analyze it. While there are lots of things we can do with DEM data, let's calculate how often each unique elevation value occurs within the data.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note15" class="calibre1"/>Note</h3><p class="calibre8">Notice that we're loading the DEM data directly using <code class="email">QgsRasterDataProvider</code>. We don't want to display this information on a map, so we don't want (or need) to load it into <code class="email">QgsRasterLayer</code>.</p></div><p class="calibre8">Since the DEM data is in a raster format, you need to iterate over the individual pixels or cells to get each height value. The <code class="email">provider.xSize()</code> and <code class="email">provider.ySize()</code> methods tell us how many cells are there in the DEM, while the <code class="email">provider.extent()</code> method gives us the area of the Earth's surface covered by the DEM. Using this information, we can extract the individual elevation values from the contents of the DEM in the following way:</p><div class="informalexample"><pre class="programlisting">raster_extent = provider.extent()
raster_width = provider.xSize()
raster_height = provider.ySize()
block = provider.block(1, raster_extent, raster_width,
            raster_height)</pre></div><p class="calibre8">The returned <code class="email">block</code> variable is an object of type <code class="email">QgsRasterBlock</code>, which is essentially a two-dimensional array of values. Let's iterate over the raster and extract the individual elevation values:</p><div class="informalexample"><pre class="programlisting">for x in range(raster_width):
  for y in range(raster_height):
    elevation = block.value(x, y)
    ....</pre></div><p class="calibre8">Now that <a id="id231" class="calibre1"/>we've loaded the individual elevation values, it's easy to build a histogram out of those values. Here is the entire program to load the DEM data into memory, and then calculate and display the histogram:</p><div class="informalexample"><pre class="programlisting">from PyQt4.QtCore import QSettings
QSettings().setValue("/Projections/defaultBehaviour", "useGlobal")

registry = QgsProviderRegistry.instance()
provider = registry.provider("gdal", "/path/to/e10g")

raster_extent = provider.extent()
raster_width = provider.xSize()
raster_height = provider.ySize()
no_data_value = provider.srcNoDataValue(1)

histogram = {} # Maps elevation to number of occurrences.

block = provider.block(1, raster_extent, raster_width,
            raster_height)
if block.isValid():
  for x in range(raster_width):
    for y in range(raster_height):
      elevation = block.value(x, y)
      if elevation != no_data_value:
        try:
          histogram[elevation] += 1
        except KeyError:
          histogram[elevation] = 1

for height in sorted(histogram.keys()):
  print height, histogram[height]</pre></div><p class="calibre8">Note that we've added a <span class="strong"><em class="calibre10">no data value</em></span> check to the code. Raster data often includes pixels that have no value associated with them. In the case of a DEM, elevation data is only provided for areas of land; pixels over the sea have no elevation, and we have to exclude them, or our <a id="id232" class="calibre1"/>histogram will be inaccurate.</p></div></div>

<div class="book" title="Using the PyQGIS library">
<div class="book" title="Manipulating vector data and saving it to a shapefile"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec21" class="calibre1"/>Manipulating vector data and saving it to a shapefile</h2></div></div></div><p class="calibre8">Let's <a id="id233" class="calibre1"/>create a program that takes two vector data sources, subtracts one set of vectors from the other, and saves the resulting geometries into a new shapefile. Along the way, we'll learn a few important things about the PyQGIS library.</p><p class="calibre8">We'll be making use of the <code class="email">QgsGeometry.difference()</code> function. This function performs a geometrical subtraction of one geometry from another, like this:</p><div class="mediaobject"><img src="../images/00032.jpeg" alt="Manipulating vector data and saving it to a shapefile" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Let's start by asking the user to select the first shapefile and open up a vector data provider for that file:</p><div class="informalexample"><pre class="programlisting">filename_1 = QFileDialog.getOpenFileName(iface.mainWindow(),
                     "First Shapefile",
                     "~", "*.shp")
if not filename_1:
  return

registry = QgsProviderRegistry.instance()
provider_1 = registry.provider("ogr", filename_1)</pre></div><p class="calibre8">We can then read the geometries from that file into memory:</p><div class="informalexample"><pre class="programlisting">geometries_1 = []
for feature in provider_1.getFeatures(QgsFeatureRequest()):
  geometries_1.append(QgsGeometry(feature.geometry()))</pre></div><p class="calibre8">This last line of code includes an important feature. Notice that we use the following:</p><div class="informalexample"><pre class="programlisting">QgsGeometry(feature.geometry())</pre></div><p class="calibre8">We use the preceding line instead of the following:</p><div class="informalexample"><pre class="programlisting">feature.geometry()</pre></div><p class="calibre8">This is to get the geometry object to add to the list. In other words, we had to create a new geometry object based on the feature's existing geometry object. This is a limitation of the way the QGIS Python wrappers work: the <code class="email">feature.geometry()</code> method returns a reference to the geometry, but the C++ code doesn't know that you are storing this reference away in your Python code. So, when the feature is no longer needed, the memory used by the feature's geometry is also released. If you then try to access that geometry later on, the entire QGIS system will crash. To get around this, we make a copy of the geometry so that we can refer to it even after the feature's memory has been released.</p><p class="calibre8">Now that <a id="id234" class="calibre1"/>we've loaded our first set of geometries into memory, let's do the same for the second shapefile:</p><div class="informalexample"><pre class="programlisting">filename_2 = QFileDialog.getOpenFileName(iface.mainWindow(),
                     "Second Shapefile",
                     "~", "*.shp")
if not filename_2:
  return

provider_2 = registry.provider("ogr", filename_2)

geometries_2 = []
for feature in provider_2.getFeatures(QgsFeatureRequest()):
  geometries_2.append(QgsGeometry(feature.geometry()))</pre></div><p class="calibre8">With the two sets of geometries loaded into memory, we're ready to start subtracting one from the other. However, to make this process more efficient, we will combine the geometries from the second shapefile into one large geometry, which we can then subtract all at once, rather than subtracting one at a time. This will make the subtraction process much faster:</p><div class="informalexample"><pre class="programlisting">combined_geometry = None
for geometry in geometries_2:
  if combined_geometry == None:
    combined_geometry = geometry
  else:
    combined_geometry = combined_geometry.combine(geometry)</pre></div><p class="calibre8">We can now calculate the new set of geometries by subtracting one from the other:</p><div class="informalexample"><pre class="programlisting">dst_geometries = []
for geometry in geometries_1:
  dst_geometry = geometry.difference(combined_geometry)
  if not dst_geometry.isGeosValid(): continue
  if dst_geometry.isGeosEmpty(): continue
  dst_geometries.append(dst_geometry)</pre></div><p class="calibre8">Notice that we check to see whether the destination geometry is mathematically valid and is not empty.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note16" class="calibre1"/>Note</h3><p class="calibre8">Invalid geometries are a common problem when manipulating complex shapes. There are options for fixing them, such as splitting apart multi-geometries and performing a buffer operation. However, doing this is beyond the scope of this book.</p></div><p class="calibre8">Our last task <a id="id235" class="calibre1"/>is to save the resulting geometries into a new shapefile. We'll first ask the user for the name of the destination shapefile:</p><div class="informalexample"><pre class="programlisting">dst_filename = QFileDialog.getSaveFileName(iface.mainWindow(),
                      "Save results to:",
                      "~", "*.shp")
if not dst_filename:
  return</pre></div><p class="calibre8">We'll make use of a <span class="strong"><strong class="calibre9">vector file writer</strong></span> to save the geometries into a shapefile. Let's start by initializing the file writer object:</p><div class="informalexample"><pre class="programlisting">fields = QgsFields()
writer = QgsVectorFileWriter(dst_filename, "ASCII", fields,
               dst_geometries[0].wkbType(),
               None, "ESRI Shapefile")
if writer.hasError() != QgsVectorFileWriter.NoError:
  print "Error!"
  return</pre></div><p class="calibre8">We don't have any attributes in our shapefile, so the fields list is empty. Now that the writer has been set up, we can save the geometries into the file:</p><div class="informalexample"><pre class="programlisting">for geometry in dst_geometries:
  feature = QgsFeature()
  feature.setGeometry(geometry)
  writer.addFeature(feature)</pre></div><p class="calibre8">Now that all the data has been written to the disk, let's display a message box that informs the user that we've finished:</p><div class="informalexample"><pre class="programlisting">QMessageBox.information(iface.mainWindow(), "",
            "Subtracted features saved to disk.")</pre></div><p class="calibre8">As you can see, creating a new shapefile is very straightforward in PyQGIS, and it's easy to manipulate geometries using Python—just so long as you copy the <code class="email">QgsGeometry</code> objects you want to keep around. If your Python code starts to crash while manipulating geometries, this is probably the <a id="id236" class="calibre1"/>first thing you should look for.</p></div></div>

<div class="book" title="Using the PyQGIS library">
<div class="book" title="Using different symbols for different features within a map"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch03lvl2sec22" class="calibre1"/>Using different symbols for different features within a map</h2></div></div></div><p class="calibre8">Let's <a id="id237" class="calibre1"/>use World Borders Dataset that you downloaded in the previous chapter to draw a world map, using different symbols for different continents. This is a good example of using a categorized symbol renderer, though we'll combine it into a script that loads the shapefile into a map layer and sets up the symbols and map renderer to display the map exactly as you want. We'll then save the resulting map as an image.</p><p class="calibre8">Let's start by creating a map layer to display the contents of the World Borders Dataset shapefile:</p><div class="informalexample"><pre class="programlisting">layer = iface.addVectorLayer("/path/to/TM_WORLD_BORDERS-0.3.shp", 
               "continents", "ogr")</pre></div><p class="calibre8">Each unique region code in the World Borders Dataset shapefile corresponds to a continent. We want to define the name and color to use for each of these regions, and use this information to set up the various categories to use when displaying the map:</p><div class="informalexample"><pre class="programlisting">from PyQt4.QtGui import QColor
categories = []
for value,color,label in [(0,   "#660000", "Antarctica"),
                          (2,   "#006600", "Africa"),
                          (9,   "#000066", "Oceania"),
                          (19,  "#660066", "The Americas"),
                          (142, "#666600", "Asia"),
                          (150, "#006666", "Europe")]:
  symbol = QgsSymbolV2.defaultSymbol(layer.geometryType())
  symbol.setColor(QColor(color))
  categories.append(QgsRendererCategoryV2(value, symbol, label))</pre></div><p class="calibre8">With these categories set up, we simply update the map layer to use a categorized renderer based on the value of the <code class="email">region</code> attribute, and then redraw the map:</p><div class="informalexample"><pre class="programlisting">layer.setRendererV2(QgsCategorizedSymbolRendererV2("region",
                          categories))
layer.triggerRepaint()</pre></div><p class="calibre8">There's only one more thing to do, since this is a script that can be run multiple times, let's have our script automatically remove the existing <code class="email">continents</code> layer, if it exists, before adding a new one. To do this, we can add the following to the start of our script:</p><div class="informalexample"><pre class="programlisting">layer_registry = QgsMapLayerRegistry.instance()
for layer in layer_registry.mapLayersByName("continents"):
  layer_registry.removeMapLayer(layer.id())</pre></div><p class="calibre8">Now <a id="id238" class="calibre1"/>when our script is run, it will create one (and only one) layer that shows the various continents in different colors. These will appear as different shades of gray in the printed book, but the colors will be visible on the computer screen:</p><div class="mediaobject"><img src="../images/00033.jpeg" alt="Using different symbols for different features within a map" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Now, let's use the same data set to color each country based on its relative population. We'll start by removing the existing <code class="email">"population"</code> layer, if it exists:</p><div class="informalexample"><pre class="programlisting">layer_registry = QgsMapLayerRegistry.instance()
for layer in layer_registry.mapLayersByName("population"):
  layer_registry.removeMapLayer(layer.id())</pre></div><p class="calibre8">Next, we open the World Borders Dataset into a new layer called <code class="email">"population"</code>:</p><div class="informalexample"><pre class="programlisting">layer = iface.addVectorLayer("/path/to/TM_WORLD_BORDERS-0.3.shp", 
               "population", "ogr")</pre></div><p class="calibre8">We then need to set up our various population ranges:</p><div class="informalexample"><pre class="programlisting">from PyQt4.QtGui import QColor
ranges = []
for min_pop,max_pop,color in [(0,        99999,     "#332828"),
                              (100000,   999999,    "#4c3535"),
                              (1000000,  4999999,   "#663d3d"),
                              (5000000,  9999999,   "#804040"),
                              (10000000, 19999999,  "#993d3d"),
                              (20000000, 49999999,  "#b33535"),
                              (50000000, 999999999, "#cc2828")]:
  symbol = QgsSymbolV2.defaultSymbol(layer.geometryType())
  symbol.setColor(QColor(color))
  ranges.append(QgsRendererRangeV2(min_pop, max_pop,
                   symbol, ""))</pre></div><p class="calibre8">Now that <a id="id239" class="calibre1"/>we have our population ranges and their associated colors, we simply set up a graduated symbol renderer to choose a symbol based on the value of the <code class="email">pop2005</code> attribute, and tell the map to redraw itself:</p><div class="informalexample"><pre class="programlisting">layer.setRendererV2(QgsGraduatedSymbolRendererV2("pop2005",
                         ranges))
layer.triggerRepaint()</pre></div><p class="calibre8">The result will be a map layer that shades each country according to its population:</p><div class="mediaobject"><img src="../images/00034.jpeg" alt="Using different symbols for different features within a map" class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div class="book" title="Using the PyQGIS library">
<div class="book" title="Calculating the distance between two user-defined points"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch03lvl2sec23" class="calibre1"/>Calculating the distance between two user-defined points</h2></div></div></div><p class="calibre8">In our <a id="id240" class="calibre1"/>final example of using the PyQGIS library, we'll write some code that, when run, starts listening for mouse events from the user. If the user clicks on a point, drags the mouse, and then releases the mouse button again, we will display the distance between those two points. This is a good example of how to add your own map interaction logic to QGIS, using the <code class="email">QgsMapTool</code> class.</p><p class="calibre8">This is the basic structure for our <code class="email">QgsMapTool</code> subclass:</p><div class="informalexample"><pre class="programlisting">class DistanceCalculator(QgsMapTool):
  def __init__(self, iface):
    QgsMapTool.__init__(self, iface.mapCanvas())
    self.iface = iface

  def canvasPressEvent(self, event):
    ...

  def canvasReleaseEvent(self, event):
    ...</pre></div><p class="calibre8">To make this map tool active, we'll create a new instance of it and pass it to the <code class="email">mapCanvas.setMapTool()</code> method. Once this is done, our <code class="email">canvasPressEvent()</code> and <code class="email">canvasReleaseEvent()</code> methods will be called whenever the user clicks or releases the mouse button over the map canvas.</p><p class="calibre8">Let's start with the code that responds when the user clicks on the canvas. In this method, we're going to convert from the pixel coordinates that the user clicked on to the corresponding map coordinates (that is, a latitude and longitude value). We'll then remember these coordinates so that we can refer to them later. Here is the necessary code:</p><div class="informalexample"><pre class="programlisting">def canvasPressEvent(self, event):
  transform = self.iface.mapCanvas().getCoordinateTransform()
  self._startPt = transform.toMapCoordinates(event.pos().x(),
                        event.pos().y())</pre></div><p class="calibre8">When the <code class="email">canvasReleaseEvent()</code> method is called, we'll want to do the same with the point at which the user released the mouse button:</p><div class="informalexample"><pre class="programlisting">def canvasReleaseEvent(self, event):
  transform = self.iface.mapCanvas().getCoordinateTransform()
  endPt = transform.toMapCoordinates(event.pos().x(),
                    event.pos().y())</pre></div><p class="calibre8">Now that <a id="id241" class="calibre1"/>we have the two desired coordinates, we'll want to calculate the distance between them. We can do this using a <code class="email">QgsDistanceArea</code> object:</p><div class="informalexample"><pre class="programlisting">  crs = self.iface.mapCanvas().mapRenderer().destinationCrs()
  distance_calc = QgsDistanceArea()
  distance_calc.setSourceCrs(crs)
  distance_calc.setEllipsoid(crs.ellipsoidAcronym())
  distance_calc.setEllipsoidalMode(crs.geographicFlag())
  distance = distance_calc.measureLine([self._startPt,
                     endPt]) / 1000</pre></div><p class="calibre8">Notice that we divide the resulting value by 1000. This is because the <code class="email">QgsDistanceArea</code> object returns the distance in meters, and we want to display the distance in kilometers.</p><p class="calibre8">Finally, we'll display the calculated distance in the QGIS message bar:</p><div class="informalexample"><pre class="programlisting">  messageBar = self.iface.messageBar()
  messageBar.pushMessage("Distance = %d km" % distance,
              level=QgsMessageBar.INFO,
              duration=2)</pre></div><p class="calibre8">Now that we've created our map tool, we need to activate it. We can do this by adding the following to the end of our script:</p><div class="informalexample"><pre class="programlisting">calculator = DistanceCalculator(iface)
iface.mapCanvas().setMapTool(calculator)</pre></div><p class="calibre8">With the map tool activated, the user can click and drag on the map. When the mouse button is released, the distance (in kilometers) between the two points will be displayed in the message bar:</p><div class="mediaobject"><img src="../images/00035.jpeg" alt="Calculating the distance between two user-defined points" class="calibre11"/></div><p class="calibre12"> </p></div></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec19" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we took an in-depth look at the PyQGIS libraries and how you can use them in your own programs. We learned that the QGIS Python libraries are implemented as wrappers around the QGIS APIs implemented in C++. We saw how Python programmers can understand and work with the QGIS reference documentation, even though it is written for C++ developers. We also looked at the way the PyQGIS libraries are organized into different packages, and learned about the most important classes defined in the <code class="email">qgis.core</code> and <code class="email">qgis.gui</code> packages.</p><p class="calibre8">We then saw how a coordinate reference systems (CRS) is used to translate from points on the three-dimensional surface of the Earth to coordinates within a two-dimensional map plane.</p><p class="calibre8">We learned that vector format data is made up of features, where each feature has an ID, a geometry, and a set of attributes, and that symbols are used to draw vector geometries onto a map layer, while renderers are used to choose which symbol to use for a given feature.</p><p class="calibre8">We learned how a spatial index can be used to speed up access to vector features.</p><p class="calibre8">Next, we saw how raster format data is organized into bands that represent information such as color, elevation, and so on, and looked at the various ways in which a raster data source can be displayed within a map layer. Along the way, we learned how to access the contents of a raster data source.</p><p class="calibre8">Finally, we looked at various techniques for performing useful tasks using the PyQGIS library.</p><p class="calibre8">In the next chapter, we will learn more about QGIS Python plugins, and then go on to use the plugin architecture as a way of implementing a useful feature within a mapping application.</p></div></body></html>