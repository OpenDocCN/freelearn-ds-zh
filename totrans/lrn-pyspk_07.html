<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 7. GraphFrames"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. GraphFrames</h1></div></div></div><p>Graphs are an interesting way to solve data problems because graph structures are a more intuitive approach to many classes of data problems.</p><p>In this chapter, you will learn about:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Why use graphs?</li><li class="listitem" style="list-style-type: disc">Understanding the classic graph problem: the flights dataset</li><li class="listitem" style="list-style-type: disc">Understanding the graph vertices and edges</li><li class="listitem" style="list-style-type: disc">Simple queries</li><li class="listitem" style="list-style-type: disc">Using motif finding</li><li class="listitem" style="list-style-type: disc">Using breadth first search</li><li class="listitem" style="list-style-type: disc">Using PageRank</li><li class="listitem" style="list-style-type: disc">Visualizing flights using D3</li></ul></div><p>Whether traversing social networks or restaurant recommendations, it is easier to understand these data problems within the context of graph structures: vertices, edges, and properties:</p><div class="mediaobject"><img src="images/B05793_07_01.jpg" alt="GraphFrames"/></div><p>For example, within the<a id="id435" class="indexterm"/> context of <span class="strong"><strong>social networks</strong></span>, the <span class="emphasis"><em>vertices </em></span>are the people while the <span class="emphasis"><em>edges</em></span> are the connections between them. Within the context of <span class="strong"><strong>restaurant recommendations</strong></span>, the vertices (for example) involve the location, cuisine type, and restaurants while the edges are the connections between them (for example, these three restaurants are in <span class="strong"><strong>Vancouver, BC</strong></span>, but only two of them serve ramen).</p><p>While the two graphs are seemingly disconnected, you can in fact create a social network + restaurant recommendation graph based on the reviews of friends within a social circle, as noted in the following figure:</p><div class="mediaobject"><img src="images/B05793_07_02.jpg" alt="GraphFrames"/></div><p>For example, if <span class="strong"><strong>Isabella</strong></span> wants to find a great ramen restaurant in Vancouver, traversing her friends' reviews, she will most likely choose <span class="strong"><strong>Kintaro Ramen</strong></span>, as both <span class="strong"><strong>Samantha</strong></span> and <span class="strong"><strong>Juliette</strong></span> have rated the restaurant favorably:</p><div class="mediaobject"><img src="images/B05793_07_03.jpg" alt="GraphFrames"/></div><p>Another classic graph problem is the analysis of flight data: airports are represented by <span class="emphasis"><em>vertices</em></span> and flights between those airports are represented by <span class="emphasis"><em>edges</em></span>. Also, there are numerous <span class="emphasis"><em>properties</em></span> associated with these flights, including, but not limited to, departure delays, plane type, and carrier:</p><div class="mediaobject"><img src="images/B05793_07_04.jpg" alt="GraphFrames"/></div><p>In this chapter, we will use GraphFrames to quickly and easily analyze flight performance data organized in graph structures. Because we're using graph structures, we can easily ask many questions that are not as intuitive as tabular structures, such as finding structural motifs, airport ranking using PageRank, and shortest paths between cities. GraphFrames leverages the distribution and expression capabilities of the DataFrame API to both simplify your queries and leverage the performance optimizations of the Apache Spark SQL engine.</p><p>In addition, with GraphFrames, graph analysis is available in Python, Scala, and Java. Just as important, you can leverage your existing Apache Spark skills to solve graph problems (in addition to machine learning, streaming, and SQL) instead of making a paradigm shift to learn a new framework.</p><div class="section" title="Introducing GraphFrames"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec43"/>Introducing GraphFrames</h1></div></div></div><p>GraphFrames utilizes<a id="id436" class="indexterm"/> the power of Apache Spark DataFrames to support general graph processing. Specifically, the vertices and edges are represented by DataFrames allowing us to store arbitrary data with each vertex and edge. While GraphFrames is similar to Spark's GraphX library, there are some key differences, including:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">GraphFrames leverage the performance optimizations and simplicity of the DataFrame API.</li><li class="listitem" style="list-style-type: disc">By using the DataFrame API, GraphFrames now have Python, Java, and Scala APIs. GraphX is only accessible through Scala; now all its algorithms are available in Python and Java.</li><li class="listitem" style="list-style-type: disc">Note, at the time of writing, there was a bug preventing GraphFrames from working with Python3.x, hence we will be using Python2.x.</li></ul></div><p>At the time of writing, GraphFrames is<a id="id437" class="indexterm"/> on version 0.3 and available as a Spark package (<a class="ulink" href="http://spark-packages.org">http://spark-packages.org</a>) at <a class="ulink" href="https://spark-packages.org/package/graphframes/graphframes">https://spark-packages.org/package/graphframes/graphframes</a>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip31"/>Tip</h3><p>For more information about GraphFrames, please refer to <span class="emphasis"><em>Introducing GraphFra</em></span>
<span class="emphasis"><em>mes</em></span> at <a class="ulink" href="https://databricks.com/blog/2016/03/03/introducing-graphframes.html">https://databricks.com/blog/2016/03/03/introducing-graphframes.html</a>.</p></div></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Installing GraphFrames"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec44"/>Installing GraphFrames</h1></div></div></div><p>If you are running<a id="id438" class="indexterm"/> your job from a Spark CLI (for example, <code class="literal">spark-shell, pyspark, spark-sql, spark-submit</code>), you can use the <code class="literal">–-packages</code> command, which will extract, compile, and execute the necessary code for you to use the GraphFrames package.</p><p>For example, to use the latest GraphFrames package (version 0.3) with Spark 2.0 and Scala 2.11 with spark-shell, the command is:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; $SPARK_HOME/bin/spark-shell --packages graphframes:graphframes:0.3.0-spark2.0-s_2.11</strong></span>
</pre></div><p>If you are using<a id="id439" class="indexterm"/> a notebook service, you may need to install the package first. For example, the following section shows the steps to install the<a id="id440" class="indexterm"/> GraphFrames library within the free Databricks Community Edition (<a class="ulink" href="http://databricks.com/try-databricks">http://databricks.com/try-databricks</a>).</p><div class="section" title="Creating a library"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec78"/>Creating a library</h2></div></div></div><p>Within Databricks, you can create a library that is comprised of a Scala/Java JAR, Python Egg, or<a id="id441" class="indexterm"/> Maven Coordinate (including the Spark package).</p><p>To start, go to your <span class="strong"><strong>Workspace</strong></span> within <span class="strong"><strong>databricks</strong></span>, right-click the folder you want to create the library in (in this case, <span class="strong"><strong>flights</strong></span>), click <span class="strong"><strong>Create</strong></span>, and then click <span class="strong"><strong>Library</strong></span>:</p><div class="mediaobject"><img src="images/B05793_07_05.jpg" alt="Creating a library"/></div><p>In the <span class="strong"><strong>Create Library</strong></span> dialog, choose within the <span class="strong"><strong>Source</strong></span> dropdown, <span class="strong"><strong>Maven Coordinate</strong></span> as noted in the following diagram:</p><div class="mediaobject"><img src="images/B05793_07_06.jpg" alt="Creating a library"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip32"/>Tip</h3><p>Maven is a tool<a id="id442" class="indexterm"/> that is used to build and manage Java-based projects such as the GraphFrames project. Maven coordinates uniquely identify those projects (or dependencies or plug-ins) so you can quickly find the project within a Maven repository; for example, <a class="ulink" href="https://mvnrepository.com/artifact/graphframes/graphframes">https://mvnrepository.com/artifact/graphframes/graphframes</a>.</p></div></div><p>From here, you can<a id="id443" class="indexterm"/> click the <span class="strong"><strong>Search Spark Packages and Maven Central</strong></span> button and search for the GraphFrames package. Ensure that you match the GraphFrames version of Spark (for example, Spark 2.0) and Scala (for example, Scala 2.11) with your Spark cluster.</p><p>You can also enter the Maven coordinate for the GraphFrames Spark package if you already know it. For Spark 2.0 and Scala 2.11, enter the following coordinate:</p><div class="informalexample"><pre class="programlisting">graphframes:graphframes:0.3.0-spark2.0-s_2.11</pre></div><p>Once entered, click on <span class="strong"><strong>Create Library</strong></span>, as noted in the following screenshot:</p><div class="mediaobject"><img src="images/B05793_07_07.jpg" alt="Creating a library"/></div><p>Note that this is a one-time installation task for the GraphFrames Spark package (as part of a library). Once it<a id="id444" class="indexterm"/> is installed, you can by default automatically auto-attach the package to any Databricks cluster that you create:</p><div class="mediaobject"><img src="images/B05793_07_08.jpg" alt="Creating a library"/></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Preparing your flights dataset"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec45"/>Preparing your flights dataset</h1></div></div></div><p>For this<a id="id445" class="indexterm"/> flights sample scenario, we will make use of two sets of data:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Airline On-Time Performance and Causes of Flight Delays</em></span>: [<a class="ulink" href="http://bit.ly/2ccJPPM">http://bit.ly/2ccJPPM</a>] This dataset contains scheduled and actual departure and arrival times, and delay causes as reported by US air carriers. The data<a id="id446" class="indexterm"/> is collected by the Office<a id="id447" class="indexterm"/> of Airline Information, <span class="strong"><strong>Bureau of Transportation Statistics</strong></span> (<span class="strong"><strong>BTS</strong></span>).</li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Open Flights: Airports and airline data</em></span>: [<a class="ulink" href="http://openflights.org/data.html">http://openflights.org/data.html</a>] This dataset contains the list of US airport data including the IATA code, airport name, and airport location.</li></ul></div><p>We will create two DataFrames – <code class="literal">airports</code> and <code class="literal">departureDelays</code>–which will make up our <span class="strong"><strong>vertices</strong></span> and <span class="strong"><strong>edges</strong></span> of our<a id="id448" class="indexterm"/> GraphFrame, respectively. We will be creating this flights sample application<a id="id449" class="indexterm"/> using Python.</p><p>As we are<a id="id450" class="indexterm"/> using a Databricks notebook for our example, we can make use of the <code class="literal">/databricks-datasets/</code>location, which contains numerous sample datasets. You can<a id="id451" class="indexterm"/> also download the data from:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">depa</code><code class="literal">rtureDelays.csv</code>: <a class="ulink" href="http://bit.ly/2ejPr8k">http://bit.ly/2ejPr8k</a></li><li class="listitem" style="list-style-type: disc"><code class="literal">airportCodes</code>: <a class="ulink" href="http://bit.ly/2ePAdKT">http://bit.ly/2ePAdKT</a></li></ul></div><p>In this example, we are<a id="id452" class="indexterm"/> creating two variables denoting the file paths for our Airports and Departure Delays data, respectively. Then we will load these datasets and create the respective Spark DataFrames; note for both of these files, we can easily infer the schema:</p><div class="informalexample"><pre class="programlisting"># Set File Paths
tripdelaysFilePath = "/databricks-datasets/flights/departuredelays.csv"
airportsnaFilePath = "/databricks-datasets/flights/airport-codes-na.txt"

# Obtain airports dataset
# Note, this dataset is tab-delimited with a header
airportsna = spark.read.csv(airportsnaFilePath, header='true', inferSchema='true', sep='\t')
airportsna.createOrReplaceTempView("airports_na")

# Obtain departure Delays data
# Note, this dataset is comma-delimited with a header
departureDelays = spark.read.csv(tripdelaysFilePath, header='true')
departureDelays.createOrReplaceTempView("departureDelays")
departureDelays.cache()</pre></div><p>Once we loaded the <code class="literal">departureDelays</code> DataFrame, we also cache it so we can include some additional filtering of the data in a performant manner:</p><div class="informalexample"><pre class="programlisting"># Available IATA codes from the departuredelays sample dataset
tripIATA = spark.sql("select distinct iata from (select distinct origin as iata from departureDelays union all select distinct destination as iata from departureDelays) a")
tripIATA.createOrReplaceTempView("tripIATA")</pre></div><p>The preceding query allows us to build a distinct list with origin city IATA codes (for example, <code class="literal">Seattle = 'SEA', San Francisco = 'SFO', New York JFK = 'JFK'</code>, and so on). Next, we only include airports that had a trip occur within the <code class="literal">departureDelays</code> DataFrame:</p><div class="informalexample"><pre class="programlisting"># Only include airports with atleast one trip from the 
# `departureDelays` dataset
airports = spark.sql("select f.IATA, f.City, f.State, f.Country from airports_na f join tripIATA t on t.IATA = f.IATA")
airports.createOrReplaceTempView("airports")
airports.cache()</pre></div><p>By building the distinct list of origin airport codes, we can build the airports DataFrame to contain only the<a id="id453" class="indexterm"/> airport codes that exist in the <code class="literal">departureDelays</code> dataset. The following code snippet generates a new DataFrame (<code class="literal">departureDelays_geo</code>) that is comprised of key attributes including date of flight, delays, distance, and airport information (origin, destination):</p><div class="informalexample"><pre class="programlisting"># Build `departureDelays_geo` DataFrame
# Obtain key attributes such as Date of flight, delays, distance, 
# and airport information (Origin, Destination)  
departureDelays_geo = spark.sql("select cast(f.date as int) as tripid, cast(concat(concat(concat(concat(concat(concat('2014-', concat(concat(substr(cast(f.date as string), 1, 2), '-')), substr(cast(f.date as string), 3, 2)), ''), substr(cast(f.date as string), 5, 2)), ':'), substr(cast(f.date as string), 7, 2)), ':00') as timestamp) as `localdate`, cast(f.delay as int), cast(f.distance as int), f.origin as src, f.destination as dst, o.city as city_src, d.city as city_dst, o.state as state_src, d.state as state_dst from departuredelays f join airports o on o.iata = f.origin join airports d on d.iata = f.destination") 

# Create Temporary View and cache
departureDelays_geo.createOrReplaceTempView("departureDelays_geo")
departureDelays_geo.cache()</pre></div><p>To take a quick peek into this data, you can run the <code class="literal">show</code> method as shown here:</p><div class="informalexample"><pre class="programlisting"># Review the top 10 rows of the `departureDelays_geo` DataFrame
departureDelays_geo.show(10)</pre></div><div class="mediaobject"><img src="images/B05793_07_09.jpg" alt="Preparing your flights dataset"/></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Building the graph"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec46"/>Building the graph</h1></div></div></div><p>Now that we've imported our data, let's build our graph. To do this, we're going to build the structure for<a id="id454" class="indexterm"/> our vertices and edges. At the time of writing, GraphFrames requires a specific naming convention for vertices and edges:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The column representing the <span class="emphasis"><em>vertices</em></span> needs to have the name of<code class="literal">id</code>. In our case, the vertices of our flight data are the airports. Therefore, we will need to rename the IATA airport code to <code class="literal">id</code> in our <code class="literal">airports</code> DataFrame.</li><li class="listitem" style="list-style-type: disc">The columns representing the <span class="emphasis"><em>edges</em></span> need to have a source (<code class="literal">src</code>) and destination (<code class="literal">dst</code>). For our flight data, the edges are the flights, therefore the <code class="literal">src</code> and <code class="literal">dst</code> are the origin and destination columns from the <code class="literal">departureDelays_geo</code> DataFrame.</li></ul></div><p>To simplify the edges for our graph, we will create the <code class="literal">tripEdges</code> DataFrame with a subset of the columns available within the <code class="literal">departureDelays_Geo</code> DataFrame. As well, we created a <code class="literal">tripVertices</code> DataFrame that simply renames the <code class="literal">IATA</code> column to <code class="literal">id</code> to match the GraphFrame naming convention:</p><div class="informalexample"><pre class="programlisting"># Note, ensure you have already installed 
# the GraphFrames spark-package
from pyspark.sql.functions import *
from graphframes import *

# Create Vertices (airports) and Edges (flights)
tripVertices = airports.withColumnRenamed("IATA", "id").distinct()
tripEdges = departureDelays_geo.select("tripid", "delay", "src", "dst", "city_dst", "state_dst")

# Cache Vertices and Edges
tripEdges.cache()
tripVertices.cache()</pre></div><p>Within Databricks, you can<a id="id455" class="indexterm"/> query the data using the <code class="literal">display</code> command. For example, to view the <code class="literal">tripEdges</code> DataFrame, the command is as follows:</p><div class="informalexample"><pre class="programlisting">display(tripEdges)</pre></div><p>The output is as follows:</p><div class="mediaobject"><img src="images/B05793_07_10.jpg" alt="Building the graph"/></div><p>Now that we have the two DataFrames, we can create a GraphFrame using the <code class="literal">GraphFrame</code> command:</p><div class="informalexample"><pre class="programlisting">tripGraph = GraphFrame(tripVertices, tripEdges)</pre></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Executing simple queries"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec47"/>Executing simple queries</h1></div></div></div><p>Let's start with<a id="id456" class="indexterm"/> a set of simple graph queries to understand flight performance and departure delays.</p><div class="section" title="Determining the number of airports and trips"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec79"/>Determining the number of airports and trips</h2></div></div></div><p>For example, to determine<a id="id457" class="indexterm"/> the number of airports<a id="id458" class="indexterm"/> and trips, you can run the following commands:</p><div class="informalexample"><pre class="programlisting">print "Airports: %d" % tripGraph.vertices.count()
print "Trips: %d" % tripGraph.edges.count()</pre></div><p>As you can<a id="id459" class="indexterm"/> see from the results, there are 279 airports<a id="id460" class="indexterm"/> with 1.36 million trips:</p><div class="mediaobject"><img src="images/B05793_07_11.jpg" alt="Determining the number of airports and trips"/></div></div><div class="section" title="Determining the longest delay in this dataset"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec80"/>Determining the longest delay in this dataset</h2></div></div></div><p>To determine<a id="id461" class="indexterm"/> the longest delayed flight in the dataset, you can run the following query with the result of 1,642 minutes (that's more than 27 hours!):</p><div class="informalexample"><pre class="programlisting">tripGraph.edges.groupBy().max("delay")

# Output
+----------+
|max(delay)| 
+----------+ 
|      1642| 
+----------+</pre></div></div><div class="section" title="Determining the number of delayed versus on-time/early flights"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec81"/>Determining the number of delayed versus on-time/early flights</h2></div></div></div><p>To determine<a id="id462" class="indexterm"/> the number of delayed versus on-time (or early) flights, you can run the following queries:</p><div class="informalexample"><pre class="programlisting">print "On-time / Early Flights: %d" % tripGraph.edges.filter("delay &lt;= 0").count()
print "Delayed Flights: %d" % tripGraph.edges.filter("delay &gt; 0").count()</pre></div><p>with the results<a id="id463" class="indexterm"/> nothing that almost 43% of the flights were delayed!</p><div class="mediaobject"><img src="images/B05793_07_12.jpg" alt="Determining the number of delayed versus on-time/early flights"/></div></div><div class="section" title="What flights departing Seattle are most likely to have significant delays?"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec82"/>What flights departing Seattle are most likely to have significant delays?</h2></div></div></div><p>Digging further<a id="id464" class="indexterm"/> in this data, let's find out the top five destinations for flights departing from Seattle that are most likely to have significant delays. This can be achieved through the following query:</p><div class="informalexample"><pre class="programlisting">tripGraph.edges\
  .filter("src = 'SEA' and delay &gt; 0")\
  .groupBy("src", "dst")\
  .avg("delay")\
  .sort(desc("avg(delay)"))\
  .show(5)</pre></div><p>As you can see in the following results: Philadelphia (PHL), Colorado Springs (COS), Fresno (FAT), Long Beach (LGB), and Washington D.C (IAD) are the top five cities with flights delayed originating from Seattle:</p><div class="mediaobject"><img src="images/B05793_07_13.jpg" alt="What flights departing Seattle are most likely to have significant delays?"/></div></div><div class="section" title="What states tend to have significant delays departing from Seattle?"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec83"/>What states tend to have significant delays departing from Seattle?</h2></div></div></div><p>Let's find which<a id="id465" class="indexterm"/> states have the longest cumulative delays (with individual delays &gt; 100 minutes) originating from Seattle. This time we will use the <code class="literal">display</code> command to review the data:</p><div class="informalexample"><pre class="programlisting"># States with the longest cumulative delays (with individual
# delays &gt; 100 minutes) (origin: Seattle)
display(tripGraph.edges.filter("src = 'SEA' and delay &gt; 100"))</pre></div><div class="mediaobject"><img src="images/B05793_07_14.jpg" alt="What states tend to have significant delays departing from Seattle?"/></div><p>Using the Databricks <code class="literal">display</code> command, we can also quickly change from this table view to<a id="id466" class="indexterm"/> a map view of the data. As can be seen in the following figure, the state with the most cumulative delays originating from Seattle (in this dataset) is California:</p><div class="mediaobject"><img src="images/B05793_07_15.jpg" alt="What states tend to have significant delays departing from Seattle?"/></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Understanding vertex degrees"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec48"/>Understanding vertex degrees</h1></div></div></div><p>Within the context<a id="id467" class="indexterm"/> of graph theory, the degrees around a vertex are the number of edges around the vertex. In our <span class="emphasis"><em>flights</em></span> example, the degrees are then the total number of edges (that is, flights) to the vertex (that is, airports). Therefore, if we were to obtain the top 20 vertex degrees (in descending order) from our graph, then we would be asking for the top 20 busiest airports (most flights in and out) from our graph. This can be quickly determined using the following query:</p><div class="informalexample"><pre class="programlisting">display(tripGraph.degrees.sort(desc("degree")).limit(20))</pre></div><p>Because we're using the <code class="literal">display</code> command, we can quickly view a bar graph of this data:</p><div class="mediaobject"><img src="images/B05793_07_16.jpg" alt="Understanding vertex degrees"/></div><p>Diving into<a id="id468" class="indexterm"/> more details, here are the top 20 <code class="literal">inDegrees</code> (that is, incoming flights):</p><div class="informalexample"><pre class="programlisting">display(tripGraph.inDegrees.sort(desc("inDegree")).limit(20))</pre></div><div class="mediaobject"><img src="images/B05793_07_17.jpg" alt="Understanding vertex degrees"/></div><p>While here are the top 20 <code class="literal">outDegrees</code> (that is, outgoing flights):</p><div class="informalexample"><pre class="programlisting">display(tripGraph.outDegrees.sort(desc("outDegree")).limit(20))</pre></div><div class="mediaobject"><img src="images/B05793_07_18.jpg" alt="Understanding vertex degrees"/></div><p>Interestingly, while the top 10 airports (Atlanta/ATL to Charlotte/CLT) are ranked the same for incoming<a id="id469" class="indexterm"/> and outgoing flights, the ranks of the next 10 airports change (for example, Seattle/SEA is 17th for incoming flights, but 18th for outgoing).</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Determining the top transfer airports"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec49"/>Determining the top transfer airports</h1></div></div></div><p>An extension of<a id="id470" class="indexterm"/> understanding vertex degrees for airports is to determine the top transfer airports. Many airports are used as transfer points instead of being the final destination. An easy way to calculate this is by calculating the ratio of <code class="literal">inDegrees</code> (the number of flights to the airport) and / <code class="literal">outDegrees</code> (the number of flights leaving the airport). Values close to <code class="literal">1</code> may indicate many transfers, whereas values &lt;<code class="literal">1</code> indicate many outgoing flights and values &gt;<code class="literal">1</code> indicate many incoming flights.</p><p>Note that this is a simple calculation that does not consider timing or scheduling of flights, just the overall aggregate number within the dataset:</p><div class="informalexample"><pre class="programlisting"># Calculate the inDeg (flights into the airport) and 
# outDeg (flights leaving the airport)
inDeg = tripGraph.inDegrees
outDeg = tripGraph.outDegrees

# Calculate the degreeRatio (inDeg/outDeg)
degreeRatio = inDeg.join(outDeg, inDeg.id == outDeg.id) \
  .drop(outDeg.id) \
  .selectExpr("id", "double(inDegree)/double(outDegree) as degreeRatio") \
  .cache()

# Join back to the 'airports' DataFrame 
# (instead of registering temp table as above)
transferAirports = degreeRatio.join(airports, degreeRatio.id == airports.IATA) \
  .selectExpr("id", "city", "degreeRatio") \
  .filter("degreeRatio between 0.9 and 1.1")

# List out the top 10 transfer city airports
display(transferAirports.orderBy("degreeRatio").limit(10))</pre></div><p>The output of this<a id="id471" class="indexterm"/> query is a bar chart of the top 10 transfer city airports (that is, hub airports):</p><div class="mediaobject"><img src="images/B05793_07_22.jpg" alt="Determining the top transfer airports"/></div><p>This makes sense since these airports are major hubs for national airlines (for example, Delta uses <span class="strong"><strong>Minneapolis</strong></span> and <span class="strong"><strong>Salt Lake City</strong></span> as its hub, Frontier uses <span class="strong"><strong>Denver</strong></span>, American uses <span class="strong"><strong>Dallas</strong></span> and <span class="strong"><strong>Phoenix</strong></span>, United uses <span class="strong"><strong>Houston</strong></span>, <span class="strong"><strong>Chicago</strong></span>, and <span class="strong"><strong>San Francisco</strong></span>, and Hawaiian Airlines uses <span class="strong"><strong>Kahului</strong></span> and <span class="strong"><strong>Honolulu</strong></span> as its hubs).</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Understanding motifs"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec50"/>Understanding motifs</h1></div></div></div><p>To easily understand<a id="id472" class="indexterm"/> the complex relationship of city airports and the flights between each other, we can use <code class="literal">motifs</code> to find patterns of airports (for example, vertices) connected by flights (that is, edges). The result is a DataFrame in which the column names are given by the motif keys. Note that motif finding is one of the new graph algorithms supported as part of GraphFrames.</p><p>For example, let's determine the delays that are due to <span class="strong"><strong>San Francisco International Airport</strong></span> (<span class="strong"><strong>SFO</strong></span>):</p><div class="informalexample"><pre class="programlisting"># Generate motifs
motifs = tripGraphPrime.find("(a)-[ab]-&gt;(b); (b)-[bc]-&gt;(c)")\
  .filter("(b.id = 'SFO') and (ab.delay &gt; 500 or bc.delay &gt; 500) and bc.tripid &gt; ab.tripid and bc.tripid &lt; ab.tripid + 10000")

# Display motifs
display(motifs)</pre></div><p>Breaking down the<a id="id473" class="indexterm"/> preceding query, the <code class="literal">(x)</code> represents the vertex (that is, airport) while the <code class="literal">[xy]</code> represents the edge (that is, flights between airports). Therefore, to determine the delays that are due to SFO, use the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The vertex <code class="literal">(b)</code> represents the airport in the middle (that is, SFO)</li><li class="listitem" style="list-style-type: disc">The vertex<code class="literal">(a)</code>represents the origin airport (within the dataset)</li><li class="listitem" style="list-style-type: disc">The vertex <code class="literal">(c)</code> represents the destination airport (within the dataset)</li><li class="listitem" style="list-style-type: disc">The edge <code class="literal">[ab]</code> represents the flight between <code class="literal">(a)</code> (that is, origin) and <code class="literal">(b)</code> (that is, SFO)</li><li class="listitem" style="list-style-type: disc">The edge <code class="literal">[bc]</code> represents the flight between <code class="literal">(b)</code> (that is, SFO) and <code class="literal">(c)</code> (that is, destination)</li></ul></div><p>Within the <code class="literal">filter</code> statement, we put in some rudimentary constraints (note that this is an over simplistic representation of flight paths):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">b.id = 'SFO'</code> denotes that the middle vertex <code class="literal">(b)</code> is limited to just SFO airport</li><li class="listitem" style="list-style-type: disc"><code class="literal">(ab.delay &gt; 500 or bc.delay &gt; 500)</code> denotes that we are limited to flights that have delays greater than 500 minutes</li><li class="listitem" style="list-style-type: disc"><code class="literal">(bc.tripid &gt; ab.tripid and bc.tripid &lt; ab.tripid + 10000) </code>denotes that the <code class="literal">(ab)</code> flight must be before the <code class="literal">(bc)</code> trip and within the same day. The <code class="literal">tripid</code> was derived from the date time, thus explaining why it could be simplified this way</li></ul></div><p>The output of this query is noted in the following figure:</p><div class="mediaobject"><img src="images/B05793_07_19.jpg" alt="Understanding motifs"/></div><p>The following is a<a id="id474" class="indexterm"/> simplified abridged subset from this query where the columns are the respective motif keys:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>a</p>
</th><th style="text-align: left" valign="bottom">
<p>ab</p>
</th><th style="text-align: left" valign="bottom">
<p>b</p>
</th><th style="text-align: left" valign="bottom">
<p>bc</p>
</th><th style="text-align: left" valign="bottom">
<p>c</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Houston (IAH)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">IAH -&gt; SFO (-4)</code>
</p>
<p>
<code class="literal">[1011126]</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">San Francisco (SFO)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">SFO -&gt; JFK (536)</code>
</p>
<p>
<code class="literal">[1021507]</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">New York (JFK)</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Tuscon (TUS)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">TUS -&gt; SFO (-5)</code>
</p>
<p>
<code class="literal">[1011126]</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">San Francisco (SFO)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">SFO -&gt; JFK (536)</code>
</p>
<p>
<code class="literal">[1021507]</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">New York (JFK)</code>
</p>
</td></tr></tbody></table></div><p>Referring to the TUS &gt; SFO &gt; JFK flight, you will notice that while the flight from Tuscon to San Francisco departed 5 minutes early, the flight from San Francisco to New York JFK was delayed by 536 minutes.</p><p>By using motif finding, you can easily search for structural patterns in your graph; by using GraphFrames, you are using the power and speed of DataFrames to distribute and perform your query.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Determining airport ranking using PageRank"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec51"/>Determining airport ranking using PageRank</h1></div></div></div><p>Because GraphFrames<a id="id475" class="indexterm"/> is built on top of GraphX, there are several algorithms that we can immediately leverage. PageRank was popularized<a id="id476" class="indexterm"/> by the Google Search Engine and created by Larry Page. To quote Wikipedia:</p><div class="blockquote"><blockquote class="blockquote"><p>"PageRank works by counting the number and quality of links to a page to determine a rough estimate of how important the website is. The underlying assumption is that more important websites are likely to receive more links from other websites."</p></blockquote></div><p>While the preceding example refers to web pages, this concept readily applies to any graph structure<a id="id477" class="indexterm"/> whether it is created from web pages, bike stations, or airports. Yet the interface via GraphFrames is as simple as calling<a id="id478" class="indexterm"/> a method. <code class="literal">GraphFrames.PageRank</code> will return the PageRank results as a new column appended to the <span class="emphasis"><em>vertices</em></span> DataFrame to simplify our downstream analysis.</p><p>As there are many flights and connections through the various airports included in this dataset, we can use the PageRank algorithm to have Spark traverse the graph iteratively to compute a rough estimate of how important each airport is:</p><div class="informalexample"><pre class="programlisting"># Determining Airport ranking of importance using 'pageRank'
ranks = tripGraph.pageRank(resetProbability=0.15, maxIter=5)

# Display the pageRank output
display(ranks.vertices.orderBy(ranks.vertices.pagerank.desc()).limit(20))</pre></div><p>Note that <code class="literal">resetProbability = 0.15</code> represents the probability of resetting to a random vertex (this is the default value) while <code class="literal">maxIter = 5</code> is a set number of iterations.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip33"/>Tip</h3><p>For more<a id="id479" class="indexterm"/> information on PageRank parameters, please refer to Wikipedia &gt; Page Rank at <a class="ulink" href="https://en.wikipedia.org/wiki/PageRank">https://en.wikipedia.org/wiki/PageRank</a>.</p></div></div><p>The results of the <code class="literal">PageRank</code> are noted in the following bar graph:</p><div class="mediaobject"><img src="images/B05793_07_20.jpg" alt="Determining airport ranking using PageRank"/></div><p>In terms of<a id="id480" class="indexterm"/> airport ranking, the <code class="literal">PageRank</code> algorithm has<a id="id481" class="indexterm"/> determined that ATL (Hartsfield-Jackson Atlanta International Airport) is the most important airport in the United States. This<a id="id482" class="indexterm"/> observation makes sense as ATL is not only the busiest airport in the United States (<a class="ulink" href="http://bit.ly/2eTGHs4">http://bit.ly/2eTGHs4</a>), but it is also the busiest airport in the world (2000-2015) (<a class="ulink" href="http://bit.ly/2eTGDsy">http://bit.ly/2eTGDsy</a>).</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Determining the most popular non-stop flights"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec52"/>Determining the most popular non-stop flights</h1></div></div></div><p>Expanding upon our <code class="literal">tripGraph</code> GraphFrame, the following query will allow us to find the most popular<a id="id483" class="indexterm"/> non-stop flights in the US (for this dataset):</p><div class="informalexample"><pre class="programlisting"># Determine the most popular non-stop flights
import pyspark.sql.functions as func
topTrips = tripGraph \
  .edges \
  .groupBy("src", "dst") \
  .agg(func.count("delay").alias("trips"))

# Show the top 20 most popular flights (single city hops)
display(topTrips.orderBy(topTrips.trips.desc()).limit(20))</pre></div><p>Note, while we<a id="id484" class="indexterm"/> are using the <code class="literal">delay</code> column, we're just actually doing a <code class="literal">count</code> of the number of trips. Here's the output:</p><div class="mediaobject"><img src="images/B05793_07_21.jpg" alt="Determining the most popular non-stop flights"/></div><p>As can be observed from this query, the two most frequent non-stop flights are between LAX (Los Angeles) and SFO (San Francisco). The fact that these flights are so frequent indicates their<a id="id485" class="indexterm"/> importance in the airline market. As noted in the New York Times article from April 4, 2016, <span class="emphasis"><em>Alaska Air Sees Virgin America as Key to West Coast</em></span> (<a class="ulink" href="http://nyti.ms/2ea1uZR">http://nyti.ms/2ea1uZR</a>), acquiring slots at these two airports was one of the reasons why Alaska Airlines purchased Virgin Airlines. Graphs are not just fun but also contain potentially powerful business insight!</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Using Breadth-First Search"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec53"/>Using Breadth-First Search</h1></div></div></div><p>The <span class="strong"><strong>Breadth-first search</strong></span> (<span class="strong"><strong>BFS</strong></span>) is a new algorithm as part of GraphFrames that finds the shortest path from<a id="id486" class="indexterm"/> one set of vertices to another. In this section, we will<a id="id487" class="indexterm"/> use BFS to traverse our <code class="literal">tripGraph</code> to quickly find the desired vertices (that is, airports) and edges (that is, flights). Let's try to find the shortest number of connections between cities based on the dataset. Note that these examples do not consider time or distance, just hops between cities. For example, to find the number of direct flights between Seattle and San Francisco, you can run the following query:</p><div class="informalexample"><pre class="programlisting"># Obtain list of direct flights between SEA and SFO
filteredPaths = tripGraph.bfs(
  fromExpr = "id = 'SEA'",
  toExpr = "id = 'SFO'",
  maxPathLength = 1)

# display list of direct flights
display(filteredPaths)</pre></div><p>
<code class="literal">fromExpr</code> and <code class="literal">toExpr</code> are the expressions indicating the origin and destination airports (that is, SEA and SFO, respectively). The <code class="literal">maxPathLength = 1</code> indicates that we only want one edge between the two vertices, that is, a non-stop flight between Seattle and San Francisco. As noted in the following results, there are many direct flights between Seattle and San Francisco:</p><div class="mediaobject"><img src="images/B05793_07_23.jpg" alt="Using Breadth-First Search"/></div><p>But how about if we want to determine the number of direct flights between San Francisco and Buffalo? Running the following query will note that there are no results, that is, no direct flights between the two cities:</p><div class="informalexample"><pre class="programlisting"># Obtain list of direct flights between SFO and BUF
filteredPaths = tripGraph.bfs(
  fromExpr = "id = 'SFO'",
  toExpr = "id = 'BUF'",
  maxPathLength = 1)

# display list of direct flights
display(filteredPaths)</pre></div><p>Once we modify<a id="id488" class="indexterm"/> the preceding query to <code class="literal">maxPathLength = 2</code>, that is, one layover, then you will see a lot more flight options:</p><div class="informalexample"><pre class="programlisting"># display list of one-stop flights between SFO and BUF
filteredPaths = tripGraph.bfs(
  fromExpr = "id = 'SFO'",
  toExpr = "id = 'BUF'",
  maxPathLength = 2)

# display list of flights
display(filteredPaths)</pre></div><p>The following table provides an abridged version of the output from this query:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>From</p>
</th><th style="text-align: left" valign="bottom">
<p>Layover</p>
</th><th style="text-align: left" valign="bottom">
<p>To</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SFO</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>MSP</strong></span> (<span class="strong"><strong>Minneapolis</strong></span>)</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">BUF</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SFO</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>EWR</strong></span> (<span class="strong"><strong>Newark</strong></span>)</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">BUF</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SFO</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>JFK</strong></span> (<span class="strong"><strong>New York</strong></span>)</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">BUF</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SFO</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>ORD</strong></span> (<span class="strong"><strong>Chicago</strong></span>)</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">BUF</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SFO</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>ATL</strong></span> (<span class="strong"><strong>Atlanta</strong></span>)</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">BUF</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SFO</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>LAS</strong></span> (<span class="strong"><strong>Las Vegas</strong></span>)</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">BUF</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SFO</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>BOS</strong></span> (<span class="strong"><strong>Boston</strong></span>)</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">BUF</code>
</p>
</td></tr></tbody></table></div><p>But now that I have my list of airports, how can I determine which layover airports are more popular between SFO and BUF? To determine this, you can now run the following query:</p><div class="informalexample"><pre class="programlisting"># Display most popular layover cities by descending count
display(filteredPaths.groupBy("v1.id", "v1.City").count().orderBy(desc("count")).limit(10))</pre></div><p>The output is shown in the following bar chart:</p><div class="mediaobject"><img src="images/B05793_07_26.jpg" alt="Using Breadth-First Search"/></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Visualizing flights using D3"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec54"/>Visualizing flights using D3</h1></div></div></div><p>To get a powerful<a id="id489" class="indexterm"/> and fun visualization of the flight paths and connections in this dataset, we can leverage the Airports D3 visualization (<a class="ulink" href="https://mbostock.github.io/d3/talk/20111116/airports.html">https://mbostock.github.io/d3/talk/20111116/airports.html</a>) within our<a id="id490" class="indexterm"/> Databricks notebook. By connecting our GraphFrames, DataFrames, and D3 visualizations, we can visualize the scope of all the flight connections as noted for all on-time or early departing flights within this dataset.</p><p>The blue circles represent the vertices (that is, airports) where the size of the circle represents the number of edges (that is, flights) in and out of those airports. The black lines are the edges<a id="id491" class="indexterm"/> themselves (that is, flights) and their respective connections to the other vertices (that is, airports). Note for any edges that go offscreen, they are representing vertices (that is, airports) in the states of Hawaii and Alaska.</p><p>For this to work, we first create a <code class="literal">scala</code> package called <code class="literal">d3a</code> that is embedded in our notebook (you can download it from here: <a class="ulink" href="https://github.com/drabastomek/learningPySpark/blob/master/Chapter08/LearningPySpark_Chapter08.ipynb">http://bit.ly/2kPkXkc</a>). Because we're using Databricks notebooks, we can make <code class="literal">Scala</code> calls within our PySpark notebook:</p><div class="informalexample"><pre class="programlisting">%scala
// On-time and Early Arrivals
import d3a._
graphs.force(
  height = 800,
  width = 1200,
  clicks = sql("""select src, dst as dest, count(1) as count from departureDelays_geo where delay &lt;= 0 group by src, dst""").as[Edge])</pre></div><p>The results of the preceding query for on-time and early arrivals flights are visualized in the following screenshot:</p><div class="mediaobject"><img src="images/B05793_07_24.jpg" alt="Visualizing flights using D3"/></div><p>You can hover<a id="id492" class="indexterm"/> over the airports (blue circle, vertex) in the airports D3 visualization where the lines are the edges (flights). The preceding visualization is a snapshot when hovering over Seattle (SEA) airport; while the following visualization is a snapshot when hovering over Los Angeles (LAX) airport:</p><div class="mediaobject"><img src="images/B05793_07_25.jpg" alt="Visualizing flights using D3"/></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec55"/>Summary</h1></div></div></div><p>As you can see in this chapter, you can easily perform a lot of powerful data analysis by executing queries against graph structures. With GraphFrames, you can leverage the power, simplicity, and performance of the DataFrame API against your graph problems.</p><p>For more information on GraphFrames, please refer to the following resources:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Introducing GraphFrames</em></span> (<a class="ulink" href="http://bit.ly/2dBPhKn">http://bit.ly/2dBPhKn</a>)</li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>On-Time Flight Performance with GraphFrames for Apache Spark</em></span> (<a class="ulink" href="http://bit.ly/2c804ZD">http://bit.ly/2c804ZD</a>)</li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>On-Time Flight Performance with GraphFrames for Apache Spark (Spark 2.0) Notebook</em></span> (<a class="ulink" href="https://github.com/drabastomek/learningPySpark/blob/master/Chapter08/LearningPySpark_Chapter08.ipynb">http://bit.ly/2kPkXkc</a>)</li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>GraphFrames Overview</em></span> (<a class="ulink" href="http://graphframes.github.io/">http://graphframes.github.io/</a>)</li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Pygraphframes documentation</em></span> (<a class="ulink" href="http://graphframes.github.io/api/python/graphframes.html">http://graphframes.github.io/api/python/graphframes.html</a>)</li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>GraphX Programming Guide</em></span> (<a class="ulink" href="http://spark.apache.org/docs/latest/graphx-programming-guide.html">http://spark.apache.org/docs/latest/graphx-programming-guide.html</a>)</li></ul></div><p>In the next chapter, we will expand our PySpark horizon into the area of Deep Learning with the focus on TensorFlow and TensorFrames.</p></div></div>
</body></html>