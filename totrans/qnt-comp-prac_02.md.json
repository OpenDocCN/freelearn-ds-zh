["```py\n    import numpy as np\n    from math import sqrt, pow\n    ```", "```py\n    # Define the qubit parameters for superposition\n    a = sqrt(1/2)\n    b = sqrt(1/2)\n    if round(pow(a,2)+pow(b,2),0)!=1:\n        print(\"Your qubit parameters are not normalized.\n            \\nResetting to basic superposition\")\n        a = sqrt(1/2)\n        b = sqrt(1/2)\n    bits = {\"bit = 0\":np.array([1,0]), \n        \"bit = 1\":np.array([0,1]), \n        \"|0\\u27E9\":np.array([1,0]), \n        \"|1\\u27E9\":np.array([0,1]), \n        \"a|0\\u27E9+b|1\\u27E9\":np.array([a,b])}\n    # Print the vectors \n    for b in bits:\n      print(b, \": \", bits[b].round(3)) \n    print (\"\\n\")\n    ```", "```py\n    print(\"'Measuring' our bits and qubits\")\n    print(\"-------------------------------\")\n    prob={}\n    for b in bits:\n        print(b)\n        print(\"Probability of getting:\")\n        for dig in range(len(bits[b])):\n            prob[b]=pow(bits[b][dig],2)\n            print(dig, \" = \", '%.2f'%(prob[b]*100), percent\") \n        print (\"\\n\")\n    ```", "```py\n    import numpy as np\n    import cmath \n    from math import pi, sin, cos\n    from qiskit.visualization import plot_bloch_vector\n    ```", "```py\n    # Superposition with zero phase\n    angles={\"theta\": pi/2, \"phi\":0}\n    # Self defined qubit\n    #angles[\"theta\"]=float(input(\"Theta:\\n\"))\n    #angles[\"phi\"]=float(input(\"Phi:\\n\"))\n    # Set up the bit and qubit vectors\n    bits = {\"bit = 0\":{\"theta\": 0, \"phi\":0}, \n        \"bit = 1\":{\"theta\": pi, \"phi\":0}, \n        \"|0\\u27E9\":{\"theta\": 0, \"phi\":0}, \n        \"|1\\u27E9\":{\"theta\": pi, \"phi\":0}, \n        \"a|0\\u27E9+b|1\\u27E9\":angles}\n    ```", "```py\n    bloch=[cos(bits[bit][\"phi\"])*sin(bits[bit]\n        [\"theta\"]),sin(bits[bit][\"phi\"])*sin(bits[bit]\n        [\"theta\"]),cos(bits[bit][\"theta\"])]\n    ```", "```py\n    for bit in bits:\n         bloch=[cos(bits[bit][\"phi\"])*sin(bits[bit]\n            [\"theta\"]),sin(bits[bit][\"phi\"])*sin(bits[bit]\n            [\"theta\"]),cos(bits[bit][\"theta\"])]\n        display(plot_bloch_vector(bloch, title=bit))\n        # Build the state vector\n        a = cos(bits[bit][\"theta\"]/2)\n        b = cmath.exp(bits[bit][\"phi\"]*1j)*sin(bits[bit]\n            [\"theta\"]/2)\n        state_vector = [a * complex(1, 0), b * complex(1, 0)]\n        print(\"State vector:\", np.around(state_vector, \n            decimals = 3))\n    ```", "```py\n# Superposition with zero phase\nangles={\"theta\": pi/2, \"phi\":0}\n```", "```py\n# Self-defined qubit\nangles[\"theta\"]=float(input(\"Theta:\\n\"))\nangles[\"phi\"]=float(input(\"Phi:\\n\"))\n```", "```py\n    import numpy as np\n    from math import sqrt\n    ```", "```py\n    np.array([1,0])\n    ```", "```py\n    qubits = {\"|0\\u27E9\":np.array([1,0]), \n        \"|1\\u27E9\":np.array([0,1]), \n        \"(|0\\u27E9+|1\\u27E9)/\\u221a2\":1/sqrt(2)*np.\n        array([1,1])}\n    for q in qubits:\n      print(q, \"\\n\", qubits[q].round(3))\n    ```", "```py\n    np.array([[0, 1], [1, 0]])\n    ```", "```py\n    gates ={\"id\":np.array([[1, 0], [0, 1]]),\n        \"x\":np.array([[0, 1], [1, 0]]), \n        \"h\":1/sqrt(2)*np.array([[1, 1], [1, -1]])}\n    for g in gates:\n      print(g, \"\\n\", gates[g].round(3)) \n    ```", "```py\n    np.dot(np.array([[0, 1], [1, 0]]), np.array([1,0]))\n    ```", "```py\n    for g in gates:\n        print(\"Gate:\",g) \n        for q in qubits:\n            print(q,\"\\n\",qubits[q].round(3),\"->\", \n                np.dot(gates[g],qubits[q]).round(3))\n    ```", "```py\n    np.array([1,0,0,0])\n    ```", "```py\n    twoqubits = {\"|00\\u27E9\":np.array([1,0,0,0]),\n        \"|01\\u27E9\":np.array([0,1,0,0]),\n        \"|10\\u27E9\":np.array([0,0,1,0]),\n        \"|11\\u27E9\":np.array([0,0,0,1]),\n        \"|PH\\u27E9\":np.array([0.5,-0.5,0.5,-0.5])}\n    for b in twoqubits:\n      print(b, \"\\n\", twoqubits[b]) \n    ```", "```py\n    twogates ={\"cx\":np.array([[1, 0, 0, 0], [0, 1, 0, 0], \n        [0, 0, 0, 1], [0, 0, 1, 0]]), \n        \"swap\":np.array([[1, 0, 0, 0], [0, 0, 1, 0], \n        [0, 1, 0, 0], [0, 0, 0, 1]])}\n    ```", "```py\n    np.dot(np.array([[1, 0, 0, 0], [0, 1, 0, 0], \n        [0, 0, 0, 1], [0, 0, 1, 0]]), np.array([0,0,0,1]))\n    ```", "```py\n    twogates ={\"cx\":np.array([[1, 0, 0, 0], [0, 1, 0, 0], \n        [0, 0, 0, 1], [0, 0, 1, 0]]), \n        \"swap\":np.array([[1, 0, 0, 0], [0, 0, 1, 0], \n        [0, 1, 0, 0], [0, 0, 0, 1]])}\n    for g in twogates:\n      print(g, \"\\n\", twogates[g].round()) \n    print (\"\\n\")\n    ```", "```py\n    for g in twogates:\n        print(\"Gate:\",g) \n        for b in twoqubits:\n            print(b,\"\\n\",twoqubits[b],\"->\", \n                np.dot(twogates[g],twoqubits[b])) \n        print(\"\\n\")\n    ```", "```py\n    import numpy as np\n    from math import sqrt\n    ```", "```py\n    qubits = {\"|0\\u232A\":np.array([1,0]), \n        \"|1\\u232A\":np.array([0,1]), \n        \"(|0\\u232A+|1\\u232A)/\\u221a2\":1/sqrt(2)*np.\n        array([1,1])}\n    for q in qubits:\n      print(q, \"\\n\", qubits[q]) \n    print (\"\\n\")\n    gates ={\"id\":np.array([[1, 0], [0, 1]]),\n        \"x\":np.array([[0, 1], [1, 0]]), \n        \"y\":np.array([[0, -1.j], [1.j, 0]]), \n        \"z\":np.array([[1, 0], [0, -1]]), \n        \"h\":1/sqrt(2)*np.array([[1, 1], [1, -1]]), \n        \"s\":np.array([[1, 0], [0, 1j]])}\n    diff=\"\"\n    for g in gates:\n      print(g, \"\\n\", gates[g].round(3)) \n      if gates[g].all==np.matrix.conjugate(gates[g]).all:\n          diff=\"(Same as original)\" \n      else:\n          diff=\"(Complex numbers conjugated)\" \n      print(\"Inverted\",g, diff, \"\\n\",     np.matrix.conjugate(gates[g]).round(3)) \n    print (\"\\n\")\n    ```", "```py\n    for g in gates:\n        input(\"Press enter...\")\n        print(\"Gate:\",g) \n        print(\"-------\")\n        for q in qubits:\n            print (\"\\nOriginal qubit: \",q,\"\\n\", \n                qubits[q].round(3))\n            print (\"Qubit after\",g,\"gate: \\n\",\n                np.dot(gates[g],qubits[q]).round(3))\n            print (\"Qubit after inverted\",g,\"gate.\",\"\\n\",\n                np.dot(np.dot(gates[g],qubits[q]),\n                np.matrix.conjugate(gates[g])).round(3))\n        print(\"\\n\")\n    ```"]