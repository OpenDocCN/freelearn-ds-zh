- en: '*Chapter 2*: Quantum Computing and Qubits with Python'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Quantum computing is a fairly new and fairly old field at the same time. The
    ideas and concepts used to achieve quantum computing (such as quantum mechanical
    superposition and entanglement) have been around for almost a century and the
    field of quantum information science was founded almost 40 years ago. Early explorers,
    such as Peter Shor and Lov Grover, produced quantum computing algorithms (Shor's
    algorithm and Grover's algorithm) that are now starting to become as well known
    as foundational physics concepts such as *E=mc**2*. For details, see the references
    at the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, real quantum computers that utilize these effects are a relatively
    recent invention. The requirements for building one were outlined by DiVincenzo
    in the 1990, and IBM opened up its IBM Quantum Experience® and Qiskit® in 2016,
    effectively the first time anyone outside of a research lab could start exploring
    this nascent field for real.
  prefs: []
  type: TYPE_NORMAL
- en: So, what is the difference between classical computing and quantum computing?
    One way to start exploring is by taking a look at the basic computational elements
    used by each—the classical bits and the quantum qubits.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will contrast bits and qubits, play with some generic linear
    algebra to explore them in more detail, and contrast deterministic (classical)
    computation and probabilistic (quantum) computation. We will even take a quick
    look at some basic Qiskit® presentation methods to visualize a qubit.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Comparing a bit and a qubit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizing a qubit in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A quick introduction to quantum gates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The recipes that we discuss in this chapter can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter02](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter02).'
  prefs: []
  type: TYPE_NORMAL
- en: For more information about how to get the recipe sample code, refer to the *Downloading
    the code samples* section in [*Chapter 1*](B14436_01_Final_PG_ePub.xhtml#_idTextAnchor021),
    *Preparing Your Environment*.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing a bit and a qubit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, let's start with the obvious—or perhaps, not so obvious—notion that most
    people who read this book know what a bit is.
  prefs: []
  type: TYPE_NORMAL
- en: An intuitive feeling that we have says that a bit is something that is either
    **zero** (**0**) or **one** (**1**). By putting many bits together, you can create
    bytes as well as arbitrary large binary numbers, and with those, build the most
    amazing computer programs, encode digital images, encrypt your love letters and
    bank transactions, and more.
  prefs: []
  type: TYPE_NORMAL
- en: In a classical computer, a bit is realized by using low or high voltages over
    the transistors that make up the logic board, typically something such as 0 V
    and 5 V. In a hard drive, the bit might be a region magnetized in a certain way
    to represent 0 and the other way for 1, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In books about quantum computing, the important point to drive home is that
    a classical bit can only be a 0 or a 1; it can never be anything else. In the
    computer example, you can imagine a box with an input and an output, where the
    box represents the program that you are running. With a classical computer (and
    I use the term classical here to indicate a binary computer that is not a quantum
    computer), the input is a string of bits, the output is another string of bits,
    and the box is a bunch of bits being manipulated, massaged, and organized to generate
    that output with some kind of algorithm. An important thing, again, to emphasize
    is that while in the box, the bits are still bits, always 0s or 1s, and nothing
    else.
  prefs: []
  type: TYPE_NORMAL
- en: A qubit, as we will discover in this chapter, is something quite different.
    Let's go explore.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As recipes go, this one isn't really that much to brag about. It is just a quick
    Python and NumPy implementation that defines a bit as a 2x1 matrix, or a vector
    representing 0 or 1\. We also introduce the Dirac notation of ![](img/Formula_02_001.png)
    to represent our qubits. We then calculate the probability of getting various
    results when measuring the bits and qubits.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python file for the following recipe can be downloaded from here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter02/ch2_r1_bits_qubits.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter02/ch2_r1_bits_qubits.py).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by importing `numpy` and `math`, which we will need to do the
    calculations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create and print the bit and qubit vectors for 0, 1, ![](img/Formula_02_001.png)
    as `[1,0]`, `[0,1]`, `[1,0]`, `[0,1]`, and `[a,b]`, respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Notice the Unicode entries here: `\u27E9`. We use this instead of just `>`
    to create the nice-looking Dirac qubit rendering ![](img/Formula_02_003.png) in
    the output.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You must provide the correct a and b parameters
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that the parameter verification code checks whether the values for `a`
    and `b` are *normalized*. If not, then `a` and `b` are reset to a simple 50/50
    superposition by setting ![](img/Formula_02_004.png) and ![](img/Formula_02_005.png).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Measure the qubits by creating a measurement dictionary, and then calculate
    the probability of getting `0` and `1` from the bit vectors we created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code should give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Simulating bits and qubits with NumPy'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.1_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 – Simulating bits and qubits with NumPy
  prefs: []
  type: TYPE_NORMAL
- en: Now we know what the probabilities of getting the values of `0` or `1` are when
    measuring the bits and qubits. For some of these (0, 1, ![](img/Formula_02_006.png))
    the outcome is what we expected, 0 or 100%; the bit or qubit is either 0 or 1
    and nothing else. For one (![](img/Formula_02_007.png)), which is a qubit that
    is in a superposition of 0 and 1, the probability of getting either is 50%. This
    is an outcome that can never happen for a classical bit, only for a qubit. We
    will explain why in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What we have seen in this recipe is that the probability of reading a classical
    bit will always be *100%*, either 0 or 1; there are no other options. But for
    a qubit that can be expressed as ![](img/Formula_02_008.png) the probability of
    a 0 or 1 is proportional to ![](img/Formula_02_009.png). For pure ![](img/Formula_02_010.png)
    states, *a* or *b* is always 1, and the probability of measuring each is 100%.
    But for the qubit that we labeled ![](img/Formula_02_011.png), a and b are both
    ![](img/Formula_02_012.png), giving a probability of 50% for 0 or 1 ![](img/Formula_02_013.png).
  prefs: []
  type: TYPE_NORMAL
- en: Measuring a bit and a qubit
  prefs: []
  type: TYPE_NORMAL
- en: The word **measure** means two slightly different things in classical computing
    and quantum computing. In classical computing, you can measure your bits at any
    time without seriously disturbing the calculations that you are doing. For a quantum
    computer, measuring is a more definite act that results in your qubit reverting
    from a bit that behaves quantum-mechanically to a bit that behaves classically.
    After you measure a qubit, you are done. You can do no further quantum actions
    on that qubit.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the quantum mechanical nature of a qubit, we can describe it as a vector
    similar to the vector we use for a bit. To clarify that, when we are talking about
    qubits, we do not just use 0 and 1 as labels, but rather the Dirac *ket* notation,
    ![](img/Formula_02_014.png) and ![](img/Formula_02_015.png), indicating that these
    are state vectors in a vector space.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write out the state vector, ![](img/Formula_02_016.png) (psi), of a
    qubit like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_02_017.png) for a qubit in the *ground state*, representing
    0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/Formula_02_018.png) for a qubit in the *excited state*, representing
    1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, we have used **ground state** and **excited state** as one way of categorizing
    qubits. This is appropriate as the Josephson junctions that the IBM Quantum® qubits
    use are quantum systems with two energy levels. Depending on the underlying physical
    system, qubits can also be based on other two-level quantum systems, such as electron
    spin (up or down) or photon polarization (horizontal or vertical).
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, nothing is intuitively much different from classical bits, as each
    represents just the value 0 or 1\. But now we add a complexity: a qubit can also
    be a superposition of the two states, ![](img/Formula_02_019.png) and ![](img/Formula_02_020.png).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_02_021.png), where *a* and *b* are complex numbers. These numbers
    are normalized so that ![](img/Formula_02_022.png), which geometrically means
    that the resulting vector, ![](img/Formula_02_023.png), has a length of 1\. This
    is important!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to the simplest cases, these can be described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_02_024.png) for a qubit in the ground state. In this case,
    a=1 and b=0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/Formula_02_025.png) for a qubit in the excited state. In this case,
    a=0 and b=1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So far, so good, but now we add the quantum twist: superposition. The following
    qubit state vector is also supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_02_026.png)'
  prefs: []
  type: TYPE_IMG
- en: Just to check that we are still normalized, in this case,
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_02_027.png).'
  prefs: []
  type: TYPE_NORMAL
- en: But what does this state vector mean?
  prefs: []
  type: TYPE_NORMAL
- en: The qubit is set up in a state where it is exactly halfway between ![](img/Formula_02_028.png)
    and ![](img/Formula_02_029.png); it exists in a superposition of the two basic
    states. It is behaving quantumly.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The quantum superposition state of a qubit can only be sustained while we are
    doing calculations on the quantum computer. The same is true for an actual particle
    in nature, such as a photon that behaves quantum-mechanically. For example, the
    polarization of the photon can be described as a superposition of horizontal and
    vertical orientations while the photon is in flight, but when you add a polarizer
    in its path, you will measure it as either horizontal or vertical, and nothing
    else.
  prefs: []
  type: TYPE_NORMAL
- en: Going back to the computer-as-a-box example, for a quantum computer we have
    a similar image, a string of bits as input and another string of bits as output.
    The difference comes inside the box where the qubits can exist in superposition
    while we are doing our calculations.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as we measure the qubits to get that string of output bits however,
    the qubits must decide, quantum-mechanically, if they are a ![](img/Formula_02_030.png)
    or a ![](img/Formula_02_031.png), and here is where those *a* and *b* parameters
    come in.
  prefs: []
  type: TYPE_NORMAL
- en: The ![](img/Formula_02_032.png) formula not only states that the vector is normalized
    to the length 1, but it also describes the probability of getting the ![](img/Formula_02_033.png)
    and ![](img/Formula_02_034.png) outputs. The probability of getting ![](img/Formula_02_035.png)
    is ![](img/Formula_02_036.png), and ![](img/Formula_02_037.png) is ![](img/Formula_02_038.png).
    This is the core of the difference between a quantum computer and a classical
    computer. The quantum computer is probabilistic—you cannot know in advance what
    the end result will be, only the probability of getting a certain result—whereas
    the classical computer is deterministic—you can always, at least in theory, predict
    what the answer will be.
  prefs: []
  type: TYPE_NORMAL
- en: About probabilistic computing
  prefs: []
  type: TYPE_NORMAL
- en: People often get a little confused about quantum computers and probabilistic
    outcomes and visualize the whole quantum programming concept as qubits spinning
    randomly and uncontrollably in all different states at the same time. This is
    not a true picture; each qubit is initialized in a specific known state, ![](img/Formula_02_144.png),
    and then acted upon by quantum gate manipulations. Each manipulation is strictly
    deterministic; there is nothing random. At each stage in a quantum state evolution,
    we know exactly what our qubit is doing, expressed as an ![](img/Formula_02_039.png)
    superposition. It is only at the end, when we measure and force the qubit to be
    either 0 or 1, that the probabilistic nature shows with the probability of measuring
    0 or 1 set by the *a* and *b* parameters (![](img/Formula_02_040.png)).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information about qubits and how to interpret them, refer to the following
    excellent books:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Dancing with Qubits, How quantum computing works and how it can change the
    world*, Robert S. Sutor, Packt Publishing Ltd., 2019, [*Chapter 7*](B14436_07_Final_PG_ePub.xhtml#_idTextAnchor197),
    *One Qubit*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Quantum Computation and Quantum Information*, Isaac L. Chuang; Michael A.
    Nielsen, Cambridge University Press, 2010, *Chapter 1.2*, *Quantum bits*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Quantum Mechanics: The theoretical minimum*, Leonard Susskind & Art Friedman,
    Basic Books, 2015, *Lecture 1: Systems and experiments*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Shor, I''ll do it*, Scott Aaronson''s blog, [https://www.scottaaronson.com/blog/?p=208](https://www.scottaaronson.com/blog/?p=208)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*What''s a Quantum Phone Book?*, Lov Grover, Lucent Technologies, [https://web.archive.org/web/20140201230754/http://www.bell-labs.com/user/feature/archives/lkgrover/](https://web.archive.org/web/20140201230754/http://www.bell-labs.com/user/feature/archives/lkgrover/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Physical Implementation of Quantum Computation*, David P. DiVincenzo,
    IBM, [https://arxiv.org/abs/quant-ph/0002077](https://arxiv.org/abs/quant-ph/0002077)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizing a qubit in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will use generic Python with NumPy to create a vector and
    visual representation of a bit and show how it can be in only two states, 0 and
    1\. We will also introduce our first, smallish foray into the Qiskit® world by
    showing how a qubit can not only be in the unique 0 and 1 states but also in a
    superposition of these states. The way to do this is to take the vector form of
    the qubit and project it on the so-called **Bloch sphere**, for which there is
    a Qiskit® method. Let's get to work!
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding recipe, we defined our qubits with the help of two complex
    parameters—*a* and *b*. This meant that our qubits could take values other than
    the 0 and 1 of a classical bit. But it is hard to visualize a qubit halfway between
    0 and 1, even if you know *a* and *b*.
  prefs: []
  type: TYPE_NORMAL
- en: However, with a little mathematical trickery, it turns out that you can also
    describe a qubit using two angles—**theta** (![](img/Formula_02_041.png)) and
    **phi** (![](img/Formula_02_042.png))—and visualize the qubit on a Bloch sphere.
    You can think of the ![](img/Formula_02_0411.png) and ![](img/Formula_02_0421.png)
    angles much as the latitude and longitude of the earth. On the Bloch sphere, we
    can project any possible value that the qubit can take.
  prefs: []
  type: TYPE_NORMAL
- en: 'The equation for the transformation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_02_043.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we use the formula we saw before:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_02_044.png)'
  prefs: []
  type: TYPE_IMG
- en: '*a* and *b* are, respectively, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_02_045.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_02_046.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I''ll leave the deeper details and math to you for further exploration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – The Bloch sphere](img/Figure_2.2_B14436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – The Bloch sphere.
  prefs: []
  type: TYPE_NORMAL
- en: The poor classical bits cannot do much on a Bloch sphere as they can exist at
    the North and South poles only, representing the binary values 0 and 1\. We will
    include them just for comparison.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason 0 points up and 1 points down has peculiar and historical reasons.
    The qubit vector representation of ![](img/Formula_02_047.png) is ![](img/Formula_02_048.png),
    or up, and ![](img/Formula_02_049.png) is ![](img/Formula_02_050.png), or down,
    which is intuitively not what you expect. You would think that 1, or a more exciting
    qubit, would be a vector pointing upward, but this is not the case; it points
    down. So, I will do the same with the poor classical bits as well: 0 means up
    and 1 means down.'
  prefs: []
  type: TYPE_NORMAL
- en: The latitude, the distance to the poles from a cut straight through the Bloch
    sphere, corresponds to the numerical values of *a* and *b*, with ![](img/Formula_02_051.png)
    pointing straight up for ![](img/Formula_02_052.png) (a=1, b=0), ![](img/Formula_02_053.png)
    pointing straight down for ![](img/Formula_02_054.png) points to the equator for
    the basic superposition where ![](img/Formula_02_055.png).
  prefs: []
  type: TYPE_NORMAL
- en: So, what we are adding to the equation here is the *phase* of the qubit. The
    ![](img/Formula_02_042.png) angle cannot be directly measured and has no impact
    on the outcome of our initial quantum circuits. Later on in the book, in [*Chapter
    9*](B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246), *Grover's Search Algorithm*,
    we will see that you can use the phase angle to great advantage in certain algorithms.
    But we are getting ahead of ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Python file for the following recipe can be downloaded from here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter02/ch2_r2_visualize_bits_qubits.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter02/ch2_r2_visualize_bits_qubits.py).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this exercise, we will use the ![](img/Formula_02_057.png) and ![](img/Formula_02_058.png)
    angles as latitude and longitude coordinates on the Bloch sphere. We will code
    the 0, 1, ![](img/Formula_02_059.png), ![](img/Formula_02_049.png), and ![](img/Formula_02_061.png)
    states with the corresponding angles. As we can set these angles to any latitude
    and longitude value we want, we can put the qubit state vector wherever we want
    on the Bloch sphere:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the classes and methods that we need, including `numpy` and `plot_bloch_``vector`
    from Qiskit®. We also need to use `cmath` to do some calculations on imaginary
    numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the qubits:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'From the code sample, you can see that we are using the theta angle only for
    now, with theta = 0 meaning that we point straight up and theta ![](img/Formula_02_062.png)
    meaning straight down for our basic bits and qubits: 0, 1, ![](img/Formula_02_063.png),
    and ![](img/Formula_02_064.png). Theta ![](img/Formula_02_065.png) takes us halfway,
    to the equator, and we use that for the superposition qubit, ![](img/Formula_02_066.png).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Print the bits and qubits on the Bloch sphere.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Bloch sphere method takes a three-dimensional vector as input, but we have
    to build the vector first. We can use the following formula to calculate the *X*,
    *Y*, and *Z* parameters to use with `plot_bloch_vector` and display the bits and
    qubits as Bloch sphere representations:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now cycle through the bits dictionary to display the Bloch sphere view of
    the bits and qubits, as well as the state vectors that correspond to them:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/Formula_02_069_(1).jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The state vector is calculated using the equation we saw previously:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/Formula_02_070.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: What we see now is that *a* and *b* can actually turn into complex values, just
    as defined.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here''s the code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The sample code should give an output similar to the following examples.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we show the classical bits, 0 and 1:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Bloch sphere visualization of classical bits](img/Figure_2.3_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 2.3 – Bloch sphere visualization of classical bits
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, we show the quantum bits, or qubits, ![](img/Formula_02_030.png) and ![](img/Formula_02_029.png):![Figure
    2.4 – Bloch sphere visualization of qubits
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_2.4_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 2.4 – Bloch sphere visualization of qubits
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we show a qubit in superposition, a mix of ![](img/Formula_02_073.png)
    and ![](img/Formula_02_074.png):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Bloch sphere visualization of a qubit in superposition'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.5_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.5 – Bloch sphere visualization of a qubit in superposition
  prefs: []
  type: TYPE_NORMAL
- en: So, there is very little that is earth-shattering with the simple 0, 1, ![](img/Formula_02_075.png),
    and ![](img/Formula_02_076.png) displays. They simply point up and down to the
    north and south pole of the Bloch sphere as appropriate. If we check what the
    value of the bit or qubit is by measuring it, we will get 0 or 1 with 100% certainty.
  prefs: []
  type: TYPE_NORMAL
- en: The qubit in superposition, calculated as ![](img/Formula_02_077.png), on the
    other hand, points to the equator. From the equator, it is an equally long distance
    to either pole, thus a 50/50 chance of getting a 0 or a 1\.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the code, we include the following few lines, which define the `angles`
    variable that sets ![](img/Formula_02_078.png) and ![](img/Formula_02_079.png)
    for the ![](img/Formula_02_080.png) qubit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We mentioned earlier that we weren't going to touch on the phase (![](img/Formula_02_058.png))
    angle, at least not initially. But we can visualize what it does for our qubits.
    Remember that we can directly describe *a* and *b* using the angles ![](img/Formula_02_082.png)
    and ![](img/Formula_02_083.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this out, you can uncomment the lines that define the angles in the
    sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can now define what your third qubit looks like by manipulating the ![](img/Formula_02_084.png)
    and ![](img/Formula_02_085.png) values. Let's test what we can do by running the
    script again and plugging in some angles.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_02_086.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_02_087.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You should see the final Bloch sphere look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – The qubit state vector rotated by   ](img/Figure_2.6_B14436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – The qubit state vector rotated by ![](img/Formula_02_088.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Note how the state vector is still on the equator with ![](img/Formula_02_089.png)
    but now at ![](img/Formula_02_090.png) angle to the *x* axis. You can also take
    a look at the state vector: [0.707+0.j 0.653+0.271j].'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have now stepped away from the Bloch sphere prime meridian and out into
    the complex plane, and added a phase angle, which is represented by an imaginary
    state vector component along the *y* axis: ![](img/Formula_02_091.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Let's go on a trip
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and experiment with different ![](img/Formula_02_092.png) and ![](img/Formula_02_093.png)
    angles to get other *a* and *b* entries and see where you end up. No need to include
    10+ decimals for these rough estimates, two or three decimals will do just fine.
    Try plotting your hometown on the Bloch sphere. Remember that the script wants
    the input in radians and that theta starts at the North Pole, not at the equator.
    For example, the coordinates for Greenwich Observatory in England are 51.4779°
    N, 0.0015° W, which translates into: ![](img/Formula_02_094.png), ![](img/Formula_02_095.png).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s Qiskit® and a globe displaying the same coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Greenwich quantumly and on a globe'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.7_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.7 – Greenwich quantumly and on a globe
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Quantum Computation and Quantum Information*, Isaac L. Chuang; Michael A.
    Nielsen, Cambridge University Press, 2010, *Chapter 1.2*, *Quantum bits*, and
    *Chapter 4.2*, *Single qubit operations*.'
  prefs: []
  type: TYPE_NORMAL
- en: A quick introduction to quantum gates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have sorted out the difference between bits and qubits, and have
    also understood how to visualize the qubit as a Bloch sphere, we know all that
    there is to know about qubits, correct? Well, not quite. A qubit, or for that
    matter, hundreds or thousands of qubits, is not the only thing you need to make
    a quantum computer! You need to perform logical operations on and with the qubits.
    For this, just like a classical computer, we need logical gates.
  prefs: []
  type: TYPE_NORMAL
- en: I will not go into any great detail on how logical gates work, but suffice to
    say that a quantum gate, operates on the input of one or more qubits and outputs
    a result.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will work our way through the mathematical interpretation
    of few quantum gates by using matrix multiplication of single- and multi-qubit
    gates. Don't worry, we will not dig deep, just a little to scratch the surface.
    You will find a deeper look quantum gates in [*Chapter 6*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156),
    *Understanding the Qiskit Gate Library*.
  prefs: []
  type: TYPE_NORMAL
- en: Again, we will not be building any actual Qiskit quantum circuits just yet.
    We are still using more or less plain Python with some NumPy matrix manipulations
    to prove our points.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Python file for the following recipe can be downloaded from here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter02/ch2_r3_qubit_gates.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter02/ch2_r3_qubit_gates.py).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe will create vector and matrix representations of qubits and gates,
    and use simple algebra to illustrate the behavior of the qubits as gates are applied
    to them:'
  prefs: []
  type: TYPE_NORMAL
- en: In your Python environment, run `ch2_r3_qubit_gates.py` and respond to the **Press
    return to continue** prompts to move along the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we see the vector representations of three qubit states: ![](img/Formula_02_075.png),
    ![](img/Formula_02_097.png), and ![](img/Formula_02_098.png):![Figure 2.8 – Qubits
    as vectors'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_2.8_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 2.8 – Qubits as vectors
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we display the matrix representation of a couple of gates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will use the `Id` (does nothing), `X` (flips the qubit), and `H` (creates
    a superposition) gates:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.9 – Single-qubit gates as matrices'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_2.9_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 2.9 – Single-qubit gates as matrices
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The final step for our single-qubit setup is to see how each gate manipulates
    the qubits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is done using matrix multiplication of the qubit vector and the gate matrix:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.10 – Gates acting on qubits'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_2.10_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 2.10 – Gates acting on qubits
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With the single qubits done, we now move on to working with combinations of
    two qubit states: ![](img/Formula_02_099.png):![Figure 2.11 – Two qubits as vectors'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_2.11_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 2.11 – Two qubits as vectors
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Like for the single qubits, we now show the matrix representations of the two-qubit
    quantum gates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here, we use `CX` (controlled NOT, flips one qubit if the other is 1) and `swap`
    (swaps the values of the two qubits):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.12 – Two-qubit gates as matrices'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_2.12_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 2.12 – Two-qubit gates as matrices
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, let's see gate manipulations of our multi-qubit states.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Again, we have a matrix multiplication of the qubits vector and the gate matrix:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.13 – Multi-qubit gates acting on two qubits'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.13_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.13 – Multi-qubit gates acting on two qubits
  prefs: []
  type: TYPE_NORMAL
- en: That's it… we have now witnessed Python-generated linear algebra that describes
    how our qubits are defined and how they behave when gates are applied to them.
  prefs: []
  type: TYPE_NORMAL
- en: How it is works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The previous section contained a lot of printed information with very little
    explanation of how we got those results. Let''s dig into the sample code to see
    how the output is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The numbered steps that follow correspond to the same numbered steps in the
    preceding *How to do it…* section. Refer back to those steps to see the result
    of the code samples that follow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by importing the math tools we need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Set up the basic vectors for our qubits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A qubit set to the value 0 is labeled ![](img/Formula_02_100.png) in the Dirac
    ket notation and is mathematically represented by the ![](img/Formula_02_101.png)
    vector, if it is set to 1 as ![](img/Formula_02_102.png), or the ![](img/Formula_02_103.png)
    vector. So far, so good, still only 0 and 1\. As we have seen, the real magic
    comes when you have a qubit set to a superposition value represented by a vector
    pointing to the equator of the Bloch sphere, or anywhere except the poles—for
    example, ![](img/Formula_02_104.png), which would be represented by the following
    vector:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/Formula_02_105.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here''s how we create a dictionary of our qubits in the sample:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Set up the basic matrices for our quantum gates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For qubits, any single-qubit gate can be represented by a 2x2 matrix like this:
    ![](img/Formula_02_109.png).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For single qubits, the math that we have implemented is a matrix operation
    that corresponds to the truth table for the two operations, *ID* and *NOT* (or
    *X*, as the quantum gate is called):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here''s how we create a dictionary of our gates in the sample:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, let's use NumPy to apply the defined gates on our qubits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The application of a gate on a qubit can be expressed as a vector multiplication
    of the qubit and the gate. Here''s the NumPy matrix dot multiplication for an
    X gate on the ![](img/Formula_02_120.png) qubit:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our sample, we step our way through the two dictionaries that we created,
    applying the matrix multiplication to each gate/qubit combination:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we see the expected behavior of the gates on our qubits: the ID gate
    does nothing, the X gate flips the qubit, and the H gate creates or uncreates
    a superposition.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you want to experiment a little, you can take a look at the vector representations
    of the various quantum gates that we show in [*Chapter 6*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156),
    *Understanding the Qiskit® Gate Library*, and see whether you can add these gates
    to the **gates** dictionary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this first example, we took a look at how to build our single qubits and
    gates as vectors and matrices, and how to run our qubits through the gates by
    using vector multiplication. Now let's do the same with two qubits…
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Set up our multi-qubit vectors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we expand our Dirac-noted qubit combinations: ![](img/Formula_02_121.png),
    ![](img/Formula_02_122.png), ![](img/Formula_02_123.png), and ![](img/Formula_02_124.png).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'These represent, respectively, both qubits 0, first qubit 1 and second 0, first
    qubit 0 and second 1, and both qubits 1\. Here, we are using the **backward Qiskit®
    notation** for our qubits, starting with the first qubit (![](img/Formula_02_125.png))
    as the **Least Significant Bit** (**LSB**) in the vector notation, like this:
    ![](img/Formula_02_126.png).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The vector representation of these are, respectively, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/Formula_02_127.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'We already know how to build our qubits as 2x1 NumPy arrays, so let''s extend
    that to 4x1 vectors. With NumPy, this is how we create, for example, the ![](img/Formula_02_128.png)
    qubit vector:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the sample code, we set up a dictionary with the multi-qubit arrays:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Set up our multi-qubit gate matrices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The two-qubit quantum gates are represented by 4x4 matrices, such as the **controlled-NOT**
    (**CX**) gate, which flips the first qubit (![](img/Formula_02_129.png)) if the
    controlling second qubit (![](img/Formula_02_130.png)) is set to 1:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/Formula_02_131.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Gate matrices like these, where one qubit acts as the control and the other
    as controlled, differ somewhat depending on which qubit you select as the control.
    If the CX gate points the other way, with the first qubit (![](img/Formula_02_132.png))
    as the controlling qubit, the matrix will look like this instead:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/Formula_02_133.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Here''s how we build the gates:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here''s a NumPy matrix dot multiplication example for a CX gate on the ![](img/Formula_02_134.png)
    qubit:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here''s the sample code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we''ll apply the gates to our bits and see the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The main takeaway with the multi-qubit matrix manipulations is that the output
    is a vector of the same dimensions as the input vector; no information is lost.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One other aspect of quantum gates that is generally not true of classical gates
    is that they are reversible. If you run the gate backward, you end up with the
    input states of your qubits, and no information is lost. The final recipe in this
    chapter illustrates this.
  prefs: []
  type: TYPE_NORMAL
- en: The sample code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The sample file for the following recipe can be downloaded from here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter02/ch2_r4_reversible_gates.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter02/ch2_r4_reversible_gates.py):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by importing all we need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set up the basic qubit vectors and gate matrices. When printing out the gates,
    we compare the gate matrix with its complex conjugate. If these are the same,
    the gate and its inverse are identical:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Demonstrate that the basic quantum gates are reversible by applying the gate
    then its complex conjugate, and then comparing the outcome with the input. For
    the quantum gates, which are reversible, this will bring the qubit back to the
    starting state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Running the sample
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you run this `ch2_r4_reversible_gates.py` script, it will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Like before, create and print out vector and matrix representations of our qubits
    and quantum gates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This time, we add three new gates:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/Formula_02_135.jpg)![](img/Formula_02_136.jpg)![](img/Formula_02_137.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Here, *Y* and *Z* perform ![](img/Formula_02_138.png) rotation around the corresponding
    axes, in essence acting as NOT gates along the *y* and *z* axes on the Bloch sphere.
    The S gate adds a new functionality to the gates, ![](img/Formula_02_139.png)
    rotation around the *z* axis. We will return to these gates in more detail in
    [*Chapter 6*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156), *Understanding
    the Qiskit® Gate Library*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.14 – Quantum gates and their inverses'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_2.14_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 2.14 – Quantum gates and their inverses
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The complex conjugate of a complex number is obtained by changing the sign of
    its imaginary part, so for gates with only real numbers in their matrices, the
    complex conjugate does nothing, and the gate is its own reverse.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, for each of our qubits, we apply each gate and then its reverse gate and
    show that we end up with the same qubit state as we started with.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The examples that follow are for the X and S gates:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.15 – The effects of the X gate and reversed X gate on three qubit
    states'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.15_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.15 – The effects of the X gate and reversed X gate on three qubit states
  prefs: []
  type: TYPE_NORMAL
- en: 'The reversed X gate is simply itself, and applying it twice to a qubit brings
    back the original qubit state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.16 – The effects of the S and reversed S gate () on three qubit
    states'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.16_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.16 – The effects of the S and reversed S gate (![](img/Formula_02_140.png))
    on three qubit states
  prefs: []
  type: TYPE_NORMAL
- en: The reverse of the S gate is called the ![](img/Formula_02_141.png) gate, where
    ![](img/Formula_02_142.png) is the complex conjugation of S. Applying S followed
    by ![](img/Formula_02_143.png) brings back the original qubit state.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Quantum Computation and Quantum Information*, Isaac L. Chuang; Michael A.
    Nielsen, Cambridge University Press, 2010, *Chapter 4.2*, *Single qubit operations*,
    and *Chapter 4.3*, *Controlled operations*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Feynman Lectures on Physics*, Feynman, Richard P.; Leighton, Robert B.;
    Sands, Matthew, 1965, Addison-Wesley. Take a look at the online version, and the
    chapter on amplitudes and vectors, for more about Dirac notation: [https://www.feynmanlectures.caltech.edu/III_08.html#Ch8-S1](https://www.feynmanlectures.caltech.edu/III_08.html#Ch8-S1).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For a quick interactive look at a single qubit Bloch sphere representation,
    take a look at the **grok bloch** application by Qiskit Advocate James Weaver:
    [https://github.com/JavaFXpert/grok-bloch](https://github.com/JavaFXpert/grok-bloch).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can install and run it from your own Python environment, or run it online
    here: [https://javafxpert.github.io/grok-bloch/](https://javafxpert.github.io/grok-bloch/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application supports the simple X and H gates that we have tested so far,
    as well as additional gates that we will be touching on in the following chapters,
    such as Y, Z, Rx, Ry, Rz, and more. For a deeper dive into the quantum gates that
    are available with Qiskit®, refer to [*Chapter 6*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156),
    *Understanding the Qiskit® Gate Library*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
