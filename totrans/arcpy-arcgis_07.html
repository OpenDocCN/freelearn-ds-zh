<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Creating a Script Tool</h1></div></div></div><p>Now that the basics of creating and executing ArcPy scripts have been covered, we need to take the next<a id="id245" class="indexterm"/> step and create re-useable <strong>Script tools</strong>. Creating Script tools will allow for greater code reuse, and will make it easy to create custom tools for other GIS analysts and customers. With a Python script <strong>backend</strong> or code, and a familiar ArcGIS tool <strong>frontend</strong> or user interface, the particulars of the code are hidden from the user; it becomes just another tool, albeit a tool that can save days and weeks of work.</p><p>This chapter will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Adding parameters to scripts to accept input and produce output as required by the user</li><li class="listitem" style="list-style-type: disc">Creating a custom tool frontend and a custom toolbox</li><li class="listitem" style="list-style-type: disc">Setting the parameters of the tool frontend to allow it to pass arguments to the code backend</li></ul></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec36"/>Adding dynamic parameters to a script</h1></div></div></div><p>The scripts <a id="id246" class="indexterm"/>we have generated in previous chapters <a id="id247" class="indexterm"/>have all had <strong>hard-coded</strong> inputs. The input<a id="id248" class="indexterm"/> values were written in the script as strings or numbers and assigned to variables. While they can be updated manually to replace the input and output file paths and SQL statements, programmers should aim to create scripts that will not require editing each time they are used. Instead, scripts should be designed to be dynamic and accept file paths and other inputs as parameters or arguments, in much the same manner that the functions we have created accept parameters.</p><p>Python was designed with this in mind, and the <code class="literal">sys</code> module has a method called <code class="literal">sys.argv</code> that accepts inputs passed to the script when it is executed. While the designers of ArcPy and its predecessor <code class="literal">arcgisscripting module</code> initially took advantage of the <code class="literal">sys.argv</code> method, in time they designed an ArcPy method for accepting script parameters. As either method can be used when writing ArcPy scripts, and both are found in example scripts on the web, it is important to recognize the minute differences between the <code class="literal">sys.argv</code> method and <code class="literal">arcpy.GetParameterAsText()</code>. The major difference between the two methods is that <code class="literal">sys.argv</code> accepts the dynamic arguments<a id="id249" class="indexterm"/> as a list. Members of the list are accessed <a id="id250" class="indexterm"/>using list indexing and assigned to variables. <code class="literal">Arcpy.GetParameterAsText()</code> is a function that accepts an index number parameter. The index number passed reflects the order of the parameter within the tool's frontend; the first parameter is zero, the next is one, and so on.</p><div><div><h3 class="title"><a id="note09"/>Note</h3><p>If the order of the parameters is adjusted in the tool frontend, this adjustment must be reflected in the code backend.</p></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec55"/>Displaying script messages using arcpy.AddMessage</h2></div></div></div><p>It is<a id="id251" class="indexterm"/> important to receive feedback <a id="id252" class="indexterm"/>from scripts to assess the progress of the script as it performs an analysis. As basic as this would seem, Python scripts and programming languages in general do not, by default, provide any feedback except for errors and the termination of the script. This can be a bit discouraging to the novice programmer, as all built-in feedback is negative.</p><p>To alleviate this lack of feedback, the use of print statements allows the script to give reports on the progress of the analysis as it runs. However, when using a Script tool, <code class="literal">print</code> statements do not have any effect. They will not be displayed anywhere, and are ignored by the Python executable. To display messages in the script console when Script tools are executed, ArcPy has a <code class="literal">arcpy.AddMessage()</code> method.</p><p>
<code class="literal">Arcpy.AddMessage</code> statements are added to scripts wherever feedback is required by the programmer. The feedback required is passed to the method as a parameter and displayed; whether it be a list, string, float or integer. <code class="literal">Arcpy.AddMessage</code> makes it easy to check on the results of analysis calculations, to ensure that the correct inputs are used and that the correct outputs are produced. As this feedback from the script can be a powerful debugging tool, use <code class="literal">arcpy.AddMessage</code> whenever there is a need for feedback from the Script tool.</p><div><div><h3 class="title"><a id="note10"/>Note</h3><p>Note that statements passed to <code class="literal">arcpy.AddMessage</code> will only display when the script is run as a Script tool.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec56"/>Adding dynamic components to the script</h2></div></div></div><p>To start <a id="id253" class="indexterm"/>making <a id="id254" class="indexterm"/>the script into a Script tool, we should first copy the script that we created in <a class="link" href="ch06.html" title="Chapter 6. Working with ArcPy Geometry Objects">Chapter 6</a>, <em>Working with ArcPy Geometry Objects</em> <code class="literal">Chapter6_1.py</code>, as <code class="literal">Chapter7_1.py</code> in a new folder called <code class="literal">Chapter7</code>. We can then start replacing the hard-coded variables with dynamic variables using <code class="literal">arcpy.GetParameterAsText</code>. There is another ArcPy method called <code class="literal">GetParameter</code> that accepts the inputs as an object, but for our purposes, <code class="literal">GetParameterAsText</code> is the  method to use.</p><p>By adding <code class="literal">arcpy</code>.<code class="literal">GetParameterAsText</code> and <code class="literal">arcpy.AddMessage</code> to the script, we will have taken the first step towards creating a Script tool. Care must be taken to ensure that the variables created from the dynamic parameters are in the correct order, as reordering them can be time-consuming. Once the parameters are added to the script and the hard-coded portions of the script replaced with variables, the script is ready to become a Script tool.</p><p>First, move all of the variables that are hard-coded into the top of the script. Then, replace all of the assigned values with <code class="literal">arcpy.GetParameterAsText</code>, making them dynamic values. Each parameter is referred to using zero-based indexing; however, they are passed to a function individually instead of as a member of a list:</p><div><pre class="programlisting">
<strong>#Chapter 7.py</strong>
<strong>import arcpy, csv</strong>
<strong>busStops = arcpy.GetParameterAsText(0)</strong>
<strong>censusBlocks2010 = arcpy.GetParameterAsText(1)</strong>
<strong>censusBlockField = arcpy.GetParameterAsText(2)</strong>
<strong>csvname = arcpy.GetParameterAsText(3)</strong>
<strong>headers = arcpy.GetParameterAsText(4).split(',')</strong>
<strong>sql = arcpy.GetParameterAsText(5)</strong>
<strong>keyfields = arcpy.GetParameterAsText(6).split(';')</strong>
<strong>dataDic = {}</strong>

<strong>censusFields = ['BLOCKID10',censusBlockField, 'SHAPE@']</strong>
<strong>if "SHAPE@" not in keyfields:</strong>
<strong>    keyfields.append("SHAPE@")</strong>

<strong>arcpy.AddMessage(busStops)</strong>
<strong>arcpy.AddMessage(censusBlocks2010)</strong>
<strong>arcpy.AddMessage(censusBlockField)</strong>
<strong>arcpy.AddMessage(csvname)</strong>
<strong>arcpy.AddMessage(sql)</strong>
<strong>arcpy.AddMessage(keyfields)</strong>
</pre></div><p>As you can see from the variable <code class="literal">keyfields</code> and the variable headers, some further processing must be applied to certain variables, as not all of them are going to be used as strings. In this case, a list is created from the string passed to the variable <code class="literal">keyfields</code> by using the <code class="literal">string</code> functions split and splitting the string on every semi-colon, while the <code class="literal">headers</code> variable is created by splitting on the commas. To other variables, such as the <code class="literal">censusBlockField</code> variable and the variable keyfields, the <code class="literal">SHAPE@</code> keyword is added because it will be required each time the analysis is run. If a particular field is required for each run of the data, such as the <code class="literal">BLOCKID10</code> field, it can remain hard-coded in the script, or optionally could become its own selectable field parameter in the Script tool.</p><p>The <a id="id255" class="indexterm"/>variables will then be added to the remainder <a id="id256" class="indexterm"/>of the script in the correct places, making the script ready for the Script tool to become part of a custom Toolbox in a geodatabase or in ArcToolbox. However, we must first create the tool part of the Script tool for the values to be collected and passed to the script.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec37"/>Creating a Script tool</h1></div></div></div><p>Creating a<a id="id257" class="indexterm"/> script tool is a powerful combination of the power of ArcPy and the ease of use of the tools in ArcToolbox.</p><p>The first step is to create a custom toolbox to hold the script tool. To achieve this, do the following:</p><div><ol class="orderedlist arabic"><li class="listitem">Open up <strong>ArcCatalog</strong> and right click in the <strong>SanFrancisco.gdb</strong> File Geodatabase.</li><li class="listitem">Select <strong>New</strong> and then <strong>Toolbox</strong> from the menu.</li><li class="listitem">Call the toolbox <strong>Chapter8Tools</strong>.</li><li class="listitem">Right click on <strong>Chapter8Tools</strong>, select <strong>Add</strong>, and then select <strong>Script</strong>.</li></ol></div><p>The following menu will appear allowing you to set up the script tool. Add a title with no spaces and a label, as well as a description. I prefer to run script tools in the foreground to see the messages it passes, but it is not necessary and can be annoying when needing to start a script and still work on other tasks. Click <strong>Next</strong> once the menu has been filled out.</p><div><img src="img/8662OS_07_01.jpg" alt="Creating a Script tool"/></div><p>The next <a id="id258" class="indexterm"/>menu contains an entry field and a file dialog button, allowing the user to find the script to which the parameters collected will be passed. Use the file dialog to navigate to and select the script, and make sure that <strong>Run Python script in process</strong> is checked.</p><div><img src="img/8662OS_07_02.jpg" alt="Creating a Script tool"/></div><p>Now, push <strong>Next</strong> once <a id="id259" class="indexterm"/>the script has been identified.</p><div><img src="img/8662OS_07_03.jpg" alt="Creating a Script tool"/></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec57"/>Labelling and defining parameters </h2></div></div></div><p>The next <a id="id260" class="indexterm"/>dialog box is the most important one. It is where <a id="id261" class="indexterm"/>the parameters to be passed are labeled and their data types are defined. Care must be taken to choose the correct data type for each parameter as there are multiple data types that can be supplied for some of the parameters. Also, properties for each parameter will be defined; this information will characterize the data to be collected and help to make it possible for the data to be in the correct format as well as the correct data type.</p><p>Start by adding the display name for each parameter to be collected. The display name should explain the type of input that is required. For instance, the first parameter will be the bus stop's feature class, so the display name could be <strong>Bus Stop Feature Class</strong>.</p><div><div><h3 class="title"><a id="note11"/>Note</h3><p>Make sure to add  the display names in the order that they will be passed to variables in the script.</p></div></div><div><img src="img/8662OS_07_04.jpg" alt="Labelling and defining parameters"/></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec24"/>Adding data types</h3></div></div></div><p>Next, add <a id="id262" class="indexterm"/>in the <strong>Data Types</strong> for each parameter. This is intricate <a id="id263" class="indexterm"/>because there will be a large list of data types to choose from, and often there are a few types that would work for many parameters. For instance, if a shapefile parameter is created, it would allow the user to select a shapefile as expected. However, it might be better to use the Feature Class data type, as then both shapefiles and feature classes could be used in the analysis.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec25"/>Adding the Bus Stop feature class as a parameter</h3></div></div></div><p>The <a id="id264" class="indexterm"/>first parameter is the <strong>Bus Stop feature class</strong>, and <a id="id265" class="indexterm"/>it should be a <strong>Feature Class</strong> data type. Click on the <strong>Data Type Field </strong>next to the display name and a drop-down list will appear. Once the data type is selected, check out the <strong>parameter properties</strong> below the list of parameters. For the Bus Stop feature class, the defaults will be acceptable, as the feature class is required, is not a multi-value, has no default or environment settings, and is not obtained from any other parameter.</p><div><img src="img/8662OS_07_05.jpg" alt="Adding the Bus Stop feature class as a parameter"/></div><div><div><h3 class="title"><a id="note12"/>Note</h3><p>Some<a id="id266" class="indexterm"/> of the parameters will <a id="id267" class="indexterm"/>require another parameter to be selected first as they are derived values obtained from the first parameter. The Census Block Field parameter and the SQL statement parameter derive values from the Census Block feature class and Bus Stop feature class parameters, respectively.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec26"/>Adding the Census Block feature class as a parameter</h3></div></div></div><p>The <a id="id268" class="indexterm"/>Census Block feature class is <a id="id269" class="indexterm"/>similar to the Bus Stop feature class. It will be a Feature Class data type, allowing both shapefiles and feature classes to be selected, and there is no need to adjust the default parameter properties. Once the data type has been set, the <strong>Census Block</strong> parameter is ready for use.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec27"/>Adding the Census Block field as a parameter</h3></div></div></div><p>The<a id="id270" class="indexterm"/> <strong>Census Block</strong> field parameter has a new <a id="id271" class="indexterm"/>twist; it is obtained from the Census Block feature class parameter, and will only be populated once that first parameter has been created. To make this possible, the <strong>Obtained from parameter</strong> property will have to be set. Select <strong>Field</strong> as the data type, and then click on the blank area next to the <strong>Obtained from parameter</strong> property and select <strong>Census_Block_Feature_Class</strong>. This will create a list of the fields contained within the <strong>Census Block feature class</strong>.</p><div><img src="img/8662OS_07_06.jpg" alt="Adding the Census Block field as a parameter"/></div></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec28"/>Adding the output spreadsheet as a parameter</h3></div></div></div><p>As <a id="id272" class="indexterm"/>the spreadsheet that will be produced from the <a id="id273" class="indexterm"/>analysis run by the script tool is a<a id="id274" class="indexterm"/> <strong>Comma Separated Value</strong> (<strong>CSV</strong>) file, select <strong>Text File</strong> as the <strong>Data Type</strong>. Setting the <strong>Default</strong> parameter property to a file name can save time, and will make the required file extension easier to identify. Also, as the spreadsheet will be produced by the Script tool as an output, the <strong>Direction</strong> parameter property should be <strong>Output</strong>.</p><div><img src="img/8662OS_07_07.jpg" alt="Adding the output spreadsheet as a parameter"/></div></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec29"/>Adding the spreadsheet field names as a parameter</h3></div></div></div><p>The <a id="id275" class="indexterm"/>field names chosen as headers for the <a id="id276" class="indexterm"/>output spreadsheet should be a <strong>String</strong> data type, with the field names separated by commas and no spaces. The script uses the string data type's <code class="literal">split</code> method to separate the field names. Passing a comma to the <code class="literal">split</code> method separates the parameter by <strong>splitting</strong> the input string on the commas to create a list of field names. The list of field names will be used as a header by the <code class="literal">csv</code> module when creating the spreadsheet.</p><div><img src="img/8662OS_07_08.jpg" alt="Adding the spreadsheet field names as a parameter"/></div></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec30"/>Adding the SQL Statement as a parameter</h3></div></div></div><p>The <strong>SQL Statement</strong> parameter will require the helpful SQL Expression Builder menu and <a id="id277" class="indexterm"/>should therefore be a <strong>SQL Expression</strong> data <a id="id278" class="indexterm"/>type. The SQL Expression Builder will use a field obtained from the Bus Stop feature class. Set the <code class="literal">Obtained from parameter</code> property to the Bus Stop feature class by clicking on that property and selecting <strong>Bus_Stop_Feature_Class</strong> from the drop-down list.</p><div><img src="img/8662OS_07_09.jpg" alt="Adding the SQL Statement as a parameter"/></div></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec31"/>Adding the bus stop fields as a parameter</h3></div></div></div><p>The final <a id="id279" class="indexterm"/>parameter is the bus stop fields parameter, which is<a id="id280" class="indexterm"/> a <strong>Field</strong> data type that will be obtained from the <strong>Bus Stop feature class</strong>. Change the <strong>MultiValue</strong> parameter property from <strong>No</strong> to <strong>Yes</strong> to allow the user to select multiple fields. Also remember to set the <strong>Obtained</strong> <strong>from parameter</strong> property to <strong>Bus_Stop_Feature_Class</strong> so that the fields are populated from the Bus Stop feature class parameter.</p><div><img src="img/8662OS_07_10.jpg" alt="Adding the bus stop fields as a parameter"/></div><p>Now <a id="id281" class="indexterm"/>that all the parameters have been described <a id="id282" class="indexterm"/>and their properties have been set, the script tool is ready. Click on <strong>Finish</strong> to close the menu.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec38"/>Inspecting the final script</h1></div></div></div><p>Once all<a id="id283" class="indexterm"/> of the parameters have been collected, the variables are then used to replace the hard-coded field lists or other static script elements with the new dynamic parameters collected from the script tool. In this manner, the script has become a valuable tool that can be used for multiple data analyses, as the fields to be analyzed are now dynamic:</p><div><pre class="programlisting">
<strong>import arcpy, csv</strong>
<strong>busStops = arcpy.GetParameterAsText(0)</strong>
<strong>censusBlocks2010 = arcpy.GetParameterAsText(1)</strong>
<strong>censusBlockField = arcpy.GetParameterAsText(2)</strong>
<strong>csvname = arcpy.GetParameterAsText(3)</strong>
<strong>headers = arcpy.GetParameterAsText(4).split(',')</strong>
<strong>sql = arcpy.GetParameterAsText(5)</strong>
<strong>keyfields = arcpy.GetParameterAsText(6).split(';')</strong>
<strong>dataDic = {}</strong>
<strong>censusFields = [ 'BLOCKID10',censusBlockField,'SHAPE@']</strong>
<strong>if "SHAPE@" not in keyfields:</strong>
<strong>    keyfields.append("SHAPE@")</strong>

<strong>arcpy.AddMessage(busStops)</strong>
<strong>arcpy.AddMessage(censusBlocks2010)</strong>
<strong>arcpy.AddMessage(censusBlockField)</strong>
<strong>arcpy.AddMessage(csvname)</strong>
<strong>arcpy.AddMessage(sql)</strong>
<strong>arcpy.AddMessage(keyfields)</strong>
<strong>x = 0</strong>
<strong>with arcpy.da.SearchCursor(busStops, keyfields, sql) as cursor:</strong>
<strong>    for row in cursor:</strong>
<strong>        stopid = x</strong>
<strong>        shape = row[-1]</strong>
<strong>        dataDic[stopid] = []</strong>
<strong>        dataDic[stopid].append(shape.buffer(400))</strong>
<strong>        dataDic[stopid].extend(row[:-1])</strong>
<strong>        x+=1</strong>
<strong>         </strong>
<strong>processedDataDic = {}</strong>
<strong>for stopid in dataDic.keys():</strong>
<strong>    values = dataDic[stopid]</strong>
<strong>    busStopBuffer = values[0]</strong>
<strong>    blocksIntersected = []</strong>
<strong>    with arcpy.da.SearchCursor(censusBlocks2010, censusFields) as cursor:</strong>
<strong>        for row in cursor:</strong>
<strong>            block = row[-1]</strong>
<strong>            population = row[1]</strong>
<strong>            blockid = row[0]            </strong>

<strong>            if busStopBuffer.overlaps(block) ==True:</strong>
<strong>                interPoly = busStopBuffer.intersect(block,4)</strong>
<strong>                data = population,interPoly, block</strong>
<strong>                blocksIntersected.append(data)</strong>
<strong>    processedDataDic[stopid] = values, blocksIntersected</strong>
<strong>     </strong>
<strong>dataList = []</strong>
<strong>for stopid in processedDataDic.keys():</strong>
<strong>    allValues = processedDataDic[stopid]</strong>
<strong>    popValues = []</strong>
<strong>    blocksIntersected = allValues[-1]</strong>
<strong>    for blocks in blocksIntersected:</strong>
<strong>        pop = blocks[0]</strong>
<strong>        totalArea = blocks[-1].area</strong>
<strong>        interArea = blocks[-2].area</strong>
<strong>        finalPop = pop * (interArea/totalArea)</strong>
<strong>        popValues.append(finalPop)</strong>
<strong>    averagePop = round(sum(popValues)/len(popValues),2)</strong>
<strong>    busStopLine = allValues[0][1]</strong>
<strong>    busStopID = stopid</strong>
<strong>    finalData = busStopLine, busStopID, averagePop</strong>
<strong>    dataList.append(finalData)</strong>



<strong>def createCSV(data, csvname, mode ='ab'):</strong>
<strong>    with open(csvname, mode) as csvfile:</strong>
<strong>        csvwriter = csv.writer(csvfile, delimiter=',')</strong>
<strong>        csvwriter.writerow(data)</strong>
<strong>             </strong>
<strong>headers.insert(0,"ID")</strong>
<strong>createCSV(headers, csvname, 'wb')     </strong>
<strong>for data in dataList:</strong>
<strong>    createCSV(data, csvname)</strong>
</pre></div><p>The <a id="id284" class="indexterm"/>variable <code class="literal">x</code> was added to keep track of the members of the dictionary <code class="literal">dataDic</code>, which in the script in <a class="link" href="ch06.html" title="Chapter 6. Working with ArcPy Geometry Objects">Chapter 6</a>, <em>Working with ArcPy Geometry Objects</em> had relied on the <code class="literal">STOPID</code> field. To eliminate this dependency, <code class="literal">x</code> was introduced.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec58"/>Running the Script Tool</h2></div></div></div><p>Now that the frontend has been designed to accept parameters from a user, and the backend script is ready to accept the parameters from the frontend, the tool is ready to be executed. Double click on the <strong>Script Tool</strong> in the toolbox to open the tool dialog box.</p><div><img src="img/8662OS_07_11.jpg" alt="Running the Script Tool"/></div><p>Select the <a id="id285" class="indexterm"/>parameters as with any ArcToolbox tool (for example using the file dialog to navigate a file tree to the <strong>Bus Stop feature class</strong>). Once the parameters have been set, click on <strong>OK</strong> to execute the script.</p><p>One optional adjustment would be to add an <code class="literal">arcpy.AddMessage</code> line where the average population is calculated. By doing this, the individual block population would be displayed and the script console would give feedback about the progress of the script.</p><p>Insert in the script just below the line where the variable <code class="literal">finalData</code> is defined:</p><div><pre class="programlisting">
<strong>arcpy.AddMessage(finalData)</strong>
</pre></div><p>The feedback provided by this line will make it obvious that the script is working, which is useful when the script executes a long analysis. When performing long analyses, it is good practice to provide feedback to the user so that they can see that the script is working as expected. Pass newline characters (<code class="literal">\n</code>) as parameters to <code class="literal">arcpy.AddMessage</code> when there is a large amount of data being passed to <code class="literal">arcpy.AddMessage</code>. This will break up the data into discrete chunks and make it easier to read.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec39"/>Summary</h1></div></div></div><p>In this chapter, we learned how to convert a script into a permanent and sharable script tool that can be used by an ArcGIS user with no programming experience. By creating a frontend using the familiar ArcGIS tool interface, and then passing parameters to custom built tools that employ ArcPy, GIS programmers can combine the ease of use of the ArcToolbox with the power of Python.</p><p>In the next chapter, we will explore how to use ArcPy to control the export of maps from map documents. By adjusting map elements such as titles and legends, we can create dynamic map outputs to reflect the nature of the data produced by map analysis. In <a class="link" href="ch09.html" title="Chapter 9. More ArcPy.Mapping Techniques">Chapter 9</a>, <em>More Arcpy.Mapping Techniques </em>we will add the output of maps to our script tool created in this chapter.</p></div></body></html>