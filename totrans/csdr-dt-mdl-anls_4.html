<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Indexes</h1></div></div></div><p>There is no doubt that Cassandra can store a gigantic volume of data effortlessly. However, if we cannot efficiently look for what we want in such a data abyss, it is meaningless. Cassandra provides very good support to search and retrieve the desired data by the primary index and secondary index.</p><p>In this chapter, we will look at how Cassandra uses the primary index and the secondary index to spotlight the data. After developing an understanding of them, we can then design a high-performance data model.</p><div><div><div><div><h1 class="title"><a id="ch04lvl1sec22"/>Primary index</h1></div></div></div><p>Cassandra is a column-based database. Each row can have different number of columns. A cell is the<a id="id314" class="indexterm"/> placeholder of the value and the timestamp data is identified by a row and column. Each cell can store values that are less than 2 GB. The rows are grouped by partitions. The maximum number of cells per partition is limited to the condition that the number of rows times the number of columns is less than 2 billion. Each row is identified by a row key that determines which machine stores the row. In other words, the row key determines the node location of the row. A list of row keys of a table is known<a id="id315" class="indexterm"/> as a primary key. A primary index is just created on the primary key.</p><p>A primary key can be defined on a single column or multiple columns. In either case, the first component of a table's primary key is the partition key. Each node stores a data partition of the table and maintains its own primary key for the data that it manages. Therefore, each node knows what ranges of row key it can manage and the rows can then be located by scanning the row indexes only on the relevant replicas. The range of the primary keys that a node manages is determined by the partition key and a cluster-wide configuration parameter called partitioner. Cassandra provides three choices to partitioner that will be covered later in this chapter.</p><p>A primary key can be defined by the CQL keywords <code class="literal">PRIMARY KEY</code>, with the column(s) to be indexed. Imagine that we want to store the daily stock quotes into a Cassandra table called <code class="literal">dayquote01</code>. The <code class="literal">CREATE TABLE</code> statement creates a table with a simple primary key that involves only one column, as shown in the following screenshot:</p><div><img src="img/8884OS_04_01.jpg" alt="Primary index"/></div><p>The <code class="literal">symbol</code> field<a id="id316" class="indexterm"/> is assigned the primary key of the <code class="literal">dayquote01</code> table. This means that all the rows of the same symbol are stored on the same node. Hence, this makes the retrieval of these rows very efficient.</p><p>Alternatively, the primary key can be defined by an explicit <code class="literal">PRIMARY KEY</code> clause, as shown in the following screenshot:</p><div><img src="img/8884OS_04_02.jpg" alt="Primary index"/></div><p>Unlike relational databases, Cassandra does not enforce a unique constraint on the primary key, as there is no <em>primary key violation</em> in Cassandra. An <code class="literal">INSERT</code> statement using an existing row key is allowed. Therefore, in CQL, <code class="literal">INSERT</code> and <code class="literal">UPDATE</code> act in the same way, which is <a id="id317" class="indexterm"/>known as <strong>UPSERT</strong>. For example, we can insert two records into the table <code class="literal">dayquote01</code> with the same symbol and no primary key violation is alerted, as shown in the following screenshot:</p><div><img src="img/8884OS_04_03.jpg" alt="Primary index"/></div><p>The returned<a id="id318" class="indexterm"/> query result contains only one row, not two rows as expected. This is because the primary key is the symbol and the row in the latter <code class="literal">INSERT</code> statement overrode the record that was created by the former <code class="literal">INSERT</code> statement. There is no warning for a duplicate primary key. Cassandra simply and quietly updated the row. This silent UPSERT behavior might sometimes cause undesirable effects in the application logic.</p><div><div><h3 class="title"><a id="tip04"/>Tip</h3><p>Hence, it is very important for an application developer to handle duplicate primary key situations in the application logic. Do not rely on Cassandra to check the uniqueness for you.</p></div></div><p>In fact, the reason why Cassandra behaves like this becomes more clear when we know how the internal storage engine stores the row, as shown by Cassandra CLI in the following screenshot:</p><div><img src="img/8884OS_04_04.jpg" alt="Primary index"/></div><p>The row <a id="id319" class="indexterm"/>key is <code class="literal">0001.HK</code>. It is used to locate which node is used to store the row. Whenever we insert or update the row of the same row key, Cassandra blindly locates the row and modifies the columns accordingly, even though an <code class="literal">INSERT</code> statement has been used.</p><p>Although a single column primary key is not uncommon, a primary key composed of more than one column is much more practical.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec23"/>Compound primary key and composite partition key</h1></div></div></div><p>A <a id="id320" class="indexterm"/>compound primary key is composed of more than one <a id="id321" class="indexterm"/>column. The order of the columns is important. The structure of a compound primary key is depicted in the following figure:</p><div><img src="img/8884OS_04_05.jpg" alt="Compound primary key and composite partition key"/></div><p>Columns 1 to A are used as the partition key for Cassandra to determine the node location for the partition. The remaining columns, columns B to N, are referred to as the clustering columns for the ordering of data. The clustering columns are used to locate a unique record in the data node. They are ordered, by default, and have the ability to use the <code class="literal">ORDER BY [DESC]</code> clause in the <code class="literal">SELECT</code> statements. Moreover, we can get the <code class="literal">MIN</code> or <code class="literal">MAX</code> values for clustering keys with the <code class="literal">LIMIT 1</code> clause. We also need to use the clustering<a id="id322" class="indexterm"/> columns for the predicates in a <code class="literal">WHERE</code> clause. We <a id="id323" class="indexterm"/>cannot leave out one when trying to build a query.</p><p>To define a compound primary key, an explicit <code class="literal">PRIMARY KEY</code> clause must be used in the <code class="literal">CREATE TABLE</code> or <code class="literal">ALTER TABLE</code> statements. We can define a compound primary key for the table <code class="literal">dayquote03</code>, as shown in the following screenshot:</p><div><img src="img/8884OS_04_06.jpg" alt="Compound primary key and composite partition key"/></div><p>Because the first part of the primary key (that is <code class="literal">symbol</code>) is the same as that of the simple primary key, the partition key is the same as that in <code class="literal">dayquote01</code>. Therefore, the node location is the same regardless of whether the primary key is compound or not, as in this case.</p><p>So, what is difference between the simple primary key (<code class="literal">symbol</code>) and this compound one (<code class="literal">symbol, price_time</code>)? The additional field <code class="literal">price_time</code> instructs Cassandra to guarantee the clustering or ordering of the rows within the partition by the values of <code class="literal">price_time</code>. Thus, the compound primary key sorts the rows of the same symbol by <code class="literal">price_time</code>. We insert two records into the <code class="literal">dayquote03</code> table and select all the records to see the effect, as shown in the following screenshot:</p><div><img src="img/8884OS_04_07.jpg" alt="Compound primary key and composite partition key"/></div><p>Two <a id="id324" class="indexterm"/>records are returned as expected (compared to only<a id="id325" class="indexterm"/> one record in <code class="literal">dayquote01</code>). Moreover, the ordering of the results is sorted by the values of <code class="literal">price_time</code>. The following screenshot shows the internal view of the rows in the <code class="literal">dayquote03</code> table:</p><div><img src="img/8884OS_04_08.jpg" alt="Compound primary key and composite partition key"/></div><p>The <a id="id326" class="indexterm"/>row key is still the partition key, that is, <code class="literal">0001.HK</code>. However, Cassandra stores the two rows returned by the CQL <code class="literal">SELECT</code> statement, as <a id="id327" class="indexterm"/>one single internal row in its storage. The values of the clustering columns are used as a prefix to the columns that are not specified in the <code class="literal">PRIMARY KEY</code> clause. As Cassandra stores the internal columns in the sorting order of the column name, the rows returned by the CQL <code class="literal">SELECT</code> statement are sorted inherently. In a nutshell, on a physical node, when the rows for a partition key are stored in the order that is based on the clustering columns, the retrieval of rows is very efficient.</p><p>Now you know that the first part of a compound primary key is the partition key. If we need to keep on storing 3,000 daily quotes (around 10 years) for <code class="literal">0001.HK</code>, although the CQL <code class="literal">SELECT</code> statement returns 3,000 virtual rows, Cassandra requires to store these 3,000 virtual rows as one entire row on a node by the partition key. The size of the entire row gets bigger and bigger on a node as a result of storing more and more daily quotes. The row will quickly become gigantic over a period of time and will then pose a serious performance problem, as a result of an unbalanced cluster. The solution is a feature offered by Cassandra called composite partition key.</p><p>The <a id="id328" class="indexterm"/>composite partition key spreads the data over multiple<a id="id329" class="indexterm"/> nodes. It is defined by an extra set of parentheses in the <code class="literal">PRIMARY KEY</code> clause. Let us create another table <code class="literal">dayquote04</code> with a composite partition key in order to illustrate the effect. The columns <code class="literal">exchange</code> and <code class="literal">symbol</code> are now members of a composite partition key, whereas the column <code class="literal">price_time</code> is a clustering column. We insert the same two records of different symbols into <code class="literal">dayquote04</code>, as shown in the following screenshot:</p><div><img src="img/8884OS_04_09.jpg" alt="Compound primary key and composite partition key"/></div><p>With reference to the following screenshot, two internal rows are returned with their row keys as <code class="literal">SEHK:0001.HK</code> and <code class="literal">SEHK:0002.HK</code>, respectively. Internally, Cassandra concatenates the columns in the composite partition key together as an internal row key. In short, the original row without a composite partition key is now split into two rows. As the row keys are now different from each other, the corresponding rows can be stored on different nodes. The value of the clustering column <code class="literal">price_time</code> is still used as a prefix in the internal column name to preserve the ordering of data:</p><div><img src="img/8884OS_04_10.jpg" alt="Compound primary key and composite partition key"/></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec60"/>Time-series data</h2></div></div></div><p>Cassandra is<a id="id330" class="indexterm"/> very suitable for handling time-series<a id="id331" class="indexterm"/> type of data, such as web server logfiles, usage data, sensor data, SIP packets, and so on. The tables <code class="literal">dayquote01</code> to <code class="literal">dayquote04</code> in the previous sections are used to store the daily stock quotes is an example of the time-series data.</p><p>We have just seen in the last section that a composite partition key is a better way of not overwhelming the row. It limits the size of the rows on the basis of a symbol. However, this does partially solve the problem. The size of the row of a symbol still grows over a period of time. Do you have any other suggestion? We can define an artificial column, <code class="literal">quote_date</code>, in the table and set the composite partition key to <code class="literal">exchange</code> and <code class="literal">quote_date</code> instead, as shown in the following screenshot:</p><div><img src="img/8884OS_04_11.jpg" alt="Time-series data"/></div><p>Now the <a id="id332" class="indexterm"/>composite partition key limits the size of<a id="id333" class="indexterm"/> the rows on a daily basis, and makes the rows more manageable. This way of doing is analogous to inserting the data into different buckets<a id="id334" class="indexterm"/> labeled by a particular date. Hence, it is given a name called the <strong>date bucket pattern</strong>. Partitioning by the date also makes table maintenance easier by allowing you to drop the partition of <code class="literal">quote_date</code>. One drawback of the date bucket pattern is that you always need to know the partition key in order to get the rows. So, in <code class="literal">dayquote05</code>, you cannot get the latest <code class="literal">quote_date</code> value using the <code class="literal">ORDER BY DESC</code> and <code class="literal">LIMIT 1</code> clauses.</p><p>The date bucket pattern gives an application developer a design option to attain a more balanced cluster, but how balanced a cluster is depends on a number of factors in which the most important one is the selection of the partitioner.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec24"/>Partitioner</h1></div></div></div><p>A partitioner<a id="id335" class="indexterm"/> is basically a hash function used to calculate the <code class="literal">TOKEN()</code> (the hash value) of a row key and so, it determines how data is distributed across the nodes in a cluster. Choosing a partitioner determines which node is used to place the first copy of data. Each row of data is uniquely identified by a partition key and is distributed across the cluster by the value of the <code class="literal">TOKEN()</code>. Cassandra provides the following three partitioners:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Murmur3Partitioner</code> (default since version 1.2)</li><li class="listitem" style="list-style-type: disc"><code class="literal">RandomPartitioner</code> (default before version 1.2)</li><li class="listitem" style="list-style-type: disc"><code class="literal">ByteOrderedPartitioner</code></li></ul></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec61"/>Murmur3Partitioner</h2></div></div></div><p>
<code class="literal">Murmur3Partitioner</code> provides<a id="id336" class="indexterm"/> faster hashing and improved <a id="id337" class="indexterm"/>performance than the partitioner <code class="literal">RandomPartitioner</code>. It is the default partitioning strategy and the right choice for new clusters in almost all cases. It uses the <em>MurmurHash</em> function that creates a 64-bit hash value of the partition key. The possible range of hash values is from -2<sup>63</sup> to +2<sup>63</sup> -1. When using <code class="literal">Murmur3Partitioner</code>, you can page through all the rows using the <code class="literal">TOKEN()</code> function in a CQL <code class="literal">SELECT</code> statement.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec62"/>RandomPartitioner</h2></div></div></div><p>
<code class="literal">RandomPartitioner</code> was<a id="id338" class="indexterm"/> the default partitioner prior to <a id="id339" class="indexterm"/>Cassandra Version 1.2. It distributes data evenly across the nodes using an <em>MD5</em> hash value of the row key. The possible range of hash values is from 0 to 2<sup>127</sup> -1. The MD5 hash function is slow in performance, that is why Cassandra has moved to Murmur3 hashes. When using <code class="literal">RandomPartitioner</code>, you can page through all rows using the <code class="literal">TOKEN()</code> function in a CQL <code class="literal">SELECT</code> statement.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec63"/>ByteOrderedPartitioner</h2></div></div></div><p>
<code class="literal">ByteOrderedPartitioner</code>, as its name suggests, is used for ordered partitioning. This partitioner <a id="id340" class="indexterm"/>orders rows lexically by key bytes. Tokens are<a id="id341" class="indexterm"/> calculated by looking at the actual values of the partition key data and using a hexadecimal representation of the leading character(s) in a key. For example, if you wanted to partition rows alphabetically, you can assign a B <code class="literal">TOKEN()</code> using its hexadecimal representation of <code class="literal">0x42</code>.</p><p>Using <code class="literal">ByteOrderedPartitioner</code> allows ordered scans by a primary key as though you were moving a cursor through a traditional index in a relational table. This type of range scan query is not possible using <code class="literal">RandomPartitioner</code> because the keys are stored in the order of their MD5 hash, and not in the sequential order of the keys.</p><p>Apparently, performing range-scan on rows sounds like a desirable feature of <code class="literal">ByteOrderedPartitioner</code>. There are ways to achieve the same functionality using secondary<a id="id342" class="indexterm"/> indexes. Conversely, using <code class="literal">ByteOrderedPartitioner</code> is not recommended for the following reasons:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Difficult load balancing</strong>: More administrative overhead is required to load balance the cluster. <code class="literal">ByteOrderedPartitioner</code> requires administrators to manually calculate partition ranges based on their estimates of the partition key distribution.</li><li class="listitem" style="list-style-type: disc"><strong>Sequential writes can cause hot spots</strong>: If the application tends to write or update a sequential block of rows at a time, the writes will not be distributed across<a id="id343" class="indexterm"/> the cluster. They all go to one<a id="id344" class="indexterm"/> node. This is frequently a problem for applications dealing with timestamped data.</li><li class="listitem" style="list-style-type: disc"><strong>Uneven load balancing for multiple tables</strong>: If the application has multiple tables, chances are that these tables have different row keys and different distributions<a id="id345" class="indexterm"/> of data. An ordered partitioner that is balanced for one table can cause hot spots and uneven distribution for another table in the same cluster.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec64"/>Paging and token function</h2></div></div></div><p>When <a id="id346" class="indexterm"/>using the <code class="literal">RandomPartitioner</code> or <code class="literal">Murmur3Partitioner</code>, the rows are ordered by the hash of their value. Hence, the order of the rows is<a id="id347" class="indexterm"/> not meaningful. Using CQL, the rows can still be paged through <a id="id348" class="indexterm"/>even when using <code class="literal">RandomPartitioner</code> or <code class="literal">Murmur3Partitioner</code> using the <code class="literal">TOKEN()</code> function, as shown in the following<a id="id349" class="indexterm"/> screenshot:</p><div><img src="img/8884OS_04_12.jpg" alt="Paging and token function"/></div><p>
<code class="literal">ByteOrderedPartitioner</code> arranges tokens in the same way as key values, while <code class="literal">RandomPartitioner</code> and <code class="literal">Murmur3Partitioner</code> distribute tokens in a completely unordered manner. The <code class="literal">TOKEN()</code> function makes it possible to page through the unordered partitioner results. It actually queries results directly using tokens.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec25"/>Secondary indexes</h1></div></div></div><p>As Cassandra <a id="id350" class="indexterm"/>only allows each table to have one primary key, it supports secondary index on columns other than those in the primary key. The benefit is a fast, efficient lookup of data matching the indexed columns in the <code class="literal">WHERE</code> clause. Each table can have more than one secondary index. Cassandra uses secondary indexes to find the rows that are not using the row key. Behind the scenes, the secondary index is implemented as a separate, hidden table that is maintained automatically by the internal process of Cassandra. As with relational databases, keeping secondary indexes up to date is not free, so unnecessary indexes should be avoided.</p><div><div><h3 class="title"><a id="note29"/>Note</h3><p>The<a id="id351" class="indexterm"/> major difference <a id="id352" class="indexterm"/>between a primary index and a secondary index is that the primary index is a distributed index used to locate the node that stores the row key, whereas the secondary index is a local index just to index the data on the local node.</p></div></div><p>Therefore, the secondary index will not be able to know immediately the locations of all matched rows without having examined all the nodes in the cluster. This makes the performance of the secondary index unpredictable.</p><div><div><h3 class="title"><a id="note30"/>Note</h3><p>The secondary index is the most efficient when using equality predicates. This is indeed a limitation that must have at least one equality predicate clause to hopefully limit the set of rows that need to be read into memory.</p></div></div><p>In addition, the secondary index cannot be created on the primary key itself.</p><div><div><h3 class="title"><a id="note31"/>Note</h3><p>
<strong>Caveat!</strong>
</p><p>Secondary indexes<a id="id353" class="indexterm"/> in Cassandra are <em>NOT</em> equivalent to those in the traditional RDBMS. They are not akin to a B-tree index in RDBMS. They are mostly like a hash. So, the range queries do not work on secondary indexes in Cassandra, only equality queries work on secondary indexes.</p></div></div><p>We can use the CQL <code class="literal">CREATE INDEX</code> statement to create an index on a column after we define a table. For example, we might want to add a column <code class="literal">sector</code> to indicate the sector that the stock belongs to, as shown in the following screenshot:</p><div><img src="img/8884OS_04_13.jpg" alt="Secondary indexes"/></div><p>If we want to <a id="id354" class="indexterm"/>search <code class="literal">dayquote06</code> for symbols that belong to <code class="literal">Properties</code>, we might run the command, as shown in the following screenshot:</p><div><img src="img/8884OS_04_14.jpg" alt="Secondary indexes"/></div><p>As <code class="literal">sector</code> is not in the primary key, we cannot query Cassandra directly by <code class="literal">sector</code>. Instead, we can create a secondary index on the column <code class="literal">sector</code> to make this possible, as shown in the following screenshot:</p><div><img src="img/8884OS_04_15.jpg" alt="Secondary indexes"/></div><p>The index <a id="id355" class="indexterm"/>name <code class="literal">dayquote06_sector_idx</code> is optional, but must be unique within the keyspace. Cassandra assigns a name such as <code class="literal">dayquote06_idx</code> if you do not provide a name. We can now query Cassandra for daily stock quotes by <code class="literal">sector</code>.</p><p>You can see that the columns in the primary key are not present in the <code class="literal">WHERE</code> predicate clause in the previous screenshot and Cassandra uses the secondary index to look for the rows matching the selection condition.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec65"/>Multiple secondary indexes</h2></div></div></div><p>Cassandra supports multiple secondary indexes on a table. The <code class="literal">WHERE</code> clause is executed if at least<a id="id356" class="indexterm"/> one column is involved in a secondary<a id="id357" class="indexterm"/> index. Thus, we can use multiple conditions <a id="id358" class="indexterm"/>in the <code class="literal">WHERE</code> clause to filter the results. When multiple occurrences of data match a condition in the <code class="literal">WHERE</code> predicate clause, Cassandra selects the least frequent occurrence of a condition to process first so as to have a better query efficiency.</p><p>When a potentially expensive query is attempted, such as a range query, Cassandra requires <a id="id359" class="indexterm"/>the <code class="literal">ALLOW FILTERING</code> clause, which can apply additional filters to the result set for values of other non-indexed columns. It works very slowly because it scans all rows in all nodes. The <code class="literal">ALLOW FILTERING</code> clause is used to explicitly direct Cassandra to execute that potentially expensive query on any <code class="literal">WHERE</code> clause without creating secondary indexes, despite unpredictability of the performance.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec66"/>Secondary index do's and don'ts</h2></div></div></div><p>The secondary<a id="id360" class="indexterm"/> index is best on a table that has many rows <a id="id361" class="indexterm"/>that contain fewer unique values, that is low cardinality in the relational database terminologies, which is counterintuitive to the relational people. The more unique values that exist in a particular column, the more overhead you will have to query and maintain the index. Hence, it is not suitable for querying a huge volume of records for a small number of results.</p><div><div><h3 class="title"><a id="tip05"/>Tip</h3><p>Do index the columns with values that have low cardinality. Cassandra stores secondary indexes<a id="id362" class="indexterm"/> only for local rows in the data node as a hash-multimap or as bitmap indexes, you can refer to it at <a class="ulink" href="https://issues.apache.org/jira/browse/CASSANDRA-1472">https://issues.apache.org/jira/browse/CASSANDRA-1472</a>.</p></div></div><p>Secondary indexes should be avoided in the following situations:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">On high-cardinality columns for a small number of results out of a huge volume of rows<p>An index on a high-cardinality column will incur many seeks for very few results. For columns containing unique values, using an index for convenience is fine from a performance perspective, as long as the query volume to the indexed column family is moderate and not under constant load.</p></li><li class="listitem" style="list-style-type: disc">In tables that use a counter column</li><li class="listitem" style="list-style-type: disc">On a frequently updated or deleted column<p>Cassandra stores tombstones (a marker in a row that indicates that a column was deleted. During compaction, marked columns are deleted in the index (a hidden table) until the tombstone limit reaches 100 K cells. After exceeding this limit, the query that uses the indexed value will fail.</p></li><li class="listitem" style="list-style-type: disc">To look for a row in a large partition<p>A query on an indexed column in a large cluster typically requires collating responses from multiple data partitions. The query response slows down as more machines get added to the cluster.</p></li></ul></div><div><div><h3 class="title"><a id="tip06"/>Tip</h3><p>
<strong>Important points to take note of</strong>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Don't index<a id="id363" class="indexterm"/> on high-cardinality columns</li><li class="listitem" style="list-style-type: disc">Don't use<a id="id364" class="indexterm"/> index in tables having a counter column</li><li class="listitem" style="list-style-type: disc">Don't index on a frequently updated or deleted column</li><li class="listitem" style="list-style-type: disc">Don't abuse the index to look for a row in a large partition</li></ul></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec26"/>Summary</h1></div></div></div><p>We have learned about the primary and secondary indexes in this chapter. Related topics such as compound primary key, composite partition key, and partitioner are also introduced. With the help of the explanation of the internal storage and inner working mechanisms of Cassandra, you should now be able to state the difference between the primary index and the secondary index, as well as use them properly in your data model.</p><p>In the next chapter, we will start building the first version of the technical analysis application using Cassandra and Python. A quick installation and setup guide on how to connect Python to Cassandra and collect market data will also be provided.</p></div></body></html>