<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Cassandra Data Modeling</h1></div></div></div><p>In this chapter, we will open the door to the world of Cassandra data modeling. We will briefly go through its building blocks, the main differences to the relational data model, and examples of constructing queries on a Cassandra data model.</p><p>Cassandra describes its data model components by using the terms that are inherited from the Google BigTable parent, for example, column family, column, row, and so on. Some of these terms also exist in a relational data model. They, however, have completely different meanings. It often confuses developers and administrators who have a background in the relational world. At first sight, the Cassandra data model is counterintuitive and very difficult to grasp and understand.</p><p>In the relational world, you model the data by creating entities and associating them with relationships according to the guidelines governed by the relational theories. It means that you can solely concentrate on the logical view or structure of the data without any considerations of how the application accesses and manipulates the data. The objective is to have a stable data model complying with the relational guidelines. The design of the application can be done separately. For instance, you can answer different queries by constructing different SQL statements, which is not of your concern during data modeling. In short, relational data modeling is process oriented, based on a clear separation of concerns.</p><p>On the contrary, in Cassandra, you reverse the above steps and always start from what you want to answer in the queries of the application. The queries exert a considerable amount of influence on the underlying data model. You also need to take the physical storage and the cluster topology into account. Therefore, the query and the data model are twins, as they were born together. Cassandra data modeling is result oriented based on a clear understanding of how a query works internally in Cassandra.</p><p>Owing to the unique architecture of Cassandra, many simple things in a relational database, such as sequence and sorting, cannot be presumed. They require your special handling in implementing the same. Furthermore, they are usually design decisions that you need to make upfront in the process of data modeling. Perhaps it is the cost of the trade-off for the attainment of superb scalability, performance, and fault tolerance.</p><p>To enjoy reading this book, you are advised to temporarily think in both relational and NoSQL ways. Although you may not become a friend of Cassandra, you will have an eye-opening experience in realizing the fact that there exists a different way of working in the world.</p><div><div><div><div><h1 class="title"><a id="ch02lvl1sec13"/>What is unique to the Cassandra data model?</h1></div></div></div><p>If you want me to use <a id="id104" class="indexterm"/>just one sentence to describe Cassandra's data model, I will say it is a non-relational data model, period. It implies that you need to forget the way you do data modeling in a relational database.</p><p>You focus on modeling the data according to relational theories. However, in Cassandra and even in other NoSQL databases, you need to focus on the application in addition to the data itself. This means you need to think about how you will query the data in the application. It is a paradigm shift for those of you coming from the relational world. Examples are given in the subsequent sections to make sure that you understand why you cannot apply relational theories to model data in Cassandra.</p><p>Another important consideration<a id="id105" class="indexterm"/> in Cassandra data modeling is that you need to take the physical topology of a Cassandra cluster into account. In a relational database, the primary goal is to remove data duplication through normalization to have a single source of data. It makes a relational database ACID compliant very easily. The related storage space required is also optimized. Conversely, Cassandra is designed to work in a massive-scale, distributed environment in which ACID compliance is difficult to achieve, and replication is a must. You must be aware of such differences in the process of data modeling in Cassandra.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Map and SortedMap</h2></div></div></div><p>In <a class="link" href="ch01.html" title="Chapter 1. Bird's Eye View of Cassandra">Chapter 1</a>, <em>Bird's Eye View of Cassandra</em>, you learned that Cassandra's storage model is based on BigTable, a column-oriented store. A column-oriented store is a multidimensional map. Specifically, it is a data structure known as <a id="id106" class="indexterm"/>
<strong>Map</strong>. An example<a id="id107" class="indexterm"/> of the declaration of map data structure is as follows:</p><div><pre class="programlisting">Map&lt;RowKey, SortedMap&lt;ColumnKey, ColumnValue&gt;&gt;</pre></div><p>The <code class="literal">Map</code> data structure<a id="id108" class="indexterm"/> gives efficient key lookup, and the sorted nature provides efficient scans. <code class="literal">RowKey</code> is a unique key and can hold a value. The inner <code class="literal">SortedMap</code> data structure<a id="id109" class="indexterm"/> allows a variable number of <code class="literal">ColumnKey</code> values. This is the trick that Cassandra uses to be schemaless and to allow the data model to evolve organically over time. It should be noted that each column has a client-supplied timestamp associated, but it can be ignored during data modeling. Cassandra uses the timestamp internally to resolve transaction conflicts.</p><p>In a relational database, column names<a id="id110" class="indexterm"/> can be only strings and be stored in the table metadata. In Cassandra, both <code class="literal">RowKey</code> and <code class="literal">ColumnKey</code> can be strings, long<a id="id111" class="indexterm"/> integers, Universal Unique IDs, or any kind of byte arrays. In addition, <code class="literal">ColumnKey</code> is stored in each column. You may opine that it wastes storage space to repeatedly store the <code class="literal">ColumnKey</code> values. However, it brings us a very powerful feature of Cassandra. <code class="literal">RowKey</code> and <code class="literal">ColumnKey</code> can<a id="id112" class="indexterm"/> store data themselves and not just in <code class="literal">ColumnValue</code>. We will not go <a id="id113" class="indexterm"/>too deep into this at the moment; we will revisit it in later chapters.</p><div><div><h3 class="title"><a id="note10"/>Note</h3><p>
<strong>Universal Unique ID</strong>
</p><p>
<strong>Universal Unique ID</strong> (<strong>UUID</strong>)<a id="id114" class="indexterm"/> is an <strong>Internet Engineering Task Force</strong> (<strong>IETF</strong>)<a id="id115" class="indexterm"/> standard, <strong>Request for Comments</strong> (<strong>RFC</strong>) 4122, with the intent of enabling distributed systems<a id="id116" class="indexterm"/> to uniquely identify information without significant central coordination. It is a 128-bit number represented by 32 lowercase hexadecimal digits, displayed in five groups separated by hyphens, for example: <code class="literal">0a317b38-53bf-4cad-a2c9-4c5b8e7806a2</code>
</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec20"/>Logical data structure</h2></div></div></div><p>There are a few logical building blocks to<a id="id117" class="indexterm"/> come up with a Cassandra<a id="id118" class="indexterm"/> data model. Each of them is introduced as follows.</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec05"/>Column</h3></div></div></div><p>Column is the<a id="id119" class="indexterm"/> smallest data model element and storage unit in <a id="id120" class="indexterm"/>Cassandra. Though it also exists in a relational database, it is a different thing in Cassandra. As shown in the following figure, a column is a name-value pair with a timestamp and an optional <strong>Time-To-Live</strong> (<strong>TTL</strong>)<a id="id121" class="indexterm"/> value:</p><div><img src="img/8884OS_02_01.jpg" alt="Column"/><div><p>The elements of a column</p></div></div><p>The name <a id="id122" class="indexterm"/>and the value (<code class="literal">ColumnKey</code> and <code class="literal">ColumnValue</code> in <code class="literal">SortedMap</code> respectively) are byte <a id="id123" class="indexterm"/>arrays, and Cassandra provides a bunch of built-in data types that influence the sort order of the values. The timestamp here is for conflict resolution and is supplied by the client application during a write operation. Time-To-Live is an optional expiration value used to mark the column deleted after expiration. The column is then physically removed during compaction.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec06"/>Row</h3></div></div></div><p>One level up is a <a id="id124" class="indexterm"/>row, as <a id="id125" class="indexterm"/>depicted in the following figure. It is a set of orderable columns with a unique row key, also known as a primary key:</p><div><img src="img/8884OS_02_02.jpg" alt="Row"/><div><p>The structure of a row</p></div></div><p>The row key can be any <a id="id126" class="indexterm"/>one of the same built-in data types as those for columns. What <a id="id127" class="indexterm"/>orderable means is that columns are stored in sorted order by their column names.</p><div><div><h3 class="title"><a id="note11"/>Note</h3><p>Sort order<a id="id128" class="indexterm"/> is extremely important because Cassandra cannot sort by value as we do in a relational database.</p></div></div><p>Different names in columns are possible in different rows. That is why Cassandra is both row oriented and column oriented. It should be remarked that there is no timestamp for rows. Moreover, a row cannot be split to store across two nodes in the cluster. It means that if a row exists on a node, the entire row exists on that node.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec07"/>Column family</h3></div></div></div><p>The next level <a id="id129" class="indexterm"/>up is a <a id="id130" class="indexterm"/>column family. As shown in the<a id="id131" class="indexterm"/> following figure, it is a container for a set of rows with a name:</p><div><img src="img/8884OS_02_03.jpg" alt="Column family"/><div><p>The structure of a column family</p></div></div><p>The row keys in a column family must be unique and are used to order rows. A column family is analogous to a table in a relational database, but you should not go too far with this idea. A column family provides greater flexibility by allowing different columns in different rows. Any column can be freely added to any column family at any time. Once again, it helps Cassandra be schemaless.</p><p>Columns<a id="id132" class="indexterm"/> in a column family are sorted by a comparator. The <a id="id133" class="indexterm"/>comparator determines how columns are sorted and ordered when Cassandra returns the columns in a query. It accepts long, byte and UTF8 for the data type of the column name, and the sort order in which columns are stored within a row.</p><p>Physically, column families are stored in individual files on a disk. Therefore, it is important to keep related columns in the same column family to save disk I/O and improve performance.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec08"/>Keyspace</h3></div></div></div><p>The outermost data model<a id="id134" class="indexterm"/> element is<a id="id135" class="indexterm"/> keyspace, as illustrated in the following figure:</p><div><img src="img/8884OS_02_04.jpg" alt="Keyspace"/><div><p>The structure of a keyspace</p></div></div><p>Keyspace is a set of column families and super column families, which will be introduced in the following section. It is analogous to a schema or database in the relational world. Each Cassandra instance has a system keyspace to keep system-wide metadata.</p><p>Keyspace contains replication settings controlling how data is distributed and replicated in the cluster. Very often, one cluster contains just one keyspace.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec09"/>Super column and super column family</h3></div></div></div><p>As shown in the<a id="id136" class="indexterm"/> following figure, a super column<a id="id137" class="indexterm"/> is a named map of columns and a super column family<a id="id138" class="indexterm"/> is just a<a id="id139" class="indexterm"/> collection of super columns:</p><div><img src="img/8884OS_02_05.jpg" alt="Super column and super column family"/><div><p>The structure of a super column and a super column family</p></div></div><p>Super columns were popular in the earlier versions of Cassandra but are not recommended anymore since they are not supported by the Cassandra Query Language (CQL), a SQL-like language to manipulate and query Cassandra, and must be accessed by using the low-level Thrift API. A column family is enough in most cases.</p><div><div><h3 class="title"><a id="note12"/>Note</h3><p>
<strong>Thrift</strong>
</p><p>Thrift<a id="id140" class="indexterm"/> is a software framework for the development of scalable cross-language services. It combines a software stack with a code generation engine to build services that work efficiently and seamlessly with numerous programming languages. It is used as a <strong>remote procedure call</strong> (<strong>RPC</strong>)<a id="id141" class="indexterm"/> framework and was developed at Facebook Inc. It is now an open source project in the Apache Software Foundation.</p><p>There are other alternatives, for example, Protocol Buffers, Avro, MessagePack, JSON, and so on.</p></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Collections</h2></div></div></div><p>Cassandra<a id="id142" class="indexterm"/> allows <a id="id143" class="indexterm"/>collections, namely sets, lists, and maps, as parts of the data model. Collections are a complex type that can provide flexibility in querying.</p><p>Cassandra allows the following collections:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Sets</strong>: These <a id="id144" class="indexterm"/>provide a <a id="id145" class="indexterm"/>way of keeping a unique set of values. It means that one can easily solve the problem of tracking unique values.</li><li class="listitem" style="list-style-type: disc"><strong>Lists</strong>: These are <a id="id146" class="indexterm"/>suitable<a id="id147" class="indexterm"/> for maintaining the order of the values in the collection. Lists are ordered by the natural order of the type selected.</li><li class="listitem" style="list-style-type: disc"><strong>Maps</strong>: These are<a id="id148" class="indexterm"/> similar to <a id="id149" class="indexterm"/>a store of key-value pairs. They are useful for storing table-like data within a single row. They can be a workaround of not having joins.</li></ul></div><p>Here we only provided a brief introduction, and we will revisit the collections in subsequent chapters.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec22"/>No foreign key</h2></div></div></div><p>Foreign keys are <a id="id150" class="indexterm"/>used in a relational database to maintain referential integrity that defines the relationship between two tables. They are used to enforce relationships in a relational data model such that the data in different but related tables can be joined to answer a query. Cassandra does not have the concept of referential integrity and hence, joins are not allowed either.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec23"/>No join</h2></div></div></div><p>Foreign keys and joins <a id="id151" class="indexterm"/>are the product of normalization in a relational data model. Cassandra has neither foreign keys nor joins. Instead, it encourages and performs best when the data model is denormalized.</p><p>Indeed, denormalization<a id="id152" class="indexterm"/> is not completely disallowed in the relational world, for example, a data warehouse built on a relational database. In practice, denormalization is a solution to the problem of poor performance of highly complex relational queries involving a large number of table joins.</p><div><div><h3 class="title"><a id="note13"/>Note</h3><p>In Cassandra, denormalization is normal.</p></div></div><p>Foreign keys and joins can be avoided in Cassandra with proper data modeling.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec24"/>No sequence</h2></div></div></div><p>In a relational database, sequences<a id="id153" class="indexterm"/> are usually used to generate unique values for a surrogate key. Cassandra has no sequences because it is extremely difficult to implement in a peer-to-peer distributed system. There are however workarounds, which are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using part of the data to generate a unique key</li><li class="listitem" style="list-style-type: disc">Using a UUID</li></ul></div><p>In most cases, the best practice is to select the second workaround.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec25"/>Counter</h2></div></div></div><p>A counter column<a id="id154" class="indexterm"/> is <a id="id155" class="indexterm"/>a special column used to store a number that keeps counting values. Counting can be either increment or decrement and timestamp is not required.</p><p>The counter column should not be used to generate surrogate keys. It is just designed to hold a distributed counter appropriate for distributed counting. Also bear in mind that updating a counter is not idempotent.</p><div><div><h3 class="title"><a id="note14"/>Note</h3><p>
<strong>Idempotent</strong>
</p><p>Idempotent <a id="id156" class="indexterm"/>was originally a term in mathematics. But in computer science, idempotent is used more comprehensively to describe an operation that will produce the same results if executed once or multiple times.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec26"/>Time-To-Live</h2></div></div></div><p>
<strong>Time-To-Live</strong> (<strong>TTL</strong>)<a id="id157" class="indexterm"/> is set on columns only. The unit is in seconds. When set<a id="id158" class="indexterm"/> on a column, it automatically counts down and will then be expired on the server side without any intervention of the client application.</p><p>Typical use cases are for the generation of security token and one-time token, automatic purging of outdated columns, and so on.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec27"/>Secondary index</h2></div></div></div><p>One<a id="id159" class="indexterm"/> important thing you need to remember is that the secondary index in Cassandra is not identical to that in a relational database. The secondary index in Cassandra can be created to query a column that is not a part of the primary key. A column family can have more than one secondary index. Behind the scenes, it is implemented as a separate hidden table which is maintained automatically by Cassandra's internal process.</p><p>The secondary index <a id="id160" class="indexterm"/>does not support collections and cannot be created on the primary key itself. The major difference between a primary key and a secondary index is that the former is a distributed index while the latter is a local index. The primary key is used to determine the node location and so, for a given row key, its node location can be found immediately. However, the secondary index is used just to index data on the local node, and it might not be possible to know immediately the locations of all matched rows without having examined all the nodes in the cluster. Hence, the performance is unpredictable.</p><p>More information on secondary keys will be provided as we go through the later chapters.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Modeling by query</h1></div></div></div><p>In the previous section, we<a id="id161" class="indexterm"/> gained a basic understanding of the differences between a relational database and Cassandra. The most important difference is that a relational database models data by relationships whereas Cassandra models data by query. Now let us start with a simple example to look into what modeling by query means.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec28"/>Relational version</h2></div></div></div><p>The following figure shows a simple<a id="id162" class="indexterm"/> relational data model of a stock quote application:</p><div><img src="img/8884OS_02_06.jpg" alt="Relational version"/><div><p>The relational data model of a stock quote application (Source: Yahoo! Finance)</p></div></div><p>The <code class="literal">stock_symbol</code> table is an entity representing the stock master information such as the symbol of a stock, the description of the stock, and the exchange that the stock is traded. The <code class="literal">stock_ticker</code> table is another entity storing the prices of <code class="literal">open</code>, <code class="literal">high</code>, <code class="literal">low</code>, <code class="literal">close</code>, and the transacted <code class="literal">volume</code> of a stock on a trading day. Obviously the two tables have a relationship based on the <code class="literal">symbol</code> column. It is a well-known one-to-many relationship.</p><p>The following is the <strong>Data Definition Language</strong> (<strong>DDL</strong>)<a id="id163" class="indexterm"/> of the two tables:</p><div><pre class="programlisting">CREATE TABLE stock_symbol (
symbol varchar PRIMARY KEY,
description varchar,
exchange varchar
);

CREATE TABLE stock_ticker (
symbol varchar <strong>references stock_symbol(symbol)</strong>,
tick_date varchar,
open decimal,
high decimal,
low decimal,
close decimal,
volume bigint,
PRIMARY KEY (symbol, tick_date)
);</pre></div><p>Consider the following three cases: first, we want to list out all stocks and their description in all exchanges. The SQL query for this is very simple:</p><div><pre class="programlisting">// Query A
SELECT symbol, description, exchange
FROM stock_symbol;</pre></div><p>Second, if we want to <a id="id164" class="indexterm"/>know all the daily close prices and descriptions of the stocks listed in the <code class="literal">NASDAQ</code> exchange, we can write a SQL query as:</p><div><pre class="programlisting">// Query B
SELECT stock_symbol.symbol, stock_symbol.description,
stock_ticker.tick_date, stock_ticker.close
FROM stock_symbol, stock_ticker
WHERE stock_symbol.symbol = stock_ticker.symbol
AND stock_symbol.exchange = ''NASDAQ'';</pre></div><p>Furthermore, if we want to know all the day close prices and descriptions of the stocks listed in the <code class="literal">NASDAQ</code> exchange on April 24, 2014, we can use the following SQL query:</p><div><pre class="programlisting">// Query C
SELECT stock_symbol.symbol, stock_symbol.description,
stock_ticker.tick_date, stock_ticker.open,
stock_ticker.high, stock_ticker.low, stock_ticker_close,
stock_ticker.volume
FROM stock_symbol, stock_ticker
WHERE stock_symbol.symbol = stock_ticker.symbol
AND stock_symbol.exchange = ''NASDAQ''
AND stock_ticker.tick_date = ''2014-04-24'';</pre></div><p>By virtue of the relational data model, we can simply write different SQL queries to return different results with no changes to the underlying data model at all.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec29"/>Cassandra version</h2></div></div></div><p>Now let us turn to Cassandra. The DDL<a id="id165" class="indexterm"/> statements in the last section can be slightly modified to create column families, or tables, in Cassandra, which are as follows:</p><div><pre class="programlisting">CREATE TABLE stock_symbol (
symbol varchar PRIMARY KEY,
description varchar,
exchange varchar
);

CREATE TABLE stock_ticker (
symbol varchar,
tick_date varchar,
open decimal,
high decimal,
low decimal,
close decimal,
volume bigint,
PRIMARY KEY (symbol, tick_date)
);</pre></div><p>They seem to be correct at first sight.</p><p>As for <code class="literal">Query A</code>, we can query the Cassandra <code class="literal">stock_symbol</code> table exactly the same way:</p><div><pre class="programlisting">// Query A
SELECT symbol, description, exchange
FROM stock_symbol;</pre></div><p>The following figure depicts the logical and physical storage views of the <code class="literal">stock_symbol </code>table:</p><div><img src="img/8884OS_02_07.jpg" alt="Cassandra version"/><div><p>The Cassandra data model for Query A</p></div></div><p>The primary<a id="id166" class="indexterm"/> key of the <code class="literal">stock_symbol</code> table involves only one single column, <code class="literal">symbol</code>, which is also used as the row key and partition key of the column family. We can consider the <code class="literal">stock_symbol</code> table in terms of the SortedMap data structure mentioned in the previous section:</p><div><pre class="programlisting">Map&lt;RowKey, SortedMap&lt;ColumnKey, ColumnValue&gt;&gt;</pre></div><p>The assigned values are as follows:</p><div><pre class="programlisting">RowKey=AAPL
ColumnKey=description
ColumnValue=Apple Inc.
ColumnKey=exchange
ColumnValue=NASDAQ</pre></div><p>So far so good, right?</p><p>However, without foreign keys and joins, how can we obtain the same results for <code class="literal">Query B</code> and <code class="literal">Query C</code> in Cassandra? It indeed highlights that we need another way to do so. The short answer is to use denormalization.</p><p>For <code class="literal">Query B</code>, what we want is all the day close prices and descriptions of the stocks listed in the <code class="literal">NASDAQ</code> exchange. The columns involved are <code class="literal">symbol</code>, <code class="literal">description</code>, <code class="literal">tick_date</code>, <code class="literal">close</code>, and <code class="literal">exchange</code>. The first four columns are obvious, but why do we need the <code class="literal">exchange</code> column? The <code class="literal">exchange</code> column is necessary because it is used as a filter for the query. Another implication is that the <code class="literal">exchange</code> column is required to be the row key, or at least part of the row key.</p><p>Remember two rules:</p><div><ol class="orderedlist arabic"><li class="listitem">A row key is regarded as a partition key to locate the nodes storing that row</li><li class="listitem">A row cannot be split across two nodes</li></ol></div><p>In a distributed <a id="id167" class="indexterm"/>system backed by Cassandra, we should minimize unnecessary network traffic as much as possible. In other words, the lesser the number of nodes the query needs to work with, the better the performance of the data model. We must cater to the cluster topology as well as the physical storage of the data model.</p><p>Therefore we should create a column family for <code class="literal">Query B</code> similar to the previous one:</p><div><pre class="programlisting">// Query B
CREATE TABLE stock_ticker_by_exchange (
exchange varchar,
symbol varchar,
description varchar,
tick_date varchar,
close decimal,
PRIMARY KEY (exchange, symbol, tick_date)
);</pre></div><p>The logical and physical storage views of <code class="literal">stock_ticker_by_exchange</code> are shown as follows:</p><div><img src="img/8884OS_02_08.jpg" alt="Cassandra version"/><div><p>The Cassandra data model for Query B</p></div></div><p>The row key is<a id="id168" class="indexterm"/> the <code class="literal">exchange</code> column. However, this time, it is very strange that the column keys are no longer <code class="literal">symbol</code>, <code class="literal">tick_date</code>, <code class="literal">close</code>, and <code class="literal">description</code>. There are now 12 columns including <code class="literal">APPL:2014-04-24:</code>, <code class="literal">APPL:2014-04-24:close</code>, <code class="literal">APPL:2014-04-24:description</code>, <code class="literal">APPL:2014-04-25:</code>, <code class="literal">APPL:2014-04-25:close</code>, <code class="literal">APPL:2014-04-25:description</code>, <code class="literal">FB:2014-04-24:</code>, <code class="literal">FB:2014-04-24:close</code>, <code class="literal">FB:2014-04-24:description</code>, <code class="literal">FB:2014-04-25:</code>, <code class="literal">FB:2014-04-25:close</code>, and <code class="literal">FB:2014-04-25:description</code>, respectively. Most importantly, the column keys are now dynamic and are able to store data in just a single row. The row of this dynamic usage is called a wide row, in contrast to the row containing static columns of the <code class="literal">stock_symbol</code> table—termed as a skinny row.</p><p>Whether a column family stores a skinny row or a wide row depends on how the primary key is defined.</p><div><div><h3 class="title"><a id="note15"/>Note</h3><p>If the primary key contains only one column, the row is a skinny row.</p><p>If the primary key contains more than one column, it is called a compound primary key and the row is a wide row.</p></div></div><p>In either case, the <a id="id169" class="indexterm"/>first column in the primary key definition is the row key.</p><p>Finally, we come to <code class="literal">Query C</code>. Similarly, we make use of denormalization. <code class="literal">Query C</code> differs from <code class="literal">Query B</code> by an additional date filter on April 24, 2014. You might think of reusing the <code class="literal">stock_ticker_by_exchange</code> table for <code class="literal">Query C</code>. The answer is wrong. Why? The clue is the primary key which is composed of three columns, <code class="literal">exchange</code>, <code class="literal">symbol</code>, and <code class="literal">tick_date</code>, respectively. If you look carefully at the column keys of the <code class="literal">stock_ticker_by_exchange</code> table, you find that the column keys are dynamic as a result of the <code class="literal">symbol</code> and <code class="literal">tick_date</code> columns. Hence, is it possible for Cassandra to determine the column keys without knowing exactly which symbols you want? Negative.</p><p>A suitable column family for <code class="literal">Query C</code> should resemble the following code:</p><div><pre class="programlisting">// Query C
CREATE TABLE stock_ticker_by_exchange_date (
exchange varchar,
symbol varchar,
description varchar,
tick_date varchar,
close decimal,
PRIMARY KEY ((exchange, tick_date), symbol)
);</pre></div><p>This time you should be aware of the definition of the primary key. It is interesting that there is an additional pair of parentheses for the <code class="literal">exchange</code> and <code class="literal">tick_date</code> columns. Let's look at the logical and physical storage views of <code class="literal">stock_ticker_by_exchange_date</code>, as shown in the following figure:</p><div><img src="img/8884OS_02_09.jpg" alt="Cassandra version"/><div><p>The Cassandra data model for Query C</p></div></div><p>You should pay<a id="id170" class="indexterm"/> attention to the number of column keys here. It is only six instead of 12 as in <code class="literal">stock_ticker_by_exchange</code> for <code class="literal">Query B</code>. The column keys are still dynamic according to the <code class="literal">symbol</code> column but the row key is now <code class="literal">NASDAQ:2014-04-24</code> instead of just <code class="literal">NASDAQ</code> in <code class="literal">Query B</code>. Do you remember the previously mentioned additional pair of parentheses? If you define a primary key in that way, you intend to use more than one column to be the row key and the partition key. It is called a composite partition key. For the time being, it is enough for you to know the terminology only. Further information will be given in later chapters.</p><p>Until now, you might have felt dizzy and uncomfortable, especially for those of you having so many years of expertise in the relational data model. I also found the Cassandra data model very difficult to comprehend at the first time. However, you should be aware of the subtle differences between a relational data model and Cassandra data model. You must also be very cautious of the query that you handle. A query is always the starting point of designing a Cassandra data model. As an analogy, a query is a question and the data model is the answer. You merely use the data model to answer the query. It is exactly what modeling by query means.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Data modeling considerations</h1></div></div></div><p>Apart from modeling by <a id="id171" class="indexterm"/>query, we need to bear in mind a few important points when designing a Cassandra data model. We can also consider a few good patterns that will be introduced in this section.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec30"/>Data duplication</h2></div></div></div><p>Denormalization is<a id="id172" class="indexterm"/> an evil in a <a id="id173" class="indexterm"/>relational data model, but not in Cassandra. Indeed, it is a good and common practice. It <a id="id174" class="indexterm"/>is solely based on the fact that Cassandra does not use high-end disk storage subsystem. Cassandra loves commodity-grade hard drives, and hence disk space is cheap. Data duplication as a result of denormalization is by no means a problem anymore; Cassandra welcomes it.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec31"/>Sorting</h2></div></div></div><p>In a relational <a id="id175" class="indexterm"/>database, sorting <a id="id176" class="indexterm"/>can be easily controlled using the <code class="literal">ORDER BY</code> clause in a SQL query. Alternatively, a secondary index can be created to further speed up the sorting operations.</p><p>In Cassandra, however, sorting is by design because you must determine how to compare data for a column family at the time of its creation. The comparator of the column family dictates how the rows are ordered on reads. Additionally, columns are ordered by their column names, also by a comparator.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec32"/>Wide row</h2></div></div></div><p>It is common to use <a id="id177" class="indexterm"/>wide rows for <a id="id178" class="indexterm"/>ordering, grouping and efficient filtering. Besides, you can use skinny rows. All you have to consider is the number of columns the row contains.</p><p>It is worth noting that for a column family storing skinny rows, the column key is repeatedly stored in each column. Although it wastes some storage space, it is not a problem on inexpensive commodity hard disks.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec33"/>Bucketing</h2></div></div></div><p>Even though a <a id="id179" class="indexterm"/>wide row can <a id="id180" class="indexterm"/>accommodate up to 2 billion variable columns, it is still a hard limit that cannot prevent voluminous data from filling up a node. In order to break through the 2 billion column limit, we can use a workaround technique called bucketing to split the data across multiple nodes.</p><p>Bucketing requires the <a id="id181" class="indexterm"/>client application to generate a bucket ID, which is often a random <a id="id182" class="indexterm"/>number. By including the bucket ID into a composite partition key, you can break up and distribute segments of the data to different nodes. However, it should not be abused. Breaking up the data across multiple nodes causes reading operations to consume extra resources to merge and reorder data. Thus, it is expensive and not a favorable method, and therefore should only be a last resort.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec34"/>Valueless column</h2></div></div></div><p>Column keys can store values as<a id="id183" class="indexterm"/> shown in<a id="id184" class="indexterm"/> the <em>Modeling by query</em> section. There is no "Not Null" concept in Cassandra such that column values can store empty values without any problem. Simply storing data in column keys while leaving empty values in the column, known as a valueless column, is sometimes used purposely. It's a common practice with Cassandra.</p><p>One motivation for valueless columns is the sort-by-column-key feature of Cassandra. Nonetheless, there are some limitations and caveats. The maximum size of a column key is 64 KB, in contrast to 2 GB for a column value. Therefore, space in a column key is limited. Furthermore, using timestamp alone as a column key can result in timestamp collision.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec35"/>Time-series data</h2></div></div></div><p>What is <a id="id185" class="indexterm"/>time-series data? It is<a id="id186" class="indexterm"/> anything that varies on a temporal basis such as processor utilization, sensor data, clickstream, and stock ticker. The stock quote data model introduced earlier is one such example. Cassandra is a perfect fit for storing time-series data. Why? Because one row can hold as many as 2 billion variable columns. It is a single layout on disk, based on the storage model. Therefore, Cassandra can handle voluminous time-series data in a blazing fast fashion. TTL is another excellent feature to simplify data housekeeping.</p><p>In the second half of this book, a complete stock quote technical analysis application will be developed to further explain the details of using Cassandra to handle time-series data.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Cassandra Query Language</h1></div></div></div><p>It is quite common for<a id="id187" class="indexterm"/> other authors to start introducing the Cassandra data model from CQL. I use a different approach in this chapter. I try to avoid diving too deep in CQL before we have a firm understanding of how Cassandra handles its physical storage.</p><p>The syntax of CQL is designed to be very similar to that of SQL. This intent is good for someone who is used to writing SQL statements in the relational world, to migrate to Cassandra. However, because of the high degree of similarity between CQL and SQL, it is even more difficult for us to throw away the relational mindsets if CQL is used to explain how to model data in Cassandra. It might cause more confusion in the end. I prefer the approach of a microscopic view of how the data model relates to the physical storage. By doing so, you can grasp the key points more quickly and understand the inner working mechanism more clearly. CQL is covered extensively in the next chapter.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Summary</h1></div></div></div><p>In this chapter, we looked at the basics of a Cassandra data model and are now familiar with the column, row, column family, keyspace, counter, and other related terms. A comparison of the main differences between a relational data model and the Cassandra data model was also given to explain the concept of modeling by query that may seem shocking and counterintuitive at first sight. Then a few important considerations on data modeling and typical usage patterns were introduced. Finally, the reason why the introduction of CQL is deliberately postponed was expressed.</p><p>This chapter is only the first part on Cassandra data modeling. In the next chapter, we will continue the second part of the tour, Cassandra Query Language.</p></div></body></html>