- en: Geoprocessing with Geodatabases
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地理数据库的地理处理
- en: In [Chapter 3](42c1ea5a-7372-4688-bb7f-fc3822248562.xhtml), *Introduction to
    Geospatial Databases*, you learned how to install PostGIS, create a table, add
    data, and perform basic spatial queries. In this chapter, you will learn how to
    work with geospatial databases to answer questions and make maps. This chapter
    will have you load crime data into tables. Once you have populated your geodatabase
    with real-world data, you will learn how to perform common crime analysis tasks.
    You will learn how to map queries, query by date ranges, and perform basic geoprocessing
    tasks such as buffers, point in polygon, and nearest neighbor. You will learn
    how to add widgets to your Jupyter Notebooks to allow queries to be interactive.
    Lastly, you will learn how to use Python to create charts from your geospatial
    queries. As a crime analyst, you will make maps, but not all GIS-related tasks
    are map-based. Analysts use GIS data to answer questions and create reports. Executives
    are often more familiar with charts and graphs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](42c1ea5a-7372-4688-bb7f-fc3822248562.xhtml)《地理空间数据库简介》中，你学习了如何安装PostGIS、创建表、添加数据以及执行基本空间查询。在本章中，你将学习如何使用地理空间数据库来回答问题和制作地图。本章将指导你将犯罪数据加载到表中。一旦你的地理数据库用真实世界的数据填充，你将学习如何执行常见的犯罪分析任务。你将学习如何映射查询、按日期范围查询以及执行基本地理处理任务，如缓冲区、点在多边形内和最近邻。你将学习如何将小部件添加到你的Jupyter笔记本中，以使查询变得交互式。最后，你将学习如何使用Python从你的地理空间查询中创建图表。作为一名犯罪分析师，你将制作地图，但并非所有GIS相关任务都是基于地图的。分析师使用GIS数据来回答问题和创建报告。高管通常更熟悉图表和图形。
- en: 'In this chapter, you will learn:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习：
- en: How to use spatial queries to perform geoprocessing tasks
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用空间查询来执行地理处理任务
- en: How to add triggers to your tables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何向你的表格添加触发器
- en: How to map your geospatial query results
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何映射你的地理空间查询结果
- en: How to graph geospatial queries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何图形化地理空间查询
- en: How to use Jupyter to interact with and connect widgets to your queries
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Jupyter与查询交互并连接小部件
- en: A crime dashboard
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 犯罪仪表板
- en: To build an interactive **crime dashboard**, you will need to collect data to
    build a database. Then, you will query the data and add widgets to allow users
    to modify the queries without needing to code. Lastly, you will graph and map
    the query results.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个交互式**犯罪仪表板**，你需要收集数据来构建数据库。然后，你将查询数据并添加小部件，使用户能够修改查询而不需要编写代码。最后，你将图形化和地图化查询结果。
- en: Building a crime database
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建犯罪数据库
- en: To build the components for a crime dashboard, we will use the City of Albuquerque's
    open data. Albuquerque has datasets for crime incidents, as well as area commands
    and `beats`. By combining the areas with `incidents`, you will be able to report
    on two geographic areas. You could then extend the analysis using neighborhood
    associations or any other boundary—Census blocks, groups, or tracts, and get demographic
    information as well.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建犯罪仪表板的组件，我们将使用阿尔伯克基市的开放数据。阿尔伯克基市有犯罪事件、区域指挥和`beat`的数据集。通过将区域与`事件`结合，你将能够报告两个地理区域。然后，你可以通过使用邻里协会或任何其他边界——人口普查区块、群体或区域，来扩展分析并获取人口信息。
- en: You can find links to the data on the main open data site located at: [http://www.cabq.gov/abq-data/](http://www.cabq.gov/abq-data/).
    Scroll to the bottom of the page and look for the Safety Data Sets heading.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在位于[http://www.cabq.gov/abq-data/](http://www.cabq.gov/abq-data/)的主开放数据网站上找到数据链接。滚动到页面底部并查找“安全数据集”标题。
- en: Creating the tables
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建表格
- en: 'We will need to create three tables to hold the crime data. We need a table
    for:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建三个表格来存储犯罪数据。我们需要一个表格来：
- en: Area commands
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 区域指挥
- en: Beats
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: beat
- en: Incidents
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事件
- en: 'To create the tables, we need to import the required libraries:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建表格，我们需要导入所需的库：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The precious code imports `psycopg2` for connecting to PostGIS, `requests` to
    make the call to the service so you can grab the data, `Point`, `Polygon`, and
    `MultiPolygon` from `shapely.geometry` to make converting the `GeoJSON` to objects
    easier, and `datetime` because the `incidents` have a `date` field.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 程序代码导入`psycopg2`以连接到PostGIS，`requests`用于调用服务以便你可以获取数据，从`shapely.geometry`中的`Point`、`Polygon`和`MultiPolygon`以使将`GeoJSON`转换为对象更容易，以及`datetime`因为事件有`日期`字段。
- en: In [Chapter 3](42c1ea5a-7372-4688-bb7f-fc3822248562.xhtml), *Introduction to
    Geospatial Databases*, you created a database named `pythonspatial` with a user
    called `postgres`. We will create the tables in that database. To populate the
    tables, we will copy some of the fields from the service. The layer page of the
    service has a list of fields at the bottom.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 3 章](42c1ea5a-7372-4688-bb7f-fc3822248562.xhtml)，*地理空间数据库简介* 中，你创建了一个名为
    `pythonspatial` 的数据库，用户名为 `postgres`。我们将在该数据库中创建表。为了填充表，我们将从服务中复制一些字段。服务的层页面底部有一个字段列表。
- en: 'The URL to the layer is linked to the root page of the service or the layer
    number. For incidents, the URL to the layer is: [http://coagisweb.cabq.gov/arcgis/rest/services/public/APD_Incidents/MapServer/0](http://coagisweb.cabq.gov/arcgis/rest/services/public/APD_Incidents/MapServer/0).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 层的 URL 链接到服务的根页面或层编号。对于事件，层的 URL 为：[http://coagisweb.cabq.gov/arcgis/rest/services/public/APD_Incidents/MapServer/0](http://coagisweb.cabq.gov/arcgis/rest/services/public/APD_Incidents/MapServer/0)。
- en: 'Each of the fields has a type and length for the `incidents` layer as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 每个字段都有 `incidents` 层的类型和长度，如下所示：
- en: '`OBJECTID` (type: esriFieldTypeOID, alias: Object_ID)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OBJECTID`（类型：esriFieldTypeOID，别名：对象 ID）'
- en: '`Shape` (type: esriFieldTypeGeometry, alias: Geometry)'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Shape`（类型：esriFieldTypeGeometry，别名：几何形状）'
- en: '`CV_BLOCK_ADD` (type: esriFieldTypeString, alias: Location, length: 72)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CV_BLOCK_ADD`（类型：esriFieldTypeString，别名：位置，长度：72）'
- en: '`CVINC_TYPE` (type: esriFieldTypeString, alias: Description, length: 255)'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CVINC_TYPE`（类型：esriFieldTypeString，别名：描述，长度：255）'
- en: '`date` (type: esriFieldTypeDate, alias: Date, length: 8)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`date`（类型：esriFieldTypeDate，别名：日期，长度：8）'
- en: '**Supported operations**: Query, Generate Renderer, Return updates.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**支持的操作**：查询、生成渲染器、返回更新。'
- en: 'Create the tables using the following code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码创建表：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The previous code starts by creating the connection and getting the `cursor`.
    It then creates the `areacommand` table, with a field for the `name` and a `GEOMETRY`
    field. In the **ArcServer** service, the area command field has a length of `20`,
    so the code created a field called `name` as a `VARCHAR(20)`. The next two lines
    create the tables for `beats` and `incidents`, and lastly, the code commits, making
    the changes permanent.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码首先创建连接并获取 `cursor`。然后创建 `areacommand` 表，包含一个 `name` 字段和一个 `GEOMETRY` 字段。在
    **ArcServer** 服务中，区域命令字段长度为 `20`，因此代码创建了一个名为 `name` 的字段作为 `VARCHAR(20)`。接下来的两行创建了
    `beats` 和 `incidents` 表，最后代码提交，使更改永久生效。
- en: Populating the data
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 填充数据
- en: 'With the tables in place, we need to grab the data and populate them. The following
    code will grab the area commands and insert them into our table:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在表就绪后，我们需要抓取数据并填充它们。以下代码将抓取区域命令并将其插入到我们的表中：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The previous code uses `requests` to query the URL passing parameters. The parameters
    just grab all the data (`1=1`), and grab all the fields (`*`) in reference `4326`
    and as `json`. The results are loaded in the variable `data` using the `json()`
    method.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用 `requests` 查询带有参数的 URL。参数只是抓取所有数据（`1=1`），并且抓取参考 `4326` 中的所有字段（`*`）以及作为
    `json`。结果使用 `json()` 方法加载到变量 `data` 中。
- en: 'To learn about the** Environmental Systems Research Institute** (**ESRI**)
    ArcServer query parameters, see the API reference here: [http://coagisweb.cabq.gov/arcgis/sdk/rest/index.html#/Query_Map_Service_Layer/02ss0000000r000000/](http://coagisweb.cabq.gov/arcgis/sdk/rest/index.html#/Query_Map_Service_Layer/02ss0000000r000000/)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解**环境系统研究协会**（**ESRI**） ArcServer 查询参数，请参阅以下 API 参考：[http://coagisweb.cabq.gov/arcgis/sdk/rest/index.html#/Query_Map_Service_Layer/02ss0000000r000000/](http://coagisweb.cabq.gov/arcgis/sdk/rest/index.html#/Query_Map_Service_Layer/02ss0000000r000000/)
- en: The next block of code is the `for` loop that will insert the data. The service
    returns `json`, and the data we need is stored in the features array. For each
    area command (`acmd`) in the `features` array (`data['features']`), we will grab
    the `name` and `geometry`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下一段代码是 `for` 循环，它将插入数据。服务返回 `json`，我们需要的数据存储在 `features` 数组中。对于 `features` 数组（`data['features']`）中的每个区域命令（`acmd`），我们将抓取
    `name` 和 `geometry`。
- en: The `geometry` is comprised of multiple `rings`—in this case, because our data
    is comprised of polygons. We need to loop through the `rings`. To do so, the code
    has another `for` loop that iterates through each `ring`, creates a polygon, and
    adds it to `polys[]`. When all the `rings` are collected as polygons, the code
    creates a single `MultiPolygon` with the name of the area command and inserts
    it into the table using `cursor.execute()`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`geometry`由多个`rings`组成——在本例中，因为我们的数据由多边形组成。我们需要遍历`rings`。为了做到这一点，代码中有一个另一个`for`循环，它遍历每个`ring`，创建一个多边形，并将其添加到`polys[]`中。当所有`rings`都被收集为多边形时，代码创建一个名为区域命令的单个`MultiPolygon`，并使用`cursor.execute()`将其插入到表中。'
- en: 'The SQL is the basic insert command but uses a parameterized query and `ST_GeometryFromText()`.
    Do not get distracted by those additions. Build the query by using the base query
    as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: SQL是基本的插入命令，但使用了参数化查询和`ST_GeometryFromText()`。不要被这些附加功能分散注意力。通过以下基本查询构建查询：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To pass the values, the code uses `.format()`. It passes the string name and
    uses Shapely to convert the coordinates to WKT (`p.wkt`).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要传递值，代码使用了`.format()`。它传递了字符串名称，并使用Shapely将坐标转换为WKT（`p.wkt`）。
- en: 'You will need to do the same thing for the `beats` table:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要对`beats`表做同样的事情：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The previous code is the same as the code for area commands, only passing additional
    fields using multiple placeholders (`'{}'`).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码与面积命令的代码相同，只是通过多个占位符（`'{}'`）传递了额外的字段。
- en: 'Lastly, we need to add the `incidents`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要添加`incidents`：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The previous code grabs the data using `requests`. It then iterates through
    the `features`. This code block has some error checking because there are `features`
    with blank dates and some with no coordinates. The code passes if there is no
    `date` and uses a `try`, with the `catch` block accepting a `KeyError`, which
    will catch the missing coordinates.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用`requests`获取数据。然后它遍历`features`。这个代码块有一些错误检查，因为有一些`features`有空白日期，还有一些没有坐标。如果不存在`date`，代码会通过，并使用`try`，`catch`块接受一个`KeyError`，这将捕获缺失的坐标。
- en: Now that the data is loaded into the tables, we can start to query the data
    and present it in maps and charts.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数据已经加载到表中，我们可以开始查询数据并在地图和图表中展示它。
- en: Mapping queries
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射查询
- en: In [Chapter 3](42c1ea5a-7372-4688-bb7f-fc3822248562.xhtml), *Introduction to
    Geospatial Databases*, you queried the database and got text back. The `geometry`
    came back as **well-known text** (**WKT**). These are the results we asked for,
    but I cannot visualize geographic data by reading a list of coordinates. I need
    to see it on a map. In this section, you will use `ipyleaflet` and Jupyter to
    map the results of your queries.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](42c1ea5a-7372-4688-bb7f-fc3822248562.xhtml)，《地理空间数据库简介》中，你查询了数据库并返回了文本。`geometry`以**已知文本**（WKT）的形式返回。这是我们要求的结果，但我不能通过阅读坐标列表来可视化地理数据。我需要看到它在地图上。在本节中，你将使用`ipyleaflet`和Jupyter来将查询结果映射到地图上。
- en: 'To map the queries in Jupyter, you need to install `ipyleaflet`. You can do
    this using `pip` at your OS''s command prompt:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Jupyter中映射查询，你需要安装`ipyleaflet`。你可以在操作系统的命令提示符中使用`pip`来完成此操作：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then you may need to enable the extension, depending on your environment. At
    the command prompt, type:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可能需要根据你的环境启用扩展。在命令提示符中输入：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For the code, and examples of using `ipyleaflet`, you can view the GitHub repository
    at: [https://github.com/ellisonbg/ipyleaflet](https://github.com/ellisonbg/ipyleaflet)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于代码和`ipyleaflet`的使用示例，你可以在GitHub仓库中查看：[https://github.com/ellisonbg/ipyleaflet](https://github.com/ellisonbg/ipyleaflet)
- en: 'If you receive an error in your mapping, you may need to enable the `widgetsnbextension`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在映射过程中收到错误，你可能需要启用`widgetsnbextension`：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you have Jupyter running, you will need to restart it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在运行Jupyter，你需要重新启动它。
- en: 'With `ipyleaflet` installed and enabled, you can map your queries:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 安装并启用`ipyleaflet`后，你可以将查询映射到地图上：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The previous code imports the libraries we need to query and map the data.
    Let''s make the `connection` and get the `cursor`, as shown in the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码导入了我们需要查询和映射数据的库。让我们按照以下代码建立`connection`并获取`cursor`：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In [Chapter 3](42c1ea5a-7372-4688-bb7f-fc3822248562.xhtml), *Introduction to
    Geospatial Databases*, the queries all used `ST_AsText()` to return `geometry`.
    Now that we will map the results, it will be easier if we have them returned as
    `GeoJSON`. In the following code, you will use `ST_AsGeoJSON()` to get the `geometry`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](42c1ea5a-7372-4688-bb7f-fc3822248562.xhtml)，《地理空间数据库简介》中，所有的查询都使用了`ST_AsText()`来返回`geometry`。现在我们将映射结果，如果我们将它们作为`GeoJSON`返回，将会更容易。在下面的代码中，你将使用`ST_AsGeoJSON()`来获取`geometry`：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The previous query grabs all the records in the `areacommand` table, with their
    `name` and `geometry` as `GeoJSON`, then prints the first record (`c[0]`). The
    result is as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的查询获取了`areacommand`表中的所有记录，包括它们的`name`和`geometry`作为`GeoJSON`，然后打印第一条记录（`c[0]`）。结果如下：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`ST_AsText` and `ST_AsGeoJSON` are two of the 17 ways to get `geometry` out
    of PostGIS. For a full list of available return types, see the PostGIS reference
    at: [https://postgis.net/docs/reference.html#Geometry_Accessors](https://postgis.net/docs/reference.html#Geometry_Accessors)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`ST_AsText`和`ST_AsGeoJSON`是从PostGIS中获取`geometry`的17种方法中的两种。有关可用返回类型的完整列表，请参阅PostGIS参考文档：[https://postgis.net/docs/reference.html#Geometry_Accessors](https://postgis.net/docs/reference.html#Geometry_Accessors)'
- en: 'Now that you have some `GeoJSON`, it is time to create a map to display it.
    To make the leaflet map, use the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了一些`GeoJSON`，是时候创建一个地图来显示它了。为了创建leaflet地图，使用以下代码：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The previous code defines the `center` of the map which, for Albuquerque, I
    always use the intersections of I-25 and I-40\. This intersection splits the city
    into quadrants. The code then defines the `zoom` level—the higher the number,
    the closer the `zoom`. Lastly, it prints the map.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码定义了地图的`center`，对于阿尔伯克基，我总是使用I-25和I-40的交汇点。这个交汇点将城市分为四个象限。然后代码定义了`zoom`级别——数字越高，缩放越近。最后，它打印了地图。
- en: You will have a blank basemap with `OpenStreetMap` tiles. In Jupyter, when you
    add data to the map, you can scroll back to the original print of the map to see
    the data; you do not need to reprint the map every time.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到一个带有`OpenStreetMap`瓦片的空白底图。在Jupyter中，当你向地图添加数据时，你可以滚动回地图的原始打印版以查看数据；你不需要每次都重新打印地图。
- en: 'The `GeoJSON` of the area commands is stored in variable `c`. For every item
    `c[x]`, the `GeoJSON` is in position `1` `(c[x][1]`). The following code will
    iterate through `c` and add the `GeoJSON` to the map:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 区域命令的`GeoJSON`存储在变量`c`中。对于每个项目`c[x]`，`GeoJSON`位于位置`1`（`c[x][1]`）。以下代码将遍历`c`并将`GeoJSON`添加到地图中：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The previous code assigns the `GeoJSON` to a layer using `json.loads()`. This
    will make the returned `GeoJSON` string a dictionary in Python. Next, the code
    calls the `ipyleaflet GeoJSON()` method on the layer, and passes it to the variable
    `layergeojson`. Finally, `add_layer()` is called on the map and passes `layergeojson`.
    There are other ways to draw maps in Jupyter; for example, you could plot them
    using Matplotlib, Plotly, or Bokeh. If you come from web mapping, you are probably
    already familiar with the Leaflet JavaScript library, which will make using `ipyleaflet`
    familiar. Also, `ipyleaflet` loads a basemap and provides interactivity.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用`json.loads()`将`GeoJSON`分配给一个图层。这将使返回的`GeoJSON`字符串在Python中成为一个字典。接下来，代码在图层上调用`ipyleaflet
    GeoJSON()`方法，并将其传递给变量`layergeojson`。最后，在地图上调用`add_layer()`并将`layergeojson`传递过去。在Jupyter中还有其他绘制地图的方法；例如，你可以使用Matplotlib、Plotly或Bokeh来绘制它们。如果你来自网络地图，你可能已经熟悉Leaflet
    JavaScript库，这将使使用`ipyleaflet`变得熟悉。此外，`ipyleaflet`加载底图并提供交互性。
- en: 'If you scroll up to the map, you should see the screenshot as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你滚动到地图上，你应该看到以下截图：
- en: '![](img/fb3cfccb-7d9a-438e-a919-5461df1c5137.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fb3cfccb-7d9a-438e-a919-5461df1c5137.jpg)'
- en: 'Changing the SQL query in `cursor.execute()`, you can map the `beats`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`cursor.execute()`中更改SQL查询，你可以映射`beats`：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You should see the `beats` drawn as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到`beats`被绘制如下：
- en: '![](img/e89910fa-5868-48ea-8593-74ee198937a5.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e89910fa-5868-48ea-8593-74ee198937a5.png)'
- en: You can do the same for `incidents`, but we will hold on to that for now, because
    there are almost 30,000 `incidents` in the data set and it would overwhelm our
    map. To map `incidents`, we will use spatial queries to limit our selection.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为`incidents`做同样的操作，但我们现在先保留这个，因为数据集中有近30,000个`incidents`，这会使得我们的地图显得过于拥挤。为了在地图上显示`incidents`，我们将使用空间查询来限制我们的选择。
- en: Incidents by date
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按日期统计事件
- en: 'One of the ways you can limit the results of an incident query is by `date`.
    Using the Python `datetime` library, you can specify a `date`, then query `incidents`
    on that `date`, and get the `geometry` of the results as `GeoJSON` and add it
    to your map:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 限制事件查询结果的一种方法是通过`date`。使用Python的`datetime`库，你可以指定一个`date`，然后查询该日期的`incidents`，并将结果的`geometry`作为`GeoJSON`添加到你的地图中：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The previous code specifies a `date` (YYYYMD) of August 1, 2017\. It queries
    the `incidents` table we're using, where `date = d` and returns the `geometry`
    as `GeoJSON`. It then uses the `for` loop you used for area commands, and `beats`
    to map the `incidents`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码指定了一个日期（YYYYMD）为 2017 年 8 月 1 日。它查询我们正在使用的 `incidents` 表，其中 `date = d`
    并将 `geometry` 作为 `GeoJSON` 返回。然后，它使用您用于区域命令的 `for` 循环和 `beats` 来映射 `incidents`。
- en: When you create a map in a Jupyter Notebook, further blocks of code will modify
    that map. You may need to scroll back up to your map to see the changes.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在 Jupyter Notebook 中创建地图时，进一步的代码块将修改该地图。您可能需要向上滚动以查看地图以查看更改。
- en: 'The map you created earlier will now look like the screenshot as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您创建的地图现在将看起来像下面的截图：
- en: '![](img/e3a40684-3088-4091-8c8d-f01267967508.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e3a40684-3088-4091-8c8d-f01267967508.png)'
- en: 'Besides specifying a specific `date`, you could get all the `incidents` where
    the `date` was greater than a specific day:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 除了指定一个特定的 `date`，您还可以获取所有 `date` 大于特定日期的 `incidents`：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Or, you could query dates at an `interval` earlier than today and now:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以查询早于今天的 `interval` 日期：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The previous code uses the `NOW()` method and a `10 day` interval. By specifying
    `>=`, you will get all the crimes that are 10 days old, and newer from the current
    day. I wrote this on November 24, 2017, so the results will be all `incidents`
    from November 14^(th) until today.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用 `NOW()` 方法和一个 `10 天` 间隔。通过指定 `>=`，您将获得所有 10 天前以及更近期的犯罪。我在 2017 年 11
    月 24 日写了这篇文章，所以结果将是 11 月 14 日（第 14 天）直到今天的所有 `incidents`。
- en: Incidents in a polygon
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多边形内的 `incidents`
- en: 'Our crime database has a polygon area—area commands and `beats`—as well as
    incident points. To build a crime dashboard, we want to be able to map `incidents`
    within a specific area command or `beat`. We can do that by using `JOIN` and `ST_Intersects`.
    The following code shows you how:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的犯罪数据库有一个多边形区域——区域命令和 `beats`——以及事件点。为了构建犯罪仪表板，我们希望能够映射特定区域命令或 `beat` 内的 `incidents`。我们可以通过使用
    `JOIN` 和 `ST_Intersects` 来实现这一点。以下代码显示了如何操作：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The previous code selects the `geometry` from `incidents` as `GeoJSON` (`ST_AsGeoJSON(i.geom)`
    from `incidents`), where the incident `ST_Intersects` the polygon area command,
    specifically where the name of the area command is `FOOTHILLS`. The code is joining
    the incident and area command tables where the intersection is true. The code
    limits the results by selecting only the last 10 days of crimes.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码从 `incidents` 中选择 `geometry` 作为 `GeoJSON` (`ST_AsGeoJSON(i.geom)` 来自 `incidents`)，其中事件
    `ST_Intersects` 多边形区域命令，具体来说，区域命令的名称是 `FOOTHILLS`。代码通过将事件和区域命令表连接起来，其中交集为真。代码通过仅选择过去
    10 天的犯罪来限制结果。
- en: 'The code then iterates through the results and maps them as in the previous
    examples. You should see the screenshot as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 代码随后遍历结果并将它们映射，您应该看到下面的截图：
- en: '![](img/7d335f59-7618-4ed3-804c-5a466a398938.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d335f59-7618-4ed3-804c-5a466a398938.png)'
- en: The preceding screenshot overlays the `incidents` on the `Foothills` area command.
    Notice all the `incidents` are within the polygon.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图将 `incidents` 展示在 `Foothills` 区域命令上。注意所有 `incidents` 都在多边形内。
- en: 'You can do the same thing for specific `beats` by changing the SQL query. The
    following code will map specific `beats`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过更改 SQL 查询来为特定的 `beats` 执行相同操作。以下代码将映射特定的 `beats`：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The previous code uses an array of the `beats.beat` field. In Python, the array
    is `[]`, but in the SQL statement, use parentheses. The results are the specified
    `beats`. Then, the code maps them.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用 `beats.beat` 字段的数组。在 Python 中，数组是 `[]`，但在 SQL 语句中，使用括号。结果是指定的 `beats`。然后，代码将它们映射。
- en: 'Using the same specified `beats`, we can select the `incidents` using a join
    on `ST_Intersects()` with the `beats`, and mapping the `incidents` as shown in
    the code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的指定 `beats`，我们可以通过在 `ST_Intersects()` 上与 `beats` 进行连接来选择 `incidents`，并映射
    `incidents`，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The previous code passes the `beats` array and filters again by the last 10
    days. It then maps the `incidents`, as shown in the following screenshot:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码传递了 `beats` 数组，并通过最后 10 天再次进行筛选。然后，它映射了 `incidents`，如下面的截图所示：
- en: '![](img/2ec522a6-b36a-4490-b562-50d31cca930d.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ec522a6-b36a-4490-b562-50d31cca930d.png)'
- en: Buffers
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓冲区
- en: You have mapped data from tables, but now you will map the results of a geoprocessing
    task—buffer.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经从表中映射了数据，但现在您将映射地理处理任务的输出结果——缓冲区。
- en: 'To code a buffer example, we must first create a point. The following code
    will do that for us:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写一个缓冲区示例的代码，我们首先必须创建一个点。以下代码将为我们完成这项工作：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The previous code creates a point using Shapely. It then converts it to `GeoJSON`
    using `shapely.geometry.mapping()`. The next two lines allow us to display it
    on the map.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用 Shapely 创建了一个点。然后使用 `shapely.geometry.mapping()` 将其转换为 `GeoJSON`。接下来的两行代码允许我们在地图上显示它。
- en: 'PostGIS allows you to send data to the database and get data back, none of
    which has to be in a table. For example, examine the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: PostGIS 允许您将数据发送到数据库并获取数据，无需任何数据都在表中。例如，检查以下代码：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The previous code uses `ST_Buffer()` to get a polygon back from PostGIS. `ST_Buffer()`
    can take a point geography and a radius in meters to return the polygon. The code
    wraps the result in `ST_AsGeoJSON` so we can map it. In this example, the result
    set is a single item, so we don't need the `for` loop. The code loads the result
    `buff[0][0]`and maps it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用 `ST_Buffer()` 从 PostGIS 获取一个多边形。`ST_Buffer()` 可以接受一个点地理和半径（以米为单位）来返回多边形。代码将结果包装在
    `ST_AsGeoJSON` 中，以便我们可以将其映射。在这个例子中，结果集是一个单独的项目，所以我们不需要 `for` 循环。代码加载结果 `buff[0][0]`
    并将其映射。
- en: 'The result of the previous code is shown in the following screenshot:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了之前代码的结果：
- en: '![](img/9905bae8-76cc-4352-8b76-f5585ab4033f.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9905bae8-76cc-4352-8b76-f5585ab4033f.png)'
- en: 'We now have a polygon that we can use to select `incidents` from. The following
    code will execute the same query as earlier, but instead of `ST_AsGeoJSON`, we
    will use `ST_AsText`. We are not mapping the polygon, but using it as a parameter
    for a point in the polygon operation:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个多边形，我们可以用它来选择 `incidents`。以下代码将执行与之前相同的查询，但我们将使用 `ST_AsText` 而不是 `ST_AsGeoJSON`。我们不是映射多边形，而是将其用作多边形操作中点的参数：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the previous code, the query result is passed to a `shapely` polygon named
    `b` using `loads()`. Now, you can pass that polygon to another query using `ST_Intersects()`,
    as in the following code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，查询结果通过 `loads()` 传递给名为 `b` 的 `shapely` 多边形。现在，您可以将该多边形传递给另一个查询，使用 `ST_Intersects()`，如下所示：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The previous code selects the `incidents` as `GeoJSON`, where they intersect
    the `buffer` (`b.wkt`), and where they are within the last 10 days. The results
    are mapped. The following map shows the output of the previous code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码选择与 `buffer` (`b.wkt`) 相交的 `incidents` 作为 `GeoJSON`，并且它们在过去的 10 天内。结果被映射。以下地图显示了之前代码的输出：
- en: '![](img/72a6e62b-94ac-4701-9580-fe7e703099f9.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/72a6e62b-94ac-4701-9580-fe7e703099f9.png)'
- en: Nearest neighbor
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最近邻
- en: Using a `buffer`, you can get all the `incidents` within a specified radius
    of the point of interest. But what if you only want the 5, 10, or 15 closest incidents?
    To do that, you can use the `<->` operator or k-nearest neighbor.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `buffer`，您可以获取到兴趣点指定半径内的所有 `incidents`。但如果你只想获取 5、10 或 15 个最近的 `incidents`
    呢？为了做到这一点，您可以使用 `<->` 操作符或 k-最近邻算法。
- en: 'You can use the following code to select the `15` closest points to a specified
    point, `p`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下代码选择到指定点 `p` 的 `15` 个最近点：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The previous code creates a point using Shapely, and uses it in the SQL query.
    The query selects the incident `geometry` as `GeoJSON`, and then calculates the
    distance of each incident from the specified point. The `ORDER BY` clause, `<->`
    operator, and limit clause make sure that we get the `15` nearest points in order
    of closeness.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用 Shapely 创建了一个点，并在 SQL 查询中使用它。查询选择事故的 `geometry` 作为 `GeoJSON`，然后计算每个事故与指定点的距离。`ORDER
    BY` 子句、`<->` 操作符和限制子句确保我们按接近程度顺序获取最近的 `15` 个点。
- en: 'The last block of code is our code for adding the results to the map. The results
    are shown in the following screenshot. The point in the center of the screenshot
    is the specified point:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一块代码是我们添加结果到地图的代码。以下截图显示了结果。截图中心的是指定的点：
- en: '![](img/bbf19a2f-97a6-4d7a-a3b2-304570e2c7d2.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bbf19a2f-97a6-4d7a-a3b2-304570e2c7d2.png)'
- en: Now that you know how to map the results of your spatial queries, let's add
    interactive widgets to modify the queries and change the map without writing new
    code.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经知道了如何映射空间查询的结果，让我们添加交互式小部件来修改查询并更改地图，而无需编写新代码。
- en: Interactive widgets
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交互式小部件
- en: 'At the beginning of the chapter, you learned how to query and map `incidents`
    based on a `date`. In Jupyter, you can use interactive widgets to change values.
    The code will help us in how you can use `ipywidgets` to import `interact`, which
    will allow you to insert a `DatePicker` so that you can select a `date` to interact
    with the Notebook:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开头，您学习了如何根据 `date` 查询和映射 `incidents`。在 Jupyter 中，您可以使用交互式小部件更改值。代码将帮助我们了解如何使用
    `ipywidgets` 的 `interact` 来插入 `DatePicker`，这样您就可以选择一个 `date` 与笔记本进行交互：
- en: '![](img/21e217ae-4e75-4102-a6f2-947fe5623420.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/21e217ae-4e75-4102-a6f2-947fe5623420.png)'
- en: The previous code imports `interact` and the `DatePicker` widget. At its simplest,
    the previous screenshot shows a decorator and function to allow interactively
    selecting a `date` and displaying it as a string.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码导入了 `interact` 和 `DatePicker` 小部件。在最简单的情况下，之前的截图显示了一个装饰器和函数，允许交互式选择一个 `date`
    并将其显示为字符串。
- en: When the `DatePicker` changes, `x` (the `DatePicker`) is sent to the function
    `theDate(x)`, and `x` is printed as a string. The actual return value is `datetime.date`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `DatePicker` 发生变化时，`x`（`DatePicker`）被发送到函数 `theDate(x)`，并且 `x` 被打印为字符串。实际的返回值是
    `datetime.date`。
- en: 'Using the `DatePicker` widget, you can pass a `date` value to an SQL query,
    and then map the results. When the `DatePicker` changes, you can erase the map
    and then display the new results. The following code will show you how:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `DatePicker` 小部件，您可以将 `date` 值传递给 SQL 查询，然后映射结果。当 `DatePicker` 发生变化时，您可以清除地图，然后显示新的结果。以下代码将向您展示如何操作：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The previous code creates an interactive `DatePicker` widget. The code has an
    `if...else` statement because, on the first pass, `x` will be none. The `DatePicker`
    is not selected, so we `pass` on the first go around.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码创建了一个交互式 `DatePicker` 小部件。代码中有一个 `if...else` 语句，因为第一次遍历时，`x` 将是 `none`。`DatePicker`
    未被选中，所以我们第一次遍历时 `pass`。
- en: Next, the code grabs all the layers on the map, and removes them using `map.remove_layer()`,
    starting at the second (`[1:]`) layer. Why the second layer? Because the first
    layer on the map is the `TileLayer`—the basemap. We want that to stay, and only
    remove the markers that were added from the SQL query.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，代码获取地图上的所有图层，并使用 `map.remove_layer()` 删除它们，从第二个（`[1:]`）图层开始。为什么是第二个图层？因为地图上的第一层是
    `TileLayer`——基础地图。我们希望它保持原样，只删除从 SQL 查询中添加的标记。
- en: The code then strips the hyphens from the `date` string and converts it into
    a `datetime`. Once it is a `datetime`, you can pass it to the SQL query.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 代码随后从 `date` 字符串中删除连字符，并将其转换为 `datetime`。一旦它成为 `datetime`，就可以将其传递给 SQL 查询。
- en: The next code block is the same block you have used throughout this chapter
    to add the query results to the map.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码块与您在本章中用于将查询结果添加到地图上的代码块相同。
- en: 'Selecting a `date` of November 2, 2017, is shown in the following screenshot:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了选择 2017 年 11 月 2 日的 `date`：
- en: '![](img/ed83f731-e64d-49ca-ab8a-ca09926047fc.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ed83f731-e64d-49ca-ab8a-ca09926047fc.png)'
- en: 'And when selecting November 8, 2017, the map is redrawn and shown in the following
    screenshot:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择 2017 年 11 月 8 日时，地图被重新绘制，并在以下截图显示：
- en: '![](img/573d8ec3-9954-4981-82bc-c25e4e341f90.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/573d8ec3-9954-4981-82bc-c25e4e341f90.png)'
- en: These screenshots were generated immediately following the reselection of a
    `date`. A user can use a `DatePicker` drop-down to requery the data in your PostGIS
    database.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这些截图是在重新选择 `date` 后立即生成的。用户可以使用 `DatePicker` 下拉菜单重新查询您的 PostGIS 数据库中的数据。
- en: 'In Jupyter, if you set the value of a variable to a string or an integer, you
    will get a number slider or a text box. In the following screenshot, the decorator
    has `x="None"`, with `None` being a string. The text `None` is a placeholder to
    create the text box. This creates a text box with the word `None` in it:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Jupyter 中，如果您将变量的值设置为字符串或整数，您将得到一个数字滑块或文本框。在以下截图中，装饰器有 `x="None"`，其中 `None`
    是一个字符串。文本 `None` 是一个占位符，用于创建文本框。这创建了一个包含单词 `None` 的文本框：
- en: '![](img/bd28f970-d507-45b6-9ae6-e943bad6d1cc.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bd28f970-d507-45b6-9ae6-e943bad6d1cc.png)'
- en: 'The code in the previous screenshot is presented as follows. The code will
    allow you to type the name of an area command, and then display the `incidents`
    within that area command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的截图中的代码如下所示。该代码将允许您输入区域命令的名称，然后显示该区域命令内的 `incidents`：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The previous code starts with the decorator and a string. This will draw the
    text box. The `areaCommand()` function acts exactly as the `date` example mentioned
    earlier, but passes a string to the SQL query. It returns the results of the query,
    and draws the `incidents` on the map.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码从装饰器和字符串开始。这将绘制文本框。`areaCommand()` 函数与前面提到的 `date` 示例作用相同，但将字符串传递给 SQL
    查询。它返回查询结果，并在地图上绘制 `incidents`。
- en: 'The following screenshot shows the return values for `NORTHWEST`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 `NORTHWEST` 的返回值：
- en: '![](img/47fdc251-03f1-4ff6-a9f6-a9ae6abb3548.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/47fdc251-03f1-4ff6-a9f6-a9ae6abb3548.png)'
- en: 'The following screenshot shows the map when the user types `NORTHWEST` in the
    text box:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了用户在文本框中输入 `NORTHWEST` 时的地图：
- en: '![](img/e398e0e1-7be4-48eb-ab99-caa76341fcf9.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e398e0e1-7be4-48eb-ab99-caa76341fcf9.png)'
- en: In this section, you have learned how to perform queries on your spatial data,
    and how to map the results. In the next section, you will learn how to chart the
    results of your queries.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您已经学习了如何查询您的空间数据以及如何映射结果。在下一节中，您将学习如何图表查询结果。
- en: Charts
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图表
- en: Maps are a great data visualization tool, but sometimes a bar chart will do
    the trick. In this section, you will learn how to chart your data using `pandas.DataFrame`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 地图是出色的数据可视化工具，但有时条形图也能解决问题。在本节中，您将学习如何使用`pandas.DataFrame`图表您的数据。
- en: A `DataFrame` stores two-dimensional tabular data (think of a spreadsheet).
    Data frames can be loaded with data from many different sources and data structures,
    but what interests us is that it can load data from SQL queries.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataFrame`存储二维表格数据（想想电子表格）。数据框可以从许多不同的来源和数据结构加载数据，但我们感兴趣的是它可以从SQL查询加载数据。'
- en: 'The following code loads an SQL query into a `DataFrame`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将SQL查询加载到`DataFrame`中：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The previous code selects the `date`, and then counts the occurrence of each
    `date` in `incidents` where the `date` is greater than October 1, 2017\. The `DataFrame`
    is then populated using `DataFrame` (SQL, columns). In this case, the code passes
    `cursor.fetchall()`*,* and `columns=["date","count"]`. The resulting five records
    are displayed using `df.head()`. You could use `df.tial()` to see the last five
    records, or `df` to see it all.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码选择了`日期`，然后统计了`incidents`中每个`日期`的出现的次数，其中`日期`大于2017年10月1日。然后使用`DataFrame`（SQL，列）填充`DataFrame`。在这种情况下，代码传递`cursor.fetchall()`和`columns=["date","count"]`。使用`df.head()`显示了结果的前五条记录。您可以使用`df.tail()`查看最后五条记录，或使用`df`查看全部。
- en: 'The following screenshot shows `df.head()`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了`df.head()`：
- en: '![](img/1c74eb97-d105-424a-9e1d-6ebbef910774.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1c74eb97-d105-424a-9e1d-6ebbef910774.png)'
- en: The preceding screenshot shows that on 2017-10-17, there were 175 `incidents`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示，在2017-10-17这一天，共有175个`事件`。
- en: 'You can plot a `DataFrame` by calling the `plot()` method from the `pandas`
    library. The following code will plot a bar chart of the `DataFrame` `df`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过从`pandas`库中调用`plot()`方法来绘制`DataFrame`。以下代码将绘制`df`的条形图：
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The previous code sorts the data frame by `date`. This is so that the dates
    are in chronological order in our bar chart. It then plots the data using a bar
    chart, with the *x*-axis being the `date`, and the *y*-axis is the `count`. I
    specified the figure size to make it fit on the screen. For smaller data sets,
    the default figure size tends to work well.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码按`日期`对数据框进行排序。这样，日期在我们的条形图中按时间顺序排列。然后它使用条形图绘制数据，其中*x*轴是`日期`，*y*轴是`计数`。我指定了图形大小以使其适合屏幕。对于较小的数据集，默认图形大小通常效果很好。
- en: 'The following screenshot is the result of the `plot`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图是`plot`的结果：
- en: '![](img/9da3f2f5-50e5-4513-a167-494f2b73bb9d.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9da3f2f5-50e5-4513-a167-494f2b73bb9d.png)'
- en: This chart shows us what a map cannot—that crimes seem to decrease on Friday
    and Saturday.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此图表向我们展示了地图无法展示的内容——犯罪似乎在周五和周六有所减少。
- en: 'Let''s walk through another example using `beats`. The following code will
    load crimes by `beat`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用`beats`的另一个例子来演示。以下代码将按`beats`加载犯罪：
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The previous code selects the `beat`, `agency`, and count of `incidents` from
    the `beats` table. Notice the `left join`. The `left join` will give us `beats`
    that may have zero `incidents`. The join is based on an incident being in a `beat`
    polygon. We group by each field we selected.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码从`beats`表中选择了`beat`、`agency`和`incidents`的`计数`。注意`left join`。`left join`将给我们可能没有`incidents`的`beats`。连接基于一个事件位于`beat`多边形内。我们按每个选定的字段进行分组。
- en: 'The query is loaded into a `DataFrame`, and the `head()` is displayed. The
    result is in the screenshot as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 查询被加载到`DataFrame`中，并显示`head()`。结果如下截图所示：
- en: '![](img/a10108e4-06b6-4ea6-a6f7-d41e7a9fd2d6.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a10108e4-06b6-4ea6-a6f7-d41e7a9fd2d6.jpg)'
- en: 'Notice that we have `beats` with no crimes instead of missing beats. There
    are too many `beats` to scroll through, so let''s chart the `DataFrame`. We will
    use the plot function again, passing an `x`, `y`, `kind`, and `figsize` as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有显示没有犯罪的`beats`而不是缺失的`beats`。`beats`太多，无法滚动查看，所以让我们图表`DataFrame`。我们将再次使用绘图函数，传递`x`、`y`、`kind`和`figsize`如下：
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The result of the plot is shown in the following screenshot:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图的结果如下截图所示：
- en: '![](img/e31d97c2-6256-4473-9748-7d23f9830bc0.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e31d97c2-6256-4473-9748-7d23f9830bc0.png)'
- en: 'That is a lot of data to look through, but certain `beats` stand out as high
    crime. This is where data frames can help. You can query the `DataFrame` instead
    of requerying the database. The following code will plot the selection of `beats`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 需要查看的数据量很大，但某些`beats`（打击区域）的犯罪率较高。这就是数据帧可以帮助的地方。您可以直接查询`DataFrame`而不是重新查询数据库。以下代码将绘制`beats`的选择：
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The previous code passes an expression to the area. The expression selects
    records in the `DataFrame` column `Crimes`, where the value is over `800`; `Crimes`
    is the `count` column. The result is shown in the following screenshot:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将一个表达式传递给区域。该表达式选择`DataFrame`中`Crimes`列的记录，其中值超过`800`；`Crimes`是计数列。结果如下所示：
- en: '![](img/82ad4c02-e28a-45a5-9c19-eef2d798574a.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/82ad4c02-e28a-45a5-9c19-eef2d798574a.png)'
- en: Loading your queries into a `DataFrame` will allow you to plot the data, but
    also to slice and query the data again without having to requery the database.
    You can also use the interactive widgets to allow users to modify the charts as
    you learned with the maps.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的查询加载到`DataFrame`中将允许您绘制数据，但还可以在不重新查询数据库的情况下切片和再次查询数据。您还可以使用交互式小部件允许用户修改图表，就像您使用地图学习的那样。
- en: Triggers
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触发器
- en: In any database, when data is inserted, updated, or deleted, you can have the
    table launch a **trigger**. For example, if a user inserts a record, you could
    launch a trigger to make sure that the record meets some specified criteria—no
    null values. Spatial databases allow you to use the same triggers. You can create
    these in several languages, including Python and SQL. The following example will
    use `PL/pgsql`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何数据库中，当数据被插入、更新或删除时，您可以让表启动一个**触发器**。例如，如果用户插入一条记录，您可以使用触发器来确保记录满足某些特定的标准——没有空值。空间数据库允许您使用相同的触发器。您可以使用多种语言创建这些触发器，包括Python和SQL。以下示例将使用`PL/pgsql`。
- en: 'You create triggers using SQL expressions. The following code will create a
    trigger to prevent entering an incomplete incident:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用SQL表达式创建触发器。以下代码将创建一个触发器以防止输入不完整的事件：
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The previous code creates a new function named `newcrime()`. The function is
    an `if` statement that checks if the `NEW.crimetype` is null. If it is, the record
    is not added, and an exception is raised. The exception will state that `NEW.address`
    must include a crime type. The assumption is being made that the address is not
    null.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码创建了一个名为`newcrime()`的新函数。该函数是一个`if`语句，检查`NEW.crimetype`是否为空。如果是，则不添加记录，并引发异常。异常将声明`NEW.address`必须包含犯罪类型。假设地址不是空的。
- en: 'Now that you have a function, you can create a trigger that calls that function.
    The following code shows you how:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经有一个函数，您可以创建一个调用该函数的触发器。以下代码展示了如何操作：
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The previous code executes the SQL statement that creates the trigger. It is
    created `BEFORE INSERT OR UPDATE`. To test the trigger, let''s insert a point
    with no crime type. The following code will attempt to enter the incident:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码执行了创建触发器的SQL语句。它是在`BEFORE INSERT OR UPDATE`时创建的。为了测试触发器，让我们插入一个没有犯罪类型的点。以下代码将尝试输入事件：
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The previous code creates an incident with only an `address` and a `geom`.
    The result of executing the previous code is shown in the following screenshot:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码创建了一个只有`address`和`geom`的事件。执行之前代码的结果如下所示：
- en: '![](img/4cae4022-c224-4c5b-8834-d4352df0b5ad.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4cae4022-c224-4c5b-8834-d4352df0b5ad.png)'
- en: 'In the previous screenshot, the InternalError states that 123 Sesame St Must
    Include Crime Type. Our trigger successfully blocked bad data from being entered.
    To double-check, we can query for `"123 Sesame St."` The results are shown in
    the following screenshot:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的屏幕截图中，InternalError指出“123芝麻街”必须包含犯罪类型。我们的触发器成功阻止了不良数据的输入。为了双重检查，我们可以查询“123芝麻街”。结果如下所示：
- en: '![](img/f85d2d8f-fb99-4010-b4ac-5fdc0988b275.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f85d2d8f-fb99-4010-b4ac-5fdc0988b275.png)'
- en: A trigger can be used to prevent bad data from being loaded for emailing or
    texting when changes have occurred. For example, you could allow users to enter
    polygons they are interested in, and their phone number. On a new incident being
    added to the database, you could see if it is within a polygon, and if so, text
    the phone number associated with the polygon.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器可以用来防止在发生更改时加载不良数据用于电子邮件或短信发送。例如，您可以允许用户输入他们感兴趣的多边形以及他们的电话号码。当数据库中添加新的事件时，您可以检查该事件是否位于多边形内，如果是，则向与多边形关联的电话号码发送短信。
- en: 'To install other languages for triggers, open **Stack Builder** and add the
    add-on shown in the following screenshot:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要为触发器安装其他语言，请打开**Stack Builder**并添加以下截图所示的附加组件：
- en: '![](img/6623adda-2f3b-49fc-8396-4342f7a6fba5.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6623adda-2f3b-49fc-8396-4342f7a6fba5.png)'
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to use spatial queries to perform geoprocessing
    tasks. You also learned how to map and chart the results of your queries using
    `ipyleaflet` and data frames. You learned how to modify the maps and queries using
    interactive widgets in Jupyter. Lastly, you learned about how triggers work, and
    were shown a quick example of data checking using trigger.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用空间查询来执行地理处理任务。你还学习了如何使用`ipyleaflet`和数据框将查询结果映射和制图。你学习了如何使用Jupyter中的交互式小部件修改地图和查询。最后，你了解了触发器的工作原理，并展示了使用触发器进行数据检查的快速示例。
- en: In the next chapter, you will learn how to perform geoprocessing tasks using
    QGIS. You will learn how to use toolboxes that are already included in QGIS. You
    will learn how to write your own toolboxes that you can use and share with other
    QGIS users, and you will learn how to use QGIS to map the results. The results
    can be saved as a QGIS project, or as one of many spatial data formats from QGIS.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何使用QGIS执行地理处理任务。你将学习如何使用QGIS中已包含的工具箱。你将学习如何编写自己的工具箱，以便你可以使用并与其他QGIS用户共享，你还将学习如何使用QGIS来映射结果。结果可以保存为QGIS项目，或作为QGIS的许多空间数据格式之一。
