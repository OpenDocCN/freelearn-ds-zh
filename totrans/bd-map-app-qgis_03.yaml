- en: Chapter 3. Learning the QGIS Python API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will take a closer look at the Python libraries available
    for the QGIS Python developer, and also look at the various ways in which we can
    use these libraries to perform useful tasks within QGIS.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How the QGIS Python libraries are based on the underlying C++ APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the C++ API documentation as a reference to work with the Python
    APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the PyQGIS libraries are organized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most important concepts and classes within the PyQGIS libraries and how
    to use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some practical examples of performing useful tasks using PyQGIS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: About the QGIS Python APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The QGIS system itself is written in C++, and has its own set of APIs that are
    also written in C++. The Python APIs are implemented as wrappers around these
    C++ APIs. For example, there is a Python class named `QgisInterface` that acts
    as a wrapper around a C++ class of the same name. All the methods, class variables,
    and the like that are implemented by the C++ version of `QgisInterface` are made
    available through the Python wrapper.
  prefs: []
  type: TYPE_NORMAL
- en: 'What this means is that when you access the Python QGIS APIs, you aren''t accessing
    the API directly. Instead, the wrapper connects your code to the underlying C++
    objects and methods, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![About the QGIS Python APIs](img/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Fortunately, in most cases, the QGIS Python wrappers simply hide away the complexity
    of the underlying C++ code, so the PyQGIS libraries work as you would expect them
    to. There are some gotchas, however, and we will cover these as they come up.
  prefs: []
  type: TYPE_NORMAL
- en: Deciphering the C++ documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As QGIS is implemented in C++, the documentation for QGIS APIs is all based
    on C++. This can make it difficult for Python developers to understand and work
    with the QGIS APIs. For example, the API documentation for the `QgsInterface.zoomToActiveLayer()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deciphering the C++ documentation](img/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you''re not familiar with C++, this can be quite confusing. Fortunately,
    as a Python programmer, you can skip over much of the complexity as it doesn''t
    apply to you. In particular:'
  prefs: []
  type: TYPE_NORMAL
- en: The `virtual` keyword is an implementation detail you don't need to worry about
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void` indicates that the method doesn''t return a value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The double colons in `QgisInterface::zoomToActiveLayer` are simply a C++ convention
    for separating the class name from the method name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Just like in Python, the parentheses show that the method doesn''t take any
    parameters. So if you have an instance of `QgisInterface` (for example, as the
    standard `iface` variable available in the Python Console), you can call this
    method simply by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s take a look at a slightly more complex example: the C++ documentation
    for the `QgisInterface.addVectorLayer()` method looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deciphering the C++ documentation](img/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Notice how the `virtual` keyword is followed by `QgsVectorLayer*` instead of
    `void`. This is the return value for this method; it returns a `QgsVector` object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Technically speaking, `*` means that the method returns a **pointer** to an
    object of type `QgsVectorLayer`. Fortunately, Python wrappers automatically handle
    pointers, so you don't need to worry about this.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the brief description at the bottom of the documentation for this method;
    while many of the C++ methods have very little, if any, additional information,
    other methods have more extensive information. Obviously, you should read these
    descriptions carefully as they tell you more about what the method does.
  prefs: []
  type: TYPE_NORMAL
- en: Even without any description, the C++ documentation is still useful as it tells
    you what the method is called, what parameters it accepts, and what type of data
    is being returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding method, you can see that there are three parameters listed
    in between the parentheses. As C++ is a *strongly typed* language, you have to
    define the type of each parameter when you define a function. This is helpful
    for Python programmers as it tells you what type of value to supply. Apart from
    QGIS objects, you might also encounter the following data types in the C++ documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Data type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `int` | A standard Python integer value |'
  prefs: []
  type: TYPE_TB
- en: '| `long` | A standard Python long integer value |'
  prefs: []
  type: TYPE_TB
- en: '| `float` | A standard Python floating point (real) number |'
  prefs: []
  type: TYPE_TB
- en: '| `bool` | A Boolean value (`true` or `false`) |'
  prefs: []
  type: TYPE_TB
- en: '| `QString` | A string value. Note that the QGIS Python wrappers automatically
    convert Python strings to C++ strings, so you don''t need to deal with `QString`
    objects directly |'
  prefs: []
  type: TYPE_TB
- en: '| `QList` | This object is used to encapsulate a list of other objects. For
    example, `QList<QString*>` represents a list of strings |'
  prefs: []
  type: TYPE_TB
- en: 'Just as in Python, a method can take default values for each parameter. For
    example, the `QgisInterface.newProject()` method looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deciphering the C++ documentation](img/00024.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In this case, the `thePromptToSaveFlag` parameter has a default value, and this
    default value will be used if no value is supplied.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, classes are initialized using the `__init__` method. In C++, this
    is called a *constructor*. For example, the constructor for the `QgsLabel` class
    looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deciphering the C++ documentation](img/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Just as in Python, C++ classes *inherit* the methods defined in their superclass.
    Fortunately, QGIS doesn't have an extensive class hierarchy, so most of the classes
    don't have a superclass. However, don't forget to check for a superclass if you
    can't find the method you're looking for in the documentation for the class itself.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, be aware that C++ supports the concept of *method overloading*. A single
    method can be defined more than once, where each version accepts a different set
    of parameters. For example, take a look at the constructor for the `QgsRectangle`
    class—you will see that there are four different versions of this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first version accepts the four coordinates as floating point numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deciphering the C++ documentation](img/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The second version constructs a rectangle using two `QgsPoint` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deciphering the C++ documentation](img/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The third version copies the coordinates from `QRectF` (which is a Qt data
    type) into a `QgsRectangle` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deciphering the C++ documentation](img/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The final version copies the coordinates from another `QgsRectangle` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deciphering the C++ documentation](img/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The C++ compiler chooses the correct method to use based on the parameters that
    have been supplied. Python has no concept of method overloading; just choose the
    version of the method that accepts the parameters you want to supply, and the
    QGIS Python wrappers will automatically choose the correct method for you.
  prefs: []
  type: TYPE_NORMAL
- en: If you keep these guidelines in mind, deciphering the C++ documentation for
    QGIS isn't all that hard. It just looks more complicated than it really is, thanks
    to all the complexity specific to C++. However, it doesn't take long for your
    brain to start filtering out the C++ gobbledygook, and you'll be able to use the
    QGIS reference documentation almost as easily as if it was written for Python
    rather than C++.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing the QGIS Python libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we can understand the C++-oriented documentation, let''s see how the
    PyQGIS libraries are structured. All of the PyQGIS libraries are organized under
    a package named `qgis`. You wouldn''t normally import `qgis` directly, however,
    as all the interesting libraries are subpackages within this main package; here
    are the five packages that make up the PyQGIS library:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `qgis.core` | This provides access to the core GIS functionality used throughout
    QGIS. |'
  prefs: []
  type: TYPE_TB
- en: '| `qgis.gui` | This defines a range of GUI widgets that you can include in
    your own programs. |'
  prefs: []
  type: TYPE_TB
- en: '| `qgis.analysis` | This provides spatial analysis tools to analyze vector
    and raster format data. |'
  prefs: []
  type: TYPE_TB
- en: '| `qgis.networkanalysis` | This provides tools to build and analyze topologies.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `qgis.utils` | This implements miscellaneous functions that allow you to
    work with the QGIS application using Python. |'
  prefs: []
  type: TYPE_TB
- en: The first two packages (`qgis.core` and `qgis.gui`) implement the most important
    parts of the PyQGIS library, and it's worth spending some time to become more
    familiar with the concepts and classes they define. Let's take a closer look at
    these two packages now.
  prefs: []
  type: TYPE_NORMAL
- en: The qgis.core package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `qgis.core` package defines fundamental classes used throughout the QGIS
    system. A large part of this package is dedicated to working with vector and raster
    format geospatial data, and displaying these types of data within a map. Let's
    see how this is done.
  prefs: []
  type: TYPE_NORMAL
- en: Maps and map layers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A map consists of multiple layers drawn one on top of the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Maps and map layers](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are three types of map layers supported by QGIS:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vector layer**: This layer draws geospatial features such as points, lines,
    and polygons'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Raster layer**: This layer draws raster (bitmapped) data onto a map'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Plugin layer**: This layer allows a plugin to draw directly onto a map'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these types of map layers has a corresponding class within the `qgis.core`
    library. For example, a vector map layer will be represented by an object of type
    `qgis.core.QgsVectorLayer`.
  prefs: []
  type: TYPE_NORMAL
- en: We will take a closer look at vector and raster map layers shortly. Before we
    do this, though, we need to learn how geospatial data (both vector and raster
    data) is positioned on a map.
  prefs: []
  type: TYPE_NORMAL
- en: Coordinate reference systems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since the Earth is a three-dimensional object, while maps represent the Earth''s
    surface as a two-dimensional plane, there has to be a way of translating from
    points on the Earth''s surface into (x,y) coordinates within a map. This is done
    using a **Coordinate Reference System** (**CRS**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Coordinate reference systems](img/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Globe image courtesy Wikimedia ([http://commons.wikimedia.org/wiki/File:Rotating_globe.gif](http://commons.wikimedia.org/wiki/File:Rotating_globe.gif))
  prefs: []
  type: TYPE_NORMAL
- en: 'A CRS has two parts: an **ellipsoid**, which is a mathematical model of the
    Earth''s surface, and a **projection**, which is a formula that converts points
    on the surface of the spheroid into (x,y) coordinates on a map.'
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, most of the time you can simply select the appropriate CRS that
    matches the CRS of the data you are using. However, because many different coordinate
    reference systems have been devised over the years, it is vital that you use the
    correct CRS when plotting your geospatial data. If you don't do this, your features
    will be displayed in the wrong place or have the wrong shape.
  prefs: []
  type: TYPE_NORMAL
- en: The majority of geospatial data available today uses the **EPSG 4326** coordinate
    reference system (sometimes also referred to as WGS84). This CRS defines coordinates
    as latitude and longitude values. This is the default CRS used for new data imported
    into QGIS. However, if your data uses a different coordinate reference system,
    you will need to create and use a different CRS for your map layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `qgis.core.QgsCoordinateReferenceSystem` class represents a CRS. Once you
    create your coordinate reference system, you can tell your map layer to use that
    CRS when accessing the underlying data. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that different map layers can use different coordinate reference systems.
    Each layer will use its CRS when drawing the contents of the layer onto the map.
  prefs: []
  type: TYPE_NORMAL
- en: Vector layers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A vector layer draws geospatial data onto a map in the form of points, lines,
    polygons, and so on. Vector-format geospatial data is typically loaded from a
    **vector data source** such as a shapefile or database. Other vector data sources
    can hold vector data in memory, or load data from a web service across the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'A vector-format data source has a number of features, where each feature represents
    a single *record* within the data source. The `qgis.core.QgsFeature` class represents
    a feature within a data source. Each feature has the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ID**: This is the feature''s unique identifier within the data source'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Geometry**: This is the underlying point, line, polygon, and so on, which
    represents the feature on the map. For example, a **city** data source would have
    one feature for each city, and the geometry would typically be either a point
    that represents the center of the city, or a polygon (or a multipolygon) that
    represents the city''s outline.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attributes**: These are key/value pairs that provide additional information
    about the feature. For example, a city data source representing cities might have
    attributes such as `total_area`, `population`, `elevation`, and so on. Attribute
    values can be strings, integers, or floating point numbers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In QGIS, a **data provider** allows the vector layer to access the features
    within the data source. The data provider, an instance of `qgis.core.QgsVectorDataProvider`,
    includes:'
  prefs: []
  type: TYPE_NORMAL
- en: A **geometry type** that is stored in the data source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of **fields** that provide information about the attributes stored for
    each feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to search through the features within the data source, using the
    `getFeatures()` method and the `QgsFeatureRequest` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can access the various vector (and also raster) data providers by using
    the `qgis.core.QgsProviderRegistry` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The vector layer itself is represented by a `qgis.core.QgsVectorLayer` object.
    Each vector layer includes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data provider**: This is the connection to the underlying file or database
    that holds the geospatial information to be displayed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Coordinate reference system**: This indicates which CRS the geospatial data
    uses'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Renderer**: This chooses how the features are to be displayed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a closer look at the concept of a renderer and how features are displayed
    within a vector map layer.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying vector data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The features within a vector map layer are displayed using a combination of
    **renderer** and **symbol** objects. The renderer chooses the symbol that has
    to be used for a given feature, and the symbol that does the actual drawing.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three basic types of symbols defined by QGIS:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Marker symbol**: This displays a point as a filled circle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line symbol**: This draws a line using a given line width and color'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fill symbol**: This draws the interior of a polygon with a given color'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These three types of symbols are implemented as subclasses of the `qgis.core.QgsSymbolV2`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`qgis.core.QgsMarkerSymbolV2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`qgis.core.QgsLineSymbolV2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`qgis.core.QgsFillSymbolV2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You might be wondering why all these classes have "V2" in their name. This is
    a historical quirk of QGIS. Earlier versions of QGIS supported both an "old" and
    a "new" system of rendering, and the "V2" naming refers to the new rendering system.
    The old rendering system no longer exists, but the "V2" naming continues to maintain
    backward compatibility with existing code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Internally, symbols are rather complex, using "symbol layers" to draw multiple
    elements on top of each other. In most cases, however, you can make use of the
    "simple" version of the symbol. This makes it easier to create a new symbol without
    having to deal with the internal complexity of symbol layers. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'While symbols draw the features onto the map, a renderer is used to choose
    which symbol to use to draw a particular feature. In the simplest case, the same
    symbol is used for every feature within a layer. This is called a **single symbol
    renderer**, and is represented by the `qgis.core.QgsSingleSymbolRenderV2` class.
    Other possibilities include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Categorized symbol renderer** (`qgis.core.QgsCategorizedSymbolRendererV2`):
    This renderer chooses a symbol based on the value of an attribute. The categorized
    symbol renderer has a mapping from attribute values to symbols.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Graduated symbol renderer** (`qgis.core.QgsGraduatedSymbolRendererV2`): This
    type of renderer uses ranges of attribute values, and maps each range to an appropriate
    symbol.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using a single symbol renderer is very straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To use a categorized symbol renderer, you first define a list of `qgis.core.QgsRendererCategoryV2`
    objects, and then use that to create the renderer. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the `QgsRendererCategoryV2` constructor takes three parameters:
    the desired value, the symbol used, and the label used to describe that category.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to use a graduated symbol renderer, you define a list of `qgis.core.QgsRendererRangeV2`
    objects and then use that to create your renderer. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Accessing vector data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In addition to displaying the contents of a vector layer within a map, you
    can use Python to directly access the underlying data. This can be done using
    the data provider''s `getFeatures()` method. For example, to iterate over all
    the features within the layer, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to search for features based on some criteria, you can use the
    `QgsFeatureRequest` object''s `setFilterExpression()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have the features, it''s easy to get access to the feature''s geometry,
    ID, and attributes. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The object returned by the `feature.geometry()` call, which will be an instance
    of `qgis.core.QgsGeometry`, represents the feature's geometry. This object has
    a large number of methods you can use to extract the underlying data and perform
    various geospatial calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Spatial indexes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the previous section, we searched for features based on their attribute values.
    There are times, though, when you might want to find features based on their position
    in space. For example, you might want to find all features that lie within a certain
    distance of a given point. To do this, you can use a **spatial index**, which
    indexes features according to their location and extent. Spatial indexes are represented
    in QGIS by the `QgsSpatialIndex` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'For performance reasons, a spatial index is not created automatically for each
    vector layer. However, it''s easy to create one when you need it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget that you can use the `QgsFeatureRequest.setFilterExpression()`
    method to limit the set of features that get added to the index.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the spatial index, you can use it to perform queries based on
    the position of the features. In particular:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find one or more features that are closest to a given point using the
    `nearestNeighbor()` method. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that this method takes two parameters: the desired point as a `QgsPoint`
    object and the number of features to return.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can find all features that intersect with a given rectangular area by using
    the `intersects()` method, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Raster layers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Raster-format geospatial data is essentially a bitmapped image, where each pixel
    or "cell" in the image corresponds to a particular part of the Earth's surface.
    Raster data is often organized into **bands**, where each band represents a different
    piece of information. A common use for bands is to store the red, green, and blue
    component of the pixel's color in a separate band. Bands might also represent
    other types of information, such as moisture level, elevation, or soil type.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways in which raster information can be displayed. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: If the raster data only has one band, the pixel value can be used as an index
    into a **palette**. The palette maps each pixel value maps to a particular color.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the raster data has only one band but no palette is provided, the pixel values
    can be used directly as a **grayscale** value; that is, larger numbers are lighter
    and smaller numbers are darker. Alternatively, the pixel values can be passed
    through a **pseudocolor algorithm** to calculate the color to be displayed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the raster data has multiple bands, then typically, the bands would be combined
    to generate the desired color. For example, one band might represent the red component
    of the color, another band might represent the green component, and yet another
    band might represent the blue component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, a multiband raster data source might be drawn using a palette,
    or as a grayscale or a pseudocolor image, by selecting a particular band to use
    for the color calculation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a closer look at how raster data can be drawn onto the map.
  prefs: []
  type: TYPE_NORMAL
- en: How raster data is displayed
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The **drawing style** associated with the raster band controls how the raster
    data will be displayed. The following drawing styles are currently supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Drawing style | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `PalettedColor` | For a single band raster data source, a palette maps each
    raster value to a color. |'
  prefs: []
  type: TYPE_TB
- en: '| `SingleBandGray` | For a single band raster data source, the raster value
    is used directly as a grayscale value. |'
  prefs: []
  type: TYPE_TB
- en: '| `SingleBandPseudoColor` | For a single band raster data source, the raster
    value is used to calculate a pseudocolor. |'
  prefs: []
  type: TYPE_TB
- en: '| `PalettedSingleBandGray` | For a single band raster data source that has
    a palette, this drawing style tells QGIS to ignore the palette and use the raster
    value directly as a grayscale value. |'
  prefs: []
  type: TYPE_TB
- en: '| `PalettedSingleBandPseudoColor` | For a single band raster data source that
    has a palette, this drawing style tells QGIS to ignore the palette and use the
    raster value to calculate a pseudocolor. |'
  prefs: []
  type: TYPE_TB
- en: '| `MultiBandColor` | For multiband raster data sources, use a separate band
    for each of the red, green, and blue color components. For this drawing style,
    the `setRedBand()`, `setGreenBand()`, and `setBlueBand()` methods can be used
    to choose which band to use for each color component. |'
  prefs: []
  type: TYPE_TB
- en: '| `MultiBandSingleBandGray` | For multiband raster data sources, choose a single
    band to use as the grayscale color value. For this drawing style, use the `setGrayBand()`
    method to specify the band to use. |'
  prefs: []
  type: TYPE_TB
- en: '| `MultiBandSingleBandPseudoColor` | For multiband raster data sources, choose
    a single band to use to calculate a pseudocolor. For this drawing style, use the
    `setGrayBand()` method to specify the band to use. |'
  prefs: []
  type: TYPE_TB
- en: To set the drawing style, use the `layer.setDrawingStyle()` method, passing
    in a string that contains the name of the desired drawing style. You will also
    need to call the various `setXXXBand()` methods, as described in the preceding
    table, to tell the raster layer which bands contain the value(s) to use to draw
    each pixel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that QGIS doesn''t automatically update the map when you call the preceding
    functions to change the way the raster data is displayed. To have your changes
    displayed right away, you''ll need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Turn off raster image caching. This can be done by calling `layer.setImageCache(None)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tell the raster layer to redraw itself, by calling `layer.triggerRepaint()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accessing raster data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As with vector-format data, you can access the underlying raster data via the
    data provider''s `identify()` method. The easiest way to do this is to pass in
    a single coordinate and retrieve the value or values at that coordinate. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, you need to check whether the given coordinate exists within
    the raster data (using the `isValid()` call). The `values.results()` method returns
    a dictionary that maps band numbers to values.
  prefs: []
  type: TYPE_NORMAL
- en: Using this technique, you can extract all the underlying data associated with
    a given coordinate within the raster layer.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also use the `provider.block()` method to retrieve the band data for
    a large number of coordinates all at once. We will look at how to do this later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Other useful qgis.core classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Apart from all the classes and functionality involved in working with data
    sources and map layers, the `qgis.core` library also defines a number of other
    classes that you might find useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Class | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `QgsProject` | This represents the current QGIS project. Note that this is
    a singleton object, as only one project can be open at a time. The `QgsProject`
    class is responsible for loading and storing properties, which can be useful for
    plugins. |'
  prefs: []
  type: TYPE_TB
- en: '| `QGis` | This class defines various constants, data types, and functions
    used throughout the QGIS system. |'
  prefs: []
  type: TYPE_TB
- en: '| `QgsPoint` | This is a generic class that stores the coordinates for a point
    within a two-dimensional plane. |'
  prefs: []
  type: TYPE_TB
- en: '| `QgsRectangle` | This is a generic class that stores the coordinates for
    a rectangular area within a two-dimensional plane. |'
  prefs: []
  type: TYPE_TB
- en: '| `QgsRasterInterface` | This is the base class to use for processing raster
    data, for example, to reproject a set of raster data into a new coordinate system,
    to apply filters to change the brightness or color of your raster data, to resample
    the raster data, and to generate new raster data by rendering the existing data
    in various ways. |'
  prefs: []
  type: TYPE_TB
- en: '| `QgsDistanceArea` | This class can be used to calculate distances and areas
    for a given geometry, automatically converting from the source coordinate reference
    system into meters. |'
  prefs: []
  type: TYPE_TB
- en: '| `QgsMapLayerRegistry` | This class provides access to all the registered
    map layers in the current project. |'
  prefs: []
  type: TYPE_TB
- en: '| `QgsMessageLog` | This class provides general logging features within a QGIS
    program. This lets you send debugging messages, warnings, and errors to the QGIS
    "Log Messages" panel. |'
  prefs: []
  type: TYPE_TB
- en: The qgis.gui package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `qgis.gui` package defines a number of user-interface widgets that you can
    include in your programs. Let's start by looking at the most important `qgis.gui`
    classes, and follow this up with a brief look at some of the other classes that
    you might find useful.
  prefs: []
  type: TYPE_NORMAL
- en: The QgisInterface class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`QgisInterface` represents the QGIS system''s user interface. It allows programmatic
    access to the map canvas, the menu bar, and other parts of the QGIS application.
    When running Python code within a script or a plugin, or directly from the QGIS
    Python console, a reference to `QgisInterface` is typically available through
    the `iface` global variable.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `QgisInterface` object is only available when running the QGIS application
    itself. If you are running an external application and import the PyQGIS library
    into your application, `QgisInterface` won't be available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the more important things you can do with the `QgisInterface` object
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: Get a reference to the list of layers within the current QGIS project via the
    `legendInterface()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get a reference to the map canvas displayed within the main application window,
    using the `mapCanvas()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieve the currently active layer within the project, using the `activeLayer()`
    method, and set the currently active layer by using the `setActiveLayer()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get a reference to the application's main window by calling the `mainWindow()`
    method. This can be useful if you want to create additional Qt windows or dialogs
    that use the main window as their parent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get a reference to the QGIS system's message bar by calling the `messageBar()`
    method. This allows you to display messages to the user directly within the QGIS
    main window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The QgsMapCanvas class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **map canvas** is responsible for drawing the various map layers into a
    window. The `QgsMapCanvas` class represents a map canvas. This class includes:'
  prefs: []
  type: TYPE_NORMAL
- en: A list of the currently shown **map layers**. This can be accessed using the
    `layers()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that there is a subtle difference between the list of map layers available
    within the map canvas and the list of map layers included in the `QgisInterface.legendInterface()`
    method. The map canvas's list of layers only includes the list of layers currently
    visible, while `QgisInterface.legendInterface()` returns all the map layers, including
    those that are currently hidden.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The **map units** used by this map (meters, feet, degrees, and so on). The map's
    map units can be retrieved by calling the `mapUnits()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **extent**, **which** is the area of the map currently shown within the canvas.
    The map's extent will change as the user zooms in and out, and pans across the
    map. The current map extent can be obtained by calling the `extent()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A current map tool** that is used to control the user''s interaction with
    the contents of the map canvas. The current map tool can be set using the `setMapTool()`
    method, and you can retrieve the current map tool (if any) by calling the `mapTool()`
    method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **background color** used to draw the background behind all the map layers.
    You can change the map's background color by calling the `canvasColor()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **coordinate transform** that converts from map coordinates (that is, coordinates
    in the data source's coordinate reference system) to pixels within the window.
    You can retrieve the current coordinate transform by calling the `getCoordinateTransform()`
    method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The QgsMapCanvasItem class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A **map canvas item** is an item drawn on top of the map canvas. The map canvas
    item will appear in front of the map layers. While you can create your own subclass
    of `QgsMapCanvasItem` if you want to draw custom items on top of the map canvas,
    you will find it easier to use an existing subclass that does much of the work
    for you. There are currently three subclasses of `QgsMapCanvasItem` that you might
    find useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QgsVertexMarker`: This draws an icon (an "X", a "+", or a small box) centered
    around a given point on the map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QgsRubberBand`: This draws an arbitrary polygon or polyline onto the map.
    It is intended to provide visual feedback as the user draws a polygon onto the
    map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QgsAnnotationItem`: This is used to display additional information about a
    feature, in the form of a balloon that is connected to the feature. The `QgsAnnotationItem`
    class has various subclasses that allow you to customize the way the information
    is displayed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The QgsMapTool class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **map tool** allows the user to interact with and manipulate the map canvas,
    capturing mouse events and responding appropriately. A number of `QgsMapTool`
    subclasses provide standard map interaction behavior such as clicking to zoom
    in, dragging to pan the map, and clicking on a feature to identify it. You can
    also create your own custom map tools by subclassing `QgsMapTool` and implementing
    the various methods that respond to user-interface events such as pressing down
    the mouse button, dragging the canvas, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have created a map tool, you can allow the user to activate it by associating
    the map tool with a toolbar button. Alternatively, you can activate it from within
    your Python code by calling the `mapCanvas.setMapTool(...)` method.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at the process of creating your own custom map tool in the section
    *Using the PyQGIS library*.
  prefs: []
  type: TYPE_NORMAL
- en: Other useful qgis.gui classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While the `qgis.gui` package defines a large number of classes, the ones you
    are most likely to find useful are given in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Class | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `QgsLegendInterface` | This provides access to the map legend, that is, the
    list of map layers within the current project. Note that map layers can be grouped,
    hidden, and shown within the map legend. |'
  prefs: []
  type: TYPE_TB
- en: '| `QgsMapTip` | This displays a tip on a map canvas when the user holds the
    mouse over a feature. The map tip will show the display field for the feature;
    you can set this by calling `layer.setDisplayField("FIELD")`. |'
  prefs: []
  type: TYPE_TB
- en: '| `QgsColorDialog` | This is a dialog box that allows the user to select a
    color. |'
  prefs: []
  type: TYPE_TB
- en: '| `QgsDialog` | This is a generic dialog with a vertical box layout and a button
    box, making it easy to add content and standard buttons to your dialog. |'
  prefs: []
  type: TYPE_TB
- en: '| `QgsMessageBar` | This is a bar that displays non-blocking messages to the
    user. We looked at the message bar class in the previous chapter. |'
  prefs: []
  type: TYPE_TB
- en: '| `QgsMessageViewer` | This is a generic class that displays long messages
    to the user within a modal dialog. |'
  prefs: []
  type: TYPE_TB
- en: '| `QgsBlendModeComboBox``QgsBrushStyleComboBox``QgsColorRampComboBox``QgsPenCapStyleComboBox``QgsPenJoinStyleComboBox``QgsScaleComboBox`
    | These `QComboBox` user-interface widgets allow you to prompt the user for various
    drawing options. With the exception of the `QgsScaleComboBox`, which lets the
    user choose a map scale, all the other `QComboBox` subclasses let the user choose
    various Qt drawing options. |'
  prefs: []
  type: TYPE_TB
- en: Using the PyQGIS library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we looked at a number of classes provided by the PyQGIS
    library. Let's make use of these classes to perform some real-world geospatial
    development tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing raster data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're going to start by writing a program to load in some raster-format data
    and analyze its contents. To make this more interesting, we'll use a **Digital
    Elevation Model** (**DEM**) file, which is a raster format data file that contains
    elevation data.
  prefs: []
  type: TYPE_NORMAL
- en: The **Global Land One-Kilometer Base Elevation Project** (**GLOBE**) provides
    free DEM data for the world, where each pixel represents one square kilometer
    of the Earth's surface. GLOBE data can be downloaded from [http://www.ngdc.noaa.gov/mgg/topo/gltiles.html](http://www.ngdc.noaa.gov/mgg/topo/gltiles.html).
    Download the E tile, which includes the western half of the USA. The resulting
    file, which is named `e10g`, contains the height information you need. You'll
    also need to download the `e10g.hdr` header file so that QGIS can read the file—you
    can download this from [http://www.ngdc.noaa.gov/mgg/topo/elev/esri/hdr](http://www.ngdc.noaa.gov/mgg/topo/elev/esri/hdr).
    Once you've downloaded these two files, put them together into a convenient directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now load the DEM data into QGIS using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, there is a slight complexity here. Since QGIS doesn''t know
    which coordinate reference system is used for the data, it displays a dialog box
    that asks you to choose the CRS. Since the GLOBE DEM data is in the WGS84 CRS,
    which QGIS uses by default, this dialog box is redundant. To disable it, we need
    to add the following to the top of our program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've loaded our raster DEM data into QGIS, we can analyze it. While
    there are lots of things we can do with DEM data, let's calculate how often each
    unique elevation value occurs within the data.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that we're loading the DEM data directly using `QgsRasterDataProvider`.
    We don't want to display this information on a map, so we don't want (or need)
    to load it into `QgsRasterLayer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the DEM data is in a raster format, you need to iterate over the individual
    pixels or cells to get each height value. The `provider.xSize()` and `provider.ySize()`
    methods tell us how many cells are there in the DEM, while the `provider.extent()`
    method gives us the area of the Earth''s surface covered by the DEM. Using this
    information, we can extract the individual elevation values from the contents
    of the DEM in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The returned `block` variable is an object of type `QgsRasterBlock`, which
    is essentially a two-dimensional array of values. Let''s iterate over the raster
    and extract the individual elevation values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve loaded the individual elevation values, it''s easy to build
    a histogram out of those values. Here is the entire program to load the DEM data
    into memory, and then calculate and display the histogram:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note that we've added a *no data value* check to the code. Raster data often
    includes pixels that have no value associated with them. In the case of a DEM,
    elevation data is only provided for areas of land; pixels over the sea have no
    elevation, and we have to exclude them, or our histogram will be inaccurate.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating vector data and saving it to a shapefile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create a program that takes two vector data sources, subtracts one set
    of vectors from the other, and saves the resulting geometries into a new shapefile.
    Along the way, we'll learn a few important things about the PyQGIS library.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll be making use of the `QgsGeometry.difference()` function. This function
    performs a geometrical subtraction of one geometry from another, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Manipulating vector data and saving it to a shapefile](img/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s start by asking the user to select the first shapefile and open up a
    vector data provider for that file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then read the geometries from that file into memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This last line of code includes an important feature. Notice that we use the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the preceding line instead of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This is to get the geometry object to add to the list. In other words, we had
    to create a new geometry object based on the feature''s existing geometry object.
    This is a limitation of the way the QGIS Python wrappers work: the `feature.geometry()`
    method returns a reference to the geometry, but the C++ code doesn''t know that
    you are storing this reference away in your Python code. So, when the feature
    is no longer needed, the memory used by the feature''s geometry is also released.
    If you then try to access that geometry later on, the entire QGIS system will
    crash. To get around this, we make a copy of the geometry so that we can refer
    to it even after the feature''s memory has been released.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve loaded our first set of geometries into memory, let''s do the
    same for the second shapefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'With the two sets of geometries loaded into memory, we''re ready to start subtracting
    one from the other. However, to make this process more efficient, we will combine
    the geometries from the second shapefile into one large geometry, which we can
    then subtract all at once, rather than subtracting one at a time. This will make
    the subtraction process much faster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now calculate the new set of geometries by subtracting one from the
    other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we check to see whether the destination geometry is mathematically
    valid and is not empty.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Invalid geometries are a common problem when manipulating complex shapes. There
    are options for fixing them, such as splitting apart multi-geometries and performing
    a buffer operation. However, doing this is beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our last task is to save the resulting geometries into a new shapefile. We''ll
    first ask the user for the name of the destination shapefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll make use of a **vector file writer** to save the geometries into a shapefile.
    Let''s start by initializing the file writer object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We don''t have any attributes in our shapefile, so the fields list is empty.
    Now that the writer has been set up, we can save the geometries into the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that all the data has been written to the disk, let''s display a message
    box that informs the user that we''ve finished:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, creating a new shapefile is very straightforward in PyQGIS,
    and it's easy to manipulate geometries using Python—just so long as you copy the
    `QgsGeometry` objects you want to keep around. If your Python code starts to crash
    while manipulating geometries, this is probably the first thing you should look
    for.
  prefs: []
  type: TYPE_NORMAL
- en: Using different symbols for different features within a map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's use World Borders Dataset that you downloaded in the previous chapter
    to draw a world map, using different symbols for different continents. This is
    a good example of using a categorized symbol renderer, though we'll combine it
    into a script that loads the shapefile into a map layer and sets up the symbols
    and map renderer to display the map exactly as you want. We'll then save the resulting
    map as an image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a map layer to display the contents of the World Borders
    Dataset shapefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Each unique region code in the World Borders Dataset shapefile corresponds
    to a continent. We want to define the name and color to use for each of these
    regions, and use this information to set up the various categories to use when
    displaying the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'With these categories set up, we simply update the map layer to use a categorized
    renderer based on the value of the `region` attribute, and then redraw the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s only one more thing to do, since this is a script that can be run
    multiple times, let''s have our script automatically remove the existing `continents`
    layer, if it exists, before adding a new one. To do this, we can add the following
    to the start of our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when our script is run, it will create one (and only one) layer that shows
    the various continents in different colors. These will appear as different shades
    of gray in the printed book, but the colors will be visible on the computer screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using different symbols for different features within a map](img/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s use the same data set to color each country based on its relative
    population. We''ll start by removing the existing `"population"` layer, if it
    exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we open the World Borders Dataset into a new layer called `"population"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need to set up our various population ranges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our population ranges and their associated colors, we simply
    set up a graduated symbol renderer to choose a symbol based on the value of the
    `pop2005` attribute, and tell the map to redraw itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be a map layer that shades each country according to its population:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using different symbols for different features within a map](img/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Calculating the distance between two user-defined points
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our final example of using the PyQGIS library, we'll write some code that,
    when run, starts listening for mouse events from the user. If the user clicks
    on a point, drags the mouse, and then releases the mouse button again, we will
    display the distance between those two points. This is a good example of how to
    add your own map interaction logic to QGIS, using the `QgsMapTool` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the basic structure for our `QgsMapTool` subclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: To make this map tool active, we'll create a new instance of it and pass it
    to the `mapCanvas.setMapTool()` method. Once this is done, our `canvasPressEvent()`
    and `canvasReleaseEvent()` methods will be called whenever the user clicks or
    releases the mouse button over the map canvas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the code that responds when the user clicks on the canvas.
    In this method, we''re going to convert from the pixel coordinates that the user
    clicked on to the corresponding map coordinates (that is, a latitude and longitude
    value). We''ll then remember these coordinates so that we can refer to them later.
    Here is the necessary code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `canvasReleaseEvent()` method is called, we''ll want to do the same
    with the point at which the user released the mouse button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the two desired coordinates, we''ll want to calculate the
    distance between them. We can do this using a `QgsDistanceArea` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we divide the resulting value by 1000\. This is because the `QgsDistanceArea`
    object returns the distance in meters, and we want to display the distance in
    kilometers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we''ll display the calculated distance in the QGIS message bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve created our map tool, we need to activate it. We can do this
    by adding the following to the end of our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'With the map tool activated, the user can click and drag on the map. When the
    mouse button is released, the distance (in kilometers) between the two points
    will be displayed in the message bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Calculating the distance between two user-defined points](img/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took an in-depth look at the PyQGIS libraries and how you
    can use them in your own programs. We learned that the QGIS Python libraries are
    implemented as wrappers around the QGIS APIs implemented in C++. We saw how Python
    programmers can understand and work with the QGIS reference documentation, even
    though it is written for C++ developers. We also looked at the way the PyQGIS
    libraries are organized into different packages, and learned about the most important
    classes defined in the `qgis.core` and `qgis.gui` packages.
  prefs: []
  type: TYPE_NORMAL
- en: We then saw how a coordinate reference systems (CRS) is used to translate from
    points on the three-dimensional surface of the Earth to coordinates within a two-dimensional
    map plane.
  prefs: []
  type: TYPE_NORMAL
- en: We learned that vector format data is made up of features, where each feature
    has an ID, a geometry, and a set of attributes, and that symbols are used to draw
    vector geometries onto a map layer, while renderers are used to choose which symbol
    to use for a given feature.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how a spatial index can be used to speed up access to vector features.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we saw how raster format data is organized into bands that represent information
    such as color, elevation, and so on, and looked at the various ways in which a
    raster data source can be displayed within a map layer. Along the way, we learned
    how to access the contents of a raster data source.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at various techniques for performing useful tasks using the
    PyQGIS library.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn more about QGIS Python plugins, and then
    go on to use the plugin architecture as a way of implementing a useful feature
    within a mapping application.
  prefs: []
  type: TYPE_NORMAL
