- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Principals of Data Access – Accessing Your Data
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据访问原则 – 访问您的数据
- en: '**Data access** is a term that refers to the ability to store, retrieve, transfer,
    and copy data from one system or application to another. It crucially involves
    security, legal, and, in some cases, national matters. In addition to the last
    two, we will also cover some security topics in this chapter.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据访问**是一个术语，指的是将数据从一个系统或应用程序存储、检索、传输和复制到另一个系统或应用程序的能力。它涉及安全性、法律，在某些情况下还涉及国家事务。除了最后两点，我们还将在本章中涵盖一些安全主题。'
- en: As data engineers or scientists, knowing how to retrieve data correctly is necessary.
    Some of it may require **encrypted authentication**, and for this, we need to
    understand how some decrypting libraries work and how to use them without compromising
    or leaking sensitive data. Data access also refers to the levels of authorization
    a system or database have, from administration to read-only roles.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作为数据工程师或科学家，知道如何正确检索数据是必要的。其中一些可能需要**加密身份验证**，为此，我们需要了解一些解密库的工作原理以及如何在不泄露敏感数据的情况下使用它们。数据访问还涉及系统或数据库的授权级别，从管理到只读角色。
- en: In this chapter, we will cover how the levels of data access are defined and
    the most used libraries and authentication methods in the data ingestion process.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍数据访问级别是如何定义的，以及在数据摄取过程中最常用的库和身份验证方法。
- en: 'In this chapter, you will work through the following recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将完成以下食谱：
- en: Implementing governance in a data access workflow
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数据访问工作流程中实施治理
- en: Accessing databases and data warehouses
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问数据库和数据仓库
- en: Accessing **SSH File Transfer Protocol** (**SFTP**) ﬁles
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问**SSH文件传输协议**（**SFTP**）文件
- en: Retrieving data using API authentication
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用API身份验证检索数据
- en: Managing encrypted files
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理加密文件
- en: Accessing data from AWS
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从AWS访问数据
- en: Accessing data from GCP
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从GCP访问数据
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: A Google Cloud account can be easily created if you already have a Gmail account,
    and most of the resources can be accessed with a free tier. It also provides $300
    of credit for resources that are not free. It is a good incentive if you want
    to make other tests using the other recipes in this book inside GCP.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经有Gmail账户，可以轻松创建Google Cloud账户，并且大部分资源都可以使用免费层访问。它还提供了300美元的信用额度，用于非免费资源。如果你想在GCP中使用本书中的其他食谱进行其他测试，这是一个很好的激励措施。
- en: To access and enable a Google Cloud account, go to the [https://cloud.google.com/](https://cloud.google.com/)
    page and follow the steps provided on the screen.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问和启用Google Cloud账户，请访问[https://cloud.google.com/](https://cloud.google.com/)页面，并按照屏幕上提供的步骤操作。
- en: Note
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: All the recipes covered in this chapter are eligible to use the free tier.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的所有食谱都适用于免费层。
- en: 'You can also find the code from this chapter in this GitHub repository here:
    [https://github.com/PacktPublishing/Data-Ingestion-with-Python-Cookbook](https://github.com/PacktPublishing/Data-Ingestion-with-Python-Cookbook).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在这个GitHub仓库中找到本章的代码：[https://github.com/PacktPublishing/Data-Ingestion-with-Python-Cookbook](https://github.com/PacktPublishing/Data-Ingestion-with-Python-Cookbook)。
- en: Implementing governance in a data access workflow
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在数据访问工作流程中实施治理
- en: As we saw previously, **data access** or **accessibility** is a **governance**
    pillar and is closely related to security. Data safety is not only a concern for
    administrators or managers but also for everyone that is involved with data. Having
    said that, it is essential to know how to design a base workflow to implement
    security layers for our data, allowing only authorized people to read or manipulate
    it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，**数据访问**或**可访问性**是**治理**支柱，与安全性密切相关。数据安全不仅是管理员或经理的担忧，也是所有与数据相关的人的担忧。话虽如此，了解如何设计一个基础工作流程以实施数据的安全层，只允许授权人员读取或操作数据，这是至关重要的。
- en: This recipe will create a workflow with essential topics to implement data access
    management.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此食谱将创建一个包含实施数据访问管理必要主题的工作流程。
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before designing our workflow, we need to identify the vectors interfering with
    our data access.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计我们的工作流程之前，我们需要确定干扰我们数据访问的向量。
- en: So, what are data vectors?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是数据向量呢？
- en: Vectors are paths someone can use to gain unauthorized access to a server, network,
    or database. In this case, we will identify the ones related to data leaks.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 向量是某人可以用来未经授权访问服务器、网络或数据库的路径。在这种情况下，我们将识别与数据泄露相关的向量。
- en: 'Let’s explore them in a visual form, as shown in the following diagram:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以以下图表所示的形式来探索它们：
- en: '![Figure 2.1 – Data governance vectors](img/Figure_2.1_B19453.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – 数据治理向量](img/Figure_2.1_B19453.jpg)'
- en: Figure 2.1 – Data governance vectors
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 数据治理向量
- en: 'Let us understand each of these stages in the path here:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里理解路径中的每个阶段：
- en: '**Data creation**: In this step, we identify where data is created and by who.
    With this definition, we can ensure only the **accountable** can have access to
    create or update data.'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数据创建**：在这个步骤中，我们确定数据在哪里创建以及由谁创建。有了这个定义，我们可以确保只有**负责**的人可以访问创建或更新数据。'
- en: '**Storage of data**: After creation, it’s important to know where our data
    is or will be stored. Depending on the answer to this question, the methods to
    retrieve data will be different and can require additional steps.'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数据存储**：在创建后，了解我们的数据在哪里或将被存储非常重要。根据这个问题的答案，检索数据的方法将不同，可能需要额外的步骤。'
- en: '**Management of users and services**: Data must be used, and people need access.
    Here, we define the *actors* or the roles we might have, and the common types
    are **administrator**, **write**, and **read-only** roles.'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**用户和服务管理**：数据必须被使用，人们需要访问。在这里，我们定义了**参与者**或我们可能拥有的角色，常见的类型是**管理员**、**写入**和**只读**角色。'
- en: '**Transferring data**: How will our data be transferred? It is essential to
    decide whether it will be real-time, near real-time, or batch. You can add further
    questions to your workflows, such as how the data will be available for transfers
    via API or any other method.'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数据传输**：我们的数据将如何传输？决定它是实时、近实时还是批量传输至关重要。你可以在你的工作流程中添加更多问题，例如数据将通过API或其他方法进行传输时将如何可用。'
- en: How to do it…
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: After identifying our vectors, we can define the implementation workflow for
    data access management.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定我们的向量后，我们可以定义数据访问管理的实施工作流程。
- en: To make it easy to understand how to implement it, let’s imagine a hypothetical
    scenario of a new application where we want to retrieve medical records from patients.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让大家更容易理解如何实现它，让我们设想一个假设的场景，在这个场景中，我们想要从患者那里检索医疗记录。
- en: 'Here is how we do it:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的做法：
- en: The first step is to document all our data and classify it. If there is confidential
    data, we need to work out how to identify it.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是记录所有我们的数据并将其分类。如果有机密数据，我们需要制定如何识别它的方法。
- en: Then, we will start to define who can access the data accordingly with the necessary
    usage. For example, we determine the data administrators and write or read-only
    permissions here.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将开始定义谁可以访问数据，并相应地确定必要的使用权限。例如，我们确定数据管理员并在此处设置读写权限。
- en: Once levels of access to data are implemented, we start observing how users
    will behave. Implementing logs to a database, data warehouse, or any other system
    with user activity is crucial.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦实现了数据访问级别，我们就开始观察用户的操作。将日志记录到数据库、数据仓库或任何其他具有用户活动记录的系统至关重要。
- en: Finally, we examine the whole process to determine whether any change is needed.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们检查整个流程，以确定是否需要任何更改。
- en: 'In the end, we will have a flow diagram similar to the following diagram:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将得到一个类似于以下流程图的流程：
- en: '![Figure 2.2 – A flow diagram to start implementing data governance](img/Figure_2.2_B19453.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – 开始实施数据治理的流程图](img/Figure_2.2_B19453.jpg)'
- en: Figure 2.2 – A flow diagram to start implementing data governance
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 开始实施数据治理的流程图
- en: How it works…
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Data access management is an ongoing process. Every day, we ingest and create
    new pipelines to be used by several people on different teams. Here is how it
    goes:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 数据访问管理是一个持续的过程。每天，我们都会摄取并创建新的管道，供不同团队中的多个人使用。以下是具体步骤：
- en: '**Discovering, classifying, and documenting all your data**: The first thing
    to organize is our data. Which patient’s data are we going to retrieve? Does it
    contain **Personally Identifiable Information** (**PII**) or **Protected/Personal
    Health Information** (**PHI**)? Since it’s the first time we are ingesting this
    data, we need to catalog it with flags about PII and who is responsible for the
    source data.'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**发现、分类和记录所有数据**：首先要组织的是我们的数据。我们将检索哪位患者的数据？它是否包含**个人身份信息**（**PII**）或**受保护/个人健康信息**（**PHI**）？由于这是我们第一次摄取这些数据，我们需要用有关PII和谁负责源数据的标志对其进行编目。'
- en: '**Creating access controls**: Here, we define access based on roles since not
    everybody needs access to patient history. We allocate permissions to data based
    on the roles, responsibilities, and classification.'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建访问控制**：在这里，我们根据角色定义访问权限，因为并非每个人都需要访问患者病史。我们根据角色、职责和分类分配数据权限。'
- en: '**Examining the users’ behaviors**: In this step, we observe how our users
    behave in their roles. The creation, updates, and deletion actions are logged
    to be monitored and reviewed if needed. If a medical department no longer uses
    a report, we can restrict their access or even stop them from ingesting information
    for them.'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**检查用户行为**：在这个步骤中，我们观察用户在其角色中的行为。创建、更新和删除操作被记录下来以便监控和必要时审查。如果医疗部门不再使用某个报告，我们可以限制他们的访问，甚至阻止他们获取信息。'
- en: '**Analyzing and reviewing requirements for compliance**: We must ensure our
    access management follows compliance and local regulations. Legal regulations
    apply differently for different types of data, which needs to be considered.'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**分析和审查合规性要求**：我们必须确保我们的访问管理遵循合规性和当地法规。不同类型的数据有不同的法律规范，这需要考虑。'
- en: See also
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: '*Healthcare Data Breaches* *Statistics*: [https://www.hipaajournal.com/healthcare-data-breach-statistics/](https://www.hipaajournal.com/healthcare-data-breach-statistics/)'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*医疗数据泄露* *统计数据*：[https://www.hipaajournal.com/healthcare-data-breach-statistics/](https://www.hipaajournal.com/healthcare-data-breach-statistics/)'
- en: '*European Data Protection Supervisor. Health data in the* *workspace*: [https://edps.europa.eu/data-protection/data-protection/reference-library/health-data-workplace_en](https://edps.europa.eu/data-protection/data-protection/reference-library/health-data-workplace_en)'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*欧洲数据保护专员。工作空间中的健康数据*：[https://edps.europa.eu/data-protection/data-protection/reference-library/health-data-workplace_en](https://edps.europa.eu/data-protection/data-protection/reference-library/health-data-workplace_en)'
- en: Accessing databases and data warehouses
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问数据库和数据仓库
- en: '**Databases** are the foundation of any system or application, no matter your
    architecture. A database is sometimes needed to store logs, user activities or
    information, and system stuff.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据库**是任何系统或应用的基石，无论你的架构如何。有时需要数据库来存储日志、用户活动或信息，以及系统相关内容。'
- en: Putting it in a bigger perspective, data warehouses have the same usage but
    are related to analytical data. After ingesting and transforming data, we need
    to load it somewhere where it is easier to retrieve analytic information for use
    on dashboards, reports, etc.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从更大的角度来看，数据仓库有相同的用途，但与分析数据相关。在摄取和转换数据后，我们需要将其加载到更容易检索用于仪表板、报告等的地方。
- en: Currently, it is possible to find several types of databases (of the SQL and
    NoSQL types) and data warehouse architectures. However, this recipe aims to cover
    how access control is usually done for both relational structures. The goal is
    to understand how the access levels are defined, even using a generic scenario.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，可以找到多种类型的数据库（SQL和NoSQL类型）和数据仓库架构。然而，这个配方旨在介绍通常如何对关系结构进行访问控制。目标是了解访问级别是如何定义的，即使是在一个通用场景中。
- en: Getting ready
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will use MySQL. You can install it following the instructions
    on the MySQL official page here: [https://dev.mysql.com/downloads/installer/](https://dev.mysql.com/downloads/installer/).'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将使用MySQL。你可以按照MySQL官方页面上的说明进行安装：[https://dev.mysql.com/downloads/installer/](https://dev.mysql.com/downloads/installer/)。
- en: 'You can use any SQL client you choose to execute the queries here. In my case,
    I will use MySQL Workbench:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用你选择的任何SQL客户端来执行这里的查询。在我的情况下，我将使用MySQL Workbench：
- en: 'First, we will create a database using our `root` user. You can name it what
    you like. My recommendation here is to set the charset to `UTF-8`:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将使用我们的`root`用户创建一个数据库。你可以给它取任何名字。我的建议是设置字符集为`UTF-8`：
- en: '[PRE0]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: My schema will be called `cookbook-data`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我的模式将被称为`cookbook-data`。
- en: 'The next step is creating tables. Still using the root account, we will create
    a `people_city` table using the **Data Definition Language** (**DDL**) syntax:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建表。仍然使用root账户，我们将使用**数据定义语言**（**DDL**）语法创建一个`people_city`表：
- en: '[PRE1]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How to do it…
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Note
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Since the last update from MySQL 8.0, we can’t create users directly using
    the `GRANT` command. An error like this will appear:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 自从MySQL 8.0的最后一个更新以来，我们无法直接使用`GRANT`命令创建用户。将出现这样的错误：
- en: '`ERROR 1410 (42000): You are not allowed to create a user` `with GRANT`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`ERROR 1410 (42000): 您不允许使用GRANT创建用户`'
- en: To solve this issue, we will take some additional steps. We will also need at
    least two sessions of MySQL open, so keep that in mind if you opt to execute the
    commands directly on your command line.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将采取一些额外的步骤。我们还需要至少打开两次MySQL，所以如果你选择直接在命令行中执行命令，请记住这一点。
- en: 'I would like to also thank Lefred’s blog for this solution and contribution
    to the community. You can find more details and other useful information at their
    blog here: [https://lefred.be/content/how-to-grant-privileges-to-users-in-mysql-8-0/](https://lefred.be/content/how-to-grant-privileges-to-users-in-mysql-8-0/).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我还想感谢Lefred的博客为此解决方案和对社区的贡献。你可以在他们的博客中找到更多详细信息和其他有用的信息：[https://lefred.be/content/how-to-grant-privileges-to-users-in-mysql-8-0/](https://lefred.be/content/how-to-grant-privileges-to-users-in-mysql-8-0/)。
- en: 'Let us see the steps to perform this recipe:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看执行这个菜谱的步骤：
- en: 'First, let’s create the `admin` user. Here, we will start to have problems
    if we do not follow the following steps correctly. We need to create a user to
    be our superuser or administrator, using our `root user`:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建`admin`用户。在这里，如果我们没有正确遵循以下步骤，我们将会遇到问题。我们需要创建一个用户作为我们的超级用户或管理员，使用我们的`root用户`：
- en: '[PRE2]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, we log in with the `admin` user. Using the password you defined in *step
    1*, log in to the MySQL console using the `admin` user. We can’t see any databases
    yet on the SQL software client, but we will fix this in the following step. After
    logging in to the console, you can see the SQL command ready to be used:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`admin`用户登录。使用你在*步骤1*中定义的密码，使用`admin`用户登录MySQL控制台。在SQL软件客户端上，我们目前还看不到任何数据库，但在接下来的步骤中我们会解决这个问题。登录到控制台后，你可以看到准备使用的SQL命令：
- en: '[PRE3]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Keep this session open.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 保持此会话开启。
- en: 'Then, we grant permissions to the `admin` user by role. In the root session,
    let’s create a role called `administration` and grant full access to our database
    to the `admin` user:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过角色授予`admin`用户权限。在root会话中，让我们创建一个名为`administration`的角色，并将数据库的完全访问权限授予`admin`用户：
- en: '[PRE4]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We then grant permissions to the role:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们授予角色权限：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We then grant the role to our `admin` user:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将角色授予我们的`admin`用户：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We then set this role as the default:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将此角色设置为默认：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Next, like in *step 2*, we create another two users, the `write` and `read-only`
    roles.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，就像在*步骤2*中一样，我们创建另外两个用户，`write`和`read-only`角色。
- en: 'Repeat *step 3*, giving the new roles names, and for these two roles, my recommendation
    is to grant the following privileges:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 重复*步骤3*，给出新的角色名称，并且对于这两个角色，我的建议是授予以下权限：
- en: '`alter`, `create`, `index`, `insert`, `select`, `update`, `trigger`, `alter
    routine`, `create routine`, `execute`, and `create` `temporary tables`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alter`、`create`、`index`、`insert`、`select`、`update`、`trigger`、`alter routine`、`create
    routine`、`execute`和`create` `temporary tables`'
- en: '`select` and `execute`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`select`和`execute`'
- en: 'Next, we perform the actions. If we try to perform `INSERT` using our `admin`
    or `write` roles, we can see it is viable:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们执行操作。如果我们尝试使用我们的`admin`或`write`角色执行`INSERT`，我们可以看到它是可行的：
- en: '[PRE8]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'However, the same can’t be done by the `read-only` user:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`read-only`用户却不能这样做：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works…
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In a real-world project, most of the time, there is a dedicated person (or database
    administrator) to handle and take care of access to databases or data warehouses.
    Nonetheless, any person who needs to access a relational data source needs to
    understand the basic concepts of the access levels to ask for its permissions
    (and justify it).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际项目中，大多数情况下，会有一个专门的人员（或数据库管理员）来处理和照顾数据库或数据仓库的访问。尽管如此，任何需要访问关系型数据源的人员都需要了解访问级别的基本概念，以便请求其权限（并证明其合理性）。
- en: In this recipe, we used a `show` `privileges` command.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用了`show` `privileges`命令。
- en: '`alter`, `create`, `delete`, `drop`, `index`, `insert`, `select`, `update`,
    `trigger`, `alter routine`, `create routine`, `execute`, and `create temporary
    tables` are the common commands used daily, and knowing them makes it easier to
    identify an error. Let’s take, for example, the earlier error:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`alter`、`create`、`delete`、`drop`、`index`、`insert`、`select`、`update`、`trigger`、`alter
    routine`、`create routine`、`execute`和`create temporary tables`是日常使用中常用的命令，了解它们有助于更容易地识别错误。以先前的错误为例：'
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first line shows precisely the permission we need. The second line shows
    us which user (`reader`) lacks permission, the connection they are using `(@localhost`),
    and the table (`people_city`) they want to access.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行精确地显示了我们需要权限。第二行显示了哪个用户（`reader`）缺少权限，他们使用的连接`(@localhost)`，以及他们想要访问的表（`people_city`）。
- en: In addition, if you are a system administrator, you can also identify behavior
    that is not allowed and help to solve it.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你是系统管理员，你也可以识别出不被允许的行为并帮助解决它。
- en: There’s more…
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'If you are interested to know more, it is also possible to find three other
    types of access control for databases and data warehouses:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣了解更多，也可以找到数据库和数据仓库的另外三种访问控制类型：
- en: '**Discretionary Access** **Control** (**DAC**)'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自主访问控制**（**DAC**）'
- en: '**Mandatory Access** **Control** (**MAC**)'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强制访问控制**（**MAC**）'
- en: '**Attribute-Based Access** **Control** (**ABAC**)'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于属性的访问控制**（**ABAC**）'
- en: 'The following figure illustrates access control in a summarized version, as
    follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 下图以简化的形式说明了访问控制，如下所示：
- en: '![Figure 2.3 – A database access control comparison – source: https://www.cloudradius.com/access-control-paradigms-compared-rbac-vs-pbac-vs-abac/](img/Figure_2.3_B19453.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3 – 数据库访问控制比较 – 来源：[https://www.cloudradius.com/access-control-paradigms-compared-rbac-vs-pbac-vs-abac/](https://www.cloudradius.com/access-control-paradigms-compared-rbac-vs-pbac-vs-abac/)](img/Figure_2.3_B19453.jpg)'
- en: 'Figure 2.3 – A database access control comparison – source: https://www.cloudradius.com/access-control-paradigms-compared-rbac-vs-pbac-vs-abac/'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – 数据库访问控制比较 – 来源：[https://www.cloudradius.com/access-control-paradigms-compared-rbac-vs-pbac-vs-abac/](https://www.cloudradius.com/access-control-paradigms-compared-rbac-vs-pbac-vs-abac/)
- en: 'Even though it is not described in the preceding figure, we can also find databases
    that use **row and column-based access control**. You can find out more about
    it here: [https://documentation.datavirtuality.com/23/reference-guide/authentication-access-control-and-security/access-control/data-roles/permissions/row-and-column-based-security](https://documentation.datavirtuality.com/23/reference-guide/authentication-access-control-and-security/access-control/data-roles/permissions/row-and-column-based-security).'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 即使前一个图中没有描述，我们也可以找到使用**基于行和列的访问控制**的数据库。更多关于它的信息可以在这里找到：[https://documentation.datavirtuality.com/23/reference-guide/authentication-access-control-and-security/access-control/data-roles/permissions/row-and-column-based-security](https://documentation.datavirtuality.com/23/reference-guide/authentication-access-control-and-security/access-control/data-roles/permissions/row-and-column-based-security).
- en: See also
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考信息
- en: 'Here is an article by *Raimundas Matulevicius* and *Henri Lakk* on RBAC that
    discusses in depth the best approaches in several cases: [https://www.researchgate.net/publication/281479020_A_Model-driven_Role-based_Access_Control_for_SQL_Databases](https://www.researchgate.net/publication/281479020_A_Model-driven_Role-based_Access_Control_for_SQL_Databases)'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里是*Raimundas Matulevicius*和*Henri Lakk*关于RBAC的文章，深入讨论了几个案例中的最佳方法：[https://www.researchgate.net/publication/281479020_A_Model-driven_Role-based_Access_Control_for_SQL_Databases](https://www.researchgate.net/publication/281479020_A_Model-driven_Role-based_Access_Control_for_SQL_Databases)
- en: 'This article by *Arundhati Singh* offers a perspective on RBAC mode implementation
    in enterprise networks: [https://dspace.mit.edu/bitstream/handle/1721.1/87870/53700676-MIT.pdf?sequence=2](https://dspace.mit.edu/bitstream/handle/1721.1/87870/53700676-MIT.pdf?sequence=2)'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这篇文章由*Arundhati Singh*撰写，提供了关于企业网络中RBAC模式实现的视角：[https://dspace.mit.edu/bitstream/handle/1721.1/87870/53700676-MIT.pdf?sequence=2](https://dspace.mit.edu/bitstream/handle/1721.1/87870/53700676-MIT.pdf?sequence=2)
- en: Accessing SSH File Transfer Protocol (SFTP) ﬁles
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问SSH文件传输协议（SFTP）文件
- en: The **File Transfer Protocol** (**FTP**) was introduced in the 1970s at **Massachusetts
    Institute of Technology** (**MIT**) and is based on the **Transmission Control
    Protocol/Internet Protocol** (**TCP/IP**) application layer. Since the 1980s,
    it has been widely used to transfer files between computers.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件传输协议**（**FTP**）于20世纪70年代在**麻省理工学院**（**MIT**）推出，基于**传输控制协议/互联网协议**（**TCP/IP**）的应用层。自20世纪80年代以来，它被广泛用于在计算机之间传输文件。'
- en: Over the years, and with the increase in computer and internet usage, it became
    necessary to introduce a more secure way to use this solution. An **SSH layer**
    was implemented to improve the security of **FTP transactions**, creating the
    **SSH File Transfer Protocol** (**SFTP**) protocol.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 随着计算机和互联网使用的增加，多年来，引入一种更安全的解决方案使用方式变得必要。为了提高**FTP事务**的安全性，实现了**SSH层**，创建了**SSH文件传输协议**（**SFTP**）协议。
- en: Nowadays, it is common to ingest data from SFTP servers, and in this recipe,
    we will work to retrieve data from a public SFTP server.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从SFTP服务器中获取数据是很常见的，在这个菜谱中，我们将努力从公共SFTP服务器检索数据。
- en: Getting ready
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will create code with Python, using the `pysftp` library,
    to connect and retrieve sample data from a public SFTP server.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用Python和`pysftp`库编写代码，以连接并从公共SFTP服务器检索样本数据。
- en: 'If you own an SFTP server, feel free to test the Python code here to exercise
    a little more:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你拥有SFTP服务器，可以自由地测试这里提供的Python代码来练习更多：
- en: First, we will get the SFTP credentials. Go to the SFTP.NET address at https://www.sftp.net/public-online-sftp-servers,
    and save the **Hostname** and **Login** (username/password) information on a notepad.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将获取SFTP凭证。访问SFTP.NET地址https://www.sftp.net/public-online-sftp-servers，并在记事本上保存**主机名**和**登录**（用户名/密码）信息。
- en: '![Figure 2.4 – The SFTP.NET main page](img/Figure_2.4_B19453.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4 – SFTP.NET主页](img/Figure_2.4_B19453.jpg)'
- en: Figure 2.4 – The SFTP.NET main page
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – SFTP.NET主页
- en: Note
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This SFTP server is intended to be used only for testing and studying purposes.
    Because of that, the credentials are insecure and publicly available, and for
    production purposes, that information needs to be secured in a password vault
    and never shared through code.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此SFTP服务器仅用于测试和研究目的。因此，凭证是不安全的，并且是公开可用的；对于生产目的，该信息需要在密码保险库中安全存储，并且永远不要通过代码共享。
- en: 'Then, we install the Python `pysftp` package using the command line:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用命令行安装Python的`pysftp`包：
- en: '[PRE11]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How to do it…
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Here are the steps to perform this recipe:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此菜谱的步骤如下：
- en: 'First, let’s create a Python file called `accessing_sftp_files.py`. Then, we
    insert the following code to create our SFTP connection with Python:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个名为`accessing_sftp_files.py`的Python文件。然后，我们插入以下代码以使用Python创建我们的SFTP连接：
- en: '[PRE12]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can call the file using the following command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令调用该文件：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here is the output for it:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的输出：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, a known error might occur – `SSHException: No hostkey for host` `test.rebex.net
    found`.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，可能会出现一个已知错误——`SSHException: No hostkey for host` `test.rebex.net found`.'
- en: This happens because pysftp can’t find hostkey in your KnowHosts.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为pysftp在您的KnowHosts中找不到hostkey。
- en: 'If this error occurs, follow the next steps:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现此错误，请按照以下步骤操作：
- en: 'Go to your command line and execute `ssh demo@test.rebex.net`:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的命令行并执行`ssh demo@test.rebex.net`：
- en: '![Figure 2.5 – Adding a host to the known_hosts list](img/Figure_2.5_B19453.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5 – 将主机添加到known_hosts列表](img/Figure_2.5_B19453.jpg)'
- en: Figure 2.5 – Adding a host to the known_hosts list
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – 将主机添加到known_hosts列表
- en: 'Insert the password for the `demo` user and exit Rebex Virtual Shell:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`demo`用户的密码并退出Rebex虚拟外壳：
- en: '![Figure 2.6 – A welcome message from the Rebex SFTP server](img/Figure_2.6_B19453.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6 – 来自Rebex SFTP服务器的欢迎信息](img/Figure_2.6_B19453.jpg)'
- en: Figure 2.6 – A welcome message from the Rebex SFTP server
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – 来自Rebex SFTP服务器的欢迎信息
- en: 'Then, we list the files in the SFTP server:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们列出SFTP服务器上的文件：
- en: '[PRE15]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, let’s download the `readme.txt` file:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们下载`readme.txt`文件：
- en: 'Let’s change the last lines of our code to be able to download `readme.txt`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将代码的最后几行修改一下，以便能够下载`readme.txt`：
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output for this is as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 其输出如下：
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works…
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`pysftp` is a Python library that allows developers to connect, upload, and
    download data from SFTP servers. Its use is straightforward, and the library has
    tons of functionalities.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`pysftp`是一个Python库，允许开发者连接、上传和从SFTP服务器下载数据。它的使用很简单，并且该库具有众多功能。'
- en: Note that most of our code is indented inside `pysftp.Connection`. This happens
    because we create a connection session for that particular credential. The `with`
    statement makes the acquisition and release of the resources, and as you can see,
    it is widely used in file streams, locks, sockets, and so on.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的大部分代码都位于`pysftp.Connection`内部缩进。这是因为我们为特定凭证创建了一个连接会话。`with`语句负责资源的获取和释放，如您所见，它在文件流、锁、套接字等中广泛使用。
- en: We also used the `sftp.cwd()` method, allowing us to change the directory and
    avoid specifying the path whenever we need to list or retrieve files.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了`sftp.cwd()`方法，允许我们更改目录，并在需要列出或检索文件时避免指定路径。
- en: Finally, the download was made using `sftp.get()`, where the first parameter
    is the path and the name of the file we want to download, and the second is where
    we will put it. Since we are already inside the file’s directory, we can save
    it in our local `HOME` directory.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用`sftp.get()`完成了下载，其中第一个参数是我们想要下载的文件的路径和名称，第二个参数是我们将放置它的位置。由于我们已经在文件的目录中，我们可以将其保存在我们的本地`HOME`目录中。
- en: Last but not least, `sftp.close()` closes the connection. This is excellent
    practice in ingesting scripts to avoid network concurrency with other pipelines
    or the SFTP server.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，`sftp.close()`关闭了连接。这是在脚本中避免与网络并发或其他管道或SFTP服务器的好做法。
- en: There’s more…
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: If you want to go deeper and make other tests, you can also create a local SFTP
    server.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想深入了解并进行其他测试，您还可以创建一个本地SFTP服务器。
- en: 'For Linux users, it is possible to do this using the `ssh` command line. You
    can see more here: [https://linuxhint.com/setup-sftp-server-ubuntu/](https://linuxhint.com/setup-sftp-server-ubuntu/).'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Linux用户来说，可以使用`ssh`命令行来完成这项操作。更多内容请查看这里：[https://linuxhint.com/setup-sftp-server-ubuntu/](https://linuxhint.com/setup-sftp-server-ubuntu/).
- en: 'For Windows users, go to the **SFTP Servers** section here: [https://www.sftp.net/servers](https://www.sftp.net/servers).'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows用户，请转到此处的**SFTP服务器**部分：[https://www.sftp.net/servers](https://www.sftp.net/servers).
- en: '![Figure 2.7 – The SFTP.NET page, with a link to a tutorial on how to create
    a small SFTP server](img/Figure_2.7_B19453.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.7 – SFTP.NET 页面，包含创建小型 SFTP 服务器的教程链接](img/Figure_2.7_B19453.jpg)'
- en: Figure 2.7 – The SFTP.NET page, with a link to a tutorial on how to create a
    small SFTP server
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 – SFTP.NET 页面，包含创建小型 SFTP 服务器的教程链接
- en: Select **Rebex Tiny SFTP Server** under **Minimalist SFTP servers**, download
    it, and start the program.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **Minimalist SFTP servers** 下选择 **Rebex Tiny SFTP Server**，下载并启动程序。
- en: See also
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Creating a local SFTP server with Docker: [https://hub.docker.com/r/atmoz/sftp](https://hub.docker.com/r/atmoz/sftp)'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker 创建本地 SFTP 服务器：[https://hub.docker.com/r/atmoz/sftp](https://hub.docker.com/r/atmoz/sftp)
- en: Retrieving data using API authentication
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 API 身份验证获取数据
- en: An **Application Programming Interface** (**API**) is a set of configurations
    that allows two systems or applications to communicate or transmit data with each
    other. Its concept has been improved in recent years, allowing faster transmissions
    and more security with **OAuth** methods, preventing **Denial of Service** (**DoS**)
    or **Distributed Denial of Service** (**DDoS**) attacks, and so on.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用程序编程接口（API**）是一组配置，允许两个系统或应用程序相互通信或传输数据。近年来，其概念得到了改进，允许使用 **OAuth** 方法实现更快的传输和更高的安全性，防止
    **拒绝服务（DoS**）或 **分布式拒绝服务（DDoS**）攻击等。'
- en: Its use is widely applied in data ingesting, whether to retrieve data from an
    application to retrieve the latest logs for analysis or from **BigQuery** using
    a cloud provider such as Google. Most applications nowadays make their data available
    through an API service, from which the data world gets a lot of benefits. The
    critical aspect here is to know how to retrieve data from an API service using
    the most accepted forms of authentication.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 它在数据摄取中得到了广泛应用，无论是从应用程序中检索数据以获取分析的最新日志，还是从 **BigQuery** 使用云服务提供商（如 Google）检索数据。如今，大多数应用程序都通过
    API 服务提供其数据，这使得数据世界从中获得了许多好处。关键在于知道如何使用最接受的认证形式从 API 服务中检索数据。
- en: In this recipe, we will retrieve data from a public API using API key authentication,
    a standard method to gather data.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用 API 密钥身份验证从公共 API 获取数据，这是一种标准的数据收集方法。
- en: Getting ready
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Since we will use two different methods, this section will be split to make
    it easy to understand how to handle them.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用两种不同的方法，本节将分为两部分，以便更容易理解如何处理它们。
- en: 'For this section, we will use the HolidayAPI, a public and free API that provides
    information about holidays worldwide:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节，我们将使用 HolidayAPI，这是一个公开且免费的 API，提供有关全球假期的信息：
- en: 'Install the Python `requests` library:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Python 的 `requests` 库：
- en: '[PRE18]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, access the Holiday API website. Go to [https://holidayapi.com/](https://holidayapi.com/)
    and click on **Get Your Free API Key**. You should see the following page:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，访问 Holiday API 网站。访问 [https://holidayapi.com/](https://holidayapi.com/) 并点击
    **获取您的免费 API 密钥**。你应该会看到以下页面：
- en: '![Figure 2.8 – The Holidays API main web page](img/Figure_2.8_B19453.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.8 – Holidays API 主网页](img/Figure_2.8_B19453.jpg)'
- en: Figure 2.8 – The Holidays API main web page
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 – Holidays API 主网页
- en: 'Then, we create an account and get the API Key. To create an account, you can
    use an email and password or sign up with your GitHub account:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个账户并获取 API 密钥。要创建账户，您可以使用电子邮件和密码，或者使用 GitHub 账户注册：
- en: '![Figure 2.9 – The Holiday API user authentication page](img/Figure_2.9_B19453.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.9 – Holiday API 用户身份验证页面](img/Figure_2.9_B19453.jpg)'
- en: Figure 2.9 – The Holiday API user authentication page
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9 – Holiday API 用户身份验证页面
- en: After the authentication, you can see and copy your API Key. Note that you can
    also generate a new one at any time.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证后，你可以看到并复制你的 API 密钥。请注意，你可以在任何时候生成一个新的密钥。
- en: '![Figure 2.10 – The user dashboard page on the Holiday API page](img/Figure_2.10_B19453.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.10 – Holiday API 页面上的用户仪表板页面](img/Figure_2.10_B19453.jpg)'
- en: Figure 2.10 – The user dashboard page on the Holiday API page
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10 – Holiday API 页面上的用户仪表板页面
- en: Note
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We will use the free tier of this API, which has limited requests per month.
    It is also prohibited from commercial use.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用此 API 的免费层，每月请求量有限。它也禁止用于商业用途。
- en: How to do it…
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Here are the steps to perform the recipe:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是执行菜谱的步骤：
- en: 'We create a Python script using the `requests` library:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `requests` 库创建一个 Python 脚本：
- en: '[PRE19]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Ensure you use a `year` value equal to your previous year since we are using
    a free version of the API, which is limited to last year’s historical data.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您使用与上一年相同的 `year` 值，因为我们正在使用 API 的免费版本，该版本仅限于去年的历史数据。
- en: 'Here is the output for the code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是代码的输出：
- en: '[PRE20]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As a best practice, the API key should never be hardcoded in the script. The
    definition here is for educational purposes.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最佳实践，API 密钥绝不应该在脚本中硬编码。这里的定义仅用于教育目的。
- en: 'Then, we save our API request as a JSON file:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将我们的 API 请求保存为 JSON 文件：
- en: '[PRE21]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works…
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The Python `requests` library is one of the most downloaded libraries on the
    PyPi servers. This popularity is not surprising, as we will see when we work with
    the library and see its power and versatility.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `requests` 库是 PyPi 服务器上下载量最大的库之一。这种流行度并不令人惊讶，因为我们将在使用库时看到它的强大和多功能性。
- en: In *step 1*, we imported both the `requests` and `json` modules at the beginning
    of the Python script. The `params` dictionary is a payload sender to the API,
    so we inserted the API key and the two other mandatory fields.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 1* 中，我们在 Python 脚本的开始处导入了 `requests` 和 `json` 模块。`params` 字典是发送到 API 的有效载荷发送者，因此我们插入了
    API 密钥和另外两个必填字段。
- en: Note
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This API authorization key was sent through a payload request; however, it depends
    on how the API is built. Some request that the authentication is sent via `Header`
    definitions, for instance. Always check the API documentation or developer to
    understand how to authenticate correctly.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 此 API 授权密钥是通过有效载荷请求发送的；然而，这取决于 API 的构建方式。一些请求要求通过 `Header` 定义发送认证，例如。始终检查 API
    文档或开发者以了解如何正确认证。
- en: The `print()` function in *step 1* served as a test to see whether our calls
    were authenticated.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 1* 中的 `print()` 函数用作测试，以查看我们的调用是否已认证。
- en: 'With the API call returning a `200` status code, we proceed to save the `JSON`
    file, and you should have output like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当 API 调用返回 `200` 状态码时，我们继续保存 `JSON` 文件，您应该有如下输出：
- en: '![Figure 2.11 – The downloaded JSON file data](img/Figure_2.11_B19453.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.11 – 下载的 JSON 文件数据](img/Figure_2.11_B19453.jpg)'
- en: Figure 2.11 – The downloaded JSON file data
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11 – 下载的 JSON 文件数据
- en: There’s more…
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: API keys are commonly used to authenticate clients, but other security methods
    such as OAuth should be considered, depending on the data sensitivity level.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: API 密钥通常用于认证客户端，但根据数据敏感性级别，还应考虑其他安全方法，如 OAuth。
- en: Note
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: API key authentication can only be considered secure if associated with other
    security mechanisms such as HTTPS/SSL.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果与 HTTPS/SSL 等其他安全机制相关联，API 密钥认证才能被认为是安全的。
- en: Authentication using the OAuth method
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 OAuth 方法进行认证
- en: '**Open Authorization** (**OAuth**) is an industry-standard protocol to authorize
    websites or applications to communicate and access informa[tion. You can find](https://oauth.net/2/)
    out more about it on the official documentation page here: [https://oauth.net/2/](https://oauth.net/2/).'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**开放授权**（**OAuth**）是一个行业标准协议，用于授权网站或应用程序进行通信和访问信息。您可以在官方文档页面这里了解更多信息：[https://oauth.net/2/](https://oauth.net/2/)'
- en: You can also test this type of authentication with the **Google Calendar API**.
    To enable the OAuth met[hod, follow these steps:](https://edps.europa.eu/data-protection/data-protection/reference-library/health-data-workplace_en)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 **Google 日历 API** 测试此类型的认证。要启用 OAuth 方法，请按照以下步骤操作：(https://edps.europa.eu/data-protection/data-protection/reference-library/health-data-workplace_en)
- en: '[Enable the Google Calendar API by](https://edps.europa.eu/data-protection/data-protection/reference-library/health-data-workplace_en)
    visiting the page at [https://developers.google.com/calendar/api/quickstart/python](https://developers.google.com/calendar/api/quickstart/python),
    and then go to the **Enable** **APIs** section.'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过访问页面 [https://developers.google.com/calendar/api/quickstart/python](https://developers.google.com/calendar/api/quickstart/python)
    来 **启用 Google 日历 API**，然后转到 **启用** **API** 部分。
- en: A new tab will open, and **Google Cloud** will ask you to select or create a
    new project. Select the project you want to use.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 将打开一个新标签页，**Google Cloud** 将要求您选择或创建一个新项目。选择您想要使用的项目。
- en: Note
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you opt to create a new project, insert the project name in the **Project’s
    Name** field and leave the **Organization** field with the default value (**No
    Organization**).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择创建一个新项目，请在 **项目名称** 字段中输入项目名称，并将 **组织** 字段保留为默认值（**无组织**）。
- en: 'Select **Next** to confirm your project, and then click on **Activate**; you
    should then see this page:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 **下一步** 以确认您的项目，然后点击 **激活**；您应该会看到这个页面：
- en: '![Figure 2.12 – The GCP page to activate a resource API](img/Figure_2.12_B19453.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.12 – 激活资源 API 的 GCP 页面](img/Figure_2.12_B19453.jpg)'
- en: Figure 2.12 – The GCP page to activate a resource API
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12 – 激活资源API的GCP页面
- en: Now, we are almost ready to get our credentials.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们几乎准备好获取我们的凭证了。
- en: Enable OAuth authentication by returning to the page at [https://developers.google.com/calendar/api/quickstart/python](https://developers.google.com/calendar/api/quickstart/python),
    clicking on **Go to Credentials**, and following the instructions under **Authorize
    credentials for a** **desktop application**.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过返回到[https://developers.google.com/calendar/api/quickstart/python](https://developers.google.com/calendar/api/quickstart/python)页面，点击**转到凭证**，并遵循**为桌面应用程序授权凭证**下的说明来启用OAuth认证。
- en: '![Figure 2.13 – GCP tutorial page to create the credentials.json file](img/Figure_2.13_B19453.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图2.13 – 创建credentials.json文件的GCP教程页面](img/Figure_2.13_B19453.jpg)'
- en: Figure 2.13 – GCP tutorial page to create the credentials.json file
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13 – 创建credentials.json文件的GCP教程页面
- en: At the end of this, you should have a `credentials.json` file for this recipe.
    Keep this file safe, since all calls to the Google API will require it to verify
    your authenticity.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您应该为这个配方有一个`credentials.json`文件。请妥善保管此文件，因为所有对Google API的调用都需要它来验证您的真实性。
- en: 'You can use one of the GCP script examples to test this authentication method.
    Google has a Python script sample to retrieve data from the **Google Calendar
    API**, which can be accessed here: [https://github.com/googleworkspace/python-samples/blob/main/calendar/quickstart/quickstart.py](https://github.com/googleworkspace/python-samples/blob/main/calendar/quickstart/quickstart.py).'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用GCP脚本示例之一来测试此认证方法。Google提供了一个用于从**Google日历API**检索数据的Python脚本示例，可以在此处访问：[https://github.com/googleworkspace/python-samples/blob/main/calendar/quickstart/quickstart.py](https://github.com/googleworkspace/python-samples/blob/main/calendar/quickstart/quickstart.py)。
- en: Other authentication methods
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他认证方法
- en: Even though we covered the two most common methods to authenticate to an API,
    a data ingestion pipeline is not limited to In your day-to-day work, you're likely
    to find legacy systems or applications that require other forms of authentication.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经介绍了两种最常用的API认证方法，但数据摄取管道并不局限于这些。在您的日常工作中，您可能会遇到需要其他形式认证的遗留系统或应用程序。
- en: 'Methods such as **HTTP Basic and Bearer**, **OpenID Connect**, and **OpenAPI
    security schemes** are also widely used. You can find more details about them
    in this article written by *Guy* *Levin*: [https://blog.restcase.com/4-most-used-rest-api-authentication-methods/](https://blog.restcase.com/4-most-used-rest-api-authentication-methods/).'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**HTTP基本认证**、**Bearer**、**OpenID Connect**和**OpenAPI安全方案**等方法也广泛使用。您可以在由*Guy*
    *Levin*撰写的这篇文章中找到更多关于它们的信息：[https://blog.restcase.com/4-most-used-rest-api-authentication-methods/](https://blog.restcase.com/4-most-used-rest-api-authentication-methods/)。'
- en: SFTP versus API
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SFTP与API的比较
- en: You might be wondering, what is the difference between ingesting data from an
    SFTP server and an API? It is clear that they authenticate differently, and the
    code also behaves distinctly. But when should we implement an SFTP or API to make
    data available for ingestion?
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道，从SFTP服务器和API中摄取数据有什么区别？很明显，它们的认证方式不同，代码的行为也各不相同。但我们应该在何时实现SFTP或API来使数据可用于摄取？
- en: FTP or SFTP transactions are designed to use **flat files**, such as **CSV**,
    **XML**, and **JSON** files. These two types of transactions also perform well
    when we need to transfer bulk data, and it is the only method available for older
    systems. An API provides real-time data delivery and a more secure internet-based
    connection, and its integration with several cloud applications has made it popular
    in the data ingestion world. However, API calls are sometimes paid for based on
    the number of requests.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: FTP或SFTP事务旨在使用**平面文件**，例如**CSV**、**XML**和**JSON**文件。这两种类型的事务在需要传输大量数据时也表现良好，并且是旧系统唯一可用的方法。API提供实时数据交付和更安全的基于互联网的连接，并且由于其与多个云应用程序的集成，在数据摄取领域变得流行。然而，API调用有时是根据请求数量付费的。
- en: This file transaction architecture discussion is primarily for financial and
    HR systems, which may use some old programming language versions. The system architecture
    discussion is based on flat files or real-time data in more recent and cloud-based
    applications.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 本文件事务架构讨论主要针对金融和人力资源系统，这些系统可能使用一些旧的编程语言版本。系统架构讨论基于更现代和基于云的应用程序中的平面文件或实时数据。
- en: See also
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'You can find a list of public APIs with different types of auth methods here:
    [https://github.com/public-apis/public-apis](https://github.com/public-apis/public-apis)'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在此处找到具有不同类型认证方法的公共API列表：[https://github.com/public-apis/public-apis](https://github.com/public-apis/public-apis)
- en: 'The Holiday API Python Client: [https://github.com/holidayapi/holidayapi-python](https://github.com/holidayapi/holidayapi-python)'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Holiday API Python 客户端：[https://github.com/holidayapi/holidayapi-python](https://github.com/holidayapi/holidayapi-python)
- en: 'The Python `requests` library documentation: [https://requests.readthedocs.io/en/latest/user/quickstart/](https://requests.readthedocs.io/en/latest/user/quickstart/)'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python `requests` 库文档：[https://requests.readthedocs.io/en/latest/user/quickstart/](https://requests.readthedocs.io/en/latest/user/quickstart/)
- en: Managing encrypted ﬁles
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理加密文件
- en: When handling sensitive data is common, some fields or even the entire file
    is encrypted. It is comprehensive when this file security measure is implemented
    since sensitive data can expose the life of users. After all, encryption is the
    process of converting information into code that hides the original content.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理敏感数据是常见的情况时，一些字段甚至整个文件都会被加密。当实施这种文件安全措施时，这是全面的，因为敏感数据可能会暴露用户的生命。毕竟，加密是将信息转换为隐藏原始内容的代码的过程。
- en: Nonetheless, we must still ingest and process these encrypted files in our data
    pipelines. To be able to do so, we need to understand a bit more about how encryption
    works and how it is done.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们仍然需要在我们的数据管道中摄取和处理这些加密文件。为了能够做到这一点，我们需要了解更多关于加密是如何工作以及如何进行的。
- en: In this recipe, we will decrypt a GnuPG-encrypted (where **GnuPG** stands for
    **GNU Privacy Guard**) file using Python libraries and best practices.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用 Python 库和最佳实践解密 GnuPG 加密的文件（其中 **GnuPG** 代表 **GNU Privacy Guard**）。
- en: Getting ready
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before jumping into the fun part, we must install the GnuPG library on our local
    machine and download the encrypted dataset.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入有趣的部分之前，我们必须在本地机器上安装 GnuPG 库并下载加密的数据集。
- en: 'You will need two installations for the GnuPG file – one for the **operating
    system** (**OS**) and another for a Python package. This because the Python package
    requires internal resources from the installed OS package:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 GnuPG 文件，您需要安装两个版本 – 一个用于 **操作系统**（**OS**），另一个用于 Python 包。这是因为 Python 包需要从已安装的
    OS 包中获取内部资源：
- en: 'To use the Python wrapper library, we first need to install the GnuPG on our
    local machine:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用 Python 封装库，我们首先需要在本地机器上安装 GnuPG：
- en: '[PRE22]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For Windows users, it is recommended to download the executable file here:
    [https://gnupg.org/download/index.xhtml](https://gnupg.org/download/index.xhtml).'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows 用户，建议在此处下载可执行文件：[https://gnupg.org/download/index.xhtml](https://gnupg.org/download/index.xhtml)。
- en: 'Mac users can install it using Homebrew: [https://formulae.brew.sh/formula/gnupg](https://formulae.brew.sh/formula/gnupg).'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Mac 用户可以使用 Homebrew 安装它：[https://formulae.brew.sh/formula/gnupg](https://formulae.brew.sh/formula/gnupg)。
- en: 'Then, we install the Python GnuPG wrapper as follows:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们按照以下方式安装 Python GnuPG 封装库：
- en: '[PRE23]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we download the **spotify tracks chart encrypted** dataset. You can use
    this link to download the file: [https://github.com/PacktPublishing/Data-Ingestion-with-Python-Cookbook/tree/main/Chapter_2/managing_encrypted_%EF%AC%81les](https://github.com/PacktPublishing/Data-Ingestion-with-Python-Cookbook/tree/main/Chapter_2/managing_encrypted_%EF%AC%81les).'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们下载 **spotify tracks chart encrypted** 加密数据集。您可以使用此链接下载文件：[https://github.com/PacktPublishing/Data-Ingestion-with-Python-Cookbook/tree/main/Chapter_2/managing_encrypted_%EF%AC%81les](https://github.com/PacktPublishing/Data-Ingestion-with-Python-Cookbook/tree/main/Chapter_2/managing_encrypted_%EF%AC%81les)。
- en: How to do it…
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We will need a key to decrypt the file using GnuPG. You can find it in the
    `| Managing encrypted ﬁles` folder. The link to access it is in the *Technical
    requirements* section at the beginning of this chapter:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要一个密钥来使用 GnuPG 解密文件。您可以在 `| 管理加密文件` 文件夹中找到它。访问链接在本书开头的 *技术要求* 部分中：
- en: 'First, we import our key:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入我们的密钥：
- en: '[PRE24]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we decrypt the ingestion file:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们解密导入文件：
- en: '[PRE25]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works…
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Regarding the best practices for encrypting, GnuPG is a security reference
    and widely used, and it is documented in **RFC 4880**. You can find out more here:
    [https://www.rfc-editor.org/rfc/rfc4880](https://www.rfc-editor.org/rfc/rfc4880).'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 关于加密的最佳实践，GnuPG 是一个安全参考，广泛使用，并在 **RFC 4880** 中进行了记录。您可以在以下链接中了解更多信息：[https://www.rfc-editor.org/rfc/rfc4880](https://www.rfc-editor.org/rfc/rfc4880)。
- en: Note
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A **Request for Comments** (**RFC**) is a technical documentation developed
    and maintained by the **Internet Engineering Task Force** (**IETF**). This institute
    specifies the best practices for protocols, services, and patterns on the internet.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**请求评论**（**RFC**）是由 **互联网工程任务组**（**IETF**）开发和维护的技术文档。该机构规定了互联网上协议、服务和模式的最佳实践。'
- en: 'Here, we saw a real-life example of GnuPG application, even though it seems
    simple. Let’s pass through some important lines in the code:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到了一个 GnuPG 应用程序的实际例子，尽管它看起来很简单。让我们通过代码中的一些重要行来了解一下：
- en: In the `gpg = gnupg.GPG(gnupghome='gpghome')` line, we instantiated our `GPG`
    class and passed where it can store temporary files, and you can set any path
    you want to. In my case, I created a folder in my home directory called `gpghome`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `gpg = gnupg.GPG(gnupghome='gpghome')` 这一行中，我们实例化了我们的 `GPG` 类，并传递了它存储临时文件的位置，你可以设置任何你想要的路径。在我的情况下，我在我的主目录中创建了一个名为
    `gpghome` 的文件夹。
- en: In the next lines, the key is imported, and we print its fingerprint just for
    demonstration purposes.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几行中，我们导入了密钥，并仅为了演示目的打印了它的指纹。
- en: For *step 2*, we open the file we want to decrypt using the `with open` statement
    and decrypt it. You can see that a parameter for `passphrase` was set. This happened
    because the more recent versions of GnuPG require the file to have a passphrase
    set when encrypted. Since this recipe is only for educational matters, the passphrase
    here is simple and hardcoded.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *步骤 2*，我们使用 `with open` 语句打开我们想要解密的文件，并对其进行解密。你可以看到为 `passphrase` 设置了一个参数。这是因为
    GnuPG 的较新版本要求加密的文件设置密码。由于这个食谱仅用于教育目的，这里的密码很简单且是硬编码的。
- en: After that, you should be able to open the `.csv` file with no problems.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你应该能够无问题地打开 `.csv` 文件。
- en: '![Figure 2.14 – The decrypted Spotify CSV file](img/Figure_2.14_B19453.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.14 – 解密后的 Spotify CSV 文件](img/Figure_2.14_B19453.jpg)'
- en: Figure 2.14 – The decrypted Spotify CSV file
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.14 – 解密后的 Spotify CSV 文件
- en: There’s more…
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Usually, GnuPG is the tool of choice when it comes to encrypting files, but
    there are other market solutions such as the Python `cryptography` library, which
    has a `Fernet` class, a symmetric encryption method. As you can see in the following
    code, its use is very similar to what we did in this recipe:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，GnuPG 是加密文件的首选工具，但还有其他市场解决方案，例如 Python 的 `cryptography` 库，它有一个 `Fernet` 类，是一种对称加密方法。正如你在以下代码中所看到的，它的使用与我们在这个食谱中所做的是非常相似的：
- en: '[PRE26]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Still, the `Fernet` method is not widely used in the data world. It happens
    because an encrypted file with sensitive data often comes from an application
    or software that uses GnuPG hybrid encryption, which, as we saw in the *How it
    works…* section, complies with RFC 4880.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，`Fernet` 方法在数据世界中并不广泛使用。这是因为带有敏感数据的加密文件通常来自使用 GnuPG 混合加密的应用程序或软件，正如我们在
    *如何工作…* 部分所看到的，它符合 RFC 4880。
- en: 'You can find more details in the `cryptography` library documentation: [https://cryptography.io/en/latest/fernet/](https://cryptography.io/en/latest/fernet/).'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `cryptography` 库的文档中找到更多详细信息：[https://cryptography.io/en/latest/fernet/](https://cryptography.io/en/latest/fernet/)。
- en: See also
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'How to create and encrypt files using the **Python Wrapper for** **GnuPG**:
    [https://gnupg.readthedocs.io/en/latest/](https://gnupg.readthedocs.io/en/latest/).'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 **GnuPG 的 Python 包装器** 创建和加密文件：[https://gnupg.readthedocs.io/en/latest/](https://gnupg.readthedocs.io/en/latest/)。
- en: 'GnuPG official page and documentation: [https://gnupg.org/](https://gnupg.org/).'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GnuPG 官方页面和文档：[https://gnupg.org/](https://gnupg.org/)。
- en: 'If you are curious about RFC 4880 and want to understand it deeper, a summarized
    article about it was written by David Steele in his blog: [https://davesteele.github.io/gpg/2014/09/20/anatomy-of-a-gpg-key/](https://davesteele.github.io/gpg/2014/09/20/anatomy-of-a-gpg-key/).'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你对于 RFC 4880 感兴趣并想深入了解，David Steele 在他的博客中写了一篇关于它的总结文章：[https://davesteele.github.io/gpg/2014/09/20/anatomy-of-a-gpg-key/](https://davesteele.github.io/gpg/2014/09/20/anatomy-of-a-gpg-key/)。
- en: '*Voltage by opentext* is a great tool for data security and recommended by
    many companies. You can find out more here: [https://www.microfocus.com/en-us/cyberres/data-privacy-protection](https://www.microfocus.com/en-us/cyberres/data-privacy-protection).'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*由 opentext 提供的电压* 是一款用于数据安全性的优秀工具，并被许多公司推荐。你可以在这里了解更多信息：[https://www.microfocus.com/en-us/cyberres/data-privacy-protection](https://www.microfocus.com/en-us/cyberres/data-privacy-protection)。'
- en: Accessing data from AWS using S3
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 S3 从 AWS 访问数据
- en: AWS is one of the most popular cloud providers, mixing different service architectures
    and allowing easy and fast implementations.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 是最受欢迎的云服务提供商之一，它混合了不同的服务架构，并允许轻松快速的实施。
- en: While it has various solutions for relational and non-relational databases,
    in this recipe, we will cover how to manage data access from **S3 buckets**, which
    is an object storage service allowing not only text files to be uploaded, but
    also media and several other types of files used in the IoT and big data fields.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它为关系型和非关系型数据库提供了各种解决方案，但在本食谱中，我们将介绍如何管理从**S3存储桶**的数据访问，这是一个允许上传文本文件、媒体以及物联网和大数据领域使用的其他几种类型文件的对象存储服务。
- en: There are two commonly used types of data access management for S3 buckets,
    both used on ingest pipelines – **user control** and **bucket policies**. In this
    recipe, we will learn how to manage access by user control, given that it is the
    most used method among data ingestion pipelines.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 对于S3存储桶，有两种常用的数据访问管理类型，都在数据摄取管道中使用 – **用户控制**和**存储桶策略**。在本食谱中，我们将学习如何通过用户控制来管理访问，鉴于它是数据摄取管道中最常用的方法。
- en: Getting ready
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To do this recipe, having or creating an AWS account is not mandatory. The objective
    is to build a step-by-step **Identity Access Management** (**IAM)** policy to
    retrieve data from an S3 bucket using good data access practices you understand.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个食谱，拥有或创建AWS账户不是强制性的。目标是构建一个逐步的**身份访问管理**（**IAM**）策略，使用您理解的良好数据访问实践从S3存储桶中检索数据。
- en: 'However, if you want to create a free AWS account to test it, you can follow
    the steps provided by the **AWS official docs** here: [https://docs.aws.amazon.com/accounts/latest/reference/manage-acct-creating](https://docs.aws.amazon.com/accounts/latest/reference/manage-acct-creating).xhtml.
    After creating your AWS account, follow these steps:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您想创建一个免费的AWS账户来测试，您可以按照以下提供的**AWS官方文档**中的步骤进行：[https://docs.aws.amazon.com/accounts/latest/reference/manage-acct-creating](https://docs.aws.amazon.com/accounts/latest/reference/manage-acct-creating).xhtml。创建您的AWS账户后，按照以下步骤操作：
- en: 'Let’s create a user to test our S3 policy. To create a user, check out this
    AWS link: [https://docs.aws.amazon.com/IAM/latest/UserGuide/id_users_create.xhtml](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_users_create.xhtml).
    You don’t need to worry about attaching policies to it, so skip this part of the
    tutorial. The idea is to explore what a user without any policies attached can
    do inside the AWS console.'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个用户来测试我们的S3策略。要创建用户，请查看以下AWS链接：[https://docs.aws.amazon.com/IAM/latest/UserGuide/id_users_create.xhtml](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_users_create.xhtml)。您无需担心将其附加到策略上，因此请跳过本教程的这一部分。目的是探索没有任何策略附加的用户在AWS控制台中能做什么。
- en: 'Next, let’s create an S3 bucket using our administrator user. On the search
    bar, type `S3` and click on the first link:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们使用我们的管理员用户创建一个S3存储桶。在搜索栏中输入`S3`并点击第一个链接：
- en: '![Figure 2.15 – The AWS search bar](img/Figure_2.15_B19453.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图2.15 – AWS搜索栏](img/Figure_2.15_B19453.jpg)'
- en: Figure 2.15 – The AWS search bar
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15 – AWS搜索栏
- en: 'Then, click the **Create bucket** button and a new page will load as follows:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击**创建存储桶**按钮，将加载一个新页面如下：
- en: '![Figure 2.16 – The AWS S3 main page](img/Figure_2.16_B19453.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![图2.16 – AWS S3主页面](img/Figure_2.16_B19453.jpg)'
- en: Figure 2.16 – The AWS S3 main page
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.16 – AWS S3主页面
- en: 'A new page will load as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 将加载一个新页面如下：
- en: '![Figure 2.17 – The AWS S3 page to create a new bucket](img/Figure_2.17_B19453.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图2.17 – 创建新存储桶的AWS S3页面](img/Figure_2.17_B19453.jpg)'
- en: Figure 2.17 – The AWS S3 page to create a new bucket
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.17 – 创建新存储桶的AWS S3页面
- en: 'On the `Stockholm` in this recipe since it is the nearest region to where I
    live. Skip the other fields for now, scroll down, and press the **Create** **bucket**
    button:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们选择在**斯德哥尔摩**进行操作，因为它是我居住地最近的一个区域。现在请跳过其他字段，向下滚动并点击**创建存储桶**按钮：
- en: 'On the S3 page, you know should be able to see and select the bucket you created:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在S3页面上，您应该能够看到并选择您创建的存储桶：
- en: '![Figure 2.18 – The S3 bucket objects page](img/Figure_2.18_B19453.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图2.18 – S3存储桶对象页面](img/Figure_2.18_B19453.jpg)'
- en: Figure 2.18 – The S3 bucket objects page
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.18 – S3存储桶对象页面
- en: You can upload any files here for testing if you want to.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想测试，可以在这里上传任何文件。
- en: After completing the steps, open another window on your browser and switch to
    the user you created for testing. If possible, try to keep administrator and testing
    users logged on in different browsers so that you can see the changes in real
    time.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 完成步骤后，在您的浏览器中打开另一个窗口并切换到您为测试创建的用户。如果可能的话，尽量在不同的浏览器中保持管理员和测试用户登录，这样您就可以实时看到变化。
- en: We are ready to start creating and applying the access policy.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已准备好开始创建和应用访问策略。
- en: How to do it…
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'If we try to list **S3**, we can see the buckets, but when clicking on any
    bucket, this error will happen:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试列出**S3**，我们可以看到存储桶，但当点击任何存储桶时，将会发生以下错误：
- en: '![Figure 2.19 – Testing the user view of an S3 bucket with an Insufficient
    permissions message](img/Figure_2.19_B19453.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![图2.19 – 使用权限不足的消息测试S3桶的用户视图](img/Figure_2.19_B19453.jpg)'
- en: Figure 2.19 – Testing the user view of an S3 bucket with an Insufficient permissions
    message
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.19 – 使用权限不足的消息测试S3桶的用户视图
- en: 'Let’s fix this by creating and attaching a policy with the following steps:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤创建并附加一个策略来解决这个问题：
- en: 'First, we will define an access policy for the user. The user will be capable
    of listing, retrieving, and deleting any object inside the S3 bucket we created.
    Let’s start by creating a JSON file with the AWS policy requirements to make it
    possible. See the following file:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将为用户定义一个访问策略。用户将能够列出、检索和删除我们创建的S3存储桶中的任何对象。让我们首先创建一个包含AWS策略要求的JSON文件，使其成为可能。请参阅以下文件：
- en: '[PRE27]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we allow the user to access the bucket via IAM policies. On the user
    IAM page, click on **Add inline policy** as follows:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们允许用户通过IAM策略访问存储桶。在用户IAM页面上，按照以下步骤点击**添加内联策略**：
- en: '![Figure 2.20 – AWS user Permission policy section](img/Figure_2.20_B19453.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![图2.20 – AWS用户权限策略部分](img/Figure_2.20_B19453.jpg)'
- en: Figure 2.20 – AWS user Permission policy section
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.20 – AWS用户权限策略部分
- en: 'Insert the previous code into the **JSON** option tab, and click on **Review
    policy**. On the **Review Policy** page, insert the policy’s name and click **Create
    policy** to confirm it, as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 将上一段代码插入到**JSON**选项卡中，然后点击**审查策略**。在**审查策略**页面，输入策略的名称并点击**创建策略**以确认，如下所示：
- en: '![Figure 2.21 – The AWS IAM review policy page](img/Figure_2.21_B19453.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![图2.21 – AWS IAM审查策略页面](img/Figure_2.21_B19453.jpg)'
- en: Figure 2.21 – The AWS IAM review policy page
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.21 – AWS IAM审查策略页面
- en: If we check now, we can see that adding but not deleting files is possible.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在检查，我们可以看到添加文件是可能的，但删除文件则不行。
- en: How it works…
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: At the beginning of this recipe, our testing user had no permission to access
    any resources at AWS. For example, when accessing our created bucket, a warning
    appeared on the page. Then we allowed the user to access and upload files or objects
    to the bucket.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱的开始，我们的测试用户没有权限访问AWS上的任何资源。例如，当我们访问我们创建的存储桶时，页面上会出现警告。然后我们允许用户访问并上传文件或对象到存储桶。
- en: 'In *step 1*, we built an inline IAM policy with the following steps:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*中，我们按照以下步骤构建了一个内联IAM策略：
- en: 'First, we allowed the testing user to list all the buckets inside the respective
    AWS account:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们允许测试用户列出相应AWS账户内的所有存储桶：
- en: '[PRE28]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The second statement allows the user to list objects and get the bucket’s location.
    Note that in the **Resource** key, we only specified a target S3 bucket **AWS
    Resource** **Name** (**ARN**):'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个语句允许用户列出对象并获取存储桶的位置。请注意，在**资源**键中，我们只指定了一个目标S3存储桶**AWS资源** **名称**（**ARN**）：
- en: '[PRE29]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, we create another statement to allow the insertion and retrieval of
    objects. In this case, the resource now also has a `/*` character at the end of
    the ARN. This represents the policy that is going to affect the respective bucket
    objects:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建另一个语句以允许对象的插入和检索。在这种情况下，资源现在在ARN的末尾也有一个`/*`字符。这代表将影响相应存储桶对象的策略：
- en: '[PRE30]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Depending on the AWS resource you want to manage access, the **Action** key
    can be very different and can have different applications. Regarding S3 buckets
    and objects, you find all possible actions in the AWS documentation: [https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-with-s3-actions.xhtml](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-with-s3-actions.xhtml).'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您想要管理访问的AWS资源，**操作**键可以非常不同，并且可以有不同的应用。关于S3存储桶和对象，您可以在AWS文档中找到所有可能的操作：[https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-with-s3-actions.xhtml](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-with-s3-actions.xhtml)。
- en: There’s more…
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: When ingesting data, the user control method is the most used. It happens because
    an application such use **Airflow** or **Elastic MapReduce** (**EMR**) can usually
    connect to a bucket. Also, from a management control perspective, it is much easier
    to handle, with just a few programmatic accesses instead of one for each user
    in a company.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 当导入数据时，用户控制方法是使用最频繁的。这是因为像**Airflow**或**Elastic MapReduce**（**EMR**）这样的应用程序通常可以连接到存储桶。从管理控制的角度来看，它也更容易处理，只需要少量程序性访问，而不是公司中每个用户的单独访问。
- en: Of course, there will be scenarios where each data engineer has a user with
    permissions set. Still, the scenario usually is (and should be) a development
    environment with a sample of data.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，会有一些场景，每个数据工程师都有一个具有权限设置的账户。但通常（并且应该是）这样的场景是一个开发环境，其中包含数据样本。
- en: Bucket policies
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 存储桶策略
- en: 'Bucket policies can add a security layer to control the access of external
    resources to internal objects. With these policies, limiting access to specific
    IP addresses, specific resources such as **CloudFront**, or types of **HTTP**
    method requests is possible. In the AWS official documentation, you can see a
    list of practical examples: [https://docs.aws.amazon.com/AmazonS3/latest/userguide/example-bucket-policies.xhtml](https://docs.aws.amazon.com/AmazonS3/latest/userguide/example-bucket-policies.xhtml).'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 存储桶策略可以为控制外部资源对内部对象的访问添加一个安全层。使用这些策略，可以限制对特定 IP 地址、特定资源（如**CloudFront**）或**HTTP**方法请求类型的访问。在
    AWS 官方文档中，您可以查看一系列实用示例：[https://docs.aws.amazon.com/AmazonS3/latest/userguide/example-bucket-policies.xhtml](https://docs.aws.amazon.com/AmazonS3/latest/userguide/example-bucket-policies.xhtml)。
- en: See also
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In the AWS official documentation, you can also see other types of access control,
    such as **Access Control Lists** (**ACLs**) and **Cross-Origin Resource Sharing**
    (**CORS**): [https://docs.aws.amazon.com/AmazonS3/latest/userguide/s3-access-control.xhtml](https://docs.aws.amazon.com/AmazonS3/latest/userguide/s3-access-control.xhtml).'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AWS 官方文档中，您还可以看到其他类型的访问控制，如**访问控制列表**（**ACLs**）和**跨源资源共享**（**CORS**）：[https://docs.aws.amazon.com/AmazonS3/latest/userguide/s3-access-control.xhtml](https://docs.aws.amazon.com/AmazonS3/latest/userguide/s3-access-control.xhtml)。
- en: Accessing data from GCP using Cloud Storage
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用云存储从 GCP 访问数据
- en: '**Google Cloud Platform** (**GCP**) is a cloud provider that offers manifold
    services, from cloud computing to **Artificial Intelligence** (**AI**), which
    can be implemented in only a few steps. It also provides broad-spectrum storage
    called **Cloud Storage**.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '**Google Cloud Platform**（**GCP**）是一个提供多种服务的云提供商，从云计算到**人工智能**（**AI**），只需几个步骤即可实现。它还提供广泛范围的存储服务，称为**云存储**。'
- en: In this recipe, we will build step-by-step policies to control access to data
    inside our **Cloud** **Storage buckets**.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将逐步构建策略来控制对**云存储桶**内数据的访问。
- en: Getting ready
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'This recipe will use the *uniform* method, as defined by the Google Cloud team:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方将使用由 Google Cloud 团队定义的**统一**方法：
- en: 'First, we will create a testing user. Go to the **IAM** page ([https://console.cloud.google.com/iam-admin/iam](https://console.cloud.google.com/iam-admin/iam))
    and select **Grant Access**. Add a valid Gmail address in the **New principals**
    field. For now, this user will only have the **Browser** role:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个测试用户。转到**IAM**页面（[https://console.cloud.google.com/iam-admin/iam](https://console.cloud.google.com/iam-admin/iam)）并选择**授予权限**。在**新主体**字段中添加一个有效的
    Gmail 地址。目前，此用户将只有**浏览器**角色：
- en: '![Figure 2.22 – The GCP IAM page to attach policies to a user](img/Figure_2.22_B19453.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.22 – 将策略附加到用户的 GCP IAM 页面](img/Figure_2.22_B19453.jpg)'
- en: Figure 2.22 – The GCP IAM page to attach policies to a user
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.22 – 将策略附加到用户的 GCP IAM 页面
- en: 'Then, we will create a Cloud Storage bucket. Go to the **Cloud Storage** page
    and select **Create a** **bucket**: [https://console.cloud.google.com/storage/create-bucket](https://console.cloud.google.com/storage/create-bucket).'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个云存储桶。转到**云存储**页面并选择**创建一个****存储桶**：[https://console.cloud.google.com/storage/create-bucket](https://console.cloud.google.com/storage/create-bucket)。
- en: '![Figure 2.23 – The GCP search bar with Cloud Storage selected](img/Figure_2.23_B19453.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.23 – 已选择云存储的 GCP 搜索栏](img/Figure_2.23_B19453.jpg)'
- en: Figure 2.23 – The GCP search bar with Cloud Storage selected
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.23 – 已选择云存储的 GCP 搜索栏
- en: 'Add a unique name to your bucket and leave the other option as it is:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 为您的存储桶添加一个唯一的名称，并保留其他选项不变：
- en: '![Figure 2.24 – The GCP page to create a new bucket](img/Figure_2.24_B19453.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.24 – 创建新存储桶的 GCP 页面](img/Figure_2.24_B19453.jpg)'
- en: Figure 2.24 – The GCP page to create a new bucket
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.24 – 创建新存储桶的 GCP 页面
- en: How to do it…
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here are the steps to perform this recipe:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此配方的步骤如下：
- en: 'We will try to access the Cloud Storage objects. First, let’s try to access
    the bucket using the user we just created. An error message should appear:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将尝试访问云存储对象。首先，让我们尝试使用我们刚刚创建的用户访问存储桶。应该会显示一个错误消息：
- en: '![Figure 2.25 – An insufficient permission message for the testing user in
    the GCP console](img/Figure_2.25_B19453.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.25 – GCP 控制台中测试用户的权限不足消息](img/Figure_2.25_B19453.jpg)'
- en: Figure 2.25 – An insufficient permission message for the testing user in the
    GCP console
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.25 – GCP 控制台中测试用户的权限不足信息
- en: Then, we grant **Editor** permissions in Cloud Storage. Go to the **IAM** page
    and select the testing user you created. On the editing user page, select **Editor**.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在云存储中授予 **编辑者** 权限。转到 **IAM** 页面并选择你创建的测试用户。在编辑用户页面上，选择 **编辑者**。
- en: '![Figure 2.26 – The GCP IAM page – assigning the Editor role to the testing
    user](img/Figure_2.26_B19453.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.26 – GCP IAM 页面 – 将编辑者角色分配给测试用户](img/Figure_2.26_B19453.jpg)'
- en: Figure 2.26 – The GCP IAM page – assigning the Editor role to the testing user
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.26 – GCP IAM 页面 – 将编辑者角色分配给测试用户
- en: Note
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you are confused about the roles, use the Policy Simulator in Google Cloud:
    [https://console.cloud.google.com/iam-admin/simulator](https://console.cloud.google.com/iam-admin/simulator).'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对角色有疑问，请使用 Google Cloud 中的策略模拟器：[https://console.cloud.google.com/iam-admin/simulator](https://console.cloud.google.com/iam-admin/simulator).
- en: 'Next, we access Cloud Storage with a proper role. The user should be able to
    see and upload objects to the bucket:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用适当的角色访问云存储。用户应该能够查看并将对象上传到存储桶：
- en: '![Figure 2.27 – The testing user view of the GCP bucket](img/Figure_2.27_B19453.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.27 – 测试用户对 GCP 存储桶的视图](img/Figure_2.27_B19453.jpg)'
- en: Figure 2.27 – The testing user view of the GCP bucket
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.27 – 测试用户对 GCP 存储桶的视图
- en: How it works…
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *step 1*, our testing user had only permission to browse, and an error message
    appeared when trying to see the bucket list. However, the **Editor** role for
    Cloud Storage solves this problem by granting access to the bucket (and most of
    the other essential Google Cloud resources). At this point, creating a condition
    to allow only access to this bucket is also possible.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 1* 中，我们的测试用户只有浏览权限，当尝试查看存储桶列表时出现了错误信息。然而，云存储的 **编辑者** 角色通过授予对存储桶（以及大多数其他基本
    Google Cloud 资源）的访问权限解决了这个问题。此时，也可以创建一个条件，仅允许访问这个存储桶。
- en: 'The Google Cloud access hierarchy is based on its organization and projects.
    To provide access to a respective bucket, we need to ensure we also have access
    to the resources of a project. Refer to the following screenshot:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: Google Cloud 的访问层次结构基于其组织和项目。为了提供对相应存储桶的访问权限，我们需要确保我们也有对项目资源的访问权限。请参考以下截图：
- en: '![Figure 2.28 – GCP control access hierarchy – source: https://cloud.google.com/resource-manager/docs/cloud-platform-resource-hierarchy#inheritance](img/Figure_2.28_B19453.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.28 – GCP 控制访问层次结构 – 来源：https://cloud.google.com/resource-manager/docs/cloud-platform-resource-hierarchy#inheritance](img/Figure_2.28_B19453.jpg)'
- en: 'Figure 2.28 – GCP control access hierarchy – source: https://cloud.google.com/resource-manager/docs/cloud-platform-resource-hierarchy#inheritance'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.28 – GCP 控制访问层次结构 – 来源：https://cloud.google.com/resource-manager/docs/cloud-platform-resource-hierarchy#inheritance
- en: Once the access hierarchy is defined, we can select several built-in user permission
    groups on the IAM page and add conditions if needed. Unlike AWS, Google Cloud
    policies are often created as “roles” and grouped to serve a specific area or
    department. Additional permissions or conditionals can be made for particular
    cases, but they are not shared.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了访问层次结构，我们就可以在 IAM 页面上选择几个内置的用户权限组，并在需要时添加条件。与 AWS 不同，Google Cloud 策略通常以“角色”的形式创建，并分组以服务于特定的区域或部门。可以为特定情况创建额外的权限或条件，但它们不会共享。
- en: Even though the uniform method seems simple, it can be a powerful way to manage
    access to Google Cloud when properly grouped and revised and uniformly grant permissions.
    In our case, the **Editor** role solved our problem, but a specialist on this
    topic is recommended when working with larger teams and different types of access
    policies.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管统一的方法看起来很简单，但通过适当分组、修订并统一授予权限，它可以成为一种管理 Google Cloud 访问的强大方式。在我们的案例中，**编辑者**
    角色解决了我们的问题，但在与大型团队和不同类型的访问策略一起工作时，建议咨询该领域的专家。
- en: There’s more…
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Like S3, Cloud Storage also has another type of access control called **fine-grained**.
    It consists of a mixture of IAM policies and ACLs and is recommended in cases
    where storage connects to an S3 bucket, for instance. As its name suggests, the
    permission is refined to the bucket and individual object levels. It needs to
    be configured by someone (or a team) with a high level of security knowledge,
    since the data exposure can be elevated if the [**ACL policy** is not set correctly.](https://davesteele.github.io/gpg/2014/09/20/anatomy-of-a-gpg-key/)
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 与S3类似，云存储还有另一种名为**细粒度**的访问控制。它由IAM策略和ACLs的混合组成，在存储连接到S3存储桶等情况下推荐使用。正如其名所示，权限被细化到存储桶和单个对象级别。由于数据暴露可能会因[**ACL策略**设置不正确而加剧]，因此需要由具有高度安全知识的人（或团队）进行配置。
- en: '[You can read more about ACLs i](https://davesteele.github.io/gpg/2014/09/20/anatomy-of-a-gpg-key/)n
    Cloud Storage here: [https://cloud.google.com/storage/docs/access-control/lists](https://cloud.google.com/storage/docs/access-control/lists).'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里了解更多关于ACLs的信息：[云存储ACLs](https://cloud.google.com/storage/docs/access-control/lists).
- en: Further reading
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[https://www.manageengine.com/device-control/data-replication.xhtml](https://www.manageengine.com/device-control/data-replication.xhtml)'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数据复制](https://www.manageengine.com/device-control/data-replication.xhtml)'
- en: '[https://www.keboola.com/blog/database-replication-techniques](https://www.keboola.com/blog/database-replication-techniques)'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数据库复制技术](https://www.keboola.com/blog/database-replication-techniques)'
- en: '[https://satoricyber.com/access-control/access-control-101-a-comprehensive-guide-to-database-access-control/](https://satoricyber.com/access-control/access-control-101-a-comprehensive-guide-to-database-access-control/)'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数据库访问控制全面指南](https://satoricyber.com/access-control/access-control-101-a-comprehensive-guide-to-database-access-control/)'
- en: '[https://stackoverflow.com/questions/190257/best-role-based-access-control-rbac-database-model](https://stackoverflow.com/questions/190257/best-role-based-access-control-rbac-database-model)'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[最佳基于角色的访问控制（RBAC）数据库模型](https://stackoverflow.com/questions/190257/best-role-based-access-control-rbac-database-model)'
- en: '[https://www.researchgate.net/publication/281479020_A_Model-driven_Role-based_Access_Control_for_SQL_Databases](https://www.researchgate.net/publication/281479020_A_Model-driven_Role-based_Access_Control_for_SQL_Databases)'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[基于模型的SQL数据库基于角色的访问控制](https://www.researchgate.net/publication/281479020_A_Model-driven_Role_based_Access_Control_for_SQL_Databases)'
- en: '[https://dspace.mit.edu/bitstream/handle/1721.1/87870/53700676-MIT.pdf?sequence=2](https://dspace.mit.edu/bitstream/handle/1721.1/87870/53700676-MIT.pdf?sequence=2)'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[MIT PDF](https://dspace.mit.edu/bitstream/handle/1721.1/87870/53700676-MIT.pdf?sequence=2)'
- en: '[https://scholarworks.calstate.edu/downloads/sb397840v](https://scholarworks.calstate.edu/downloads/sb397840v)'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[下载PDF](https://scholarworks.calstate.edu/downloads/sb397840v)'
- en: '[https://www.sftp.net/public-online-sftp-servers](https://www.sftp.net/public-online-sftp-servers)'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[公共在线SFTP服务器](https://www.sftp.net/public-online-sftp-servers)'
- en: '[https://www.ittsystems.com/how-to-access-sftp-server-in-python/](https://www.ittsystems.com/how-to-access-sftp-server-in-python/)'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[如何在Python中访问SFTP服务器](https://www.ittsystems.com/how-to-access-sftp-server-in-python/)'
- en: '[https://towardsdatascience.com/encrypt-and-decrypt-files-using-python-python-programming-pyshark-a67774bbf9f4](https://towardsdatascience.com/encrypt-and-decrypt-files-using-python-python-programming-pyshark-a67774bbf9f4)'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用Python加密和解密文件 - Python编程 - PyShark](https://towardsdatascience.com/encrypt-and-decrypt-files-using-python-python-programming-pyshark-a67774bbf9f4)'
- en: '[https://www.geeksforgeeks.org/encrypt-and-decrypt-files-using-python/](https://www.geeksforgeeks.org/encrypt-and-decrypt-files-using-python/)'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用Python加密和解密文件](https://www.geeksforgeeks.org/encrypt-and-decrypt-files-using-python/)'
- en: '[https://www.saltycrane.com/blog/2011/10/python-gnupg-gpg-example/](https://www.saltycrane.com/blog/2011/10/python-gnupg-gpg-example/)'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Python gnupg/gpg示例](https://www.saltycrane.com/blog/2011/10/python-gnupg-gpg-example/)'
- en: '[https://www.ekransystem.com/en/blog/data-security-best-practices](https://www.ekransystem.com/en/blog/data-security-best-practices)'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数据安全最佳实践](https://www.ekransystem.com/en/blog/data-security-best-practices)'
- en: '[https://www.ovaledge.com/blog/data-access-management-basics-implementation-strategy](https://www.ovaledge.com/blog/data-access-management-basics-implementation-strategy)'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数据访问管理基础实施策略](https://www.ovaledge.com/blog/data-access-management-basics-implementation-strategy)'
