- en: Simulating Sales Data and Working with Databases
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟销售数据和与数据库一起工作
- en: The Food Factory example is about a fictitious company called **The Food Factory**.
    They sell custom meals for people looking for healthy food. They allow their customers
    to choose the macronutrients combinations they want, as well as their protein
    sources. Macronutrients are the base for any diet, and they are composed of carbohydrates,
    proteins, and fats. Customers can choose the percentage of each macronutrient,
    as well as their protein source (fish, chicken, beef, or vegetarian); then, The
    Food Factory will come up with a tasty meal which fulfills their diet specifications.
    They have found some great combinations this way, and if they continue to do as
    well as they have, they will add more meal options, as well as fixed recipes,
    according to what their customers like most.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 食品工厂的例子是关于一家虚构的公司，名为**食品工厂**。他们为寻找健康食品的人提供定制餐食。他们允许客户选择他们想要的宏量营养素组合，以及他们的蛋白质来源。宏量营养素是任何饮食的基础，它们由碳水化合物、蛋白质和脂肪组成。客户可以选择每种宏量营养素的百分比，以及他们的蛋白质来源（鱼、鸡肉、牛肉或素食）；然后，食品工厂将提供一份美味的餐食，满足他们的饮食要求。他们通过这种方式找到了一些很好的组合，如果他们继续做得像现在这样好，他们将根据客户最喜欢的添加更多餐食选项以及固定食谱。
- en: The Food Factory has done a good job so far and they have a system in place
    that allows them to collect a good amount of data across their five store locations,
    as well as keep track of customer messages. Our job in this example will be to
    analyze the data to diagnose the current state of the business and propose ways
    to improve it. To do so, we will use lots of visualizations in [Chapter 5](part0110.html#38STS0-f494c932c729429fb734ce52cafce730),
    *Communicating Sales with Visualizations;* perform text analysis on customer reviews
    in [Chapter 6](part0129.html#3R0OI0-f494c932c729429fb734ce52cafce730), *Understanding
    Reviews with Text Analysis;* and provide automatic diagnosis of the current state
    of the business in [Chapter 7](part0147.html#4C62M0-f494c932c729429fb734ce52cafce730),
    *Developing Automatic Presentations*. Sounds good, right? However, before we can
    do all of that, we need to get a hold of the data, and we don't have it yet. We're
    going to simulate it! This chapter will show you how to design a non-trivial data
    simulation to produce the data for the example. Furthermore, The Food Factory,
    as well as many organizations, doesn't always make our lives easier by providing
    CSV files, and they often have databases we need to work with. This chapter will
    also show you how to work with such databases.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 食品工厂到目前为止做得很好，他们已经建立了一套系统，可以让他们在其五个门店收集大量数据，同时跟踪客户信息。在这个例子中，我们的工作将是分析数据，以诊断业务的当前状态，并提出改进的方法。为此，我们将使用大量的可视化，在[第5章](part0110.html#38STS0-f494c932c729429fb734ce52cafce730)，*用可视化传达销售；*在[第6章](part0129.html#3R0OI0-f494c932c729429fb734ce52cafce730)，*通过文本分析理解评论；*以及在[第7章](part0147.html#4C62M0-f494c932c729429fb734ce52cafce730)，*开发自动演示*中提供对业务当前状态的自动诊断。听起来不错，对吧？然而，在我们能够做所有这些之前，我们需要掌握数据，但我们还没有。我们将模拟它！本章将向您展示如何设计一个非平凡的数据模拟来生成示例所需的数据。此外，食品工厂以及许多组织并不总是让我们的工作变得容易，他们经常提供CSV文件，并且他们通常有我们需要与之合作的数据库。本章还将向您展示如何处理这样的数据库。
- en: 'Some of the important topics covered in this chapter are:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的一些重要主题包括：
- en: Designing and implementing non-trivial simulations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计和实施非平凡模拟
- en: Simulating numbers, categories, strings, and dates
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟数字、类别、字符串和日期
- en: Function signatures with parameter objects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有参数对象的函数签名
- en: Reusing functions in different contexts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同上下文中重用函数
- en: Mixing internal and external data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合内部和外部数据
- en: Working with relational databases
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与关系数据库一起工作
- en: Required packages
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所需软件包
- en: The only package required for this chapter is `RMySQL`. However, to be able
    to fully replicate the code shown towards the end of the chapter, you will need
    a working installation of the MySQL database ([https://www.mysql.com/](https://www.mysql.com/)).
    Specific instructions for Linux and Mac can be found in [Appendix](part0296.html#8Q96G0-f494c932c729429fb734ce52cafce730),
    *Required Packages.*
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 仅需本章所需的软件包是`RMySQL`。然而，为了能够完全复制本章末尾所示代码，您需要一个可工作的MySQL数据库安装([https://www.mysql.com/](https://www.mysql.com/))。有关Linux和Mac的具体说明，请参阅[附录](part0296.html#8Q96G0-f494c932c729429fb734ce52cafce730)，*所需软件包*。
- en: '| **Package** | **Reason** |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| **软件包** | **原因** |'
- en: '| `RMySQL` | Interface to MySQL database |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `RMySQL` | MySQL数据库接口 |'
- en: Designing our data tables
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计我们的数据表
- en: It's always a good practice to design with paper and a pencil before starting
    to program. If you do, you'll find that your code is much better because you'll
    contemplate scenarios that you may not see if you start programming right away,
    and, instead of hacking your way around what you have already programmed, you'll
    be able to design solutions beforehand. It's an easy investment that very often
    pays off, so that's what we will do in this section, we will design our data.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编程之前用纸和铅笔设计总是一个好习惯。如果你这样做，你会发现你的代码会更好，因为你会考虑那些如果你直接开始编程可能看不到的场景，而且，你将能够事先设计解决方案，而不是在已经编写的代码中打补丁。这是一个很容易的投资，而且往往能带来回报，所以这就是我们在这个部分要做的，我们将设计我们的数据。
- en: The basic variables
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本变量
- en: Let's start from the most simple scenario we can imagine and try to find any
    potential problems we may encounter. For each sale, we would like to have the
    following variables, the sales `DATE`, the `COST` for producing that type of food,
    the `QUANTITY` bought, the `PRICE` for the type food, whether or not we applied
    a `DISCOUNT`, the macronutrient percentages for `CARBS` (carbohydrates), `PROTEIN`,
    and `FAT`, the `PROTEIN_SOURCE` of the food (either `FISH`, `CHICKEN`, `BEEF`,
    or `VEGETARIAN`, if the person does not eat meat), the `STORE` where it was sold,
    the `DELIVERY` method (either send `TO LOCATION` or deliver `IN STORE`), the `STATUS` of
    the sale, which can be `PENDING`, `DELIVERED`, `RETURNED`, or `CANCELLED` (a sale
    can't have two statuses at the same time), whether or not it has been `PAID`,
    the client's `BIRTH_DATE` and `GENDER`, how many `STARS` they awarded to the company,
    the `CUSTOMER_SINCE` date, and how many messages they sent us related to their
    order, as well as the `DATE`, `STARS`, and actual `MESSAGE` for each one.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最简单的场景开始想象，并尝试找出我们可能遇到的问题。对于每一笔销售，我们希望有以下变量：销售`日期`，生产该类型食品的`成本`，购买的`数量`，该类型食品的`价格`，是否应用了`折扣`，`碳水化合物`（`CARBS`）、`蛋白质`和`脂肪`的宏量营养素百分比，食品的`蛋白质来源`（如果是素食者，则为`FISH`、`CHICKEN`、`BEEF`或`VEGETARIAN`），销售所在的`商店`，`配送`方式（要么是发送到`地点`，要么是在`商店`内配送），销售的`状态`，可以是`待处理`、`已配送`、`已退货`或`已取消`（销售不能同时具有两种状态），是否已`支付`，客户的`出生日期`和`性别`，他们给公司评了多少`星`，客户的`注册日期`，以及他们与订单相关的消息数量，以及每个消息的`日期`、`星数`和实际`消息`。
- en: Simplifying assumptions
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简化假设
- en: We can complicate the example as much as we want, but to keep the simulation
    simple (although not trivial), we are going to assume a couple of things upfront.
    First, we assume that each sale record contains a single type of food. If a person
    buys two or more different types of foods, then each of those types will produce
    a different sale record. However, each sale can contain as many portions of the
    foods as we want, as long as they are the same type (combination of macronutrients
    and protein sources). This is the most important simplification, since company
    sales orders normally have various items per sale, but it will allow us to focus
    on the programming side of things.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以随意复杂化这个例子，但为了保持模拟简单（尽管不是微不足道的），我们事先假设一些事情。首先，我们假设每条销售记录只包含一种类型的食品。如果一个人购买两种或更多不同类型的食品，那么每种类型将产生不同的销售记录。然而，只要食品类型相同（宏量营养素和蛋白质来源的组合），每笔销售可以包含我们想要的任何数量的食品。这是最重要的简化，因为公司的销售订单通常每笔销售包含多种商品，但这将使我们能够专注于编程方面的事情。
- en: Second, we will not worry about the relation among food types and costs (or
    prices) being continuous in the mathematical sense. This means that we may find
    a food type with some combination of macronutrients and protein sources that is
    very similar to another food's combination, but their production costs, as well
    as their prices, are very different. Similarly, we assume that each food type
    has its unique cost and price, and it can vary for different sales (the same food
    type can have different costs and prices for different sales). This is not a realistic
    assumption, as most companies have standardized products (including costs and
    prices), but we can think of The Food Factory as being a craft shop, where each
    food is unique, and that can generate the differences in costs and prices. If
    anything, it's adding complexity (fun) to the analysis.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们不会担心食物类型和成本（或价格）在数学意义上的连续性关系。这意味着我们可能会找到一个食物类型，其宏量营养素和蛋白质来源的组合与另一种食物的组合非常相似，但它们的制造成本以及价格却非常不同。同样，我们假设每种食物类型都有其独特的成本和价格，并且这些成本和价格可能因不同的销售而异（同一种食物类型在不同销售中可能有不同的成本和价格）。这个假设并不现实，因为大多数公司都有标准化的产品（包括成本和价格），但我们可以将食品工厂视为一个手工艺品店，每种食物都是独一无二的，这可以产生成本和价格上的差异。如果有什么的话，这只是在分析中增加了复杂性（乐趣）。
- en: Third, we will not worry about the relation among sales dates and sale statuses,
    or among sales dates and whether or not a sale has been paid. This means that
    we may actually find sales that have been delivered and are old, but were not
    paid. This is something that does happen in some real-life cases, so there's no
    problem assuming it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，我们不会担心销售日期和销售状态之间的关系，或者销售日期和销售是否已付款之间的关系。这意味着我们实际上可能会发现已经交付但尚未付款的旧销售。这在现实生活中确实会发生，因此假设这一点没有问题。
- en: Fourth, the fact that a customer's messages related to a specific sale are rated
    high or low, does not affect the overall score they gave to The Food Factory.
    There are two `STARS` columns, one for overall rating of The Food Factory, and
    one that will be sent with each message related to an order. This means that a
    client who in general likes The Food Factory can have a bad experience, and it
    will not affect how much they continue to like the store. Conversely, a customer
    who in general does not like The Food Factory, will not start liking it because
    they had a good experience with it one day. This assumption holds true for people
    with fixed preferences, but does not hold true in general. If we wanted to, we
    could include mechanisms in the simulation that take these dynamics into account.
    As a matter of fact, I encourage you to try to implement some of these mechanisms
    yourself. It will be good practice.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第四，客户与特定销售相关的消息的评分高低，不会影响他们对食品工厂的整体评分。有两个“星级”列，一个用于食品工厂的整体评分，另一个将随每条与订单相关的消息发送。这意味着一个通常喜欢食品工厂的客户可能会有一次不好的体验，但这不会影响他们继续喜欢这家店的程度。相反，一个通常不喜欢食品工厂的客户，不会因为某一天的好体验而开始喜欢它。这个假设对于有固定偏好的个人是成立的，但并不普遍。如果我们愿意，我们可以在模拟中包含考虑这些动态的机制。实际上，我鼓励你尝试自己实现一些这些机制。这将是一个很好的实践。
- en: Fifth, we won't worry about the macronutrients making sense, including the combination
    with protein sources. A common diet would include approximately 50% protein, 35%
    carbohydrates, and 15% fat, but we won't worry about our numbers making nutritional
    sense. That means, please don't think any of these simulated food orders are realistic,
    or are actually healthy.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第五，我们不会担心宏量营养素是否合理，包括与蛋白质来源的组合。常见的饮食中大约包括50%的蛋白质、35%的碳水化合物和15%的脂肪，但我们不会担心我们的数字在营养学上是否合理。这意味着，请不要认为这些模拟食品订单是现实的，或者实际上是健康的。
- en: Potential pitfalls
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 潜在的陷阱
- en: Now that we understand the general data structure, we need to find potential
    pitfalls that should be avoided. We can think about this data structure as a standard
    table structure (a data frame or a spreadsheet) where each column represents a
    variable and each row represents an observation (a sales record, in our case).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了数据结构的一般形式，我们需要找到应该避免的潜在陷阱。我们可以将这个数据结构视为一个标准的表格结构（一个数据框或电子表格），其中每一列代表一个变量，每一行代表一个观察值（在我们的案例中是销售记录）。
- en: The too-much-empty-space problem
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过多的空格问题
- en: Let's say we have a sales record; what happens if we get a message related to
    that order from our customer? Well, we simply add the data to the corresponding
    columns `DATE`, `STARS`, and `MESSAGE`. What happens if we get another message
    related to the same order? Well, a possible solution would be to add a new combination
    of `DATE`, `STARS`, and `MESSAGE` for the new message, but names would collapse.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个销售记录；如果我们收到客户关于该订单的消息，会发生什么？嗯，我们只需将数据添加到相应的列 `DATE`、`STARS` 和 `MESSAGE`。如果我们收到另一条与同一订单相关的消息，会发生什么？嗯，一个可能的解决方案是为新消息添加一个新的
    `DATE`、`STARS` 和 `MESSAGE` 组合，但名称会重叠。
- en: How would we differentiate among them? Well, we can append a number indicating
    the actual message number. Then, we would have `DATE_1`, `STARS_1`, and `MESSAGE_1` for
    the first message, and `DATE_2`, `STARS_2`, and `MESSAGE_2` for the second message.
    That would fix it, wouldn't it? What happens if we get a third, or more, messages
    related to the order? Well, we would end up with a lot of variables in our data
    frame. Specifically, we would have as many combinations as the maximum number
    of messages that were sent to a single order. What would be the content of the
    cells for the orders that did not have such a big number of messages? They would
    be empty. That would be a lot of wasted space! Plus, the general structure for
    the data would feel awkward. There must be a better way.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何区分它们？嗯，我们可以在后面附加一个表示实际消息编号的数字。然后，我们就会有第一条消息的 `DATE_1`、`STARS_1` 和 `MESSAGE_1`，以及第二条消息的
    `DATE_2`、`STARS_2` 和 `MESSAGE_2`。这样就能解决问题，不是吗？如果我们收到第三条或更多的与订单相关的消息，会发生什么？嗯，我们最终会在数据框中有很多变量。具体来说，我们会根据发送给单个订单的消息的最大数量来组合变量。对于没有这么多消息的订单，单元格的内容会是什么？它们将是空的。这将浪费很多空间！此外，数据的一般结构会感觉很不舒服。一定有更好的方法。
- en: If you think about it, it feels like the messages and the sales are two different
    things and that they should be kept separate, doesn't it? If you think about it
    that way, you are right. So let's imagine that, let's keep one data frame for
    the sales orders and another for the messages. There is another problem. Can you
    see it? How are we going to tell which messages belong to which sales orders?
    Identifiers to the rescue! We can add `SALE_ID` to the sales data frame, where
    it should be unique, and we can add the same `SALE_ID` to the messages data frame,
    where it will not be unique because there can be multiple messages related to
    the same sales order. This means we have a one-to-many relation. With this in
    mind, the sales data frame would have all the variables we mentioned earlier,
    minus the `DATE`, `STARS`, and `MESSAGE` variable for the messages (don't confuse
    the sales order `DATE` with the `DATE` for each message), and those three variables
    would conform to the separate messages data frame. Both data frames would have
    a `SALE_ID` variable. Great; we're past that one.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你这样想，感觉消息和销售是两回事，它们应该分开保存，不是吗？如果你这样想，你就对了。那么，让我们想象一下，让我们保留一个数据框用于销售订单，另一个用于消息。还有一个问题。你能看到吗？我们如何区分哪些消息属于哪个销售订单？标识符来帮忙！我们可以在销售数据框中添加
    `SALE_ID`，它应该是唯一的，我们可以在消息数据框中添加相同的 `SALE_ID`，它将不是唯一的，因为可能有多个消息与同一销售订单相关。这意味着我们有一个一对一的关系。考虑到这一点，销售数据框将包含我们之前提到的所有变量，但不包括消息的
    `DATE`、`STARS` 和 `MESSAGE` 变量（不要将销售订单的 `DATE` 与每条消息的 `DATE` 混淆），这三个变量将符合单独的消息数据框。两个数据框都将有一个
    `SALE_ID` 变量。太好了；我们解决了这个问题。
- en: The too-much-repeated-data problem
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过多重复数据的问题
- en: What variable do we still have in the sales data frame? Well, to phrase it in
    such a way as to make the problem very obvious, we still have the sales variables
    and the customer's variables. So, what might the problem be? Well, each time a
    customer makes a new purchase, we save her `BIRTH_DATE`, `CLIENT_SINCE`, `GENDER`,
    and `STARS` information again. What if a frequent customer has 100 different purchases
    with The Food Factory? Well, her information will be repeated 100 times! We need
    to fix that. How might we do it? We do the same thing we did before, separate
    things that are different. That's right. We create a separate data frame for the
    customer data, and we already know how to link the customers with the sales since
    we used that same technique in the previous problem, we create identifiers in
    both data frames. This is a many-to-one relation (from the point of view of the
    sales data towards the customers' data). I'm sure you can figure out which variables
    belong to which data frames.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在销售数据框中我们还有哪些变量？嗯，为了使问题非常明显，我们仍然有销售变量和客户的变量。那么，问题可能是什么？嗯，每次客户进行新的购买时，我们都会再次保存她的`BIRTH_DATE`、`CLIENT_SINCE`、`GENDER`和`STARS`信息。如果一个常客在食品工厂有100次不同的购买呢？嗯，她的信息将会重复100次！我们需要解决这个问题。我们该如何做呢？我们做和之前一样的事情，分离不同的事物。没错。我们为客户数据创建一个单独的数据框，并且我们已经知道如何将客户与销售联系起来，因为我们之前在处理前一个问题时就使用了同样的技术，我们在两个数据框中创建标识符。这是一个多对一的关系（从销售数据的角度来看客户的资料）。我相信你能想出哪些变量属于哪个数据框。
- en: By eliminating the repeated data, we're also eliminating the possibility of
    accidentally changing some of those repeated values and then being confused about
    which ones are correct.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通过消除重复数据，我们也消除了意外更改这些重复值并对此感到困惑的可能性。
- en: 'To recapitulate, what we have done is break up a huge initial table that contained
    all the information in a single place into three different tables that are linked
    through identifiers, in such a way that we represent different things in each
    table (sales, clients, and client messages), while eliminating a lot of wasted
    space and repeated values. To get more intuition on how is organized after these
    adjustments, we can take a look at the following image which shows what data attributes
    belong to which entities, and how they are related among each other:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回顾，我们所做的是将一个包含所有信息的巨大初始表分解成三个不同的表，这些表通过标识符相互链接，这样我们可以在每个表中表示不同的事物（销售、客户和客户消息），同时消除很多浪费的空间和重复的值。为了更好地理解这些调整后的组织结构，我们可以查看以下图像，它显示了哪些数据属性属于哪些实体，以及它们之间是如何相互关联的：
- en: '![](img/00028.jpeg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00028.jpeg)'
- en: Data entities and attributes for the simulation
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟的数据实体和属性
- en: These techniques, together with many others, are called **database normalization**,
    which can be useful in certain scenarios. There are times, however, that we will
    not want our data to be fully normalized because of performance issues, but those
    are advanced cases that we won't cover in this book. For the interested reader,
    I'd recommend looking at Silberschatz, Korth, and Sudarshan's, *Database System
    Concepts, 2010* for advanced concepts and examples.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术与许多其他技术一起被称为**数据库规范化**，在某些场景中可能很有用。然而，有时我们可能不希望我们的数据完全规范化，因为性能问题，但这些是本书不会涉及的高级案例。对于感兴趣的读者，我建议查阅Silberschatz、Korth和Sudarshan的《数据库系统概念，2010》以获取高级概念和示例。
- en: Finally, keep in mind that although we are creating our own unique identifiers
    in this chapter, in real-world applications you will be better off using a well
    established tool for such a task. The `uuid` package is specially designed to
    generate and handle **Universally Unique Identifiers** (**UUIDs**). You can find
    more information about it in its CRAN page ([https://cran.r-project.org/web/packages/uuid/index.html](https://cran.r-project.org/web/packages/uuid/index.html)).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请记住，尽管我们在本章中创建了独特的标识符，但在现实世界的应用中，你最好使用一个经过良好建立的工具来完成这样的任务。`uuid`包专门设计用来生成和处理**全球唯一标识符**（**UUIDs**）。你可以在其CRAN页面找到更多信息（[https://cran.r-project.org/web/packages/uuid/index.html](https://cran.r-project.org/web/packages/uuid/index.html))。
- en: Simulating the sales data
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟销售数据
- en: 'Enough concepts; let''s start programming. To get a clear idea of where we''re
    heading, we start by initializing the `sales` data frame we will be using, with
    zero observations for now. We do so by defining the available categories for each
    factor variable, and defining empty values with the data type we need for each
    variable. As you can see, it has the identifiers `SALE_ID` and `CLIENT_ID`, which
    will allow us to link this data with the one from `clients` and `client_messages`.
    To understand this, let''s have a look at the following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 足够的概念了；让我们开始编程。为了清楚地了解我们将要走向何方，我们首先初始化我们将要使用的`sales`数据框，目前为零观察值。我们通过定义每个因子变量的可用类别，并定义每个变量所需的数据类型来空值。如您所见，它有`SALE_ID`和`CLIENT_ID`标识符，这将允许我们将这些数据与`clients`和`client_messages`中的数据联系起来。为了理解这一点，让我们看一下以下代码：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This way of initializing an empty data frame, as opposed to many other methods
    you may find elsewhere, is safer, since you'll have the correct column types from
    the beginning. If your code relies on some column type checking (as we will do),
    it will work even with a data frame with zero rows (as is the case here).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与你可能在其他地方找到的许多其他方法相比，这种初始化空数据框的方式更安全，因为你从一开始就会拥有正确的列类型。如果你的代码依赖于某些列类型检查（正如我们将要做的那样），它甚至会在零行数据的数据框中工作（正如这里的情况）。
- en: Simulating numeric data according to distribution assumptions
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据分布假设模拟数值数据
- en: We will generate the data for each column separately and then we'll recreate
    the data frame with it. We want to start with the easy parts first, so we'll take
    a look at the simulation for `QUANTITY`, `COST`, `PRICE`, and `DISCOUNT`. The
    easy way would be to just simulate some random numbers and make sure they are
    within some range by multiplying or dividing them accordingly. We could also use
    the `round()` function to make sure `QUANTITY` is not fractional. However, if
    we want to do it the correct way, then we must consider the underlying assumptions
    in each of those numbers. An image showing the distributions mentioned in the
    following paragraphs is shown below.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分别生成每一列的数据，然后用这些数据重新创建数据框。我们想先从简单的部分开始，所以我们将查看`QUANTITY`、`COST`、`PRICE`和`DISCOUNT`的模拟。简单的方法就是随机生成一些数字，并通过相应的乘除确保它们在某个范围内。我们也可以使用`round()`函数确保`QUANTITY`不是分数。然而，如果我们想正确地做这件事，那么我们必须考虑这些数字背后的假设。下面段落中提到的分布的图像如下所示。
- en: '![](img/00029.jpeg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00029.jpeg)'
- en: Distributions for COST, PRICE, QUANTITY and DISCOUNT
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: COST、PRICE、QUANTITY和DISCOUNT的分布
- en: 'The `COST` and `PRICE` value follow a normal distribution because they are
    real numbers. On average, `COST` should be lower than `PRICE`, so we will set
    their respective mean parameters accordingly. Note that this allows for the possibility
    of some foods being sold for less than their production cost, which sometimes
    happens when companies are trying to minimize losses. `DISCOUNT` follows an exponential
    distribution because we want most discounts to be zero, or low (compared to the
    price). This means that we don''t give out discounts often, and when we do, they
    will be small. `QUANTITY` follows a *Poisson distribution* because it needs to
    be an integer. A good resource is Sean Owen''s *Common Probability Distributions:
    The Data Scientist''s Crib Sheet, 2015* ( [https://blog.cloudera.com/blog/2015/12/common-probability-distributions-the-data-scientists-crib-sheet/](https://blog.cloudera.com/blog/2015/12/common-probability-distributions-the-data-scientists-crib-sheet/)).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`COST`和`PRICE`的值遵循正态分布，因为它们是实数。平均而言，`COST`应该低于`PRICE`，因此我们将相应地设置它们的均值参数。请注意，这允许某些食品以低于其生产成本的价格出售，这在公司试图最小化损失时有时会发生。`DISCOUNT`遵循指数分布，因为我们希望大多数折扣为零或低（与价格相比）。这意味着我们不会经常提供折扣，而且当提供时，折扣会很小。`QUANTITY`遵循泊松分布，因为它需要是一个整数。一个很好的资源是Sean
    Owen的*《常见概率分布：数据科学家的便签，2015》*（[https://blog.cloudera.com/blog/2015/12/common-probability-distributions-the-data-scientists-crib-sheet/](https://blog.cloudera.com/blog/2015/12/common-probability-distributions-the-data-scientists-crib-sheet/))。'
- en: 'Given these assumptions, we will create three functions. `COST` and `PRICE` are
    simulated with the `random_values()` function, while `QUANTITY` and `DISCOUNT` have
    their own functions. The `random_values()` function uses the `rnorm()` function
    to simulate `n` values (where `n` is the number of rows we want in the data frame)
    using the normal distribution, with a specific `mean` and standard deviation (`sqrt(variance)`).
    We then take these values and round them to two decimal places using the `round()` function
    as shown in the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些假设的基础上，我们将创建三个函数。`COST` 和 `PRICE` 通过 `random_values()` 函数进行模拟，而 `QUANTITY`
    和 `DISCOUNT` 则有它们自己的函数。`random_values()` 函数使用 `rnorm()` 函数通过正态分布模拟 `n` 个值（其中 `n`
    是我们希望在数据框中拥有的行数），具有特定的 `mean` 和标准差（`sqrt(variance)`）。然后我们使用 `round()` 函数将这些值四舍五入到两位小数，如下所示：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `random_discounts()` function uses the `rexp()` function to simulate `n` values
    using the exponential distribution with the `lambda` parameter, and, as we did
    before, we use the `round()` function to round the values to two decimal places.
    When we use this function, we''ll use a very high `lambda` parameter (100) to
    heavily skew the distribution to the right so that we get a lot of zeros in the
    simulation. However, this will make our values be very small (for example, 0.021).
    If we use these values directly, our discounts will be of a couple of cents, which
    is not realistic. Therefore, we multiply these values by 100 to get discounts
    that are a couple of dollars. Note that if we first round and then multiply by
    100, we get full dollar discounts (for example, $2), but if we first multiply
    by 100 and then round, we get discounts that include cents (for example, $2.1),
    which is something we prefer to avoid, but it would work just as well. Let''s
    have a look at the following code to understand this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`random_discounts()` 函数使用 `rexp()` 函数通过指数分布模拟 `n` 个值，使用 `lambda` 参数，并且像之前一样，我们使用
    `round()` 函数将值四舍五入到两位小数。当我们使用这个函数时，我们会使用一个非常高的 `lambda` 参数（100）来严重偏斜分布到右侧，以便在模拟中获得很多零。然而，这将使我们的值变得非常小（例如，0.021）。如果我们直接使用这些值，我们的折扣将只有几美分，这是不现实的。因此，我们将这些值乘以
    100 以获得几美元的折扣。请注意，如果我们先四舍五入然后乘以 100，我们得到的是整美元折扣（例如，$2），但如果我们先乘以 100 再四舍五入，我们得到的折扣将包括分（例如，$2.1），这是我们希望避免的，但它也会同样有效。让我们看一下以下代码来理解这一点：'
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `random_quantities()` function uses the `rpois()` function to simulate
    `n` values using the *Poisson distribution* with the `lambda` parameter. In this
    case, we don''t need to round, because the values will already be integers. However,
    we do add `1` to each value, because we might get zero as a quantity, and having
    a sales order with zero foods would not make sense. Adding `1`  guarantees we
    have at least one food in each sales order:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`random_quantities()` 函数使用 `rpois()` 函数通过泊松分布模拟 `n` 个值，使用 `lambda` 参数。在这种情况下，我们不需要四舍五入，因为值将已经是整数。然而，我们给每个值加
    `1`，因为我们可能会得到零作为数量，而拥有零食品的销售订单是没有意义的。加 `1` 保证每个销售订单中至少有一件食品：'
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Simulating categorical values using factors
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用因子模拟分类值
- en: The `random_levels()` function simulates `n` categorical values by sampling
    the `levels` provided with replacement (controlled by the third parameter, which
    is sent as `TRUE`). You can think about the `levels` as an array of strings, each
    of which is a possible value for the simulation. These `levels` will come from
    the categories defined for factor variables in the data frame (`PROTEIN_SOURCE`,
    `STORE`, `DELIVERY`, `STATUS`, and `PAID`). A sample with replacement means that
    every time we pick one of the values from the `levels` object, we return it so
    that we can pick it again later. Sampling without replacement only makes sense
    when you want a number of samples that is smaller than the total amount of values
    available, which is not the case here, since we want to simulate thousands of
    rows and we won't have that many `levels`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`random_levels()` 函数通过有放回地抽样提供的 `levels` 来模拟 `n` 个分类值（由第三个参数控制，发送为 `TRUE`）。你可以把
    `levels` 视为一个字符串数组，每个字符串都是模拟的可能值。这些 `levels` 将来自数据框中因子变量定义的类别（`PROTEIN_SOURCE`、`STORE`、`DELIVERY`、`STATUS`
    和 `PAID`）。有放回的抽样意味着每次我们从 `levels` 对象中选择一个值时，我们都会返回它，以便我们稍后可以再次选择它。不进行放回的抽样只有在你想得到比可用的总值数量少的样本数量时才有意义，而这在这里不是情况，因为我们想模拟成千上万的行，我们不会有那么多
    `levels`。'
- en: 'There''s a third parameter that we have not mentioned, the `probabilities` parameter.
    As you can see, by default it''s set to `NULL`, but we do send an object there;
    it must be a vector of numbers between 0 and 1, such that they sum to 1 and they
    represent the probability of picking a specific category. The order of this `probabilities` object
    must be the same as in the `levels` object. For example, if we have three possible
    levels and we send the `probabilities` object as `c(0.2, 0.3, 0.5)`, the first
    level will have a 20% probability of being picked, while the second and third
    levels will have probabilities of 30% and 50%, respectively. Note that the probabilities
    add up to one. Let''s have a look at the code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个未提及的第三个参数，即`probabilities`参数。如您所见，默认情况下它设置为`NULL`，但我们确实发送了一个对象到那里；它必须是一个介于0和1之间的数字向量，它们的和为1，并且代表选择特定类别的概率。这个`probabilities`对象的顺序必须与`levels`对象中的顺序相同。例如，如果我们有三个可能的级别，并且将`probabilities`对象发送为`c(0.2,
    0.3, 0.5)`，则第一个级别将有20%的概率被选中，而第二个和第三个级别将分别有30%和50%的概率。请注意，概率的总和为1。让我们看看代码：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that we don't check whether the `probabilities` object is being sent as
    `NULL` before we pass it along to the `sample()` function. This can be done because
    the corresponding parameter in the `sample()` function also uses `NULL` as a default,
    and interprets it as using equal probabilities for all the values. You can check
    this in the function's documentation.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在我们将`probabilities`对象传递给`sample()`函数之前，我们没有检查该对象是否为`NULL`。这是因为`sample()`函数中对应的参数也默认使用`NULL`，并将其解释为对所有值使用相等的概率。您可以在函数的文档中查看这一点。
- en: 'To test that the probabilities are being implemented correctly, we can simulate
    100 values and then create a table with the results to see the amount of values
    produced for each of the categories. As you can see, if we simulate `100` values
    of the categories `A`, `B`, and `C`, with 20%, 30%, and 50% probabilities, we
    get 18%, 37%, and 45% proportions, respectively. These results are close enough
    to our specifications, and thus, correct. Note that you will get different values
    every time you re-execute the code, and they will almost never be the exact values
    you specified, which is natural in simulations. However, they should almost always
    be close to the specifications:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试概率是否被正确实现，我们可以模拟100个值，然后创建一个包含结果的表格，以查看每个类别的生成值的数量。如您所见，如果我们模拟类别`A`、`B`和`C`的`100`个值，其概率分别为20%、30%和50%，我们得到的比例分别为18%、37%和45%。这些结果与我们的规格足够接近，因此是正确的。请注意，每次重新执行代码时，您都会得到不同的值，并且它们几乎永远不会是您指定的确切值，这在模拟中是自然的。然而，它们应该几乎总是接近规格：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Simulating dates within a range
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在范围内模拟日期
- en: 'The `random_dates_in_range()` function uses the same `sample()` function we
    used before, but instead of receiving a list of strings as categories from factor
    variables, it will receive a list of dates. To generate the full set of valid
    dates for the simulation, we use the `seq()` function. This function will generate
    all values from the `start` to the `end` by a specific interval. If we want to
    generate all odd numbers between 1 and 10, we will use `seq(1, 10, 2)`, which
    means that it will take `1` and add `2` to it sequentially until `10` is reached.
    In our case, we want the increment to be a full day, and, conveniently, the `seq()` function
    provides this capability when sending date objects by sending the increment as
    the string `"day"`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`random_dates_in_range()`函数使用了我们之前使用的相同的`sample()`函数，但它不会从因子变量接收字符串列表作为类别，而是会接收日期列表。为了生成模拟的有效日期的全集，我们使用`seq()`函数。此函数将根据特定的间隔生成从`start`到`end`的所有值。如果我们想生成1到10之间的所有奇数，我们将使用`seq(1,
    10, 2)`，这意味着它将按顺序将`1`加上`2`，直到达到`10`。在我们的情况下，我们希望增量为一个完整的天，并且方便的是，`seq()`函数在发送日期对象时通过发送增量字符串`"day"`提供了这种能力：'
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note that this will only work when sending *date* objects. If you try to test
    this function with strings, you will get an error saying that `''from'' cannot
    be NA, NaN, or infinite`. Instead, you should convert those strings to dates with
    the `as.Date()` function:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这仅在发送*日期*对象时才会起作用。如果您尝试用字符串测试此函数，您将得到一个错误，表明`'from'不能是NA、NaN或无穷大`。相反，您应该使用`as.Date()`函数将这些字符串转换为日期：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Simulating numbers under shared restrictions
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在共享限制下模拟数字
- en: As you may remember, The Food Factory creates their foods by receiving a macronutrient
    specification. Customers can specify whatever combination of percentages they
    want for each one, as long as they add up to 1\. Now we are going to simulate
    these macronutrient percentages. This will require a little more work than the
    previous cases.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所记得，食品工厂通过接收宏量营养素规格来创建他们的食品。客户可以指定他们想要的每个食品的百分比组合，只要它们的总和为1。现在我们将模拟这些宏量营养素百分比。这比之前的案例需要更多的工作。
- en: 'First, we create a function that will return numeric triples, where each number
    is between 0 and 1, and together they add up to 1\. To accomplish this, we will
    use two random numbers and make the third one dependent on the first two. We will
    use the following mathematical fact:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个函数，该函数将返回数值三元组，其中每个数字介于0和1之间，并且它们加起来等于1。为了实现这一点，我们将使用两个随机数，并将第三个数依赖于前两个数。我们将使用以下数学事实：
- en: '![](img/00030.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00030.jpeg)'
- en: 'This tells us to take one number as *1 - max(a, b)*, another as *min(a, b)*,
    and the last one as *abs(a, b)*; which is exactly what we do in the `random_triple()` function.
    Doing so mathematically guarantees that we will get three random numbers between
    0 and 1 that together add up to 1\. Note that the `random_triple()` is one of
    the few functions we have created which does not require any arguments at all,
    which makes sense, since we don''t need *external* information to simulate the
    triple:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们取一个数字为*1 - max(a, b)*，另一个为*min(a, b)*，最后一个为*abs(a, b)*；这正是我们在`random_triple()`函数中所做的。从数学上保证我们将得到三个介于0和1之间的随机数，它们加起来等于1。请注意，`random_triple()`是我们创建的少数几个不需要任何参数的函数之一，这是有意义的，因为我们不需要*外部*信息来模拟三元组：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can test that it''s working simply by using `sum()` over the result:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过对结果使用`sum()`来简单地测试它是否工作：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now we want to generate `n` of these triples. To do so, we use the `replicate()` function
    to produce `n` triples. The `TRUE` argument corresponds to the `simplify` argument
    of the function, which will reduce a list of triples to matrix form, which is
    easier to work with in this particular case. When we are testing the code and
    look at the results of `replicate(n, random_triple(), TRUE)`, we will find that
    the resulting structure is the transpose of what we want, meaning that it has
    three rows and `n` columns, where each row represents a macronutrient percentage
    and each column represents an observation. We want to transpose this structure
    to get the macronutrient percentages as columns and the observations as rows;
    to do so, we simply use the `t()` function. After that, we simply create a data
    frame with the corresponding values for each macronutrient:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要生成`n`个这样的三元组。为此，我们使用`replicate()`函数来生成`n`个三元组。`TRUE`参数对应于函数的`simplify`参数，它将三元组列表简化为矩阵形式，这在特定情况下更容易处理。当我们测试代码并查看`replicate(n,
    random_triple(), TRUE)`的结果时，我们会发现结果结构是我们想要的转置，这意味着它有三行和`n`列，其中每一行代表宏量营养素百分比，每一列代表一个观察值。我们想要转置这个结构，以得到宏量营养素百分比作为列，观察值作为行；为此，我们只需使用`t()`函数。之后，我们只需创建一个包含每个宏量营养素对应值的data
    frame：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Simulating strings for complex identifiers
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟复杂标识符的字符串
- en: It's time for the most complex part of the simulation, the identifiers. We want
    to produce `n` identifiers, and, depending on what identifiers we are simulating,
    we may want them to be unique. Client identifiers in the client data must be unique,
    because we don't want two distinct clients with the same identifier, and our clients'
    data will not have repeated records by design. On the other hand, we don't want
    unique client identifiers in the sales data, because we want *repeated* clients
    to appear in there.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候模拟最复杂的一部分了，即标识符。我们想要生成`n`个标识符，并且根据我们模拟的标识符类型，我们可能希望它们是唯一的。客户数据中的客户标识符必须是唯一的，因为我们不希望有两个具有相同标识符的不同客户，并且根据设计，我们的客户数据将不会有重复的记录。另一方面，我们不想在销售数据中有唯一的客户标识符，因为我们希望*重复*的客户出现在那里。
- en: We could create two distinct functions that take care of these cases independently,
    but it's easy enough to combine them into a single function by just using a `reduction` parameter
    that specifies the percentage of unique identifiers. If the `reduction` parameter
    is sent as 0 (the default), we assume that full unique identifiers are requested.
    We will assume that identifiers are composed of a group of letters followed by
    a group of digits, and each group's length should be specified separately. That's
    what the `n_letters` and `n_digits` are for. Our implementation will work by creating
    the letters and digits groups separately and then combining them.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建两个不同的函数来独立处理这些情况，但通过使用一个指定唯一标识符百分比的`reduction`参数，我们可以很容易地将它们合并成一个函数。如果`reduction`参数设置为0（默认值），我们假设需要完整的唯一标识符。我们将假设标识符由一组字母后跟一组数字组成，并且每组长度应单独指定。这就是`n_letters`和`n_digits`的作用。我们的实现将通过分别创建字母和数字组，然后组合它们来实现。
- en: First, we will create the letter combinations by taking a sample from the `LETTERS` group
    (an internal R object which contains all ASCII letters in the capitalized form)
    of size `n` with replacement (we may have repeated letters in each identifier).
    Then, we are going to replicate this sample for `n_letters`, which is the amount
    of letters we need in each identifier, and we won't simplify the structure, which
    is why we send the `FALSE` parameter. This will return a list with `n_letters` elements,
    where each element is a vector of `n` letters. Now we want to paste these objects
    together. To do so, we use the `paste0()` function (which is a shortcut for the
    `paste()` function that collapses everything together, if you just use `paste()`,
    you will get spaces between the letters). However, we can't send our construction
    to `paste0()` because we will get some garbage out. We need to use the `do.call()` function
    to this properly. To understand what is going on, let's assume that `n_letters`
    is 5, and see how the code behaves.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将通过从`LETTERS`组（一个包含所有大写ASCII字母的内部R对象）中抽取大小为`n`的样本（我们可能在每个标识符中都有重复的字母）来创建字母组合。然后，我们将对这个样本进行`n_letters`次复制，这是每个标识符中所需的字母数量，我们不会简化结构，这就是为什么我们发送`FALSE`参数。这将返回一个包含`n_letters`个元素的列表，其中每个元素是一个包含`n`个字母的向量。现在我们想要将这些对象粘合在一起。为了做到这一点，我们使用`paste0()`函数（它是`paste()`函数的一个快捷方式，如果只使用`paste()`，你将在字母之间得到空格）。然而，我们不能将我们的构建发送到`paste0()`，因为我们将会得到一些垃圾输出。我们需要使用`do.call()`函数来正确地做到这一点。为了理解正在发生的事情，让我们假设`n_letters`是5，看看代码是如何表现的。
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now we will focus on the digit combinations. Our objective is to get a number
    between zero and the number formed of `n_digits` nines. For example, if `n_digits` is
    5, we want numbers between 0 and 99,999\. This will be broken into two steps.
    First, create the dynamic right-extreme number composed of only nines. Then, make
    sure that it has exactly `n_digit` digits, even if the natural way of representing
    the number does not. This means that if `n_digits` is 5 and the number we end
    up sampling is 123, we need to use 00123 as the result, since we need to ensure
    `n_digit` digits.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将关注数字组合。我们的目标是得到一个介于零和由`n_digits`个九组成的数字之间的数字。例如，如果`n_digits`是5，我们希望得到0到99,999之间的数字。这将被分为两个步骤。首先，创建一个由九组成的动态右极端数字。然后，确保它恰好有`n_digit`位数字，即使自然表示数字的方式不是这样。这意味着如果`n_digits`是5，而我们最终抽取的数字是123，我们需要使用00123作为结果，因为我们需要确保有`n_digit`位数字。
- en: To accomplish the first part, we use `replicate()` to repeat the string **9** `n_digits` times.
    Then we use `paste()` with `collapse = ""` to put all the strings together, resulting
    in a string such as **99999**. Then we convert that string into a number by using
    the `as.numeric()` function. We end up with the desired number of nines in the
    `max_number` object.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成第一部分，我们使用`replicate()`函数重复字符串**9**`n_digits`次。然后我们使用`paste()`函数，并设置`collapse
    = ""`来将所有字符串组合在一起，得到一个如**99999**的字符串。然后我们使用`as.numeric()`函数将这个字符串转换为数字。最终我们在`max_number`对象中得到了所需的九位数。
- en: 'Then we use the `sprintf()` function to make sure we have `n_digits` when using
    the number. To do so, we specify the `format` with a pre-fill of zeros (using
    the `"%0"` syntax), such that we have `n_digits` (using the `n_digits` followed
    by the `d` letter for digits). We put this inside a `paste()` function because
    the `format` string will be created dynamically. Following the example stated
    before, it would be `"%05d"` for 5 digits. For more information on how to use
    the `sprintf()` function, take a look at [Chapter 1](part0022.html#KVCC0-f494c932c729429fb734ce52cafce730),
    *Introduction to R*. These lines combined give us:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用 `sprintf()` 函数来确保在使用数字时具有 `n_digits` 位。为此，我们指定一个带有前导零的 `format`（使用 `"%0"`
    语法），这样我们就有 `n_digits` 位（使用 `n_digits` 后跟 `d` 字母表示数字）。我们将这个格式放在 `paste()` 函数中，因为格式字符串将会动态创建。按照之前的例子，如果是
    5 位数字，将会是 `"%05d"`。有关如何使用 `sprintf()` 函数的更多信息，请参阅 [第 1 章](part0022.html#KVCC0-f494c932c729429fb734ce52cafce730)，*R
    语言简介*。这些行结合起来给我们：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now we need to paste the `letters` and `digits` objects together by using the
    `paste0()` function again. Since this is a vectorized operation, we will end up
    with a single array of `n` identifiers. Note that even though we have not enforced
    uniqueness, the probability of the sampling procedures producing repeated identifiers
    is so extremely low that we won't worry about it here.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要再次使用 `paste0()` 函数将 `letters` 和 `digits` 对象粘贴在一起。由于这是一个向量操作，我们最终将得到一个包含
    `n` 个标识符的单个数组。请注意，尽管我们没有强制唯一性，但采样程序产生重复标识符的概率极低，所以我们在这里不会担心。
- en: Real-world problems have a surprising ability to produce these extremely low
    probability cases, making careless code fail. If you are developing critical applications,
    always make sure you check for these cases explicitly.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现实世界的问题具有产生这些极低概率情况的惊人能力，使得粗心的代码会失败。如果你正在开发关键应用，请务必明确检查这些情况。
- en: 'Finally, if `reduction` is greater than zero, meaning that we want to use only
    the `reduction` percentage of the identifiers created so far to generate the total
    of `n` identifiers, we will use the `sample()` function to get `n` identifiers
    from the first `reduction` percentage identifiers, which is computed as an array
    from 1 to the floor of the percentage (must be an integer) of the `ids`, and we
    will do it with replacement (hence the `TRUE` parameter). If `reduction` is zero,
    we simply send the `ids` we have created so far without any modifications:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果 `reduction` 大于零，意味着我们只想使用到目前为止创建的标识符的 `reduction` 百分比来生成总共 `n` 个标识符，我们将使用
    `sample()` 函数从第一个 `reduction` 百分比标识符中获取 `n` 个标识符，这被计算为一个从 1 到 `ids` 百分比下限的数组（必须是整数），并且我们将进行有放回的抽样（因此有
    `TRUE` 参数）。如果 `reduction` 为零，我们只需发送到目前为止创建的 `ids` 而不进行任何修改：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Putting everything together
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将一切组合起来
- en: Now that we have done the hard work of creating all our simulation functions,
    we can just assemble them inside a general function that will use them to easily
    simulate the data for us. The first thing we note is that there are a lot of parameters
    that we need to control, and if we create a function signature that contains all
    of these parameters explicitly, we will be constraining ourselves by having a
    rigid signature that is hard to work with. We don't want to deal with these parameters
    by hand because it will make it cumbersome to work with the code. What if we could
    pass a single parameter that would mutate for us as we require? Well, we can do
    that! Parameter objects exist for this reason. They are a simple concept to grasp
    and provide a lot of flexibility. They are lists that are packed before being
    sent to the function and are unpacked inside the function to be used as needed
    inside nested functions. This is a form of *encapsulation*. We will look deeper
    into encapsulation in [Chapter 8](part0178.html#59O440-f494c932c729429fb734ce52cafce730),
    *Object-Oriented System to Track Cryptocurrencies*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了创建所有模拟函数的艰苦工作，我们只需将它们组装在一个通用函数中，该函数将使用它们来轻松地为我们模拟数据。我们首先注意到有很多参数需要我们控制，如果我们创建一个包含所有这些参数的显式函数签名，我们将通过具有刚性签名来约束自己，这使得工作变得困难。我们不希望手动处理这些参数，因为这会使代码变得繁琐。如果我们能传递一个会根据我们的需求进行变化的单个参数会怎样？嗯，我们可以做到！参数对象就是为了这个原因而存在的。这是一个简单易懂的概念，提供了很多灵活性。它们是在发送到函数之前打包的列表，并在函数内部解包以供嵌套函数内部按需使用。这是一种
    *封装* 的形式。我们将在 [第 8 章](part0178.html#59O440-f494c932c729429fb734ce52cafce730)，*面向对象系统跟踪加密货币*
    中深入了解封装。
- en: Next, we note that since these simulations are stochastic processes, meaning
    we may get different results every time we execute them, we may lose the reproducibility
    of our results. To avoid this, we simply set the seed at the beginning of the
    simulations to make sure we get the same results every time, just as we did in
    [Chapter 3](part0076.html#28FAO0-f494c932c729429fb734ce52cafce730), *Predicting
    Votes with Linear Models*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们注意到，由于这些模拟是随机过程，这意味着每次执行时我们可能会得到不同的结果，我们可能会失去结果的可重复性。为了避免这种情况，我们只需在模拟开始时设置种子，以确保每次都能得到相同的结果，就像我们在[第3章](part0076.html#28FAO0-f494c932c729429fb734ce52cafce730)“使用线性模型预测选票”中所做的那样。
- en: 'The rest of the code is simply calling the functions we have already created
    with the appropriate arguments, which come from the parameters object we unpack
    at the beginning. There are three things worth noting. First, we can’t simply
    use the `random_composition()` function directly into one of the variables in
    the data frame we create because the resulting object contains data for three
    different variables in the data frame. Therefore we need to store an intermediate
    object with the results, `composition`, and then use it to extract the information
    for each macronutrient. Second, we use the `stringsAsFactors` argument of the
    `data.frame()` function as `FALSE` to make sure that `SALE_ID` and `CLIENT_ID`
    are not treated as factors (since they are strings). When factors start having
    many categories inside, processing data frames becomes slower, and we can avoid
    that by treating them as simple strings since we will have lots of unique identifiers.
    Third, since we are treating all strings as non-factors and we may not get all
    of the possible categories in our sample when using `random_levels()` the factor
    variable may be defined without some of the factors we previously specified. To
    make sure this doesn’t happen we explicitly define the levels inside the `factor()`
    function to be the levels in the original sales data frame sent to the function
    which contains the data from our initial definition:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的代码只是调用我们已创建的函数，并使用来自我们开始解包的参数对象的适当参数。有三点值得注意。首先，我们不能直接将`random_composition()`函数用于我们创建的数据框中的变量之一，因为结果对象包含数据框中三个不同变量的数据。因此，我们需要存储一个包含结果的中间对象`composition`，然后使用它来提取每个宏量营养素的信息。其次，我们使用`data.frame()`函数的`stringsAsFactors`参数设置为`FALSE`，以确保`SALE_ID`和`CLIENT_ID`不被视为因子（因为它们是字符串）。当因子内部有多个类别时，处理数据框会变慢，我们可以通过将它们视为简单的字符串来避免这种情况，因为我们会有很多唯一的标识符。第三，由于我们将所有字符串视为非因子，并且在使用`random_levels()`时可能不会在我们的样本中获得所有可能的类别，因子变量可能没有我们之前指定的某些因子被定义。为了确保这种情况不会发生，我们明确地在`factor()`函数内部定义级别，使其与原始销售数据框中的级别相同，该数据框包含我们从初始定义中发送给函数的数据：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Finally, to create our simulation, we create the `parameters` object with the
    necessary information, and update our `sales` object using the `random_sales_data()` function.
    In this case we are going to simulate 10,000 sales orders between January 2015
    (`date_start`) and today's date (`date_end`, using the `Sys.Date()` function to
    generate the date for today). We require our identifiers to have five letters
    (`n_letters`) followed by five digits (`n_digits`), and we want our `CLIENT_ID` to
    use only the first 25% of the generated identifiers to allow for repeated customers
    (`reduction`).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了创建我们的模拟，我们使用必要的`parameters`对象创建`sales`对象，并使用`random_sales_data()`函数更新我们的`sales`对象。在这种情况下，我们将模拟2015年1月（`date_start`）和今天日期（`date_end`，使用`Sys.Date()`函数生成今天的日期）之间的10,000个销售订单。我们需要我们的标识符由五个字母（`n_letters`）后跟五个数字（`n_digits`）组成，并且我们希望`CLIENT_ID`只使用生成的标识符的前25%以允许重复的客户（`reduction`）。
- en: 'We want five foods per sales order on average (`quantity_lambda`), with production
    costs with a mean of 30 (`cost_mean`) and variance of 10 (`cost_variance`), and
    prices with a mean of 50 (`price_mean`) and a variance of 10 (`price_variance`).
    We also want discounts around 1 or 2 USD (`discount_lambda`; remember the transformation
    we did inside the corresponding function). Finally, we want the probabilities
    of `PENDING`, `DELIVERED`, `RETURNED`, and `CANCELLED` as `STATUS` to be 20%,
    60%, 10%, and 10%, respectively. Similarly, we want the probabilities of an order
    being paid to be 90%:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望每个销售订单平均有五种食品（`quantity_lambda`），生产成本的平均值为30（`cost_mean`）和方差为10（`cost_variance`），价格的平均值为50（`price_mean`）和方差为10（`price_variance`）。我们还希望折扣在1或2美元左右（`discount_lambda`；记得我们在相应函数内部所做的转换）。最后，我们希望`PENDING`、`DELIVERED`、`RETURNED`和`CANCELLED`状态的概率分别为20%、60%、10%和10%。类似地，我们希望订单付款的概率为90%：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can have fun with these parameters and simulate many different kinds of
    scenarios. For example, if you want to simulate a company that has been doing
    very badly with thin margins or even losses, you can bring the means of costs
    and prices together, and maybe even increase their respective variances to make
    sure there are a lot of crossovers, meaning losses per sale order.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以玩转这些参数，并模拟许多不同类型的场景。例如，如果你想模拟一家经营状况不佳、利润微薄甚至亏损的公司，你可以将成本和价格手段结合起来，甚至可能增加它们各自的方差，以确保有很多交叉点，即每笔销售订单的损失。
- en: Congratulations! You now know how to produce non-trivial data simulations. With
    this knowledge, you can have a lot of fun simulating many kinds of data. We encourage
    you to expand this example and play around with its analysis using the knowledge
    from the following chapters.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你现在知道如何产生非平凡的数据模拟。有了这些知识，你可以模拟许多种类的数据，享受其中的乐趣。我们鼓励你扩展这个例子，并使用以下章节中的知识来分析它。
- en: Simulating the client data
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟客户数据
- en: Now that we have gone through the sales data simulation and we have the necessary
    fundamentals, the rest of the data simulation will be much easier. Furthermore,
    we will use many of the functions we created before to simulate the client and
    client messages data, which is great! Reusing functions like this is very efficient,
    and over time you will get into the habit of doing so. You will build your own
    collection of reusable code, which will make you increasingly more efficient when
    programming.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了销售数据模拟，并且拥有了必要的基本数据，接下来的数据模拟将会容易得多。此外，我们将使用之前创建的许多函数来模拟客户和客户消息数据，这真是太好了！像这样重用函数非常高效，随着时间的推移，你将养成这样的习惯。你将建立自己的可重用代码库，这将使你在编程时越来越高效。
- en: 'We start by defining the data frame we will use, just as we did before. In
    this case we will have the `CLIENT_ID`, `BIRTH_DATE`, `CLIENT_SINCE`, `GENDER`,
    and `STARS` variables. The `STARS` represent a rating between `1` (bad) and `5`
    (excellent):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义我们将使用的数据框，就像之前做的那样。在这种情况下，我们将有`CLIENT_ID`、`BIRTH_DATE`、`CLIENT_SINCE`、`GENDER`和`STARS`变量。`STARS`代表一个介于`1`（差）和`5`（优秀）之间的评分：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The first thing we note is that the `CLIENT_ID` information should not be simulated
    again, because we will get different client identifiers from the ones we already
    have in the sales data. We want unique client identifiers in the sales data to
    correspond to a record in the client data, which we accomplish by sending them
    as the `client_ids` parameter and assigning them directly into the `CLIENT_ID` variable
    in the `clients` data frame. In this case, `n` will correspond to the number of
    unique client identifiers we get, which we get by using the `length()` function.
    The other parameters we extract as we normally would with parameter objects. Specifically,
    we need the range of dates which are valid for our client''s birth dates (they
    must be at least 18 years old), as well as the valid range of dates since they
    were clients (they couldn''t have been a client before the company started operations
    in January 2015; see the parameters for the sales data simulation). The rest of
    the code is very similar to what we saw in the sales data simulation, so we won''t
    explain it again. To understand this, let''s have a look at the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要注意的是，不应再次模拟`CLIENT_ID`信息，因为我们将从销售数据中获取与现有不同的客户端标识符。我们希望在销售数据中拥有唯一的客户端标识符，以对应客户端数据中的一个记录，我们通过将它们作为`client_ids`参数发送，并将它们直接分配到`clients`数据框中的`CLIENT_ID`变量来实现这一点。在这种情况下，`n`将对应于我们获得的唯一客户端标识符的数量，我们通过使用`length()`函数来获取这个数量。我们像往常一样使用参数对象提取其他参数。具体来说，我们需要有效日期范围，这些日期对于我们的客户出生日期来说是有效的（他们必须至少18岁），以及自他们成为客户以来的有效日期范围（他们不可能在2015年1月公司开始运营之前成为客户；请参阅销售数据模拟的参数）。代码的其余部分与我们在销售数据模拟中看到的基本相同，因此我们不再解释。为了理解这一点，让我们看一下以下代码：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To simulate the client data, we simply create the corresponding parameters
    inside the parameters object and send that to the `random_clients_data()` function
    to update the `clients` data frame:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟客户数据，我们只需在参数对象内部创建相应的参数，并将其发送到`random_clients_data()`函数以更新`clients`数据框：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Did you notice how easy this was? This is because we created our fundamentals
    in the previous section, and they drastically simplified following applications
    of the same concepts. As you increase your programming skills, this will happen
    more often.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到这有多简单吗？这是因为我们在上一节中创建了我们的基础，这极大地简化了后续对相同概念的运用。随着你编程技能的提高，这种情况会越来越常见。
- en: Simulating the client messages data
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟客户消息数据
- en: 'Simulating text messages that actually make sense is very hard, and we won''t
    attempt it here. Instead, what we''ll do is leverage a dataset that was published
    about food reviews on Amazon. The dataset was published as part of the paper published
    by McAuley and Leskovec, *From amateurs to connoisseurs: modeling the evolution
    of user expertise through online reviews, 2013*. You can find the dataset in Kaggle
    ([https://www.kaggle.com/snap/amazon-fine-food-reviews](https://www.kaggle.com/snap/amazon-fine-food-reviews)).
    We won''t show the code that prepared the data for this example, but basically,
    what it does is rename the variables we want `STARS`, `SUMMARY`, and `MESSAGE`,
    delete the rest, and save the data frame into the `reviews.csv` file. For the
    interested reader, the code that accomplishes this task, as well as the original
    and processed data, is inside the code repository for this book ([https://github.com/PacktPublishing/R-Programming-By-Example](https://github.com/PacktPublishing/R-Programming-By-Example)).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟有意义的文本消息非常困难，我们在这里不会尝试。相反，我们将利用一个关于亚马逊食品评论的数据集。该数据集作为McAuley和Leskovec发表的论文的一部分发布，该论文题为《从业余爱好者到鉴赏家：通过在线评论建模用户专业知识的演变，2013年》。您可以在Kaggle上找到该数据集（[https://www.kaggle.com/snap/amazon-fine-food-reviews](https://www.kaggle.com/snap/amazon-fine-food-reviews)）。我们不会展示准备此示例数据的代码，但基本上，它所做的就是重命名我们想要的变量`STARS`、`SUMMARY`和`MESSAGE`，删除其余部分，并将数据框保存到`reviews.csv`文件中。对于感兴趣的读者，完成此任务的代码、原始数据和处理后的数据都包含在此书的代码仓库中（[https://github.com/PacktPublishing/R-Programming-By-Example](https://github.com/PacktPublishing/R-Programming-By-Example)）。
- en: 'The idea is that since it''s hard to simulate this data, we will leverage an
    already existing dataset with real reviews and sample it to get the messages we
    want for our example. As before, we start by defining the `client_messages` data
    frame we will use with the `SALE_ID`, `DATE`, `STARS`, `SUMMARY`, and `MESSAGE` variables
    as shown in the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 想法是，由于模拟这些数据很困难，我们将利用一个已经存在的包含真实评论的数据集，并从中抽样以获取我们想要的示例中的消息。和之前一样，我们首先定义我们将使用的
    `client_messages` 数据框，其中包含 `SALE_ID`、`DATE`、`STARS`、`SUMMARY` 和 `MESSAGE` 变量，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As we have done before, in our `random_client_messages_data()` function, we
    first unpack the parameter object and set the seed. The next step is to actually
    retrieve the reviews sample we want with the `random_reviews()` function we will
    create next. Assuming we have the reviews data ready, we create the `client_messages` data
    frame by taking a random sample from the `sale_ids` from the sales data so that
    we can generate a connection among messages and sales orders, and we do so in
    a way that we can generate various messages for a single sales order, since we
    use the `replace` argument as `TRUE`. The other parts of the code are similar
    to what we have seen before. Let''s have a look at the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所做的那样，在我们的 `random_client_messages_data()` 函数中，我们首先解包参数对象并设置种子。下一步是实际检索我们想要的评论样本，我们将使用我们接下来要创建的
    `random_reviews()` 函数。假设我们已经准备好了评论数据，我们通过从销售数据中的 `sale_ids` 中随机抽样来创建 `client_messages`
    数据框，这样我们就可以在消息和销售订单之间生成联系，并且我们以这种方式做，以便我们可以为单个销售订单生成各种消息，因为我们使用了 `replace` 参数作为
    `TRUE`。代码的其他部分与之前我们看到的是相似的。让我们看看下面的代码：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `random_reviews()` function takes the CSV file path as an argument in `reviews_file` and
    uses it to load the data into the `reviews` object. Then it takes a sample of
    the row indexes without replacement, because we don''t want to use the same review
    twice, and we have enough reviews to make sure that doesn''t happen (there are
    over 5,00,000 reviews in the data). We simply return this subset of the data frame
    back to be used in the final `client_messages` data frame:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`random_reviews()` 函数将 CSV 文件路径作为 `reviews_file` 参数，并使用它将数据加载到 `reviews` 对象中。然后它抽取行索引的样本，但不进行替换，因为我们不希望重复使用相同的评论，而且我们有足够的评论来确保这种情况不会发生（数据中有超过
    500,000 条评论）。我们只需简单地将这个数据框的子集返回，以便在最终的 `client_messages` 数据框中使用：'
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, we create the parameters object with the necessary information, and
    pass it along to the `random_client_messages_data()` to update the `client_messages` data
    frame with the simulated data. Make sure you change the `reviews_file` path to
    the one appropriate for your setup (`./` means that it''s in the same directory).
    Let''s have a look at the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建包含必要信息的参数对象，并将其传递给 `random_client_messages_data()`，以使用模拟数据更新 `client_messages`
    数据框。确保你将 `reviews_file` 路径更改为适合你设置的路径（`./` 表示它在同一目录中）。让我们看看下面的代码：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We're done! Now we should have a full simulation for sales data, as well as
    data for clients and their messages for their respective sales orders. Not every
    sales order will have a message, and some of them may have more than one, and
    this is by design. Remember that the reviews we used for the example are not necessarily
    for foods, but the idea was to show how these techniques can be used to simulate
    new data using already existing datasets.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了！现在我们应该有一个完整的销售数据模拟，以及客户及其对应销售订单的消息数据。并非每个销售订单都会有消息，其中一些可能有多个，这是有意为之。记住，我们用于示例的评论不一定与食物相关，但我们的想法是展示如何使用这些技术来模拟使用现有数据集生成的新数据。
- en: 'A look at the three datasets we have simulated should put a smile on our face.
    Note that we omit the `client_messages` data because it was too large to be shown
    here, but you should see it just fine on your computer:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们模拟的三个数据集应该会让我们的脸上露出笑容。请注意，我们省略了 `client_messages` 数据，因为它太大，无法在这里显示，但你应该能在你的电脑上看到它：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Working with relational databases
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与关系型数据库一起工作
- en: Now that we have the data we need for the rest of the example, we're going to
    learn how to work with it using databases. In this section, we will learn how
    to save our data into a relational database, as well as how to read it back. We
    won't go too deep into advanced operations or workflows. We will only look into
    the basics, and this section may be skipped if you are not interested in this
    topic. It's not critical to know this to reproduce the rest of the example in
    the following chapters.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了后续示例所需的数据，我们将学习如何使用数据库来处理这些数据。在本节中，我们将学习如何将我们的数据保存到关系型数据库中，以及如何读取它。我们不会深入探讨高级操作或工作流程。我们只会关注基础知识，如果你对这个主题不感兴趣，可以跳过这一节。了解这些内容对于在后续章节中重现示例不是必需的。
- en: 'The first thing we must do is install the `RMySQL` package. There are various
    packages for working with databases, and they work almost the same. We chose the
    `RMySQL` package because it''s designed for the MySQL database, which is very
    popular and easy to work with in almost all operating systems. To be able to reproduce
    this code, you will need a MySQL database set up properly in your computer, and
    we won''t go into the details of how to do so here. You can find many good resources
    online. From this point on, we''ll assume you have your database ready:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须做的第一件事是安装`RMySQL`包。有各种用于处理数据库的包，它们的工作方式几乎相同。我们选择`RMySQL`包，因为它是为MySQL数据库设计的，MySQL数据库在几乎所有操作系统中都非常流行且易于使用。为了能够重现此代码，你需要在你的电脑上正确设置MySQL数据库，我们在这里不会详细介绍如何操作。你可以在网上找到许多优质资源。从现在开始，我们假设你已经准备好了你的数据库：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The first thing we need to do to work with databases is to connect and disconnect
    from them. To do so, we use the `dbConnect()` and `dbDisconnect()` functions.
    The `dbConnect()` function returns an object that contains the connection to the
    database, and which must be used in all following actions regarding the database.
    We will call this object `db` to remind us that it represents the database we''re
    working with:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要与数据库一起工作，我们首先需要连接和断开连接。为此，我们使用`dbConnect()`和`dbDisconnect()`函数。`dbConnect()`函数返回一个包含数据库连接的对象，该对象必须在所有后续的数据库操作中使用。我们将称此对象为`db`，以提醒我们它代表我们正在处理的数据库：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you're using a database that is not operating on the same computer you're
    using R from, then you can use the corresponding IP address in the `host` parameters
    as you normally would with any SQL remote connection. There's a fifth parameter
    that we need to use when we know the name of the database we're connecting (a
    single MySQL server can have multiple databases inside). When you see the `TRUE` value
    after trying to disconnect from the database, it means that everything executed
    correctly.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是不在你使用R的同一台计算机上运行的数据库，那么你可以像使用任何SQL远程连接一样，在`host`参数中使用相应的IP地址。当我们知道我们要连接的数据库的名称时（单个MySQL服务器可以包含多个数据库），我们需要使用第五个参数。当你尝试从数据库断开连接后看到`TRUE`值，这意味着一切执行正确。
- en: 'To send a query into the database server, we use the `dbSendQuery()` function
    after having connected to it again. We create the fresh `sales` database (which
    will contain our `sales`, `clients`, and `client_messages` tables) in our MySQL
    server by executing:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要将查询发送到数据库服务器，我们再次连接到它后使用`dbSendQuery()`函数。我们通过执行以下命令在我们的MySQL服务器上创建新的`sales`数据库（该数据库将包含我们的`sales`、`clients`和`client_messages`表）：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Since MySQL syntax requires "`;`" at the end of each query, depending on your
    setup, you may get an error if you don''t put them in. Now we will disconnect
    and reconnect to the server, but this time, we will specify which particular database
    we want to work with (the `sales` database we just created):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于MySQL语法要求每个查询的末尾都要有`;`，根据你的设置，如果你没有放入它们，可能会得到一个错误。现在我们将断开并重新连接到服务器，但这次，我们将指定我们想要与之工作的特定数据库（我们刚刚创建的`sales`数据库）：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now we're going to write the data we simulated into the MySQL server. To do
    so, we use the `dbWriteTable()` function. The first argument is the database connection
    object, the second argument is the name of the table we want to store the data
    in, the third argument is the data frame that contains the data we want to store,
    and the fourth argument, as the name suggests, will overwrite (as opposed to append)
    any data already present in the database.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将模拟的数据写入MySQL服务器。为此，我们使用`dbWriteTable()`函数。第一个参数是数据库连接对象，第二个参数是我们想要存储数据的表名，第三个参数是包含我们想要存储的数据的数据框，第四个参数，正如其名称所暗示的，将覆盖（而不是追加）数据库中已存在的任何数据。
- en: 'To read a full table from the MySQL server into R, we use the `dbReadTable()` function.
    However, note that when we do, any information regarding factors is lost, and
    the data frame only knows it contains strings, which is the way the data is stored
    within the MySQL server. To verify this, you can look into the structure of the
    data being read from the MySQL server with the `str()` function. We won''t show
    the output here to preserve space, but you will find that `sales` does have the
    factor information, while `sales_from_db` does not:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要将整个表从MySQL服务器读取到R中，我们使用`dbReadTable()`函数。然而，请注意，当我们这样做时，任何关于因子的信息都会丢失，数据框只知道它包含字符串，这是数据在MySQL服务器内部存储的方式。为了验证这一点，你可以使用`str()`函数查看从MySQL服务器读取的数据的结构。我们不会在这里显示输出以节省空间，但你将发现`sales`确实有因子信息，而`sales_from_db`则没有：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Not fixing this metadata problem about the factor variables will have implications
    when we create our visualizations in the next chapter. We can deal with it now
    or later, but since this chapter is about working with data, we will show how
    to do so here. First, we will create the `read_table()` function that will wrap
    the `dbReadTable()` function. This `read_table()` function will check which table
    is being read and apply the appropriate metadata by calling `add_sales_metadata()`,
    `add_clients_metadata()`, or `add_client_messages_metadata()`. Note that if the
    table being read is not one of those three, we will not know what metadata to
    add for now, so we will just return the table directly:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不解决关于因子变量的元数据问题，在下一章创建可视化时会有影响。我们现在可以处理它，或者稍后处理，但既然本章是关于处理数据，我们将在这里展示如何做到这一点。首先，我们将创建一个`read_table()`函数，该函数将包装`dbReadTable()`函数。这个`read_table()`函数将检查正在读取哪个表，并通过调用`add_sales_metadata()`、`add_clients_metadata()`或`add_client_messages_metadata()`来应用适当的元数据。请注意，如果正在读取的表不是这三个之一，我们现在不知道要添加什么元数据，所以我们只需直接返回表即可：
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The way we add metadata to each case is by redefining the factor variables
    as we did before, as well as transforming the date objects, which are also received
    as strings. We don''t have to change anything else in the data:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向每个案例添加元数据的方式是重新定义因子变量，就像我们之前做的那样，以及转换日期对象，这些对象也是作为字符串接收的。我们不需要在数据中做任何其他改变：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now we can see that both `sales` and `sales_from_db` contain the same metadata.
    Again, we don''t show the output to preserve space, but you''ll see that the factor
    metadata is now preserved when reading from the MySQL server:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到`sales`和`sales_from_db`都包含相同的元数据。再次强调，我们不显示输出以节省空间，但你将看到，当从MySQL服务器读取时，因子元数据现在被保留：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Since they have the same data and metadata, it's now safe to completely read
    the data from the MySQL server whenever we need to work with this data. Just remember
    to use the `read_table()` function instead of the `dbReadTable()` function.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们具有相同的数据和元数据，现在在需要处理这些数据时，我们可以安全地从MySQL服务器完全读取数据。只需记住，使用`read_table()`函数而不是`dbReadTable()`函数。
- en: Reading full tables from the MySQL server with the `dbReadTable()` is only practical
    when the tables are not too large. If you're working with a database in a real
    problem, that's probably not the case. If the data you're trying to read is too
    large, use a combination of the `dbSendQuery()` and `fetch()` functions.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`dbReadTable()`从MySQL服务器读取整个表只有在表不是太大时才是实用的。如果你在一个实际的问题中处理数据库，这通常不是情况。如果你试图读取的数据太大，请使用`dbSendQuery()`和`fetch()`函数的组合。
- en: 'If you want to know what data type will be used in the MySQL server to store
    the data you''re sending, you can use the `dbDataType()` function with the `MySQL()` argument,
    as well as the data type whose server type you want to find out:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道MySQL服务器将使用什么数据类型来存储你发送的数据，你可以使用带有`MySQL()`参数的`dbDataType()`函数，以及你想要找出服务器类型的那个数据类型：
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, you may use the `dbListTables()` and `dbListFields()` functions to
    find out the tables available in the database and the fields available for a specific
    table, respectively. If you followed the example this far, you should see the
    following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以使用`dbListTables()`和`dbListFields()`函数来找出数据库中可用的表和特定表可用的字段。如果你一直跟随这个例子，你应该会看到以下内容：
- en: '[PRE33]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that you see the `row.names` field because it's necessary for MySQL functionality,
    but when you actually read the data from the database, you won't get that field.
    You will get all other fields shown (the ones in capital letters).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你看到`row.names`字段是因为它是MySQL功能所必需的，但当你实际上从数据库读取数据时，你不会得到这个字段。你将得到所有其他显示的字段（大写字母中的那些）。
- en: These are the basics of working with a MySQL server using R. For the interested
    reader, a good, concise resource that showcases many other `RMySQL` features are
    Squared Academy's *RMySQL Tutorial for Beginners, 2016* slides ([https://www.slideshare.net/RsquaredIn/rmysql-tutorial-for-beginners](https://www.slideshare.net/RsquaredIn/rmysql-tutorial-for-beginners)).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是使用R与MySQL服务器协同工作的基础知识。对于感兴趣的读者，一个展示了许多其他`RMySQL`功能的良好、简洁的资源是Squared Academy的*《RMySQL入门教程，2016》幻灯片》（[https://www.slideshare.net/RsquaredIn/rmysql-tutorial-for-beginners](https://www.slideshare.net/RsquaredIn/rmysql-tutorial-for-beginners)）。
- en: Summary
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we established the fundamentals of the food sales example
    by presenting the general scenario for The Food Factory: what they do, what they
    want to accomplish, and, most importantly, how to simulate the data we will need
    for the rest of the example. We went over various techniques to simulate different
    kinds of data, like numbers, categories, strings, and dates. The approach we showed
    is flexible enough to allow you to simulate many different kinds of data in modular
    and incremental ways. We also showed how to allow flexibility for different assumptions
    about the simulation to easily take place by using parameter objects. We learned
    how to create functions that are useful for different scenarios, and how to mix
    our simulated data with data coming from external sources. Finally, we learned
    how to work with external MySQL databases.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过展示食品工厂的一般场景，建立了食品销售示例的基本原理：他们做什么，他们想要实现什么，最重要的是，如何模拟我们将在示例的其余部分所需的数据。我们探讨了模拟不同类型数据（如数字、类别、字符串和日期）的各种技术。我们展示的方法足够灵活，允许您以模块化和逐步的方式模拟许多不同类型的数据。我们还展示了如何通过使用参数对象来允许对模拟的不同假设的灵活性，以便轻松实现。我们学习了如何创建适用于不同场景的函数，以及如何将我们的模拟数据与来自外部来源的数据混合。最后，我们学习了如何与外部MySQL数据库协同工作。
- en: We are ready to take on the analysis part of the example. In the next chapter,
    [Chapter 5](part0110.html#38STS0-f494c932c729429fb734ce52cafce730), *Communicating
    Sales with Visualization*, we will use the data we just simulated to create many
    visualizations that will allow us to get a good idea of the current status of
    The Food Factory, as well as its areas for improvement.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好承担示例的分析部分。在下一章[第五章](part0110.html#38STS0-f494c932c729429fb734ce52cafce730)，*通过可视化沟通销售*中，我们将使用我们刚刚模拟的数据来创建许多可视化，这将使我们能够了解食品工厂的当前状况以及其改进领域。
