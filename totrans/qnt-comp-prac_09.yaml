- en: '*Chapter 9*: Grover''s Search Algorithm'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*: Grover搜索算法'
- en: 'In this chapter, we will take a look at a fairly well-known quantum algorithm:
    **Grover''s search algorithm**. We will learn how to code it by building our own
    circuits for the following variations: a 2-qubit version, a 3-qubit version, and
    a 4- and more qubit version, to see how the complexity of the circuit grows with
    the number of qubits.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一个相当知名的量子算法：**Grover搜索算法**。我们将通过构建以下变体的电路来学习如何编码它：2量子位版本、3量子位版本以及4量子位及以上版本，以了解电路的复杂性如何随着量子位的数量增加而增长。
- en: We will run our algorithm both on a local simulator and on an IBM Quantum® backend
    and will see how the algorithm works pretty well on the relatively short circuit
    that is required for a 2-qubit Grover, but not as well on the much larger circuits
    that are required for more qubits. The number of gates in your circuit gets successively
    larger, and the various errors that we explored in [*Chapter 8*](B14436_08_Final_PG_ePub.xhtml#_idTextAnchor220),
    *Cleaning Up Your Quantum Act with Ignis*, start to dominate.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本地模拟器和IBM Quantum®后端上运行我们的算法，并看到算法在相对较短的2量子位Grover电路上运行得相当好，但在需要更多量子位的更大电路上则不太理想。你的电路中的门数量会依次增加，我们在[*第8章*](B14436_08_Final_PG_ePub.xhtml#_idTextAnchor220)中探讨的各种错误开始占主导地位。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Exploring quantum phase kickback
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索量子相位回弹
- en: A quick interlude on classical search
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于经典搜索的简要介绍
- en: Building Grover's search algorithm
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建Grover搜索算法
- en: Searching with a 3-qubit Grover
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用3量子位Grover进行搜索
- en: Adding more qubits to the Grover search
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向Grover搜索添加更多量子位
- en: Using the Grover circuit in your own code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的代码中使用Grover电路
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The quantum programs that we will discuss in this chapter can be found here:
    [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter09](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter09).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将讨论的量子程序可以在以下位置找到：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter09](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter09)。
- en: 'Much like we did in [*Chapter 6*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156),
    *Understanding the Qiskit® Gate Library*, we will create one main Python file
    to contain the more complex functions that we will use: `ch9_grover_functions.py`.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在[*第6章*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156)中做的那样，*理解Qiskit®门库*，我们将创建一个主要的Python文件来包含我们将使用的更复杂函数：`ch9_grover_functions.py`。
- en: 'Among other functions, this program includes a set of core functions that are
    used to build the Grover algorithm:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 除了其他函数外，此程序还包括一组核心函数，用于构建Grover算法：
- en: '`create_oracle()`: This function builds a 2-5-qubit Oracle for the correct
    solution.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create_oracle()`: 此函数构建一个2-5量子位的Oracle，用于正确解决方案。'
- en: '`create_amplifier()`: This function builds the phase amplification part of
    your Grover circuit.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create_amplifier()`: 此函数构建Grover电路的相位放大部分。'
- en: '`create_grover()`: This function puts the pieces together and returns a functioning
    Grover circuit that you can run on a simulator or on a real quantum computer.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create_grover()`: 此函数将各个部分组合在一起，并返回一个可以在模拟器或真实量子计算机上运行的Grover电路。'
- en: We will discuss these further in the *Building the Grover search algorithm*
    recipe. Suffice to say that these main functions are all that is required to build
    the Grover algorithm, and the rest of the components in the program are there
    to assist in visualizing the process.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*构建Grover搜索算法*的配方中进一步讨论这些内容。简而言之，这些主要函数是构建Grover算法所需的所有内容，而程序中的其余部分都是为了帮助可视化这个过程。
- en: 'The other functions that are included in the `ch9_grover_functions.py` file
    are as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 包含在`ch9_grover_functions.py`文件中的其他函数如下：
- en: '`print_psi()`: This function prints out a nicely formatted statevector for
    your circuits.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print_psi()`: 此函数打印出电路的格式化良好的状态向量。'
- en: '`get_psi()`: This function returns the statevector for your circuit, and also
    displays it as a Q-sphere, Bloch sphere, or plain vector.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_psi()`: 此函数返回电路的状态向量，并将其显示为Q球体、Bloch球体或普通向量。'
- en: '`print_unitary()`: This function prints out the unitary matrix for your circuit.
    For this chapter, where we expect no imaginary components of the unitary; we simplify
    things a bit and only print out the real values and use the BasicAer `unitary_simulator`
    to create the unitary.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print_unitary()`: 这个函数会打印出电路的单位矩阵。对于这一章，我们预期单位矩阵没有虚部；我们简化了一下，只打印出实值，并使用BasicAer的`unitary_simulator`来创建单位矩阵。'
- en: '`display_circuit()`: This function displays the circuit, and optionally a Q-sphere
    view of the circuit statevector and the unitary matrix of the circuit.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display_circuit()`: 这个函数显示电路，以及可选的电路状态向量和电路单位矩阵的Q球视图。'
- en: 'Finally, we have a set of functions that we use to run our circuits on simulators,
    quantum computers, and transpilers:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一组函数，我们使用这些函数在模拟器、量子计算机和转换器上运行我们的电路：
- en: '`run_grover()`: Included for completeness, a function that runs your Grover
    circuit on a simulator or on an IBM Quantum® backend.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run_grover()`: 为了完整性，包含一个函数，该函数可以在模拟器或IBM Quantum®后端上运行你的Grover电路。'
- en: '`mitigated_results()`: Revisiting the previous chapter, [*Chapter 8*](B14436_08_Final_PG_ePub.xhtml#_idTextAnchor220),
    *Cleaning Up Your Quantum Act with Ignis*, we use this function to run error mitigation
    on our 2-qubit Grover. As we will see, running error mitigation on the 3- and
    4+-qubit circuits will not produce any better results.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mitigated_results()`: 回顾上一章，[*第8章*](B14436_08_Final_PG_ePub.xhtml#_idTextAnchor220)，*用Ignis清理你的量子行为*，我们使用这个函数在我们的2量子位Grover上运行错误缓解。正如我们将看到的，在3和4+量子位电路上进行错误缓解不会产生更好的结果。'
- en: '`transpile_circuit()`: To provide insight, we bring back the transpile functionality
    that we used in the *What your quantum circuit really looks like* recipe of [*Chapter
    6*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156), *Understanding the Qiskit®
    Gate Library*.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transpile_circuit()`: 为了提供洞察，我们再次引入了在[*第6章*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156)，*理解Qiskit®门库*中的*你的量子电路真正看起来是什么样子*菜谱中使用的转换功能。'
- en: But before we dive into the algorithm, we will start by taking a look at one
    of the building blocks for many quantum algorithms (Grover included)—so-called
    **phase kickback**.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们深入算法之前，我们将先看看许多量子算法（包括Grover）的构建块之一——所谓的**相位回弹**。
- en: Exploring quantum phase kickback
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索量子相位回弹
- en: In this first recipe, we will take a closer look at a staple component of many
    quantum algorithms, quantum phase kickback, which is used to let one or more qubits
    pick up the phase angle of a second qubit without changing that second qubit.
    In the *Building the Grover algorithm* recipe, we will use phase kickback to identify
    the correct solution for our search and to amplify the probability of measuring
    that solution.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个菜谱中，我们将更深入地研究许多量子算法的基本组成部分——量子相位回弹，它被用来让一个或多个量子位拾取第二个量子位的相位角，而不会改变第二个量子位。在*构建Grover算法*菜谱中，我们将使用相位回弹来识别搜索的正确解决方案，并放大测量该解决方案的概率。
- en: This recipe will require a little bit of math to explain some pretty unintuitive
    aspects of the process and results, but we'll walk through it. It is a really
    good starting point for the mind-blowing aspects of quantum algorithms.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱需要一点数学知识来解释一些相当不直观的过程和结果，但我们会一步步讲解。这对于量子算法令人惊叹的方面是一个非常好的起点。
- en: Getting ready
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The sample code for this recipe can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_r1_kickback.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_r1_kickback.py).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的示例代码可以在以下位置找到：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_r1_kickback.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_r1_kickback.py)。
- en: The recipe in itself is pretty simple and consists of a set of steps that will
    walk you through the phase kickback process, first on one, then two qubits.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱本身相当简单，由一系列步骤组成，这些步骤将引导你通过相位回弹过程，首先是一个量子位，然后是两个量子位。
- en: 'With each step, we will use the `display_circuit()` function from `ch9_grover_functions.py`
    to display what happens to the qubits, so let''s start by taking a look at that
    function:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个步骤中，我们将使用`ch9_grover_functions.py`中的`display_circuit()`函数来显示量子位发生了什么，所以让我们先看看这个函数：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `display_circuit()` function is the main visualization function of the collection
    and takes a quantum `circuit` and two logical arguments as input. If `psi=True`,
    we will call the `get_psi()` function, which displays the circuit as a Q-sphere
    and calls the `print_psi()` function to print a nice version of the resulting
    circuit statevector. If `unitary=True`, then it calls the `print_unitary()` function
    to display the unitary matrix of the circuit.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`display_circuit()`函数是集合中的主要可视化函数，它接受一个量子`circuit`和两个逻辑参数作为输入。如果`psi=True`，我们将调用`get_psi()`函数，该函数将电路显示为Q球体，并调用`print_psi()`函数以打印结果的电路状态向量的美观版本。如果`unitary=True`，则调用`print_unitary()`函数以显示电路的单位矩阵。'
- en: In this recipe, we set `unitary=False` and focus on the statevector visualization.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们设置`unitary=False`并专注于状态向量可视化。
- en: How to do it...
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s explore how to add phases to qubits:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索如何给量子比特添加相位：
- en: 'We start by importing the required classes and methods and the `display_circuit()`
    function, which will let us display what we are doing:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先导入所需的类、方法和`display_circuit()`函数，这将使我们能够显示我们所做的工作：
- en: '[PRE1]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let''s create a single qubit initialized to state ![](img/Formula_06_047.png):'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个初始化为状态![公式](img/Formula_06_047.png)的单量子比特：
- en: '[PRE2]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `display_circuit()` function shows us the Q-sphere visualization of our
    qubit initialized to state ![](img/Formula_09_001.png) :'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`display_circuit()`函数显示了我们的量子比特初始化为状态![公式](img/Formula_09_001.png)的Q球体可视化：'
- en: '![Figure 9.1 – Single qubit set to'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.1 – 单量子比特设置为'
- en: '](img/Figure__9.1_B14436.jpg)'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.1 – 单量子比特设置为](img/Figure__9.1_B14436.jpg)'
- en: Figure 9.1 – Single qubit set to ![](img/Formula_09_003.png)
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.1 – 单量子比特设置为![公式](img/Formula_09_003.png)
- en: 'Let''s take a look at the underlying math, as we discussed in [*Chapter 2*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045),
    *Quantum Computing and Qubits with Python*. What we have done here is create a
    statevector that can be displayed like this:'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们看看背后的数学，正如我们在[*第2章*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045)，“使用Python进行量子计算和量子比特”中讨论的那样。我们在这里所做的是创建一个可以像这样显示的状态向量：
- en: '![](img/Formula_09_004.jpg)'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![公式](img/Formula_09_004.jpg)'
- en: 'Or described in the form of the angles ![](img/Formula_09_112.png) and ![](img/Formula_09_113.png):'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者用角度![公式](img/Formula_09_112.png)和![公式](img/Formula_09_113.png)的形式描述：
- en: '![](img/Formula_09_005.jpg)'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![公式](img/Formula_09_005.jpg)'
- en: 'For our qubit, initiated to ![](img/Formula_09_006.png) , the statevector resolves
    to the following:'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于我们的量子比特，初始化为![公式](img/Formula_09_006.png)，状态向量解析为以下内容：
- en: '![](img/Formula_09_007.jpg)'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![公式](img/Formula_09_007.jpg)'
- en: 'Set the qubit in superposition:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置量子比特处于叠加态：
- en: '[PRE3]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With the qubit in superposition, the Q-sphere shows that there is an equal
    probability of getting ![](img/Formula_06_0221.png) and ![](img/Formula_06_139.png):'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当量子比特处于叠加态时，Q球体显示有相等的机会得到![公式](img/Formula_06_0221.png)和![公式](img/Formula_06_139.png)：
- en: '![Figure 9.2 – Single qubit in superposition'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.2 – 单量子比特在叠加态'
- en: '](img/Figure__9.2_B14436.jpg)'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.2 – 单量子比特在叠加态](img/Figure__9.2_B14436.jpg)'
- en: Figure 9.2 – Single qubit in superposition
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.2 – 单量子比特在叠加态
- en: 'For a qubit in superposition, with ![](img/Formula_09_010.png), which is what
    we will work with here, the formula from the previous step translates into the
    following:'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于处于叠加态的量子比特，具有![公式](img/Formula_09_010.png)，这是我们在这里要处理的，上一步的公式转化为以下形式：
- en: '![](img/Formula_09_011.jpg)'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![公式](img/Formula_09_011.jpg)'
- en: This means that we describe the relative phase of the qubit by the angle ![](img/Formula_09_012.png)
    then ![](img/Formula_09_013.png) and the phase of the qubit is the opposite of
    the phase when ![](img/Formula_09_014.png)![](img/Formula_09_018.png), in which
    case, ![](img/Formula_09_114.png) = 1\. As you can see from the equation, the
    phase angle only affects the ![](img/Formula_06_056.png) part of the qubit. This
    will be important in the next step.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着我们通过角度![公式](img/Formula_09_012.png)然后![公式](img/Formula_09_013.png)来描述量子比特的相对相位，量子比特的相位是![公式](img/Formula_09_014.png)![公式](img/Formula_09_018.png)时的相反相位，在这种情况下，![公式](img/Formula_09_114.png)
    = 1。从方程中可以看出，相位角只影响量子比特的![公式](img/Formula_06_056.png)部分。这在下一步将非常重要。
- en: Now, let's add a phase to the second qubit using the Z gate.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用Z门给第二个量子比特添加一个相位。
- en: 'From here on, I will not show the `display_circuit(qc1,True,False)` code; just
    assume it is included after each step to show the progress:'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从现在开始，我将不再展示`display_circuit(qc1,True,False)`代码；只需假设在每个步骤之后都包含它以显示进度：
- en: '[PRE4]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Remember that the Q-sphere represents the end states of the qubit, the size
    of the vector tip represents the relative probability of measuring the corresponding
    outcome, and the color represents the relative phase of the outcome.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住，Q球体代表量子比特的最终状态，向量尖端的大小代表测量相应结果相对概率的大小，颜色代表结果的相对相位。
- en: 'When you measure the qubit, the phase has no impact, only the probabilities.
    Here you can see that state ![](img/Formula_06_001.png) with phase angle 0 has
    a 50% probability of giving the result 0, and state ![](img/Formula_06_056.png)
    with phase angle ![](img/Formula_09_0181.png) also a 50% chance of giving the
    result 1:'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你测量量子比特时，相位没有影响，只有概率。在这里，你可以看到具有相角 0 的状态 ![](img/Formula_06_001.png) 有 50%
    的概率给出结果 0，而具有相角 ![](img/Formula_09_0181.png) 的状态 ![](img/Formula_06_056.png) 也有
    50% 的机会给出结果 1：
- en: '![Figure 9.3 – A single qubit in superposition with phase angle'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 9.3 – 具有相角 ![](img/Formula_09_018.png) 的单个量子比特叠加'
- en: '](img/Figure__9.3_B14436.jpg)'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure__9.3_B14436.jpg)'
- en: Figure 9.3 – A single qubit in superposition with phase angle ![](img/Formula_09_018.png)
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Figure 9.3 – 具有相角 ![](img/Formula_09_018.png) 的单个量子比特叠加
- en: 'In this recipe, we will be using the *Z gate*, which is also called the **phase
    gate**, to add the phase ![](img/Formula_09_0182.png) to the ![](img/Formula_09_019.png)
    state:'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个方法中，我们将使用 *Z 门*，也称为 **相位门**，将相角 ![](img/Formula_09_0182.png) 添加到 ![](img/Formula_09_019.png)
    状态：
- en: '![](img/Formula_09_020.jpg)'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/Formula_09_020.jpg)'
- en: 'Expressed with the preceding statevector nomenclature, this transformation
    looks like this:'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用前面的状态向量命名法，这种转换看起来是这样的：
- en: 'Qubit in superposition with phase 0 (or with phase 2![](img/Formula_09_018.png)):'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 具有相角 0（或者具有相角 2![](img/Formula_09_018.png)）的叠加态量子比特：
- en: '![](img/Formula_09_021.jpg)'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/Formula_09_021.jpg)'
- en: 'Qubit in superposition with phase ![](img/Formula_09_0182.png) (after passing
    through a Z gate):'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 具有相角 ![](img/Formula_09_0182.png)（通过 Z 门后）的叠加态量子比特：
- en: '![](img/Formula_09_023.jpg)'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/Formula_09_023.jpg)'
- en: Notice how the + sign in front of ![](img/Formula_06_002.png) changes to -,
    signifying the state flip.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意看在 ![](img/Formula_06_002.png) 前面的 + 号如何变成 - 号，这标志着状态的翻转。
- en: 'Now let''s go through the same steps for 2 qubits, adding the phase ![](img/Formula_008_037.png)
    to each:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们对 2 个量子比特进行相同的步骤，给每个量子比特添加相角 ![](img/Formula_008_037.png)：
- en: '[PRE5]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Skipping the intermediate steps, the end result of the preceding code when
    printed using the two psi functions is the following:'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 跳过中间步骤，前面代码的最终结果，当使用两个 psi 函数打印时，如下所示：
- en: '![Figure 9.4 – Two qubits in superposition, both with phase angle ](img/Figure__9.4_B14436.jpg)'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Figure 9.4 – 两个处于叠加态的量子比特，两者都具有相角 ](img/Figure__9.4_B14436.jpg)'
- en: Figure 9.4 – Two qubits in superposition, both with phase angle ![](img/Formula_09_018.png)
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Figure 9.4 – 两个处于叠加态的量子比特，两者都具有相角 ![](img/Formula_09_018.png)
- en: For two qubits in superposition, what feels somewhat intuitive for the preceding
    single-qubit example gets a little muddled, so let's do it step by step.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于两个处于叠加态的量子比特，对于前面单个量子比特的例子，感觉上有点直观，但对于两个量子比特来说，可能会有些混乱，所以让我们一步一步来做。
- en: 'Like in the 1-qubit example, each qubit can be described like this:'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就像在 1 量子比特的例子中一样，每个量子比特可以这样描述：
- en: '![](img/Formula_09_026.jpg)'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/Formula_09_026.jpg)'
- en: 'Setting the qubits up in a superposition, they can be written out like this:'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将量子比特设置在叠加态，可以写成这样：
- en: '![](img/Formula_09_027.jpg)'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/Formula_09_027.jpg)'
- en: 'In our simplified superpositioned view, this resolves into the following expression:'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们简化的叠加态视图中，这转化为以下表达式：
- en: '![](img/Formula_09_028.png) and ![](img/Formula_09_029.png)'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/Formula_09_028.png) 和 ![](img/Formula_09_029.png)'
- en: '![](img/Formula_09_030.jpg)'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/Formula_09_030.jpg)'
- en: 'And for two qubits, the phase shift transformation is done as in the following
    steps:'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于两个量子比特，相移变换按照以下步骤进行：
- en: 'First, two qubits in superposition with 0 (or indeed ![](img/Formula_09_031.png))
    phase angle ![](img/Formula_09_032.png):'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '首先，两个具有 0（或者确切地说，![](img/Formula_09_031.png)）相角的叠加态量子比特 ![](img/Formula_09_032.png):'
- en: '![](img/Formula_09_033.jpg)'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/Formula_09_033.jpg)'
- en: 'Then, 2 qubits in superposition with the second (![](img/Formula_09_034.png))
    having phase angle ![](img/Formula_09_035.png):'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，两个处于叠加态的量子比特，第二个 (![](img/Formula_09_034.png)) 具有相角 ![](img/Formula_09_035.png)：
- en: '![](img/Formula_09_036.jpg)'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/Formula_09_036.jpg)'
- en: Finally, 2 qubits in superposition with both having phase angle ![](img/Formula_09_037.png)
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，两个具有相角 ![](img/Formula_09_037.png) 的叠加态量子比特：
- en: '![](img/Formula_09_038.jpg)'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/Formula_09_038.jpg)'
- en: This last example represents the final outcome of the preceding sample code.
    The Q-sphere has four equally probable outcomes, with two of them **tagged** with
    the phase ![](img/Formula_008_037.png), namely ![](img/Formula_09_040.png) and
    ![](img/Formula_09_041.png).
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个最后的例子代表了前面示例代码的最终结果。Q 球有四个等可能的结果，其中两个被 **标记** 为具有相角 ![](img/Formula_008_037.png)，即
    ![](img/Formula_09_040.png) 和 ![](img/Formula_09_041.png)。
- en: This makes sense if you remember that only the ![](img/Formula_06_002.png) state
    includes the phase parameter, and that if both qubits have the phase ![](img/Formula_008_024.png),
    the exponential sum for the combination is ![](img/Formula_09_044.png), which
    results in no phase for ![](img/Formula_09_045.png). Remember this result. It
    will appear in the next step.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你记得只有![](img/Formula_06_002.png)状态包含相位参数，并且如果两个量子比特都具有相位![](img/Formula_008_024.png)，组合的指数和为![](img/Formula_09_044.png)，这将导致![](img/Formula_09_045.png)没有相位。记住这个结果。它将在下一步出现。
- en: Entangle a qubit with a phase angle.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个量子比特与一个相位角纠缠。
- en: 'So far, this is math, and as you saw in the first recipe, this is what Qiskit®
    will build for you. You can change the phase of one qubit without touching the
    other. The real interesting part comes when you entangle the qubits using a CX
    gate, from qubit 0 to qubit 1:'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到目前为止，这是数学，正如你在第一个菜谱中看到的那样，这是Qiskit®为你构建的内容。你可以改变一个量子比特的相位，而不影响另一个。真正有趣的部分来自于当你使用CX门纠缠量子比特时，从量子比特0到量子比特1：
- en: '![Figure 9.5 – CX (Controlled-NOT) gate from 0 to 1'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.5 – 从0到1的CX（受控非）门'
- en: '](img/Figure__9.5_B14436.jpg)'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure__9.5_B14436.jpg)'
- en: Figure 9.5 – CX (Controlled-NOT) gate from 0 to 1
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.5 – 从0到1的CX（受控非）门
- en: 'The unitary matrix version of that gate is as follows:'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该门的单位矩阵版本如下：
- en: '![](img/Formula_09_046.jpg)'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/Formula_09_046.jpg)'
- en: 'For two qubits, each in superposition, the outcome is not that exciting; you
    end up with what you started with:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于两个处于叠加态的量子比特，结果并不那么令人兴奋；你最终得到的是你开始时的结果：
- en: '![](img/Formula_09_047.jpg)'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/Formula_09_047.jpg)'
- en: 'But now add a phase shift of ![](img/Formula_09_0182.png) to the controlled
    qubit 1, ![](img/Formula_09_049.png) from the preceding and do the calculation
    again:'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但现在给受控量子比特1，即![](img/Formula_09_0182.png)，添加一个相移，然后从前面进行计算：
- en: '![](img/Formula_09_050.jpg)'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/Formula_09_050.jpg)'
- en: 'This is how it is done in the sample code:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是在示例代码中是如何实现的：
- en: '[PRE6]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Again, we are skipping the intermediate steps and focusing on the end result.
    Do step through them and compare them to the preceding calculations:'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同样，我们跳过了中间步骤，专注于最终结果。逐步进行，并与前面的计算进行比较：
- en: '![Figure 9.6 – Two entangled qubits with the same  phase, using phase kickback'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.6 – 使用相位回弹的两个纠缠量子比特，具有相同的相位'
- en: '](img/Figure__9.6_B14436.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure__9.6_B14436.jpg)'
- en: Figure 9.6 – Two entangled qubits with the same ![](img/Formula_09_018.png)
    phase, using phase kickback
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 使用相位回弹的两个具有相同![](img/Formula_09_018.png)相位的纠缠量子比特
- en: Take a look at that result. It is pretty astounding!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个结果。它相当令人惊讶！
- en: 'Let me explain: we started out with two qubits in superposition, one of them
    with a phase angle ![](img/Formula_008_040.png). Then we entangled the qubits,
    using the qubit with no phase angle as the controlling qubit, and the qubit with
    a phase angle being the controlled qubit. What we ended up with is the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我来解释：我们最初有两个处于叠加态的量子比特，其中一个具有相位角![](img/Formula_008_040.png)。然后我们使用没有相位角的量子比特作为控制量子比特，具有相位角的量子比特作为受控量子比特来纠缠量子比特。最终我们得到以下结果：
- en: '![](img/Formula_09_052.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_09_052.jpg)'
- en: Two qubits in superposition, both having phase angle ![](img/Formula_008_040.png),
    just like the example that we manually built before.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 两个处于叠加态的量子比特，都具有相位角![](img/Formula_008_040.png)，就像我们之前手动构建的例子一样。
- en: This is called phase kickback and is a common trick used in quantum algorithms.
    In the remaining recipes of this chapter, we will look at the Grover algorithm,
    which uses phase kickback to tag a correct solution of a problem with a phase
    to set it apart from incorrect solutions.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为相位回弹，是量子算法中常用的一个技巧。在本章的剩余菜谱中，我们将查看Grover算法，该算法使用相位回弹将问题的正确解与相位标记出来，以区别于错误解。
- en: For 2-qubit Grover, we will use the CX gate (controlled-NOT) to achieve this,
    for 3-qubit Grover, the CCX (controlled-controlled NOT), and finally for 4 qubits,
    the CCCX gate (controlled-controlled-controlled-NOT).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于2量子比特的Grover算法，我们将使用CX门（受控非）来实现，对于3量子比特的Grover算法，使用CCX（受控受控非），最后对于4量子比特，使用CCCX门（受控受控受控非）。
- en: A quick interlude on classical search
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简短地谈谈经典搜索
- en: Before we hit the Grover algorithm, let's just take a quick peek at a standard,
    classical linear search algorithm. For a classical algorithm that searches an
    unordered database, the average number of times you have to look for a given entry
    is of the order of ![](img/Formula_09_054.png) where **N** is the number of items
    in the database. For example, if your unordered database has four items, you will
    generally have to look an average of two times to find your item.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行Grover算法之前，让我们快速看一下一个标准的经典线性搜索算法。对于一个搜索无序数据库的经典算法，你平均需要查找给定条目的次数是 *![](img/Formula_09_054.png)*
    的量级，其中 **N** 是数据库中的项数。例如，如果你的无序数据库有四个项，你通常需要平均查找两次才能找到你的项。
- en: Getting ready
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The sample code for this recipe can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_r2_classic_search.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_r2_classic_search.py).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 该食谱的示例代码可以在以下链接找到：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_r2_classic_search.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_r2_classic_search.py).
- en: How to do it…
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s search for a specific two-bit entry in a small database with four items:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个包含四个项的小型数据库中搜索特定的两位条目：
- en: 'First, we need to enter the two-bit string that we are searching for, and then
    the number of searches to try to get some statistics:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要输入我们正在搜索的两个位字符串，然后尝试搜索的次数以获取一些统计数据：
- en: '[PRE7]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The two-bit format here will be reused in the Grover recipes of this chapter
    and will then symbolize the statevector of two qubits, for example, ![](img/Formula_09_055.png).
    We will also use 3- and 4-bit entries for the corresponding number of qubits.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里的两位格式将在本章的Grover食谱中重复使用，并将表示两个量子比特的状态向量，例如，![](img/Formula_09_055.png)。我们还将使用3位和4位条目来表示相应数量的量子比特。
- en: 'The script now scrambles the initial database and runs the search function:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在脚本打乱初始数据库并运行搜索函数：
- en: '[PRE8]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `simple_search()` function takes a database list as input, and then walks
    through it until it finds the entry that we are searching for. The position of
    the item is returned, and is shunted as the number of searches in the `search`
    variable:'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`simple_search()` 函数接受一个数据库列表作为输入，然后遍历它直到找到我们正在搜索的条目。返回项的位置，并将其作为 `search`
    变量中的搜索次数：'
- en: '[PRE9]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And finally, the collected statistics are displayed using the `plot_results()`
    function:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用 `plot_results()` 函数显示收集到的统计数据：
- en: '[PRE10]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding code should create something similar to this:'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码应该创建出类似以下内容：
- en: '![Figure 9.7 – Typical outcome of a classical linear search among four unsorted
    items'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.7 – 在四个未排序项中典型经典线性搜索的结果'
- en: '](img/Figure__9.7_B14436.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure__9.7_B14436.jpg)'
- en: Figure 9.7 – Typical outcome of a classical linear search among four unsorted
    items
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – 在四个未排序项中典型经典线性搜索的结果
- en: This small search example illustrates one classical algorithm that can be used
    to find a single item in a database. In this example, we have statistically shown
    that finding a single entry in an unordered database of four items takes in the
    order of *two searches* to achieve, which matches the prediction of *N/2 searches*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小的搜索示例说明了可以用来在数据库中查找单个项的一个经典算法。在这个例子中，我们统计表明，在四个项的无序数据库中查找单个条目需要大约 *两次搜索*
    来实现，这与 *N/2 搜索* 的预测相匹配。
- en: If you add random items to the database, then you can convince yourself that
    this is true for databases of 8 and 16 items as well, which corresponds to 3-
    and 4-bit search strings.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你向数据库中添加随机项，那么你可以确信这一点也适用于包含8和16个项的数据库，这对应于3位和4位搜索字符串。
- en: In *The Grover search algorithm* recipe, we will see how we can use the Grover
    quantum algorithm to find the item in the order of ![](img/Formula_09_056.png)
    searches. That is a quadratic speedup. Not much difference in a four-item database,
    but if your database contains hundreds of thousands or even millions of items,
    it makes a difference.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *Grover搜索算法* 食谱中，我们将看到如何使用Grover量子算法以 *![](img/Formula_09_056.png)* 搜索的顺序找到项。这是一个平方加速。在四项数据库中差别不大，但如果你的数据库包含数十万甚至数百万项，这就有区别了。
- en: Building Grover's search algorithm
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Grover搜索算法
- en: Let's take our first bite into Grover's search algorithm, one of the more straightforward
    quantum algorithms for solving an actual problem using quantum computing, namely
    finding information in an indexed but unsorted database. As we discussed in *A
    quick interlude on classical search*, Grover is expected to be quadratically faster
    than its classical counterpart.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝一尝Grover的搜索算法，这是解决实际问题的更直接的量子算法之一，即在索引但未排序的数据库中查找信息。正如我们在*关于经典搜索的快速插曲*中讨论的那样，Grover预计将比其经典对应物快平方倍。
- en: 'In Qiskit Terra, we can create an implementation of Grover that uses a phase-kickback
    oracle combined with another neat trick: **phase amplification**. Phase amplification
    increases the amplitude of the correct phase-shifted answer and thereby increases
    the probability of that outcome when you measure your circuit.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qiskit Terra中，我们可以创建一个使用相位回弹神谕结合另一个巧妙技巧的实现Grover：**相位放大**。相位放大增加了正确相位偏移答案的幅度，从而在测量你的电路时增加了该结果出现的概率。
- en: First, we create a so-called **oracle function**, which is designed to take
    as input a set of qubits in initial superposition and switch the phase of the
    correct answer by ![](img/Formula_09_057.png), while leaving the phase of the
    incorrect answers alone. The oracle circuit is what is called a **black box**,
    which is coded to identify an answer from a set of inputs.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个所谓的**神谕函数**，它被设计为接受一组初始叠加的量子比特作为输入，并通过![](img/Formula_09_057.png)切换正确答案的相位，同时保持错误答案的相位不变。神谕电路被称为**黑盒**，它被编码为从一组输入中识别答案。
- en: In our example, we explicitly code the oracle to identify a specific answer,
    which feels like cheating. If we already know the answer, what is the point of
    running the Grover algorithm to find it? In our simple example, this is true,
    but an oracle black box might be any type of function in a hybrid classical/quantum
    computing program.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们明确编码了神谕以识别特定的答案，这感觉像是作弊。如果我们已经知道答案，那么运行Grover算法来找到它有什么意义呢？在我们的简单例子中，这是正确的，但神谕黑盒可能是在混合经典/量子计算程序中的任何类型的函数。
- en: 'You can see it this way: an oracle can identify the correct answer if that
    answer exists in the input that you feed it; it cannot calculate the correct answer.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样理解：如果神谕在输入中识别出正确的答案，那么它可以识别正确的答案；它不能计算出正确的答案。
- en: The oracle unitary matrix is essentially an identity matrix, with a single negative
    entry that represents the solution and will switch the phase for the corresponding
    state. This unitary matrix can be realized using standard gates in a quantum circuit.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 神谕单位矩阵本质上是一个单位矩阵，只有一个负数项表示解，并将对应状态的相位切换。这个单位矩阵可以使用量子电路中的标准门来实现。
- en: In this recipe, we will build the Grover circuit for two qubits. For each step,
    we will display what we are doing using the Q-sphere and the statevector of the
    circuit. For the two vital components—the oracle and the amplifier—we also display
    the unitary matrixes that they represent.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将构建两个量子比特的Grover电路。对于每一步，我们将使用Q-sphere和电路的状态向量来显示我们所做的工作。对于两个关键组件——神谕和放大器——我们也显示了它们所代表的单位矩阵。
- en: Getting ready
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The sample code for this recipe can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_r3_grover_main.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_r3_grover_main.py).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的示例代码可以在以下链接找到：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_r3_grover_main.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_r3_grover_main.py)。
- en: The script, in turn, uses three steps to create the Grover circuit. Let's go
    over them one by one, with our initial example for a two-qubit Grover circuit
    in the next subsections. The basic features of the circuit that we are implementing
    here are the same as you add more qubits.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本反过来使用三个步骤来创建Grover电路。让我们逐一介绍它们，并在下一节中详细介绍两个量子比特Grover电路的初始示例。我们在这里实现电路的基本特征与你添加更多量子比特时相同。
- en: 'The sample code for building the Oracle, the amplifier circuit, and the final
    Grover circuit can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_grover_functions.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_grover_functions.py).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 构建或然电路、放大电路和最终Grover电路的示例代码可以在以下链接找到：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_grover_functions.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_grover_functions.py).
- en: Creating the oracle circuit
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建或然电路
- en: The first component that we need is the oracle. One simple way of building an
    oracle to tag a correct answer with a phase shift is to use a phase kickback circuit
    like the one we built in the *Exploring quantum phase kickback* recipe.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要的是或然电路。构建或然电路以标记正确答案并引入相移的一个简单方法就是使用类似于我们在*探索量子相移回波*配方中构建的相移回波电路。
- en: As an example, let's set up a phase kickback oracle circuit that kicks back
    the phase for a specific outcome, such as ![](img/Formula_09_055.png). This means
    that the possible statevector ![](img/Formula_09_055.png) will be phase-shifted
    ![](img/Formula_008_024.png) relative to all the other possible statevectors,
    in this case, ![](img/Formula_09_060.png).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们设置一个相移回波或然电路，该电路将特定结果（如![](img/Formula_09_055.png)）的相移回传。这意味着可能的态向量![](img/Formula_09_055.png)相对于所有其他可能的态向量（在这种情况下，![](img/Formula_09_060.png)）将相移![](img/Formula_008_024.png)。
- en: 'This is what the oracle circuit looks like when printed out from Qiskit®:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是从Qiskit®打印出来的或然电路的样子：
- en: '![Figure 9.8 – A phase kickback oracle circuit and corresponding unitary matrix
    for the correct result'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.8 – 一个相移回波或然电路及其对应正确结果的单位矩阵'
- en: '](img/Figure__9.8_B14436.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure__9.8_B14436.jpg)'
- en: Figure 9.8 – A phase kickback oracle circuit and corresponding unitary matrix
    for the correct result ![](img/Formula_09_055.png)
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 9.8 – 一个相移回波或然电路及其对应正确结果![](img/Formula_09_055.png)的单位矩阵
- en: 'How does this work? Let''s walk through what each part of the circuit does:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何工作的？让我们一步步了解电路的每个部分是如何工作的：
- en: On the first controlling qubit, we add an X gate to make sure that ![](img/Formula_09_061.png)
    on that qubit gets flipped to ![](img/Formula_09_062.png), so that it triggers
    the CX gate.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个控制量子位上，我们添加一个X门以确保该量子位上的![](img/Formula_09_061.png)翻转成![](img/Formula_09_062.png)，从而触发CX门。
- en: On the second qubit, we first add an H gate.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二个量子位上，我们首先添加一个H门。
- en: What does this one do? In this case, we want to add a phase to the second qubit,
    so that we can then use the CX gate to kick back to the first qubit. Here, if
    the second qubit is an incorrect ![](img/Formula_09_063.png), applying the H gate
    gives us a superposition ![](img/Formula_09_064.png) with phase 0\. There is nothing
    to kick back, and the solution is not tagged. However, if the second qubit is
    a correct ![](img/Formula_09_065.png), the H gate gives us ![](img/Formula_09_066.png),
    which has a phase of ![](img/Formula_008_037.png), which is then promptly tagged
    to the solution by the CX gate.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个电路是做什么的？在这种情况下，我们想要给第二个量子位添加一个相移，这样我们就可以使用CX门将相移回传到第一个量子位。这里，如果第二个量子位是一个错误的![](img/Formula_09_063.png)，应用H门会给我们一个相位为0的叠加态![](img/Formula_09_064.png)，没有相移回传，解决方案没有被标记。然而，如果第二个量子位是一个正确的![](img/Formula_09_065.png)，H门会给我们![](img/Formula_09_066.png)，它有一个相位为![](img/Formula_008_037.png)，然后被CX门迅速标记到解决方案上。
- en: Finally, after the CX gate, we then add another X gate to flip the first qubit
    back to its initial state, and another H gate for the second qubit to do the same.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在CX门之后，我们再添加一个X门将第一个量子位翻转回其初始状态，并为第二个量子位添加另一个H门以执行相同的操作。
- en: What we have achieved is tagging the statevector for the oracle answer ![](img/Formula_09_068.png)
    with a phase shift of ![](img/Formula_008_037.png). Only that combination will
    get the phase shift; no other combination will.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所实现的是为或然答案的态向量![](img/Formula_09_068.png)标记一个相移为![](img/Formula_008_037.png)。只有那个组合会得到相移；没有其他组合会。
- en: Perhaps this is easier to see in the displayed unitary matrix, where all solutions
    except for the correct one are represented by a 1 in the diagonal, whereas the
    correct solution (![](img/Formula_09_070.png)) is represented by -1, which results
    in a phase shift in the resulting statevector.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 可能通过显示的单位矩阵更容易理解，其中除了正确的解决方案外，所有解决方案的对角线上都表示为1，而正确的解决方案(![](img/Formula_09_070.png))表示为-1，这导致结果状态向量的相移。
- en: 'And this is how we do it in our Python sample:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在Python示例中是如何做的：
- en: '[PRE11]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s step through it:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步来看：
- en: The input to the `create_oracle()` function is an oracle type and a size, where
    the type is a string that specifies the qubit combination we are looking for,
    for example, 10 for the ![](img/Formula_09_068.png) combination.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`create_oracle()`函数的输入是一个预言机类型和大小，其中类型是一个字符串，指定了我们正在寻找的量子比特组合，例如，对于![公式_09_068.png]组合，为10。'
- en: Next, we step through the oracle type in reverse, adding an X gate for each
    0 in the string to flip it to a 1, as per the preceding discussion.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们以相反的顺序遍历预言机类型，对于字符串中的每个0添加一个X门，将其翻转成1，正如前面的讨论所述。
- en: Notice here that the input to the oracle for a two-bit string is the reverse
    of how Qiskit® labels its qubits, so we need to reverse it into `oracle_input_rev`
    before processing it.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，对于两位字符串的预言机输入，它与Qiskit®标记量子比特的方式相反，因此我们需要在处理之前将其反转到`oracle_input_rev`。
- en: We then add an H gate to the last qubit.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们在最后一个量子比特上添加一个H门。
- en: 'Now for the real meat. Depending on the size of the circuit we are building,
    we add a superposition gate to take care of the phase kickback:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是真正的重点。根据我们构建电路的大小，我们添加一个叠加门来处理相位回弹：
- en: For two qubits, a CX gate is added by the program.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于两个量子比特，程序会添加一个CX门。
- en: For three qubits, a CCX gate is added; we'll see more on that in *Searching
    with a 3-qubit Grover* recipe.
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于三个量子比特，添加了一个CCX门；我们将在*使用3量子比特Grover搜索*配方中了解更多关于这一点。
- en: For 4 and 5 qubits, an MCX (multi-control NOT) gate is added; we'll see more
    about that one in the *Adding more qubits to the Grover search* recipe.
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于4和5个量子比特，添加了一个MCX（多控制非）门；我们将在*添加更多量子比特到Grover搜索*配方中了解更多关于这一点。
- en: And finally, we perform the H gate and X gate steps in reverse to balance out
    the oracle circuit.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们以相反的顺序执行H门和X门步骤，以平衡预言机电路。
- en: We now have an oracle circuit that will tag the oracle type that we passed it.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个预言机电路，它将标记我们传递给它的预言机类型。
- en: Creating the amplifier circuit
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建放大器电路
- en: The amplifier circuit is built the same way no matter how many qubits we use
    for the oracle. It takes the input statevector and amplifies the probability of
    the correct solution by reflecting the phase-changed probability across the average
    probability of all solutions.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 不论我们为预言机使用多少量子比特，放大器电路的构建方式都是相同的。它通过将相位改变的概率反射到所有解决方案的平均概率上来放大正确解决方案的概率。
- en: 'Here is what that circuit looks like for a 2-qubit circuit:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是2量子比特电路的电路图：
- en: '![Figure 9.9 – A two-qubit amplifier circuit and its corresponding unitary
    matrix'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '![图_9.9 – 一个两量子比特放大器电路及其对应的单位矩阵'
- en: '](img/Figure__9.9_B14436.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '![图_9.9_B14436.jpg](img/Figure__9.9_B14436.jpg)'
- en: Figure 9.9 – A two-qubit amplifier circuit and its corresponding unitary matrix
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 – 一个两量子比特放大器电路及其对应的单位矩阵
- en: Again, perhaps this is easier to see if you look at the amplifier unitary matrix.
    If you do the matrix multiplication for the phase-shifted solution, you will see
    that the probability for the phase-shifted solution is amplified, whereas the
    probability for the no-phase shifted ones is not. It turns out that in the special
    case of a two-qubit Grover circuit, the probability of getting the correct solution
    is actually 100%; you will find the correct solution among four possible ones
    in just one search. That is pretty amazing!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，如果你看看放大器单位矩阵，可能更容易理解。如果你对相位移位的解决方案进行矩阵乘法，你会看到相位移位解决方案的概率被放大，而没有相位移位的解决方案的概率则没有。结果是，在两个量子比特Grover电路的特殊情况下，得到正确解决方案的概率实际上是100%；你将在四个可能的解决方案中找到正确的解决方案，只需进行一次搜索。这真是太令人惊讶了！
- en: 'In the following matrix multiplication, we will multiply the amplifier matrix
    with the phase-tagged superposition vector to get a solution vector with just
    one possible result, ![](img/Formula_09_068.png), at 100% probability:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的矩阵乘法中，我们将放大器矩阵与相位标记的叠加向量相乘，以得到一个只有一个可能结果的解决方案向量，![公式_09_068.png]，概率为100%：
- en: '![](img/Formula_09_073.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![公式_09_073.jpg](img/Formula_09_073.jpg)'
- en: 'In our Python sample, this is how it is done:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Python示例中，它是这样做的：
- en: '[PRE12]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The function `create_amplifier()` only takes size as input. The amplifier works
    the same no matter what the oracle is. As you can see, it is somewhat similar
    to the oracle circuit; it too builds a balanced circuit:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_amplifier()`函数只接受大小作为输入。放大器无论预言机是什么都工作相同。正如你所看到的，它与预言机电路有些相似；它也构建了一个平衡电路：'
- en: It starts with H gates on all qubits.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它从所有量子比特上的H门开始。
- en: The second step is to add X gates on all qubits.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二步是在所有量子比特上添加X门。
- en: And again, depending on the size of the circuit, it adds a CX, CCX, or MCX gate
    for the phase kickback in the middle.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次强调，根据电路的大小，它会在中间添加一个CX、CCX或MCX门来实现相位回跳。
- en: And just like for the oracle circuit, we now reverse the initial X and H gates,
    to balance out the circuit.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像对于Oracle电路一样，我们现在反转初始的X和H门，以平衡电路。
- en: We now have our oracle and our amplifier; all we need to do is put them together.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了Oracle和放大器；我们唯一需要做的就是将它们放在一起。
- en: Creating the Grover circuit
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建Grover电路
- en: The Grover circuit puts the pieces together, adds H gates at the beginning,
    to set up a superposition, and adds measurement gates at the end to let you run
    the circuit.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Grover电路将各个部分组合在一起，在开始时添加H门以设置叠加态，并在结束时添加测量门以允许你运行电路。
- en: The `create_grover()` function takes the oracle circuit and the amplifier circuit
    as input. It also takes a Boolean `showsteps` parameter. With this one set to
    `showsteps` parameter to **False** to just run the Grover circuit with no extra
    visualizations.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_grover()`函数接受Oracle电路和放大器电路作为输入。它还接受一个布尔`showsteps`参数。将此参数设置为`showsteps`为**False**，以仅运行Grover电路，不进行额外的可视化。'
- en: 'The Python code looks like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Python代码看起来是这样的：
- en: '[PRE13]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here are the steps for the code we just saw:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们刚刚看到的代码的步骤：
- en: We create a quantum circuit with the global quantum and classical registers
    that we set when we created the oracle.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个量子电路，其中包含我们在创建Oracle时设置的全球量子寄存器和经典寄存器。
- en: Next, we add H gates on all the qubits and add a barrier instruction to keep
    our circuit intact on transpiling. There are a lot of duplicate gates that follow
    each other here, and we need to retain all of them for the circuit to work.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们在所有量子比特上添加H门，并添加一个屏障指令以保持电路在编译时的完整性。这里有很多连续的重复门，我们需要保留所有这些门以确保电路能够工作。
- en: Now comes the critical step where we add the oracle and amplifier circuits.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是添加Oracle和放大器电路的关键步骤。
- en: To get a well-formed outcome from the Grover circuit, we need to perform the
    correct number of searches as we discussed in *A quick interlude on classical
    search*. In the quantum Grover algorithm, this is represented by running the oracle
    and amplifier circuits once for each search.
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了从Grover电路中获得良好的结果，我们需要执行我们之前在*关于经典搜索的快速插曲*中讨论的正确数量的搜索。在量子Grover算法中，这表示为对每次搜索运行一次Oracle和放大器电路。
- en: 'For a database of size N=2q, the optimal number of searches or repetitions
    is set by the following formula: n![](img/Formula_09_074.png) . In this case,
    *q* is the number of qubits in our circuit.'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于大小为N=2q的数据库，最佳搜索次数或重复次数由以下公式确定：n![](img/Formula_09_074.png)。在这种情况下，*q*是我们电路中的量子比特数量。
- en: If you do the math, you see that for a 2-qubit Grover circuit, it is enough
    with 1 search only (n=1.57). For 3- and 4-qubit circuits, we add 2 and 3 repetitions
    respectively by just physically adding the oracle and amplifier circuits.
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你做数学计算，你会发现对于一个2量子比特的Grover电路，只需要进行1次搜索就足够了（n=1.57）。对于3和4量子比特的电路，我们分别通过物理添加Oracle和放大器电路来增加2和3次重复。
- en: 'For an insight into why we use ![](img/Formula_09_075.png) repetitions, see
    the *What happens if we run Grover''s algorithm for too long?* section of the
    *Lecture 22, Tues April 11: Grover* article that is listed in the *See also* section.'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要了解为什么我们使用![](img/Formula_09_075.png)次重复，请参阅*See also*部分列出的*讲座22，4月11日星期二：Grover*文章中的*如果我们运行Grover算法时间过长会发生什么？*部分。
- en: Finally, we add the measurement instructions to the circuit, which is now ready
    to run.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将测量指令添加到电路中，现在电路可以运行了。
- en: These are the three functions that we need to build the Grover circuit. But
    if you want to, sit down and play around with building a set of oracles and testing
    them on simulators or real IBM Quantum® quantum computers; see what error mitigation
    does to the results and see what your Grover code actually looks like, and how
    big it becomes after it is transpiled for an IBM Quantum® backend.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们构建Grover电路所需的三种函数。但如果你想的话，坐下来，尝试构建一组Oracle并测试它们在模拟器或真实的IBM Quantum®量子计算机上；看看错误缓解对结果的影响，看看你的Grover代码实际上是什么样子，以及它在为IBM
    Quantum®后端编译后变得有多大。
- en: How to do it...
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create a two-qubit Grover circuit, follow these steps:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个双量子比特的Grover电路，请按照以下步骤操作：
- en: In your Python environment, run `ch9_r3_grover_main.py`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的Python环境中，运行`ch9_r3_grover_main.py`。
- en: When prompted, enter the Oracle answer you want to find in the form of a two-digit
    string consisting of only 1 and 0, for example, *10*.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当提示时，输入你想要找到的Oracle答案，形式为只包含1和0的两个数字字符串，例如，*10*。
- en: 'The program now uses the `create_oracle()` function from the `ch9_grover_functions.py`
    script to build a two-qubit oracle circuit, using the oracle type that you entered,
    and then displays what you created:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序现在使用`create_oracle()`函数从`ch9_grover_functions.py`脚本中构建一个双量子位预言机电路，使用您输入的预言机类型，然后显示您创建的内容：
- en: '[PRE14]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The two-qubit oracle for ![](img/Formula_09_076.png) is displayed:'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于![](img/Formula_09_076.png)的双量子位预言机如下所示：
- en: '![Figure 9.10 – Oracle circuit for , coded for ](img/Figure__9.10_B14436.jpg)'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图9.10 – 为编码的预言机电路，用于](img/Figure__9.10_B14436.jpg)'
- en: Figure 9.10 – Oracle circuit for ![](img/Formula_09_077.png), coded for ![](img/Formula_09_078.png)
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.10 – 为![](img/Formula_09_077.png)编码的预言机电路，用于![](img/Formula_09_078.png)
- en: We are building a circuit with a CX gate to handle the phase kickback from the
    second qubit to the first qubit.
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们正在构建一个电路，使用CX门来处理第二个量子位对第一个量子位的相位回弹。
- en: Now build the amplifier circuit for two qubits.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在构建两个量子位的放大器电路。
- en: The next step is to create the amplifier circuit by using the `create_amplifier()`
    function. This also uses a CX gate for the phase kickback. The only input the
    function needs is the number of qubits.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下一步是使用`create_amplifier()`函数创建放大器电路。这也使用CX门进行相位回弹。该函数需要的唯一输入是量子位的数量。
- en: 'This is where we make a couple of circuit manipulations on all the qubits at
    the same time, using the quantum register as input. For example, by using the
    following code, we add a Hadamard gate to all qubits in the `qr` two-qubit quantum
    register, that is, both of them: `amplifierCircuit.h(qr)`.'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是我们同时对所有量子位进行电路操作的地方，使用量子寄存器作为输入。例如，通过使用以下代码，我们在`qr`双量子位量子寄存器中的所有量子位上添加一个Hadamard门，即两个量子位：`amplifierCircuit.h(qr)`。
- en: 'The amplifier circuit and its corresponding unitary matrix look the same for
    all two-qubit Grover circuits:'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 放大器电路及其相应的单位矩阵对于所有双量子位Grover电路都是相同的：
- en: '![Figure 9.11 – Two-qubit amplifier circuit'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.11 – 双量子位放大器电路'
- en: '](img/Figure__9.11_B14436.jpg)'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure__9.11_B14436.jpg)'
- en: Figure 9.11 – Two-qubit amplifier circuit
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.11 – 双量子位放大器电路
- en: 'Go back to the *Creating the amplifier circuit* section for a matrix multiplication
    refresher, if needed:'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果需要，请回到*创建放大器电路*部分进行矩阵乘法的复习：
- en: '![](img/Formula_09_079.jpg)'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/Formula_09_079.jpg)'
- en: As you can see, the phase shifter state 10 has been amplified to `-1`. When
    we calculate the outcome probabilities by squaring the outcome state parameter
    as we did in the [*Chapter 2*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045),
    *Quantum Computing and Qubits with Python*, in the *Comparing a bit and a qubit*
    section, we get the following probable outcome. Result 10 = 100%, and all other
    outcomes = 0%. The probability of getting the amplified correct answer is 100%.
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，相位移位状态10已被放大到`-1`。当我们通过平方输出状态参数来计算结果概率，就像我们在[*第2章*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045)中做的那样，即*使用Python进行量子计算和量子位*，在*比较比特和量子位*部分，我们得到以下可能的输出。结果10
    = 100%，所有其他结果 = 0%。得到放大正确答案的概率是100%。
- en: 'Create the Grover circuit step by step:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逐步创建Grover电路：
- en: In the next step, the program creates the Grover quantum circuit that encloses
    our oracle and amplifier and adds measurement gates. Again, we use the `create_grover()`
    function for this.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下一步中，程序创建了一个包含我们的预言机和放大器的Grover量子电路，并添加了测量门。我们再次使用`create_grover()`函数来完成此操作。
- en: With the verbose circuit creation display, we get the following output in a
    quick flow. Let's take a look at the circuits one at a time.
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用详细的电路创建显示，我们得到以下快速流程中的输出。让我们逐个查看电路。
- en: 'Create a blank two-qubit circuit:'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建一个空白的双量子位电路：
- en: '![Figure 9.12 – A blank circuit with 100% probability of getting the result'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.12 – 一个100%概率得到结果的空白电路'
- en: '](img/Figure__9.12_B14436.jpg)'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure__9.12_B14436.jpg)'
- en: Figure 9.12 – A blank circuit with 100% probability of getting the result ![](img/Formula_008_007.png)
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.12 – 一个100%概率得到结果![](img/Formula_008_007.png)的空白电路
- en: 'Set the two qubits in superposition:'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将两个量子位设置为叠加状态：
- en: '![Figure 9.13 – A circuit with two qubits in superposition. There is an equal
    probability of 25% of getting each result:](img/Figure__9.13_B14436.jpg)'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图9.13 – 具有两个量子位的叠加电路。每个结果的概率都是25%：](img/Figure__9.13_B14436.jpg)'
- en: 'Figure 9.13 – A circuit with two qubits in superposition. There is an equal
    probability of 25% of getting each result: ![](img/Formula_09_109.png), ![](img/Formula_008_013.png),
    and ![](img/Formula_09_110.png)'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.13 – 具有两个量子位的叠加电路。每个结果的概率都是25%：![](img/Formula_09_109.png)，![](img/Formula_008_013.png)，和![](img/Formula_09_110.png)
- en: 'Add the oracle circuit:'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加预言机电路：
- en: '![Figure 9.14 – Adding the oracle circuit for . There is still an equal probability
    of 25% of getting each result: , , and , but  is now phase-shifted'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.14 – 添加 . 仍然有25%的等概率得到每种结果： ， ， 和 ，但  现在相位移位'
- en: '](img/Figure__9.14_B14436.jpg)'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/Figure__9.14_B14436.jpg]'
- en: 'Figure 9.14 – Adding the oracle circuit for ![](img/Formula_09_082.png). There
    is still an equal probability of 25% of getting each result: ![](img/Formula_09_109.png),
    ![](img/Formula_008_013.png), and ![](img/Formula_09_110.png), but ![](img/Formula_008_013.png)
    is now phase-shifted ![](img/Formula_09_018.png)'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.14 – 添加 ![img/Formula_09_082.png] 的查询算子。仍然有25%的等概率得到每种结果：![img/Formula_09_109.png]，![img/Formula_008_013.png]，和![img/Formula_09_110.png]，但![img/Formula_008_013.png]现在相位移位为![img/Formula_09_018.png]
- en: 'Add the amplifier circuit:'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加放大器电路：
- en: '![Figure 9.15 – Adding the amplifier circuit, which amplifies the probability
    of the phase-shifted outcome. Now there is a 100% probability of getting'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.15 – 添加放大器电路，该电路放大了相位移位结果的概率。现在有100%的概率得到'
- en: '](img/Figure__9.15_B14436.jpg)'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/Figure__9.15_B14436.jpg]'
- en: Figure 9.15 – Adding the amplifier circuit, which amplifies the probability
    of the phase-shifted outcome. Now there is a 100% probability of getting ![](img/Formula_09_083.png)
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.15 – 添加放大器电路，该电路放大了相位移位结果的概率。现在有100%的概率得到 ![img/Formula_09_083.png]
- en: 'Add the measurement components to finalize the circuit. The final circuit will
    look something like this:'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加测量组件以完成电路。最终的电路将看起来像这样：
- en: '![Figure 9.16 – Three-qubit Grover circuit with one repetition of the oracle
    for  and an amplifier'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.16 – 三量子比特Grover电路，包含对 ![img/Formula_09_083.png] 的查询算子的一次重复和一个放大器'
- en: '](img/Figure__9.16_B14436.jpg)'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/Figure__9.16_B14436.jpg]'
- en: Figure 9.16 – Three-qubit Grover circuit with one repetition of the oracle for
    ![](img/Formula_09_083.png) and an amplifier
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.16 – 三量子比特Grover电路，包含对 ![img/Formula_09_083.png] 的查询算子的一次重复和一个放大器
- en: As you can see, the first step of the Grover circuit is to set all the qubits
    in an even superposition by using the H gate. Then, the oracle and the amplifier
    circuits. Finally, we finish by adding measurement components for all the qubits
    so we can read out the end result.
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，Grover电路的第一步是使用H门将所有量子比特设置在偶数叠加状态。然后是查询算子和放大器电路。最后，我们添加所有量子比特的测量组件，以便我们可以读取最终结果。
- en: Now, let's run the circuit and see what result we get:![Figure 9.17 – Two-qubit
    Grover search outcome for  oracle on the Aer simulator](img/Figure__9.17_B14436.jpg)
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们运行电路并看看我们得到什么结果：![图9.17 – 在Aer模拟器上对 ![img/Formula_09_083.png] 查询算子的双量子比特Grover搜索结果](img/Figure__9.17_B14436.jpg)
- en: Figure 9.17 – Two-qubit Grover search outcome for ![](img/Formula_09_083.png)
    oracle on the Aer simulator
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.17 – 在Aer模拟器上对 ![img/Formula_09_083.png] 查询算子的双量子比特Grover搜索结果
- en: Enter `Y` to run the Grover circuit on the least busy 5-qubit IBM Q backend:![Figure
    9.18 – Two-qubit Grover search outcome for  oracle on an IBM Q backend
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`Y`以在最不忙的5量子比特IBM Q后端运行Grover电路：![图9.18 – 在IBM Q后端对 ![img/Formula_09_083.png]
    查询算子的双量子比特Grover搜索结果
- en: '](img/Figure__9.18_B14436.jpg)'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/Figure__9.18_B14436.jpg]'
- en: Figure 9.18 – Two-qubit Grover search outcome for ![](img/Formula_09_083.png)
    oracle on an IBM Q backend
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.18 – 在IBM Q后端对 ![img/Formula_09_083.png] 查询算子的双量子比特Grover搜索结果
- en: So, what is going on here? How come we are not getting the super-precise outcome
    that the oracle and amplifier circuits promised? With the simulator, we had a
    100% chance of getting the correct result. Now we are down to ~91%. Can we use
    error mitigation to do better? For a two-qubit Grover circuit, it turns out we
    can.
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 那么，这里发生了什么？为什么我们没有得到查询算子和放大器电路承诺的超精确结果？在模拟器中，我们得到正确结果的机会是100%。现在我们下降到约91%。我们能否使用误差缓解做得更好？对于双量子比特Grover电路，结果证明我们可以。
- en: Run the two-qubit Grover error mitigated for the behavior of the actual quantum
    computer.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行双量子比特Grover误差缓解以模拟实际量子计算机的行为。
- en: 'Here we add in the mitigated run function that we tested in [*Chapter 8*](B14436_08_Final_PG_ePub.xhtml#_idTextAnchor220),
    *Cleaning Up Our Act with Ignis*, which is encoded as the `mitigated_results(backend,circuit,results)`
    function:'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们添加了在[*第8章*](B14436_08_Final_PG_ePub.xhtml#_idTextAnchor220)“用Ignis清理我们的行为”中测试的缓解运行函数，该函数编码为`mitigated_results(backend,circuit,results)`函数：
- en: '[PRE15]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The mitigated results are displayed:'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 显示了缓解后的结果：
- en: '![Figure 9.19 – Error-mitigated results of a two-qubit Grover search outcome
    for  oracle on an IBM Quantum® backend'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.19 – 在IBM Quantum®后端对 ![img/Formula_09_083.png] 查询算子的双量子比特Grover搜索结果的误差缓解结果'
- en: '](img/Figure__9.19_B14436.jpg)'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/Figure__9.19_B14436.jpg]'
- en: Figure 9.19 – Error-mitigated results of a two-qubit Grover search outcome for
    ![](img/Formula_09_0831.png) oracle on an IBM Quantum® backend
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.19 – 在IBM Quantum®后端上对![](img/Formula_09_0831.png)或门的两个量子比特Grover搜索结果的错误缓解结果
- en: Yes, that is better; we now see a ~95% chance of getting the correct result!
    The error mitigation of this circuit improved our results somewhat and reduced
    the probability of incorrect solutions. The error mitigation works as the circuit
    that we have built is relatively small.
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是的，这样更好；我们现在看到有95%的几率得到正确的结果！这个电路的错误缓解提高了我们的结果，并减少了错误解决方案的概率。错误缓解之所以有效，是因为我们构建的电路相对较小。
- en: See the final transpiled circuit.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看最终的转换电路。
- en: 'The final step in our two-qubit Grover exploration is to take a look at the
    transpiled circuit that we ran on the quantum computer. For this, we reuse the
    `transpile_circuit(circuit,backend)` function that we introduced in the *What
    your quantum circuit really looks like* recipe of [*Chapter 6*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156),
    *Understanding the Qiskit® Gate Library*:'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们双量子比特Grover探索的最终步骤中，我们要查看在量子计算机上运行的转换电路。为此，我们重用了在[*第6章*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156)“你的量子电路究竟是什么样子”食谱中介绍的`transpile_circuit(circuit,backend)`函数，*理解Qiskit®门库*：
- en: '[PRE16]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![Figure 9.20 – Final backend executable quantum circuit for the two-qubit
    Grover circuit'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.20 – 双量子比特Grover电路的最终后端可执行量子电路'
- en: '](img/Figure__9.20_B14436.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure__9.20_B14436.jpg)'
- en: Figure 9.20 – Final backend executable quantum circuit for the two-qubit Grover
    circuit
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.20 – 双量子比特Grover电路的最终后端可执行量子电路
- en: 'And here are some statistics about our Grover circuit:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们Grover电路的一些统计数据：
- en: '[PRE17]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Our Grover circuit has a total depth, from left to right, of 9 gate manipulations;
    there are a total of 15 individual gates.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Grover电路从左到右的总深度为9次门操作；总共有15个单独的门。
- en: For the two-qubit Grover, it turns out that we can use 100% backend basis gates,
    so our transpiled circuit is about the same size as our coded circuit. This will
    change for the three, four, and more qubit Grover circuits where we will be using
    the non-basis gates CCX and MCX. See the *Searching with a three qubit Grover*
    and *Adding more qubits to the Grover search* recipes to take a look.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 对于双量子比特Grover，我们实际上可以使用100%的后端基本门，因此我们的转换电路的大小与我们的编码电路大致相同。对于三量子比特、四量子比特以及更多量子比特的Grover电路，我们将使用非基本门CCX和MCX。参见“使用三量子比特Grover搜索”和“向Grover搜索添加更多量子比特”食谱，以查看这些内容。
- en: There's more…
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'A quick final note on the two-qubit Grover that we start out with. The two-qubit
    circuit we have built is just one of many different ways of approaching the Grover
    algorithm. I have intentionally chosen this approach to keep down the number of
    qubits that we use, and in doing so we are seeing the second qubit serve two purposes:
    it is part of the oracle, and it is also part of the phase kickback component.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们最初使用的双量子比特Grover算法的简要说明。我们构建的双量子比特电路只是接近Grover算法的众多不同方法之一。我故意选择这种方法来减少我们使用的量子比特数量，并且在这个过程中，我们看到第二个量子比特扮演了两个角色：它是或门的组成部分，同时也是相位回弹组件的一部分。
- en: Another way of building the circuit is to use an ancilla qubit strictly for
    the phase kickback. This keeps the oracle qubits free, but adds one qubit, and
    slightly more complexity to the circuit; we now have to use a CCX gate to do the
    phase kickback, not a CX gate.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 构建电路的另一种方法是仅使用辅助量子比特严格进行相位回弹。这保持了或门量子比特的自由，但增加了一个量子比特，并稍微增加了电路的复杂性；我们现在必须使用CCX门来进行相位回弹，而不是CX门。
- en: 'An example of a Grover circuit coded for ![](img/Formula_09_068.png) and built
    with an ancilla qubit is here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_grover_ancilla.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_grover_ancilla.py).'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 一个为![](img/Formula_09_068.png)编码并使用辅助量子比特构建的Grover电路的示例在这里：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_grover_ancilla.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_grover_ancilla.py)。
- en: 'Here''s how that Python sample is built:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何构建这个Python示例的：
- en: 'We start by importing the required classes:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先导入所需的类：
- en: '[PRE18]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Create a three-qubit circuit with two classical bits.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含两个经典比特的三量子比特电路。
- en: 'We will use the third, ancilla qubit as the phase kickback controller:'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用第三个，辅助量子比特作为相位回弹控制器：
- en: '[PRE19]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add the code for the oracle:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加或门的代码：
- en: '[PRE20]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we add the phase kickback using the ancilla qubit:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们使用辅助量子位添加相位回弹：
- en: '[PRE21]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We complete the coding of the oracle:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们完成了或门的编码：
- en: '[PRE22]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Before we are done, we need to build the amplifier:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们完成之前，我们需要构建放大器：
- en: '[PRE23]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Add the measurements of the two first qubits.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加前两个量子位的测量。
- en: 'As the ancilla qubit is just a tool we use inside the circuit, we do not need
    to measure it:'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于辅助量子位只是我们在电路内部使用的工具，我们不需要测量它：
- en: '[PRE24]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, we display the circuit, execute it on a simulator, and show the results:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们显示电路，在模拟器上执行它，并显示结果：
- en: '[PRE25]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The ![](img/Formula_09_068.png) oracle circuit looks like this:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/Formula_09_068.png)或门电路看起来像这样：'
- en: '![Figure 9.21 – A  oracle Grover circuit using three qubits with an ancilla
    qubit'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.21 – 使用三个量子位和一个辅助量子位的![](img/Formula_09_068.png)或门Grover电路'
- en: '](img/Figure__9.21_B14436.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure__9.21_B14436.jpg)'
- en: Figure 9.21 – A ![](img/Formula_09_0832.png) oracle Grover circuit using three
    qubits with an ancilla qubit
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.21 – 使用三个量子位和一个辅助量子位的![](img/Formula_09_0832.png)或门Grover电路
- en: Note that to expand the oracle with additional qubits, the only thing you have
    to do is add new qubits at the top and expand the CCX and CX gates to accommodate
    for the additional phase kickback requirements.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了使用额外的量子位扩展或门，你唯一要做的就是添加新的量子位在顶部，并扩展CCX和CX门以适应额外的相位回弹要求。
- en: See also
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'For a good read on understanding the Grover algorithm, take a look at *Lecture
    22, Tues April 11: Grover* from the lecture series by Scott Aaronson, David J.
    Bruton Centennial Professor of Computer Science at The University of Texas at
    Austin: [https://www.scottaaronson.com/qclec/22.pdf](https://www.scottaaronson.com/qclec/22.pdf).'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入了解Grover算法，请参阅德克萨斯大学奥斯汀分校计算机科学David J. Bruton百周年教授Scott Aaronson的讲座系列中的*第22讲，4月11日星期二：Grover*：[https://www.scottaaronson.com/qclec/22.pdf](https://www.scottaaronson.com/qclec/22.pdf)。
- en: Searching with a three qubit Grover
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用三量子位Grover进行搜索
- en: The 3-qubit Grover algorithm is very similar to the two qubit implementation
    that we explored in the previous recipe. The main difference is in how we build
    the oracle circuit for three instead of two qubits, building a phase kickback
    that adds the phase to two qubits instead of one.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 三量子位Grover算法与我们之前配方中探索的两个量子位实现非常相似。主要区别在于我们如何为三个量子位而不是两个量子位构建或门电路，构建一个相位回弹，将相位添加到两个量子位而不是一个。
- en: To do this, we have to use a controlled-NOT gate that uses two qubits as input
    to flip the third to entangle the qubits and mark the correct answer with a ![](img/Formula_09_018.png)
    phase. That gate is the Toffoli (CCX) gate instead of the CX gate.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们必须使用一个受控-NOT门，它使用两个量子位作为输入来翻转第三个量子位以纠缠量子位，并用![](img/Formula_09_018.png)相位标记正确答案。这个门是Toffoli（CCX）门而不是CX门。
- en: 'In the following example, the two qubit input Toffoli gate (CCX) with 2 controlling
    qubits and 1 controlled qubit serves as the phase kickback that shifts the phase
    of the state by ![](img/Formula_09_085.png) if the value of the three qubits matches
    the correct answer:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，两个量子位输入Toffoli门（CCX）带有2个控制量子位和1个受控量子位，作为相位回弹，如果三个量子位的值匹配正确答案，则将状态相位移![](img/Formula_09_085.png)：
- en: '![Figure 9.22 – A CCX-driven oracle for ](img/Figure__9.22_B14436.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![图9.22 – 一个由CCX驱动的或门](img/Figure__9.22_B14436.jpg)'
- en: Figure 9.22 – A CCX-driven oracle for ![](img/Formula_09_088.png)
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.22 – 一个由CCX驱动的或门![](img/Formula_09_088.png)
- en: We will be using the same sample functions as in *The Grover search algorithm*
    recipe.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与*Grover搜索算法*配方中相同的示例函数。
- en: How to do it...
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create a three qubit Grover circuit, let''s follow these steps:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个三量子位Grover电路，请按照以下步骤进行：
- en: In your Python environment, run `ch9_r3_grover_main.py`.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的Python环境中运行`ch9_r3_grover_main.py`。
- en: When prompted, enter the oracle answer you want to find in the form of a three-digit
    string consisting of only 1 and 0, for example, `100`.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当提示时，以三位字符串的形式输入你想要找到的或门答案，只包含1和0，例如，`100`。
- en: The program now steps through the building process for your three qubit Grover,
    just like for the two qubit one we built in the previous recipe. We will highlight
    the important steps, but not go into any real details. The output should speak
    for itself.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序现在将逐步构建你的三量子位Grover，就像我们在前面的配方中构建的两个量子位Grover一样。我们将突出显示重要步骤，但不会深入任何细节。输出应该可以自说自话。
- en: Create the Grover circuit.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建Grover电路。
- en: With three qubits, we have a total of N = 8 (![](img/Formula_09_086.png)) possible
    outcomes, as we discussed in *Building Grover's search algorithm* recipe.
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于三个量子位，我们有总共N = 8 (![](img/Formula_09_086.png))种可能的结果，正如我们在*构建Grover搜索算法*配方中讨论的那样。
- en: 'For a database of size N=2q, the optimal number of searches or repetitions
    is set by the following formula: n![](img/Formula_09_087.png) . For 3 qubits,
    we thus get n = 2.22\. This we round to 2, for 2 repetitions of the oracle and
    amplifier circuits.'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于大小为 N=2q 的数据库，最佳搜索次数或重复次数由以下公式确定：n![](img/Formula_09_087.png) 。对于 3 个量子比特，我们因此得到
    n = 2.22。我们将这个值四舍五入到 2，以便对占卜器和放大器电路进行两次重复。
- en: 'The final circuit will look something like this:'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最终电路将看起来像这样：
- en: '![Figure 9.23 – Three-qubit Grover circuit with two repetitions for oracle'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 9.23 – 用于占卜器的两个重复的三量子比特 Grover 电路'
- en: '](img/Figure__9.23_B14436.jpg)'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure__9.23_B14436.jpg)'
- en: Figure 9.23 – Three-qubit Grover circuit with two repetitions for oracle ![](img/Formula_09_088.png)
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.23 – 用于占卜器的两个重复的三量子比特 Grover 电路 ![](img/Formula_09_088.png)
- en: As you can see, the first step of the Grover circuit is to set all the qubits
    in an even superposition by using the H gate. Then we add two repetitions of the
    oracle and the amplifier circuits. Finally, we finish by adding measurement components
    for all the qubits so we can read out the end result.
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，Grover 电路的第一步是使用 H 门将所有量子比特设置为偶数叠加。然后我们添加两次占卜器和放大器电路的重复。最后，我们添加所有量子比特的测量组件，以便我们可以读取最终结果。
- en: 'If you have the Boolean `showsteps` parameter set to **True**, you will see
    the individual steps and temporary results for the Grover circuit, with the final
    step looking like this:'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你将布尔 `showsteps` 参数设置为 **True**，你将看到 Grover 电路的各个步骤和临时结果，最终步骤看起来像这样：
- en: '![Figure 9.24 – Three-qubit Grover with the oracle coded for'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 9.24 – 带有编码为'
- en: '](img/Figure__9.24_B14436.jpg)'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure__9.24_B14436.jpg)'
- en: Figure 9.24 – Three-qubit Grover with the oracle coded for ![](img/Formula_09_088.png)
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.24 – 带有编码为 ![](img/Formula_09_088.png) 的占卜器的三量子比特 Grover
- en: In this final step, you can see that the correct answer, ![](img/Formula_09_090.png),
    has been amplified and now has ~94% probability (0.9722) whereas all other results
    have in the order of 0.8% (-0.0882) probability.
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一最终步骤中，你可以看到正确答案，![](img/Formula_09_090.png)，已经被放大，现在有 ~94% 的概率（0.9722），而所有其他结果的概率都在
    0.8%（-0.0882）的量级。
- en: Now, let's run the circuit and see what result we get:![Figure 9.25 – Three-qubit
    Grover search outcome for a  oracle on a simulator
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们运行电路并查看我们得到什么结果：![图 9.25 – 在模拟器上对占卜器的三量子比特 Grover 搜索结果
- en: '](img/Figure__9.25_B14436.jpg)'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure__9.25_B14436.jpg)'
- en: Figure 9.25 – Three-qubit Grover search outcome for a ![](img/Formula_09_088.png)
    oracle on a simulator
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.25 – 在模拟器上对 ![](img/Formula_09_088.png) 占卜器的三量子比特 Grover 搜索结果
- en: Notice how the results nicely match what we predicted from the final statevector.
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意结果如何很好地匹配我们从最终状态矢量预测的结果。
- en: Enter `Y` to run the Grover circuit on the least busy five qubit IBM Quantum®
    backend:![Figure 9.26 – Three-qubit Grover search outcome for a  oracle on an
    IBM Quantum® backend
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `Y` 以在最不繁忙的五量子比特 IBM Quantum® 后端上运行 Grover 电路：![图 9.26 – 在 IBM Quantum® 后端上对占卜器的三量子比特
    Grover 搜索结果
- en: '](img/Figure__9.26_B14436.jpg)'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure__9.26_B14436.jpg)'
- en: Figure 9.26 – Three-qubit Grover search outcome for a ![](img/Formula_09_0881.png)
    oracle on an IBM Quantum® backend
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.26 – 在 IBM Quantum® 后端上对 ![](img/Formula_09_0881.png) 占卜器的三量子比特 Grover 搜索结果
- en: So, what is going on here? How come we are not getting the super-precise outcome
    that the oracle and amplifier circuits promised? With the simulator, we had about
    a 94% chance of getting the correct result. Here, we are apparently down to ~40%.
    Can we use error mitigation to do better?
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 那么，这里发生了什么？为什么我们没有得到占卜器和放大器电路所承诺的超级精确的结果？使用模拟器，我们大约有 94% 的机会得到正确的结果。这里，我们显然下降到
    ~40%。我们能使用错误缓解来做得更好吗？
- en: See the final, mitigated results:![Figure 9.27 – Error-mitigated results of
    a 3-qubit Grover search outcome for a  oracle on an IBM Quantum® backend
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看最终的、缓解后的结果：![图 9.27 – 在 IBM Quantum® 后端上对占卜器的三量子比特 Grover 搜索结果的错误缓解结果
- en: '](img/Figure__9.27_B14436.jpg)'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure__9.27_B14436.jpg)'
- en: Figure 9.27 – Error-mitigated results of a 3-qubit Grover search outcome for
    a ![](img/Formula_09_0881.png) oracle on an IBM Quantum® backend
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.27 – 在 IBM Quantum® 后端上对 ![](img/Formula_09_0881.png) 占卜器的三量子比特 Grover 搜索结果的错误缓解结果
- en: Nope, that didn't do it. Even though the results are slightly better, error
    mitigation didn't fix it. Why? Remember that basic error mitigation mainly concerns
    measurement errors and doesn't take into account issues that might crop up with
    the gates that make up the circuit.
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不行，这并没有解决问题。尽管结果略有改善，但错误缓解并没有解决这个问题。为什么？记住，基本的错误缓解主要关注测量误差，并且不考虑电路中可能出现的门问题。
- en: The explanation is in the size of our final Grover circuit. Let's run the final
    step of the program, which transpiles the final circuit and provides us with the
    size, depth, and width of the circuit that is actually run on the backend.
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 解释在于我们最终Grover电路的大小。让我们运行程序的最终步骤，它将最终电路转换为汇编代码，并为我们提供实际在后台运行的电路的大小、深度和宽度。
- en: Press *Enter* to see the final, transpiled circuit:![Figure 9.28 – Final backend
    executable quantum circuit for the 3-qubit Grover circuit
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*Enter*键以查看最终、转换后的电路：![图9.28 – 3量子比特Grover电路的最终后台可执行量子电路
- en: '](img/Figure__9.28_B14436.jpg)'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure__9.28_B14436.jpg)'
- en: Figure 9.28 – Final backend executable quantum circuit for the 3-qubit Grover
    circuit
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.28 – 3量子比特Grover电路的最终后台可执行量子电路
- en: 'And finally, we have the answer, the circuit size:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们得到了答案，电路大小：
- en: '[PRE26]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Our Grover circuit has a total depth, from left to right, of 49 gate manipulations;
    there are a total of 76 individual gates. If you take a quick look at [*Chapter
    8*](B14436_08_Final_PG_ePub.xhtml#_idTextAnchor220), *Cleaning Up Our Act with
    Ignis* again, you'll remember that we pulled out the gate error rates for the
    basis gates for each qubit. Although these errors are pretty small, in the order
    of tenths of a percent and less, when you run in the order of 100 or so gates
    as in the preceding circuit, chances are that there will be errors.
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们Grover电路的总深度，从左到右，为49次门操作；总共有76个单独的门。如果你快速查看[*第8章*](B14436_08_Final_PG_ePub.xhtml#_idTextAnchor220)，*用Ignis整理我们的行为*，你会记得我们为每个量子比特的基础门提取了门错误率。尽管这些错误很小，在十分之一以下，当你以100次左右的顺序运行时，如前面的电路，很可能会出现错误。
- en: So, in the final analysis, the slightly higher probabilities of getting results
    other than the expected ![](img/Formula_09_090.png) are mainly due to gate errors,
    and not measurement errors.
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，在最终分析中，得到除预期![](img/Formula_09_090.png)之外的结果的略高概率主要是由于门错误，而不是测量错误。
- en: Adding more qubits to the Grover search
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向Grover搜索添加更多量子比特
- en: 'So far, we have done reasonably well in our Grover coding. We built our two
    and three qubit circuits using unique Qiskit® gates for the number of qubits that
    our circuits contained: CX and CCX. For a four qubit and more Grover, we will
    use a multi-control NOT gate, MCX, to dynamically create the right number of control
    inputs.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在Grover编码方面做得相当不错。我们使用独特的Qiskit®门为我们的电路包含的量子比特数量构建了两个和三个量子比特的电路：CX和CCX。对于四个量子比特及以上的Grover，我们将使用多控制非门，MCX，以动态创建正确的控制输入数量。
- en: Getting ready
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will use the same sample functions as in the *Building the Grover's search
    algorithm* recipe.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与*构建Grover搜索算法*配方中相同的示例函数。
- en: For two and three qubit Grovers, we could use the prefabricated CX and CCX gates
    to create our oracle and amplifier circuits. As we are using the same model to
    build a four and more qubit Grover, instead of using CCCX, CCCCX gates, and more,
    we use the MCX gate in our circuit, to let Qiskit® build the gate logic behind
    the scenes.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 对于两个和三个量子比特的Grover，我们可以使用预制CX和CCX门来创建我们的预言机和放大器电路。由于我们使用相同的模型来构建四个和更多量子比特的Grover，而不是使用CCCX、CCCCX门等，我们在电路中使用MCX门，让Qiskit®在幕后构建门逻辑。
- en: Note
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To understand what we are doing here, take a look back at [*Chapter 6*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156),
    *Understanding the Qiskit® Gate Library*, specifically at the CX and CCX gates.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解我们在这里做什么，请回顾[*第6章*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156)，*理解Qiskit®门库*，特别是CX和CCX门。
- en: 'Here''s the unitary matrix for the CX gate, as seen in the *Building the Grover''s
    search algorithm* recipe:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是CX门的单位矩阵，正如在*构建Grover搜索算法*配方中看到的那样：
- en: '![](img/Formula_09_095.jpg)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_09_095.jpg)'
- en: 'Here''s the unitary matrix for the CCX gate (Toffoli), as seen in the *Searching
    with a 3-qubit Grover* recipe:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是CCX门（Toffoli）的单位矩阵，正如在*使用3量子比特Grover搜索*配方中看到的那样：
- en: '![](img/Formula_09_096.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_09_096.jpg)'
- en: The magic here is in the lower-right corner where the ones have left the diagonal
    and form a mini-diagonal the other way. The effect of this swap is to flip the
    value of the last qubit. Algebraically, this is an easy manipulation of the initial
    diagonal identity matrix; all we have to do is swap the two last rows.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的魔法在于右下角，其中1已经离开了对角线，形成了一个小对角线。这种交换的效果是翻转最后一个量子比特的值。从代数上来说，这是一个简单的初始对角单位矩阵的操作；我们只需要交换最后两行。
- en: 'A **controlled-controlled-controlled NOT** (**CCCX**) gate unitary matrix will
    then look like this:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 控制控制的控制的非门（**CCCX**）的单位矩阵将看起来像这样：
- en: '![](img/Formula_09_097.jpg)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![img/Formula_09_104.png](img/Formula_09_104.png)'
- en: It turns out that building a unitary matrix that represents CCCX is not that
    hard for just a few qubits, but the matrix grows in size as 2n so the next one,
    CCCCX, will be quite large.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，仅对几个量子比特构建表示CCCX的单位矩阵并不困难，但随着量子比特数量的增加，矩阵的大小会以2^n的速度增长。因此，下一个将是相当大的CCCCX。
- en: This is all great, but what do we now do with this glorious matrix? The answer
    is to let Qiskit® code it into gates for us by using the MCX gate. This gate takes
    a set of control qubits and a target qubit as input. You can also specify to use
    **ancilla** qubits for handling the phase kickback, but for our circuit, we will
    not do that. Look back at the ancilla sample in the *There's more* section of
    the *Building Grover's search algorithm* recipe.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这都很不错，但我们现在该如何处理这个辉煌的矩阵呢？答案是让Qiskit®通过使用MCX门将其编码成门。这个门接受一组控制量子比特和一个目标量子比特作为输入。你也可以指定使用**辅助**量子比特来处理相位回跳，但对我们这个电路，我们不会这么做。回顾一下“构建Grover搜索算法”配方中的“更多内容”部分的辅助样本。
- en: 'Here''s what using that gate looks like in Python:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中使用该门看起来是这样的：
- en: '[PRE27]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'For more help on the MCX gate, use Python `help`:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取关于MCX门的更多帮助，请使用Python `help`：
- en: '[PRE28]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: With the nitty-gritty behind the CCCX gate taken care of, building the 4+ Grover
    circuit is done exactly like the two and three qubit Grovers.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完CCCX门背后的细节后，构建4+量子比特的Grover电路与两个和三个量子比特的Grover算法完全一样。
- en: How to do it...
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We will be a little less stringent in covering and displaying all the steps
    here as the four qubit Grover takes up a lot more space than the others we have
    worked with. Feel free to revisit the previous recipes for details, and just apply
    them to the Grover we are building here.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将对覆盖和显示所有步骤的要求稍微宽松一些，因为4量子比特的Grover算法比我们之前使用的算法占用更多的空间。请随时回顾之前的配方以获取详细信息，并将它们应用于我们在这里构建的Grover算法。
- en: 'To create a 4-qubit Grover, follow these steps:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个4量子比特的Grover算法，请按照以下步骤操作：
- en: In your Python environment, run `ch9_r3_grover_main.py`.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的Python环境中，运行`ch9_r3_grover_main.py`。
- en: When prompted, enter the Oracle answer you want to find in the form of a 3-digit
    string consisting of only 1 and 0, for example, `1000`.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当提示时，以仅由1和0组成的3位字符串的形式输入你想要找到的Oracle答案，例如，`1000`。
- en: Let's build the Grover circuit.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们构建Grover电路。
- en: The program now steps through the building process for your three qubit Grover,
    just like for the two qubit one we built in the previous recipe. We will highlight
    the important steps, but not go into any real details. The output should speak
    for itself.
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 程序现在将逐步构建你的三量子比特Grover算法，就像我们在之前的配方中构建的两个量子比特Grover算法一样。我们将突出显示重要步骤，但不会深入细节。输出应该可以自说自明。
- en: With three qubits, we have a total of N = 16 (![](img/Formula_09_098.png)) possible
    outcomes, and as we discussed in the *Building the Grover's search algorithm*
    recipe, the ideal number of repetitions of the circuit is ![](img/Formula_09_099.png).
    For 3 qubits, we thus get n = 3.14\. This we round to 3, for 3 repetitions of
    the oracle and amplifier circuits.
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于三个量子比特，我们有总共N = 16（![img/Formula_09_107.png](img/Formula_09_107.png)）种可能的结果，正如我们在“构建Grover搜索算法”配方中讨论的那样，电路的理想重复次数是![img/Formula_09_108.png]。对于3个量子比特，我们因此得到n
    = 3.14。我们将它四舍五入到3，以便Oracle和放大电路重复3次。
- en: 'The final circuit will look something like this:'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最终电路将看起来像这样：
- en: '![Figure 9.29 – Four-qubit Grover circuit with three repetitions for oracle
    ](img/Figure__9.29_B14436.jpg)'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图9.29 – 具有三个重复的4量子比特Grover电路，用于oracle ![img/Formula_09_102.png](img/Formula_09_102.png)]'
- en: Figure 9.29 – Four-qubit Grover circuit with three repetitions for oracle ![](img/Formula_09_100.png)
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.29 – 具有三个重复的4量子比特Grover电路，用于oracle ![img/Formula_09_100.png](img/Formula_09_100.png)
- en: 'If you have the Boolean `showsteps` parameter set to **True**, you will see
    the individual steps and temporary results for the Grover circuit, with the final
    step looking like this:'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你将布尔参数`showsteps`设置为**True**，你将看到Grover电路的各个步骤和临时结果，最终步骤看起来如下：
- en: '![Figure 9.30 – Four-qubit Grover with the oracle coded for'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.30 – 具有已编码oracle的4量子比特Grover ![img/Formula_09_101.png](img/Formula_09_101.png)]'
- en: '](img/Figure__9.30_B14436.jpg)'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/Formula_09_105.png](img/Formula_09_105.png)]'
- en: Figure 9.30 – Four-qubit Grover with the oracle coded for ![](img/Formula_09_101.png)
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.30 – 具有已编码oracle的4量子比特Grover ![img/Formula_09_106.png](img/Formula_09_106.png)
- en: In this final step, you can see (after some digging) that the correct answer,
    ![](img/Formula_09_102.png) has been amplified (-0.98046875) and now has ~96%
    probability whereas all other results have in the order of 0.02% probability.
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个最终步骤中，你可以看到（经过一些挖掘后），正确的答案![img/Formula_09_103.png]已经被放大（-0.98046875），现在有大约96%的概率，而所有其他结果都有大约0.02%的概率。
- en: Now, let's run the circuit and see what result we get:![Figure 9.31 – Four-qubit
    Grover search outcome for a  oracle on a simulator
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们运行电路并看看我们得到什么结果：![图 9.31 – 在模拟器上对 oracle 进行四量子比特 Grover 搜索的结果
- en: '](img/Figure__9.31_B14436.jpg)'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/Figure__9.31_B14436.jpg)'
- en: Figure 9.31 – Four-qubit Grover search outcome for a ![](img/Formula_09_103.png)
    oracle on a simulator
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 9.31 – 在模拟器上对 ![](img/Formula_09_103.png) oracle 进行四量子比特 Grover 搜索的结果'
- en: Enter `Y` to run the Grover circuit on the least busy five qubit IBM Quantum®
    backend:![Figure 9.32 – Four-qubit Grover search outcome for a  oracle on an IBM
    Quantum® backend
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `Y` 以在最不繁忙的五量子比特 IBM Quantum® 后端运行 Grover 电路：![图 9.32 – 在 IBM Quantum® 后端上对
    oracle 进行四量子比特 Grover 搜索的结果
- en: '](img/Figure__9.32_B14436.jpg)'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/Figure__9.32_B14436.jpg)'
- en: Figure 9.32 – Four-qubit Grover search outcome for a ![](img/Formula_09_104.png)
    oracle on an IBM Quantum® backend
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 9.32 – 在 IBM Quantum® 后端上对 ![](img/Formula_09_104.png) oracle 进行四量子比特 Grover
    搜索的结果'
- en: This time, we seem to be getting nothing but noise. Surely there is no clear
    answer in that randomness. The correct answer is nowhere near the top of this
    list. Let's see the results after error mitigation.
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这次，我们似乎什么都没有得到，只有噪音。当然，在那随机性中没有任何明确的答案。正确的答案根本不在列表的顶部。让我们看看错误缓解后的结果。
- en: The explanation is again in the size of our final Grover circuit. The final
    step of the program will give us the transpiled circuit.
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 解释再次在于我们最终 Grover 电路的大小。程序的最终步骤将给我们编译后的电路。
- en: 'Press *Enter* to see the final, transpiled circuit. The result this time is
    pretty overwhelming:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下 *Enter* 键以查看最终、编译后的电路。这次的结果相当令人印象深刻：
- en: '![Figure 9.33 – Final backend executable quantum circuit for the 4-qubit Grover
    circuit'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.33 – 4-量子比特 Grover 电路的最终后端可执行量子电路'
- en: '](img/Figure__9.33_B14436.jpg)'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure__9.33_B14436.jpg)'
- en: Figure 9.33 – Final backend executable quantum circuit for the 4-qubit Grover
    circuit
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.33 – 4-量子比特 Grover 电路的最终后端可执行量子电路'
- en: 'Again, we have the answer, the circuit size:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们得到了答案，电路大小：
- en: '[PRE29]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Our Grover circuit has a total depth, from left to right, of 311 gate manipulations;
    there are a total of 409 individual gates. Again, just like in the *Searching
    with a three qubit Grover* recipe, the fact that we just get noise is due to gate
    errors and not measurement errors. The circuit has grown too big for efficient
    execution on a NISQ machine. There is nothing wrong with our Grover circuit, it
    is just too large!
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Grover 电路总深度，从左到右，为 311 次门操作；总共有 409 个单独的门。同样，就像在 *使用三量子比特 Grover 搜索* 的配方中一样，我们只得到噪音是因为门错误，而不是测量错误。电路太大，无法在
    NISQ 机器上高效执行。我们的 Grover 电路没有问题，只是太大！
- en: There's more…
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'Now go ahead and create a five qubit Grover and see where it takes you. The
    simulator should be able to handle it gallantly and give you the expected results,
    say for a ![](img/Formula_09_105.png) oracle. But running it on a real quantum
    computer will just give you noise:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 现在继续创建一个五量子比特的 Grover 电路，看看它会带你去哪里。模拟器应该能够勇敢地处理它，并给出预期的结果，比如对于一个 ![](img/Formula_09_105.png)
    oracle。但在真实的量子计算机上运行它只会给你噪音：
- en: '![Figure 9.34 – Five-qubit Grover search outcome for a  oracle on a simulator'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.34 – 在模拟器上对 oracle 进行五量子比特 Grover 搜索的结果'
- en: '](img/Figure__9.34_B14436.jpg)'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure__9.34_B14436.jpg)'
- en: Figure 9.34 – Five-qubit Grover search outcome for a ![](img/Formula_09_106.png)
    oracle on a simulator
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.34 – 在模拟器上对 ![](img/Formula_09_106.png) oracle 进行五量子比特 Grover 搜索的结果'
- en: 'The final results of a five qubit Grover circuit when run on a real quantum
    computer are displayed:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在真实量子计算机上运行五量子比特 Grover 电路的最终结果显示：
- en: '![Figure 9.35 – Five-qubit Grover search outcome for a  oracle on an IBM Quantum®
    backend'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.35 – 在 IBM Quantum® 后端上对 oracle 进行五量子比特 Grover 搜索的结果'
- en: '](img/Figure__9.35_B14436.jpg)'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure__9.35_B14436.jpg)'
- en: Figure 9.35 – Five-qubit Grover search outcome for a ![](img/Formula_09_107.png)
    oracle on an IBM Quantum® backend
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.35 – 在 IBM Quantum® 后端上对 ![](img/Formula_09_107.png) oracle 进行五量子比特 Grover
    搜索的结果'
- en: Take a look at the final, transpiled circuit. Depending on which IBM Quantum®
    machine that you run your circuit on, you might get a different size and depth
    depending on the machine topology. Creating a CCCCX gate (using the MCX gate)
    on a machine with just five qubits will require a *lot* of swapping, not to mention
    repeating the oracle and amplifier four times.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 查看最终、编译后的电路。根据您在哪个 IBM Quantum® 机器上运行电路，您可能会得到不同的大小和深度，这取决于机器拓扑结构。在一个只有五个量子比特的机器上创建一个
    CCCCX 门（使用 MCX 门）将需要大量的交换，更不用说重复 oracle 和放大器四次了。
- en: 'Here''s a circuit size example from running on the `ibmqx2` five qubit backend:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ibmqx2` 五量子比特后端运行时的电路大小示例：
- en: '[PRE30]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: A circuit this size will have to wait for a universal quantum computer; it is
    too big to successfully run on a NISQ machine.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 这个大小的电路将不得不等待通用量子计算机；它太大，无法在NISQ机器上成功运行。
- en: Using the Grover circuit in your own code
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在你的代码中使用Grover电路
- en: There's quite a bit of code going into the combined `ch9_r3_grover_main.py`
    and `ch9_grover_functions.py` scripts. The interactive main program is not needed
    to just run Grover if, for example, you want to utilize it in another Python program.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ch9_r3_grover_main.py`和`ch9_grover_functions.py`脚本中有很多代码。如果你只是想运行Grover，例如，想在另一个Python程序中利用它，那么交互式主程序是不需要的。
- en: Getting ready
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The sample Grover functions code that you need is included here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_grover_functions.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_grover_functions.py).'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要的示例Grover函数代码包含在这里：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_grover_functions.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_grover_functions.py).
- en: How to do it…
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Technically, all you need to do is to include the following short code snippet
    in your own code:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 技术上，你只需要在你的代码中包含以下简短的代码片段：
- en: '[PRE31]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The preceding code should give the following result:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上一段代码应该得到以下结果：
- en: '![Figure 9.36 – Using the Grover functions in a minimal script to create a  Grover
    circuit'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.36 – 在最小脚本中使用Grover函数创建一个 Grover电路'
- en: '](img/Figure__9.36_B14436.jpg)'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure__9.36_B14436.jpg)'
- en: Figure 9.36 – Using the Grover functions in a minimal script to create a ![](img/Formula_09_108.png)
    Grover circuit
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.36 – 在最小脚本中使用Grover函数创建一个 ![img/Formula_09_108.png] Grover电路
- en: From a Qiskit Terra circuit point of view, we are now done, and you can include
    your `grover` circuit with your own hybrid classical/quantum code to get the Grover
    search results.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 从Qiskit Terra电路的角度来看，我们现在已经完成了，你可以将你的`grover`电路与你的混合经典/量子代码一起包含，以获取Grover搜索结果。
- en: There's more…
  id: totrans-436
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: But we can do even better! Qiskit Aqua actually includes a `Grover()` function
    that you can use directly without having to write any code. More on this in the
    *Running Grover as an Aqua function* recipe in [*Chapter 10*](B14436_10_Final_PG_ePub.xhtml#_idTextAnchor271),
    *Getting to Know Algorithms with Aqua*.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们可以做得更好！Qiskit Aqua实际上包含一个可以直接使用而不需要编写任何代码的`Grover()`函数。更多关于这一点，请参考[*第10章*](B14436_10_Final_PG_ePub.xhtml#_idTextAnchor271)中的*使用Aqua了解算法*食谱，*了解Aqua算法*。
