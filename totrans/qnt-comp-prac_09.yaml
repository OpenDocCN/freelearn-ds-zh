- en: '*Chapter 9*: Grover''s Search Algorithm'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will take a look at a fairly well-known quantum algorithm:
    **Grover''s search algorithm**. We will learn how to code it by building our own
    circuits for the following variations: a 2-qubit version, a 3-qubit version, and
    a 4- and more qubit version, to see how the complexity of the circuit grows with
    the number of qubits.'
  prefs: []
  type: TYPE_NORMAL
- en: We will run our algorithm both on a local simulator and on an IBM Quantum® backend
    and will see how the algorithm works pretty well on the relatively short circuit
    that is required for a 2-qubit Grover, but not as well on the much larger circuits
    that are required for more qubits. The number of gates in your circuit gets successively
    larger, and the various errors that we explored in [*Chapter 8*](B14436_08_Final_PG_ePub.xhtml#_idTextAnchor220),
    *Cleaning Up Your Quantum Act with Ignis*, start to dominate.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring quantum phase kickback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A quick interlude on classical search
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building Grover's search algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching with a 3-qubit Grover
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding more qubits to the Grover search
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Grover circuit in your own code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The quantum programs that we will discuss in this chapter can be found here:
    [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter09](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter09).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Much like we did in [*Chapter 6*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156),
    *Understanding the Qiskit® Gate Library*, we will create one main Python file
    to contain the more complex functions that we will use: `ch9_grover_functions.py`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Among other functions, this program includes a set of core functions that are
    used to build the Grover algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '`create_oracle()`: This function builds a 2-5-qubit Oracle for the correct
    solution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`create_amplifier()`: This function builds the phase amplification part of
    your Grover circuit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`create_grover()`: This function puts the pieces together and returns a functioning
    Grover circuit that you can run on a simulator or on a real quantum computer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss these further in the *Building the Grover search algorithm*
    recipe. Suffice to say that these main functions are all that is required to build
    the Grover algorithm, and the rest of the components in the program are there
    to assist in visualizing the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other functions that are included in the `ch9_grover_functions.py` file
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`print_psi()`: This function prints out a nicely formatted statevector for
    your circuits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_psi()`: This function returns the statevector for your circuit, and also
    displays it as a Q-sphere, Bloch sphere, or plain vector.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print_unitary()`: This function prints out the unitary matrix for your circuit.
    For this chapter, where we expect no imaginary components of the unitary; we simplify
    things a bit and only print out the real values and use the BasicAer `unitary_simulator`
    to create the unitary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`display_circuit()`: This function displays the circuit, and optionally a Q-sphere
    view of the circuit statevector and the unitary matrix of the circuit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, we have a set of functions that we use to run our circuits on simulators,
    quantum computers, and transpilers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`run_grover()`: Included for completeness, a function that runs your Grover
    circuit on a simulator or on an IBM Quantum® backend.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mitigated_results()`: Revisiting the previous chapter, [*Chapter 8*](B14436_08_Final_PG_ePub.xhtml#_idTextAnchor220),
    *Cleaning Up Your Quantum Act with Ignis*, we use this function to run error mitigation
    on our 2-qubit Grover. As we will see, running error mitigation on the 3- and
    4+-qubit circuits will not produce any better results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`transpile_circuit()`: To provide insight, we bring back the transpile functionality
    that we used in the *What your quantum circuit really looks like* recipe of [*Chapter
    6*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156), *Understanding the Qiskit®
    Gate Library*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But before we dive into the algorithm, we will start by taking a look at one
    of the building blocks for many quantum algorithms (Grover included)—so-called
    **phase kickback**.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring quantum phase kickback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this first recipe, we will take a closer look at a staple component of many
    quantum algorithms, quantum phase kickback, which is used to let one or more qubits
    pick up the phase angle of a second qubit without changing that second qubit.
    In the *Building the Grover algorithm* recipe, we will use phase kickback to identify
    the correct solution for our search and to amplify the probability of measuring
    that solution.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will require a little bit of math to explain some pretty unintuitive
    aspects of the process and results, but we'll walk through it. It is a really
    good starting point for the mind-blowing aspects of quantum algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The sample code for this recipe can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_r1_kickback.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_r1_kickback.py).'
  prefs: []
  type: TYPE_NORMAL
- en: The recipe in itself is pretty simple and consists of a set of steps that will
    walk you through the phase kickback process, first on one, then two qubits.
  prefs: []
  type: TYPE_NORMAL
- en: 'With each step, we will use the `display_circuit()` function from `ch9_grover_functions.py`
    to display what happens to the qubits, so let''s start by taking a look at that
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `display_circuit()` function is the main visualization function of the collection
    and takes a quantum `circuit` and two logical arguments as input. If `psi=True`,
    we will call the `get_psi()` function, which displays the circuit as a Q-sphere
    and calls the `print_psi()` function to print a nice version of the resulting
    circuit statevector. If `unitary=True`, then it calls the `print_unitary()` function
    to display the unitary matrix of the circuit.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we set `unitary=False` and focus on the statevector visualization.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s explore how to add phases to qubits:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by importing the required classes and methods and the `display_circuit()`
    function, which will let us display what we are doing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s create a single qubit initialized to state ![](img/Formula_06_047.png):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `display_circuit()` function shows us the Q-sphere visualization of our
    qubit initialized to state ![](img/Formula_09_001.png) :'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Single qubit set to'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure__9.1_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.1 – Single qubit set to ![](img/Formula_09_003.png)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s take a look at the underlying math, as we discussed in [*Chapter 2*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045),
    *Quantum Computing and Qubits with Python*. What we have done here is create a
    statevector that can be displayed like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/Formula_09_004.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Or described in the form of the angles ![](img/Formula_09_112.png) and ![](img/Formula_09_113.png):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/Formula_09_005.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'For our qubit, initiated to ![](img/Formula_09_006.png) , the statevector resolves
    to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/Formula_09_007.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Set the qubit in superposition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the qubit in superposition, the Q-sphere shows that there is an equal
    probability of getting ![](img/Formula_06_0221.png) and ![](img/Formula_06_139.png):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Single qubit in superposition'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure__9.2_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.2 – Single qubit in superposition
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For a qubit in superposition, with ![](img/Formula_09_010.png), which is what
    we will work with here, the formula from the previous step translates into the
    following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/Formula_09_011.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: This means that we describe the relative phase of the qubit by the angle ![](img/Formula_09_012.png)
    then ![](img/Formula_09_013.png) and the phase of the qubit is the opposite of
    the phase when ![](img/Formula_09_014.png)![](img/Formula_09_018.png), in which
    case, ![](img/Formula_09_114.png) = 1\. As you can see from the equation, the
    phase angle only affects the ![](img/Formula_06_056.png) part of the qubit. This
    will be important in the next step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, let's add a phase to the second qubit using the Z gate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From here on, I will not show the `display_circuit(qc1,True,False)` code; just
    assume it is included after each step to show the progress:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remember that the Q-sphere represents the end states of the qubit, the size
    of the vector tip represents the relative probability of measuring the corresponding
    outcome, and the color represents the relative phase of the outcome.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When you measure the qubit, the phase has no impact, only the probabilities.
    Here you can see that state ![](img/Formula_06_001.png) with phase angle 0 has
    a 50% probability of giving the result 0, and state ![](img/Formula_06_056.png)
    with phase angle ![](img/Formula_09_0181.png) also a 50% chance of giving the
    result 1:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.3 – A single qubit in superposition with phase angle'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure__9.3_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.3 – A single qubit in superposition with phase angle ![](img/Formula_09_018.png)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In this recipe, we will be using the *Z gate*, which is also called the **phase
    gate**, to add the phase ![](img/Formula_09_0182.png) to the ![](img/Formula_09_019.png)
    state:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/Formula_09_020.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Expressed with the preceding statevector nomenclature, this transformation
    looks like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Qubit in superposition with phase 0 (or with phase 2![](img/Formula_09_018.png)):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/Formula_09_021.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Qubit in superposition with phase ![](img/Formula_09_0182.png) (after passing
    through a Z gate):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/Formula_09_023.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Notice how the + sign in front of ![](img/Formula_06_002.png) changes to -,
    signifying the state flip.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now let''s go through the same steps for 2 qubits, adding the phase ![](img/Formula_008_037.png)
    to each:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Skipping the intermediate steps, the end result of the preceding code when
    printed using the two psi functions is the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Two qubits in superposition, both with phase angle ](img/Figure__9.4_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 9.4 – Two qubits in superposition, both with phase angle ![](img/Formula_09_018.png)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For two qubits in superposition, what feels somewhat intuitive for the preceding
    single-qubit example gets a little muddled, so let's do it step by step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Like in the 1-qubit example, each qubit can be described like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/Formula_09_026.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Setting the qubits up in a superposition, they can be written out like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/Formula_09_027.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'In our simplified superpositioned view, this resolves into the following expression:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/Formula_09_028.png) and ![](img/Formula_09_029.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![](img/Formula_09_030.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'And for two qubits, the phase shift transformation is done as in the following
    steps:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First, two qubits in superposition with 0 (or indeed ![](img/Formula_09_031.png))
    phase angle ![](img/Formula_09_032.png):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/Formula_09_033.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Then, 2 qubits in superposition with the second (![](img/Formula_09_034.png))
    having phase angle ![](img/Formula_09_035.png):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/Formula_09_036.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Finally, 2 qubits in superposition with both having phase angle ![](img/Formula_09_037.png)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/Formula_09_038.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: This last example represents the final outcome of the preceding sample code.
    The Q-sphere has four equally probable outcomes, with two of them **tagged** with
    the phase ![](img/Formula_008_037.png), namely ![](img/Formula_09_040.png) and
    ![](img/Formula_09_041.png).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This makes sense if you remember that only the ![](img/Formula_06_002.png) state
    includes the phase parameter, and that if both qubits have the phase ![](img/Formula_008_024.png),
    the exponential sum for the combination is ![](img/Formula_09_044.png), which
    results in no phase for ![](img/Formula_09_045.png). Remember this result. It
    will appear in the next step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Entangle a qubit with a phase angle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So far, this is math, and as you saw in the first recipe, this is what Qiskit®
    will build for you. You can change the phase of one qubit without touching the
    other. The real interesting part comes when you entangle the qubits using a CX
    gate, from qubit 0 to qubit 1:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.5 – CX (Controlled-NOT) gate from 0 to 1'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure__9.5_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.5 – CX (Controlled-NOT) gate from 0 to 1
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The unitary matrix version of that gate is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/Formula_09_046.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'For two qubits, each in superposition, the outcome is not that exciting; you
    end up with what you started with:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/Formula_09_047.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'But now add a phase shift of ![](img/Formula_09_0182.png) to the controlled
    qubit 1, ![](img/Formula_09_049.png) from the preceding and do the calculation
    again:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/Formula_09_050.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'This is how it is done in the sample code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Again, we are skipping the intermediate steps and focusing on the end result.
    Do step through them and compare them to the preceding calculations:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Two entangled qubits with the same  phase, using phase kickback'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure__9.6_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.6 – Two entangled qubits with the same ![](img/Formula_09_018.png)
    phase, using phase kickback
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at that result. It is pretty astounding!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me explain: we started out with two qubits in superposition, one of them
    with a phase angle ![](img/Formula_008_040.png). Then we entangled the qubits,
    using the qubit with no phase angle as the controlling qubit, and the qubit with
    a phase angle being the controlled qubit. What we ended up with is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_09_052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Two qubits in superposition, both having phase angle ![](img/Formula_008_040.png),
    just like the example that we manually built before.
  prefs: []
  type: TYPE_NORMAL
- en: This is called phase kickback and is a common trick used in quantum algorithms.
    In the remaining recipes of this chapter, we will look at the Grover algorithm,
    which uses phase kickback to tag a correct solution of a problem with a phase
    to set it apart from incorrect solutions.
  prefs: []
  type: TYPE_NORMAL
- en: For 2-qubit Grover, we will use the CX gate (controlled-NOT) to achieve this,
    for 3-qubit Grover, the CCX (controlled-controlled NOT), and finally for 4 qubits,
    the CCCX gate (controlled-controlled-controlled-NOT).
  prefs: []
  type: TYPE_NORMAL
- en: A quick interlude on classical search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we hit the Grover algorithm, let's just take a quick peek at a standard,
    classical linear search algorithm. For a classical algorithm that searches an
    unordered database, the average number of times you have to look for a given entry
    is of the order of ![](img/Formula_09_054.png) where **N** is the number of items
    in the database. For example, if your unordered database has four items, you will
    generally have to look an average of two times to find your item.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The sample code for this recipe can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_r2_classic_search.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_r2_classic_search.py).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s search for a specific two-bit entry in a small database with four items:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to enter the two-bit string that we are searching for, and then
    the number of searches to try to get some statistics:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The two-bit format here will be reused in the Grover recipes of this chapter
    and will then symbolize the statevector of two qubits, for example, ![](img/Formula_09_055.png).
    We will also use 3- and 4-bit entries for the corresponding number of qubits.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The script now scrambles the initial database and runs the search function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `simple_search()` function takes a database list as input, and then walks
    through it until it finds the entry that we are searching for. The position of
    the item is returned, and is shunted as the number of searches in the `search`
    variable:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And finally, the collected statistics are displayed using the `plot_results()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code should create something similar to this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Typical outcome of a classical linear search among four unsorted
    items'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure__9.7_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.7 – Typical outcome of a classical linear search among four unsorted
    items
  prefs: []
  type: TYPE_NORMAL
- en: This small search example illustrates one classical algorithm that can be used
    to find a single item in a database. In this example, we have statistically shown
    that finding a single entry in an unordered database of four items takes in the
    order of *two searches* to achieve, which matches the prediction of *N/2 searches*.
  prefs: []
  type: TYPE_NORMAL
- en: If you add random items to the database, then you can convince yourself that
    this is true for databases of 8 and 16 items as well, which corresponds to 3-
    and 4-bit search strings.
  prefs: []
  type: TYPE_NORMAL
- en: In *The Grover search algorithm* recipe, we will see how we can use the Grover
    quantum algorithm to find the item in the order of ![](img/Formula_09_056.png)
    searches. That is a quadratic speedup. Not much difference in a four-item database,
    but if your database contains hundreds of thousands or even millions of items,
    it makes a difference.
  prefs: []
  type: TYPE_NORMAL
- en: Building Grover's search algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take our first bite into Grover's search algorithm, one of the more straightforward
    quantum algorithms for solving an actual problem using quantum computing, namely
    finding information in an indexed but unsorted database. As we discussed in *A
    quick interlude on classical search*, Grover is expected to be quadratically faster
    than its classical counterpart.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Qiskit Terra, we can create an implementation of Grover that uses a phase-kickback
    oracle combined with another neat trick: **phase amplification**. Phase amplification
    increases the amplitude of the correct phase-shifted answer and thereby increases
    the probability of that outcome when you measure your circuit.'
  prefs: []
  type: TYPE_NORMAL
- en: First, we create a so-called **oracle function**, which is designed to take
    as input a set of qubits in initial superposition and switch the phase of the
    correct answer by ![](img/Formula_09_057.png), while leaving the phase of the
    incorrect answers alone. The oracle circuit is what is called a **black box**,
    which is coded to identify an answer from a set of inputs.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we explicitly code the oracle to identify a specific answer,
    which feels like cheating. If we already know the answer, what is the point of
    running the Grover algorithm to find it? In our simple example, this is true,
    but an oracle black box might be any type of function in a hybrid classical/quantum
    computing program.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see it this way: an oracle can identify the correct answer if that
    answer exists in the input that you feed it; it cannot calculate the correct answer.'
  prefs: []
  type: TYPE_NORMAL
- en: The oracle unitary matrix is essentially an identity matrix, with a single negative
    entry that represents the solution and will switch the phase for the corresponding
    state. This unitary matrix can be realized using standard gates in a quantum circuit.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will build the Grover circuit for two qubits. For each step,
    we will display what we are doing using the Q-sphere and the statevector of the
    circuit. For the two vital components—the oracle and the amplifier—we also display
    the unitary matrixes that they represent.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The sample code for this recipe can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_r3_grover_main.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_r3_grover_main.py).'
  prefs: []
  type: TYPE_NORMAL
- en: The script, in turn, uses three steps to create the Grover circuit. Let's go
    over them one by one, with our initial example for a two-qubit Grover circuit
    in the next subsections. The basic features of the circuit that we are implementing
    here are the same as you add more qubits.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sample code for building the Oracle, the amplifier circuit, and the final
    Grover circuit can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_grover_functions.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_grover_functions.py).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the oracle circuit
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first component that we need is the oracle. One simple way of building an
    oracle to tag a correct answer with a phase shift is to use a phase kickback circuit
    like the one we built in the *Exploring quantum phase kickback* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let's set up a phase kickback oracle circuit that kicks back
    the phase for a specific outcome, such as ![](img/Formula_09_055.png). This means
    that the possible statevector ![](img/Formula_09_055.png) will be phase-shifted
    ![](img/Formula_008_024.png) relative to all the other possible statevectors,
    in this case, ![](img/Formula_09_060.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the oracle circuit looks like when printed out from Qiskit®:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – A phase kickback oracle circuit and corresponding unitary matrix
    for the correct result'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure__9.8_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.8 – A phase kickback oracle circuit and corresponding unitary matrix
    for the correct result ![](img/Formula_09_055.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'How does this work? Let''s walk through what each part of the circuit does:'
  prefs: []
  type: TYPE_NORMAL
- en: On the first controlling qubit, we add an X gate to make sure that ![](img/Formula_09_061.png)
    on that qubit gets flipped to ![](img/Formula_09_062.png), so that it triggers
    the CX gate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the second qubit, we first add an H gate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does this one do? In this case, we want to add a phase to the second qubit,
    so that we can then use the CX gate to kick back to the first qubit. Here, if
    the second qubit is an incorrect ![](img/Formula_09_063.png), applying the H gate
    gives us a superposition ![](img/Formula_09_064.png) with phase 0\. There is nothing
    to kick back, and the solution is not tagged. However, if the second qubit is
    a correct ![](img/Formula_09_065.png), the H gate gives us ![](img/Formula_09_066.png),
    which has a phase of ![](img/Formula_008_037.png), which is then promptly tagged
    to the solution by the CX gate.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, after the CX gate, we then add another X gate to flip the first qubit
    back to its initial state, and another H gate for the second qubit to do the same.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What we have achieved is tagging the statevector for the oracle answer ![](img/Formula_09_068.png)
    with a phase shift of ![](img/Formula_008_037.png). Only that combination will
    get the phase shift; no other combination will.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps this is easier to see in the displayed unitary matrix, where all solutions
    except for the correct one are represented by a 1 in the diagonal, whereas the
    correct solution (![](img/Formula_09_070.png)) is represented by -1, which results
    in a phase shift in the resulting statevector.
  prefs: []
  type: TYPE_NORMAL
- en: 'And this is how we do it in our Python sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s step through it:'
  prefs: []
  type: TYPE_NORMAL
- en: The input to the `create_oracle()` function is an oracle type and a size, where
    the type is a string that specifies the qubit combination we are looking for,
    for example, 10 for the ![](img/Formula_09_068.png) combination.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we step through the oracle type in reverse, adding an X gate for each
    0 in the string to flip it to a 1, as per the preceding discussion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice here that the input to the oracle for a two-bit string is the reverse
    of how Qiskit® labels its qubits, so we need to reverse it into `oracle_input_rev`
    before processing it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We then add an H gate to the last qubit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now for the real meat. Depending on the size of the circuit we are building,
    we add a superposition gate to take care of the phase kickback:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For two qubits, a CX gate is added by the program.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For three qubits, a CCX gate is added; we'll see more on that in *Searching
    with a 3-qubit Grover* recipe.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For 4 and 5 qubits, an MCX (multi-control NOT) gate is added; we'll see more
    about that one in the *Adding more qubits to the Grover search* recipe.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: And finally, we perform the H gate and X gate steps in reverse to balance out
    the oracle circuit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have an oracle circuit that will tag the oracle type that we passed it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the amplifier circuit
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The amplifier circuit is built the same way no matter how many qubits we use
    for the oracle. It takes the input statevector and amplifies the probability of
    the correct solution by reflecting the phase-changed probability across the average
    probability of all solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what that circuit looks like for a 2-qubit circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – A two-qubit amplifier circuit and its corresponding unitary
    matrix'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure__9.9_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.9 – A two-qubit amplifier circuit and its corresponding unitary matrix
  prefs: []
  type: TYPE_NORMAL
- en: Again, perhaps this is easier to see if you look at the amplifier unitary matrix.
    If you do the matrix multiplication for the phase-shifted solution, you will see
    that the probability for the phase-shifted solution is amplified, whereas the
    probability for the no-phase shifted ones is not. It turns out that in the special
    case of a two-qubit Grover circuit, the probability of getting the correct solution
    is actually 100%; you will find the correct solution among four possible ones
    in just one search. That is pretty amazing!
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following matrix multiplication, we will multiply the amplifier matrix
    with the phase-tagged superposition vector to get a solution vector with just
    one possible result, ![](img/Formula_09_068.png), at 100% probability:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_09_073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In our Python sample, this is how it is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The function `create_amplifier()` only takes size as input. The amplifier works
    the same no matter what the oracle is. As you can see, it is somewhat similar
    to the oracle circuit; it too builds a balanced circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: It starts with H gates on all qubits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second step is to add X gates on all qubits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And again, depending on the size of the circuit, it adds a CX, CCX, or MCX gate
    for the phase kickback in the middle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And just like for the oracle circuit, we now reverse the initial X and H gates,
    to balance out the circuit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have our oracle and our amplifier; all we need to do is put them together.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Grover circuit
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Grover circuit puts the pieces together, adds H gates at the beginning,
    to set up a superposition, and adds measurement gates at the end to let you run
    the circuit.
  prefs: []
  type: TYPE_NORMAL
- en: The `create_grover()` function takes the oracle circuit and the amplifier circuit
    as input. It also takes a Boolean `showsteps` parameter. With this one set to
    `showsteps` parameter to **False** to just run the Grover circuit with no extra
    visualizations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the steps for the code we just saw:'
  prefs: []
  type: TYPE_NORMAL
- en: We create a quantum circuit with the global quantum and classical registers
    that we set when we created the oracle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we add H gates on all the qubits and add a barrier instruction to keep
    our circuit intact on transpiling. There are a lot of duplicate gates that follow
    each other here, and we need to retain all of them for the circuit to work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now comes the critical step where we add the oracle and amplifier circuits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To get a well-formed outcome from the Grover circuit, we need to perform the
    correct number of searches as we discussed in *A quick interlude on classical
    search*. In the quantum Grover algorithm, this is represented by running the oracle
    and amplifier circuits once for each search.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For a database of size N=2q, the optimal number of searches or repetitions
    is set by the following formula: n![](img/Formula_09_074.png) . In this case,
    *q* is the number of qubits in our circuit.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you do the math, you see that for a 2-qubit Grover circuit, it is enough
    with 1 search only (n=1.57). For 3- and 4-qubit circuits, we add 2 and 3 repetitions
    respectively by just physically adding the oracle and amplifier circuits.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For an insight into why we use ![](img/Formula_09_075.png) repetitions, see
    the *What happens if we run Grover''s algorithm for too long?* section of the
    *Lecture 22, Tues April 11: Grover* article that is listed in the *See also* section.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, we add the measurement instructions to the circuit, which is now ready
    to run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These are the three functions that we need to build the Grover circuit. But
    if you want to, sit down and play around with building a set of oracles and testing
    them on simulators or real IBM Quantum® quantum computers; see what error mitigation
    does to the results and see what your Grover code actually looks like, and how
    big it becomes after it is transpiled for an IBM Quantum® backend.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a two-qubit Grover circuit, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In your Python environment, run `ch9_r3_grover_main.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When prompted, enter the Oracle answer you want to find in the form of a two-digit
    string consisting of only 1 and 0, for example, *10*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The program now uses the `create_oracle()` function from the `ch9_grover_functions.py`
    script to build a two-qubit oracle circuit, using the oracle type that you entered,
    and then displays what you created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The two-qubit oracle for ![](img/Formula_09_076.png) is displayed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.10 – Oracle circuit for , coded for ](img/Figure__9.10_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 9.10 – Oracle circuit for ![](img/Formula_09_077.png), coded for ![](img/Formula_09_078.png)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We are building a circuit with a CX gate to handle the phase kickback from the
    second qubit to the first qubit.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now build the amplifier circuit for two qubits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step is to create the amplifier circuit by using the `create_amplifier()`
    function. This also uses a CX gate for the phase kickback. The only input the
    function needs is the number of qubits.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This is where we make a couple of circuit manipulations on all the qubits at
    the same time, using the quantum register as input. For example, by using the
    following code, we add a Hadamard gate to all qubits in the `qr` two-qubit quantum
    register, that is, both of them: `amplifierCircuit.h(qr)`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The amplifier circuit and its corresponding unitary matrix look the same for
    all two-qubit Grover circuits:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.11 – Two-qubit amplifier circuit'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure__9.11_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.11 – Two-qubit amplifier circuit
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Go back to the *Creating the amplifier circuit* section for a matrix multiplication
    refresher, if needed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/Formula_09_079.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: As you can see, the phase shifter state 10 has been amplified to `-1`. When
    we calculate the outcome probabilities by squaring the outcome state parameter
    as we did in the [*Chapter 2*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045),
    *Quantum Computing and Qubits with Python*, in the *Comparing a bit and a qubit*
    section, we get the following probable outcome. Result 10 = 100%, and all other
    outcomes = 0%. The probability of getting the amplified correct answer is 100%.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create the Grover circuit step by step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next step, the program creates the Grover quantum circuit that encloses
    our oracle and amplifier and adds measurement gates. Again, we use the `create_grover()`
    function for this.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With the verbose circuit creation display, we get the following output in a
    quick flow. Let's take a look at the circuits one at a time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a blank two-qubit circuit:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.12 – A blank circuit with 100% probability of getting the result'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure__9.12_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.12 – A blank circuit with 100% probability of getting the result ![](img/Formula_008_007.png)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Set the two qubits in superposition:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.13 – A circuit with two qubits in superposition. There is an equal
    probability of 25% of getting each result:](img/Figure__9.13_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 9.13 – A circuit with two qubits in superposition. There is an equal
    probability of 25% of getting each result: ![](img/Formula_09_109.png), ![](img/Formula_008_013.png),
    and ![](img/Formula_09_110.png)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the oracle circuit:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.14 – Adding the oracle circuit for . There is still an equal probability
    of 25% of getting each result: , , and , but  is now phase-shifted'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure__9.14_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.14 – Adding the oracle circuit for ![](img/Formula_09_082.png). There
    is still an equal probability of 25% of getting each result: ![](img/Formula_09_109.png),
    ![](img/Formula_008_013.png), and ![](img/Formula_09_110.png), but ![](img/Formula_008_013.png)
    is now phase-shifted ![](img/Formula_09_018.png)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the amplifier circuit:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.15 – Adding the amplifier circuit, which amplifies the probability
    of the phase-shifted outcome. Now there is a 100% probability of getting'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure__9.15_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.15 – Adding the amplifier circuit, which amplifies the probability
    of the phase-shifted outcome. Now there is a 100% probability of getting ![](img/Formula_09_083.png)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the measurement components to finalize the circuit. The final circuit will
    look something like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.16 – Three-qubit Grover circuit with one repetition of the oracle
    for  and an amplifier'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure__9.16_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.16 – Three-qubit Grover circuit with one repetition of the oracle for
    ![](img/Formula_09_083.png) and an amplifier
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As you can see, the first step of the Grover circuit is to set all the qubits
    in an even superposition by using the H gate. Then, the oracle and the amplifier
    circuits. Finally, we finish by adding measurement components for all the qubits
    so we can read out the end result.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, let's run the circuit and see what result we get:![Figure 9.17 – Two-qubit
    Grover search outcome for  oracle on the Aer simulator](img/Figure__9.17_B14436.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 9.17 – Two-qubit Grover search outcome for ![](img/Formula_09_083.png)
    oracle on the Aer simulator
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Enter `Y` to run the Grover circuit on the least busy 5-qubit IBM Q backend:![Figure
    9.18 – Two-qubit Grover search outcome for  oracle on an IBM Q backend
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure__9.18_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.18 – Two-qubit Grover search outcome for ![](img/Formula_09_083.png)
    oracle on an IBM Q backend
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: So, what is going on here? How come we are not getting the super-precise outcome
    that the oracle and amplifier circuits promised? With the simulator, we had a
    100% chance of getting the correct result. Now we are down to ~91%. Can we use
    error mitigation to do better? For a two-qubit Grover circuit, it turns out we
    can.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run the two-qubit Grover error mitigated for the behavior of the actual quantum
    computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here we add in the mitigated run function that we tested in [*Chapter 8*](B14436_08_Final_PG_ePub.xhtml#_idTextAnchor220),
    *Cleaning Up Our Act with Ignis*, which is encoded as the `mitigated_results(backend,circuit,results)`
    function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The mitigated results are displayed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.19 – Error-mitigated results of a two-qubit Grover search outcome
    for  oracle on an IBM Quantum® backend'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure__9.19_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.19 – Error-mitigated results of a two-qubit Grover search outcome for
    ![](img/Formula_09_0831.png) oracle on an IBM Quantum® backend
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Yes, that is better; we now see a ~95% chance of getting the correct result!
    The error mitigation of this circuit improved our results somewhat and reduced
    the probability of incorrect solutions. The error mitigation works as the circuit
    that we have built is relatively small.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See the final transpiled circuit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final step in our two-qubit Grover exploration is to take a look at the
    transpiled circuit that we ran on the quantum computer. For this, we reuse the
    `transpile_circuit(circuit,backend)` function that we introduced in the *What
    your quantum circuit really looks like* recipe of [*Chapter 6*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156),
    *Understanding the Qiskit® Gate Library*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 9.20 – Final backend executable quantum circuit for the two-qubit
    Grover circuit'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure__9.20_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.20 – Final backend executable quantum circuit for the two-qubit Grover
    circuit
  prefs: []
  type: TYPE_NORMAL
- en: 'And here are some statistics about our Grover circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Our Grover circuit has a total depth, from left to right, of 9 gate manipulations;
    there are a total of 15 individual gates.
  prefs: []
  type: TYPE_NORMAL
- en: For the two-qubit Grover, it turns out that we can use 100% backend basis gates,
    so our transpiled circuit is about the same size as our coded circuit. This will
    change for the three, four, and more qubit Grover circuits where we will be using
    the non-basis gates CCX and MCX. See the *Searching with a three qubit Grover*
    and *Adding more qubits to the Grover search* recipes to take a look.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A quick final note on the two-qubit Grover that we start out with. The two-qubit
    circuit we have built is just one of many different ways of approaching the Grover
    algorithm. I have intentionally chosen this approach to keep down the number of
    qubits that we use, and in doing so we are seeing the second qubit serve two purposes:
    it is part of the oracle, and it is also part of the phase kickback component.'
  prefs: []
  type: TYPE_NORMAL
- en: Another way of building the circuit is to use an ancilla qubit strictly for
    the phase kickback. This keeps the oracle qubits free, but adds one qubit, and
    slightly more complexity to the circuit; we now have to use a CCX gate to do the
    phase kickback, not a CX gate.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a Grover circuit coded for ![](img/Formula_09_068.png) and built
    with an ancilla qubit is here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_grover_ancilla.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_grover_ancilla.py).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how that Python sample is built:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by importing the required classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a three-qubit circuit with two classical bits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will use the third, ancilla qubit as the phase kickback controller:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the code for the oracle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we add the phase kickback using the ancilla qubit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We complete the coding of the oracle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before we are done, we need to build the amplifier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add the measurements of the two first qubits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As the ancilla qubit is just a tool we use inside the circuit, we do not need
    to measure it:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we display the circuit, execute it on a simulator, and show the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The ![](img/Formula_09_068.png) oracle circuit looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.21 – A  oracle Grover circuit using three qubits with an ancilla
    qubit'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure__9.21_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.21 – A ![](img/Formula_09_0832.png) oracle Grover circuit using three
    qubits with an ancilla qubit
  prefs: []
  type: TYPE_NORMAL
- en: Note that to expand the oracle with additional qubits, the only thing you have
    to do is add new qubits at the top and expand the CCX and CX gates to accommodate
    for the additional phase kickback requirements.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For a good read on understanding the Grover algorithm, take a look at *Lecture
    22, Tues April 11: Grover* from the lecture series by Scott Aaronson, David J.
    Bruton Centennial Professor of Computer Science at The University of Texas at
    Austin: [https://www.scottaaronson.com/qclec/22.pdf](https://www.scottaaronson.com/qclec/22.pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: Searching with a three qubit Grover
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The 3-qubit Grover algorithm is very similar to the two qubit implementation
    that we explored in the previous recipe. The main difference is in how we build
    the oracle circuit for three instead of two qubits, building a phase kickback
    that adds the phase to two qubits instead of one.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we have to use a controlled-NOT gate that uses two qubits as input
    to flip the third to entangle the qubits and mark the correct answer with a ![](img/Formula_09_018.png)
    phase. That gate is the Toffoli (CCX) gate instead of the CX gate.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the two qubit input Toffoli gate (CCX) with 2 controlling
    qubits and 1 controlled qubit serves as the phase kickback that shifts the phase
    of the state by ![](img/Formula_09_085.png) if the value of the three qubits matches
    the correct answer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.22 – A CCX-driven oracle for ](img/Figure__9.22_B14436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.22 – A CCX-driven oracle for ![](img/Formula_09_088.png)
  prefs: []
  type: TYPE_NORMAL
- en: We will be using the same sample functions as in *The Grover search algorithm*
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a three qubit Grover circuit, let''s follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In your Python environment, run `ch9_r3_grover_main.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When prompted, enter the oracle answer you want to find in the form of a three-digit
    string consisting of only 1 and 0, for example, `100`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The program now steps through the building process for your three qubit Grover,
    just like for the two qubit one we built in the previous recipe. We will highlight
    the important steps, but not go into any real details. The output should speak
    for itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the Grover circuit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With three qubits, we have a total of N = 8 (![](img/Formula_09_086.png)) possible
    outcomes, as we discussed in *Building Grover's search algorithm* recipe.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For a database of size N=2q, the optimal number of searches or repetitions
    is set by the following formula: n![](img/Formula_09_087.png) . For 3 qubits,
    we thus get n = 2.22\. This we round to 2, for 2 repetitions of the oracle and
    amplifier circuits.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The final circuit will look something like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.23 – Three-qubit Grover circuit with two repetitions for oracle'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure__9.23_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.23 – Three-qubit Grover circuit with two repetitions for oracle ![](img/Formula_09_088.png)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As you can see, the first step of the Grover circuit is to set all the qubits
    in an even superposition by using the H gate. Then we add two repetitions of the
    oracle and the amplifier circuits. Finally, we finish by adding measurement components
    for all the qubits so we can read out the end result.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you have the Boolean `showsteps` parameter set to **True**, you will see
    the individual steps and temporary results for the Grover circuit, with the final
    step looking like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.24 – Three-qubit Grover with the oracle coded for'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure__9.24_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.24 – Three-qubit Grover with the oracle coded for ![](img/Formula_09_088.png)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this final step, you can see that the correct answer, ![](img/Formula_09_090.png),
    has been amplified and now has ~94% probability (0.9722) whereas all other results
    have in the order of 0.8% (-0.0882) probability.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, let's run the circuit and see what result we get:![Figure 9.25 – Three-qubit
    Grover search outcome for a  oracle on a simulator
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure__9.25_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.25 – Three-qubit Grover search outcome for a ![](img/Formula_09_088.png)
    oracle on a simulator
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Notice how the results nicely match what we predicted from the final statevector.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Enter `Y` to run the Grover circuit on the least busy five qubit IBM Quantum®
    backend:![Figure 9.26 – Three-qubit Grover search outcome for a  oracle on an
    IBM Quantum® backend
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure__9.26_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.26 – Three-qubit Grover search outcome for a ![](img/Formula_09_0881.png)
    oracle on an IBM Quantum® backend
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: So, what is going on here? How come we are not getting the super-precise outcome
    that the oracle and amplifier circuits promised? With the simulator, we had about
    a 94% chance of getting the correct result. Here, we are apparently down to ~40%.
    Can we use error mitigation to do better?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See the final, mitigated results:![Figure 9.27 – Error-mitigated results of
    a 3-qubit Grover search outcome for a  oracle on an IBM Quantum® backend
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure__9.27_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.27 – Error-mitigated results of a 3-qubit Grover search outcome for
    a ![](img/Formula_09_0881.png) oracle on an IBM Quantum® backend
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Nope, that didn't do it. Even though the results are slightly better, error
    mitigation didn't fix it. Why? Remember that basic error mitigation mainly concerns
    measurement errors and doesn't take into account issues that might crop up with
    the gates that make up the circuit.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The explanation is in the size of our final Grover circuit. Let's run the final
    step of the program, which transpiles the final circuit and provides us with the
    size, depth, and width of the circuit that is actually run on the backend.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Press *Enter* to see the final, transpiled circuit:![Figure 9.28 – Final backend
    executable quantum circuit for the 3-qubit Grover circuit
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure__9.28_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.28 – Final backend executable quantum circuit for the 3-qubit Grover
    circuit
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'And finally, we have the answer, the circuit size:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our Grover circuit has a total depth, from left to right, of 49 gate manipulations;
    there are a total of 76 individual gates. If you take a quick look at [*Chapter
    8*](B14436_08_Final_PG_ePub.xhtml#_idTextAnchor220), *Cleaning Up Our Act with
    Ignis* again, you'll remember that we pulled out the gate error rates for the
    basis gates for each qubit. Although these errors are pretty small, in the order
    of tenths of a percent and less, when you run in the order of 100 or so gates
    as in the preceding circuit, chances are that there will be errors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: So, in the final analysis, the slightly higher probabilities of getting results
    other than the expected ![](img/Formula_09_090.png) are mainly due to gate errors,
    and not measurement errors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Adding more qubits to the Grover search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have done reasonably well in our Grover coding. We built our two
    and three qubit circuits using unique Qiskit® gates for the number of qubits that
    our circuits contained: CX and CCX. For a four qubit and more Grover, we will
    use a multi-control NOT gate, MCX, to dynamically create the right number of control
    inputs.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use the same sample functions as in the *Building the Grover's search
    algorithm* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: For two and three qubit Grovers, we could use the prefabricated CX and CCX gates
    to create our oracle and amplifier circuits. As we are using the same model to
    build a four and more qubit Grover, instead of using CCCX, CCCCX gates, and more,
    we use the MCX gate in our circuit, to let Qiskit® build the gate logic behind
    the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To understand what we are doing here, take a look back at [*Chapter 6*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156),
    *Understanding the Qiskit® Gate Library*, specifically at the CX and CCX gates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the unitary matrix for the CX gate, as seen in the *Building the Grover''s
    search algorithm* recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_09_095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s the unitary matrix for the CCX gate (Toffoli), as seen in the *Searching
    with a 3-qubit Grover* recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_09_096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The magic here is in the lower-right corner where the ones have left the diagonal
    and form a mini-diagonal the other way. The effect of this swap is to flip the
    value of the last qubit. Algebraically, this is an easy manipulation of the initial
    diagonal identity matrix; all we have to do is swap the two last rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'A **controlled-controlled-controlled NOT** (**CCCX**) gate unitary matrix will
    then look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_09_097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It turns out that building a unitary matrix that represents CCCX is not that
    hard for just a few qubits, but the matrix grows in size as 2n so the next one,
    CCCCX, will be quite large.
  prefs: []
  type: TYPE_NORMAL
- en: This is all great, but what do we now do with this glorious matrix? The answer
    is to let Qiskit® code it into gates for us by using the MCX gate. This gate takes
    a set of control qubits and a target qubit as input. You can also specify to use
    **ancilla** qubits for handling the phase kickback, but for our circuit, we will
    not do that. Look back at the ancilla sample in the *There's more* section of
    the *Building Grover's search algorithm* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what using that gate looks like in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'For more help on the MCX gate, use Python `help`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: With the nitty-gritty behind the CCCX gate taken care of, building the 4+ Grover
    circuit is done exactly like the two and three qubit Grovers.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will be a little less stringent in covering and displaying all the steps
    here as the four qubit Grover takes up a lot more space than the others we have
    worked with. Feel free to revisit the previous recipes for details, and just apply
    them to the Grover we are building here.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a 4-qubit Grover, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In your Python environment, run `ch9_r3_grover_main.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When prompted, enter the Oracle answer you want to find in the form of a 3-digit
    string consisting of only 1 and 0, for example, `1000`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's build the Grover circuit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The program now steps through the building process for your three qubit Grover,
    just like for the two qubit one we built in the previous recipe. We will highlight
    the important steps, but not go into any real details. The output should speak
    for itself.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With three qubits, we have a total of N = 16 (![](img/Formula_09_098.png)) possible
    outcomes, and as we discussed in the *Building the Grover's search algorithm*
    recipe, the ideal number of repetitions of the circuit is ![](img/Formula_09_099.png).
    For 3 qubits, we thus get n = 3.14\. This we round to 3, for 3 repetitions of
    the oracle and amplifier circuits.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The final circuit will look something like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.29 – Four-qubit Grover circuit with three repetitions for oracle
    ](img/Figure__9.29_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 9.29 – Four-qubit Grover circuit with three repetitions for oracle ![](img/Formula_09_100.png)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you have the Boolean `showsteps` parameter set to **True**, you will see
    the individual steps and temporary results for the Grover circuit, with the final
    step looking like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.30 – Four-qubit Grover with the oracle coded for'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure__9.30_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.30 – Four-qubit Grover with the oracle coded for ![](img/Formula_09_101.png)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this final step, you can see (after some digging) that the correct answer,
    ![](img/Formula_09_102.png) has been amplified (-0.98046875) and now has ~96%
    probability whereas all other results have in the order of 0.02% probability.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, let's run the circuit and see what result we get:![Figure 9.31 – Four-qubit
    Grover search outcome for a  oracle on a simulator
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure__9.31_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.31 – Four-qubit Grover search outcome for a ![](img/Formula_09_103.png)
    oracle on a simulator
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Enter `Y` to run the Grover circuit on the least busy five qubit IBM Quantum®
    backend:![Figure 9.32 – Four-qubit Grover search outcome for a  oracle on an IBM
    Quantum® backend
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure__9.32_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.32 – Four-qubit Grover search outcome for a ![](img/Formula_09_104.png)
    oracle on an IBM Quantum® backend
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This time, we seem to be getting nothing but noise. Surely there is no clear
    answer in that randomness. The correct answer is nowhere near the top of this
    list. Let's see the results after error mitigation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The explanation is again in the size of our final Grover circuit. The final
    step of the program will give us the transpiled circuit.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Press *Enter* to see the final, transpiled circuit. The result this time is
    pretty overwhelming:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.33 – Final backend executable quantum circuit for the 4-qubit Grover
    circuit'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure__9.33_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.33 – Final backend executable quantum circuit for the 4-qubit Grover
    circuit
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, we have the answer, the circuit size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Our Grover circuit has a total depth, from left to right, of 311 gate manipulations;
    there are a total of 409 individual gates. Again, just like in the *Searching
    with a three qubit Grover* recipe, the fact that we just get noise is due to gate
    errors and not measurement errors. The circuit has grown too big for efficient
    execution on a NISQ machine. There is nothing wrong with our Grover circuit, it
    is just too large!
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now go ahead and create a five qubit Grover and see where it takes you. The
    simulator should be able to handle it gallantly and give you the expected results,
    say for a ![](img/Formula_09_105.png) oracle. But running it on a real quantum
    computer will just give you noise:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.34 – Five-qubit Grover search outcome for a  oracle on a simulator'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure__9.34_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.34 – Five-qubit Grover search outcome for a ![](img/Formula_09_106.png)
    oracle on a simulator
  prefs: []
  type: TYPE_NORMAL
- en: 'The final results of a five qubit Grover circuit when run on a real quantum
    computer are displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.35 – Five-qubit Grover search outcome for a  oracle on an IBM Quantum®
    backend'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure__9.35_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.35 – Five-qubit Grover search outcome for a ![](img/Formula_09_107.png)
    oracle on an IBM Quantum® backend
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the final, transpiled circuit. Depending on which IBM Quantum®
    machine that you run your circuit on, you might get a different size and depth
    depending on the machine topology. Creating a CCCCX gate (using the MCX gate)
    on a machine with just five qubits will require a *lot* of swapping, not to mention
    repeating the oracle and amplifier four times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a circuit size example from running on the `ibmqx2` five qubit backend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: A circuit this size will have to wait for a universal quantum computer; it is
    too big to successfully run on a NISQ machine.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Grover circuit in your own code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's quite a bit of code going into the combined `ch9_r3_grover_main.py`
    and `ch9_grover_functions.py` scripts. The interactive main program is not needed
    to just run Grover if, for example, you want to utilize it in another Python program.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The sample Grover functions code that you need is included here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_grover_functions.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_grover_functions.py).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Technically, all you need to do is to include the following short code snippet
    in your own code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code should give the following result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.36 – Using the Grover functions in a minimal script to create a  Grover
    circuit'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure__9.36_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.36 – Using the Grover functions in a minimal script to create a ![](img/Formula_09_108.png)
    Grover circuit
  prefs: []
  type: TYPE_NORMAL
- en: From a Qiskit Terra circuit point of view, we are now done, and you can include
    your `grover` circuit with your own hybrid classical/quantum code to get the Grover
    search results.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: But we can do even better! Qiskit Aqua actually includes a `Grover()` function
    that you can use directly without having to write any code. More on this in the
    *Running Grover as an Aqua function* recipe in [*Chapter 10*](B14436_10_Final_PG_ePub.xhtml#_idTextAnchor271),
    *Getting to Know Algorithms with Aqua*.
  prefs: []
  type: TYPE_NORMAL
