<html><head></head><body><div id="sbo-rt-content"><div>
			<div id="_idContainer051" class="Content">
			</div>
		</div>
		<div id="_idContainer052" class="Content">
			<h1 id="_idParaDest-76"><a id="_idTextAnchor078"/>3. Introduction to NumPy, Pandas, and Matplotlib</h1>
		</div>
		<div id="_idContainer082" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">In this chapter, you will learn about the fundamentals of the <strong class="source-inline">NumPy</strong>, <strong class="source-inline">pandas</strong>, and <strong class="source-inline">matplotlib</strong> libraries. You will learn to create one-dimensional and multi-dimensional arrays and manipulate <strong class="source-inline">pandas</strong> DataFrames and <strong class="source-inline">series</strong> objects. By the end of this chapter, you will be able to visualize and plot numerical data using the <strong class="source-inline">Matplotlib</strong> library, as well as to apply <strong class="source-inline">matplotlib</strong>, <strong class="source-inline">NumPy</strong>, and <strong class="source-inline">pandas</strong> to calculate descriptive statistics from a DataFrame or matrix.</p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor079"/>Introduction</h1>
			<p>In the preceding chapters, we covered some advanced data structures, s<a id="_idTextAnchor080"/>uch as stack, queue, iterator, and file operations in Python. In this chapter, we will cover three essential libraries, namely <strong class="source-inline">NumPy</strong>, <strong class="source-inline">pandas</strong>, and <strong class="source-inline">matplotlib</strong>. <strong class="source-inline">NumPy</strong> is an advanced math library in Python with an extensive range of functionality. <strong class="source-inline">pandas</strong> is a library built on <strong class="source-inline">NumPy</strong> that allows developers to model the data in a table structure similar to a database; <strong class="source-inline">malplotlib</strong>, on the other hand, is a charting library that is influenced by Matlab. With these libraries, you will be able to handle most data wrangling tasks.</p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor081"/>NumPy Arrays</h1>
			<p>A <strong class="source-inline">NumPy</strong> array is similar to a list but differs in some ways. In the life of a data scientist, reading and manipulating an array is of prime importance, and it is also the most frequently encountered task. These arrays could be a one-dimensional list, a multi-dimensional table, or a matrix full of numbers and can be used for a variety of mathematical calculations.</p>
			<p>An array could be filled with integers, floating-point numbers, Booleans, strings, or even mixed types. However, in the majority of cases, numeric data types are predominant. Some example scenarios where you will need to handle numeric arrays are as follows:</p>
			<ul>
				<li>To read a list of phone numbers and postal codes and extract a certain pattern</li>
				<li>To create a matrix with random numbers to run a Monte Carlo simulation on a statistical process</li>
				<li>To scale and normalize a sales figure table, with lots of financial and transactional data</li>
				<li>To create a smaller table of key descriptive statistics (for example, mean, median, min/max range, variance, and inter-quartile ranges) from a large raw data table</li>
				<li>To read in and analyze time series data in a one-dimensional array daily, such as the stock price of an organization over a year or daily temperature data from a weather station</li>
			</ul>
			<p>In short, arrays and numeric data tables are everywhere. As a data wrangling professional, the importance of the ability to read and process numeric arrays cannot be overstated. It is very common to work with data and need to modify it with a mathematical function. In this regard, <strong class="source-inline">NumPy</strong> arrays are the most important objects in Python that you need to know about.</p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor082"/>NumPy Arrays and Features</h2>
			<p>NumPy and SciPy are open source add-on modules for Python that provide common mathematical and numerical routines in pre-compiled, fast functions. Over the years, these have grown into highly mature libraries that provide functionality that meets, or perhaps exceeds, what is associated with common commercial software such as Matlab or Mathematica.</p>
			<p>One of the main advantages of the NumPy module is that it can be used to handle or create one-dimensional or multi-dimensional arrays. This advanced data structure/class is at the heart of the NumPy package and it serves as the fundamental building block of more advanced concepts, such as the <strong class="source-inline">pandas</strong> library and specifically, the pandas DataFrame, which we will cover shortly in this chapter.</p>
			<p>NumPy arrays are different than common Python lists since Python lists can be thought of as simple arrays. NumPy arrays are built for mathematical vectorized operations that process a lot of numerical data with just a single line of code. Many built-in mathematical functions in NumPy arrays are written in low-level languages such as C or Fortran and are pre-compiled for really fast execution.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">NumPy arrays are optimized data structures for numerical analysis, and that's why they are so important to data scientists.</p>
			<p>Let's go through the first exercise in this chapter, where we will learn how to create a <strong class="source-inline">NumPy</strong> array from a list. </p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor083"/>Exercise 3.01: Creating a NumPy Array (from a List)</h2>
			<p>In this exercise, we will create a <strong class="source-inline">NumPy</strong> array from a list. We're going to define a list first and use the array function of the <strong class="source-inline">NumPy</strong> library to convert the list into an array. Next, we'll read from a <strong class="source-inline">.csv</strong> file and store the data in a <strong class="source-inline">NumPy</strong> array using the <strong class="source-inline">genfromtxt</strong> function of the <strong class="source-inline">NumPy</strong> library. To do so, let's go through the following steps:</p>
			<ol>
				<li>To work with <strong class="source-inline">NumPy</strong>, we must import it. By convention, we give it a short name, np, while importing it. This will make referencing the objects under the <strong class="source-inline">NumPy</strong> package organized:<p class="source-code">import numpy as np</p></li>
				<li>Create a list with three elements: <strong class="source-inline">1</strong>, <strong class="source-inline">2</strong>, and <strong class="source-inline">3</strong>:<p class="source-code">list_1 = [1,2,3]</p><p class="source-code">list_1</p><p>The output is as follows:</p><p class="source-code">[1, 2, 3]</p></li>
				<li>Use the <strong class="source-inline">array</strong> function to convert it into an array:<p class="source-code">array_1 = np.array(list_1)</p><p class="source-code">array_1</p><p>The output is as follows:</p><p class="source-code">array([1, 2, 3])</p><p>We just created a <strong class="source-inline">NumPy</strong> array object called <strong class="source-inline">array_1</strong> from the regular Python list object, <strong class="source-inline">list_1</strong>.</p></li>
				<li>Create an array of floating type elements, that is, <strong class="source-inline">1.2</strong>, <strong class="source-inline">3.4</strong>, and <strong class="source-inline">5.6</strong>, using the array function directly:<p class="source-code">a = np.array([1.2, 3.4, 5.6])</p><p class="source-code">a</p><p>The output is as follows:</p><p class="source-code">array([1.2, 3.4, 5.6])</p></li>
				<li>Let's check the type of the newly created object, a, using the <strong class="source-inline">type</strong> function:<p class="source-code">type(a)</p><p>The output is as follows:</p><p class="source-code">numpy.ndarray</p></li>
				<li>Use the <strong class="source-inline">type</strong> function to check the type of <strong class="source-inline">array_1</strong>:<p class="source-code">type(array_1)</p><p>The output is as follows:</p><p class="source-code">numpy.ndarray</p><p>As we can see, both a and <strong class="source-inline">array_1</strong> are <strong class="source-inline">NumPy</strong> arrays. </p></li>
				<li>Now, use type on <strong class="source-inline">list_1</strong>:<p class="source-code">type(list_1)</p><p>The output is as follows:</p><p class="source-code">list</p><p>As we can see, <strong class="source-inline">list_1</strong> is essentially a Python list and we have used the array function of the <strong class="source-inline">NumPy</strong> library to create a <strong class="source-inline">NumPy</strong> array from that list.</p></li>
				<li>Now, let's read a <strong class="source-inline">.csv</strong> file as a <strong class="source-inline">NumPy</strong> array using the <strong class="source-inline">genfromtxt</strong> function of the <strong class="source-inline">NumPy</strong> library:<p class="source-code">data = np.genfromtxt('<strong class="bold">../datasets/stock.csv</strong>', \</p><p class="source-code">                     delimiter=',',names=True,dtype=None, \</p><p class="source-code">                     encoding='ascii')</p><p class="source-code">data</p><p class="callout-heading">Note</p><p class="callout">The path (highlighted) should be specified based on the location of the file on your system. The <strong class="source-inline">stock.csv</strong> file can be found here: <a href="https://packt.live/2YK0XB2">https://packt.live/2YK0XB2</a>.</p><p>The partial output is as follows:</p><p class="source-code">array([('MMM', 100), ('AOS', 101), ('ABT', 102), ('ABBV', 103),</p><p class="source-code">       ('ACN', 104), ('ATVI', 105), ('AYI', 106), ('ADBE', 107),</p><p class="source-code">       ('AAP', 108), ('AMD', 109), ('AES', 110), ('AET', 111),</p><p class="source-code">       ('AMG', 112), ('AFL', 113), ('A', 114), ('APD', 115),</p><p class="source-code">       ('AKAM', 116), ('ALK', 117), ('ALB', 118), ('ARE', 119),</p><p class="source-code">       ('ALXN', 120), ('ALGN', 121), ('ALLE', 122), ('AGN', 123),</p><p class="source-code">       ('ADS', 124), ('LNT', 125), ('ALL', 126), ('GOOGL', 127),</p><p class="source-code">       ('GOOG', 128), ('MO', 129), ('AMZN', 130), ('AEE', 131),</p><p class="source-code">       ('AAL', 132), ('AEP', 133), ('AXP', 134), ('AIG', 135),</p><p class="source-code">       ('AMT', 136), ('AWK', 137), ('AMP', 138), ('ABC', 139),</p><p class="source-code">       ('AME', 140), ('AMGN', 141), ('APH', 142), ('APC', 143),</p><p class="source-code">       ('ADI', 144), ('ANDV', 145), ('ANSS', 146), ('ANTM', 147),</p><p class="source-code">       ('AON', 148)], dtype=[('Symbol', '&lt;U5'), ('Price', '&lt;i8')])</p></li>
				<li>Use the <strong class="source-inline">type</strong> function to check the type of <strong class="source-inline">data</strong>:<p class="source-code">type(data)</p><p>The output is as follows:</p><p class="source-code">numpy.ndarray</p></li>
			</ol>
			<p>As we can see, the data variable is also a <strong class="source-inline">NumPy</strong> array. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2Y9pTTx">https://packt.live/2Y9pTTx</a>. </p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/2URNcPz">https://packt.live/2URNcPz</a>.</p>
			<p>From this exercise, we can observe that the <strong class="source-inline">NumPy</strong> array is different from the regular list object. The most important point to keep in mind is that <strong class="source-inline">NumPy</strong> arrays do not have the same methods as lists and that they are essentially designed for mathematical functions. </p>
			<p><strong class="source-inline">NumPy</strong> arrays are like mathematical objects – <strong class="bold">vectors</strong>. They are built for element-wise operations, that is, when we add two <strong class="source-inline">NumPy</strong> arrays, we add the first element of the first array to the first element of the second array – there is an element-to-element correspondence in this operation. This is in contrast to Python lists, where the elements are simply appended and there is no element-to-element relation. This is the real power of a NumPy array: they can be treated just like mathematical vectors.</p>
			<p>A vector is a collection of numbers that can represent, for example, the coordinates of points in a three-dimensional space or the color of numbers (RGB) in a picture. Naturally, relative order is important for such a collection and as we discussed previously, a <strong class="source-inline">NumPy</strong> array can maintain such order relationships. That's why they are perfectly suitable to use in numerical computations.</p>
			<p>With this knowledge, we're going to perform the addition operation on <strong class="source-inline">NumPy</strong> arrays in the next exercise.</p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor084"/>Exercise 3.02: Adding Two NumPy Arrays</h2>
			<p>This simple exercise will demonstrate the addition of two <strong class="source-inline">NumPy</strong> arrays using the <strong class="source-inline">+</strong> notation, and thereby show the key difference between a regular Python list/array and a <strong class="source-inline">NumPy</strong> array. Let's perform the following steps:</p>
			<ol>
				<li value="1"><a id="_idTextAnchor085"/>Import the <strong class="source-inline">NumPy</strong> library:<p class="source-code">import numpy as np</p></li>
				<li>Declare a Python list called <strong class="source-inline">list_1</strong> and a <strong class="source-inline">NumPy</strong> array:<p class="source-code">list_1 = [1,2,3]</p><p class="source-code">array_1 = np.array(list_1)</p></li>
				<li>Use the <strong class="source-inline">+</strong> notation to concatenate two <strong class="source-inline">list_1</strong> objects and save the results in <strong class="source-inline">list_2</strong>:<p class="source-code">list_2 = list_1 + list_1</p><p class="source-code">list_2</p><p>The output is as follows:</p><p class="source-code">[1, 2, 3, 1, 2, 3]</p></li>
				<li>Use the same <strong class="source-inline">+</strong> notation to concatenate two <strong class="source-inline">array_1</strong> objects and save the result in <strong class="source-inline">array_2</strong>:<p class="source-code">array_2 = array_1 + array_1</p><p class="source-code">array_2</p><p>The output is as follows:</p><p class="source-code">[2 ,4, 6]</p></li>
				<li>Load a <strong class="source-inline">.csv</strong> file and concatenate it with itself:<p class="source-code">data = np.genfromtxt('<strong class="bold">../datasets/numbers.csv</strong>', \</p><p class="source-code">                     delimiter=',', names=True)</p><p class="source-code">data = data.astype('float64')</p><p class="source-code">data + data</p><p class="callout-heading">Note</p><p class="callout">The path (highlighted) should be specified based on the location of the file on your system. The <strong class="source-inline">.csv</strong> file that will be used is <strong class="source-inline">numbers.csv</strong>; this can be found at: <a href="https://packt.live/30Om2wC">https://packt.live/30Om2wC</a>.</p><p>The output is as follows:</p><p class="source-code">array([202., 204., 206., 208., 210., 212., 214., 216., 218., </p><p class="source-code">       220., 222., 224., 226., 228., 230., 232., 234., 236., </p><p class="source-code">       238., 240., 242., 244., 246., 248., 250., 252., 254., </p><p class="source-code">       256., 258., 260., 262., 264., 266., 268., 270., 272., </p><p class="source-code">       274., 276., 278., 280., 282., 284., 286., 288., 290., </p><p class="source-code">       292., 294., 296.])</p></li>
			</ol>
			<p>Did you notice the difference? The first <strong class="bold">print</strong> shows a list with <strong class="source-inline">6</strong> elements, [<strong class="source-inline">1, 2, 3, 1, 2, 3</strong>], but the second <strong class="bold">print</strong> shows another <strong class="source-inline">NumPy</strong> array (or vector) with the elements [<strong class="source-inline">2, 4, 6</strong>], which are just the sum of the individual elements of <strong class="source-inline">array_1</strong>. As we discussed earlier, <strong class="source-inline">NumPy</strong> arrays are perfectly designed to perform element-wise operations since there is element-to-element correspondence.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/3fyvSqF">https://packt.live/3fyvSqF</a>. </p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3fvUDnf%20">https://packt.live/3fvUDnf</a></p>
			<p><strong class="source-inline">NumPy</strong> arrays even support element-wise exponentiation. For example, suppose there are two arrays – the elements of the first array will be raised to the power of the elements in the second array.</p>
			<p>In the following exercise, we will try out some mathematical operations on <strong class="source-inline">NumPy</strong> arrays.</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor086"/>Exercise 3.03: Mathematical Operations on NumPy Arrays</h2>
			<p>In this exercise, we'll generate a <strong class="source-inline">NumPy</strong> array with the values extracted from a <strong class="source-inline">.csv</strong> file. We'll be using the multiplication and division operators on the generated <strong class="source-inline">NumPy</strong> array. Let's go through the following steps:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">.csv</strong> file that will be used is <strong class="source-inline">numbers.csv</strong>; this can be found at: <a href="https://packt.live/30Om2wC">https://packt.live/30Om2wC</a>.</p>
			<ol>
				<li value="1">Import the <strong class="source-inline">NumPy</strong> library and create a <strong class="source-inline">NumPy</strong> array from the <strong class="source-inline">.csv</strong> file:<p class="source-code">import numpy as np</p><p class="source-code">data = np.genfromtxt('<strong class="bold">../datasets/numbers.csv</strong>', \</p><p class="source-code">                     delimiter=',', names=True)</p><p class="source-code">data = data.astype('float64')</p><p class="source-code">data</p><p class="callout-heading">Note</p><p class="callout">Don't forget to change the path (highlighted) based on the location of the file on your system.</p><p>The output is as follows:</p><p class="source-code">array([101., 102., 103., 104., 105., 106., 107., 108., 109., </p><p class="source-code">       110., 111., 112., 113., 114., 115., 116., 117., 118., </p><p class="source-code">       119., 120., 121., 122., 123., 124., 125., 126., 127., </p><p class="source-code">       128., 129., 130., 131., 132., 133., 134., 135., 136., </p><p class="source-code">       137., 138., 139., 140., 141., 142., 143., 144., 145., </p><p class="source-code">       146., 147., 148.])</p></li>
				<li>Multiply <strong class="source-inline">45</strong> by every element in the array:<p class="source-code">data * 45</p><p>The output is as follows:</p><p class="source-code">array([4545., 4590., 4635., 4680., 4725., 4770., 4815., 4860., </p><p class="source-code">       4905., 4950., 4995., 5040., 5085., 5130., 5175., 5220., </p><p class="source-code">       5265., 5310., 5355., 5400., 5445., 5490., 5535., 5580., </p><p class="source-code">       5625., 5670., 5715., 5760., 5805., 5850., 5895., 5940., </p><p class="source-code">       5985., 6030., 6075., 6120., 6165., 6210., 6255., 6300., </p><p class="source-code">       6345., 6390., 6435., 6480., 6525., 6570., 6615., 6660.])</p></li>
				<li>Divide the array by <strong class="source-inline">67.7</strong>:<p class="source-code">data / 67.7</p><p>The output is as follows:</p><p class="source-code">array([1.49187592, 1.50664697, 1.52141802, 1.53618907, </p><p class="source-code">       1.55096012, 1.56573117, 1.58050222, 1.59527326, </p><p class="source-code">       1.61004431, 1.62481536, 1.63958641, 1.65435746, </p><p class="source-code">       1.66912851, 1.68389956, 1.69867061, 1.71344165, </p><p class="source-code">       1.7282127 , 1.74298375, 1.7577548 , 1.77252585, </p><p class="source-code">       1.7872969 , 1.80206795, 1.816839  , 1.83161004, </p><p class="source-code">       1.84638109, 1.86115214, 1.87592319, 1.89069424, </p><p class="source-code">       1.90546529, 1.92023634, 1.93500739, 1.94977843, </p><p class="source-code">       1.96454948, 1.97932053, 1.99409158, 2.00886263, </p><p class="source-code">       2.02363368, 2.03840473, 2.05317578, 2.06794682, </p><p class="source-code">       2.08271787, 2.09748892, 2.11225997, 2.12703102, </p><p class="source-code">       2.14180207, 2.15657312, 2.17134417, 2.18611521])</p></li>
				<li>Raise one array to the second array's power using the following command:<p class="source-code">list_1 = [1,2,3]</p><p class="source-code">array_1 = np.array(list_1)</p><p class="source-code">print("array_1 raised to the power of array_1: ", \</p><p class="source-code">      array_1**array_1)</p><p>The output is as follows:</p><p class="source-code">array_1 raised to the power of array_1:  [ 1  4 27]</p></li>
			</ol>
			<p>Thus, we can observe how NumPy arrays allow element-wise exponentiation.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/3hBZMw4">https://packt.live/3hBZMw4</a>. </p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/2N4dE3Y">https://packt.live/2N4dE3Y</a>.</p>
			<p>In the next section, we'll discuss how to apply advanced mathematical operations to NumPy arrays. </p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor087"/>Advanced Mathematical Operations </h1>
			<p>Generating numerical arrays is a fairly common task. So far, we have been doing this by creating a Python list object and then converting that into a <strong class="source-inline">NumPy</strong> array. However, we can bypass that and work directly with native NumPy methods. The <strong class="source-inline">arange</strong> function creates a series of numbers based on the minimum and maximum bounds you give and the step size you specify. Another function, <strong class="source-inline">linspace</strong>, creates a series of fixed numbers of the intermediate points between two extremes.</p>
			<p>In the next exercise, we are going to create a list and then convert that into a <strong class="source-inline">NumPy</strong> array. We will then show you how to perform some advanced mathematical operations on that array.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor088"/>Exercise 3.04: Advanced Mathematical Operations on NumPy Arrays</h2>
			<p>In this exercise, we'll practice using all the built-in mathematical functions of the <strong class="source-inline">NumPy</strong> library. Here, we are going to be creating a list and converting it into a <strong class="source-inline">NumPy</strong> array. Then, we will perform some advanced mathematical operations on that array. Let's go through the following steps:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">We're going to use the <strong class="source-inline">numbers.csv</strong> file in this exercise, which can be found here: <a href="https://packt.live/30Om2wC">https://packt.live/30Om2wC</a>.</p>
			<ol>
				<li value="1">Import the <strong class="source-inline">pandas</strong> library and read from the <strong class="source-inline">numbers.csv</strong> file using <strong class="source-inline">pandas</strong>. Then, convert it into a list:<p class="source-code">import pandas as pd</p><p class="source-code">df = pd.read_csv("<strong class="bold">../datasets/numbers.csv</strong>")</p><p class="source-code">list_5 = df.values.tolist()</p><p class="source-code">list_5</p><p class="callout-heading">Note</p><p class="callout">Don't forget to change the path (highlighted) based on the location of the file on your system.</p><p>The output (partially shown) is as follows:</p><div id="_idContainer053" class="IMG---Figure"><img src="Images/B15780_03_01.jpg" alt="Figure 3.1: Partial output of the .csv file&#13;&#10;" width="726" height="255"/></div><p class="figure-caption">Figure 3.1: Partial output of the .csv file</p></li>
				<li>Convert the list into a <strong class="source-inline">NumPy</strong> array by using the following command:<p class="source-code">import numpy as np</p><p class="source-code">array_5 = np.array(list_5)</p><p class="source-code">array_5</p><p>The output (partially shown) is as follows:</p><div id="_idContainer054" class="IMG---Figure"><img src="Images/B15780_03_02.jpg" alt="Figure 3.2: Partial output of the NumPy array&#13;&#10;" width="657" height="281"/></div><p class="figure-caption">Figure 3.2: Partial output of the NumPy array</p></li>
				<li>Find the sine value of the array by using the following command:<p class="source-code"># sine function</p><p class="source-code">np.sin(array_5)</p><p>The output (partially shown) is as follows:</p><div id="_idContainer055" class="IMG---Figure"><img src="Images/B15780_03_03.jpg" alt="Figure 3.3: Partial output of the sine value&#13;&#10;" width="614" height="229"/></div><p class="figure-caption">Figure 3.3: Partial output of the sine value</p></li>
				<li>Find the logarithmic value of the array by using the following command:<p class="source-code"># logarithm</p><p class="source-code">np.log(array_5)</p><p>The output (partially shown) is as follows:</p><div id="_idContainer056" class="IMG---Figure"><img src="Images/B15780_03_04.jpg" alt="Figure 3.4: Partial output of the logarithmic array&#13;&#10;" width="623" height="203"/></div><p class="figure-caption">Figure 3.4: Partial output of the logarithmic array</p></li>
				<li>Find the exponential value of the array by using the following command:<p class="source-code"># Exponential</p><p class="source-code">np.exp(array_5)</p><p>The output (partially shown) is as follows:</p><div id="_idContainer057" class="IMG---Figure"><img src="Images/B15780_03_05.jpg" alt="Figure 3.5: Partial output of the exponential array&#13;&#10;" width="623" height="229"/></div></li>
			</ol>
			<p class="figure-caption">Figure 3.5: Partial output of the exponential array</p>
			<p>As we can see, advanced mathematical operations are fairly easy to perform on a <strong class="source-inline">NumPy</strong> array using the built-in methods.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/37NIyrf">https://packt.live/37NIyrf</a>. </p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3eh0Xz6">https://packt.live/3eh0Xz6</a>.</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor089"/>Exercise 3.05: Generating Arrays Using arange and linspace Methods</h2>
			<p>This exercise will demonstrate how we can create a series of numbers using the <strong class="source-inline">arange</strong> method. To make the list linearly spaced, we're going to use the <strong class="source-inline">linspace</strong> method. To do so, let's go through the following steps:</p>
			<ol>
				<li value="1">Import the <strong class="source-inline">NumPy</strong> library and create a series of numbers using the <strong class="source-inline">arange</strong> method using the following command:<p class="source-code">import numpy as np</p><p class="source-code">np.arange(5,16)</p><p>The output is as follows:</p><p class="source-code">array([ 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])</p></li>
				<li>Print numbers using the <strong class="source-inline">arange</strong> function by using the following command:<p class="source-code">print("Numbers spaced apart by 2: ",\</p><p class="source-code">      np.arange(0,11,2))</p><p class="source-code">print("Numbers spaced apart by a floating point number:   ",\</p><p class="source-code">      np.arange(0,11,2.5))</p><p class="source-code">print("Every 5th number from 30 in reverse order\n",\</p><p class="source-code">      np.arange(30,-1,-5))</p><p>The output is as follows:</p><p class="source-code">Numbers spaced apart by 2: [ 0 2 4 6 8 10]</p><p class="source-code">Numbers spaced apart by a floating point number:  </p><p class="source-code">[ 0. 2.5 5.0 7.5 10. ]</p><p class="source-code">Every 5th number from 30 in reverse order</p><p class="source-code"> [30 25 20 15 10  5  0]</p></li>
				<li>For linearly spaced numbers, we can use the <strong class="source-inline">linspace</strong> method, as follows:<p class="source-code">print("11 linearly spaced numbers between 1 and 5: ",\</p><p class="source-code">      np.linspace(1,5,11))</p><p>The output is as follows:</p><p class="source-code">11 linearly spaced numbers between 1 and 5: </p><p class="source-code">[1. 1.4 1.8 2.2 2.6 3. 3.4 3.8 4.2 4.6 5. ]</p></li>
			</ol>
			<p>As we can see, the <strong class="source-inline">linspace</strong> method helps us in creating linearly spaced elements in an array.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2YOZGsy">https://packt.live/2YOZGsy</a>. </p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3ddPcYG">https://packt.live/3ddPcYG</a>.</p>
			<p>So far, we have only created one-dimensional arrays. Now, let's create some multi-dimensional arrays (such as a matrix in linear algebra). </p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor090"/>Exercise 3.06: Creating Multi-Dimensional Arrays</h2>
			<p>In this exercise, just like we created the one-dimensional array from a simple flat list, we will create a two-dimensional array from a list of lists.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">This exercise will use the <strong class="source-inline">numbers2.csv</strong> file, which can be found at <a href="https://packt.live/2V8EQTZ">https://packt.live/2V8EQTZ</a>.</p>
			<p>Let's go through the following steps:</p>
			<ol>
				<li value="1">Import the necessary Python libraries, load the <strong class="source-inline">numbers2.csv</strong> file, and convert it into a two-dimensional <strong class="source-inline">NumPy</strong> array by using the following commands:<p class="source-code">import pandas as pd</p><p class="source-code">import numpy as np</p><p class="source-code">df = pd.read_csv("<strong class="bold">../datasets/numbers2.csv</strong>",\</p><p class="source-code">                 header=None)</p><p class="source-code">list_2D = df.values</p><p class="source-code">mat1 = np.array(list_2D)</p><p class="source-code">print("Type/Class of this object:",\</p><p class="source-code">      type(mat1))</p><p class="source-code">print("Here is the matrix\n----------\n",\</p><p class="source-code">      mat1, "\n----------")</p><p class="callout-heading">Note</p><p class="callout">Don't forget to change the path (highlighted) based on the location of the file on your system.</p><p>The output is as follows:</p><p class="source-code">Type/Class of this object: &lt;class 'numpy.ndarray'&gt;</p><p class="source-code">Here is the matrix</p><p class="source-code">---------- </p><p class="source-code">[[1 2 3] </p><p class="source-code">[4 5 6] </p><p class="source-code">[7 8 9]] </p><p class="source-code">----------</p></li>
				<li>Tuples can be converted into multi-dimensional arrays by using the following code:<p class="source-code">tuple_2D = np.array([(1.5,2,3), (4,5,6)])</p><p class="source-code">mat_tuple = np.array(tuple_2D)</p><p class="source-code">print (mat_tuple)</p><p>The output is as follows:</p><p class="source-code">[[1.5 2.  3. ]</p><p class="source-code"> [4.  5.  6. ]]</p></li>
			</ol>
			<p>Thus, we have created multi-dimensional arrays using Python lists and tuples.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/30RjJcc">https://packt.live/30RjJcc</a>. </p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/30QiIBm">https://packt.live/30QiIBm</a>.</p>
			<p>Now, let's determine the dimension, shape, size, and data type of the two-dimensional array. </p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor091"/>Exercise 3.07: The Dimension, Shape, Size, and Data Type of Two-dimensional Arrays</h2>
			<p>This exercise will demonstrate a few methods that will let you check the dimension, shape, and size of the array. </p>
			<p class="callout-heading">Note </p>
			<p class="callout">The <strong class="source-inline">numbers2.csv</strong> file can be found at <a href="https://packt.live/2V8EQTZ">https://packt.live/2V8EQTZ</a>.</p>
			<p>Note that if it's a <strong class="source-inline">3x2</strong> matrix, that is, it has <strong class="source-inline">3</strong> rows and <strong class="source-inline">2</strong> columns, then the shape will be (<strong class="source-inline">3,2</strong>), but the size will be <strong class="source-inline">6</strong>, as in <strong class="source-inline">6 = 3x2</strong>. To learn how to find out the dimensions of an  array in Python, let's go through the following steps:</p>
			<ol>
				<li value="1">Import the necessary Python modules and load the <strong class="source-inline">numbers2.csv</strong> file:<p class="source-code">import pandas as pd</p><p class="source-code">import numpy as np</p><p class="source-code">df = pd.read_csv("<strong class="bold">../datasets/numbers2.csv</strong>",\</p><p class="source-code">                 header=None) </p><p class="source-code">list_2D = df.values</p><p class="source-code">mat1 = np.array(list_2D)</p><p class="callout-heading">Note</p><p class="callout">Don't forget to change the path (highlighted) based on the location of the file on your system.</p></li>
				<li>Print the dimension of the matrix using the <strong class="source-inline">ndim</strong> function:<p class="source-code">print("Dimension of this matrix: ", mat1.ndim,sep='')</p><p>The output is as follows:</p><p class="source-code">Dimension of this matrix: 2</p></li>
				<li>Print the size using the <strong class="source-inline">size</strong> function:<p class="source-code">print("Size of this matrix: ", mat1.size,sep='')</p><p>The output is as follows:</p><p class="source-code">Size of this matrix: 9</p></li>
				<li>Print the shape of the matrix using the <strong class="source-inline">shape</strong> function:<p class="source-code">print("Shape of this matrix: ", mat1.shape,sep='')</p><p>The output is as follows:</p><p class="source-code">Shape of this matrix: (3, 3)</p></li>
				<li>Print the dimension type using the <strong class="source-inline">dtype</strong> function:<p class="source-code">print("Data type of this matrix: ", mat1.dtype,sep='')</p><p>The output is as follows:</p><p class="source-code">Data type of this matrix: int64</p></li>
			</ol>
			<p>In this exercise, we looked at the various utility methods available in order to check the dimensions of an array. We used the <strong class="source-inline">dnim</strong>, <strong class="source-inline">shape</strong>, <strong class="source-inline">dtype</strong>, and <strong class="source-inline">size</strong> functions to look at the dimension of the array.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/30PVEm1">https://packt.live/30PVEm1</a>. </p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3ebSsoG">https://packt.live/3ebSsoG</a>.</p>
			<p>Now that we are familiar with basic vector (one-dimensional) and matrix data structures in NumPy, we will be able to create special matrices with ease. Often, you may have to create matrices filled with zeros, ones, random numbers, or ones in a diagonal fashion. An identity matrix is a matrix filled with zeros and ones in a diagonal from left to right.</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor092"/>Exercise 3.08: Zeros, Ones, Random, Identity Matrices, and Vectors</h2>
			<p>In this exercise, we will be creating a vector of zeros and a matrix of zeros using the <strong class="source-inline">zeros</strong> function of the <strong class="source-inline">NumPy</strong> library. Then, we'll create a matrix of fives using the <strong class="source-inline">ones</strong> function, followed by generating an identity matrix using the <strong class="source-inline">eye</strong> function. We will also work with the <strong class="source-inline">random</strong> function, where we'll create a matrix filled with random values. To do this, let's go through the following steps: </p>
			<ol>
				<li value="1">Print the vector of zeros by using the following command:<p class="source-code">import numpy as np</p><p class="source-code">print("Vector of zeros: ",np.zeros(5))</p><p>The output is as follows:</p><p class="source-code">Vector of zeros:  [0. 0. 0. 0. 0.]</p></li>
				<li>Print the matrix of zeros by using the following command:<p class="source-code">print("Matrix of zeros: ",np.zeros((3,4)))</p><p>The output is as follows:</p><p class="source-code">Matrix of zeros:  [[0. 0. 0. 0.]</p><p class="source-code"> [0. 0. 0. 0.]</p><p class="source-code"> [0. 0. 0. 0.]]</p></li>
				<li>Print the matrix of fives by using the following command:<p class="source-code">print("Matrix of 5's: ",5*np.ones((3,3)))</p><p>The output is as follows:</p><p class="source-code">Matrix of 5's:  [[5. 5. 5.]</p><p class="source-code"> [5. 5. 5.]</p><p class="source-code"> [5. 5. 5.]]</p></li>
				<li>Print an identity matrix by using the following command:<p class="source-code">print("Identity matrix of dimension 2:",np.eye(2))</p><p>The output is as follows:</p><p class="source-code">Identity matrix of dimension 2: [[1. 0.]</p><p class="source-code"> [0. 1.]]</p></li>
				<li>Print an identity matrix with a dimension of <strong class="source-inline">4x4</strong> by using the following command:<p class="source-code">print("Identity matrix of dimension 4:",np.eye(4))</p><p>The output is as follows:</p><p class="source-code">Identity matrix of dimension 4: [[1. 0. 0. 0.]</p><p class="source-code"> [0. 1. 0. 0.]</p><p class="source-code"> [0. 0. 1. 0.]</p><p class="source-code"> [0. 0. 0. 1.]]</p></li>
				<li>Print a matrix of random shape using the <strong class="source-inline">randint</strong> function:<p class="source-code">print("Random matrix of shape(4,3):\n",\</p><p class="source-code">      np.random.randint(low=1,high=10,size=(4,3)))</p><p>The sample output is as follows:</p><p class="source-code">Random matrix of shape (4,3):</p><p class="source-code"> [[6 7 6]</p><p class="source-code"> [5 6 7]</p><p class="source-code"> [5 3 6]</p><p class="source-code"> [2 9 4]]</p></li>
			</ol>
			<p>As we can see from the preceding output, a matrix was generated with a random shape. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">When creating matrices, you need to pass on tuples of integers as arguments. The output is susceptible to change since we have used random numbers.</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2UROs5f">https://packt.live/2UROs5f</a>. </p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/37J5hV9">https://packt.live/37J5hV9</a>.</p>
			<p>Random number generation is a very useful utility and needs to be mastered for data science/data wrangling tasks. We will look at the topic of random variables and distributions again in the section on statistics and learn how NumPy and pandas have built-in random number and series generation, as well as manipulation functions.</p>
			<p><strong class="bold">Reshaping</strong> an array is a very useful operation for vectors as machine learning algorithms may demand input vectors in various formats for mathematical manipulation. In this section, we will be looking at how reshaping can be done on an array. The opposite of <strong class="source-inline">reshape</strong> is the <strong class="source-inline">ravel</strong> function, which flattens any given array into a one-dimensional array. It is a very useful action in many machine learning and data analytics tasks.</p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor093"/>Exercise 3.09: Reshaping, Ravel, Min, Max, and Sorting</h2>
			<p>In this exercise, we will generate a random one-dimensional vector of two-digit numbers and then reshape the vector into multi-dimensional vectors. Let's go through the following steps:</p>
			<ol>
				<li value="1">Create an array of <strong class="source-inline">30</strong> random integers (sampled from <strong class="source-inline">1</strong> to <strong class="source-inline">99</strong>) and reshape it into two different forms using the following code:<p class="source-code">import numpy as np</p><p class="source-code">a = np.random.randint(1,100,30)</p><p class="source-code">b = a.reshape(2,3,5)</p><p class="source-code">c = a.reshape(6,5)</p></li>
				<li>Print the shape using the <strong class="source-inline">shape</strong> function by using the following code:<p class="source-code">print ("Shape of a:", a.shape)</p><p class="source-code">print ("Shape of b:", b.shape)</p><p class="source-code">print ("Shape of c:", c.shape)</p><p>The output is as follows:</p><p class="source-code">Shape of a: (30,)</p><p class="source-code">Shape of b: (2, 3, 5)</p><p class="source-code">Shape of c: (6, 5)</p></li>
				<li>Print the arrays <strong class="source-inline">a</strong>, <strong class="source-inline">b</strong>, and <strong class="source-inline">c</strong> using the following code:<p class="source-code">print("\na looks like\n",a)</p><p class="source-code">print("\nb looks like\n",b)</p><p class="source-code">print("\nc looks like\n",c)</p><p>The sample output is as follows:</p><p class="source-code">a looks like</p><p class="source-code"> [ 7 82  9 29 50 50 71 65 33 84 55 78 40 68 50 15 65 55 98 </p><p class="source-code"> 38 23 75 50 57 32 69 34 59 98 48]</p><p class="source-code">b looks like</p><p class="source-code"> [[[ 7 82  9 29 50]</p><p class="source-code">  [50 71 65 33 84]</p><p class="source-code">  [55 78 40 68 50]]</p><p class="source-code"> [[15 65 55 98 38]</p><p class="source-code">  [23 75 50 57 32]</p><p class="source-code">  [69 34 59 98 48]]]</p><p class="source-code">c looks like</p><p class="source-code"> [[ 7 82  9 29 50]</p><p class="source-code"> [50 71 65 33 84]</p><p class="source-code"> [55 78 40 68 50]</p><p class="source-code"> [15 65 55 98 38]</p><p class="source-code"> [23 75 50 57 32]</p><p class="source-code"> [69 34 59 98 48]]</p><p class="callout-heading">Note</p><p class="callout"><strong class="source-inline">b</strong> is a three-dimensional array – a kind of list of a list of a list. The output is susceptible to change since we have used random numbers.</p></li>
				<li>Ravel file <strong class="source-inline">b</strong> using the following code:<p class="source-code">b_flat = b.ravel()</p><p class="source-code">print(b_flat)</p><p>The sample output is as follows (the output may be different in each iteration):</p><p class="source-code">[ 7 82  9 29 50 50 71 65 33 84 55 78 40 68 50 15 65 55 98 38 </p><p class="source-code"> 23 75 50 57 32 69 34 59 98 48]</p><p class="callout-heading">Note</p><p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2Y6KYh8">https://packt.live/2Y6KYh8</a>. </p><p class="callout">You can also run this example online at <a href="https://packt.live/2N4fDFs">https://packt.live/2N4fDFs</a>.</p></li>
			</ol>
			<p>In this exercise, you learned how to use <strong class="source-inline">shape</strong> and <strong class="source-inline">reshape</strong> functions to see and adjust the dimensions of an array. This can be useful in a variety of cases when working with arrays.</p>
			<p>Indexing and slicing NumPy arrays is very similar to regular list indexing. We can even go through a vector of elements with a definite step size by providing it as an additional argument in the format (start, step, end). Furthermore, we can pass a list as an argument to select specific elements.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In multi-dimensional arrays, you can use two numbers to denote the position of an element. For example, if the element is in the third row and second column, its indices are 2 and 1 (because of Python's zero-based indexing).</p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor094"/>Exercise 3.10: Indexing and Slicing</h2>
			<p>In this exercise, we will learn how to perform indexing and slicing on one-dimensional and multi-dimensional arrays. To complete this exercise, let's go through the following steps:</p>
			<ol>
				<li value="1">Create an array of <strong class="source-inline">10</strong> elements and examine its various elements by slicing and indexing the array with slightly different syntaxes. Do this by using the following command:<p class="source-code">import numpy as np</p><p class="source-code">array_1 = np.arange(0,11)</p><p class="source-code">print("Array:",array_1)</p><p>The output is as follows:</p><p class="source-code">Array: [ 0  1  2  3  4  5  6  7  8  9 10]</p></li>
				<li>Print the element in the seventh position by using the following command:<p class="source-code">print("Element at 7th index is:", array_1[7])</p><p>The output is as follows:</p><p class="source-code">Element at 7th index is: 7</p></li>
				<li>Print the elements between the third and sixth positions by using the following command:<p class="source-code">print("Elements from 3rd to 5th index are:", array_1[3:6])</p><p>The output is as follows:</p><p class="source-code">Elements from 3rd to 5th index are: [3 4 5]</p></li>
				<li>Print the elements until the fourth position by using the following command:<p class="source-code">print("Elements up to 4th index are:", array_1[:4])</p><p>The output is as follows:</p><p class="source-code">Elements up to 4th index are: [0 1 2 3]</p></li>
				<li>Print the elements backward by using the following command:<p class="source-code">print("Elements from last backwards are:", array_1[-1::-1])</p><p>The output is as follows:</p><p class="source-code">Elements from last backwards are: [10  9  8  7  6  5  4  3  2  1  0]</p></li>
				<li>Print the elements using their backward index, skipping three values, by using the following command:<p class="source-code">print("3 Elements from last backwards are:", array_1[-1:-6:-2])</p><p>The output is as follows:</p><p class="source-code">3 Elements from last backwards are: [10  8  6]</p></li>
				<li>Create a new array called <strong class="source-inline">array_2</strong> by using the following command:<p class="source-code">array_2 = np.arange(0,21,2)</p><p class="source-code">print("New array:",array_2)</p><p>The output is as follows:</p><p class="source-code">New array: [ 0  2  4  6  8 10 12 14 16 18 20]</p></li>
				<li>Print the second, fourth, and ninth elements of the array:<p class="source-code">print("Elements at 2nd, 4th, and 9th index are:", \</p><p class="source-code">      array_2[[2,4,9]])</p><p>The output is as follows:</p><p class="source-code">Elements at 2nd, 4th, and 9th index are: [ 4  8 18]</p></li>
				<li>Create a multi-dimensional array by using the following command:<p class="source-code">matrix_1 = np.random.randint(10,100,15).reshape(3,5)</p><p class="source-code">print("Matrix of random 2-digit numbers\n ",matrix_1)</p><p>The sample output is as follows:</p><p class="source-code">Matrix of random 2-digit numbers</p><p class="source-code">  [[21 57 60 24 15]</p><p class="source-code"> [53 20 44 72 68]</p><p class="source-code"> [39 12 99 99 33]]</p><p class="callout-heading">Note</p><p class="callout">The output is susceptible to change since we have used random numbers.</p></li>
				<li>Access the values using double bracket indexing by using the following command:<p class="source-code">print("\nDouble bracket indexing\n")</p><p class="source-code">print("Element in row index 1 and column index 2:", \</p><p class="source-code">      matrix_1[1][2])</p><p>The sample output is as follows:</p><p class="source-code">Double bracket indexing</p><p class="source-code">Element in row index 1 and column index 2: 44</p></li>
				<li>Access the values using single bracket indexing by using the following command:<p class="source-code">print("\nSingle bracket with comma indexing\n")</p><p class="source-code">print("Element in row index 1 and column index 2:", \</p><p class="source-code">      matrix_1[1,2])</p><p>The sample output is as follows:</p><p class="source-code">Single bracket with comma indexing</p><p class="source-code">Element in row index 1 and column index 2: 44</p></li>
				<li>Access the values in a multi-dimensional array using a row or column by using the following command:<p class="source-code">print("\nRow or column extract\n")</p><p class="source-code">print("Entire row at index 2:", matrix_1[2])</p><p class="source-code">print("Entire column at index 3:", matrix_1[:,3])</p><p>The sample output is as follows:</p><p class="source-code">Row or column extract</p><p class="source-code">Entire row at index 2: [39 12 99 99 33]</p><p class="source-code">Entire column at index 3: [24 72 99]</p></li>
				<li>Print the matrix with the specified row and column indices by using the following command:<p class="source-code">print("\nSubsetting sub-matrices\n")</p><p class="source-code">print("Matrix with row indices 1 and 2 and column "\</p><p class="source-code">      "indices 3 and 4\n", matrix_1[1:3,3:5])</p><p>The sample output is as follows:</p><p class="source-code">Subsetting sub-matrices</p><p class="source-code">Matrix with row indices 1 and 2 and column indices 3 and 4</p><p class="source-code"> [[72 68]</p><p class="source-code"> [99 33]]</p></li>
				<li>Print the matrix with the specified row and column indices by using the following command:<p class="source-code">print("Matrix with row indices 0 and 1 and column "\</p><p class="source-code">      "indices 1 and 3\n", matrix_1[0:2,[1,3]])</p><p>The sample output is as follows:</p><p class="source-code">Matrix with row indices 0 and 1 and column indices 1 and 3</p><p class="source-code"> [[57 24]</p><p class="source-code"> [20 72]]</p><p class="callout-heading">Note</p><p class="callout">The output is susceptible to change since we have used random numbers.</p><p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/3fsxJ00">https://packt.live/3fsxJ00</a>. </p><p class="callout">You can also run this example online at <a href="https://packt.live/3hEDYjh">https://packt.live/3hEDYjh</a>.</p></li>
			</ol>
			<p>In this exercise, we worked with <strong class="source-inline">NumPy</strong> arrays and various ways of subletting them, such as slicing them. When working with arrays, it's very common to deal with them in this way. </p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor095"/>Conditional SubSetting</h2>
			<p><strong class="bold">Conditional subsetting</strong> is a way to select specific elements based on some numeric condition. It is almost like a shortened version of a SQL query to subset elements. See the following example:</p>
			<p class="source-code">matrix_1 = np.array(np.random.randint(10,100,15)).reshape(3,5)</p>
			<p class="source-code">print("Matrix of random 2-digit numbers\n",matrix_1)</p>
			<p class="source-code">print ("\nElements greater than 50\n", matrix_1[matrix_1&gt;50])</p>
			<p>In the preceding code example, we have created an array with 15 random values between <strong class="source-inline">10-100</strong>. We have applied the <strong class="source-inline">reshape</strong> function. Then, we selected the elements that are less than <strong class="source-inline">50</strong>.</p>
			<p>The sample output is as follows (note that the exact output will be different for you as it is random):</p>
			<p class="source-code">Matrix of random 2-digit numbers</p>
			<p class="source-code"> [[71 89 66 99 54]</p>
			<p class="source-code"> [28 17 66 35 85]</p>
			<p class="source-code"> [82 35 38 15 47]]</p>
			<p class="source-code">Elements greater than 50</p>
			<p class="source-code"> [71 89 66 99 54 66 85 82]</p>
			<p>NumPy arrays operate just like mathematical matrices, and the operations are performed element-wise.</p>
			<p>Now, let's look at an exercise to understand how we can perform array operations. </p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor096"/>Exercise 3.11: Array Operations </h2>
			<p>In this exercise, we're going to create two matrices (multi-dimensional arrays) with random integers and demonstrate element-wise mathematical operations such as addition, subtraction, multiplication, and division. We can show the exponentiation (raising a number to a certain power) operation by performing the following steps:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Due to random number generation, your specific output could be different than what is shown here.</p>
			<ol>
				<li value="1">Import the <strong class="source-inline">NumPy</strong> library and create two matrices:<p class="source-code">import numpy as np</p><p class="source-code">matrix_1 = np.random.randint(1,10,9).reshape(3,3)</p><p class="source-code">matrix_2 = np.random.randint(1,10,9).reshape(3,3)</p><p class="source-code">print("\n1st Matrix of random single-digit numbers\n",\</p><p class="source-code">      matrix_1)</p><p class="source-code">print("\n2nd Matrix of random single-digit numbers\n",\</p><p class="source-code">      matrix_2)</p><p>The sample output is as follows (note that the exact output will be different for you as it is random):</p><p class="source-code">1st Matrix of random single-digit numbers</p><p class="source-code"> [[6 5 9]</p><p class="source-code"> [4 7 1]</p><p class="source-code"> [3 2 7]]</p><p class="source-code">2nd Matrix of random single-digit numbers</p><p class="source-code"> [[2 3 1]</p><p class="source-code"> [9 9 9]</p><p class="source-code"> [9 9 6]]</p></li>
				<li>Perform addition, subtraction, division, and linear combination on the matrices:<p class="source-code">print("\nAddition\n", matrix_1+matrix_2)</p><p class="source-code">print("\nMultiplication\n", matrix_1*matrix_2)</p><p class="source-code">print("\nDivision\n", matrix_1/matrix_2)</p><p class="source-code">print("\nLinear combination: 3*A - 2*B\n", \</p><p class="source-code">      3*matrix_1-2*matrix_2)</p><p>The sample output is as follows (note that the exact output will be different for you as it is random):</p><p class="source-code">Addition</p><p class="source-code"> [[ 8  8 10]</p><p class="source-code"> [13 16 10]</p><p class="source-code"> [12 11 13]] </p><p class="source-code">Multiplication</p><p class="source-code"> [[12 15  9]</p><p class="source-code"> [36 63  9]</p><p class="source-code"> [27 18 42]]</p><p class="source-code">Division</p><p class="source-code"> [[3.       1.66666667 9.     ]</p><p class="source-code"> [0.44444444 0.77777778 0.11111111]</p><p class="source-code"> [0.33333333 0.22222222 1.16666667]]</p><p class="source-code">Linear combination: 3*A - 2*B</p><p class="source-code"> [[ 14    9  25]</p><p class="source-code"> [ -6    3 -15]</p><p class="source-code"> [ -9 -12    9]]</p></li>
				<li>Perform the addition of a scalar, exponential matrix cube, and exponential square root:<p class="source-code">print("\nAddition of a scalar (100)\n", 100+matrix_1)</p><p class="source-code">print("\nExponentiation, matrix cubed here\n", matrix_1**3)</p><p class="source-code">print("\nExponentiation, square root using 'pow' function\n", \</p><p class="source-code">      pow(matrix_1,0.5))</p><p>The sample output is as follows (note that the exact output will be different for you as it is random):</p><p class="source-code">Addition of a scalar (100)</p><p class="source-code"> [[106 105 109]</p><p class="source-code"> [104 107 101]</p><p class="source-code"> [103 102 107]]</p><p class="source-code">Exponentiation, matrix cubed here</p><p class="source-code"> [[216 125 729]</p><p class="source-code"> [ 64 343    1]</p><p class="source-code"> [ 27    8 343]]</p><p class="source-code">Exponentiation, square root using 'pow' function</p><p class="source-code"> [[2.44948974 2.23606798 3.     ]</p><p class="source-code"> [2.      2.64575131 1.     ]</p><p class="source-code"> [1.73205081 1.41421356 2.64575131]]</p><p class="callout-heading">Note</p><p class="callout">The output is susceptible to change since we have used random numbers.</p><p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/3fC1ziH">https://packt.live/3fC1ziH</a>. </p><p class="callout">You can also run this example online at <a href="https://packt.live/3fy6j96">https://packt.live/3fy6j96</a>.</p></li>
			</ol>
			<p>We have now seen how to work with arrays to perform various mathematical functions, such as scalar addition and matrix cubing. </p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor097"/>Stacking Arrays</h2>
			<p>Stacking arrays on top of each other (or side by side) is a useful operation for data wrangling. Stacking is a way to concatenate two NumPy arrays together. Here is the code:</p>
			<p class="source-code">a = np.array([[1,2],[3,4]])</p>
			<p class="source-code">b = np.array([[5,6],[7,8]])</p>
			<p class="source-code">print("Matrix a\n",a)</p>
			<p class="source-code">print("Matrix b\n",b)</p>
			<p class="source-code">print("Vertical stacking\n",np.vstack((a,b)))</p>
			<p class="source-code">print("Horizontal stacking\n",np.hstack((a,b)))</p>
			<p>The output is as follows:</p>
			<p class="source-code">Matrix a</p>
			<p class="source-code"> [[1 2]</p>
			<p class="source-code"> [3 4]]</p>
			<p class="source-code">Matrix b</p>
			<p class="source-code"> [[5 6]</p>
			<p class="source-code"> [7 8]]</p>
			<p class="source-code">Vertical stacking</p>
			<p class="source-code"> [[1 2]</p>
			<p class="source-code"> [3 4]</p>
			<p class="source-code"> [5 6]</p>
			<p class="source-code"> [7 8]]</p>
			<p class="source-code">Horizontal stacking</p>
			<p class="source-code"> [[1 2 5 6]</p>
			<p class="source-code"> [3 4 7 8]]</p>
			<p><strong class="source-inline">NumPy</strong> has many other advanced features, mainly related to statistics and linear algebra functions, which are used extensively in machine learning and data science tasks. However, not all of that is directly useful for beginner-level data wrangling, so we won't cover it here.</p>
			<p>In the next section, we'll talk about pandas DataFrames. </p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor098"/>Pandas DataFrames</h2>
			<p>The <strong class="source-inline">pandas</strong> library is a Python package that provides fast, flexible, and expressive data structures that are designed to make working with relational or labeled data both easy and intuitive. It aims to be the fundamental high-level building block for doing practical, real-world data analysis in Python. Additionally, it has the broader goal of becoming the most powerful and flexible open source data analysis/manipulation tool that's available in any language.</p>
			<p>The two primary data structures of pandas are Series (one-dimensional) and DataFrames (two-dimensional) and they handle the vast majority of typical use cases. <strong class="source-inline">pandas</strong> is built on top of <strong class="source-inline">NumPy</strong> and is intended to integrate well within a scientific computing environment with many other third-party libraries.</p>
			<p>Let's look at a few exercises in order to understand data handling techniques using the <strong class="source-inline">pandas</strong> library.</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor099"/>Exercise 3.12: Creating a Pandas Series</h2>
			<p>In this exercise, we will learn how to create a <strong class="source-inline">pandas</strong> series object from the data structures that we created previously. If you have imported pandas as pd, then the function to create a series is simply <strong class="source-inline">pd.Series</strong>. Let's go through the following steps:</p>
			<ol>
				<li value="1">Import the <strong class="source-inline">NumPy</strong> library and initialize the labels, lists, and a dictionary:<p class="source-code">import numpy as np</p><p class="source-code">labels = ['a','b','c']</p><p class="source-code">my_data = [10,20,30]</p><p class="source-code">array_1 = np.array(my_data)</p><p class="source-code">d = {'a':10,'b':20,'c':30}</p></li>
				<li>Import <strong class="source-inline">pandas</strong> as <strong class="source-inline">pd</strong> by using the following command:<p class="source-code">import pandas as pd</p></li>
				<li>Create a series from the <strong class="source-inline">my_data</strong> list by using the following command:<p class="source-code">print("\nHolding numerical data\n",'-'*25, sep='')</p><p class="source-code">print(pd.Series(array_1))</p><p>The output is as follows:</p><p class="source-code">Holding numerical data</p><p class="source-code">-------------------------</p><p class="source-code">0  10</p><p class="source-code">1  20</p><p class="source-code">2  30</p><p class="source-code">dtype: int64</p></li>
				<li>Create a series from the <strong class="source-inline">my_data</strong> list along with the labels as follows:<p class="source-code">print("\nHolding text labels\n",'-'*20, sep='')</p><p class="source-code">print(pd.Series(labels))</p><p>The output is as follows:</p><p class="source-code">Holding text labels</p><p class="source-code">--------------------</p><p class="source-code">0     a</p><p class="source-code">1     b</p><p class="source-code">2     c</p><p class="source-code">dtype: object</p></li>
				<li>Then, create a series from the <strong class="source-inline">NumPy</strong> array, as follows:<p class="source-code">print("\nHolding functions\n",'-'*20, sep='')</p><p class="source-code">print(pd.Series(data=[sum,print,len]))</p><p>The output is as follows:</p><p class="source-code">Holding functions</p><p class="source-code">--------------------</p><p class="source-code">0     &lt;built-in function sum&gt;</p><p class="source-code">1     &lt;built-in function print&gt;</p><p class="source-code">2     &lt;built-in function len&gt;</p><p class="source-code">dtype: object</p></li>
				<li>Create a series from the dictionary, as follows:<p class="source-code">print("\nHolding objects from a dictionary\n",'-'*40, sep='')</p><p class="source-code">print(pd.Series(data=[d.keys, d.items, d.values]))</p><p>The output is as follows:</p><p class="source-code">Holding objects from a dictionary</p><p class="source-code">----------------------------------------</p><p class="source-code">0     &lt;built-in method keys of dict object at 0x7fb8...</p><p class="source-code">1     &lt;built-in method items of dict object at 0x7fb...</p><p class="source-code">2     &lt;built-in method values of dict object at 0x7f...</p><p class="source-code">dtype: object</p><p class="callout-heading">Note</p><p class="callout">You may get a different final output because the system may store the object in the memory differently.</p><p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2BkMJOL">https://packt.live/2BkMJOL</a>.</p><p class="callout">You can also run this example online at <a href="https://packt.live/30XhxzQ">https://packt.live/30XhxzQ</a>.</p></li>
			</ol>
			<p>In this exercise, we created <strong class="source-inline">pandas</strong> series, which are the building blocks of <strong class="source-inline">pandas</strong> DataFrames. The <strong class="source-inline">pandas</strong> <strong class="source-inline">series</strong> object can hold many types of data, such as integers, objects, floats, doubles, and others. This is the key to constructing a bigger table where multiple series objects are stacked together to create a database-like entity.</p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor100"/>Exercise 3.13: Pandas Series and Data Handling</h2>
			<p>In this exercise, we will create a <strong class="source-inline">pandas</strong> series using the <strong class="source-inline">pd.series</strong> function. Then, we will manipulate the data in the DataFrame using various handling techniques. Perform the following steps:</p>
			<ol>
				<li value="1">Create a <strong class="source-inline">pandas</strong> series with numerical data by using the following command:<p class="source-code">import numpy as np</p><p class="source-code">import pandas as pd</p><p class="source-code">labels = ['a','b','c'] </p><p class="source-code">my_data = [10,20,30] </p><p class="source-code">array_1 = np.array(my_data)</p><p class="source-code">d = {'a':10,'b':20,'c':30} </p><p class="source-code">print("\nHolding numerical data\n",'-'*25, sep='')</p><p class="source-code">print(pd.Series(array_1))</p><p>The output is as follows:</p><p class="source-code">Holding numerical data</p><p class="source-code">-------------------------</p><p class="source-code">0     10</p><p class="source-code">1     20</p><p class="source-code">2     30</p><p class="source-code">dtype: int32</p></li>
				<li>Create a <strong class="source-inline">pandas</strong> series with labels by using the following command:<p class="source-code">print("\nHolding text labels\n",'-'*20, sep='')</p><p class="source-code">print(pd.Series(labels))</p><p>The output is as follows:</p><p class="source-code">Holding text labels</p><p class="source-code">--------------------</p><p class="source-code">0     a</p><p class="source-code">1     b</p><p class="source-code">2     c</p><p class="source-code">dtype: object</p></li>
				<li>Create a <strong class="source-inline">pandas</strong> series with functions by using the following command:<p class="source-code">print("\nHolding functions\n",'-'*20, sep='')</p><p class="source-code">print(pd.Series(data=[sum,print,len]))</p><p>The output is as follows:</p><p class="source-code">Holding functions</p><p class="source-code">--------------------</p><p class="source-code">0     &lt;built-in function sum&gt;</p><p class="source-code">1     &lt;built-in function print&gt;</p><p class="source-code">2     &lt;built-in function len&gt;</p><p class="source-code">dtype: object</p></li>
				<li>Create a <strong class="source-inline">pandas</strong> series with a dictionary by using the following command:<p class="source-code">print("\nHolding objects from a dictionary\n",'-'*40, sep='')</p><p class="source-code">print(pd.Series(data=[d.keys, d.items, d.values]))</p><p>The output is as follows:</p><p class="source-code">Holding objects from a dictionary</p><p class="source-code">----------------------------------------</p><p class="source-code">0     &lt;built-in method keys of dict object at 0x0000...</p><p class="source-code">1     &lt;built-in method items of dict object at 0x000...</p><p class="source-code">2     &lt;built-in method values of dict object at 0x00...</p><p class="source-code">dtype: object</p><p class="callout-heading">Note</p><p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/3hzXRIr">https://packt.live/3hzXRIr</a>. </p><p class="callout">You can also run this example online at <a href="https://packt.live/3endeC9">https://packt.live/3endeC9</a>.</p></li>
			</ol>
			<p>In this exercise, we created pandas <strong class="source-inline">series</strong> objects using various types of lists.</p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor101"/>Exercise 3.14: Creating Pandas DataFrames</h2>
			<p>The <strong class="source-inline">pandas</strong> DataFrame is similar to an Excel table or relational database (SQL) table, which consists of three main components: the data, the index (or rows), and the columns. Under the hood, it is a stack of <strong class="source-inline">pandas</strong> series objects, which are themselves built on top of <strong class="source-inline">NumPy</strong> arrays. So, all of our previous knowledge of NumPy arrays applies here. Let's perform the following steps:</p>
			<ol>
				<li value="1">Create a simple DataFrame from a two-dimensional matrix of numbers. First, the code draws <strong class="source-inline">20</strong> random integers from the uniform distribution. Then, we need to reshape it into a (<strong class="source-inline">5,4</strong>) NumPy array – <strong class="source-inline">5</strong> rows and <strong class="source-inline">4</strong> columns:<p class="source-code">import numpy as np</p><p class="source-code">import pandas as pd</p><p class="source-code">matrix_data = np.random.randint(1,10,size=20).reshape(5,4)</p></li>
				<li>Define the rows labels as (<strong class="source-inline">'A','B','C','D','E'</strong>) and column labels as (<strong class="source-inline">'W','X','Y','Z'</strong>):<p class="source-code">row_labels = ['A','B','C','D','E']</p><p class="source-code">column_headings = ['W','X','Y','Z']</p></li>
				<li>Create a DataFrame using <strong class="source-inline">pd.DataFrame</strong>:<p class="source-code">df = pd.DataFrame(data=matrix_data, index=row_labels, \</p><p class="source-code">                  columns=column_headings)</p></li>
				<li>Print the DataFrame:<p class="source-code">print("\nThe data frame looks like\n",'-'*45, sep='')</p><p class="source-code">print(df) </p><p>The sample output is as follows:</p><div id="_idContainer058" class="IMG---Figure"><img src="Images/B15780_03_06.jpg" alt="Figure 3.6: Output of the DataFrame&#13;&#10;" width="1120" height="321"/></div><p class="figure-caption">Figure 3.6: Output of the DataFrame</p></li>
				<li>Create a DataFrame from a Python dictionary of the lists of integers by using the following command:<p class="source-code">d={'a':[10,20],'b':[30,40],'c':[50,60]}</p></li>
				<li>Pass this dictionary as a data argument to the <strong class="source-inline">pd.DataFrame</strong> function. Pass on a list of rows or indices. Notice how the dictionary keys became the column names and that the values were distributed among multiple rows:<p class="source-code">df2=pd.DataFrame(data=d,index=['X','Y'])</p><p class="source-code">print(df2)</p><p>The output is as follows:</p><div id="_idContainer059" class="IMG---Figure"><img src="Images/B15780_03_07.jpg" alt="Figure 3.7: Output of DataFrame df2&#13;&#10;" width="1665" height="172"/></div></li>
			</ol>
			<p class="figure-caption">Figure 3.7: Output of DataFrame df2</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2UVTz4u">https://packt.live/2UVTz4u</a>. </p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/2CgBkAd">https://packt.live/2CgBkAd</a>.</p>
			<p>In this exercise, we created DataFrames manually from scratch, which will allow us to understand DataFrames better.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The most common way that you will create a pandas DataFrame will be to read tabular data from a file on your local disk or over the internet – CSV, text, JSON, HTML, Excel, and so on. We will cover some of these in the next chapter.</p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor102"/>Exercise 3.15: Viewing a DataFrame Partially</h2>
			<p>In the previous exercise, we used <strong class="source-inline">print(df)</strong> to print the whole DataFrame. For a large dataset, we would like to print only sections of data. In this exercise, we will read a part of the DataFrame. Let's learn how to do so:</p>
			<ol>
				<li value="1">Import the <strong class="source-inline">NumPy</strong> library and execute the following code to create a DataFrame with <strong class="source-inline">25</strong> rows. Then, fill it with random numbers:<p class="source-code"># 25 rows and 4 columns</p><p class="source-code">import numpy as np</p><p class="source-code">import pandas as pd</p><p class="source-code">matrix_data = np.random.randint(1,100,100).reshape(25,4)</p><p class="source-code">column_headings = ['W','X','Y','Z']</p><p class="source-code">df = pd.DataFrame(data=matrix_data,columns=column_headings)</p></li>
				<li>Run the following code to view only the first five rows of the DataFrame:<p class="source-code">df.head()</p><p>The sample output is as follows (note that your output could be different due to randomness):</p><div id="_idContainer060" class="IMG---Figure"><img src="Images/B15780_03_08.jpg" alt="Figure 3.8: The first five rows of the DataFrame&#13;&#10;" width="597" height="190"/></div><p class="figure-caption">Figure 3.8: The first five rows of the DataFrame</p><p>By default, <strong class="source-inline">head</strong> shows only five rows. If you want to see any specific number of rows, just pass that as an argument.</p></li>
				<li>Print the first eight rows by using the following command:<p class="source-code">df.head(8)</p><p>The sample output is as follows:</p><div id="_idContainer061" class="IMG---Figure"><img src="Images/B15780_03_09.jpg" alt="Figure 3.9: The first eight rows of the DataFrame&#13;&#10;" width="673" height="278"/></div><p class="figure-caption">Figure 3.9: The first eight rows of the DataFrame</p><p>Just like <strong class="source-inline">head</strong> shows the first few rows, <strong class="source-inline">tail</strong> shows the last few rows.</p></li>
				<li>Print the DataFrame using the <strong class="source-inline">tail</strong> command, as follows:<p class="source-code">df.tail(10)</p><p>The sample output (partially shown) is as follows:</p><div id="_idContainer062" class="IMG---Figure"><img src="Images/B15780_03_10.jpg" alt="Figure 3.10: The last 20 rows of the DataFrame&#13;&#10;" width="579" height="278"/></div></li>
			</ol>
			<p class="figure-caption">Figure 3.10: The last few rows of the DataFrame</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/30UiXLB">https://packt.live/30UiXLB</a>. </p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/2URYCTz">https://packt.live/2URYCTz</a>.</p>
			<p>In this section, we learned how to view portions of the DataFrame without looking at the whole DataFrame. In the next section, we're going to look at two functionalities: indexing and slicing columns in a DataFrame. </p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor103"/>Indexing and Slicing Columns</h2>
			<p>There are two methods for indexing and slicing columns in a DataFrame. They are as follows:</p>
			<ul>
				<li>The <strong class="source-inline">DOT</strong> method</li>
				<li>The <strong class="source-inline">bracket</strong> method</li>
			</ul>
			<p>The <strong class="bold">DOT</strong> method is good if you want to find a specific element. You will refer to the column after the DOT. An example is <strong class="source-inline">df.column</strong>. The bracket method is intuitive and easy to follow. In this method, you can access the data by the generic name/header of the column.</p>
			<p>The following code illustrates these concepts. We can execute them in our Jupyter Notebook:</p>
			<p class="source-code">print("\nThe 'X' column\n",'-'*25, sep='')</p>
			<p class="source-code">print(df['X'])</p>
			<p class="source-code">print("\nType of the column: ", type(df['X']), sep='')</p>
			<p class="source-code">print("\nThe 'X' and 'Z' columns indexed by passing a list\n",\</p>
			<p class="source-code">      '-'*55, sep='')</p>
			<p class="source-code">print(df[['X','Z']])</p>
			<p class="source-code">print("\nType of the pair of columns: ", \</p>
			<p class="source-code">      type(df[['X','Z']]), sep='')</p>
			<p>The output is as follows (a only the partial output is shown here because the actual column is long):</p>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<img src="Images/B15780_03_11.jpg" alt="Figure 3.11: Rows of the 'X' columns&#13;&#10;" width="524" height="204"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.11: Rows of the 'X' columns</p>
			<p>This is the output showing the type of column:</p>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="Images/B15780_03_12.jpg" alt="Figure 3.12: Type of 'X' column&#13;&#10;" width="1232" height="48"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.12: Type of 'X' column</p>
			<p>This is the output showing the X and Z column indexed by passing a list:</p>
			<div>
				<div id="_idContainer065" class="IMG---Figure">
					<img src="Images/B15780_03_13.jpg" alt="Figure 3.13: Rows of the 'Y' columns&#13;&#10;" width="580" height="226"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.13: Rows of the 'Y' columns</p>
			<p>This is the output showing the type of the pair of columns:</p>
			<div>
				<div id="_idContainer066" class="IMG---Figure">
					<img src="Images/B15780_03_14.jpg" alt="Figure 3.14: Type of 'Y' column&#13;&#10;" width="1295" height="55"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.14: Type of 'Y' column</p>
			<p class="callout-heading">Note</p>
			<p class="callout">For more than one column, the object turns into a DataFrame. But for a single column, it is a <strong class="source-inline">pandas</strong> series object.</p>
			<p>So far, we have seen how to access the columns of DataFrames using both the DOT method and the bracket method. Dataframes are commonly used for row/column data.</p>
			<p>Now, let's look at indexing and slicing rows. </p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor104"/>Indexing and Slicing Rows</h2>
			<p>Indexing and slicing rows in a DataFrame can also be done using the following methods:</p>
			<ul>
				<li>The label-based <strong class="source-inline">loc</strong> method</li>
				<li>The index-based <strong class="source-inline">iloc</strong> method</li>
			</ul>
			<p>The <strong class="source-inline">loc</strong> method is intuitive and easy to follow. In this method, you can access the data by the generic name of the row. On the other hand, the <strong class="source-inline">iloc</strong> method allows you to access the rows by their numerical index. This can be very useful for a large table with thousands of rows, especially when you want to iterate over the table in a loop with a numerical counter. The following code illustrates the concepts of <strong class="source-inline">iloc</strong>:</p>
			<p class="source-code">matrix_data = np.random.randint(1,10,size=20).reshape(5,4)</p>
			<p class="source-code">row_labels = ['A','B','C','D','E']</p>
			<p class="source-code">column_headings = ['W','X','Y','Z']</p>
			<p class="source-code">df = pd.DataFrame(data=matrix_data, index=row_labels, \</p>
			<p class="source-code">                  columns=column_headings)</p>
			<p class="source-code">print("\nLabel-based 'loc' method for selecting row(s)\n",\</p>
			<p class="source-code">      '-'*60, sep='')</p>
			<p class="source-code">print("\nSingle row\n")</p>
			<p class="source-code">print(df.loc['C'])</p>
			<p class="source-code">print("\nMultiple rows\n")</p>
			<p class="source-code">print(df.loc[['B','C']])</p>
			<p class="source-code">print("\nIndex position based 'iloc' method for selecting "\</p>
			<p class="source-code">      "row(s)\n", '-'*70, sep='')</p>
			<p class="source-code">print("\nSingle row\n")</p>
			<p class="source-code">print(df.iloc[2])</p>
			<p class="source-code">print("\nMultiple rows\n")</p>
			<p class="source-code">print(df.iloc[[1,2]])</p>
			<p>The sample output is as follows:</p>
			<div>
				<div id="_idContainer067" class="IMG---Figure">
					<img src="Images/B15780_03_15.jpg" alt="Figure 3.15: Output of the loc and iloc methods&#13;&#10;" width="771" height="704"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.15: Output of the loc and iloc methods</p>
			<p>One of the most common tasks in data wrangling is creating or deleting columns or rows of data from your DataFrame. Sometimes, you want to create a new column based on some mathematical operation or transformation involving the existing columns. This is similar to manipulating database records and inserting a new column based on simple transformations. We'll look at some of these concepts in the upcoming exercises.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor105"/>Exercise 3.16: Creating and Deleting a New Column or Row</h2>
			<p>In this exercise, we're going to create and delete a new column or a row from the <strong class="source-inline">stock.csv</strong> dataset. We'll also use the <strong class="source-inline">inplace</strong> function to modify the original DataFrame.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">stock.csv</strong> file can be found here: <a href="https://packt.live/3hxvPNP">https://packt.live/3hxvPNP</a>.</p>
			<p>Let's go through the following steps:</p>
			<ol>
				<li value="1">Import the necessary Python modules, load the <strong class="source-inline">stocks.csv</strong> file, and create a new column using the following snippet:<p class="source-code">import pandas as pd</p><p class="source-code">df = pd.read_csv("<strong class="bold">../datasets/stock.csv</strong>")</p><p class="source-code">df.head()</p><p class="source-code">print("\nA column is created by assigning it in relation\n",\</p><p class="source-code">      '-'*75, sep='')</p><p class="source-code">df['New'] = df['Price']+df['Price']</p><p class="source-code">df['New (Sum of X and Z)'] = df['New']+df['Price']</p><p class="source-code">print(df)</p><p class="callout-heading">Note</p><p class="callout">Don't forget to change the path (highlighted) based on the location of the file on your system.</p><p>The sample output (partially shown) is as follows:</p><div id="_idContainer068" class="IMG---Figure"><img src="Images/B15780_03_16.jpg" alt="Figure 3.16: Partial output of the DataFrame&#13;&#10;" width="897" height="630"/></div><p class="figure-caption">Figure 3.16: Partial output of the DataFrame</p></li>
				<li>Drop a column using the <strong class="source-inline">df.drop</strong> method:<p class="source-code">print("\nA column is dropped by using df.drop() method\n",\</p><p class="source-code">      '-'*55, sep='')</p><p class="source-code">df = df.drop('New', axis=1) # Notice the axis=1 option</p><p class="source-code"># axis = 0 is default, so one has to change it to 1</p><p class="source-code">print(df)</p><p>The sample output (partially shown) is as follows:</p><div id="_idContainer069" class="IMG---Figure"><img src="Images/B15780_03_17.jpg" alt="Figure 3.17: Partial output of the DataFrame&#13;&#10;" width="956" height="703"/></div><p class="figure-caption">Figure 3.17: Partial output of the DataFrame</p></li>
				<li>Drop a specific row using the <strong class="source-inline">df.drop</strong> method:<p class="source-code">df1=df.drop(1)</p><p class="source-code">print("\nA row is dropped by using df.drop method and axis=0\n",\</p><p class="source-code">      '-'*65, sep='')</p><p class="source-code">print(df1)</p><p>The partial output is as follows:</p><div id="_idContainer070" class="IMG---Figure"><img src="Images/B15780_03_18.jpg" alt="Figure 3.18: Partial output of the DataFrame&#13;&#10;" width="955" height="566"/></div><p class="figure-caption">Figure 3.18: Partial output of the DataFrame</p><p>Dropping methods creates a copy of the DataFrame and does not change the original DataFrame.</p></li>
				<li>Change the original DataFrame by setting the <strong class="source-inline">inplace</strong> argument to <strong class="source-inline">True</strong>:<p class="source-code">print("\nAn in-place change can be done by making ",\</p><p class="source-code">      "inplace=True in the drop method\n",\</p><p class="source-code">      '-'*75, sep='')</p><p class="source-code">df.drop('New (Sum of X and Z)', axis=1, inplace=True)</p><p class="source-code">print(df)</p><p>The sample output is as follows:</p><div id="_idContainer071" class="IMG---Figure"><img src="Images/B15780_03_19.jpg" alt="Figure 3.19: Partial Output of the DataFrame&#13;&#10;" width="1158" height="600"/></div></li>
			</ol>
			<p class="figure-caption">Figure 3.19: Partial Output of the DataFrame</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/3frxthU">https://packt.live/3frxthU</a>. </p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/2USxJyA">https://packt.live/2USxJyA</a>.</p>
			<p>We have now learned how to modify DataFrames by dropping or adding rows and columns. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">All the normal operations are not in-place, that is, they do not impact the original DataFrame object and return a copy of the original with addition (or deletion) instead. The last bit of the preceding code shows how to make a change in the existing DataFrame with the <strong class="source-inline">inplace=True</strong> argument. Please note that this change is irreversible and should be used with caution.</p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor106"/>Statistics and Visualization with NumPy and Pandas</h1>
			<p>One of the great advantages of using libraries such as NumPy and pandas is that a plethora of built-in statistical and visualization methods are available, for which we don't have to search for and write new code. Furthermore, most of these subroutines are written using C or Fortran code (and pre-compiled), making them extremely fast to execute.</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor107"/>Refresher on Basic Descriptive Statistics</h2>
			<p>For any data wrangling task, it is quite useful to extract basic descriptive statistics, which should describe the data in ways such as the mean, median, and mode and create some simple visualizations or plots. These plots are often the first step in identifying fundamental patterns as well as oddities (if present) in the data. In any statistical analysis, descriptive statistics is the first step, followed by inferential statistics, which tries to infer the underlying distribution or process that the data might have been generated from. You can imagine that descriptive statistics will inform us of the basic characteristics of the data, while inferential statistics will help us understand not only the data we are working with but alternative data that we might be experimenting with.</p>
			<p>Since inferential statistics is intimately coupled with the machine learning/predictive modeling stage of a data science pipeline, descriptive statistics naturally becomes associated with the data wrangling aspect.</p>
			<p>There are two broad approaches to descriptive statistical analysis:</p>
			<ul>
				<li><strong class="bold">Graphical techniques</strong>: Bar plots, scatter plots, line charts, box plots, histograms, and so on</li>
				<li><strong class="bold">The calculation of the central tendency and spread</strong>: Mean, median, mode, variance, standard deviation, range, and so on</li>
			</ul>
			<p>In this section, we will demonstrate how you can accomplish both of these tasks using Python. Apart from NumPy and pandas, we will need to learn the basics of another great package – <strong class="source-inline">matplotlib</strong> – which is the most powerful and versatile visualization library in Python.</p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor108"/>Exercise 3.17: Introduction to Matplotlib through a Scatter Plot</h2>
			<p>In this exercise, we will demonstrate the power and simplicity of matplotlib by creating a simple scatter plot from self-created data about the age, weight, and height of a few people. To do so, let's go through the following steps:</p>
			<ol>
				<li value="1">First, we will define simple lists of the names of people, along with their age, weight (in kgs), and height (in centimeters):<p class="source-code">people = ['Ann','Brandon','Chen','David','Emily',\</p><p class="source-code">          'Farook','Gagan','Hamish','Imran',\</p><p class="source-code">          'Joseph','Katherine','Lily']</p><p class="source-code">age = [21,12,32,45,37,18,28,52,5,40,48,15]</p><p class="source-code">weight = [55,35,77,68,70,60,72,69,18,65,82,48]</p><p class="source-code">height = [160,135,170,165,173,168,175,159,105,\</p><p class="source-code">          171,155,158]</p></li>
				<li>Import the most important module from <strong class="source-inline">matplotlib</strong>, called <strong class="source-inline">pyplot</strong>:<p class="source-code">import matplotlib.pyplot as plt</p></li>
				<li>Create simple scatter plots of <strong class="source-inline">age</strong> versus <strong class="source-inline">weight</strong>:<p class="source-code">plt.scatter(age,weight)</p><p class="source-code">plt.show()</p><p>The output is as follows:</p><div id="_idContainer072" class="IMG---Figure"><img src="Images/B15780_03_20.jpg" alt="Figure 3.20: A screenshot of a scatter plot containing age and weight&#13;&#10;" width="883" height="433"/></div><p class="figure-caption">Figure 3.20: A screenshot of a scatter plot containing age and weight</p><p>The preceding plot can be improved by enlarging the figure size, customizing the aspect ratio, adding a title with a proper font size, adding x-axis and y-axis labels with a customized font size, adding grid lines, changing the y-axis limit to be between <strong class="source-inline">0</strong> and <strong class="source-inline">100</strong>, adding x and y tick marks, customizing the scatter plot's color, and changing the size of the scatter dots.</p></li>
				<li>The code for the improved plot is as follows:<p class="source-code">plt.figure(figsize=(8,6))</p><p class="source-code">plt.title("Plot of Age vs. Weight (in kgs)",\</p><p class="source-code">          fontsize=20)</p><p class="source-code">plt.xlabel("Age (years)",fontsize=16)</p><p class="source-code">plt.ylabel("Weight (kgs)",fontsize=16)</p><p class="source-code">plt.grid (True)</p><p class="source-code">plt.ylim(0,100)</p><p class="source-code">plt.xticks([i*5 for i in range(12)],fontsize=15)</p><p class="source-code">plt.yticks(fontsize=15)</p><p class="source-code">plt.scatter(x=age,y=weight,c='orange',s=150,\</p><p class="source-code">            edgecolors='k')</p><p class="source-code">plt.text(x=20,y=85,s="Weights after 18-20 years of age",\</p><p class="source-code">         fontsize=15)</p><p class="source-code">plt.vlines(x=20,ymin=0,ymax=80,linestyles='dashed',\</p><p class="source-code">           color=›blue›,lw=3)</p><p class="source-code">plt.legend([‹Weight in kgs›],loc=2,fontsize=12)</p><p class="source-code">plt.show()</p><p>The output is as follows:</p><div id="_idContainer073" class="IMG---Figure"><img src="Images/B15780_03_21.jpg" alt="Figure 3.21: A screenshot of a scatter plot showing age versus weight&#13;&#10;" width="656" height="390"/></div></li>
			</ol>
			<p class="figure-caption">Figure 3.21: A screenshot of a scatter plot showing age versus weight</p>
			<p>We can observe the following things:</p>
			<ul>
				<li>A tuple (<strong class="source-inline">8,6</strong>) is passed as an argument for the figure size.</li>
				<li>A list comprehension is used inside <strong class="source-inline">xticks</strong> to create a customized list of 5-10-15-…-55.</li>
				<li>A newline (<strong class="source-inline">\n</strong>) character is used inside the <strong class="source-inline">plt.text()</strong> function to break up and distribute the text into two lines.</li>
				<li>The <strong class="source-inline">plt.show()</strong> function is used at the very end. The idea is to keep on adding various graphics properties (font, color, axis limits, text, legend, grid, and so on) until you are satisfied and then show the plot with one function. The plot will not be displayed without this last function call.</li>
			</ul>
			<p>The preceding plot is quite self-explanatory. We can observe that the variations in weight are reduced after <strong class="source-inline">18-20</strong> years of age.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/3hFzysK">https://packt.live/3hFzysK</a>. </p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3eauxWP">https://packt.live/3eauxWP</a>.</p>
			<p>In this exercise, we have gone through the basics of using <strong class="source-inline">matplotlib</strong>, a popular charting function. In the next section, we will look at the definition of statistical measures.</p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor109"/>The Definition of Statistical Measures – Central Tendency and Spread</h1>
			<p>A measure of central tendency is a single value that attempts to describe a set of data by identifying the central position within that set of data. They are also categorized as summary statistics:</p>
			<ul>
				<li><strong class="bold">Mean</strong>: The mean is the sum of all values divided by the total number of values.</li>
				<li><strong class="bold">Median</strong>: The median is the middle value. It is the value that splits the dataset in half. To find the median, order your data from smallest to largest, and then find the data point that has an equal amount of values above and below it.</li>
				<li><strong class="bold">Mode</strong>: The mode is the value that occurs the most frequently in your dataset. On a bar chart, the mode is the highest bar.</li>
			</ul>
			<p>Generally, the mean is a better measure to use for symmetric data while the median is a better measure for data with a skewed (left- or right-heavy) distribution. For categorical data, you have to use the mode:</p>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<img src="Images/B15780_03_22.jpg" alt="Figure 3.22: A screenshot of a curve showing the mean, median, and mode&#13;&#10;" width="1665" height="651"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.22: A screenshot of a curve showing the mean, median, and mode</p>
			<p>The spread of the data is a measure of by how much the values in the dataset are likely to differ from the mean of the values. If all the values are close together, then the spread is low; on the other hand, if some or all of the values differ by a large amount from the mean (and each other), then there is a large spread in the data:</p>
			<ul>
				<li><strong class="bold">Variance</strong>: This is the most common measure of spread. The variance is the average of the squares of the deviations from the mean. Squaring the deviations ensures that negative and positive deviations do not cancel each other out.</li>
				<li><strong class="bold">Standard deviation</strong>: Because variance is produced by squaring the distance from the mean, its unit does not match that of the original data. Standard deviation is a mathematical trick that brings back parity. It is the positive square root of the variance.</li>
			</ul>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor110"/>Random Variables and Probability Distribution</h2>
			<p>A random variable is defined as the value of a given variable that represents the outcome of a statistical experiment or process.</p>
			<p>Although it sounds very formal, pretty much everything around us that we can measure can be thought of as a random variable.</p>
			<p>The reason behind this is that almost all natural, social, biological, and physical processes are the final outcome of a large number of complex processes, and we cannot know the details of those fundamental processes. All we can do is observe and measure the final outcome. </p>
			<p>Typical examples of random variables that are around us are as follows:</p>
			<ul>
				<li>The economic output of a nation</li>
				<li>The blood pressure of a patient</li>
				<li>The temperature of a chemical process in a factory</li>
				<li>The number of friends of a person on Facebook</li>
				<li>The stock market price of a company</li>
			</ul>
			<p>These values can take any discrete or continuous value and follow a particular pattern (although this pattern may vary over time). Therefore, they can all be classified as random variables.</p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor111"/>What is a Probability Distribution?</h2>
			<p>A probability distribution is a mathematical function that tells you the likelihood of a random variable taking each different possible value. In other words, a probability distribution gives the probabilities of the different possible outcomes in a given situation.</p>
			<p>Suppose you go to a school and measure the heights of students who have been selected randomly. Height is an example of a random variable here. As you measure height, you can create a distribution of height. This type of distribution is useful when you need to know which outcomes are the most likely to occur (that is, which heights are the most common), the spread of potential values, and the likelihood of different results.</p>
			<p>The concepts of central tendency and spread are applicable to a distribution and are used to describe the properties and behavior of a distribution.</p>
			<p>Statisticians generally divide all distributions into two broad categories:</p>
			<ul>
				<li>Discrete distributions</li>
				<li>Continuous distributions</li>
			</ul>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor112"/>Discrete Distributions</h2>
			<p>Discrete probability functions, also known as probability mass functions, can assume a discrete number of values. For example, coin tosses and counts of events are discrete functions. You can only have heads or tails in a coin toss. Similarly, if you're counting the number of trains that arrive at a station per hour, you can count 11 or 12 trains, but nothing in between.</p>
			<p>Some prominent discrete distributions are as follows:</p>
			<ul>
				<li>Binomial distribution to model binary data, such as coin tosses</li>
				<li>Poisson distribution to model count data, such as the count of library book checkouts per hour</li>
				<li>Uniform distribution to model multiple events with the same probability, such as rolling a die</li>
			</ul>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor113"/>Continuous Distributions</h2>
			<p>Continuous probability functions are also known as probability density functions. You have a continuous distribution if the variable can assume an infinite number of values between any two values. Continuous variables are often measurements on a real number scale, such as height, weight, and temperature.</p>
			<p>The most well-known continuous distribution is normal distribution, which is also known as Gaussian distribution or the bell curve. This symmetric distribution fits a wide variety of phenomena, such as human height and IQ scores.</p>
			<p>Normal distribution is linked to the famous <strong class="bold">68-95-99.7</strong> rule, which describes the percentage of data that falls within 1, 2, or 3 standard deviations away from the mean if the data follows a normal distribution. This means that you can quickly look at some sample data, calculate the mean and standard deviation, and can have confidence (a statistical measure of uncertainty) that any future incoming data will fall within those <strong class="source-inline">68%-95%-99.7%</strong> boundaries. This rule is widely used in industries, medicine, economics, and social science:</p>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<img src="Images/B15780_03_23.jpg" alt="Figure 3.23: Curve showing the normal distribution of the famous 68-95-99.7 rule&#13;&#10;" width="1665" height="715"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.23: Curve showing the normal distribution of the famous 68-95-99.7 rule</p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor114"/>Data Wrangling in Statistics and Visualization</h1>
			<p>A good data wrangling professional is expected to encounter a dizzying array of diverse data sources each day. As we explained previously, due to a multitude of complex sub-processes and mutual interactions that give rise to such data, they all fall into the category of discrete or continuous random variables.</p>
			<p>It would be extremely difficult and confusing for a data wrangler or a data science team if all of this data continued to be treated as completely random without any shape or pattern. A formal statistical basis must be given to such random data streams, and one of the simplest ways to start that process is to measure their descriptive statistics.</p>
			<p>Assigning a stream of data to a particular distribution function (or a combination of many distributions) is actually part of inferential statistics. However, inferential statistics starts only when descriptive statistics is done alongside measuring all the important parameters of the pattern of the data.</p>
			<p>Therefore, as the front line of a data science pipeline, the process of data wrangling must deal with measuring and quantifying such descriptive statistics of the incoming data. Along with the formatted and cleaned-up data, the primary job of a data wrangler is to hand over these measures (and sometimes accompanying plots) to the next member of the analytics team.</p>
			<p>Plotting and visualization also help a data wrangling team in identifying potential outliers and misfits in the incoming data stream and help them take the appropriate action. We will see some examples of such tasks in the next chapter, where we will identify odd data points by creating scatter plots or histograms and either impute or omit the data point.</p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor115"/>Using NumPy and Pandas to Calculate Basic Descriptive Statistics</h2>
			<p>Now that we have some basic knowledge of <strong class="source-inline">NumPy</strong>, <strong class="source-inline">pandas</strong>, and <strong class="source-inline">matplotlib</strong> under our belt, we can explore a few additional topics related to these libraries, such as how we can bring them together for advanced data generation, analysis, and visualization.</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor116"/>Random Number Generation Using NumPy</h2>
			<p><strong class="source-inline">NumPy</strong> offers a dizzying array of random number generation utility functions, all of which correspond to various statistical distributions, such as uniform, binomial, Gaussian normal, Beta/Gamma, and chi-square. Most of these functions are extremely useful and appear countless times in advanced statistical data mining and machine learning tasks. Having a solid understanding of these concepts is strongly encouraged for all of you reading this book.</p>
			<p>Here, we will discuss three of the most important distributions that may come in handy for data wrangling tasks – <strong class="bold">uniform</strong>, <strong class="bold">binomial</strong>, and <strong class="bold">gaussian normal</strong>. The goal here is to show an example of simple function calls that can generate one or more random numbers/arrays whenever the user needs them.</p>
			<p>A <strong class="bold">uniform distribution</strong> is a probability distribution that is concerned with events that are equally likely to occur. Let's go through the following exercise to practice uniform distribution with random numbers.</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor117"/>Exercise 3.18: Generating Random Numbers from a Uniform Distribution</h2>
			<p>In this exercise, we will be generating random numbers from a uniform distribution of numbers from 1-10. Next, we'll generate some artificial data for a customized use case using the <strong class="source-inline">random</strong> function of the <strong class="source-inline">NumPy</strong> library. Let's go through the following steps:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The results will be different during each run as we will be working with random numbers.</p>
			<ol>
				<li value="1">Import the <strong class="source-inline">NumPy</strong> library:<p class="source-code">import numpy as np</p></li>
				<li>Generate a random integer between <strong class="source-inline">1</strong> and <strong class="source-inline">10</strong>:<p class="source-code">x = np.random.randint(1,10)</p><p class="source-code">print(x)</p><p>The sample output is as follows (your output could be different):</p><p class="source-code">1</p></li>
				<li>Generate a random integer between <strong class="source-inline">1</strong> and <strong class="source-inline">10</strong> but with <strong class="source-inline">size=1</strong> as an argument. This generates a <strong class="source-inline">NumPy</strong> array of size <strong class="source-inline">1</strong>:<p class="source-code">x = np.random.randint(1,10,size=1)</p><p class="source-code">print(x)</p><p>The sample output is as follows (your output could be different due to it being randomly drawn):</p><p class="source-code">[8]</p><p>Therefore, we can easily write the code to generate the outcome of a die being thrown (a normal 6-sided die) for <strong class="source-inline">10</strong> trials.</p><p>How about moving away from the integers and generating some real numbers? Let's say that we want to generate artificial data for the weights (in kgs) of <strong class="source-inline">20</strong> adults and that we can measure the accurate weights up to two decimal places.</p></li>
				<li>Generate decimal data using the following command:<p class="source-code">x = 50+50*np.random.random(size=15)</p><p class="source-code">x = x.round(decimals=2)</p><p class="source-code">print(x)</p><p>The sample output is as follows:</p><p class="source-code">[56.24 94.67 50.66 94.36 77.37 53.81 61.47 71.13 59.3 65.3 63.02 65.</p><p class="source-code"> 58.21 81.21 91.62]</p><p>We are not only restricted to one-dimensional arrays. We're going to use a multi-dimensional array for the next step.</p></li>
				<li>Generate and show a <strong class="source-inline">3x3</strong> matrix with random numbers between <strong class="source-inline">0</strong> and <strong class="source-inline">1</strong>:<p class="source-code">x = np.random.rand(3,3)</p><p class="source-code">print(x)</p><p>The sample output is as follows (note that your specific output could be different due to randomness):</p><p class="source-code">[[0.99240105 0.9149215  0.04853315]</p><p class="source-code"> [0.8425871  0.11617792 0.77983995]</p><p class="source-code"> [0.82769081 0.57579771 0.11358125]]</p><p class="callout-heading">Note</p><p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2YIycEL">https://packt.live/2YIycEL</a>. </p><p class="callout">You can also run this example online at <a href="https://packt.live/2YHqkDA">https://packt.live/2YHqkDA</a>.</p></li>
			</ol>
			<p>With this exercise, we have a basic idea of how to create random numbers, specifically, random trials on the basis of probability.</p>
			<p>A binomial distribution is the probability distribution of getting a specific number of successes in a specific number of trials of an event with a pre-determined chance or probability.</p>
			<p>The most obvious example of this is a coin toss. A fair coin may have an equal chance of heads or tails, but an unfair coin may have more chances of the head coming up or vice versa. We can simulate a coin toss using the <strong class="source-inline">NumPy</strong> library. We will look at this in the next exercise.</p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor118"/>Exercise 3.19: Generating Random Numbers from a Binomial Distribution and Bar Plot</h2>
			<p>In this exercise, we're going to generate random numbers from a binomial distribution and create a bar plot based on the generated DataFrame. Let's consider a scenario. Suppose we have a biased coin where the probability of heads is <strong class="source-inline">0.6</strong>. We toss this coin 10 times and take note of the number of heads turning up each time. That is one trial or experiment. Now, we can repeat this experiment (10 coin tosses) any number of times, say 8 times. Each time, we record the number of heads. Let's see how this works using the <strong class="source-inline">NumPy</strong> library:</p>
			<ol>
				<li value="1">Import the <strong class="source-inline">NumPy</strong> library:<p class="source-code">import numpy as np</p></li>
				<li>Let's generate random numbers from a binomial distribution. This experiment can be simulated using the following code:<p class="source-code">x = np.random.binomial(10,0.6,size=8)</p><p class="source-code">print(x)</p><p>The sample output is as follows (your specific output will be different due to randomness):</p><p class="source-code">[6 6 5 6 5 8 4 5]</p></li>
				<li>Plot the result using a bar chart:<p class="source-code">import matplotlib.pyplot as plt</p><p class="source-code">plt.figure(figsize=(7,4))</p><p class="source-code">plt.title("Number of successes in coin toss",\</p><p class="source-code">          fontsize=16)</p><p class="source-code">plt.bar(np.arange(1,9),height=x)</p><p class="source-code">plt.xlabel("Experiment number",fontsize=15)</p><p class="source-code">plt.ylabel("Number of successes",fontsize=15)</p><p class="source-code">plt.show()</p><p>The sample output is as follows:</p><div id="_idContainer076" class="IMG---Figure"><img src="Images/B15780_03_24.jpg" alt="Figure 3.24: A screenshot of a graph showing the binomial distribution and the bar plot &#13;&#10;" width="569" height="274"/></div></li>
			</ol>
			<p class="figure-caption">Figure 3.24: A screenshot of a graph showing the binomial distribution and the bar plot </p>
			<p class="callout-heading">Note</p>
			<p class="callout">The results of the aforementioned plot will vary for you due to the randomness involved.</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/3hB2aTQ">https://packt.live/3hB2aTQ</a>. </p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/2N6jbaq">https://packt.live/2N6jbaq</a>.</p>
			<p>As we can observe from the preceding plot, the bar chart represents the number of successes or number of heads that show up in each draw. We discussed normal distribution previously in this chapter and mentioned that it is the most important probability distribution because many pieces of natural, social, and biological data follow this pattern closely when the number of samples is large. <strong class="source-inline">NumPy</strong> provides an easy way for us to generate random numbers that correspond to this distribution.</p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor119"/>Exercise 3.20: Generating Random Numbers from a Normal Distribution and Histograms</h2>
			<p>This exercise will demonstrate how to generate a few random numbers using normal distribution and histograms. We haven't looked at creating plots with matplotlib and creating a binormal distribution. Creating charts can be a useful skill sometimes with data wrangling, especially when working with machine learning. To do so, let's go through the following steps:</p>
			<ol>
				<li value="1">Import the <strong class="source-inline">NumPy</strong> library:<p class="source-code">import numpy as np</p></li>
				<li>Draw a single sample from a normal distribution by using the following command:<p class="source-code">x = np.random.normal()</p><p class="source-code">print(x)</p><p>The sample output is as follows (note that your specific output could be different due to randomness):</p><p class="source-code">-1.2423774071573694</p><p>We know that normal distribution is characterized by two parameters – mean (µ) and standard deviation (σ). In fact, the default values for this particular function are µ = 0.0 and σ = 1.0.</p><p>Suppose we know that the heights of the teenage (12-16 years old) students in a particular school are distributed normally with a mean height of 155 cm and a standard deviation of 10 cm.</p></li>
				<li>Generate a histogram of 100 students by using the following command:<p class="source-code">import matplotlib.pyplot as plt</p><p class="source-code"># Code to generate the 100 samples (heights)</p><p class="source-code">heights = np.random.normal(loc=155,scale=10,size=100)</p><p class="source-code"># Plotting code</p><p class="source-code">#-----------------------</p><p class="source-code">plt.figure(figsize=(7,5))</p><p class="source-code">plt.hist(heights,color='orange',edgecolor='k')</p><p class="source-code">plt.title("Histogram of teenaged students' height",\</p><p class="source-code">          fontsize=18)</p><p class="source-code">plt.xlabel("Height in cm",fontsize=15)</p><p class="source-code">plt.xticks(fontsize=15)</p><p class="source-code">plt.yticks(fontsize=15)</p><p class="source-code">plt.show()</p><p>The sample output is as follows:</p><div id="_idContainer077" class="IMG---Figure"><img src="Images/B15780_03_25.jpg" alt="Figure 3.25: Histogram of teenage students' heights&#13;&#10;" width="637" height="335"/></div></li>
			</ol>
			<p class="figure-caption">Figure 3.25: Histogram of teenage students' heights</p>
			<p>Note the use of the loc parameter for the mean (<strong class="source-inline">=155</strong>) and the scale parameter for standard deviation (<strong class="source-inline">=10</strong>). The <strong class="source-inline">size</strong> parameter is set to 100 for that sample's generation.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2YHIODP">https://packt.live/2YHIODP</a>. </p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3hvJrsR">https://packt.live/3hvJrsR</a>.</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor120"/>Exercise 3.21: Calculating Descriptive Statistics from a DataFrame</h2>
			<p>In this exercise, we will be calculating the basic statistics of a generated DataFrame. DataFrames and statistics are commonly used together and will be a useful tool to acquire. We will define the age, weight, and height parameters and put that data in a DataFrame to calculate various descriptive statistics about them by using the <strong class="source-inline">describe</strong> method. Let's perform the following steps:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The best part of working with a <strong class="source-inline">pandas</strong> DataFrame is that it has a built-in utility function to show all of these descriptive statistics with a single line of code. </p>
			<ol>
				<li value="1">Construct a dictionary with the available series data by using the following command:<p class="source-code">import numpy as np</p><p class="source-code">import pandas as pd</p><p class="source-code">people = ['Ann','Brandon','Chen',\</p><p class="source-code">          'David','Emily','Farook',\</p><p class="source-code">          'Gagan','Hamish','Imran',\</p><p class="source-code">          'Joseph','Katherine','Lily']</p><p class="source-code">age = [21,12,32,45,37,18,28,52,5,40,48,15]</p><p class="source-code">weight = [55,35,77,68,70,60,72,69,18,65,82,48]</p><p class="source-code">height = [160,135,170,165,173,168,175,159,105,171,155,158]</p><p class="source-code">people_dict={'People':people,'Age':age,\</p><p class="source-code">             'Weight':weight,'Height':height}</p><p class="source-code">people_df=pd.DataFrame(data=people_dict)</p><p class="source-code">people_df</p><p>The output is as follows:</p><div id="_idContainer078" class="IMG---Figure"><img src="Images/B15780_03_26.jpg" alt="Figure 3.26: Output of the created dictionary&#13;&#10;" width="623" height="411"/></div><p class="figure-caption">Figure 3.26: Output of the created dictionary</p></li>
				<li>Find the number of rows and columns of the DataFrame by executing the following command:<p class="source-code">print(people_df.shape)</p><p>The output is as follows:</p><p class="source-code">(12, 4)</p></li>
				<li>Obtain a simple count (any column can be used for this purpose) by executing the following command:<p class="source-code">print(people_df['Age'].count())</p><p>The output is as follows:</p><p class="source-code">12</p></li>
				<li>Calculate the sum total of age by using the following command:<p class="source-code">print(people_df['Age'].sum())</p><p>The output is as follows:</p><p class="source-code">353</p></li>
				<li>Calculate the mean age by using the following command:<p class="source-code">print(people_df['Age'].mean())</p><p>The output is as follows:</p><p class="source-code">29.416666666666668</p></li>
				<li>Calculate the median weight by using the following command:<p class="source-code">print(people_df['Weight'].median())</p><p>The output is as follows:</p><p class="source-code">66.5</p></li>
				<li>Calculate the maximum height by using the following command:<p class="source-code">print(people_df['Height'].max())</p><p>The output is as follows:</p><p class="source-code">175</p></li>
				<li>Calculate the standard deviation of the weights by using the following command:<p class="source-code">print(people_df['Weight'].std())</p><p>The output is as follows:</p><p class="source-code">18.45120510148239</p><p>Note how we are calling the statistical functions directly from a DataFrame object.</p></li>
				<li>To calculate percentile, we can call a function from <strong class="source-inline">NumPy</strong> and pass on a particular column (a <strong class="source-inline">pandas</strong> series). For example, to calculate the 75th and 25th percentiles of age distribution and their difference (called the interquartile range), use the following code:<p class="source-code">pcnt_75 = np.percentile(people_df['Age'],75)</p><p class="source-code">pcnt_25 = np.percentile(people_df['Age'],25)</p><p class="source-code">print("Inter-quartile range: ",pcnt_75-pcnt_25)</p><p>The output is as follows:</p><p class="source-code">Inter-quartile range:  24.0</p></li>
				<li>Use the <strong class="source-inline">describe</strong> command to find a detailed description of the DataFrame:<p class="source-code">print(people_df.describe())</p><p>The output is as follows:</p><div id="_idContainer079" class="IMG---Figure"><img src="Images/B15780_03_27.jpg" alt="Figure 3.27: Output of the DataFrame using the describe method&#13;&#10;" width="1392" height="422"/></div></li>
			</ol>
			<p class="figure-caption">Figure 3.27: Output of the DataFrame using the describe method</p>
			<p>We have now seen how to manipulate DataFrames, which are the cornerstones of data wrangling. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">This function only works on columns where numeric data is present. It has no impact on non-numeric columns, for example, people in this DataFrame.</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/30S3agm">https://packt.live/30S3agm</a>. </p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/2YHBFDF">https://packt.live/2YHBFDF</a>.</p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor121"/>Exercise 3.22: Built-in Plotting Utilities</h2>
			<p>In this exercise, we will be going through the basic built-in plotting utilities in the <strong class="source-inline">matplotlib</strong> library and creating useful plots using numeric data from a DataFrame. We will use the <strong class="source-inline">people</strong> DataFrame that we referenced in <em class="italic">Exercise 3.21,</em> <em class="italic">Calculating Descriptive Statistics from a DataFrame</em> and generate plots to visually represent the data. To do so, let's go through the following steps:</p>
			<ol>
				<li value="1">Import the necessary libraries:<p class="source-code">import matplotlib.pyplot as plt</p><p class="source-code">import pandas as pd</p></li>
				<li>Create the <strong class="source-inline">people</strong> DataFrame:<p class="source-code">people = ['Ann','Brandon','Chen',\</p><p class="source-code">          'David','Emily','Farook',\</p><p class="source-code">          'Gagan','Hamish','Imran',\</p><p class="source-code">          'Joseph','Katherine','Lily']</p><p class="source-code">age = [21,12,32,45,37,18,28,52,5,40,48,15]</p><p class="source-code">weight = [55,35,77,68,70,60,72,69,18,65,82,48]</p><p class="source-code">height = [160,135,170,165,173,168,175,159,105,\</p><p class="source-code">          171,155,158]</p><p class="source-code">people_dict={'People':people,'Age':age,\</p><p class="source-code">             'Weight':weight,'Height':height}</p><p class="source-code">people_df=pd.DataFrame(data=people_dict)</p></li>
				<li>Find the histogram of the weights by using the <strong class="source-inline">hist</strong> function:<p class="source-code">people_df['Weight'].hist()</p><p class="source-code">plt.show()</p><p>The output is as follows:</p><div id="_idContainer080" class="IMG---Figure"><img src="Images/B15780_03_28.jpg" alt="Figure 3.28: Histogram of the weights&#13;&#10;" width="842" height="435"/></div><p class="figure-caption">Figure 3.28: Histogram of the weights</p><p>From the preceding histogram, we can determine that there are more people that weigh <strong class="source-inline">65</strong> kg than in any other group. If this wasn't generated from random numbers, then this might be a useful observation.</p></li>
				<li>Create a simple scatter plot directly from the DataFrame to plot the relationship between <strong class="source-inline">weight</strong> and <strong class="source-inline">height</strong> by using the following command:<p class="source-code">people_df.plot.scatter('Weight','Height',s=150,\</p><p class="source-code">                       c='orange',edgecolor='k')</p><p class="source-code">plt.grid(True)</p><p class="source-code">plt.title("Weight vs. Height scatter plot",fontsize=18)</p><p class="source-code">plt.xlabel("Weight (in kg)",fontsize=15)</p><p class="source-code">plt.ylabel("Height (in cm)",fontsize=15)</p><p class="source-code">plt.show()</p><p>The output is as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer081" class="IMG---Figure">
					<img src="Images/B15780_03_29.jpg" alt="Figure 3.29: Weight versus Height scatter plot&#13;&#10;" width="489" height="276"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.29: Weight versus Height scatter plot</p>
			<p>From the preceding plot, we can infer that people in the range of 160-180cms have a weight in the range of 60-80kgs. Charts can be a powerful tool when trying to understand the nature of data. It is not uncommon to plot data in the form of various charts before and after several steps of data wrangling.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can try regular <strong class="source-inline">matplotlib</strong> methods around this function call to make your plot pretty.</p>
			<p>With all this knowledge, let's try our hand at an activity. </p>
			<h2 id="_idParaDest-118">Activity 3.01: Generating Sta<a id="_idTextAnchor122"/>tistics from a CSV File</h2>
			<p>Suppose you are working with the Boston Housing price dataset. This dataset is famous in the machine learning community. Many regression problems can be formulated, and machine learning algorithms can be run on this dataset. You will perform a basic data wrangling activity (including plotting some trends) on this dataset (<strong class="source-inline">.csv</strong> file) by reading it as a <strong class="source-inline">pandas</strong> DataFrame. We will perform a few statistical operations on this DataFrame.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The Boston Housing dataset can be found here: <a href="https://packt.live/2ZPdvc2">https://packt.live/2ZPdvc2</a>. The <strong class="source-inline">pandas</strong> function for reading a CSV file is <strong class="source-inline">read_csv</strong>.</p>
			<p>These steps will help you complete this activity:</p>
			<ol>
				<li value="1">Load the necessary libraries.</li>
				<li>Read in the Boston Housing dataset (given as a <strong class="source-inline">.csv</strong> file) from the local directory.</li>
				<li>Check the first <strong class="source-inline">10</strong> records. Find the total number of records.</li>
				<li>Create a smaller DataFrame with columns that do not include <strong class="source-inline">CHAS</strong>, <strong class="source-inline">NOX</strong>, <strong class="source-inline">B</strong>, and <strong class="source-inline">LSTAT</strong>:<p><strong class="source-inline">Chas</strong>: Charlse River Dummy variable </p><p><strong class="source-inline">Nox</strong>: Nitric Oxide concentration</p><p><strong class="source-inline">B</strong>: Proportion of the population that is African American</p><p><strong class="source-inline">LSTAT</strong>: Percentage of lower-income population</p></li>
				<li>Check the last seven records of the new DataFrame you just created.</li>
				<li>Plot the histograms of all the variables (columns) in the new DataFrame.</li>
				<li>Plot them all at once using a for loop. Try to add a unique title to the plot.</li>
				<li>Create a scatter plot of crime rate versus price.</li>
				<li>Plot <strong class="source-inline">log10(crime)</strong> versus <strong class="source-inline">price</strong>.</li>
				<li>Calculate some useful statistics, such as mean rooms per dwelling, median age, mean distances to five Boston employment centers, and the percentage of houses with a low price (<strong class="source-inline">&lt; $20,000</strong>).<p><strong class="bold">Hint:</strong> To calculate the percentage of houses below <strong class="source-inline">$20,000</strong>, create a <strong class="source-inline">pandas</strong> series with the <strong class="source-inline">PRICE</strong> column and directly compare it with <strong class="source-inline">20</strong>. You can do this because <strong class="source-inline">pandas</strong> series is basically a <strong class="source-inline">NumPy</strong> array and you have seen how to filter NumPy array in the exercises in this chapter.</p></li>
			</ol>
			<p>The output should be as follows:</p>
			<p>Mean rooms per dwelling: <strong class="source-inline">6.284634387351788</strong></p>
			<p>Median age: <strong class="source-inline">77.5</strong></p>
			<p>Mean distances to five Boston employment centers: <strong class="source-inline">3.795042687747034</strong></p>
			<p>Percentage of houses with a low price (&lt;$20,000): <strong class="source-inline">41.50197628458498</strong></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found via <a href="B15780_Solution_Final_RK.xhtml#_idTextAnchor312">this link</a>.</p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor123"/>Summary</h1>
			<p>In this chapter, we started with the basics of <strong class="source-inline">NumPy</strong> arrays, including how to create them and their essential properties. We discussed and showed how a <strong class="source-inline">NumPy</strong> array is optimized for vectorized element-wise operations and differs from a regular Python list. Then, we moved on to practicing various operations on <strong class="source-inline">NumPy</strong> arrays such as indexing, slicing, filtering, and reshaping. We also covered special one-dimensional and two-dimensional arrays, such as zeros, ones, identity matrices, and random arrays.</p>
			<p>In the second major topic of this chapter, we started with <strong class="source-inline">pandas</strong> series objects and quickly moved on to a critically important object – <strong class="source-inline">pandas</strong> DataFrames. They are analogous to Excel or Matlab or a database tab, but with many useful properties for data wrangling. We demonstrated some basic operations on DataFrames, such as indexing, sub-setting, row and column addition, and deletion.</p>
			<p>Next, we covered the basics of plotting with <strong class="source-inline">matplotlib</strong>, the most widely used and popular Python library for visualization. Along with plotting exercises, we touched upon refresher concepts such as descriptive statistics (such as central tendency and measure of spread) and probability distributions (such as uniform, binomial, and normal).</p>
			<p>In the next chapter, we will cover more advanced operations that can be used on <strong class="source-inline">pandas</strong> DataFrames that will come in very handy in your journey toward becoming an expert data wrangler.</p>
		</div>
		<div>
			<div id="_idContainer083" class="Basic-Text-Frame">
			</div>
		</div>
		<div>
			<div id="_idContainer084" class="Content">
			</div>
		</div>
	</div></body></html>