<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Accessing Geodata</h1></div></div></div><p>All GIS processing must start with geographic data, so we begin our application by building the capacity to interact with, load, and save various geographic file formats. This chapter is divided into a vector and raster section, and in each section, we will cover the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Firstly, we create a data interface which means understanding data structures and how to interact with them.</li><li class="listitem" style="list-style-type: disc">Secondly and thirdly, any format-specific differences are outsourced to separate loader and saver modules.</li></ul></div><p>This is a lot of functionality to fit into one chapter, but by working your way through, you will learn a lot about data structures, and file formats, and end up with a solid foundation for your application.</p><div><div><div><div><h1 class="title"><a id="ch02lvl1sec13"/>The approach</h1></div></div></div><p>In our efforts to build data access<a id="id24" class="indexterm"/> in this chapter, we focus on simplicity, understanding, and lightweight libraries. We create standardized data interfaces for vector and raster data so that we can use the same methods and expect the same results on any data, without worrying about file format differences. They are not necessarily optimized for speed or memory efficiency as they load entire files into memory at once.</p><p>In our choice of third-party libraries for loading and saving, we focus on format-specific ones, so that we can pick and choose which formats to support and thus maintain a lightweight application. This requires some more work but allows us to learn intricate details about file formats.</p><div><div><h3 class="title"><a id="note06"/>Note</h3><p>If the size is not an issue in your application, you may wish to instead use the more powerful <a id="id25" class="indexterm"/>
<strong>GDAL</strong> library, which can single-handedly load and save a much wider range of both vector and raster formats. To use GDAL, I suggest downloading and installing a precompiled version from <a class="ulink" href="http://www.lfd.uci.edu/~gohlke/pythonlibs/#gdal">http://www.lfd.uci.edu/~gohlke/pythonlibs/#gdal</a>. On top of GDAL, the<a id="id26" class="indexterm"/> packages <strong>Fiona</strong> (<a class="ulink" href="http://www.lfd.uci.edu/~gohlke/pythonlibs/#fiona">http://www.lfd.uci.edu/~gohlke/pythonlibs/#fiona</a>) and <strong>Rasterio</strong> (<a class="ulink" href="http://www.lfd.uci.edu/~gohlke/pythonlibs/#rasterio">http://www.lfd.uci.edu/~gohlke/pythonlibs/#rasterio</a>) provide a more convenient<a id="id27" class="indexterm"/> and Pythonic interface to GDAL's <a id="id28" class="indexterm"/>functionality<a id="id29" class="indexterm"/> for vector and raster data, respectively.</p></div></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Vector data</h1></div></div></div><p>We begin by adding<a id="id30" class="indexterm"/> support for vector data. We will be creating three submodules inside our <code class="literal">vector</code> package: <code class="literal">data</code>, <code class="literal">loader</code>, and <code class="literal">saver</code>. To make these accessible from their parent vector package, we need to import it in <code class="literal">vector/__init__.py</code> as follows:</p><div><pre class="programlisting">from . import data
from . import loader
from . import saver</pre></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec07"/>A data interface for vector data</h2></div></div></div><p>The first thing we want is <a id="id31" class="indexterm"/>a data interface that we can conveniently interact with. This data interface will be contained in a module of its own, so create this module now and save it as <code class="literal">vector/data.py</code>.</p><p>We start off with a few<a id="id32" class="indexterm"/> basic imports, including compatibility functions for Shapely (which we installed in <a class="link" href="ch01.html" title="Chapter 1. Preparing to Build Your Own GIS Application">Chapter 1</a>, <em>Preparing to Build Your Own GIS Application</em>) and the spatial indexing abilities of <strong>Rtree</strong>, a package we will install later. Note that vector data loading and saving, are handled by separate modules that we have not yet created, but since they are accessed through our data interface, we need to import them here:</p><div><pre class="programlisting"># import builtins
import sys, os, itertools, operator
from collections import OrderedDict
import datetime

# import shapely geometry compatibility functions
# ...and rename them for clarity
import shapely
from shapely.geometry import asShape as geojson2shapely

# import rtree for spatial indexing
import rtree

# import internal modules
from . import loader
from . import saver</pre></div><div><div><h3 class="title"><a id="tip03"/>Tip</h3><p><strong>Downloading the example code</strong></p><p>You can download the example <a id="id33" class="indexterm"/>code files from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a> for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to <a id="id34" class="indexterm"/>you.</p></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec01"/>The vector data structure</h3></div></div></div><p>Geographic vector data <a id="id35" class="indexterm"/>can be thought of as a table of data. Each row in the table is an observation (say, a country), and holds one or more attributes, or piece of information for that observation (say, population). In a vector data structure, rows are <a id="id36" class="indexterm"/>known as a <strong>features</strong>, and have additional geometry definitions (coordinates that define, say, the shape and location of a country). An overview of the structure may therefore look something like this:</p><div><img src="img/5407OS_02_01.jpg" alt="The vector data structure"/></div><p>In our implementation of the vector data structure, we therefore create the interface as a <code class="literal">VectorData</code> class. To create and populate a <code class="literal">VectorData</code> instance with data, we can give it a <code class="literal">filepath</code> argument that it loads via the loader module that we create later. We also allow for optional keyword arguments to pass to the loader, which as we shall see includes the ability to specify text encoding. Alternatively, an empty <code class="literal">VectorData</code> instance can be created by not passing it any arguments. While creating an empty instance, it is possible to specify the geometry type of the entire data instance (meaning, it can only hold either polygon, line, or point geometries), otherwise it will set the data type based on the geometry type of the first feature that is added.</p><p>In addition to storing the fieldnames and creating features from rows and geometries, a <code class="literal">VectorData</code> instance remembers the <code class="literal">filepath</code> origin of the loaded data if applicable, and the <strong>Coordinate Reference System</strong> (<strong>CRS</strong>) which <a id="id37" class="indexterm"/>defaults to unprojected WGS84 if not specified.</p><p>To store the features, rather<a id="id38" class="indexterm"/> than using lists or dictionaries, we use an <a id="id39" class="indexterm"/>
<strong>ordered</strong> dictionary that allows us to identify each feature with a unique ID, sort the features, and perform fast and frequent feature lookups. To ensure that each feature in <code class="literal">VectorData</code> has a unique ID, we define a unique ID generator and attach independent ID generator instances to each <code class="literal">VectorData</code> instance.</p><p>To let us interact with the <code class="literal">VectorData</code> instance, we add various magic methods to enable standard Python operations such as getting the number of features in the data, looping through them, and getting and setting them through indexing their ID. Finally, we include a convenient <code class="literal">add_feature</code> and <code class="literal">copy</code> method. Take a look at the following code:</p><div><pre class="programlisting">def ID_generator():
    i = 0
    while True:
        yield i
        i += 1

class VectorData:
    def __init__(self, filepath=None, type=None, **kwargs):
        self.filepath = filepath

        # type is optional and will make the features ensure that all geometries are of that type
        # if None, type enforcement will be based on first geometry found
        self.type = type
        
        if filepath:
            fields,rows,geometries,crs = loader.from_file(filepath, **kwargs)
        else:
            fields,rows,geometries,crs = [],[],[],"+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"

        self.fields = fields

        self._id_generator = ID_generator()
        
        ids_rows_geoms = itertools.izip(self._id_generator,rows,geometries)
        featureobjs = (Feature(self,row,geom,id=id) for id,row,geom in ids_rows_geoms )
        self.features = OrderedDict([ (feat.id,feat) for feat in featureobjs ])
        self.crs = crs

    def __len__(self):
        """
        How many features in data.
        """
        return len(self.features)

    def __iter__(self):
        """
        Loop through features in order.
        """
        for feat in self.features.itervalues():
            yield feat

    def __getitem__(self, i):
        """
        Get a Feature based on its feature id.
        """
        if isinstance(i, slice):
            raise Exception("Can only get one feature at a time")
        else:
            return self.features[i]

    def __setitem__(self, i, feature):
        """
        Set a Feature based on its feature id.
        """
        if isinstance(i, slice):
            raise Exception("Can only set one feature at a time")
        else:
            self.features[i] = feature

    ### DATA ###

    def add_feature(self, row, geometry):
        feature = Feature(self, row, geometry)
        self[feature.id] = feature
    def copy(self):
        new = VectorData()
        new.fields = [field for field in self.fields]
        featureobjs = (Feature(new, feat.row, feat.geometry) for feat in self )
        new.features = OrderedDict([ (feat.id,feat) for feat in featureobjs ])
        if hasattr(self, "spindex"): new.spindex = self.spindex.copy()
        return new</pre></div><p>When we load or add features, they are stored in a <code class="literal">Feature</code> class with a link to its parent <code class="literal">VectorData</code> class. For the sake of simplicity, maximum interoperability, and memory efficiency, we choose to store <a id="id40" class="indexterm"/>feature geometries in the popular and <a id="id41" class="indexterm"/>widely supported <strong>GeoJSON</strong> format, which is just a Python dictionary structure formatted according to certain rules.</p><div><div><h3 class="title"><a id="note07"/>Note</h3><p>GeoJSON is<a id="id42" class="indexterm"/> a human-readable textual representation to describe various vector geometries, such as points, lines, and polygons. For the full specification, go to <a class="ulink" href="http://geojson.org/geojson-spec.html">http://geojson.org/geojson-spec.html</a>.</p></div></div><p>We make sure to give the <code class="literal">Feature</code> class some magic methods to support standard Python operations, such as easy getting and setting of attributes through fieldname indexing using the position of the desired field in the feature's parent list of fields to fetch the relevant row value. A <code class="literal">get_shapely</code> method to return the Shapely geometry representation and <code class="literal">copy</code> method will also be useful for later. The following code explains the <code class="literal">Feature</code> class:</p><div><pre class="programlisting">class Feature:
    def __init__(self, data, row, geometry, id=None):
        "geometry must be a geojson dictionary"
        self._data = data
        self.row  = list(row)

        self.geometry = geometry.copy()

        # ensure it is same geometry type as parent
        geotype = self.geometry["type"]
        if self._data.type: 
            if "Point" in geotype and self._data.type == "Point": pass
            elif "LineString" in geotype and self._data.type == "LineString": pass
            elif "Polygon" in geotype and self._data.type == "Polygon": pass
            else: raise TypeError("Each feature geometry must be of the same type as the file it is attached to")
        else: self._data.type = self.geometry["type"].replace("Multi", "")
        
        if id == None: id = next(self._data._id_generator)
        self.id = id

    def __getitem__(self, i):
        if isinstance(i, (str,unicode)):
            i = self._data.fields.index(i)
        return self.row[i]

    def __setitem__(self, i, setvalue):
        if isinstance(i, (str,unicode)):
            i = self._data.fields.index(i)
        self.row[i] = setvalue

    def get_shapely(self):
        return geojson2shapely(self.geometry)

    def copy(self):
        geoj = self.geometry
        if self._cached_bbox: geoj["bbox"] = self._cached_bbox
        return Feature(self._data, self.row, geoj) </pre></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec02"/>Computing bounding boxes</h3></div></div></div><p>Although we now have<a id="id43" class="indexterm"/> the basic structure of vector data, we want some additional convenience methods. For vector data, it is frequently useful to know the<a id="id44" class="indexterm"/> <strong>bounding box</strong> of each feature, which is an aggregated geographical description of a feature represented as a sequence of four coordinates <code class="literal">[xmin, ymin, xmax, ymax]</code>. Computing the bounding box can be computationally expensive, so we allow the <code class="literal">Feature</code> instance to receive a precomputed bounding box upon instantiation if available. In the Feature's <code class="literal">__init__</code> method, we therefore add to what we have already written:</p><div><pre class="programlisting">        bbox = geometry.get("bbox")
        self._cached_bbox = bbox</pre></div><p>This bounding box can also be cached or stored, for later use, so that we can just keep referring to that value after we have computed it. Using the <code class="literal">@property</code> descriptor, before we define the <code class="literal">Feature</code> class's <code class="literal">bbox</code> method, allows us to access the bounding box as a simple value or attribute even though it is computed as several steps in a method:</p><div><pre class="programlisting">    @property
    def bbox(self):
        if not self._cached_bbox:
            geotype = self.geometry["type"]
            coords = self.geometry["coordinates"]

            if geotype == "Point":
                x,y = coords
                bbox = [x,y,x,y]
            elif geotype in ("MultiPoint","LineString"):
                xs, ys = itertools.izip(*coords)
                bbox = [min(xs),min(ys),max(xs),max(ys)]
            elif geotype == "MultiLineString":
                xs = [x for line in coords for x,y in line]
                ys = [y for line in coords for x,y in line]
                bbox = [min(xs),min(ys),max(xs),max(ys)]
            elif geotype == "Polygon":
                exterior = coords[0]
                xs, ys = itertools.izip(*exterior)
                bbox = [min(xs),min(ys),max(xs),max(ys)]
            elif geotype == "MultiPolygon":
                xs = [x for poly in coords for x,y in poly[0]]
                ys = [y for poly in coords for x,y in poly[0]]
                bbox = [min(xs),min(ys),max(xs),max(ys)]
            self._cached_bbox = bbox
        return self._cached_bbox</pre></div><p>Finally, the bounding box for the entire collection of features in the <code class="literal">VectorData</code> class is also useful, so we create <a id="id45" class="indexterm"/>a similar routine at the <code class="literal">VectorData</code> level, except we do not care about caching because a <code class="literal">VectorData</code> class will frequently lose or gain new features. We want the bounding box to always be up to date. Add the following dynamic property to the <code class="literal">VectorData</code> class:</p><div><pre class="programlisting">    @property
    def bbox(self):
        xmins, ymins, xmaxs, ymaxs = itertools.izip(*(feat.bbox for feat in self))
        xmin, xmax = min(xmins), max(xmaxs)
        ymin, ymax = min(ymins), max(ymaxs)
        bbox = (xmin, ymin, xmax, ymax)
        return bbox</pre></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec03"/>Spatial indexing</h3></div></div></div><p>Finally, we add a<a id="id46" class="indexterm"/> spatial indexing structure that nests the bounding boxes of overlapping features inside each other so that feature locations can be tested and retrieved faster. For this, we will use the Rtree library. Perform the following <a id="id47" class="indexterm"/>steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Go to <a class="ulink" href="http://www.lfd.uci.edu/~gohlke/pythonlibs/#rtree">http://www.lfd.uci.edu/~gohlke/pythonlibs/#rtree</a>.</li><li class="listitem">Download the wheel file appropriate for our system, currently <code class="literal">Rtree-0.8.2.-cp27-none-win32.whl</code>.</li><li class="listitem">To install the package on Windows, open your command line and type <code class="literal">C:/Python27/Scripts/pip install path/to/Rtree-0.8.2.-cp27-none-win32.whl</code>.</li><li class="listitem">To verify that the<a id="id48" class="indexterm"/> installation has worked, open an interactive Python shell window and type <code class="literal">import rtree</code>.<div><div><h3 class="title"><a id="note08"/>Note</h3><p>Rtree is only one type of spatial index. Another <a id="id49" class="indexterm"/>common one is a <strong>Quad Tree</strong> index, whose main advantage is faster updating of the index if you need to change it often. <code class="literal">PyQuadTree</code> is a pure-Python implementation created by the author, which you can install in the command line as <code class="literal">C:/Python27/Scripts/pip install pyquadtree</code>.</p></div></div></li></ol></div><p>Since spatial indexes rely on bounding boxes, which as we said before can be computationally costly, we only create the spatial index if the user specifically asks for it. Therefore, let's create a <code class="literal">VectorData</code> class method that will make a spatial index from the Rtree library, populate it by inserting the bounding boxes of each feature and their ID, and store it as a property. This is shown in the following code snippet:</p><div><pre class="programlisting">    def create_spatial_index(self):
        """Allows quick overlap search methods"""
        self.spindex = rtree.index.Index()
        for feat in self:
            self.spindex.insert(feat.id, feat.bbox)</pre></div><p>Once created, Rtree's spatial index has two main methods that can be used for fast spatial lookups. The spatial lookups only return the IDs of the matches, so we use those IDs to fetch the actual feature instances from the matched IDs. Given a target bounding box, the first method finds features that overlap it, while the other method loops through the <em>n</em> nearest features in the order of closest to furthest away. In case the target bounding box is not in the required <code class="literal">[xmin, ymin,xmax,ymax]</code> format, we force it that way:</p><div><pre class="programlisting">    def quick_overlap(self, bbox):
        """
        Quickly get features whose bbox overlap the specified bbox via the spatial index.
        """
        if not hasattr(self, "spindex"):
            raise Exception("You need to create the spatial index before you can use this method")
        # ensure min,min,max,max pattern
        xs = bbox[0],bbox[2]
        ys = bbox[1],bbox[3]
        bbox = [min(xs),min(ys),max(xs),max(ys)]
        # return generator over results
        results = self.spindex.intersection(bbox)
        return (self[id] for id in results)

    def quick_nearest(self, bbox, n=1):
        """
        Quickly get n features whose bbox are nearest the specified bbox via the spatial index.
        """
        if not hasattr(self, "spindex"):
            raise Exception("You need to create the spatial index before you can use this method")
        # ensure min,min,max,max pattern
        xs = bbox[0],bbox[2]
        ys = bbox[1],bbox[3]
        bbox = [min(xs),min(ys),max(xs),max(ys)]
        # return generator over results
        results = self.spindex.nearest(bbox, num_results=n)
        return (self[id] for id in results)</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec08"/>Loading vector files</h2></div></div></div><p>So far, we have not defined<a id="id50" class="indexterm"/> the routine that actually loads data from a file into our <code class="literal">VectorData</code> interface. This is contained in a separate module as <code class="literal">vector/loader.py</code>. Start off the module by importing the necessary modules (don't worry if you have never heard of them before, we will install them shortly):</p><div><pre class="programlisting"># import builtins
import os

# import fileformat modules
import shapefile as pyshp
import pygeoj</pre></div><p>The main point of the loader module is to use a function, which we call <code class="literal">from_file()</code>, that takes a filepath and automatically detects which file type it is. It then loads it with the appropriate routine. Once loaded, it returns the information that our <code class="literal">VectorData</code> class expects: fieldnames, a list of row lists, a list of GeoJSON dictionaries of the geometries, and CRS information. An optional encoding argument determines the text encoding of the file (which the user will have to know or guess in advance), but more on that later. Go ahead and make it<a id="id51" class="indexterm"/> now:</p><div><pre class="programlisting">def from_file(filepath, encoding="utf8"):

    def decode(value):
        if isinstance(value, str): 
            return value.decode(encoding)
        else: return value</pre></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec04"/>Shapefile</h3></div></div></div><p>To deal with<a id="id52" class="indexterm"/> the shapefile format, an old but very commonly used vector file format, we use the popular and<a id="id53" class="indexterm"/> lightweight <strong>PyShp</strong> library. To install it in the command line just type <code class="literal">C:/Python27/Scripts/pip install pyshp</code>.</p><p>Inside the <code class="literal">from_file</code> function, we first detect if the file is in the shapefile format and then run our routine for loading it. The routine starts using the PyShp module to get access to the file contents through a <code class="literal">shapereader</code> object. Using the <code class="literal">shapereader</code> object, we extract the name (the first item) from each field information tuple, and exclude the first field which is always a deletion flag field. The rows are loaded by looping the <code class="literal">shapereader</code> object's <code class="literal">iterRecords</code> method.</p><p>Loading geometries is slightly more complicated because we want to perform some additional steps. PyShp, like most packages, can format its geometries as GeoJSON dictionaries via its shape object's <code class="literal">__geo_interface__</code> property. Now, remember from the earlier <em>Spatial indexing</em> section, calculating the individual bounding boxes for each individual feature can be costly. One of the benefits of the shapefile format is that each shape's bounding box is stored as part of the shapefile format. Therefore, we take advantage of the fact that they are already calculated for us and stored as a part of the GeoJSON dictionary that we send to initiate our <code class="literal">VectorData</code> class. We create a <code class="literal">getgeoj</code> function that adds the bounding box information to the GeoJSON dictionary if it is available (point shapes for instance, do not have a <code class="literal">bbox</code> attribute) and use it on each shape that we get from the <code class="literal">shapereader</code> object's <code class="literal">iterShapes</code> method.</p><p>Next, the shapefile formats have an optional <code class="literal">.prj</code> file containing projection information, so we also try to read this information if it exists, or default to unprojected WGS84 if not. Finally, we have the function return the loaded fields, rows, geometries, and projection so our data module can use them to build a <code class="literal">VectorData</code> instance.</p><p>Here is the final code:</p><div><pre class="programlisting">    # shapefile
    if filepath.endswith(".shp"):
        shapereader = pyshp.Reader(filepath)

        # load fields, rows, and geometries
        fields = [decode(fieldinfo[0]) for fieldinfo in shapereader.fields[1:]]
        rows = [ [decode(value) for value in record] for record in shapereader.iterRecords()]
        def getgeoj(obj):
            geoj = obj.__geo_interface__
            if hasattr(obj, "bbox"): geoj["bbox"] = obj.bbox
            return geoj
        geometries = [getgeoj(shape) for shape in shapereader.iterShapes()]

        # load projection string from .prj file if exists
        if os.path.lexists(filepath[:-4] + ".prj"):
            crs = open(filepath[:-4] + ".prj", "r").read()
        else: crs = "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
        
        return fields, rows, geometries, crs</pre></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec05"/>GeoJSON</h3></div></div></div><p>GeoJSON is a more recent file format than the shapefile format, due to its simplicity it is widely used, especially by <a id="id54" class="indexterm"/>web applications. The library we will use to read them is <code class="literal">PyGeoj</code>, created by the author. To install it, in the command line, type <code class="literal">C:/Python27/Scripts/pip install pygeoj</code>.</p><p>To detect GeoJSON files, there is no rule as to what their filename extension should be, but it tends to be either <code class="literal">.geojson</code> or just <code class="literal">.json</code>. We then load the GeoJSON file into a PyGeoj object. The GeoJSON features don't need to have all the same fields, so we use a convenience method that gets only the fieldnames that are common to all features.</p><p>Rows are loaded by looping the features and accessing the <code class="literal">properties</code> attribute. This PyGeoj object's geometries consist purely of GeoJSON dictionaries, same as our own data structure, so we just load the geometries as is. Finally, we return all the loaded information. Refer to the following code:</p><div><pre class="programlisting">    # geojson file
    elif filepath.endswith((".geojson",".json")):
        geojfile = pygeoj.load(filepath)

        # load fields, rows, and geometries
        fields = [decode(field) for field in geojfile.common_attributes]
        rows = [[decode(feat.properties[field]) for field in fields] for feat in geojfile]
        geometries = [feat.geometry.__geo_interface__ for feat in geojfile]

        # load projection
        crs = geojfile.crs
        
        return fields, rows, geometries, crs </pre></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec06"/>File format not supported</h3></div></div></div><p>Since we do not intend to support any additional file formats for now, we add an <code class="literal">else</code> clause returning an <a id="id55" class="indexterm"/>unsupported file format exception if the file path didn't match any of the previous formats:</p><div><pre class="programlisting">    else:
        raise Exception("Could not create vector data from the given filepath: the filetype extension is either missing or not supported")</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec09"/>Saving vector data</h2></div></div></div><p>To enable saving our<a id="id56" class="indexterm"/> vector data back to the file, create a module called <code class="literal">vector/saver.py</code>. At the top of the script, we import the necessary modules:</p><div><pre class="programlisting"># import builtins
import itertools

# import fileformats
import shapefile as pyshp
import pygeoj</pre></div><p>The main purpose of the saver module is a simple <code class="literal">to_file</code> function, which will do the saving for us. We do<a id="id57" class="indexterm"/> not allow a CRS projection argument, as that will require a way to format projections according to different standards which, to my knowledge, can currently only be done using GDAL, which we opted not to use.</p><p>Now, a common difficulty faced when saving files containing text is that you must remember to encode your <a id="id58" class="indexterm"/>
<strong>Unicode</strong> type text (text with fancy non-English characters) back into machine-readable byte strings, or if they are Python objects such as dates, we want to get their byte-string representation. Therefore, the first thing we do is create a quick function that will do this for us, using the text encoding argument from the <code class="literal">to_file</code> function. So far, our code looks like this:</p><div><pre class="programlisting">def to_file(fields, rows, geometries, filepath, encoding="utf8"):

    def encode(value):
        if isinstance(value, (float,int)):
            # nrs are kept as nrs
            return value
        elif isinstance(value, unicode):
            # unicode is custom encoded into bytestring
            return value.encode(encoding)
        else:
            # brute force anything else to string representation
            return bytes(value)</pre></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec07"/>Shapefile</h3></div></div></div><p>For saving vector data to the shapefile format, once we have created a <code class="literal">shapewriter</code> object, we first want to detect and set all the fields with the correct value types. Instead of dealing with potential type mismatches, we just check whether all valid values in each field are numeric, and if not, we force to text type. In the end, we assign to each field, a field tuple with a <a id="id59" class="indexterm"/>cleaned and encoded fieldname (shapefiles do not allow names longer than 10 characters or that contain spaces), the value type (where <em>C</em> stands for text characters and <em>N</em> for numbers), the maximum text length, and the decimal precision for numbers.</p><p>Once this is done, we can start writing our file. Unfortunately, PyShp currently has no ready-made way to save geometries directly from GeoJSON dictionaries, so we first create a function to do this conversion. Doing this requires making an empty PyShp shape instance and setting the correct <code class="literal">shapeType</code> property. The <code class="literal">points</code> attribute is a continuous list of all coordinate points, which for multigeometries is separated at the index positions indicated in the <code class="literal">parts</code> attribute.</p><p>We can then loop all our features, use our function to convert GeoJSON into PyShp shape instances, append those to the writer's <code class="literal">_shapes</code> list, encode and add the feature's row with the <code class="literal">record</code> method, and finish up by saving. The entire code is shown as follows:</p><div><pre class="programlisting">    # shapefile
    if filepath.endswith(".shp"):
        shapewriter = pyshp.Writer()
        
        # set fields with correct fieldtype
        for fieldindex,fieldname in enumerate(fields):
            for row in rows:
                value = row[fieldindex]
                if value != "":
                    try:
                        # make nr fieldtype if content can be made into nr
                        float(value)
                        fieldtype = "N"
                        fieldlen = 16
                        decimals = 8
                    except:
                        # but turn to text if any of the cells cannot be made to float bc they are txt
                        fieldtype = "C"
                        fieldlen = 250
                        decimals = 0
                        break
                else:
                    # empty value, so just keep assuming nr type
                    fieldtype = "N"
                    fieldlen = 16
                    decimals = 8
            # clean fieldname
            fieldname = fieldname.replace(" ","_")[:10]
            # write field
            shapewriter.field(fieldname.encode(encoding), fieldtype, fieldlen, decimals)

        # convert geojson to shape
        def geoj2shape(geoj):
            # create empty pyshp shape
            shape = pyshp._Shape()
            # set shapetype
            geojtype = geoj["type"]
            if geojtype == "Null":
                pyshptype = pyshp.NULL
            elif geojtype == "Point":
                pyshptype = pyshp.POINT
            elif geojtype == "LineString":
                pyshptype = pyshp.POLYLINE
            elif geojtype == "Polygon":
                pyshptype = pyshp.POLYGON
            elif geojtype == "MultiPoint":
                pyshptype = pyshp.MULTIPOINT
            elif geojtype == "MultiLineString":
                pyshptype = pyshp.POLYLINE
            elif geojtype == "MultiPolygon":
                pyshptype = pyshp.POLYGON
            shape.shapeType = pyshptype
            
            # set points and parts
            if geojtype == "Point":
                shape.points = [ geoj["coordinates"] ]
                shape.parts = [0]
            elif geojtype in ("MultiPoint","LineString"):
                shape.points = geoj["coordinates"]
                shape.parts = [0]
            elif geojtype in ("Polygon"):
                points = []
                parts = []
                index = 0
                for ext_or_hole in geoj["coordinates"]:
                    points.extend(ext_or_hole)
                    parts.append(index)
                    index += len(ext_or_hole)
                shape.points = points
                shape.parts = parts
            elif geojtype in ("MultiLineString"):
                points = []
                parts = []
                index = 0
                for linestring in geoj["coordinates"]:
                    points.extend(linestring)
                    parts.append(index)
                    index += len(linestring)
                shape.points = points
                shape.parts = parts
            elif geojtype in ("MultiPolygon"):
                points = []
                parts = []
                index = 0
                for polygon in geoj["coordinates"]:
                    for ext_or_hole in polygon:
                        points.extend(ext_or_hole)
                        parts.append(index)
                        index += len(ext_or_hole)
                shape.points = points
                shape.parts = parts
            return shape
        
        # iterate through original shapes
        for row,geom in itertools.izip(rows, geometries):
            shape = geoj2shape(geom)
            shapewriter._shapes.append(shape)
            shapewriter.record(*[encode(value) for value in row])
            
        # save
        shapewriter.save(filepath)</pre></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec08"/>GeoJSON</h3></div></div></div><p>Saving GeoJSON is slightly more straightforward to implement with the PyGeoj package. We start by<a id="id60" class="indexterm"/> creating a new <code class="literal">geojwriter</code> object, following which we loop all of our features, encode Unicode text to byte strings, add them to the <code class="literal">geojwriter</code> instance, and save once finished:</p><div><pre class="programlisting">    # GeoJSON file
    elif filepath.endswith((".geojson",".json")):
        geojwriter = pygeoj.new()        
        for row,geom in itertools.izip(rows,geometries):
            # encode row values
            row = (encode(value) for value in row)
            rowdict = dict(zip(fields, row))
            # add feature
            geojwriter.add_feature(properties=rowdict,
                                   geometry=geom)

        # save
        geojwriter.save(filepath) </pre></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec09"/>File format not supported</h3></div></div></div><p>Finally, we add<a id="id61" class="indexterm"/> an <code class="literal">else</code> clause to provide a message that the user attempted to save to a file format, for which saving is not yet supported:</p><div><pre class="programlisting">    else:
        raise Exception("Could not save the vector data to the given filepath: the filetype extension is either missing or not supported") </pre></div></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Raster data</h1></div></div></div><p>Now that we have<a id="id62" class="indexterm"/> implemented a data structure for loading and saving vector data, we can proceed to do the same for raster data. As stated earlier, we will be creating three submodules inside our <code class="literal">raster</code> package: <code class="literal">data</code>, <code class="literal">loader</code>, and <code class="literal">saver</code>. To make these accessible from their parent raster package, we need to import it in <code class="literal">raster/__init__.py</code> as follows:</p><div><pre class="programlisting">from . import data
from . import loader
from . import saver</pre></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec10"/>A data interface for raster data</h2></div></div></div><p>Raster data has a<a id="id63" class="indexterm"/> very different structure that we must accommodate, and we begin by making its data interface. The code for this interface will be contained in a <a id="id64" class="indexterm"/>module of its own inside the raster folder. To create this module now, save it as <code class="literal">raster/data.py</code>. Start it out with a few basic imports, including the loader and saver modules that we have not yet created and PIL which we installed in <a class="link" href="ch01.html" title="Chapter 1. Preparing to Build Your Own GIS Application">Chapter 1</a>, <em>Preparing to Build Your Own GIS Application</em>:</p><div><pre class="programlisting"># import builtins
import sys, os, itertools, operator

# import internals
from . import loader
from . import saver

# import PIL as the data container
import PIL.Image, PIL.ImageMath</pre></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec10"/>The raster data structure</h3></div></div></div><p>A raster consists of one<a id="id65" class="indexterm"/> or more grids of data referred to as<a id="id66" class="indexterm"/> <strong>bands</strong>. These grids and the values in<a id="id67" class="indexterm"/> each of their <strong>cells</strong> represent how a piece of information flows across space-like pixels in a photograph:</p><div><img src="img/5407OS_02_02.jpg" alt="The raster data structure"/></div><p>Given raster data's similarities with imagery data, we take advantage of our existing PIL imaging library that we imported earlier and use it for our application's raster data structure. Its C-based code makes it fast and memory-efficient, and it already contains a lot of the pixel-based raster functionality that we want to be able to do eventually.</p><p>At the top level, our <code class="literal">RasterData</code> class <a id="id68" class="indexterm"/>contains some raster metadata and one or more <strong>Band</strong> layers, which are just wrappers around pixel image data containers. When creating a new <code class="literal">RasterData</code> class, we usually load from a file path. The actual loading is outsourced to a loader module we create later, which returns a dictionary of various metadata about the raster (<code class="literal">info</code>), a list of one or more bands (<code class="literal">bands</code>), and the definition of its coordinate<a id="id69" class="indexterm"/> reference system (<code class="literal">crs</code>). We can also create a new <code class="literal">RasterData</code> class from non-spatial data based on a list of lists representing a grid or an ordinary image file, in which case it is up to us to define its CRS and geospatial metadata (we return to this shortly).</p><p>The <code class="literal">Band</code> class is <a id="id70" class="indexterm"/>where the actual values are stored. We keep one reference to a PIL image (<code class="literal">img</code>) so that we can use its various imagery processing methods, and one reference to the image's pixel access object (<code class="literal">cells</code>) so we can tinker directly with individual pixels. Each pixel is accessed as a <code class="literal">Cell</code> class instance, which provides a convenience method for its row/column position.</p><p>Look at the following code:</p><div><pre class="programlisting">class Cell:
    def __init__(self, band, col, row):
        self.band = band
        self.col, self.row = col, row

    def __repr__(self):
        return "Cell(col=%s, row=%s, value=%s)" %(self.col, self.row, self.value)

    @property
    def value(self):
        return self.band.cells[self.col, self.row]


class Band:
    def __init__(self, img, cells):
        self.img = img
        self.cells = cells

    def __iter__(self):
        width,height = self.img.size
        for row in range(height):
            for col in range(width):
                yield Cell(self, col, row)
            
    def get(self, col, row):
        return Cell(self, col, row)

    def set(self, col, row, value):
        self.cells[col,row] = value

    def copy(self):
        img = self.img.copy()
        cells = img.load()
        return Band(img, cells)


class RasterData:
    def __init__(self, filepath=None, data=None, image=None, **kwargs):
        self.filepath = filepath
        
        if filepath:
            info, bands, crs = loader.from_file(filepath)
        elif data:
            info, bands, crs = loader.from_lists(data, **kwargs)
        elif image:
            info, bands, crs = loader.from_image(image, **kwargs)
        else:
            info, bands, crs = loader.new(**kwargs)

        self.bands = [Band(img,cells) for img,cells in bands]

        self.info = info

        self.crs = crs

        self.update_geotransform()
    
    def __iter__(self):
        for band in self.bands:
            yield band
            
    @property
    def width(self):
        return self.bands[0].img.size[0]

    @property
    def height(self):
        return self.bands[0].img.size[1]

    def copy(self):
        new = RasterData(width=self.width, height=self.height, **self.info)
        new.bands = [band.copy() for band in self.bands]
        new._cached_mask = self.mask
        return new</pre></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec11"/>Positioning the raster in coordinate space</h3></div></div></div><p>We are not <a id="id71" class="indexterm"/>done yet. While the gridded structure of our raster bands gives us a sense of the relative location of each value within the grid, it does not say anything about their real-world geographical position in the same way that a <code class="literal">Feature</code> geometry's coordinates does. This is why we need additional geospatial metadata about the raster. To position our values in geographic space, there are two ways this can be specified in our <code class="literal">info</code> metadata dictionary:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We need to translate one of the cells (<code class="literal">xy_cell</code>) to a geographic or projected coordinate (<code class="literal">xy_geo</code>) and specify the coordinate width and height of its cells (<code class="literal">cellwidth</code> and <code class="literal">cellheight</code>) so that we can move and resize the raster. These are essentially just components of the transform coefficients described next.</li><li class="listitem" style="list-style-type: disc">In some cases, such as aerial imagery taken along some arbitrary direction, it might not be enough to move and resize the raster. We may also need to rotate and possibly skew the raster. To do this, we need a set of affine transform coefficients (<code class="literal">transform_ceoffs</code>), so we can recalculate the position of each and every cell to end up with the warped image. This is also known as a <a id="id72" class="indexterm"/><strong>geotransform</strong>.<div><div><h3 class="title"><a id="note09"/>Note</h3><p>There is also a third possibility, by using a sample of geocoded points, which can then be approximated using a non-linear transformation, but we do not cover this method. For more on positioning rasters in coordinate space, check out: <a class="ulink" href="http://www.remotesensing.org/geotiff/spec/geotiff2.6.html">http://www.remotesensing.org/geotiff/spec/geotiff2.6.html</a>.</p></div></div></li></ul></div><p>The following diagram illustrates how a set of geotransform coefficients might offset, scale, and rotate a raster dataset to position it in coordinate space, which usually requires flipping the <em>y</em> axis:</p><div><img src="img/5407OS_02_03.jpg" alt="Positioning the raster in coordinate space"/></div><p>One last aspect of raster data that should be considered is where in each cell the coordinate offsets are anchored; either at the cell center or any of its four corners. We store this information as <code class="literal">xy_anchor</code>. However, as the difference is very small, we choose not to do anything with it for our simple application.</p><p>Based on the provided geospatial metadata, we must first calculate the regular and inverse transform coefficients (<code class="literal">update_geotransform()</code>) so that we can map back and forth between cell<a id="id73" class="indexterm"/> positions and spatial coordinates (<code class="literal">cell_to_geo()</code> and <code class="literal">geo_to_cell()</code>). With this foundation, we can get further information about the bounding box of the raster (<code class="literal">bbox</code>). Most importantly, we allow repositioning/warping the raster (and its nodata mask that we create later) into a new raster that reflects its real-world location within a specified bounding box and at a specified width/height resolution (<code class="literal">positioned()</code>). This repositioning is easy to implement by transforming from the old to the new coordinate bounding box using PIL's quad transform. Let's add these functionalities to the <code class="literal">RasterData</code> structure:</p><div><pre class="programlisting">    def cell_to_geo(self, column, row):
        [xscale, xskew, xoffset, yskew, yscale, yoffset] = self.transform_coeffs
        x, y = column, row
        x_coord = x*xscale + y*xskew + xoffset
        y_coord = x*yskew + y*yscale + yoffset
        return x_coord, y_coord

    def geo_to_cell(self, x, y, fraction=False):
        [xscale, xskew, xoffset, yskew, yscale, yoffset] = self.inv_transform_coeffs
        column = x*xscale + y*xskew + xoffset
        row = x*yskew + y*yscale + yoffset
        if not fraction:
            # round to nearest cell
            column,row = int(round(column)), int(round(row))
        return column,row

    @property
    def bbox(self):
        # get corner coordinates of raster
        xleft_coord,ytop_coord = self.cell_to_geo(0,0)
        xright_coord,ybottom_coord = self.cell_to_geo(self.width, self.height)
        return [xleft_coord,ytop_coord,xright_coord,ybottom_coord]

    def update_geotransform(self):
        info = self.info
        
        # get coefficients needed to convert from raster to geographic space
        if info.get("transform_coeffs"):
            [xscale, xskew, xoffset,
             yskew, yscale, yoffset] = info["transform_coeffs"]
        else:
            xcell,ycell = info["xy_cell"]
            xgeo,ygeo = info["xy_geo"]
            xoffset,yoffset = xgeo - xcell, ygeo - ycell
            xscale,yscale = info["cellwidth"], info["cellheight"] 
            xskew,yskew = 0,0
        self.transform_coeffs = [xscale, xskew, xoffset, yskew, yscale, yoffset]

        # and the inverse coefficients to go from geographic space to raster
        # taken from Sean Gillies' "affine.py"
        a,b,c,d,e,f = self.transform_coeffs
        det = a*e - b*d
        if det != 0:
            idet = 1 / float(det)
            ra = e * idet
            rb = -b * idet
            rd = -d * idet
            re = a * idet
            a,b,c,d,e,f = (ra, rb, -c*ra - f*rb,
                           rd, re, -c*rd - f*re)
            self.inv_transform_coeffs = a,b,c,d,e,f
        else:
            raise Exception("Error with the transform matrix, \
                            a raster should not collapse upon itself")

    def positioned(self, width, height, coordspace_bbox):
        # GET COORDS OF ALL 4 VIEW SCREEN CORNERS
        xleft,ytop,xright,ybottom = coordspace_bbox
        viewcorners = [(xleft,ytop), (xleft,ybottom), (xright,ybottom), (xright,ytop)]
        
        # FIND PIXEL LOCS OF ALL THESE COORDS ON THE RASTER
        viewcorners_pixels = [self.geo_to_cell(*point, fraction=True) for point in viewcorners]

        # ON RASTER, PERFORM QUAD TRANSFORM
        #(FROM VIEW SCREEN COORD CORNERS IN PIXELS TO RASTER COORD CORNERS IN PIXELS)
        flattened = [xory for point in viewcorners_pixels for xory in point]
        newraster = self.copy()

        #self.update_mask()
        mask = self.mask

        # make mask over 
        masktrans = mask.transform((width,height), PIL.Image.QUAD,
                            flattened, resample=PIL.Image.NEAREST)
        
        for band in newraster.bands:
            datatrans = band.img.transform((width,height), PIL.Image.QUAD,
                                flattened, resample=PIL.Image.NEAREST)
            trans = PIL.Image.new(datatrans.mode, datatrans.size)
            trans.paste(datatrans, (0,0), masktrans)
            # store image and cells
            band.img = trans
            band.cells = band.img.load()

        return newraster,masktrans</pre></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec12"/>Nodata masking</h3></div></div></div><p>Sometimes cells in a<a id="id74" class="indexterm"/> raster contain missing data, so each <code class="literal">RasterData</code> class will define a <code class="literal">nodata_value</code> in its <code class="literal">info</code> metadata dictionary if specified. This is important because these <code class="literal">nodata</code> cells have to be ignored while visualizing or performing operations. Therefore, in our data interface, we need to create an additional image grid that knows the location of missing values so that we can use it with PIL to mask <a id="id75" class="indexterm"/>or hide away those values. This mask is accessed as a dynamic property that we cache for repeated use. Refer to the following code:</p><div><pre class="programlisting">    @property
    def mask(self):
        if hasattr(self, "_cached_mask"):
            return self._cached_mask

        else:
            nodata = self.info.get("nodata_value")
            if nodata != None:
                # mask out nodata
                if self.bands[0].img.mode in ("F","I"):
                    # if 32bit float or int values, need to manually check each cell
                    mask = PIL.Image.new("1", (self.width, self.height), 1)
                    px = mask.load()
                    for col in xrange(self.width):
                        for row in xrange(self.height):
                            value = (band.cells[col,row] for band in self.bands)
                            # mask out only where all bands have nodata value
                            if all((val == nodata for val in value)):
                                px[col,row] = 0
                else:
                    # use the much faster point method
                    masks = []
                    for band in self.bands:
                        mask = band.img.point(lambda px: 1 if px != nodata else 0, "1")
                        masks.append(mask)
                    # mask out where all bands have nodata value
                    masks_namedict = dict([("mask%i"%i, mask) for i,mask in enumerate(masks) ])
                    expr = " &amp; ".join(masks_namedict.keys())
                    mask = PIL.ImageMath.eval(expr, **masks_namedict).convert("1")
            else:
                # EVEN IF NO NODATA, NEED TO CREATE ORIGINAL MASK,
                # TO PREVENT INFINITE OUTSIDE BORDER AFTER GEOTRANSFORM
                nodata = 0
                mask = PIL.Image.new("1", self.bands[0].img.size, 1)
            self._cached_mask = mask
            return self._cached_mask</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec11"/>Loading raster data</h2></div></div></div><p>Now, it is time to add the loading to the <code class="literal">Raster</code> class. Unfortunately, besides GDAL, there are not many independent <a id="id76" class="indexterm"/>file format libraries that focus on loading geographic raster formats. Nevertheless, we are still able to make a minimal loader of the common<a id="id77" class="indexterm"/> GeoTIFF file format based on PIL. We initiate the module with some imports and save it as <code class="literal">raster/loader.py</code>:</p><div><pre class="programlisting"># import internals
import sys, os, itertools, operator
# import PIL as the image loader
import PIL.Image </pre></div><p>The main purpose of our loader module is to provide a <code class="literal">from_file</code> function that returns the necessary pieces to our raster data structure. Before we get into loading each raster file format, we begin with a function to read metadata from the ESRI world file format that sometimes <a id="id78" class="indexterm"/>accompany raster files. The world file is a very simple text file containing six values defining the affine geotransform metadata discussed previously, and its filename extension is either <code class="literal">.wld</code> or a variation on the image file type it accompanies.</p><div><div><h3 class="title"><a id="note10"/>Note</h3><p>With support for this world file, we can easily allow the loading and saving of image-like raster formats with PIL, such as <code class="literal">.png</code>, <code class="literal">.bmp</code>, <code class="literal">.gif</code>, or <code class="literal">.jpg</code>, but we do not do so in this book. The world file also sometimes comes with the ESRI ASCII raster format, a simple text file format, that is easy to understand and implement.</p></div></div><p>Take a look at the following code:</p><div><pre class="programlisting">def from_file(filepath):

    def check_world_file(filepath):
        worldfilepath = None
        
        # try to find worldfile
        dir, filename_and_ext = os.path.split(filepath)
        filename, extension = os.path.splitext(filename_and_ext)
        dir_and_filename = os.path.join(dir, filename)
        
        # first check generic .wld extension
        if os.path.lexists(dir_and_filename + ".wld"):
            worldfilepath = dir_and_filename + ".wld"
            
        # if not, check filetype-specific world file extensions
        else:
            # get filetype-specific world file extension
            if extension in ("tif","tiff","geotiff"):
                extension = ".tfw"
            else:
                return None
            # check if exists
            if os.path.lexists(dir_and_filename + extension):
                worldfilepath = dir_and_filename + extension

        # then return contents if file found
        if worldfilepath:
            with open(worldfilepath) as worldfile:
                # note that the params are arranged slightly differently
                # ...in the world file from the usual affine a,b,c,d,e,f
                # ...so remember to rearrange their sequence later
                xscale,yskew,xskew,yscale,xoff,yoff = worldfile.read().split()
            return [xscale,yskew,xskew,yscale,xoff,yoff]</pre></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec13"/>GeoTIFF</h3></div></div></div><p>GeoTIFF is a<a id="id79" class="indexterm"/> geographic extension of the flexible TIFF image file format, with the only difference being additional geo-specific metadata tags. PIL can read TIFF files along with their metadata tags, but once we fully load or access the image contents, PIL makes it format-neutral by stripping away any format-specific info. Therefore, you must extract the geo tags before you do anything with the image. Once extracted, it is up to us to interpret the tag codes, because PIL does not know about the GeoTIFF specification. We extract tags relating to the geotransform, nodata value, and the name and text-encoded tags of the CRS (there are numerous other CRS-specific tags, but it will be too much to deal with all of them here). Finally, we split the image into its individual bands in case it is a composite RGB raster, and return the info metadata, band tuples, and CRS.</p><div><div><h3 class="title"><a id="note11"/>Note</h3><p>The full-GeoTIFF <a id="id80" class="indexterm"/>specification can be found online at <a class="ulink" href="http://www.remotesensing.org/geotiff/spec/contents.html">http://www.remotesensing.org/geotiff/spec/contents.html</a>.</p></div></div><p>Refer to the following code:</p><div><pre class="programlisting">    elif filepath.lower().endswith((".tif",".tiff",".geotiff")):
        main_img = PIL.Image.open(filepath)
        raw_tags = dict(main_img.tag.items())
        
        def process_metadata(raw_tags):
            # check tag definitions here
            info = dict()
            if raw_tags.has_key(1025):
                # GTRasterTypeGeoKey, aka midpoint pixels vs topleft area pixels
                if raw_tags.get(1025) == (1,):
                    # is area
                    info["cell_anchor"] = "center"
                elif raw_tags.get(1025) == (2,):
                    # is point
                    info["cell_anchor"] = "nw"
            if raw_tags.has_key(34264):
                # ModelTransformationTag, aka 4x4 transform coeffs...
                a,b,c,d,
                e,f,g,h,
                i,j,k,l,
                m,n,o,p = raw_tags.get(34264)
                # But we don't want to meddle with 3-D transforms,
                # ...so for now only get the 2-D affine parameters
                xscale,xskew,xoff = a,b,d
                yskew,yscale,yoff = e,f,h
                info["transform_coeffs"] = xscale,xskew,xoff,yskew,yscale,yoff
            else:
                if raw_tags.has_key(33922):
                    # ModelTiepointTag
                    x, y, z, geo_x, geo_y, geo_z = raw_tags.get(33922)
                    info["xy_cell"] = x,y
                    info["xy_geo"] = geo_x,geo_y
                if raw_tags.has_key(33550):
                    # ModelPixelScaleTag
                    scalex,scaley,scalez = raw_tags.get(33550)
                    info["cellwidth"] = scalex
                    info["cellheight"] = -scaley # note: cellheight must be inversed because geotiff has a reversed y- axis (ie 0,0 is in upperleft corner)
            if raw_tags.get(42113):
                info["nodata_value"] = eval(raw_tags.get(42113)) # eval from string to nr
            return info

        def read_crs(raw_tags):
            crs = dict()
            if raw_tags.get(34735):
                # GeoKeyDirectoryTag
                crs["proj_params"] = raw_tags.get(34735)
            if raw_tags.get(34737):
                # GeoAsciiParamsTag
                crs["proj_name"] = raw_tags.get(34737)
            return crs          

        # read geotiff metadata tags
        info = process_metadata(raw_tags)

        # if no geotiff tag info look for world file transform coefficients
        if len(info) &lt;= 1 and not info.get("transform_coeffs"):
            transform_coeffs = check_world_file(filepath)
            if transform_coeffs:
                # rearrange the world file param sequence to match affine transform
                [xscale,yskew,xskew,yscale,xoff,yoff] = transform_coeffs
                info["transform_coeffs"] = [xscale,xskew,xoff,yskew,yscale,yoff]
            else:
                raise Exception("Couldn't find any geotiff tags or world file needed to position the image in space")

        # group image bands and pixel access into band tuples
        bands = []
        for img in main_img.split():
            cells = img.load()
            bands.append((img,cells))

        # read coordinate ref system
        crs = read_crs(raw_tags)

        return info, bands, crs</pre></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec14"/>File format not supported</h3></div></div></div><p>As with the <a id="id81" class="indexterm"/>vector loader, we raise an exception if an attempt to load an unsupported raster file format has been made, using the following code:</p><div><pre class="programlisting">    else:
        raise Exception("Could not create a raster from the given filepath: the filetype extension is either missing or not supported")</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec12"/>Saving raster data</h2></div></div></div><p>Finally, we want to save<a id="id82" class="indexterm"/> our raster data back to file, so we create a new<a id="id83" class="indexterm"/> module called <code class="literal">raster/saver.py</code>. We start out with some imports <a id="id84" class="indexterm"/>as follows:</p><div><pre class="programlisting"># import builtins
Import os

# import PIL as the saver
import PIL
import PIL.TiffImagePlugin
import PIL.TiffTags </pre></div><p>Inside the main <code class="literal">to_file</code> function, we define a cross-format function to combine raster bands into a final image ready to be<a id="id85" class="indexterm"/> saved, and a basic method for creating the <code class="literal">worldfile</code> containing geotransform:</p><div><pre class="programlisting">def to_file(bands, info, filepath):
    def combine_bands(bands):
        # saving in image-like format, so combine and prep final image
        if len(bands) == 1:
            img = bands[0].img
            return img
        elif len(bands) == 3:
            # merge all images together
            mode = "RGB"
            bands = [band.img for band in bands]
            img = PIL.Image.merge(mode, bands)
            return img
        elif len(bands) == 4:
            # merge all images together
            mode = "RGBA"
            bands = [band.img for band in bands]
            img = PIL.Image.merge(mode, bands)
            return img
        else:
            # raise error if more than 4 bands, because PIL cannot save such images
            raise Exception("Cannot save more than 4 bands to one file; split and save each band separately")

    def create_world_file(savepath, geotrans):
        dir, filename_and_ext = os.path.split(savepath)
        filename, extension = os.path.splitext(filename_and_ext)
        world_file_path = os.path.join(dir, filename) + ".wld"
        with open(world_file_path, "w") as writer:
            # rearrange transform coefficients and write
            xscale,xskew,xoff,yskew,yscale,yoff = geotrans
            writer.writelines([xscale, yskew, xskew, yscale, xoff, yoff])</pre></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec15"/>GeoTIFF</h3></div></div></div><p>Next, we allow<a id="id86" class="indexterm"/> saving to GeoTIFF using PIL. Until recently, saving GeoTIFF with PIL was not possible. This was because PIL had not implemented saving TIFF tags of type <code class="literal">float</code> or <code class="literal">double</code>, this would lead to errors because most GeoTIFF tags are double values. A recent user contribution added the required support for double tags, and by the time you read this, PIL's Pillow fork should have hopefully incremented to<a id="id87" class="indexterm"/> a new stable version 2.8.2.</p><div><div><h3 class="title"><a id="tip04"/>Tip</h3><p>If Pillow is still on version 2.8.1, you will have to add this support yourself by modifying your PIL package in <code class="literal">site-packages</code>. After opening PIL's <code class="literal">TiffImagePlugin.py</code> file, you will see that the <code class="literal">ImageFileDirectory</code> class has a <code class="literal">save</code> method starting at around line 483. This method loops through all the provided tags with several <code class="literal">if</code> statements checking for different tag value types. Between the <code class="literal">if</code> statements commented as <code class="literal">untyped data</code> and <code class="literal">string data</code>, you must add a new <code class="literal">if</code> statement with the following code for floats and doubles, and remember to save your changes:</p><div><pre class="programlisting">            elif typ in (11, 12):
                # float value
                tmap = {11: 'f', 12: 'd'}
                if not isinstance(value, tuple):
                    value = (value,)
                a = array.array(tmap[typ], value)
                if self.prefix != native_prefix:
                    a.byteswap()
                data = a.tostring()</pre></div></div></div><p>The actual saving procedure is implemented by leveraging some less well-known features of PIL. In order to save our raster's metadata as tags in the file itself, we must refer to PIL's <code class="literal">TiffImagePlugin</code> module, disable its use of the LibTIFF library, and create an empty <code class="literal">ImageFileDirectory</code> class to hold the tags. Each added tag value is set by index setting the tag container and must be followed by index setting the tag value type on the container's <code class="literal">tagtype</code> property.</p><p>Once all the geotransform, nodata, and projection tags are set, we simply combine the band images into one and pass the tag container as an extra argument to the final <code class="literal">save()</code> call:</p><div><pre class="programlisting">    elif filepath.endswith((".tif", ".tiff", ".geotiff")):
        # write directly to tag info
        PIL.TiffImagePlugin.WRITE_LIBTIFF = False
        tags = PIL.TiffImagePlugin.ImageFileDirectory()
        if info.get("cell_anchor"):
            # GTRasterTypeGeoKey, aka midpoint pixels vs topleft area pixels
            if info.get("cell_anchor") == "center":
                # is area
                tags[1025] = 1.0
                tags.tagtype[1025] = 12 #double, only works with PIL patch
            elif info.get("cell_anchor") == "nw":
                # is point
                tags[1025] = 2.0
                tags.tagtype[1025] = 12 #double, only works with PIL patch
        if info.get("transform_coeffs"):
            # ModelTransformationTag, aka 4x4 transform coeffs...
            tags[34264] = tuple(map(float,info.get("transform_coeffs")))
            tags.tagtype[34264] = 12 #double, only works with PIL patch
        else:
            if info.get("xy_cell") and info.get("xy_geo"):
                # ModelTiepointTag
                x,y = info["xy_cell"]
                geo_x,geo_y = info["xy_geo"]
                tags[33922] = tuple(map(float,[x,y,0,geo_x,geo_y,0]))
                tags.tagtype[33922] = 12 #double, only works with PIL patch
            if info.get("cellwidth") and info.get("cellheight"):
                # ModelPixelScaleTag
                scalex,scaley = info["cellwidth"],info["cellheight"]
                tags[33550] = tuple(map(float,[scalex,scaley,0]))
                tags.tagtype[33550] = 12 #double, only works with PIL patch
        if info.get("nodata_value"):
            tags[42113] = bytes(info.get("nodata_value"))
            tags.tagtype[42113] = 2 #ascii
            
        # finally save the file using tiffinfo headers
        img = combine_bands(bands)
        img.save(filepath, tiffinfo=tags)</pre></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec16"/>File format not supported</h3></div></div></div><p>These are the only<a id="id88" class="indexterm"/> raster file formats we allow saving to for now:</p><div><pre class="programlisting">    else:
        raise Exception("Could not save the raster to the given filepath: the filetype extension is either missing or not supported") </pre></div></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Summary</h1></div></div></div><p>In this chapter, we built the core foundation of our application. In each of our <code class="literal">vector</code> and <code class="literal">raster</code> folders, we created three new modules that allow us to access, edit, and share some popular geographic data formats. Our folder structure should, therefore, look something like this:</p><div><img src="img/5407OS_02_04.jpg" alt="Summary"/></div><p>This is the minimum we will need for any type of GIS application. We can theoretically, at this point, make a minimalistic application focused only on loading and handling file formats. In the next chapter, we jump straight into making the visual interface application, so we can have a real interactive application up and running as soon as possible.</p></div></div>
</body></html>