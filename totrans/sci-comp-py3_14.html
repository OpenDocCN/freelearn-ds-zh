<html><head></head><body><div class="chapter" title="Chapter&#xA0;14.&#xA0;Comprehensive Examples"><div class="titlepage"><div><div><h1 class="title"><a id="ch14"/>Chapter 14. Comprehensive Examples</h1></div></div></div><p>In this chapter, we present some comprehensive and longer examples together with a brief introduction to the theoretical background and their complete implementation. By this, we want to show you how the concepts defined in this book are used in practice.</p><div class="section" title="Polynomials"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec111"/>Polynomials</h1></div></div></div><p>First, we will demonstrate the power of the Python constructs presented so far by designing a class for polynomials. We will give some theoretical background, which leads us to a list of requirements, and then we will give the code, with some comments.</p><p>Note, this class differs conceptually from the class <code class="literal">numpy.poly1d</code>.</p><div class="section" title="Theoretical background"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec128"/>Theoretical background</h2></div></div></div><p>A polynomial: <span class="emphasis"><em>p</em></span>(<span class="emphasis"><em>x</em></span>)<span class="emphasis"><em> = a<sub>n </sub>x <sup>n</sup> + a<sub>n-1 </sub>x<sup>n-1</sup></em></span>+…+ <span class="emphasis"><em>a</em></span><sub>1</sub><span class="emphasis"><em>x + a</em></span><sub>0 </sub>is defined by its degree, its representation, and its coefficients. The polynomial representation shown in the preceding equation is called a monomial representation. In this representation, the polynomial is written as a linear combination of monomials, <span class="emphasis"><em>x<sup>i</sup></em></span>. Alternatively, the polynomial can be written in:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Newton representation with the coefficients <span class="emphasis"><em>c<sub>i</sub></em></span> and <span class="emphasis"><em>n</em></span> points, <span class="emphasis"><em>x<sub>0</sub></em></span>, …, <span class="emphasis"><em>x<sub>n-1</sub></em></span>:<p><span class="emphasis"><em>p</em></span>(<span class="emphasis"><em>x</em></span>)<span class="emphasis"><em> = c</em></span><sub>0</sub> +<span class="emphasis"><em> c</em></span><sub>1 </sub>(<span class="emphasis"><em>x - x</em></span><sub>0</sub>)<span class="emphasis"><em> + c</em></span><sub>2 </sub>(<span class="emphasis"><em>x - x</em></span><sub>0</sub>)(<span class="emphasis"><em>x-x</em></span><sub>1</sub>) + ... +<span class="emphasis"><em> c<sub>n</sub></em></span>(<span class="emphasis"><em>x - x<sub>0</sub></em></span>) … (<span class="emphasis"><em>x - x<sub>n</sub></em></span><sub>-1</sub>)</p></li><li class="listitem" style="list-style-type: disc">Lagrange representation with the coefficients <span class="emphasis"><em>y<sub>i</sub></em></span><sub> </sub>and <span class="emphasis"><em>n</em></span>+1 points, <span class="emphasis"><em>x</em></span><sub>0</sub>, … , <span class="emphasis"><em>x<sub>n</sub></em></span>:<p>                   <span class="emphasis"><em>p</em></span>(<span class="emphasis"><em>x</em></span>) =<span class="emphasis"><em> y</em></span><sub>0 </sub><span class="emphasis"><em>l</em></span><sub>0</sub>(<span class="emphasis"><em>x</em></span>) +<span class="emphasis"><em> y</em></span><sub>1 </sub><span class="emphasis"><em>l</em></span><sub>1</sub>(<span class="emphasis"><em>x</em></span>) + … +<span class="emphasis"><em> y<sub>n </sub>l<sub>n</sub></em></span>(<span class="emphasis"><em>x</em></span>)</p><p>with the cardinal functions:</p><p>               </p><div class="mediaobject"><img src="graphics/B05511_14_01.jpg" alt="Theoretical background"/></div><p>
</p></li></ul></div><p>There are infinitely many representations, but we restrict ourselves here to these three typical ones.</p><p>A polynomial can be determined from interpolation conditions:</p><p>
<span class="emphasis"><em>p</em></span>(<span class="emphasis"><em>x<sub>i</sub></em></span>) =<span class="emphasis"><em> y</em></span><sub>i</sub><span class="emphasis"><em>    i </em></span>= 0, … ,<span class="emphasis"><em> n</em></span>
</p><p>with the given distinct values <span class="emphasis"><em>x<sub>i</sub></em></span> and arbitrary values <span class="emphasis"><em>y<sub>i</sub></em></span> as input. In the Lagrange formulation, the interpolation polynomial is directly available, as its coefficients are the interpolation data. The coefficients for the interpolation polynomial in Newton representation can be obtained by a recursion formula, called the divided differences formula:</p><p><span class="emphasis"><em>c<sub>i</sub></em></span><sub>,0</sub> =<span class="emphasis"><em> y<sub>i,</sub></em></span><sub><span class="emphasis"><em>          </em></span></sub>and</p><p>
<span class="inlinemediaobject"><img src="graphics/B05511_14.jpg" alt="Theoretical background"/></span>.</p><p>Finally, one sets <span class="inlinemediaobject"><img src="graphics/cic0.jpg" alt="Theoretical background"/></span>.</p><p>The coefficients of the interpolation polynomial in monomial representation are obtained by solving a linear system:</p><p>
</p><div class="mediaobject"><img src="graphics/B05511_14_03.jpg" alt="Theoretical background"/></div><p>
</p><p>A matrix that has a given polynomial <span class="emphasis"><em>p</em></span> (or a multiple of it) as its characteristic polynomial is called a companion matrix. The eigenvalues of the companion matrix are the zeros (roots) of the polynomial. An algorithm for computing the zeros of <span class="emphasis"><em>p</em></span> can be constructed by first setting up its companion matrix and then computing the eigenvalues with <code class="literal">eig</code>. The companion matrix for a polynomial in Newton representation reads as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/B05511_14_04.jpg" alt="Theoretical background"/></div><p>
</p></div><div class="section" title="Tasks"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec129"/>Tasks</h2></div></div></div><p>We can now formulate some programming tasks:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Write a class called <code class="literal">PolyNomial</code> with the <code class="literal">points</code>, <code class="literal">degree</code>, <code class="literal">coeff</code>, and <code class="literal">basis</code> attributes, where:
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">points</code> is a list of tuples (<span class="emphasis"><em>x<sub>i</sub>, y<sub>i</sub></em></span>)</li><li class="listitem" style="list-style-type: disc"><code class="literal">degree</code> is the degree of the corresponding interpolation polynomial</li><li class="listitem" style="list-style-type: disc"><code class="literal">coeff</code> contains the polynomial coefficients</li><li class="listitem" style="list-style-type: disc"><code class="literal">basis</code> is a string stating which representation is used</li></ul></div></li><li class="listitem">Provide the class with a method for evaluating the polynomial at a given point.</li><li class="listitem">Provide the class with a method called <code class="literal">plot</code> that plots the polynomial over a given interval.</li><li class="listitem">Write a method called <code class="literal">__add__</code> that returns a polynomial that is the sum of two polynomials. Be aware that only in the monomial case the sum can be computed by just summing up the coefficients.</li><li class="listitem">Write a method that computes the coefficients of the polynomial represented in a monomial form.</li><li class="listitem">Write a method that computes the polynomial's companion matrix.</li><li class="listitem">Write a method that computes the zeros of the polynomial by computing the eigenvalues of the companion matrix.</li><li class="listitem">Write a method that computes the polynomial that is the <span class="emphasis"><em>i</em></span><sup>th</sup> derivative of the given polynomial.</li><li class="listitem">Write a method that checks whether two polynomials are equal. Equality can be checked by comparing all coefficients (zero leading coefficients should not matter).</li></ol></div></div></div></div>
<div class="section" title="The polynomial class"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec112"/>The polynomial class</h1></div></div></div><p>Let's now design a polynomial base class based on a monomial formulation of the polynomial. The polynomial can be initialized either by giving its coefficients with respect to the monomial basis or by giving a list of interpolation points, as follows:</p><pre class="programlisting">import scipy.linalg as sl&#13;
&#13;
class PolyNomial:&#13;
    base='monomial'&#13;
    def __init__(self,**args):&#13;
        if 'points' in args:&#13;
            self.points = array(args['points'])&#13;
            self.xi = self.points[:,0]&#13;
            self.coeff = self.point_2_coeff()&#13;
            self.degree = len(self.coeff)-1&#13;
        elif 'coeff' in args:&#13;
            self.coeff = array(args['coeff'])&#13;
            self.degree = len(self.coeff)-1&#13;
            self.points = self.coeff_2_point()&#13;
        else:&#13;
            self.points = array([[0,0]])&#13;
            self.xi = array([1.])&#13;
            self.coeff = self.point_2_coeff()&#13;
            self.degree = 0</pre><p>The <code class="literal">__init__</code> method of the new class uses the <code class="literal">**args</code> construction as discussed in section <span class="emphasis"><em>Parameters and arguments</em></span> in <a class="link" href="ch07.html" title="Chapter 7. Functions">Chapter 7</a>, <span class="emphasis"><em>Functions</em></span>. If no arguments are given, a zero polynomial is assumed. If the polynomial is given by interpolation points the method used to compute the coefficients by solving a Vandermonde system is given as follows:</p><pre class="programlisting">def point_2_coeff(self):&#13;
    return sl.solve(vander(self.x),self.y)</pre><p>If <span class="emphasis"><em>k</em></span> coefficients are given also <span class="emphasis"><em>k</em></span> interpolation points are constructed by:</p><pre class="programlisting">def coeff_2_point(self):&#13;
    points = [[x,self(x)] for x in linspace(0,1,self.degree+1)]&#13;
    return array(points)</pre><p>The <code class="literal">self(x)</code> command does a polynomial evaluation, which is done by providing a  method, <code class="literal">__call__</code>:</p><pre class="programlisting">def __call__(self,x):&#13;
    return polyval(self.coeff,x)</pre><p>(Refer example in section <span class="emphasis"><em>Special methods</em></span> in <a class="link" href="ch08.html" title="Chapter 8. Classes">Chapter 8</a>, <span class="emphasis"><em>Classes.</em></span>) Here, this method uses the command <code class="literal">polyval</code>. As a next step, we just add for convenience two methods, which we decorate with the <code class="literal">property</code> decorator (refer section <span class="emphasis"><em>Functions as decorators</em></span> in <a class="link" href="ch07.html" title="Chapter 7. Functions">Chapter 7</a>, <span class="emphasis"><em>Functions)</em></span>:</p><pre class="programlisting">@property&#13;
def x(self):&#13;
    return self.points[:,0]&#13;
@property&#13;
def y(self):&#13;
    return self.points[:,1]</pre><p>Let's explain what is going on here. We define a method to extract the <span class="emphasis"><em>x</em></span>-values of the data, which were used to define the polynomial. Similarly, a method to extract the <span class="emphasis"><em>y</em></span>-values of the data is defined. With the <code class="literal">property</code> decorator, the result of calling the method is presented as if it were just an attribute of the polynomial. There are two coding alternatives:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We use a method call:<pre class="programlisting">      def x(self):&#13;
          return self.interppoints[:,0]</pre><p>This gives access to the <span class="emphasis"><em>x</em></span>-values by the call: <code class="literal">p.x()</code>.</p></li><li class="listitem">We use the <code class="literal">property</code> decorator. It us to access the <span class="emphasis"><em>x</em></span>-values simply by this statement:  <code class="literal">p.x</code></li></ol></div><p>We choose the second variant. It is always a good practice to define a <code class="literal">__repr__</code> method (refer section <span class="emphasis"><em>Attributes</em></span> in <a class="link" href="ch08.html" title="Chapter 8. Classes">Chapter 8</a>, <span class="emphasis"><em>Classes</em></span>). At least for a quick check of the results, this method is useful:</p><pre class="programlisting">def __repr__(self):&#13;
    txt  = 'Polynomial of degree {degree} \n'&#13;
    txt += 'with coefficients {coeff} \n in {base} basis.'&#13;
    return txt.format(coeff=self.coeff, degree=self.degree,&#13;
                                            base=self.base)</pre><p>We now provide a method for plotting the polynomial, as follows:</p><pre class="programlisting">margin = .05&#13;
plotres = 500&#13;
def plot(self,ab=None,plotinterp=True):&#13;
    if ab is None: # guess a and b&#13;
       x = self.x&#13;
       a, b = x.min(), x.max()&#13;
       h = b-a&#13;
       a -= self.margin*h&#13;
       b += self.margin*h&#13;
    else:&#13;
       a,b = ab&#13;
    x = linspace(a,b,self.plotres)&#13;
    y = vectorize(self.__call__)(x)&#13;
    plot(x,y)&#13;
    xlabel('$x$')&#13;
    ylabel('$p(x)$')&#13;
    if plotinterp:&#13;
        plot(self.x, self.y, 'ro')</pre><p>Note the use of the <code class="literal">vectorize</code> command (refer section <span class="emphasis"><em>Functions acting on arrays </em></span>in <a class="link" href="ch04.html" title="Chapter 4. Linear Algebra – Arrays">Chapter 4</a>, <span class="emphasis"><em>Linear algebra - Arrays</em></span>. The <code class="literal">__call__</code> method is specific to the monomial representation and has to be changed if a polynomial is represented in another basis. This is also the case for the computation of the polynomial's companion matrix:</p><pre class="programlisting">def companion(self):&#13;
    companion = eye(self.degree, k=-1)&#13;
    companion[0,:] -= self.coeff[1:]/self.coeff[0]&#13;
    return companion</pre><p>Once the companion matrix is available, the zeros of the polynomial are given by the eigenvalues:</p><pre class="programlisting">def zeros(self):&#13;
   companion = self.companion()&#13;
   return sl.eigvals(companion)</pre><p>For this end the function <code class="literal">eigvals</code> has to be imported from <code class="literal">scipy.linalg</code> first. Let's give some usage examples.</p><p>First, we create a polynomial instance from the given interpolation points:</p><pre class="programlisting">p = PolyNomial(points=[(1,0),(2,3),(3,8)])</pre><p>The polynomial's coefficients with respect to the monomial basis are available as an attribute of <code class="literal">p</code>:</p><pre class="programlisting">p.coeff # returns array([ 1., 0., -1.])</pre><p>This corresponds to the polynomial <span class="inlinemediaobject"><img src="graphics/B05511_14_1.jpg" alt="The polynomial class"/></span> . The default plot of the polynomial, obtained by <code class="literal">p.plot(-3.5,3.5)</code>, results in the following figure (<span class="emphasis"><em>Figure 14.1</em></span>):</p><p>
</p><div class="mediaobject"><img src="graphics/polyplot.jpg" alt="The polynomial class"/></div><p>
</p><p>Figure 14.1: Result of the polynomial plot method</p><p>Finally, we compute the zeros of the polynomial, which in this case are two real numbers:</p><pre class="programlisting">pz = p.zeros() # returns array([-1.+0.j, 1.+0.j])</pre><p>The result can be verified by evaluating the polynomial at these points:</p><pre class="programlisting">p(pz) # returns array([0.+0.j, 0.+0.j])</pre></div>
<div class="section" title="Newton polynomial"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec113"/>Newton polynomial</h1></div></div></div><p>The <code class="literal">NewtonPolyNomial</code> class defines a polynomial described with respect to the Newton basis. We let it inherit some common methods from the polynomial base class, for example, <code class="literal">polynomial.plot</code>, <code class="literal">polynomial.zeros</code>, and even parts of the <code class="literal">__init__</code> method, by using the <code class="literal">super</code> command (refer to section <span class="emphasis"><em>Subclassing and Inheritance</em></span> in <a class="link" href="ch08.html" title="Chapter 8. Classes">Chapter 8</a>, <span class="emphasis"><em>Classes</em></span>):</p><pre class="programlisting">class NewtonPolynomial(PolyNomial):&#13;
    base = 'Newton'&#13;
    def __init__(self,**args):&#13;
        if 'coeff' in args:&#13;
            try:&#13;
                self.xi = array(args['xi'])&#13;
            except KeyError: &#13;
                raise ValueError('Coefficients need to be given'&#13;
                'together with abscissae values xi')&#13;
        super(NewtonPolynomial, self).__init__(**args)</pre><p>Once the interpolation points are given, the computation of the coefficients is performed by:</p><pre class="programlisting">def point_2_coeff(self):&#13;
    return array(list(self.divdiff()))</pre><p>Here we used divided differences for computing the Newton representation of the polynomial, which is programmed as a generator here:</p><pre class="programlisting">def divdiff(self): &#13;
    xi = self.xi&#13;
    row = self.y&#13;
    yield row[0]&#13;
    for level in range(1,len(xi)):&#13;
        row = (row[1:] - row[:-1])/(xi[level:] - xi[:-level])&#13;
        if allclose(row,0): # check: elements of row nearly zero&#13;
           self.degree = level-1&#13;
           break&#13;
        yield row[0]</pre><p>Let us briefly check how this works:</p><pre class="programlisting">pts = array([[0.,0],[.5,1],[1.,0],[2,0.]]) # here we define the&#13;
  interpolation data: (x,y) pairs&#13;
pN = NewtonPolynomial(points=pts) # this creates an instance of the&#13;
  polynomial class&#13;
pN.coeff # returns the coefficients array([ 0. , 2. , -4. ,&#13;
  2.66666667])&#13;
print(pN)</pre><p>The <code class="literal">print</code> function executes the <code class="literal">__repr__</code> method of the base class and returns the following text:</p><pre class="programlisting">Polynomial of degree 3&#13;
 with coefficients [ 0.     2.    -4.      2.66666667]&#13;
 in Newton basis.</pre><p>The polynomial evaluation is different from the corresponding method of the base class. The <code class="literal">Newton.PolyNomial.__call__</code> method needs to override <code class="literal">Polynomial.__call__</code>:</p><pre class="programlisting">def __call__(self,x):&#13;
    # first compute the sequence 1, (x-x_1), (x-x_1)(x-x_2),...&#13;
    nps = hstack([1., cumprod(x-self.xi[:self.degree])])&#13;
    return dot(self.coeff, nps)</pre><p>Finally, we give the code for the companion matrix, which overrides the corresponding method of the parent class, as follows:</p><pre class="programlisting">def companion(self):&#13;
    degree = self.degree&#13;
    companion = eye(degree, k=-1)&#13;
    diagonal = identity(degree,dtype=bool)&#13;
    companion[diagonal] = self.x[:degree]&#13;
    companion[:,-1] -= self.coeff[:degree]/self.coeff[degree]&#13;
    return companion</pre><p>Note the use of Boolean arrays. The exercises will further build on this foundation.</p></div>
<div class="section" title="Spectral clustering"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec114"/>Spectral clustering</h1></div></div></div><p>An interesting application of eigenvectors is for clustering data. Using the eigenvectors of a matrix derived from a distance matrix, unlabelled data can be separated into groups. Spectral clustering methods get their name from the use of the spectrum of this matrix. A distance matrix for <span class="emphasis"><em>n</em></span> elements (for example, the pairwise distance between data points) is an n × n symmetric matrix. Given such an n × n distance matrix <span class="emphasis"><em>M</em></span> with distance values <span class="emphasis"><em>m<sub>ij</sub></em></span>, we can create the Laplacian matrix of the data points as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/distance-1.jpg" alt="Spectral clustering"/></div><p>
</p><p>Here, I is the identity matrix and <span class="emphasis"><em>D</em></span> is the diagonal matrix containing the row sums of <span class="emphasis"><em>M</em></span>,</p><p> </p><div class="mediaobject"><img src="graphics/B05511_14_2.jpg" alt="Spectral clustering"/></div><p>
</p><p>The data clusters are obtained from the eigenvectors of <span class="emphasis"><em>L</em></span>. In the simplest case of data points with only two classes, the first eigenvector (that is, the one corresponding to the largest eigenvalue) is often enough to separate the data.</p><p>Here is an example for simple two-class clustering. The following code creates some 2D data points and clusters them based on the first eigenvector of the Laplacian matrix:</p><pre class="programlisting">import scipy.linalg as sl&#13;
&#13;
# create some data points&#13;
n = 100&#13;
x1 = 1.2 * random.randn(n, 2)&#13;
x2 = 0.8 * random.randn(n, 2) + tile([7, 0],(n, 1))&#13;
x = vstack((x1, x2))&#13;
&#13;
# pairwise distance matrix&#13;
M = array([[ sqrt(sum((x[i] - x[j])**2)) &#13;
                                  for i in range(2*n)]          &#13;
                                    for j in range(2 * n)])&#13;
 &#13;
# create the Laplacian matrix&#13;
D = diag(1 / sqrt( M.sum(axis = 0) ))&#13;
L = identity(2 * n) - dot(D, dot(M, D))&#13;
&#13;
# compute eigenvectors of L&#13;
S, V = sl.eig(L)&#13;
# As L is symmetric the imaginary parts&#13;
# in the eigenvalues are only due to negligible numerical errors S=S.real&#13;
V=V.real</pre><p>The eigenvector corresponding to the largest eigenvalue gives the grouping (for example, by thresholding at <span class="emphasis"><em>0</em></span>) and can be shown with:</p><pre class="programlisting">largest=abs(S).argmax()&#13;
plot(V[:,largest])</pre><p>The following figure (<span class="emphasis"><em>Figure 14.2</em></span>) shows the result of spectral clustering of a simple two-class dataset:</p><p>
</p><div class="mediaobject"><img src="graphics/cluster1.jpg" alt="Spectral clustering"/></div><p>
</p><p>Figure 14.2: shows result of simple two-class clustering</p><p>For more difficult datasets and more classes, one usually takes the <span class="emphasis"><em>k</em></span> eigenvectors corresponding to the <span class="emphasis"><em>k</em></span> largest eigenvalues and then clusters the data with some other method, but using the eigenvectors instead of the original data points. A common choice is the <span class="emphasis"><em>k</em></span>-means clustering algorithm, which is the topic of the next example:</p><p>The eigenvectors are used as input to <span class="emphasis"><em>k</em></span>-means clustering, as follows:</p><pre class="programlisting">import scipy.linalg as sl&#13;
import scipy.cluster.vq as sc&#13;
# simple 4 class data&#13;
x = random.rand(1000,2)&#13;
ndx = ((x[:,0] &lt; 0.4) | (x[:,0] &gt; 0.6)) &amp; &#13;
                     ((x[:,1] &lt; 0.4) | (x[:,1] &gt; 0.6))&#13;
x = x[ndx]&#13;
n = x.shape[0]&#13;
&#13;
# pairwise distance matrix&#13;
M = array([[ sqrt(sum((x[i]-x[j])**2)) for i in range(n) ]&#13;
                                       for j in range(n)])&#13;
&#13;
# create the Laplacian matrix&#13;
D = diag(1 / sqrt( M.sum(axis=0) ))&#13;
L = identity(n) - dot(D, dot(M, D))&#13;
&#13;
# compute eigenvectors of L&#13;
_,_,V = sl.svd(L)&#13;
&#13;
k = 4&#13;
# take k first eigenvectors&#13;
eigv = V[:k,:].T&#13;
&#13;
# k-means&#13;
centroids,dist = sc.kmeans(eigv,k)&#13;
clust_id = sc.vq(eigv,centroids)[0]</pre><p>Note that we computed the eigenvectors here using the singular value decomposition, <code class="literal">sl.svd</code>. As <span class="emphasis"><em>L</em></span> is symmetric, the result is the same as if we would have used <code class="literal">sl.eig</code>, but the eigenvectors come already ordered corresponding to the ordering of the eigenvalues. We also used throw-away variables. <code class="literal">svd</code> returns a list with three arrays, the left and right singular vectors <code class="literal">U</code>, <code class="literal">V</code>, and the singular values <code class="literal">S</code>, as follows:</p><pre class="programlisting">U, S, V = sl.svd(L)</pre><p>As we do not need <code class="literal">U</code> and <code class="literal">S</code> here, we can throw them away when unpacking the return value of <code class="literal">svd</code>:</p><pre class="programlisting">_, _, V = sl.svd(L)</pre><p>The result can be plotted using:</p><pre class="programlisting">for i in range(k):&#13;
    ndx = where(clust_id == i)[0]&#13;
    plot(x[ndx, 0], x[ndx, 1],'o')&#13;
axis('equal')</pre><p>The following figure shows the result of spectral clustering of a simple <span class="emphasis"><em>multiclass dataset:</em></span>
</p><p>
</p><div class="mediaobject"><img src="graphics/spectral_4class.jpg" alt="Spectral clustering"/></div><p>
</p><p>Figure 14.3: An example of spectral clustering of a simple four class dataset.</p></div>
<div class="section" title="Solving initial value problems"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec115"/>Solving initial value problems</h1></div></div></div><p>In this section, we will consider the mathematical task of numerically solving a system of ordinary equations for given initial values:</p><p>
<span class="emphasis"><em>y'</em></span>(<span class="emphasis"><em>t</em></span>)<span class="emphasis"><em> = f</em></span>(<span class="emphasis"><em>t, y</em></span>)<span class="emphasis"><em>      y</em></span>(<span class="emphasis"><em>t</em></span><sub>0</sub>)<span class="emphasis"><em> = y</em></span><sub>0</sub>∈ ℝ<span class="emphasis"><em><sup>n</sup></em></span>
</p><p>The solution of this problem is a function <span class="emphasis"><em>y</em></span>. A numerical method aims at computing good approximations, <span class="emphasis"><em>y<sub>i</sub></em></span>≈<span class="emphasis"><em> y</em></span>(<span class="emphasis"><em>t<sub>i</sub></em></span>) at discrete points, the communications points <span class="emphasis"><em>t<sub>i</sub></em></span>, within the interval of interest [<span class="emphasis"><em>t<sub>0</sub>, t</em></span><sub>e</sub>]. We collect the data that describes the problem in a class, as follows:</p><pre class="programlisting">class IV_Problem:&#13;
    """&#13;
    Initial value problem (IVP) class&#13;
    """&#13;
    def __init__(self, rhs, y0, interval, name='IVP'):&#13;
        """&#13;
        rhs 'right hand side' function of the ordinary differential&#13;
                                                   equation f(t,y)&#13;
        y0 array with initial values&#13;
        interval start and end value of the interval of independent&#13;
        variables often initial and end time&#13;
        name descriptive name of the problem&#13;
        """&#13;
        self.rhs = rhs&#13;
        self.y0 = y0&#13;
        self.t0, self.tend = interval&#13;
        self.name = name</pre><p>The differential equation:</p><p>
</p><div class="mediaobject"><img src="graphics/B05511_14_06.jpg" alt="Solving initial value problems"/></div><p>
</p><p>describes a mathematical pendulum; <span class="emphasis"><em>y<sub>1</sub></em></span> describes its angle with respect to the vertical axis, <span class="emphasis"><em>g</em></span> is the gravitation constant, and <span class="emphasis"><em>l</em></span> is its length. The initial angle is π/2 and the initial angular velocity is zero.</p><p>The pendulum problem becomes an instance of the problem class, as follows:</p><pre class="programlisting">def rhs(t,y):&#13;
    g = 9.81&#13;
    l = 1.&#13;
    yprime = array([y[1], g / l * sin(y[0])])&#13;
    return yprime&#13;
 &#13;
pendulum = IV_Problem(rhs, array([pi / 2, 0.]), [0., 10.] ,&#13;
                                            'mathem. pendulum')</pre><p>There might be different views on the problem at hand, leading to a different design of the class. For example, one might want to consider the interval of independent variables as a part of a solution process instead of the problem definition. The same holds when considering initial values. They might, as we did here, be considered a part of the mathematical problem, while other authors might want to allow variation of initial values by putting them as a part of the solution process.</p><p>The solution process is modeled as another class:</p><pre class="programlisting">class IVPsolver:&#13;
    """&#13;
    IVP solver class for explicit one-step discretization methods&#13;
    with constant step size&#13;
    """&#13;
    def __init__(self, problem, discretization, stepsize):&#13;
        self.problem = problem&#13;
        self.discretization = discretization&#13;
        self.stepsize = stepsize&#13;
    def one_stepper(self):&#13;
        yield self.problem.t0, self.problem.y0&#13;
        ys = self.problem.y0&#13;
        ts = self.problem.t0&#13;
        while ts &lt;= self.problem.tend:&#13;
            ts, ys = self.discretization(self.problem.rhs, ts, ys,&#13;
                                                self.stepsize)&#13;
            yield ts, ys&#13;
    def solve(self):&#13;
        return list(self.one_stepper())</pre><p>We continue by first defining two discretization schemes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Explicit <span class="strong"><strong>Euler</strong></span> method:</li></ul></div><pre class="programlisting">      def expliciteuler(rhs, ts, ys, h):&#13;
          return ts + h, ys + h * rhs(ts, ys)</pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Classical <span class="strong"><strong>Runge-Kutta four-stage</strong></span> method (<span class="strong"><strong>RK4</strong></span>):</li></ul></div><pre class="programlisting">      def rungekutta4(rhs, ts, ys, h):&#13;
          k1 = h * rhs(ts, ys)&#13;
          k2 = h * rhs(ts + h/2., ys + k1/2.) &#13;
          k3 = h * rhs(ts + h/2., ys + k2/2.)&#13;
          k4 = h * rhs(ts + h, ys +  k3)&#13;
          return ts + h, ys + (k1 + 2*k2 + 2*k3 + k4)/6.</pre><p>With these, we can create instances to obtain the corresponding discretized versions of the pendulum ODE:</p><pre class="programlisting">pendulum_Euler = IVPsolver(pendulum, expliciteuler, 0.001) &#13;
pendulum_RK4 = IVPsolver(pendulum, rungekutta4, 0.001)</pre><p>We can solve the two discrete models and plot the solution and the angle difference:</p><pre class="programlisting">sol_Euler = pendulum_Euler.solve()&#13;
sol_RK4 = pendulum_RK4.solve()&#13;
tEuler, yEuler = zip(*sol_Euler)&#13;
tRK4, yRK4 = zip(*sol_RK4)&#13;
subplot(1,2,1), plot(tEuler,yEuler),\&#13;
       title('Pendulum result with Explicit Euler'),\&#13;
       xlabel('Time'), ylabel('Angle and angular velocity')&#13;
subplot(1,2,2), plot(tRK4,abs(array(yRK4)-array(yEuler))),\&#13;
       title('Difference between both methods'),\&#13;
       xlabel('Time'), ylabel('Angle and angular velocity')</pre><p>
</p><div class="mediaobject"><img src="graphics/ivp_example.jpg" alt="Solving initial value problems"/></div><p>
</p><p>Figure14.4: Pendulum simulation with the explicit Euler method and comparison with the results of the more accurate Runge–Kutta 4 method</p><p>It is worthwhile discussing alternative class designs. What should be put in separate classes, what should be bundled into the same class?</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We strictly separated the mathematical problem from the numerical method. Where should the initial values go? Should they be part of the problem or part of the solver? Or should they be left as input parameter for the solve method of the solver instance? One might even design the program so that it allows several possibilities. The decision to use one of these alternatives depends on the future use of this program. Looping over various initial values as in parameter identification would be eased by leaving the initial values as input parameters for the solve method. On the other hand, simulating different model variants with the same initial values would motivate to couple the initial values to the problem.</li><li class="listitem" style="list-style-type: disc">We presented for simplicity only solvers with constant and given step size. Is the design of the <code class="literal">IVPsolver</code> class appropriate for a future extension of adaptive methods, where a tolerance rather than a step size is given?</li><li class="listitem" style="list-style-type: disc">We suggested earlier to use a generator construction for the stepping mechanism. Adaptive methods need to reject steps from time to time. Is this need conflicting with the design of the stepping mechanism in <code class="literal">IVPsolver.onestepper</code>?</li><li class="listitem" style="list-style-type: disc">We encourage you to check the design of the two SciPy tools for solving initial values, namely <code class="literal">scipy.integrate.ode</code> and <code class="literal">scipy.integrate.odeint</code>.</li></ul></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec116"/>Summary</h1></div></div></div><p>Most of what we explained in this book is bundled into the three longer examples of this chapter. They mimic code development and give prototypes, which you are encouraged to alter and confront with your own ideas.</p><p>You saw that code in scientific computing can have its own flavor due to its strong relation with mathematically defined algorithms and that it is often wise to keep the relationship between code and formula visible. Python has techniques for this, as you have seen.</p></div>
<div class="section" title="Exercises"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec117"/>Exercises</h1></div></div></div><p>
<span class="strong"><strong>Ex. 1</strong></span> → Implement a method <code class="literal">__add__</code>, which constructs a new polynomial <span class="emphasis"><em>p+q</em></span> by adding two given polynomials <span class="emphasis"><em>p</em></span> and <span class="emphasis"><em>q</em></span>. In monomial form, polynomials are added by just adding the coefficients, whereas in Newton form, the coefficients depend on the abscissa <span class="emphasis"><em>x<sub>i</sub></em></span> of the interpolation points. Before adding the coefficients of both polynomials, the polynomial <span class="emphasis"><em>q</em></span> has to get new interpolation points with the property that their abscissa <span class="emphasis"><em>x<sub>i</sub></em></span> coincides with those of <span class="emphasis"><em>p</em></span> and the method <code class="literal">__changepoints__</code> has to be provided for that. It should change the interpolation points and return a new set of coefficients.</p><p>
<span class="strong"><strong>Ex. 2</strong></span> → Write conversion methods to convert a polynomial from Newton form into monomial form and vice versa.</p><p>
<span class="strong"><strong>Ex. 3</strong></span> → Write a method called <code class="literal">add_point</code> that takes a polynomial <span class="emphasis"><em>q</em></span> and a tuple <span class="emphasis"><em>(x,y)</em></span> as parameters and returns a new polynomial that interpolates <code class="literal">self.points</code> and <span class="emphasis"><em>(x,y)</em></span>.</p><p>
<span class="strong"><strong>Ex. 4</strong></span> → Write a class called <code class="literal">LagrangePolynomial</code> that implements polynomials in Lagrange form and inherits as much as possible from the polynomial base class.</p><p>
<span class="strong"><strong>Ex. 5</strong></span> → Write tests for the polynomial class.</p></div></body></html>